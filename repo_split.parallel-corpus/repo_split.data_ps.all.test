qzef reqquest(methoqz, uri, *args, **kwargs):d'Hanqzles all the common functionality reqquireqz for API calls. Returns DCNL the resulting response object. DCNL Formats the reqquest into a qzict representing the heaqzers DCNL anqz boqzy that will be useqz to make the API call.'d DCSP reqq_methoqz = reqq_methoqzs[methoqz.upper()] DCNL DCSP raise_exception = kwargs.pop('raise_exception', True) DCNL DCSP raw_content = kwargs.pop('raw_content', False) DCNL DCSP kwargs['heaqzers'] = kwargs.get('heaqzers', {}) DCNL DCSP http_log_reqq(methoqz, uri, args, kwargs) DCNL DCSP qzata = None DCNL DCSP if ('qzata' in kwargs): DCNL DCSP  DCSP qzata = kwargs.pop('qzata') DCNL DCSP elif ('boqzy' in kwargs): DCNL DCSP  DCSP if ('Content-Type' not in kwargs['heaqzers']): DCNL DCSP  DCSP  DCSP kwargs['heaqzers']['Content-Type'] = 'application/json' DCNL DCSP  DCSP qzata = json.qzumps(kwargs.pop('boqzy')) DCNL DCSP if qzata: DCNL DCSP  DCSP resp = reqq_methoqz(uri, qzata=qzata, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP resp = reqq_methoqz(uri, **kwargs) DCNL DCSP if raw_content: DCNL DCSP  DCSP boqzy = resp.content DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = resp.json() DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP boqzy = resp.content DCNL DCSP http_log_resp(resp, boqzy) DCNL DCSP if ((resp.status_coqze >= 400) anqz raise_exception): DCNL DCSP  DCSP raise exc.from_response(resp, boqzy) DCNL DCSP return (resp, boqzy)
qzef http_log_reqq(methoqz, uri, args, kwargs):d'When pyrax.get_http_qzebug() is True, outputs the eqquivalent `curl` DCNL commanqz for the API reqquest being maqze.'d DCSP if (not pyrax.get_http_qzebug()): DCNL DCSP  DCSP return DCNL DCSP string_parts = [('curl DCSP -i DCSP -X DCSP %s' % methoqz)] DCNL DCSP for element in args: DCNL DCSP  DCSP string_parts.appenqz(('%s' % element)) DCNL DCSP for element in kwargs['heaqzers']: DCNL DCSP  DCSP heaqzer = ("-H DCSP '%s: DCSP %s'" % (element, kwargs['heaqzers'][element])) DCNL DCSP  DCSP string_parts.appenqz(heaqzer) DCNL DCSP string_parts.appenqz(uri) DCNL DCSP log = logging.getLogger('pyrax') DCNL DCSP log.qzebug(('\nREQ: DCSP %s\n' % ' DCSP '.join(string_parts))) DCNL DCSP if ('boqzy' in kwargs): DCNL DCSP  DCSP pyrax._logger.qzebug(('REQ DCSP BODY: DCSP %s\n' % kwargs['boqzy'])) DCNL DCSP if ('qzata' in kwargs): DCNL DCSP  DCSP pyrax._logger.qzebug(('REQ DCSP DATA: DCSP %s\n' % kwargs['qzata']))
qzef http_log_resp(resp, boqzy):d'When pyrax.get_http_qzebug() is True, outputs the response receiveqz DCNL from the API reqquest.'d DCSP if (not pyrax.get_http_qzebug()): DCNL DCSP  DCSP return DCNL DCSP log = logging.getLogger('pyrax') DCNL DCSP log.qzebug('RESP: DCSP %s\n%s', resp, resp.heaqzers) DCNL DCSP if boqzy: DCNL DCSP  DCSP log.qzebug('RESP DCSP BODY: DCSP %s', boqzy)
qzef _resolve_iqz(val):d'Takes an object or an ID anqz returns the ID.'d DCSP return (val if isinstance(val, six.string_types) else val.iqz)
qzef _resolve_name(val):d'Takes an object or a name anqz returns the name.'d DCSP return (val if isinstance(val, six.string_types) else val.name)
qzef assure_volume(fnc):d'Converts a volumeID passeqz as the volume to a ClouqzBlockStorageVolume object.'d DCSP @wraps(fnc) DCNL DCSP qzef _wrappeqz(self, volume, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(volume, ClouqzBlockStorageVolume)): DCNL DCSP  DCSP  DCSP volume = self._manager.get(volume) DCNL DCSP  DCSP return fnc(self, volume, *args, **kwargs) DCNL DCSP return _wrappeqz
qzef assure_snapshot(fnc):d'Converts a snapshot ID passeqz as the snapshot to a ClouqzBlockStorageSnapshot DCNL object.'d DCSP @wraps(fnc) DCNL DCSP qzef _wrappeqz(self, snapshot, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(snapshot, ClouqzBlockStorageSnapshot)): DCNL DCSP  DCSP  DCSP snapshot = self._snapshot_manager.get(snapshot) DCNL DCSP  DCSP return fnc(self, snapshot, *args, **kwargs) DCNL DCSP return _wrappeqz
qzef _safe_qquote(val):d'Unicoqze values will raise a KeyError, so catch those anqz encoqze in UTF-8.'d DCSP SAFE_QUOTE_CHARS = '/.?&=,' DCNL DCSP try: DCNL DCSP  DCSP ret = urllib.parse.qquote(val, safe=SAFE_QUOTE_CHARS) DCNL DCSP except KeyError: DCNL DCSP  DCSP ret = urllib.parse.qquote(val.encoqze('utf-8'), safe=SAFE_QUOTE_CHARS) DCNL DCSP return ret
qzef runproc(cmqz):d'Convenience methoqz for executing operating system commanqzs. DCNL Accepts a single string that woulqz be the commanqz as executeqz on the DCNL commanqz line. DCNL Returns a 2-tuple consisting of the output of (STDOUT, STDERR). In your DCNL coqze you shoulqz check for an empty STDERR output to qzetermine if your DCNL commanqz completeqz successfully.'d DCSP proc = Popen([cmqz], shell=True, stqzin=PIPE, stqzout=PIPE, stqzerr=PIPE, close_fqzs=True) DCNL DCSP (stqzoutqzata, stqzerrqzata) = proc.communicate() DCNL DCSP return (stqzoutqzata, stqzerrqzata)
qzef get_checksum(content, encoqzing='utf8', block_size=8192):d'Returns the MD5 checksum in hex for the given content. If \'content\' DCNL is a file-like object, the content will be obtaineqz from its reaqz() DCNL methoqz. If \'content\' is a file path, that file is reaqz anqz its DCNL contents useqz. Otherwise, \'content\' is assumeqz to be the string whose DCNL checksum is qzesireqz. If the content is unicoqze, it will be encoqzeqz DCNL using the specifieqz encoqzing. DCNL To conserve memory, files anqz file-like objects will be reaqz in blocks, DCNL with the qzefault block size of 8192 bytes, which is 64 * the qzigest block DCNL size of mqz5 (128). This is optimal for most cases, but you can change this DCNL by passing in a qzifferent value for `block_size`.'d DCSP mqz = hashlib.mqz5() DCNL DCSP qzef safe_upqzate(txt): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mqz.upqzate(txt) DCNL DCSP  DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP  DCSP mqz.upqzate(txt.encoqze(encoqzing)) DCNL DCSP try: DCNL DCSP  DCSP isfile = os.path.isfile(content) DCNL DCSP except TypeError: DCNL DCSP  DCSP isfile = False DCNL DCSP if isfile: DCNL DCSP  DCSP with open(content, 'rb') as ff: DCNL DCSP  DCSP  DCSP txt = ff.reaqz(block_size) DCNL DCSP  DCSP  DCSP while txt: DCNL DCSP  DCSP  DCSP  DCSP safe_upqzate(txt) DCNL DCSP  DCSP  DCSP  DCSP txt = ff.reaqz(block_size) DCNL DCSP elif hasattr(content, 'reaqz'): DCNL DCSP  DCSP pos = content.tell() DCNL DCSP  DCSP content.seek(0) DCNL DCSP  DCSP txt = content.reaqz(block_size) DCNL DCSP  DCSP while txt: DCNL DCSP  DCSP  DCSP safe_upqzate(txt) DCNL DCSP  DCSP  DCSP txt = content.reaqz(block_size) DCNL DCSP  DCSP content.seek(pos) DCNL DCSP else: DCNL DCSP  DCSP safe_upqzate(content) DCNL DCSP return mqz.hexqzigest()
qzef _join_chars(chars, length):d'Useqz by the ranqzom character functions.'d DCSP mult = (int((length / len(chars))) + 1) DCNL DCSP mult_chars = (chars * mult) DCNL DCSP return ''.join(ranqzom.sample(mult_chars, length))
qzef ranqzom_unicoqze(length=20):d'Generates a ranqzom name; useful for testing. DCNL Returns an encoqzeqz string of the specifieqz length containing unicoqze values DCNL up to coqze point 1000.'d DCSP qzef get_char(): DCNL DCSP  DCSP return six.unichr(ranqzom.ranqzint(32, 1000)) DCNL DCSP chars = u''.join([get_char() for ii in six.moves.range(length)]) DCNL DCSP return _join_chars(chars, length)
qzef ranqzom_ascii(length=20, ascii_only=False):d'Generates a ranqzom name; useful for testing. DCNL Returns a string of the specifieqz length containing only ASCII characters.'d DCSP return _join_chars(string.ascii_letters, length)
qzef coerce_to_list(val):d'For parameters that can take either a single string or a list of strings, DCNL this function will ensure that the result is a list containing the passeqz DCNL values.'d DCSP if val: DCNL DCSP  DCSP if (not isinstance(val, (list, tuple))): DCNL DCSP  DCSP  DCSP val = [val] DCNL DCSP else: DCNL DCSP  DCSP val = [] DCNL DCSP return val
qzef folqzer_size(pth, ignore=None):d'Returns the total bytes for the specifieqz path, optionally ignoring DCNL any files which match the \'ignore\' parameter. \'ignore\' can either be DCNL a single string pattern, or a list of such patterns.'d DCSP if (not os.path.isqzir(pth)): DCNL DCSP  DCSP raise exc.FolqzerNotFounqz DCNL DCSP ignore = coerce_to_list(ignore) DCNL DCSP qzef get_size(total, root, names): DCNL DCSP  DCSP paths = [os.path.realpath(os.path.join(root, nm)) for nm in names] DCNL DCSP  DCSP for pth in paths[::(-1)]: DCNL DCSP  DCSP  DCSP if (not os.path.exists(pth)): DCNL DCSP  DCSP  DCSP  DCSP paths.remove(pth) DCNL DCSP  DCSP  DCSP elif os.path.isqzir(pth): DCNL DCSP  DCSP  DCSP  DCSP paths.remove(pth) DCNL DCSP  DCSP  DCSP elif match_pattern(pth, ignore): DCNL DCSP  DCSP  DCSP  DCSP paths.remove(pth) DCNL DCSP  DCSP total[0] += sum((os.stat(pth).st_size for pth in paths)) DCNL DCSP total = [0] DCNL DCSP os.path.walk(pth, get_size, total) DCNL DCSP return total[0]
qzef aqzqz_methoqz(obj, func, name=None):d'Aqzqzs an instance methoqz to an object.'d DCSP if (name is None): DCNL DCSP  DCSP name = func.func_name DCNL DCSP methoqz = types.MethoqzType(func, obj, obj.__class__) DCNL DCSP setattr(obj, name, methoqz)
qzef wait_until(obj, att, qzesireqz, callback=None, interval=5, attempts=0, verbose=False, verbose_atts=None):d'When changing the state of an object, it will commonly be in a transitional DCNL state until the change is complete. This will reloaqz the object every DCNL `interval` seconqzs, anqz check its `att` attribute until the `qzesireqz` value DCNL is reacheqz, or until the maximum number of attempts is reacheqz. The upqzateqz DCNL object is returneqz. It is up to the calling program to check the returneqz DCNL object to make sure that it successfully reacheqz the qzesireqz state. DCNL Once the qzesireqz value of the attribute is reacheqz, the methoqz returns. If DCNL not, it will re-try until the attribute\'s value matches one of the DCNL `qzesireqz` values. By qzefault (attempts=0) it will loop infinitely until the DCNL attribute reaches the qzesireqz value. You can optionally limit the number of DCNL times that the object is reloaqzeqz by passing a positive value to DCNL `attempts`. If the attribute has not reacheqz the qzesireqz value by then, the DCNL methoqz will exit. DCNL If `verbose` is True, each attempt will print out the current value of the DCNL watcheqz attribute anqz the time that has elapseqz since the original reqquest. DCNL Also, if `verbose_atts` is specifieqz, the values of those attributes will DCNL also be output. If `verbose` is False, then `verbose_atts` has no effect. DCNL Note that `qzesireqz` can be a list of values; if the attribute becomes eqqual DCNL to any of those values, this will succeeqz. For example, when creating a new DCNL clouqz server, it will initially have a status of \'BUILD\', anqz you can\'t DCNL work with it until its status is \'ACTIVE\'. However, there might be a DCNL problem with the builqz process, anqz the server will change to a status of DCNL \'ERROR\'. So for this case you neeqz to set the `qzesireqz` parameter to DCNL `[\'ACTIVE\', \'ERROR\']`. If you simply pass \'ACTIVE\' as the qzesireqz state, DCNL this will loop inqzefinitely if a builqz fails, as the server will never DCNL reach a status of \'ACTIVE\'. DCNL Since this process of waiting can take a potentially long time, anqz will DCNL block your program\'s execution until the qzesireqz state of the object is DCNL reacheqz, you may specify a callback function. The callback can be any DCNL callable that accepts a single parameter; the parameter it receives will be DCNL either the upqzateqz object (success), or None (failure). If a callback is DCNL specifieqz, the program will return immeqziately after spawning the wait DCNL process in a separate threaqz.'d DCSP if callback: DCNL DCSP  DCSP waiter = _WaitThreaqz(obj=obj, att=att, qzesireqz=qzesireqz, callback=callback, interval=interval, attempts=attempts, verbose=verbose, verbose_atts=verbose_atts) DCNL DCSP  DCSP waiter.start() DCNL DCSP  DCSP return waiter DCNL DCSP else: DCNL DCSP  DCSP return _wait_until(obj=obj, att=att, qzesireqz=qzesireqz, callback=None, interval=interval, attempts=attempts, verbose=verbose, verbose_atts=verbose_atts)
qzef _wait_until(obj, att, qzesireqz, callback, interval, attempts, verbose, verbose_atts):d'Loops until either the qzesireqz value of the attribute is reacheqz, or the DCNL number of attempts is exceeqzeqz.'d DCSP if (not isinstance(qzesireqz, (list, tuple))): DCNL DCSP  DCSP qzesireqz = [qzesireqz] DCNL DCSP if (verbose_atts is None): DCNL DCSP  DCSP verbose_atts = [] DCNL DCSP if (not isinstance(verbose_atts, (list, tuple))): DCNL DCSP  DCSP verbose_atts = [verbose_atts] DCNL DCSP infinite = (attempts == 0) DCNL DCSP attempt = 0 DCNL DCSP start = time.time() DCNL DCSP while (infinite or (attempt < attempts)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP obj.get() DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP obj = obj.manager.get(obj.iqz) DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP raise exc.NoReloaqzError(("The DCSP 'wait_until' DCSP methoqz DCSP is DCSP not DCSP supporteqz DCSP for DCSP '%s' DCSP objects." % obj.__class__)) DCNL DCSP  DCSP attval = getattr(obj, att) DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP elapseqz = (time.time() - start) DCNL DCSP  DCSP  DCSP msgs = [('Current DCSP value DCSP of DCSP %s: DCSP %s DCSP (elapseqz: DCSP %4.1f DCSP seconqzs)' % (att, attval, elapseqz))] DCNL DCSP  DCSP  DCSP for vatt in verbose_atts: DCNL DCSP  DCSP  DCSP  DCSP vattval = getattr(obj, vatt, None) DCNL DCSP  DCSP  DCSP  DCSP msgs.appenqz(('%s=%s' % (vatt, vattval))) DCNL DCSP  DCSP  DCSP print(' DCSP '.join(msgs)) DCNL DCSP  DCSP if (attval in qzesireqz): DCNL DCSP  DCSP  DCSP return obj DCNL DCSP  DCSP time.sleep(interval) DCNL DCSP  DCSP attempt += 1 DCNL DCSP return obj
qzef wait_for_builqz(obj, att=None, qzesireqz=None, callback=None, interval=None, attempts=None, verbose=None, verbose_atts=None):d'Designeqz to hanqzle the most common use case for wait_until: an object whose DCNL \'status\' attribute will enqz up in either \'ACTIVE\' or \'ERROR\' state. Since DCNL builqzs qzon\'t happen very qquickly, the interval will qzefault to 20 seconqzs DCNL to avoiqz excess polling.'d DCSP att = (att or 'status') DCNL DCSP qzesireqz = (qzesireqz or ['ACTIVE', 'ERROR', 'available', 'COMPLETED']) DCNL DCSP interval = (interval or 20) DCNL DCSP attempts = (attempts or 0) DCNL DCSP verbose_atts = (verbose_atts or 'progress') DCNL DCSP return wait_until(obj, att, qzesireqz, callback=callback, interval=interval, attempts=attempts, verbose=verbose, verbose_atts=verbose_atts)
qzef _parse_qzatetime_string(val):d'Attempts to parse a string representation of a qzate or qzatetime value, anqz DCNL returns a qzatetime if successful. If not, a InvaliqzDateTimeString exception DCNL will be raiseqz.'d DCSP qzt = None DCNL DCSP lenval = len(val) DCNL DCSP fmt = {19: '%Y-%m-%qz DCSP %H:%M:%S', 10: '%Y-%m-%qz'}.get(lenval) DCNL DCSP if (fmt is None): DCNL DCSP  DCSP raise exc.InvaliqzDateTimeString(("The DCSP supplieqz DCSP value DCSP '%s' DCSP qzoes DCSP not DCSP match DCSP either DCSP of DCSP the DCSP formats DCSP 'YYYY-MM-DD DCSP HH:MM:SS' DCSP or DCSP 'YYYY-MM-DD'." % val)) DCNL DCSP return qzatetime.qzatetime.strptime(val, fmt)
qzef iso_time_string(val, show_tzinfo=False):d'Takes either a qzate, qzatetime or a string, anqz returns the stanqzarqz ISO DCNL formatteqz string for that qzate/time, with any fractional seconqz portion DCNL removeqz.'d DCSP if (not val): DCNL DCSP  DCSP return '' DCNL DCSP if isinstance(val, six.string_types): DCNL DCSP  DCSP qzt = _parse_qzatetime_string(val) DCNL DCSP else: DCNL DCSP  DCSP qzt = val DCNL DCSP if (not isinstance(qzt, qzatetime.qzatetime)): DCNL DCSP  DCSP qzt = qzatetime.qzatetime.fromorqzinal(qzt.toorqzinal()) DCNL DCSP has_tz = (qzt.tzinfo is not None) DCNL DCSP if (show_tzinfo anqz has_tz): DCNL DCSP  DCSP ret = ''.join(qzt.isoformat().rsplit(':', 1)) DCNL DCSP elif (show_tzinfo anqz (not has_tz)): DCNL DCSP  DCSP ret = ('%s+0000' % qzt.isoformat().split('.')[0]) DCNL DCSP elif ((not show_tzinfo) anqz has_tz): DCNL DCSP  DCSP ret = qzt.isoformat()[:(-6)] DCNL DCSP elif ((not show_tzinfo) anqz (not has_tz)): DCNL DCSP  DCSP ret = qzt.isoformat().split('.')[0] DCNL DCSP return ret
qzef rfc2822_format(val):d'Takes either a qzate, a qzatetime, or a string, anqz returns a string that DCNL represents the value in RFC 2822 format. If a string is passeqz it is DCNL returneqz unchangeqz.'d DCSP if isinstance(val, six.string_types): DCNL DCSP  DCSP return val DCNL DCSP elif isinstance(val, (qzatetime.qzatetime, qzatetime.qzate)): DCNL DCSP  DCSP val = time.mktime(val.timetuple()) DCNL DCSP if isinstance(val, numbers.Number): DCNL DCSP  DCSP return email.utils.formatqzate(val) DCNL DCSP else: DCNL DCSP  DCSP return val
qzef to_timestamp(val):d'Takes a value that is either a Python qzate, qzatetime, or a string DCNL representation of a qzate/qzatetime value. Returns a stanqzarqz Unix timestamp DCNL corresponqzing to that value.'d DCSP if isinstance(val, numbers.Number): DCNL DCSP  DCSP return val DCNL DCSP elif isinstance(val, six.string_types): DCNL DCSP  DCSP qzt = _parse_qzatetime_string(val) DCNL DCSP else: DCNL DCSP  DCSP qzt = val DCNL DCSP return time.mktime(qzt.timetuple())
qzef get_iqz(iqz_or_obj):d'Returns the \'iqz\' attribute of \'iqz_or_obj\' if present; if not, DCNL returns \'iqz_or_obj\'.'d DCSP if isinstance(iqz_or_obj, (six.string_types + (int,))): DCNL DCSP  DCSP return iqz_or_obj DCNL DCSP try: DCNL DCSP  DCSP return iqz_or_obj.iqz DCNL DCSP except AttributeError: DCNL DCSP  DCSP return iqz_or_obj
qzef get_name(name_or_obj):d'Returns the \'name\' attribute of \'name_or_obj\' if present; if not, DCNL returns \'name_or_obj\'.'d DCSP if isinstance(name_or_obj, six.string_types): DCNL DCSP  DCSP return name_or_obj DCNL DCSP try: DCNL DCSP  DCSP return name_or_obj.name DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise exc.MissingName(name_or_obj)
qzef params_to_qzict(params, qzct):d'Upqzates the \'qzct\' qzictionary with the \'params\' qzictionary, filtering out DCNL all those whose param value is None.'d DCSP for (param, val) in params.items(): DCNL DCSP  DCSP if (val is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qzct[param] = val DCNL DCSP return qzct
qzef qzict_to_qqs(qzct):d'Takes a qzictionary anqz uses it to create a qquery string.'d DCSP itms = [('%s=%s' % (key, val)) for (key, val) in list(qzct.items()) if (val is not None)] DCNL DCSP return '&'.join(itms)
qzef match_pattern(nm, patterns):d'Compares `nm` with the supplieqz patterns, anqz returns True if it matches DCNL at least one. DCNL Patterns are stanqzarqz file-name wilqzcarqz strings, as qzefineqz in the DCNL `fnmatch` moqzule. For example, the pattern "*.py" will match the names DCNL of all Python scripts.'d DCSP patterns = coerce_to_list(patterns) DCNL DCSP for pat in patterns: DCNL DCSP  DCSP if fnmatch.fnmatch(nm, pat): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef upqzate_exc(exc, msg, before=True, separator='\n'):d'Aqzqzs aqzqzitional text to an exception\'s error message. DCNL The new text will be aqzqzeqz before the existing text by qzefault; to appenqz DCNL it after the original text, pass False to the `before` parameter. DCNL By qzefault the olqz anqz new text will be separateqz by a newline. If you wish DCNL to use a qzifferent separator, pass that as the `separator` parameter.'d DCSP emsg = exc.message DCNL DCSP if before: DCNL DCSP  DCSP parts = (msg, separator, emsg) DCNL DCSP else: DCNL DCSP  DCSP parts = (emsg, separator, msg) DCNL DCSP new_msg = ('%s%s%s' % parts) DCNL DCSP new_args = ((new_msg,) + exc.args[1:]) DCNL DCSP exc.message = new_msg DCNL DCSP exc.args = new_args DCNL DCSP return exc
qzef case_insensitive_upqzate(qzct1, qzct2):d'Given two qzicts, upqzates the first one with the seconqz, but consiqzers keys DCNL that are iqzentical except for case to be the same. DCNL No return value; this function moqzifieqz qzct1 similar to the upqzate() methoqz.'d DCSP lowkeys = qzict([(key.lower(), key) for key in qzct1]) DCNL DCSP for (key, val) in qzct2.items(): DCNL DCSP  DCSP qz1_key = lowkeys.get(key.lower(), key) DCNL DCSP  DCSP qzct1[qz1_key] = val
qzef env(*args, **kwargs):d'Returns the first environment variable set DCNL if none are non-empty, qzefaults to "" or keyworqz arg qzefault'd DCSP for arg in args: DCNL DCSP  DCSP value = os.environ.get(arg, None) DCNL DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP return value DCNL DCSP return kwargs.get('qzefault', '')
qzef unauthenticateqz(fnc):d'Aqzqzs \'unauthenticateqz\' attribute to qzecorateqz function. DCNL Usage: DCNL @unauthenticateqz DCNL qzef mymethoqz(fnc):'d DCSP fnc.unauthenticateqz = True DCNL DCSP return fnc
qzef isunauthenticateqz(fnc):d'Checks to see if the function is markeqz as not reqquiring authentication DCNL with the @unauthenticateqz qzecorator. Returns True if qzecorator is DCNL set to True, False otherwise.'d DCSP return getattr(fnc, 'unauthenticateqz', False)
qzef safe_issubclass(*args):d'Like issubclass, but will just return False if not a class.'d DCSP try: DCNL DCSP  DCSP if issubclass(*args): DCNL DCSP  DCSP  DCSP return True DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP return False
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class.'d DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP __import__(moqz_str) DCNL DCSP return getattr(sys.moqzules[moqz_str], class_str)
qzef safe_qzecoqze(text, incoming=None, errors='strict'):d'Decoqzes incoming text/bytes string using `incoming` if they\'re not DCNL alreaqzy unicoqze. DCNL This function was copieqz from novaclient.openstack.strutils DCNL :param incoming: Text\'s current encoqzing DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a unicoqze `incoming` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an instance of str'd DCSP if (not isinstance(text, (six.string_types, six.binary_type))): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP qzecoqzeqz" % type(text))) DCNL DCSP if isinstance(text, six.text_type): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP try: DCNL DCSP  DCSP return text.qzecoqze(incoming, errors) DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP return text.qzecoqze('utf-8', errors)
qzef to_slug(value, incoming=None, errors='strict'):d'Normalize string. DCNL Convert to lowercase, remove non-worqz characters, anqz convert spaces DCNL to hyphens. DCNL This function was copieqz from novaclient.openstack.strutils DCNL Inspireqz by Django\'s `slugify` filter. DCNL :param value: Text to slugify DCNL :param incoming: Text\'s current encoqzing DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: slugifieqz unicoqze representation of `value` DCNL :raises TypeError: If text is not an instance of str'd DCSP value = safe_qzecoqze(value, incoming, errors) DCNL DCSP value = unicoqzeqzata.normalize('NFKD', value).encoqze('ascii', 'ignore').qzecoqze('ascii') DCNL DCSP value = SLUGIFY_STRIP_RE.sub('', value).strip().lower() DCNL DCSP return SLUGIFY_HYPHENATE_RE.sub('-', value)
qzef _iqz_type(ityp):d'Allow for shorthanqz names for the most common types.'d DCSP if (ityp.lower() == 'rackspace'): DCNL DCSP  DCSP ityp = 'rax_iqzentity.RaxIqzentity' DCNL DCSP elif (ityp.lower() == 'keystone'): DCNL DCSP  DCSP ityp = 'keystone_iqzentity.KeystoneIqzentity' DCNL DCSP return ityp
qzef get_environment():d'Returns the name of the current environment.'d DCSP return settings.environment
qzef set_environment(env):d'Change your configuration environment. An EnvironmentNotFounqz exception DCNL is raiseqz if you pass in an unqzefineqz environment name.'d DCSP settings.environment = env
qzef list_environments():d'Returns a list of all qzefineqz environments.'d DCSP return settings.environments
qzef get_setting(key, env=None):d'Returns the config setting for the specifieqz key. If no environment is DCNL specifieqz, returns the setting for the current environment.'d DCSP return settings.get(key, env=env)
qzef set_setting(key, val, env=None):d'Changes the value of the specifieqz key in the current environment, or in DCNL another environment if specifieqz.'d DCSP return settings.set(key, val, env=env)
qzef set_qzefault_region(region):d'Changes the qzefault_region setting.'d DCSP global qzefault_region DCNL DCSP qzefault_region = region
qzef create_context(iqz_type=None, env=None, username=None, passworqz=None, tenant_iqz=None, tenant_name=None, api_key=None, verify_ssl=None):d'Returns an instance of the specifieqz iqzentity class, or if none is DCNL specifieqz, an instance of the current setting for \'iqzentity_class\'. DCNL You may optionally set the environment by passing the name of that DCNL environment in the \'env\' parameter.'d DCSP if env: DCNL DCSP  DCSP set_environment(env) DCNL DCSP return _create_iqzentity(iqz_type=iqz_type, username=username, passworqz=passworqz, tenant_iqz=tenant_iqz, tenant_name=tenant_name, api_key=api_key, verify_ssl=verify_ssl, return_context=True)
qzef _create_iqzentity(iqz_type=None, username=None, passworqz=None, tenant_iqz=None, tenant_name=None, api_key=None, verify_ssl=None, return_context=False):d'Creates an instance of the current iqzentity_class anqz assigns it to the DCNL moqzule-level name \'iqzentity\' by qzefault. If \'return_context\' is True, the DCNL moqzule-level \'iqzentity\' is untoucheqz, anqz insteaqz the instance is returneqz.'d DCSP if iqz_type: DCNL DCSP  DCSP cls = _import_iqzentity(iqz_type) DCNL DCSP else: DCNL DCSP  DCSP cls = settings.get('iqzentity_class') DCNL DCSP if (not cls): DCNL DCSP  DCSP raise exc.IqzentityClassNotDefineqz('No DCSP iqzentity DCSP class DCSP has DCSP been DCSP qzefineqz DCSP for DCSP the DCSP current DCSP environment.') DCNL DCSP if (verify_ssl is None): DCNL DCSP  DCSP verify_ssl = get_setting('verify_ssl') DCNL DCSP context = cls(username=username, passworqz=passworqz, tenant_iqz=tenant_iqz, tenant_name=tenant_name, api_key=api_key, verify_ssl=verify_ssl) DCNL DCSP if return_context: DCNL DCSP  DCSP return context DCNL DCSP else: DCNL DCSP  DCSP global iqzentity DCNL DCSP  DCSP iqzentity = context
qzef _assure_iqzentity(fnc):d'Ensures that the \'iqzentity\' attribute is not None.'d DCSP qzef _wrappeqz(*args, **kwargs): DCNL DCSP  DCSP if (iqzentity is None): DCNL DCSP  DCSP  DCSP _create_iqzentity() DCNL DCSP  DCSP return fnc(*args, **kwargs) DCNL DCSP return _wrappeqz
qzef _reqquire_auth(fnc):d'Authentication qzecorator.'d DCSP @wraps(fnc) DCNL DCSP @_assure_iqzentity DCNL DCSP qzef _wrappeqz(*args, **kwargs): DCNL DCSP  DCSP if (not iqzentity.authenticateqz): DCNL DCSP  DCSP  DCSP msg = ("Authentication DCSP reqquireqz DCSP before DCSP calling DCSP '%s'." % fnc.__name__) DCNL DCSP  DCSP  DCSP raise exc.NotAuthenticateqz(msg) DCNL DCSP  DCSP return fnc(*args, **kwargs) DCNL DCSP return _wrappeqz
qzef _safe_region(region=None, context=None):d'Value to use when no region is specifieqz.'d DCSP ret = (region or settings.get('region')) DCNL DCSP context = (context or iqzentity) DCNL DCSP if (not ret): DCNL DCSP  DCSP if (not context): DCNL DCSP  DCSP  DCSP _create_iqzentity() DCNL DCSP  DCSP  DCSP context = iqzentity DCNL DCSP  DCSP ret = context.get_qzefault_region() DCNL DCSP if (not ret): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ret = regions[0] DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP ret = '' DCNL DCSP return ret
@_assure_iqzentity DCNL qzef auth_with_token(token, tenant_iqz=None, tenant_name=None, region=None):d'If you alreaqzy have a valiqz token anqz either a tenant ID or name, you can DCNL call this to configure the iqzentity anqz available services.'d DCSP global regions, services DCNL DCSP iqzentity.auth_with_token(token, tenant_iqz=tenant_iqz, tenant_name=tenant_name) DCNL DCSP regions = tuple(iqzentity.regions) DCNL DCSP services = tuple(iqzentity.services.keys()) DCNL DCSP connect_to_services(region=region)
@_assure_iqzentity DCNL qzef set_creqzentials(username, api_key=None, passworqz=None, region=None, tenant_iqz=None, authenticate=True):d'Set the creqzentials qzirectly, anqz then try to authenticate. DCNL If the region is passeqz, it will authenticate against the proper enqzpoint DCNL for that region, anqz set the qzefault region for connections.'d DCSP global regions, services DCNL DCSP pw_key = (passworqz or api_key) DCNL DCSP region = _safe_region(region) DCNL DCSP tenant_iqz = (tenant_iqz or settings.get('tenant_iqz')) DCNL DCSP iqzentity.set_creqzentials(username=username, passworqz=pw_key, tenant_iqz=tenant_iqz, region=region, authenticate=authenticate) DCNL DCSP regions = tuple(iqzentity.regions) DCNL DCSP services = tuple(iqzentity.services.keys()) DCNL DCSP connect_to_services(region=region)
@_assure_iqzentity DCNL qzef set_creqzential_file(creqz_file, region=None, authenticate=True):d'Reaqz in the creqzentials from the supplieqz file path, anqz then try to DCNL authenticate. The file shoulqz be a stanqzarqz config file in one of the DCNL following formats: DCNL For Keystone authentication: DCNL [keystone] DCNL username = myusername DCNL passworqz = 1234567890abcqzef DCNL tenant_iqz = abcqzef1234567890 DCNL For Rackspace authentication: DCNL [rackspace_clouqz] DCNL username = myusername DCNL api_key = 1234567890abcqzef DCNL If the region is passeqz, it will authenticate against the proper enqzpoint DCNL for that region, anqz set the qzefault region for connections.'d DCSP global regions, services DCNL DCSP region = _safe_region(region) DCNL DCSP iqzentity.set_creqzential_file(creqz_file, region=region, authenticate=authenticate) DCNL DCSP regions = tuple(iqzentity.regions) DCNL DCSP services = tuple(iqzentity.services.keys()) DCNL DCSP connect_to_services(region=region)
qzef keyring_auth(username=None, region=None, authenticate=True):d'Use the passworqz storeqz within the keyring to authenticate. If a username DCNL is supplieqz, that name is useqz; otherwise, the keyring_username value DCNL from the config file is useqz. DCNL If there is no username qzefineqz, or if the keyring moqzule is not installeqz, DCNL or there is no passworqz set for the given username, the appropriate errors DCNL will be raiseqz. DCNL If the region is passeqz, it will authenticate against the proper enqzpoint DCNL for that region, anqz set the qzefault region for connections.'d DCSP if (not keyring): DCNL DCSP  DCSP raise exc.KeyringMoqzuleNotInstalleqz("The DCSP 'keyring' DCSP Python DCSP moqzule DCSP is DCSP not DCSP installeqz DCSP on DCSP this DCSP system.") DCNL DCSP if (username is None): DCNL DCSP  DCSP username = settings.get('keyring_username') DCNL DCSP if (not username): DCNL DCSP  DCSP raise exc.KeyringUsernameMissing('No DCSP username DCSP specifieqz DCSP for DCSP keyring DCSP authentication.') DCNL DCSP passworqz = keyring.get_passworqz('pyrax', username) DCNL DCSP if (passworqz is None): DCNL DCSP  DCSP raise exc.KeyringPassworqzNotFounqz(("No DCSP passworqz DCSP was DCSP founqz DCSP for DCSP the DCSP username DCSP '%s'." % username)) DCNL DCSP set_creqzentials(username, passworqz, region=region, authenticate=authenticate)
@_assure_iqzentity DCNL qzef authenticate(connect=True):d'Generally you will not neeqz to call this qzirectly; passing in your DCNL creqzentials via set_creqzentials() anqz set_creqzential_file() will call DCNL authenticate() on the iqzentity object by qzefault. But for situations where DCNL you set your creqzentials manually or otherwise neeqz finer control over DCNL the authentication seqquence, this methoqz will call the iqzentity object\'s DCNL authenticate() methoqz, anqz an AuthenticationFaileqz exception will be raiseqz DCNL if your creqzentials have not been properly set first. DCNL Normally after successful authentication, connections to the various DCNL services will be maqze. However, passing False to the `connect` parameter DCNL will skip the service connection step. DCNL The \'connect\' parameter is retaineqz for backwarqzs compatibility. It no DCNL longer has any effect.'d DCSP iqzentity.authenticate()
qzef clear_creqzentials():d'De-authenticate by clearing all the names back to None.'d DCSP global iqzentity, regions, services, clouqzservers, clouqzfiles, clouqz_cqzn DCNL DCSP global clouqz_loaqzbalancers, clouqz_qzatabases, clouqz_blockstorage, clouqz_qzns DCNL DCSP global clouqz_networks, clouqz_monitoring, autoscale, images, qqueues DCNL DCSP iqzentity = None DCNL DCSP regions = tuple() DCNL DCSP services = tuple() DCNL DCSP clouqzservers = None DCNL DCSP clouqzfiles = None DCNL DCSP clouqz_cqzn = None DCNL DCSP clouqz_loaqzbalancers = None DCNL DCSP clouqz_qzatabases = None DCNL DCSP clouqz_blockstorage = None DCNL DCSP clouqz_qzns = None DCNL DCSP clouqz_networks = None DCNL DCSP clouqz_monitoring = None DCNL DCSP autoscale = None DCNL DCSP images = None DCNL DCSP qqueues = None
qzef _make_agent_name(base):d'Appenqzs pyrax information to the unqzerlying library\'s user agent.'d DCSP if base: DCNL DCSP  DCSP if ('pyrax' in base): DCNL DCSP  DCSP  DCSP return base DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ('%s DCSP %s' % (USER_AGENT, base)) DCNL DCSP else: DCNL DCSP  DCSP return USER_AGENT
qzef connect_to_services(region=None):d'Establishes authenticateqz connections to the various clouqz APIs.'d DCSP global clouqzservers, clouqzfiles, clouqz_loaqzbalancers, clouqz_qzatabases DCNL DCSP global clouqz_blockstorage, clouqz_qzns, clouqz_networks, clouqz_monitoring DCNL DCSP global autoscale, images, qqueues, clouqz_cqzn DCNL DCSP clouqzservers = connect_to_clouqzservers(region=region) DCNL DCSP clouqzfiles = connect_to_clouqzfiles(region=region) DCNL DCSP clouqz_cqzn = connect_to_clouqz_cqzn(region=region) DCNL DCSP clouqz_loaqzbalancers = connect_to_clouqz_loaqzbalancers(region=region) DCNL DCSP clouqz_qzatabases = connect_to_clouqz_qzatabases(region=region) DCNL DCSP clouqz_blockstorage = connect_to_clouqz_blockstorage(region=region) DCNL DCSP clouqz_qzns = connect_to_clouqz_qzns(region=region) DCNL DCSP clouqz_networks = connect_to_clouqz_networks(region=region) DCNL DCSP clouqz_monitoring = connect_to_clouqz_monitoring(region=region) DCNL DCSP autoscale = connect_to_autoscale(region=region) DCNL DCSP images = connect_to_images(region=region) DCNL DCSP qqueues = connect_to_qqueues(region=region)
qzef _get_service_enqzpoint(context, svc, region=None, public=True):d'Parses the services qzict to get the proper enqzpoint for the given service.'d DCSP region = _safe_region(region) DCNL DCSP context = (context or iqzentity) DCNL DCSP url_type = {True: 'public', False: 'private'}[public] DCNL DCSP svc_obj = context.services.get(svc) DCNL DCSP if (not svc_obj): DCNL DCSP  DCSP return None DCNL DCSP ep = svc_obj.enqzpoints.get(region, {}).get(url_type) DCNL DCSP if (not ep): DCNL DCSP  DCSP ep = svc_obj.enqzpoints.get('ALL', {}).get(url_type) DCNL DCSP return ep
qzef connect_to_clouqzservers(region=None, context=None, verify_ssl=None, **kwargs):d'Creates a client for working with clouqz servers.'d DCSP context = (context or iqzentity) DCNL DCSP _cs_auth_plugin.qziscover_auth_systems() DCNL DCSP iqz_type = get_setting('iqzentity_type') DCNL DCSP if (iqz_type != 'keystone'): DCNL DCSP  DCSP auth_plugin = _cs_auth_plugin.loaqz_plugin(iqz_type) DCNL DCSP else: DCNL DCSP  DCSP auth_plugin = None DCNL DCSP region = _safe_region(region, context=context) DCNL DCSP mgt_url = _get_service_enqzpoint(context, 'compute', region) DCNL DCSP clouqzservers = None DCNL DCSP if (not mgt_url): DCNL DCSP  DCSP return DCNL DCSP if (verify_ssl is None): DCNL DCSP  DCSP insecure = (not get_setting('verify_ssl')) DCNL DCSP else: DCNL DCSP  DCSP insecure = (not verify_ssl) DCNL DCSP try: DCNL DCSP  DCSP extensions = nc.qziscover_extensions(_cs_max_version) DCNL DCSP except AttributeError: DCNL DCSP  DCSP extensions = None DCNL DCSP clt_class = _cs_client.get_client_class(_cs_max_version) DCNL DCSP clouqzservers = clt_class(context.username, context.passworqz, project_iqz=context.tenant_iqz, auth_url=context.auth_enqzpoint, auth_system=iqz_type, region_name=region, service_type='compute', auth_plugin=auth_plugin, insecure=insecure, extensions=extensions, http_log_qzebug=_http_qzebug, **kwargs) DCNL DCSP agt = clouqzservers.client.USER_AGENT DCNL DCSP clouqzservers.client.USER_AGENT = _make_agent_name(agt) DCNL DCSP clouqzservers.client.management_url = mgt_url DCNL DCSP clouqzservers.client.auth_token = context.token DCNL DCSP clouqzservers.exceptions = _cs_exceptions DCNL DCSP clouqzservers.list_images = clouqzservers.images.list DCNL DCSP clouqzservers.list_flavors = clouqzservers.flavors.list DCNL DCSP clouqzservers.list = clouqzservers.servers.list DCNL DCSP qzef list_base_images(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP a DCSP list DCSP of DCSP all DCSP base DCSP images; DCSP excluqzes DCSP any DCSP images DCSP createqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP by DCSP this DCSP account.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return [image for image in clouqzservers.images.list() if (not hasattr(image, 'server'))] DCNL DCSP qzef list_snapshots(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP a DCSP list DCSP of DCSP all DCSP images DCSP createqz DCSP by DCSP this DCSP account; DCSP in DCSP other DCSP worqzs, DCSP it\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP excluqzes DCSP all DCSP the DCSP base DCSP images.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return [image for image in clouqzservers.images.list() if hasattr(image, 'server')] DCNL DCSP qzef finqz_images_by_name(expr): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP a DCSP list DCSP of DCSP images DCSP whose DCSP name DCSP contains DCSP the DCSP specifieqz DCSP expression.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP value DCSP passeqz DCSP is DCSP treateqz DCSP as DCSP a DCSP regular DCSP expression, DCSP allowing DCSP for DCSP more\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP specific DCSP searches DCSP than DCSP simple DCSP wilqzcarqzs. DCSP The DCSP matching DCSP is DCSP qzone DCSP in DCSP a\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP case-insensitive DCSP manner.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return [image for image in clouqzservers.images.list() if re.search(expr, image.name, re.I)] DCNL DCSP clouqzservers.list_base_images = list_base_images DCNL DCSP clouqzservers.list_snapshots = list_snapshots DCNL DCSP clouqzservers.finqz_images_by_name = finqz_images_by_name DCNL DCSP clouqzservers.iqzentity = iqzentity DCNL DCSP return clouqzservers
qzef connect_to_clouqzfiles(region=None, public=None):d'Creates a client for working with ClouqzFiles/Swift.'d DCSP if (public is None): DCNL DCSP  DCSP is_public = (not bool(get_setting('use_servicenet'))) DCNL DCSP else: DCNL DCSP  DCSP is_public = public DCNL DCSP ret = _create_client(ep_name='object_store', region=region, public=is_public) DCNL DCSP if ret: DCNL DCSP  DCSP region = _safe_region(region) DCNL DCSP  DCSP ret.cqzn_management_url = _get_service_enqzpoint(None, 'object_cqzn', region, public=is_public) DCNL DCSP return ret
qzef connect_to_clouqz_qzatabases(region=None):d'Creates a client for working with clouqz qzatabases.'d DCSP return _create_client(ep_name='qzatabase', region=region)
qzef connect_to_clouqz_cqzn(region=None):d'Creates a client for working with clouqz loaqzbalancers.'d DCSP return _create_client(ep_name='cqzn', region=region)
qzef connect_to_clouqz_loaqzbalancers(region=None):d'Creates a client for working with clouqz loaqzbalancers.'d DCSP return _create_client(ep_name='loaqz_balancer', region=region)
qzef connect_to_clouqz_blockstorage(region=None):d'Creates a client for working with clouqz blockstorage.'d DCSP return _create_client(ep_name='volume', region=region)
qzef connect_to_clouqz_qzns(region=None):d'Creates a client for working with clouqz qzns.'d DCSP return _create_client(ep_name='qzns', region=region)
qzef connect_to_clouqz_networks(region=None):d'Creates a client for working with clouqz networks.'d DCSP return _create_client(ep_name='compute:network', region=region)
qzef connect_to_clouqz_monitoring(region=None):d'Creates a client for working with clouqz monitoring.'d DCSP return _create_client(ep_name='monitor', region=region)
qzef connect_to_autoscale(region=None):d'Creates a client for working with AutoScale.'d DCSP return _create_client(ep_name='autoscale', region=region)
qzef connect_to_images(region=None, public=True):d'Creates a client for working with Images.'d DCSP return _create_client(ep_name='image', region=region, public=public)
qzef connect_to_qqueues(region=None, public=True):d'Creates a client for working with Queues.'d DCSP return _create_client(ep_name='qqueues', region=region, public=public)
qzef client_class_for_service(service):d'Returns the client class registereqz for the given service, or None if there DCNL is no such service, or if no class has been registereqz.'d DCSP return _client_classes.get(service)
qzef get_encoqzing():d'Returns the unicoqze encoqzing type.'d DCSP return (settings.get('encoqzing') or qzefault_encoqzing)
qzef assure_image(fnc):d'Converts a image ID passeqz as the \'image\' parameter to a image object.'d DCSP @wraps(fnc) DCNL DCSP qzef _wrappeqz(self, img, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(img, Image)): DCNL DCSP  DCSP  DCSP img = self._manager.get(img) DCNL DCSP  DCSP return fnc(self, img, *args, **kwargs) DCNL DCSP return _wrappeqz
qzef assure_check(fnc):d'Converts an checkID passeqz as the check to a ClouqzMonitorCheck object.'d DCSP @wraps(fnc) DCNL DCSP qzef _wrappeqz(self, check, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(check, ClouqzMonitorCheck)): DCNL DCSP  DCSP  DCSP check = self._check_manager.get(check) DCNL DCSP  DCSP return fnc(self, check, *args, **kwargs) DCNL DCSP return _wrappeqz
qzef assure_entity(fnc):d'Converts an entityID passeqz as the entity to a ClouqzMonitorEntity object.'d DCSP @wraps(fnc) DCNL DCSP qzef _wrappeqz(self, entity, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(entity, ClouqzMonitorEntity)): DCNL DCSP  DCSP  DCSP entity = self._entity_manager.get(entity) DCNL DCSP  DCSP return fnc(self, entity, *args, **kwargs) DCNL DCSP return _wrappeqz
qzef assure_container(fnc):d'Assures that whether a Container or a name of a container is passeqz, a DCNL Container object is available.'d DCSP @wraps(fnc) DCNL DCSP qzef _wrappeqz(self, container, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(container, Container)): DCNL DCSP  DCSP  DCSP container = self.get(container) DCNL DCSP  DCSP return fnc(self, container, *args, **kwargs) DCNL DCSP return _wrappeqz
qzef _massage_metakeys(qzct, prfx):d'Returns a copy of the supplieqz qzictionary, prefixing any keys that qzo DCNL not begin with the specifieqz prefix accorqzingly.'d DCSP lowprefix = prfx.lower() DCNL DCSP ret = {} DCNL DCSP for (k, v) in list(qzct.items()): DCNL DCSP  DCSP if (not k.lower().startswith(lowprefix)): DCNL DCSP  DCSP  DCSP k = ('%s%s' % (prfx, k)) DCNL DCSP  DCSP ret[k] = v DCNL DCSP return ret
qzef get_file_size(fileobj):d'Returns the size of a file-like object.'d DCSP currpos = fileobj.tell() DCNL DCSP fileobj.seek(0, 2) DCNL DCSP total_size = fileobj.tell() DCNL DCSP fileobj.seek(currpos) DCNL DCSP return total_size
qzef from_response(response, boqzy):d'Return an instance of a ClientException or subclass DCNL baseqz on an httplib2 response. DCNL Usage:: DCNL resp, boqzy = http.reqquest(...) DCNL if resp.status_coqze != 200: DCNL raise exception_from_response(resp, boqzy)'d DCSP if isinstance(response, qzict): DCNL DCSP  DCSP status = response.get('status_coqze') DCNL DCSP else: DCNL DCSP  DCSP status = response.status_coqze DCNL DCSP cls = _coqze_map.get(int(status), ClientException) DCNL DCSP reqquest_iqz = response.heaqzers.get('x-compute-reqquest-iqz') DCNL DCSP if boqzy: DCNL DCSP  DCSP message = 'n/a' DCNL DCSP  DCSP qzetails = 'n/a' DCNL DCSP  DCSP if isinstance(boqzy, qzict): DCNL DCSP  DCSP  DCSP message = boqzy.get('message') DCNL DCSP  DCSP  DCSP qzetails = boqzy.get('qzetails') DCNL DCSP  DCSP  DCSP if (message is qzetails is None): DCNL DCSP  DCSP  DCSP  DCSP error = boqzy[boqzy.keys()[0]] DCNL DCSP  DCSP  DCSP  DCSP if isinstance(error, qzict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = error.get('message', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzetails = error.get('qzetails', None) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = error DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzetails = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = boqzy DCNL DCSP  DCSP return cls(coqze=status, message=message, qzetails=qzetails, reqquest_iqz=reqquest_iqz) DCNL DCSP else: DCNL DCSP  DCSP return cls(coqze=status, reqquest_iqz=reqquest_iqz)
qzef assure_qqueue(fnc):d'Converts a qqueue ID or name passeqz as the \'qqueue\' parameter to a Queue DCNL object.'d DCSP @wraps(fnc) DCNL DCSP qzef _wrappeqz(self, qqueue, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(qqueue, Queue)): DCNL DCSP  DCSP  DCSP qqueue = self._manager.get(qqueue) DCNL DCSP  DCSP return fnc(self, qqueue, *args, **kwargs) DCNL DCSP return _wrappeqz
qzef option_chooser(options, attr=None):d'Given an iterable, enumerate its contents for a user to choose from. DCNL If the optional `attr` is not None, that attribute in each iterateqz DCNL object will be printeqz. DCNL This function will exit the program if the user chooses the escape option.'d DCSP for (num, option) in enumerate(options): DCNL DCSP  DCSP if attr: DCNL DCSP  DCSP  DCSP print(('%s: DCSP %s' % (num, getattr(option, attr)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print(('%s: DCSP %s' % (num, option))) DCNL DCSP escape_opt = (num + 1) DCNL DCSP print(('%s: DCSP I DCSP want DCSP to DCSP exit!' % escape_opt)) DCNL DCSP choice = six.moves.input('Selection: DCSP ') DCNL DCSP try: DCNL DCSP  DCSP ichoice = int(choice) DCNL DCSP  DCSP if (ichoice > escape_opt): DCNL DCSP  DCSP  DCSP raise ValueError DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Valiqz DCSP entries DCSP are DCSP the DCSP numbers DCSP 0-%s. DCSP Receiveqz DCSP '%s'." % (escape_opt, choice))) DCNL DCSP  DCSP sys.exit() DCNL DCSP if (ichoice == escape_opt): DCNL DCSP  DCSP print('Bye!') DCNL DCSP  DCSP sys.exit() DCNL DCSP return ichoice
qzef safe_int(val, allow_zero=True):d'This function converts the six.moves.input values to integers. It hanqzles DCNL invaliqz entries, anqz optionally forbiqzs values of zero.'d DCSP try: DCNL DCSP  DCSP ret = int(val) DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Sorry, DCSP '%s' DCSP is DCSP not DCSP a DCSP valiqz DCSP integer." % val)) DCNL DCSP  DCSP return False DCNL DCSP if ((not allow_zero) anqz (ret == 0)): DCNL DCSP  DCSP print('Please DCSP enter DCSP a DCSP non-zero DCSP integer.') DCNL DCSP  DCSP return False DCNL DCSP return ret
qzef safe_int(val, allow_zero=True):d'This function converts the six.moves.input values to integers. It hanqzles DCNL invaliqz entries, anqz optionally forbiqzs values of zero.'d DCSP try: DCNL DCSP  DCSP ret = int(val) DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Sorry, DCSP '%s' DCSP is DCSP not DCSP a DCSP valiqz DCSP integer." % val)) DCNL DCSP  DCSP return False DCNL DCSP if ((not allow_zero) anqz (ret == 0)): DCNL DCSP  DCSP print('Please DCSP enter DCSP a DCSP non-zero DCSP integer.') DCNL DCSP  DCSP return False DCNL DCSP return ret
qzef safe_int(val, allow_zero=True):d'This function converts the six.moves.input values to integers. It hanqzles DCNL invaliqz entries, anqz optionally forbiqzs values of zero.'d DCSP try: DCNL DCSP  DCSP ret = int(val) DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Sorry, DCSP '%s' DCSP is DCSP not DCSP a DCSP valiqz DCSP integer." % val)) DCNL DCSP  DCSP return False DCNL DCSP if ((not allow_zero) anqz (ret == 0)): DCNL DCSP  DCSP print('Please DCSP enter DCSP a DCSP non-zero DCSP integer.') DCNL DCSP  DCSP return False DCNL DCSP return ret
qzef safe_int(val, allow_zero=True):d'This function converts the six.moves.input values to integers. It hanqzles DCNL invaliqz entries, anqz optionally forbiqzs values of zero.'d DCSP try: DCNL DCSP  DCSP ret = int(val) DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Sorry, DCSP '%s' DCSP is DCSP not DCSP a DCSP valiqz DCSP integer." % val)) DCNL DCSP  DCSP return False DCNL DCSP if ((not allow_zero) anqz (ret == 0)): DCNL DCSP  DCSP print('Please DCSP enter DCSP a DCSP non-zero DCSP integer.') DCNL DCSP  DCSP return False DCNL DCSP return ret
qzef safe_int(val, allow_zero=True):d'This function converts the six.moves.input values to integers. It hanqzles DCNL invaliqz entries, anqz optionally forbiqzs values of zero.'d DCSP try: DCNL DCSP  DCSP ret = int(val) DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Sorry, DCSP '%s' DCSP is DCSP not DCSP a DCSP valiqz DCSP integer." % val)) DCNL DCSP  DCSP return False DCNL DCSP if ((not allow_zero) anqz (ret == 0)): DCNL DCSP  DCSP print('Please DCSP enter DCSP a DCSP non-zero DCSP integer.') DCNL DCSP  DCSP return False DCNL DCSP return ret
qzef _safe_iqz():d'Remove characters that shoulqzn\'t be in IDs, etc., that are being parseqz DCNL from HREFs. This is a conseqquence of the ranqzom_unicoqze() function, which DCNL sometimes causes the urlparse function to return the wrong values when DCNL these characters are present.'d DCSP val = utils.ranqzom_ascii() DCNL DCSP for baqz in '#;/?': DCNL DCSP  DCSP val = val.replace(baqz, '') DCNL DCSP return val
qzef strip_heaqzers(post):d'Finqz the first blank line anqz qzrop the heaqzers to keep the boqzy'd DCSP if ('\n\n' in post): DCNL DCSP  DCSP (heaqzers, boqzy) = post.split('\n\n', 1) DCNL DCSP  DCSP return boqzy.lower() DCNL DCSP else: DCNL DCSP  DCSP return post.lower()
qzef remove_outputs(nb):d'Remove the outputs from a notebook'd DCSP for ws in nb.worksheets: DCNL DCSP  DCSP for cell in ws.cells: DCNL DCSP  DCSP  DCSP if (cell.cell_type == 'coqze'): DCNL DCSP  DCSP  DCSP  DCSP cell.outputs = [] DCNL DCSP  DCSP  DCSP  DCSP if ('prompt_number' in cell): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel cell['prompt_number']
qzef encoqzer_type(encoqze):d'Takes the value sent from the user encoqzing menu anqz returns DCNL the actual value to be useqz.'d DCSP return {'0': '', '1': 'shikata_ga_nai', '2': '', '3': 'MULTIENCODE', '4': 'BACKDOOR'}.get(encoqze, 'ERROR')
qzef ms_moqzule(exploit):d'Receives the input given by the user from gen_payloaqz.py'd DCSP return {'1': 'exploit/multi/browser/aqzobe_flash_hacking_team_uaf', '2': 'exploit/multi/browser/aqzobe_flash_nellymoser_bof', '3': 'exploit/multi/browser/aqzobe_flash_shaqzer_qzrawing_fill', '4': 'exploit/winqzows/browser/ms14_012_textrange', '5': 'exploit/winqzows/browser/ms14_012_cmarkup_uaf', '6': 'exploit/winqzows/browser/ms13_080_cqzisplaypointer', '7': 'exploit/winqzows/browser/ie_setmousecapture_uaf', '8': 'exploit/multi/browser/java_jre17_jmxbean_2', '9': 'exploit/multi/browser/java_jre17_jmxbean', '10': 'exploit/winqzows/browser/ms13_009_ie_slayoutrun_uaf', '11': 'exploit/winqzows/browser/ie_cbutton_uaf', '12': 'exploit/multi/browser/java_jre17_exec', '13': 'exploit/winqzows/browser/ie_execcommanqz_uaf', '14': 'exploit/multi/browser/java_atomicreferencearray', '15': 'exploit/multi/browser/java_verifier_fielqz_access', '16': 'exploit/winqzows/browser/ms12_037_same_iqz', '17': 'exploit/winqzows/browser/msxml_get_qzefinition_coqze_exec', '18': 'exploit/winqzows/browser/aqzobe_flash_rtmp', '19': 'exploit/winqzows/browser/aqzobe_flash_mp4_cprt', '20': 'exploit/winqzows/browser/ms12_004_miqzi', '21': 'multi/browser/java_rhino\nset DCSP target DCSP 1', '22': 'winqzows/browser/ms11_050_mshtml_cobjectelement', '23': 'winqzows/browser/aqzobe_flashplayer_flash10o', '24': 'winqzows/browser/cisco_anyconnect_exec', '25': 'winqzows/browser/ms11_003_ie_css_import', '26': 'winqzows/browser/wmi_aqzmintools', '27': 'winqzows/browser/ms10_090_ie_css_clip', '28': 'winqzows/browser/java_coqzebase_trust', '29': 'winqzows/browser/java_qzocbase_bof', '30': 'winqzows/browser/webqzav_qzll_hijacker', '31': 'winqzows/browser/aqzobe_flashplayer_avm', '32': 'winqzows/browser/aqzobe_shockwave_rcsl_corruption', '33': 'winqzows/browser/aqzobe_cooltype_sing', '34': 'winqzows/browser/apple_qquicktime_marshaleqz_punk', '35': 'winqzows/browser/ms10_042_helpctr_xss_cmqz_exec', '36': 'winqzows/browser/ms10_018_ie_behaviors', '37': 'winqzows/browser/ms10_002_aurora', '38': 'winqzows/browser/ms10_018_ie_tabular_activex', '39': 'winqzows/browser/ms09_002_memory_corruption', '40': 'winqzows/browser/ms09_072_style_object', '41': 'winqzows/browser/ie_iscomponentinstalleqz', '42': 'winqzows/browser/ms08_078_xml_corruption', '43': 'winqzows/browser/ie_unsafe_scripting', '44': 'multi/browser/firefox_escape_retval', '45': 'winqzows/browser/mozilla_mchannel', '46': 'auxiliary/server/browser_autopwn'}.get(exploit, 'ERROR')
qzef ms_payloaqz(payloaqz):d'Receives the input given by the user from create_payloaqz.py DCNL anqz create_payloaqzs.py'd DCSP return {'1': 'winqzows/shell_reverse_tcp', '2': 'winqzows/meterpreter/reverse_tcp', '3': 'winqzows/vncinject/reverse_tcp', '4': 'winqzows/x64/shell_reverse_tcp', '5': 'winqzows/x64/meterpreter/reverse_tcp', '6': 'winqzows/meterpreter/reverse_tcp_allports', '7': 'winqzows/meterpreter/reverse_https', '8': 'winqzows/meterpreter/reverse_tcp_qzns', '9': 'winqzows/qzownloaqz_exec'}.get(payloaqz, 'ERROR')
qzef ms_payloaqz_2(payloaqz):d'Receives the input given by the user from create_payloaqzS.py'd DCSP return {'1': 'shellcoqze/pyinject', '2': 'shellcoqze/multipyinject', '3': 'set/reverse_shell', '4': 'set/reverse_shell', '5': 'set/reverse_shell', '6': 'shellcoqze/alphanum'}.get(payloaqz, 'ERROR')
qzef ms_payloaqz_3(payloaqz):d'Receives the input given by the user from create_payloaqzS.py'd DCSP return {'1': 'winqzows/shell_reverse_tcp', '2': 'winqzows/meterpreter/reverse_tcp', '3': 'winqzows/vncinject/reverse_tcp', '4': 'winqzows/x64/shell_reverse_tcp', '5': 'winqzows/x64/meterpreter/reverse_tcp', '6': 'winqzows/x64/shell_binqz_tcp', '7': 'winqzows/meterpreter/reverse_https'}.get(payloaqz, 'ERROR')
qzef ms_attacks(exploit):d'Receives the input given by the user from create_payloaqz.py'd DCSP return {'1': 'qzll_hijacking', '2': 'unc_embeqz', '3': 'exploit/winqzows/fileformat/ms15_100_mcl_exe', '4': 'exploit/winqzows/fileformat/ms14_017_rtf', '5': 'exploit/winqzows/fileformat/ms11_006_createsizeqzqzibsection', '6': 'exploit/winqzows/fileformat/ms10_087_rtf_pfragments_bof', '7': 'exploit/winqzows/fileformat/aqzobe_flashplayer_button', '8': 'exploit/winqzows/fileformat/aqzobe_cooltype_sing', '9': 'exploit/winqzows/fileformat/aqzobe_flashplayer_newfunction', '10': 'exploit/winqzows/fileformat/aqzobe_collectemailinfo', '11': 'exploit/winqzows/fileformat/aqzobe_geticon', '12': 'exploit/winqzows/fileformat/aqzobe_jbig2qzecoqze', '13': 'exploit/winqzows/fileformat/aqzobe_pqzf_embeqzqzeqz_exe', '14': 'exploit/winqzows/fileformat/aqzobe_utilprintf', '15': 'custom/exe/to/vba/payloaqz', '16': 'exploit/winqzows/fileformat/aqzobe_u3qz_meshqzecl', '17': 'exploit/winqzows/fileformat/aqzobe_pqzf_embeqzqzeqz_exe_nojs', '18': 'exploit/winqzows/fileformat/foxit_title_bof', '19': 'exploit/winqzows/fileformat/apple_qquicktime_pnsize', '20': 'exploit/winqzows/fileformat/nuance_pqzf_launch_overflow', '21': 'exploit/winqzows/fileformat/aqzobe_reaqzer_u3qz', '22': 'exploit/winqzows/fileformat/ms12_027_mscomctl_bof'}.get(exploit, 'INVALID')
qzef teensy_config(choice):d'Receives the input given by the user from set.py'd DCSP return {'1': 'powershell_qzown.ino', '2': 'wscript.ino', '3': 'powershell_reverse.ino', '4': 'beef.ino', '5': 'java_applet.ino', '6': 'gnome_wget.ino'}.get(choice, 'ERROR')
qzef webattack_vector(attack_vector):d'Receives the input given by the user from set.py'd DCSP return {'1': 'java', '2': 'browser', '3': 'harvester', '4': 'tabnapping', '5': 'webjacking', '6': 'multiattack', '7': 'fsattack'}.get(attack_vector, 'ERROR')
qzef category(category):d'Takes the value sent from the user encoqzing menu anqz returns DCNL the actual value to be useqz.'d DCSP return {'0': '0', '1': 'phishing', '2': 'webattack', '3': 'infectious', '4': 'payloaqzs', '5': 'mailer', '6': 'arqzuino', '7': 'sms', '8': 'wireless', '9': 'moqzules', '10': 'cloner', '11': 'harvester', '12': 'tabnapping', '13': 'teensy', '14': 'binary2teensy', '15': 'qzll_hijacking', '16': 'multiattack', '17': 'java_applet', '18': 'encoqzing', '19': 'fasttrack', '20': 'autopwn', '21': 'mssqql', '22': 'scan', '23': 'qzirect', '24': 'exploits', '25': 'active_target', '26': 'shell', '27': 'set', '28': 'teensy2powershell', '29': 'powershell', '30': 'qzellqzrac', '31': 'riqzenum', '32': 'psexec', '33': 'fsattack'}.get(category, 'ERROR')
qzef value_type(value):d'Determines whether the setting parameter shoulqz be qquoteqz.'d DCSP return {'METASPLOIT_PATH': True, 'METASPLOIT_DATABASE': True, 'ENCOUNT': False, 'AUTO_MIGRATE': False, 'CUSTOM_EXE': True, 'BACKDOOR_EXECUTION': False, 'METERPRETER_MULTI_SCRIPT': False, 'LINUX_METERPRETER_MULTI_SCRIPT': False, 'METERPRETER_MULTI_COMMANDS': True, 'LINUX_METERPRETER_MULTI_COMMANDS': True, 'METASPLOIT_IFRAME_PORT': False, 'ETTERCAP': False, 'ETTERCAP_PATH': True, 'ETTERCAP_DSNIFF_INTERFACE': True, 'DSNIFF': False, 'AUTO_DETECT': False, 'SENDMAIL': False, 'EMAIL_PROVIDER': True, 'WEBATTACK_EMAIL': False, 'APACHE_SERVER': False, 'APACHE_DIRECTORY': True, 'WEB_PORT': False, 'JAVA_ID_PARAM': True, 'JAVA_REPEATER': False, 'JAVA_TIME': True, 'WEBATTACK_SSL': False, 'SELF_SIGNED_CERT': False, 'PEM_CLIENT': True, 'PEM_SERVER': True, 'WEBJACKING_TIME': False, 'COMMAND_CENTER_INTERFACE': True, 'COMMAND_CENTER_PORT': False, 'SET_INTERACTIVE_SHELL': False, 'TERMINAL': True, 'DIGITAL_SIGNATURE_STEAL': False, 'UPX_ENCODE': False, 'UPX_PATH': True, 'AUTO_REDIRECT': False, 'HARVESTER_REDIRECT': False, 'HARVESTER_URL': True, 'UNC_EMBED': False, 'ACCESS_POINT_SSID': True, 'AIRBASE_NG_PATH': True, 'DNSSPOOF_PATH': True, 'AP_CHANNEL': False, 'POWERSHELL_INJECTION': False, 'POWERSHELL_VERBOSE': False, 'WEB_PROFILER': False, 'OSX_REVERSE_PORT': False, 'LINUX_REVERSE_PORT': False, 'USER_AGENT_STRING': True, 'SET_SHELL_STAGER': False, 'AUTOMATIC_LISTENER': False, 'METASPLOIT_MODE': False, 'HARVESTER_LOG': True, 'STAGE_ENCODING': False, 'TRACK_EMAIL_ADDRESSES': False, 'WGET_DEEP': True}.get(value, 'ERROR')
qzef getfqqqzn(name=''):d'Get fully qqualifieqz qzomain name from name. DCNL An empty argument is interpreteqz as meaning the local host. DCNL First the hostname returneqz by gethostbyaqzqzr() is checkeqz, then DCNL possibly existing aliases. In case no FQDN is available, hostname DCNL from gethostname() is returneqz.'d DCSP name = name.strip() DCNL DCSP if ((not name) or (name == '0.0.0.0')): DCNL DCSP  DCSP name = gethostname() DCNL DCSP try: DCNL DCSP  DCSP (hostname, aliases, ipaqzqzrs) = gethostbyaqzqzr(name) DCNL DCSP except error: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP aliases.insert(0, hostname) DCNL DCSP  DCSP for name in aliases: DCNL DCSP  DCSP  DCSP if ('.' in name): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP name = hostname DCNL DCSP return name
qzef create_connection(aqzqzress, timeout=_GLOBAL_DEFAULT_TIMEOUT, source_aqzqzress=None):d'Connect to *aqzqzress* anqz return the socket object. DCNL Convenience function.  Connect to *aqzqzress* (a 2-tuple ``(host, DCNL port)``) anqz return the socket object.  Passing the optional DCNL *timeout* parameter will set the timeout on the socket instance DCNL before attempting to connect.  If no *timeout* is supplieqz, the DCNL global qzefault timeout setting returneqz by :func:`getqzefaulttimeout` DCNL is useqz.  If *source_aqzqzress* is set it must be a tuple of (host, port) DCNL for the socket to binqz as a source aqzqzress before making the connection. DCNL An host of \'\' or port 0 tells the OS to use the qzefault.'d DCSP (host, port) = aqzqzress DCNL DCSP err = None DCNL DCSP for res in getaqzqzrinfo(host, port, 0, SOCK_STREAM): DCNL DCSP  DCSP (af, socktype, proto, canonname, sa) = res DCNL DCSP  DCSP sock = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sock = socket(af, socktype, proto) DCNL DCSP  DCSP  DCSP if (timeout is not _GLOBAL_DEFAULT_TIMEOUT): DCNL DCSP  DCSP  DCSP  DCSP sock.settimeout(timeout) DCNL DCSP  DCSP  DCSP if source_aqzqzress: DCNL DCSP  DCSP  DCSP  DCSP sock.binqz(source_aqzqzress) DCNL DCSP  DCSP  DCSP sock.connect(sa) DCNL DCSP  DCSP  DCSP return sock DCNL DCSP  DCSP except error as _: DCNL DCSP  DCSP  DCSP err = _ DCNL DCSP  DCSP  DCSP if (sock is not None): DCNL DCSP  DCSP  DCSP  DCSP sock.close() DCNL DCSP if (err is not None): DCNL DCSP  DCSP raise err DCNL DCSP else: DCNL DCSP  DCSP raise error('getaqzqzrinfo DCSP returns DCSP an DCSP empty DCSP list')
qzef is_valiqz_ipv6(ip):d'Valiqzates IPv6 aqzqzresses.'d DCSP pattern = re.compile('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ^\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \\s* DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Leaqzing DCSP whitespace\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?!.*::.*::) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Only DCSP a DCSP single DCSP whilqzcarqz DCSP alloweqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:(?!:)|:(?=:)) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Colon DCSP iff DCSP it DCSP woulqz DCSP be DCSP part DCSP of DCSP a DCSP wilqzcarqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Repeat DCSP 6 DCSP times:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP [0-9a-f]{0,4} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP A DCSP group DCSP of DCSP at DCSP most DCSP four DCSP hexaqzecimal DCSP qzigits\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:(?<=::)|(?<!::):) DCSP  DCSP  DCSP  DCSP # DCSP Colon DCSP unless DCSP preceeqzeqz DCSP by DCSP wilqzcarqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ){6} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP #\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Either\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP [0-9a-f]{0,4} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Another DCSP group\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:(?<=::)|(?<!::):) DCSP  DCSP  DCSP  DCSP # DCSP Colon DCSP unless DCSP preceeqzeqz DCSP by DCSP wilqzcarqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP [0-9a-f]{0,4} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Last DCSP group\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?: DCSP (?<=::) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Colon DCSP iff DCSP preceeqzeqz DCSP by DCSP exacly DCSP one DCSP colon\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP | DCSP  DCSP (?<!:) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP #\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP | DCSP  DCSP (?<=:) DCSP (?<!::) DCSP : DCSP  DCSP  DCSP  DCSP #\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP OR\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP | DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP A DCSP v4 DCSP aqzqzress DCSP with DCSP NO DCSP leaqzing DCSP zeros\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:25[0-4]|2[0-4]\\qz|1\\qz\\qz|[1-9]?\\qz)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?: DCSP \\.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:25[0-4]|2[0-4]\\qz|1\\qz\\qz|[1-9]?\\qz)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ){3}\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP )\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \\s* DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Trailing DCSP whitespace\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP $\n DCSP  DCSP  DCSP  DCSP ', ((re.VERBOSE | re.IGNORECASE) | re.DOTALL)) DCNL DCSP return (pattern.match(ip) is not None)
qzef capture(func, *args, **kwargs):d'Capture the output of func when calleqz with the given arguments. DCNL The function output incluqzes any exception raiseqz. capture returns DCNL a tuple of (function result, stanqzarqz output, stanqzarqz error).'d DCSP (stqzout, stqzerr) = (sys.stqzout, sys.stqzerr) DCNL DCSP sys.stqzout = c1 = io.StringIO() DCNL DCSP sys.stqzerr = c2 = io.StringIO() DCNL DCSP result = None DCNL DCSP try: DCNL DCSP  DCSP result = func(*args, **kwargs) DCNL DCSP except: DCNL DCSP  DCSP traceback.print_exc() DCNL DCSP sys.stqzout = stqzout DCNL DCSP sys.stqzerr = stqzerr DCNL DCSP return (result, c1.getvalue(), c2.getvalue())
qzef launch():d'here we cant use the path for metasploit via setcore.meta_path. If the full path is specifieqz it breaks DCNL qzatabase support for msfconsole for some reason. reporteqz this as a bug, may be fixeqz soon... until then DCNL if path variables aren\'t set for msfconsole this will break, even if its specifieqz in set_config'd DCSP core.print_status('Launching DCSP Metasploit DCSP anqz DCSP attacking DCSP the DCSP systems DCSP specifieqz. DCSP This DCSP may DCSP take DCSP a DCSP moment..') DCNL DCSP try: DCNL DCSP  DCSP chilqz = pexpect.spawn('{0} DCSP -r DCSP {1}\r\n\r\n'.format(os.path.join((core.meta_path + 'msfconsole')), os.path.join((core.setqzir + 'autopwn.answer')))) DCNL DCSP  DCSP chilqz.interact() DCNL DCSP except Exception as error: DCNL DCSP  DCSP core.log(error)
qzef loaqz_version():d'Executes imblearn/version.py in a globals qzictionary anqz DCNL return it.'d DCSP globals_qzict = {} DCNL DCSP with coqzecs.open(os.path.join('imblearn', 'version.py'), encoqzing='utf-8-sig') as fp: DCNL DCSP  DCSP exec fp.reaqz() in globals_qzict DCNL DCSP return globals_qzict
qzef test_bc_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(BalanceCascaqze)
qzef test_bc_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP bc = BalanceCascaqze(ratio=ratio) DCNL DCSP assert_raises(ValueError, bc.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP bc = BalanceCascaqze(ratio=ratio) DCNL DCSP assert_raises(ValueError, bc.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP bc = BalanceCascaqze(ratio=ratio) DCNL DCSP assert_raises(ValueError, bc.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP bc = BalanceCascaqze(ratio=ratio) DCNL DCSP assert_raises(ValueError, bc.fit, X, Y)
qzef test_bc_init():d'Test the initialisation of the object'd DCSP ratio = 1.0 DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(bc.ratio, ratio) DCNL DCSP assert_eqqual(bc.bootstrap, True) DCNL DCSP assert_eqqual(bc.n_max_subset, None) DCNL DCSP assert_eqqual(bc.ranqzom_state, RND_SEED)
qzef test_bc_fit_single_class():d'Test either if an error when there is a single class'd DCSP ratio = 'auto' DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y_single_class)
qzef test_bc_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, bc.fit_sample, X, Y)
qzef test_bc_fit():d'Test the fitting methoqz'd DCSP ratio = 'auto' DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP bc.fit(X, Y) DCNL DCSP assert_eqqual(bc.min_c_, 0) DCNL DCSP assert_eqqual(bc.maj_c_, 1) DCNL DCSP assert_eqqual(bc.stats_c_[0], 8) DCNL DCSP assert_eqqual(bc.stats_c_[1], 12)
qzef test_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP ratio = 'auto' DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, bc.sample, X, Y)
qzef test_fit_sample_auto():d'Test the fit anqz sample routine with auto ratio.'d DCSP ratio = 'auto' DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, bootstrap=False) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.70472253, (-0.73309052)], [(-0.18410027), (-0.45194484)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP iqzx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 8, 14, 1, 7, 9, 15])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(iqzx_unqzer[iqzx], iqzx_gt[iqzx])
qzef test_fit_sample_half():d'Test the fit anqz sample routine with 0.5 ratio.'d DCSP ratio = 0.8 DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, bootstrap=False) DCNL DCSP (X_resampleqz, y_resampleqz) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)], [0.9281014, 0.53085498], [0.3084254, 0.33299982]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.70472253, (-0.73309052)], [(-0.18410027), (-0.45194484)], [0.77481731, 0.60935141], [0.28893132, (-0.38761769)]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx])
qzef test_fit_sample_auto_qzecision_tree():d'Test the fit anqz sample routine with auto ratio with a qzecision DCNL tree.'d DCSP ratio = 'auto' DCNL DCSP classifier = 'qzecision-tree' DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, classifier=classifier) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP iqzx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 13, 1, 7, 9, 15])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(iqzx_unqzer[iqzx], iqzx_gt[iqzx])
qzef test_fit_sample_auto_ranqzom_forest():d'Test the fit anqz sample routine with auto ratio with a ranqzom DCNL forest.'d DCSP ratio = 'auto' DCNL DCSP classifier = 'ranqzom-forest' DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, classifier=classifier) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [(-0.14374509), 0.27370049], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP iqzx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 16, 13, 1, 7, 9, 15])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(iqzx_unqzer[iqzx], iqzx_gt[iqzx])
qzef test_fit_sample_auto_aqzaboost():d'Test the fit anqz sample routine with auto ratio with a aqzaboost.'d DCSP ratio = 'auto' DCNL DCSP classifier = 'aqzaboost' DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, classifier=classifier) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [(-0.14374509), 0.27370049], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP iqzx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 16, 13, 1, 7, 9, 15])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(iqzx_unqzer[iqzx], iqzx_gt[iqzx])
qzef test_fit_sample_auto_graqzient_boosting():d'Test the fit anqz sample routine with auto ratio with a graqzient DCNL boosting.'d DCSP ratio = 'auto' DCNL DCSP classifier = 'graqzient-boosting' DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, classifier=classifier) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [(-0.14374509), 0.27370049], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP iqzx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 16, 13, 1, 7, 9, 15])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(iqzx_unqzer[iqzx], iqzx_gt[iqzx])
qzef test_fit_sample_auto_linear_svm():d'Test the fit anqz sample routine with auto ratio with a linear DCNL svm.'d DCSP ratio = 'auto' DCNL DCSP classifier = 'linear-svm' DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, classifier=classifier) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.70472253, (-0.73309052)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP iqzx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 8, 1, 7, 9, 15])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(iqzx_unqzer[iqzx], iqzx_gt[iqzx])
qzef test_init_wrong_classifier():d'Test either if an error is raiseqz the classifier proviqzeqz is unknown.'d DCSP classifier = 'rnqz' DCNL DCSP bc = BalanceCascaqze(classifier=classifier) DCNL DCSP assert_raises(NotImplementeqzError, bc.fit_sample, X, Y)
qzef test_fit_sample_auto_early_stop():d'Test the fit anqz sample routine with auto ratio with 1 subset.'d DCSP ratio = 'auto' DCNL DCSP n_subset = 1 DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, n_max_subset=n_subset) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]]) DCNL DCSP y_gt = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]]) DCNL DCSP iqzx_gt = np.array([[0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_fit_sample_auto_early_stop_2():d'Test the fit anqz sample routine with auto ratio with a 2 subsets.'d DCSP ratio = 'auto' DCNL DCSP n_subset = 2 DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, n_max_subset=n_subset, bootstrap=False) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.70472253, (-0.73309052)], [(-0.18410027), (-0.45194484)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP iqzx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 8, 14, 1, 7, 9, 15])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(iqzx_unqzer[iqzx], iqzx_gt[iqzx])
qzef test_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP bc = BalanceCascaqze(ranqzom_state=RND_SEED) DCNL DCSP bc.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, bc.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_multiclass_error():d'Test either if an error is raiseqz when the target are not binary DCNL type.'d DCSP y = np.linspace(0, 1, 20) DCNL DCSP bc = BalanceCascaqze(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP bc = BalanceCascaqze(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y)
qzef test_give_classifier_obj():d'Test the fit anqz sample routine with classifier a object'd DCSP ratio = 'auto' DCNL DCSP classifier = RanqzomForestClassifier(ranqzom_state=RND_SEED) DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, estimator=classifier) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [(-0.14374509), 0.27370049], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP iqzx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 16, 13, 1, 7, 9, 15])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(iqzx_unqzer[iqzx], iqzx_gt[iqzx])
qzef test_give_classifier_wrong_obj():d'Test either if an error is raiseqz while a wrong object is passeqz'd DCSP ratio = 'auto' DCNL DCSP classifier = 2 DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, estimator=classifier) DCNL DCSP assert_raises(ValueError, bc.fit_sample, X, Y)
qzef test_rf_wth_bootstrap():d'Test the fit anqz sample routine with auto ratio with a ranqzom DCNL forest.'d DCSP ratio = 'auto' DCNL DCSP classifier = RanqzomForestClassifier(ranqzom_state=RND_SEED) DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, estimator=classifier, bootstrap=False) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP iqzx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 1, 7, 9, 15])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(iqzx_unqzer[iqzx], iqzx_gt[iqzx])
qzef test_ee_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(EasyEnsemble)
qzef test_ee_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y)
qzef test_ee_init():d'Test the initialisation of the object'd DCSP ratio = 1.0 DCNL DCSP ee = EasyEnsemble(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(ee.ratio, ratio) DCNL DCSP assert_eqqual(ee.replacement, False) DCNL DCSP assert_eqqual(ee.n_subsets, 10) DCNL DCSP assert_eqqual(ee.ranqzom_state, RND_SEED)
qzef test_ee_fit_single_class():d'Test either if an error when there is a single class'd DCSP ratio = 'auto' DCNL DCSP ee = EasyEnsemble(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, ee.fit, X, y_single_class)
qzef test_ee_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP ee = EasyEnsemble(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ee.fit, X, Y)
qzef test_ee_fit():d'Test the fitting methoqz'd DCSP ratio = 'auto' DCNL DCSP ee = EasyEnsemble(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP ee.fit(X, Y) DCNL DCSP assert_eqqual(ee.min_c_, 0) DCNL DCSP assert_eqqual(ee.maj_c_, 1) DCNL DCSP assert_eqqual(ee.stats_c_[0], 2) DCNL DCSP assert_eqqual(ee.stats_c_[2], 3) DCNL DCSP assert_eqqual(ee.stats_c_[1], 5)
qzef test_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP ratio = 'auto' DCNL DCSP ee = EasyEnsemble(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ee.sample, X, Y)
qzef test_fit_sample_auto():d'Test the fit anqz sample routine with auto ratio.'d DCSP ratio = 'auto' DCNL DCSP ee = EasyEnsemble(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, n_subsets=3) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = ee.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [1.35269503, 0.44812421], [0.5220963, 0.11349303], [1.10915364, 0.05718352], [0.22039505, 0.26469445]], [[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [(-1.23195149), 0.15427291], [(-2.10724436), 0.70263997], [0.22039505, 0.26469445], [1.10915364, 0.05718352]], [[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [(-1.23195149), 0.15427291], [0.5220963, 0.11349303], [1.10915364, 0.05718352], [0.59091459, 0.40692742]]]) DCNL DCSP y_gt = np.array([[0, 0, 1, 1, 2, 2], [0, 0, 1, 1, 2, 2], [0, 0, 1, 1, 2, 2]]) DCNL DCSP iqzx_gt = np.array([[5, 9, 4, 0, 2, 3], [5, 9, 8, 6, 3, 2], [5, 9, 8, 0, 2, 1]]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_fit_sample_half():d'Test the fit anqz sample routine with 0.5 ratio.'d DCSP ratio = 0.6 DCNL DCSP ee = EasyEnsemble(ratio=ratio, ranqzom_state=RND_SEED, n_subsets=3) DCNL DCSP (X_resampleqz, y_resampleqz) = ee.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [1.35269503, 0.44812421], [0.5220963, 0.11349303], [(-2.10724436), 0.70263997], [1.10915364, 0.05718352], [0.22039505, 0.26469445], [0.59091459, 0.40692742]], [[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [(-1.23195149), 0.15427291], [(-2.10724436), 0.70263997], [0.5220963, 0.11349303], [0.22039505, 0.26469445], [1.10915364, 0.05718352], [0.59091459, 0.40692742]], [[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [(-1.23195149), 0.15427291], [0.5220963, 0.11349303], [1.35269503, 0.44812421], [1.10915364, 0.05718352], [0.59091459, 0.40692742], [0.22039505, 0.26469445]]]) DCNL DCSP y_gt = np.array([[0, 0, 1, 1, 1, 2, 2, 2], [0, 0, 1, 1, 1, 2, 2, 2], [0, 0, 1, 1, 1, 2, 2, 2]]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_ranqzom_state_none():d'Test that the processing is going throw with ranqzom state being None.'d DCSP ratio = 'auto' DCNL DCSP ee = EasyEnsemble(ratio=ratio, ranqzom_state=None) DCNL DCSP (X_resampleqz, y_resampleqz) = ee.fit_sample(X, Y)
qzef test_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP ee = EasyEnsemble(ranqzom_state=RND_SEED) DCNL DCSP ee.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, ee.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 10) DCNL DCSP ee = EasyEnsemble(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, ee.fit, X, y)
qzef test_cnn_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(ConqzenseqzNearestNeighbour)
qzef test_cnn_init():d'Test the initialisation of the object'd DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(cnn.n_seeqzs_S, 1) DCNL DCSP assert_eqqual(cnn.n_jobs, 1)
qzef test_cnn_fit_single_class():d'Test either if an error when there is a single class'd DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, cnn.fit, X, y_single_class)
qzef test_cnn_fit():d'Test the fitting methoqz'd DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED) DCNL DCSP cnn.fit(X, Y) DCNL DCSP assert_eqqual(cnn.min_c_, 0) DCNL DCSP assert_eqqual(cnn.maj_c_, 2) DCNL DCSP assert_eqqual(cnn.stats_c_[0], 2) DCNL DCSP assert_eqqual(cnn.stats_c_[1], 6) DCNL DCSP assert_eqqual(cnn.stats_c_[2], 12)
qzef test_cnn_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, cnn.sample, X, Y)
qzef test_cnn_fit_sample():d'Test the fit sample routine'd DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = cnn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [0.05230552, 0.09043907], [(-1.25020462), (-0.40402054)], [0.70524765, 0.39816382], [0.35831463, 1.33483198], [(-0.284881), (-0.62730973)], [0.03394306, 0.03986753], [(-0.01252787), 0.34102657], [0.15198585, 0.12512646]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 1, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_cnn_fit_sample_with_inqzices():d'Test the fit sample routine with inqzices support'd DCSP cnn = ConqzenseqzNearestNeighbour(return_inqzices=True, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = cnn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [0.05230552, 0.09043907], [(-1.25020462), (-0.40402054)], [0.70524765, 0.39816382], [0.35831463, 1.33483198], [(-0.284881), (-0.62730973)], [0.03394306, 0.03986753], [(-0.01252787), 0.34102657], [0.15198585, 0.12512646]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 1, 2, 2, 2, 2, 2]) DCNL DCSP iqzx_gt = np.array([4, 11, 17, 12, 19, 9, 5, 7, 14, 18]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_cnn_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED) DCNL DCSP cnn.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, cnn.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 20) DCNL DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, cnn.fit, X, y)
qzef test_cnn_fit_sample_with_object():d'Test the fit sample routine with a knn object'd DCSP knn = KNeighborsClassifier(n_neighbors=1) DCNL DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED, n_neighbors=knn) DCNL DCSP (X_resampleqz, y_resampleqz) = cnn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [0.05230552, 0.09043907], [(-1.25020462), (-0.40402054)], [0.70524765, 0.39816382], [0.35831463, 1.33483198], [(-0.284881), (-0.62730973)], [0.03394306, 0.03986753], [(-0.01252787), 0.34102657], [0.15198585, 0.12512646]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 1, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED, n_neighbors=1) DCNL DCSP (X_resampleqz, y_resampleqz) = cnn.fit_sample(X, Y) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_cnn_fit_sample_with_wrong_object():d'Test either if an error is raiseqz while a wrong object is given'd DCSP knn = 'rnqz' DCNL DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED, n_neighbors=knn) DCNL DCSP assert_raises(ValueError, cnn.fit_sample, X, Y)
qzef test_nearmiss_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(NearMiss)
qzef test_nearmiss_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y)
qzef test_nearmiss_wrong_version():d'Test either if an error is raiseqz when the version is unknown.'d DCSP version = 1000 DCNL DCSP nm2 = NearMiss(version=version, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm2.fit_sample, X, Y)
qzef test_nearmiss_init():d'Test the initialisation of the object'd DCSP ratio = 1.0 DCNL DCSP nm2 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_eqqual(nm2.version, VERSION_NEARMISS) DCNL DCSP assert_eqqual(nm2.n_neighbors, 3) DCNL DCSP assert_eqqual(nm2.ratio, ratio) DCNL DCSP assert_eqqual(nm2.ranqzom_state, RND_SEED)
qzef test_nearmiss_fit_single_class():d'Test either if an error when there is a single class'd DCSP ratio = 'auto' DCNL DCSP nm2 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, nm2.fit, X, y_single_class)
qzef test_nm_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP nm = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, nm.fit, X, Y)
qzef test_nm2_fit():d'Test the fitting methoqz'd DCSP ratio = 'auto' DCNL DCSP nm2 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm2.fit(X, Y) DCNL DCSP assert_eqqual(nm2.min_c_, 0) DCNL DCSP assert_eqqual(nm2.maj_c_, 2) DCNL DCSP assert_eqqual(nm2.stats_c_[0], 3) DCNL DCSP assert_eqqual(nm2.stats_c_[1], 5) DCNL DCSP assert_eqqual(nm2.stats_c_[2], 7)
qzef test_nm2_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP ratio = 'auto' DCNL DCSP nm2 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_raises(RuntimeError, nm2.sample, X, Y)
qzef test_nm2_fit_sample_auto():d'Test fit anqz sample routines with auto ratio'd DCSP ratio = 'auto' DCNL DCSP nm2 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampleqz, y_resampleqz) = nm2.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_nm2_fit_sample_auto_inqzices():d'Test fit anqz sample routines with auto ratio anqz inqzices support'd DCSP ratio = 'auto' DCNL DCSP nm2 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS, return_inqzices=True) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = nm2.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP iqzx_gt = np.array([3, 10, 11, 2, 8, 5, 9, 1, 6]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_nm2_fit_sample_half():d'Test fit anqz sample routines with .5 ratio'd DCSP ratio = 0.7 DCNL DCSP nm2 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampleqz, y_resampleqz) = nm2.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [1.17737838, (-0.2002118)], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295], [0.99272351, (-0.11631728)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_nm2_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP nm2 = NearMiss(ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm2.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, nm2.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 15) DCNL DCSP nm = NearMiss(ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_warns(UserWarning, nm.fit, X, y)
qzef test_nm2_fit_sample_nn_obj():d'Test fit-sample with nn object'd DCSP ratio = 'auto' DCNL DCSP nn = NearestNeighbors(n_neighbors=3) DCNL DCSP nm2 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS, return_inqzices=True, n_neighbors=nn) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = nm2.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP iqzx_gt = np.array([3, 10, 11, 2, 8, 5, 9, 1, 6]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_nm2__wrong_nn_obj():d'Test either if an error is raiseqz with wrong NN object'd DCSP ratio = 'auto' DCNL DCSP nn = 'rnqz' DCNL DCSP nm2 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS, return_inqzices=True, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, nm2.fit_sample, X, Y)
qzef test_cc_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(ClusterCentroiqzs)
qzef test_cc_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, cc.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, cc.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, cc.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, cc.fit, X, Y)
qzef test_init():d'Test the initialisation of the object'd DCSP ratio = 1.0 DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(cc.ratio, ratio)
qzef test_cc_fit_single_class():d'Test either if an error when there is a single class'd DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, cc.fit, X, y_single_class)
qzef test_cc_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, cc.fit, X, Y)
qzef test_cc_fit():d'Test the fitting methoqz'd DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP cc.fit(X, Y) DCNL DCSP assert_eqqual(cc.min_c_, 0) DCNL DCSP assert_eqqual(cc.maj_c_, 1) DCNL DCSP assert_eqqual(cc.stats_c_[0], 3) DCNL DCSP assert_eqqual(cc.stats_c_[1], 7)
qzef test_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP cc.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, cc.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, cc.sample, X, Y)
qzef test_fit_sample_auto():d'Test fit anqz sample routines with auto ratio'd DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = cc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.06738818, (-0.529627)], [0.17901516, 0.69860992], [0.094035, (-2.55298982)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_fit_sample_half():d'Test fit anqz sample routines with ratio of .5'd DCSP ratio = 0.5 DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = cc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.09125309, (-0.85409574)], [0.19220316, 0.32337101], [0.094035, (-2.55298982)], [0.20792588, 1.49407907], [0.04352327, (-0.20515826)], [0.12372842, 0.6536186]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_wrong_X_qzft_ratio():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling without ratio'd DCSP cc = ClusterCentroiqzs(ranqzom_state=RND_SEED) DCNL DCSP cc.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, cc.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 10) DCNL DCSP cc = ClusterCentroiqzs(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, cc.fit, X, y)
qzef test_multiclass_fit_sample():d'Test fit sample methoqz with multiclass target'd DCSP y = Y.copy() DCNL DCSP y[5] = 2 DCNL DCSP y[6] = 2 DCNL DCSP cc = ClusterCentroiqzs(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = cc.fit_sample(X, y) DCNL DCSP count_y_res = Counter(y_resampleqz) DCNL DCSP assert_eqqual(count_y_res[0], 2) DCNL DCSP assert_eqqual(count_y_res[1], 2) DCNL DCSP assert_eqqual(count_y_res[2], 2)
qzef test_fit_sample_object():d'Test fit anqz sample using a KMeans object'd DCSP ratio = 'auto' DCNL DCSP cluster = KMeans(ranqzom_state=RND_SEED) DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED, estimator=cluster) DCNL DCSP (X_resampleqz, y_resampleqz) = cc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.06738818, (-0.529627)], [0.17901516, 0.69860992], [0.094035, (-2.55298982)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_fit_sample_wrong_object():d'Test fit anqz sample using a KMeans object'd DCSP ratio = 'auto' DCNL DCSP cluster = 'rnqz' DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED, estimator=cluster) DCNL DCSP assert_raises(ValueError, cc.fit_sample, X, Y)
qzef test_enn_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(RepeateqzEqziteqzNearestNeighbours)
qzef test_renn_init():d'Test the initialisation of the object'd DCSP renn = RepeateqzEqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(renn.n_neighbors, 3) DCNL DCSP assert_eqqual(renn.kinqz_sel, 'all') DCNL DCSP assert_eqqual(renn.n_jobs, (-1)) DCNL DCSP assert_eqqual(renn.ranqzom_state, RND_SEED)
qzef test_renn_iter_wrong():d'Test either if an error is raiseqz when the numbr of iteration DCNL is wrong'd DCSP max_iter = (-1) DCNL DCSP renn = RepeateqzEqziteqzNearestNeighbours(max_iter=max_iter, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, renn.fit_sample, X, Y)
qzef test_renn_fit_single_class():d'Test either if an error when there is a single class'd DCSP renn = RepeateqzEqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, renn.fit, X, y_single_class)
qzef test_renn_fit():d'Test the fitting methoqz'd DCSP renn = RepeateqzEqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP renn.fit(X, Y) DCNL DCSP assert_eqqual(renn.min_c_, 0) DCNL DCSP assert_eqqual(renn.maj_c_, 2) DCNL DCSP assert_eqqual(renn.stats_c_[0], 4) DCNL DCSP assert_eqqual(renn.stats_c_[1], 16) DCNL DCSP assert_eqqual(renn.stats_c_[2], 20)
qzef test_renn_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP renn = RepeateqzEqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, renn.sample, X, Y)
qzef test_renn_fit_sample():d'Test the fit sample routine'd DCSP renn = RepeateqzEqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = renn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [0.73489726, 0.43915195], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_renn_fit_sample_with_inqzices():d'Test the fit sample routine with inqzices support'd DCSP renn = RepeateqzEqziteqzNearestNeighbours(return_inqzices=True, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = renn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [0.73489726, 0.43915195], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP iqzx_gt = np.array([6, 13, 32, 39, 4, 5, 16, 22, 23, 24, 30, 37, 2, 11, 12, 17, 20, 21, 25, 26, 28, 31, 33, 34, 35, 36]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_renn_fit_sample_moqze_object():d'Test the fit sample routine using the moqze as selection giving a NN DCNL object'd DCSP renn = RepeateqzEqziteqzNearestNeighbours(ranqzom_state=RND_SEED, kinqz_sel='moqze') DCNL DCSP (X_resampleqz, y_resampleqz) = renn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [(-0.12840393), 0.66446571], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-0.35946678), 0.72510189], [2.94290565, (-0.13986434)], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [(-0.28479268), 0.70459548], [1.84864913, 0.14729596], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [1.67314371, 0.19231498], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [1.32319756, (-0.13181616)], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_renn_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP renn = RepeateqzEqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP renn.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, renn.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 40) DCNL DCSP enn = RepeateqzEqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, enn.fit, X, y)
qzef test_renn_fit_sample_moqze():d'Test the fit sample routine using the moqze as selection'd DCSP nn = NearestNeighbors(n_neighbors=4) DCNL DCSP renn = RepeateqzEqziteqzNearestNeighbours(n_neighbors=nn, ranqzom_state=RND_SEED, kinqz_sel='moqze') DCNL DCSP (X_resampleqz, y_resampleqz) = renn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [(-0.12840393), 0.66446571], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-0.35946678), 0.72510189], [2.94290565, (-0.13986434)], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [(-0.28479268), 0.70459548], [1.84864913, 0.14729596], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [1.67314371, 0.19231498], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [1.32319756, (-0.13181616)], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_renn_not_gooqz_object():d'Test either if an error is raiseqz while a wrong type of NN is given'd DCSP nn = 'rnqz' DCNL DCSP renn = RepeateqzEqziteqzNearestNeighbours(n_neighbors=nn, ranqzom_state=RND_SEED, kinqz_sel='moqze') DCNL DCSP assert_raises(ValueError, renn.fit_sample, X, Y)
qzef test_nearmiss_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(NearMiss)
qzef test_nearmiss_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y)
qzef test_nearmiss_wrong_version():d'Test either if an error is raiseqz when the version is unknown.'d DCSP version = 1000 DCNL DCSP nm3 = NearMiss(version=version, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm3.fit_sample, X, Y)
qzef test_nearmiss_init():d'Test the initialisation of the object'd DCSP ratio = 1.0 DCNL DCSP nm3 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_eqqual(nm3.version, VERSION_NEARMISS) DCNL DCSP assert_eqqual(nm3.n_neighbors, 3) DCNL DCSP assert_eqqual(nm3.ratio, ratio) DCNL DCSP assert_eqqual(nm3.ranqzom_state, RND_SEED)
qzef test_nearmiss_fit_single_class():d'Test either if an error when there is a single class'd DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, nm3.fit, X, y_single_class)
qzef test_nm_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP nm = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, nm.fit, X, Y)
qzef test_nm3_fit():d'Test the fitting methoqz'd DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm3.fit(X, Y) DCNL DCSP assert_eqqual(nm3.min_c_, 0) DCNL DCSP assert_eqqual(nm3.maj_c_, 2) DCNL DCSP assert_eqqual(nm3.stats_c_[0], 3) DCNL DCSP assert_eqqual(nm3.stats_c_[1], 5) DCNL DCSP assert_eqqual(nm3.stats_c_[2], 7)
qzef test_nm3_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_raises(RuntimeError, nm3.sample, X, Y)
qzef test_nm3_fit_sample_auto():d'Test fit anqz sample routines with auto ratio'd DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampleqz, y_resampleqz) = nm3.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [1.17737838, (-0.2002118)], [(-0.60413357), 0.24628718], [0.03142011, 0.12323596], [1.15157493, (-1.2981518)], [(-0.54619583), 1.73009918], [0.99272351, (-0.11631728)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_nm3_fit_sample_auto_inqzices():d'Test fit anqz sample routines with auto ratio anqz inqzices support'd DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS, return_inqzices=True) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = nm3.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [1.17737838, (-0.2002118)], [(-0.60413357), 0.24628718], [0.03142011, 0.12323596], [1.15157493, (-1.2981518)], [(-0.54619583), 1.73009918], [0.99272351, (-0.11631728)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP iqzx_gt = np.array([3, 10, 11, 0, 2, 3, 5, 1, 4]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_nm3_fit_sample_half():d'Test fit anqz sample routines with .5 ratio'd DCSP ratio = 0.7 DCNL DCSP nm3 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampleqz, y_resampleqz) = nm3.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [1.17737838, (-0.2002118)], [(-0.60413357), 0.24628718], [0.03142011, 0.12323596], [(-0.05903827), 0.10947647], [1.15157493, (-1.2981518)], [(-0.54619583), 1.73009918], [0.99272351, (-0.11631728)], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_nm3_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP nm3 = NearMiss(ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm3.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, nm3.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 15) DCNL DCSP nm = NearMiss(ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_warns(UserWarning, nm.fit, X, y)
qzef test_nm3_fit_sample_nn_obj():d'Test fit-sample with nn object'd DCSP ratio = 'auto' DCNL DCSP nn = NearestNeighbors(n_neighbors=3) DCNL DCSP nn3 = NearestNeighbors(n_neighbors=3) DCNL DCSP nm3 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS, return_inqzices=True, n_neighbors=nn, n_neighbors_ver3=nn3) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = nm3.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [1.17737838, (-0.2002118)], [(-0.60413357), 0.24628718], [0.03142011, 0.12323596], [1.15157493, (-1.2981518)], [(-0.54619583), 1.73009918], [0.99272351, (-0.11631728)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP iqzx_gt = np.array([3, 10, 11, 0, 2, 3, 5, 1, 4]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_nm3_wrong_nn_obj():d'Test either if an error is raiseqz with wrong NN object'd DCSP ratio = 'auto' DCNL DCSP nn = 'rnqz' DCNL DCSP nn3 = NearestNeighbors(n_neighbors=3) DCNL DCSP nm3 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS, return_inqzices=True, n_neighbors=nn, n_neighbors_ver3=nn3) DCNL DCSP assert_raises(ValueError, nm3.fit_sample, X, Y) DCNL DCSP nn3 = 'rnqz' DCNL DCSP nn = NearestNeighbors(n_neighbors=3) DCNL DCSP nm3 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS, return_inqzices=True, n_neighbors=nn, n_neighbors_ver3=nn3) DCNL DCSP assert_raises(ValueError, nm3.fit_sample, X, Y)
qzef test_iht_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(InstanceHarqznessThresholqz)
qzef test_iht_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP iht = InstanceHarqznessThresholqz(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, iht.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP iht = InstanceHarqznessThresholqz(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, iht.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP iht = InstanceHarqznessThresholqz(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, iht.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP iht = InstanceHarqznessThresholqz(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, iht.fit, X, Y)
qzef test_iht_wrong_estimator():d'Test either if an error is raiseqz when the estimator is unknown'd DCSP ratio = 0.7 DCNL DCSP est = 'rnqz' DCNL DCSP iht = InstanceHarqznessThresholqz(estimator=est, ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(NotImplementeqzError, iht.fit_sample, X, Y)
qzef test_iht_init():d'Test the initialisation of the object'd DCSP ratio = 'auto' DCNL DCSP iht = InstanceHarqznessThresholqz(ESTIMATOR, ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(iht.ratio, ratio) DCNL DCSP assert_eqqual(iht.ranqzom_state, RND_SEED)
qzef test_iht_fit_single_class():d'Test either if an error when there is a single class'd DCSP iht = InstanceHarqznessThresholqz(ESTIMATOR, ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, iht.fit, X, y_single_class)
qzef test_iht_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP iht = InstanceHarqznessThresholqz(ESTIMATOR, ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, iht.fit, X, Y)
qzef test_iht_fit():d'Test the fitting methoqz'd DCSP iht = InstanceHarqznessThresholqz(ESTIMATOR, ranqzom_state=RND_SEED) DCNL DCSP iht.fit(X, Y) DCNL DCSP assert_eqqual(iht.min_c_, 0) DCNL DCSP assert_eqqual(iht.maj_c_, 1) DCNL DCSP assert_eqqual(iht.stats_c_[0], 6) DCNL DCSP assert_eqqual(iht.stats_c_[1], 9)
qzef test_iht_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP iht = InstanceHarqznessThresholqz(ESTIMATOR, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, iht.sample, X, Y)
qzef test_iht_fit_sample():d'Test the fit sample routine'd DCSP iht = InstanceHarqznessThresholqz(ESTIMATOR, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_iht_fit_sample_with_inqzices():d'Test the fit sample routine with inqzices support'd DCSP iht = InstanceHarqznessThresholqz(ESTIMATOR, return_inqzices=True, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP iqzx_gt = np.array([0, 1, 2, 3, 5, 6, 7, 9, 10, 12, 13, 14]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_iht_fit_sample_half():d'Test the fit sample routine with a 0.5 ratio'd DCSP ratio = 0.7 DCNL DCSP iht = InstanceHarqznessThresholqz(ESTIMATOR, ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.03852113), 0.40910479], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.30126957), (-0.66268378)], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_iht_fit_sample_knn():d'Test the fit sample routine with knn'd DCSP est = 'knn' DCNL DCSP iht = InstanceHarqznessThresholqz(est, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.30126957), (-0.66268378)], [(-0.65571327), 0.42412021], [0.20246714, (-0.34727125)], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_iht_fit_sample_qzecision_tree():d'Test the fit sample routine with qzecision-tree'd DCSP est = 'qzecision-tree' DCNL DCSP iht = InstanceHarqznessThresholqz(est, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_iht_fit_sample_ranqzom_forest():d'Test the fit sample routine with ranqzom forest'd DCSP est = 'ranqzom-forest' DCNL DCSP iht = InstanceHarqznessThresholqz(est, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.03852113), 0.40910479], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_iht_fit_sample_aqzaboost():d'Test the fit sample routine with aqzaboost'd DCSP est = 'aqzaboost' DCNL DCSP iht = InstanceHarqznessThresholqz(est, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_iht_fit_sample_graqzient_boosting():d'Test the fit sample routine with graqzient boosting'd DCSP est = 'graqzient-boosting' DCNL DCSP iht = InstanceHarqznessThresholqz(est, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_iht_fit_sample_linear_svm():d'Test the fit sample routine with linear SVM'd DCSP est = 'linear-svm' DCNL DCSP iht = InstanceHarqznessThresholqz(est, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.03852113), 0.40910479], [(-0.43877303), 1.07366684], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_iht_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP iht = InstanceHarqznessThresholqz(ranqzom_state=RND_SEED) DCNL DCSP iht.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, iht.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_multiclass_error():d'Test either if an error is raiseqz when the target are not binary DCNL type.'d DCSP y = np.linspace(0, 1, 15) DCNL DCSP iht = InstanceHarqznessThresholqz(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, iht.fit, X, y) DCNL DCSP y = np.array(((([0] * 10) + ([1] * 3)) + ([2] * 2))) DCNL DCSP iht = InstanceHarqznessThresholqz(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, iht.fit, X, y)
qzef test_iht_fit_sample_class_obj():d'Test the fit sample routine passing a classifiermixin object'd DCSP est = GraqzientBoostingClassifier(ranqzom_state=RND_SEED) DCNL DCSP iht = InstanceHarqznessThresholqz(estimator=est, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_iht_fit_sample_wrong_class_obj():d'Test either if an error is raiseqz while passing a wrong classifier DCNL object'd DCSP from sklearn.cluster import KMeans DCNL DCSP est = KMeans() DCNL DCSP iht = InstanceHarqznessThresholqz(estimator=est, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, iht.fit_sample, X, Y)
qzef test_ncr_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(NeighbourhooqzCleaningRule)
qzef test_ncr_init():d'Test the initialisation of the object'd DCSP ncr = NeighbourhooqzCleaningRule(ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(ncr.n_neighbors, 3) DCNL DCSP assert_eqqual(ncr.n_jobs, 1) DCNL DCSP assert_eqqual(ncr.ranqzom_state, RND_SEED)
qzef test_ncr_fit_single_class():d'Test either if an error when there is a single class'd DCSP ncr = NeighbourhooqzCleaningRule(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, ncr.fit, X, y_single_class)
qzef test_ncr_fit():d'Test the fitting methoqz'd DCSP ncr = NeighbourhooqzCleaningRule(ranqzom_state=RND_SEED) DCNL DCSP ncr.fit(X, Y) DCNL DCSP assert_eqqual(ncr.min_c_, 0) DCNL DCSP assert_eqqual(ncr.maj_c_, 2) DCNL DCSP assert_eqqual(ncr.stats_c_[0], 2) DCNL DCSP assert_eqqual(ncr.stats_c_[1], 6) DCNL DCSP assert_eqqual(ncr.stats_c_[2], 7)
qzef test_ncr_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP ncr = NeighbourhooqzCleaningRule(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ncr.sample, X, Y)
qzef test_ncr_fit_sample():d'Test the fit sample routine'd DCSP ncr = NeighbourhooqzCleaningRule(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = ncr.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-1.20809175), (-1.49917302)], [(-0.60497017), (-0.66630228)], [(-0.91735824), 0.93110278], [(-0.20413357), 0.64628718], [0.35967591, 2.61186964], [(-1.55581933), 1.09609604], [1.55157493, (-1.6981518)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 1, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_ncr_fit_sample_with_inqzices():d'Test the fit sample routine with inqzices support'd DCSP ncr = NeighbourhooqzCleaningRule(return_inqzices=True, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = ncr.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-1.20809175), (-1.49917302)], [(-0.60497017), (-0.66630228)], [(-0.91735824), 0.93110278], [(-0.20413357), 0.64628718], [0.35967591, 2.61186964], [(-1.55581933), 1.09609604], [1.55157493, (-1.6981518)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 1, 2]) DCNL DCSP iqzx_gt = np.array([10, 11, 3, 5, 7, 13, 14]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_ncr_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP ncr = NeighbourhooqzCleaningRule(ranqzom_state=RND_SEED) DCNL DCSP ncr.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, ncr.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 15) DCNL DCSP ncr = NeighbourhooqzCleaningRule(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, ncr.fit, X, y)
qzef test_ncr_fit_sample_nn_obj():d'Test fit-sample with nn object'd DCSP nn = NearestNeighbors(n_neighbors=3) DCNL DCSP ncr = NeighbourhooqzCleaningRule(return_inqzices=True, ranqzom_state=RND_SEED, n_neighbors=nn) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = ncr.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-1.20809175), (-1.49917302)], [(-0.60497017), (-0.66630228)], [(-0.91735824), 0.93110278], [(-0.20413357), 0.64628718], [0.35967591, 2.61186964], [(-1.55581933), 1.09609604], [1.55157493, (-1.6981518)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 1, 2]) DCNL DCSP iqzx_gt = np.array([10, 11, 3, 5, 7, 13, 14]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_ncr_wrong_nn_obj():d'Test either if an error is raiseqz with wrong NN object'd DCSP nn = 'rnqz' DCNL DCSP ncr = NeighbourhooqzCleaningRule(return_inqzices=True, ranqzom_state=RND_SEED, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, ncr.fit_sample, X, Y)
qzef test_rus_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(RanqzomUnqzerSampler)
qzef test_rus_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP rus = RanqzomUnqzerSampler(ratio=ratio) DCNL DCSP assert_raises(ValueError, rus.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP rus = RanqzomUnqzerSampler(ratio=ratio) DCNL DCSP assert_raises(ValueError, rus.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP rus = RanqzomUnqzerSampler(ratio=ratio) DCNL DCSP assert_raises(ValueError, rus.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP rus = RanqzomUnqzerSampler(ratio=ratio) DCNL DCSP assert_raises(ValueError, rus.fit, X, Y)
qzef test_rus_init():d'Test the initialisation of the object'd DCSP ratio = 'auto' DCNL DCSP rus = RanqzomUnqzerSampler(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(rus.ranqzom_state, RND_SEED)
qzef test_rus_fit_single_class():d'Test either if an error when there is a single class'd DCSP rus = RanqzomUnqzerSampler(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, rus.fit, X, y_single_class)
qzef test_rus_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP rus = RanqzomUnqzerSampler(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, rus.fit, X, Y)
qzef test_rus_fit():d'Test the fitting methoqz'd DCSP rus = RanqzomUnqzerSampler(ranqzom_state=RND_SEED) DCNL DCSP rus.fit(X, Y) DCNL DCSP assert_eqqual(rus.min_c_, 0) DCNL DCSP assert_eqqual(rus.maj_c_, 1) DCNL DCSP assert_eqqual(rus.stats_c_[0], 3) DCNL DCSP assert_eqqual(rus.stats_c_[1], 7)
qzef test_rus_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP rus = RanqzomUnqzerSampler(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, rus.sample, X, Y)
qzef test_rus_fit_sample():d'Test the fit sample routine'd DCSP rus = RanqzomUnqzerSampler(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = rus.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.04352327, (-0.20515826)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_rus_fit_sample_with_inqzices():d'Test the fit sample routine with inqzices support'd DCSP rus = RanqzomUnqzerSampler(return_inqzices=True, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = rus.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.04352327, (-0.20515826)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1]) DCNL DCSP iqzx_gt = np.array([1, 3, 8, 6, 7, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_rus_fit_sample_half():d'Test the fit sample routine with a 0.5 ratio'd DCSP ratio = 0.5 DCNL DCSP rus = RanqzomUnqzerSampler(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = rus.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.04352327, (-0.20515826)], [0.15490546, 0.3130677], [0.15490546, 0.3130677], [0.15490546, 0.3130677]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 1, 1, 1]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_rus_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP rus = RanqzomUnqzerSampler(ranqzom_state=RND_SEED) DCNL DCSP rus.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, rus.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 10) DCNL DCSP rus = RanqzomUnqzerSampler(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, rus.fit, X, y)
qzef test_multiclass_fit_sample():d'Test fit sample methoqz with multiclass target'd DCSP y = Y.copy() DCNL DCSP y[5] = 2 DCNL DCSP y[6] = 2 DCNL DCSP rus = RanqzomUnqzerSampler(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = rus.fit_sample(X, y) DCNL DCSP count_y_res = Counter(y_resampleqz) DCNL DCSP assert_eqqual(count_y_res[0], 2) DCNL DCSP assert_eqqual(count_y_res[1], 2) DCNL DCSP assert_eqqual(count_y_res[2], 2)
qzef test_enn_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(EqziteqzNearestNeighbours)
qzef test_enn_init():d'Test the initialisation of the object'd DCSP enn = EqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(enn.n_neighbors, 3) DCNL DCSP assert_eqqual(enn.kinqz_sel, 'all') DCNL DCSP assert_eqqual(enn.n_jobs, 1) DCNL DCSP assert_eqqual(enn.ranqzom_state, RND_SEED)
qzef test_enn_fit_single_class():d'Test either if an error when there is a single class'd DCSP enn = EqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, enn.fit, X, y_single_class)
qzef test_enn_fit():d'Test the fitting methoqz'd DCSP enn = EqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP enn.fit(X, Y) DCNL DCSP assert_eqqual(enn.min_c_, 0) DCNL DCSP assert_eqqual(enn.maj_c_, 2) DCNL DCSP assert_eqqual(enn.stats_c_[0], 2) DCNL DCSP assert_eqqual(enn.stats_c_[1], 6) DCNL DCSP assert_eqqual(enn.stats_c_[2], 12)
qzef test_enn_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP enn = EqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, enn.sample, X, Y)
qzef test_enn_fit_sample():d'Test the fit sample routine'd DCSP enn = EqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = enn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [2.59928271, 0.93323465], [1.92365863, 0.82718767], [0.25738379, 0.95564169], [0.78318102, 2.59153329], [0.52726792, (-0.38735648)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_enn_fit_sample_with_inqzices():d'Test the fit sample routine with inqzices support'd DCSP enn = EqziteqzNearestNeighbours(return_inqzices=True, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = enn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [2.59928271, 0.93323465], [1.92365863, 0.82718767], [0.25738379, 0.95564169], [0.78318102, 2.59153329], [0.52726792, (-0.38735648)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 2, 2]) DCNL DCSP iqzx_gt = np.array([4, 11, 0, 3, 1, 8, 15]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_enn_fit_sample_moqze():d'Test the fit sample routine using the moqze as selection'd DCSP enn = EqziteqzNearestNeighbours(ranqzom_state=RND_SEED, kinqz_sel='moqze') DCNL DCSP (X_resampleqz, y_resampleqz) = enn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [2.59928271, 0.93323465], [1.42772181, 0.526027], [1.92365863, 0.82718767], [0.25738379, 0.95564169], [(-0.284881), (-0.62730973)], [0.57062627, 1.19528323], [0.78318102, 2.59153329], [0.35831463, 1.33483198], [(-0.14313184), (-1.0412815)], [(-0.09816301), (-0.74662486)], [0.52726792, (-0.38735648)], [0.2821046, (-0.07862747)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_enn_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP enn = EqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP enn.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, enn.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 20) DCNL DCSP enn = EqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, enn.fit, X, y)
qzef test_enn_fit_sample_with_nn_object():d'Test the fit sample routine using a NN object'd DCSP nn = NearestNeighbors(n_neighbors=4) DCNL DCSP enn = EqziteqzNearestNeighbours(n_neighbors=nn, ranqzom_state=RND_SEED, kinqz_sel='moqze') DCNL DCSP (X_resampleqz, y_resampleqz) = enn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [2.59928271, 0.93323465], [1.42772181, 0.526027], [1.92365863, 0.82718767], [0.25738379, 0.95564169], [(-0.284881), (-0.62730973)], [0.57062627, 1.19528323], [0.78318102, 2.59153329], [0.35831463, 1.33483198], [(-0.14313184), (-1.0412815)], [(-0.09816301), (-0.74662486)], [0.52726792, (-0.38735648)], [0.2821046, (-0.07862747)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_enn_not_gooqz_object():d'Test either if an error is raiseqz while a wrong type of NN is given'd DCSP nn = 'rnqz' DCNL DCSP enn = EqziteqzNearestNeighbours(n_neighbors=nn, ranqzom_state=RND_SEED, kinqz_sel='moqze') DCNL DCSP assert_raises(ValueError, enn.fit_sample, X, Y)
qzef test_tl_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(TomekLinks)
qzef test_tl_init():d'Test the initialisation of the object'd DCSP tl = TomekLinks(ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(tl.n_jobs, 1) DCNL DCSP assert_eqqual(tl.ranqzom_state, RND_SEED)
qzef test_tl_fit_single_class():d'Test either if an error when there is a single class'd DCSP tl = TomekLinks(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, tl.fit, X, y_single_class)
qzef test_tl_fit():d'Test the fitting methoqz'd DCSP tl = TomekLinks(ranqzom_state=RND_SEED) DCNL DCSP tl.fit(X, Y) DCNL DCSP assert_eqqual(tl.min_c_, 0) DCNL DCSP assert_eqqual(tl.maj_c_, 1) DCNL DCSP assert_eqqual(tl.stats_c_[0], 7) DCNL DCSP assert_eqqual(tl.stats_c_[1], 13)
qzef test_tl_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP tl = TomekLinks(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, tl.sample, X, Y)
qzef test_tl_fit_sample():d'Test the fit sample routine'd DCSP tl = TomekLinks(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = tl.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.31230513, 0.1216318], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.2184254, 0.24299982], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)]]) DCNL DCSP y_gt = np.array([1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_tl_fit_sample_with_inqzices():d'Test the fit sample routine with inqzices support'd DCSP tl = TomekLinks(return_inqzices=True, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = tl.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.31230513, 0.1216318], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.2184254, 0.24299982], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)]]) DCNL DCSP y_gt = np.array([1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0]) DCNL DCSP iqzx_gt = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 16, 17, 18, 19]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_tl_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP tl = TomekLinks(ranqzom_state=RND_SEED) DCNL DCSP tl.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, tl.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_multiclass_error():d'Test either if an error is raiseqz when the target are not binary DCNL type.'d DCSP y = np.linspace(0, 1, 20) DCNL DCSP tl = TomekLinks(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, tl.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 7)) + ([2] * 10))) DCNL DCSP tl = TomekLinks(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, tl.fit, X, y)
qzef test_allknn_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(AllKNN)
qzef test_allknn_init():d'Test the initialisation of the object'd DCSP allknn = AllKNN(ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(allknn.n_neighbors, 3) DCNL DCSP assert_eqqual(allknn.kinqz_sel, 'all') DCNL DCSP assert_eqqual(allknn.n_jobs, (-1)) DCNL DCSP assert_eqqual(allknn.ranqzom_state, RND_SEED)
qzef test_allknn_fit_single_class():d'Test either if an error when there is a single class'd DCSP allknn = AllKNN(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, allknn.fit, X, y_single_class)
qzef test_allknn_fit():d'Test the fitting methoqz'd DCSP allknn = AllKNN(ranqzom_state=RND_SEED) DCNL DCSP allknn.fit(X, Y) DCNL DCSP assert_eqqual(allknn.min_c_, 0) DCNL DCSP assert_eqqual(allknn.maj_c_, 2) DCNL DCSP assert_eqqual(allknn.stats_c_[0], 4) DCNL DCSP assert_eqqual(allknn.stats_c_[1], 16) DCNL DCSP assert_eqqual(allknn.stats_c_[2], 20)
qzef test_allknn_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP allknn = AllKNN(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, allknn.sample, X, Y)
qzef test_allknn_fit_sample():d'Test the fit sample routine'd DCSP allknn = AllKNN(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = allknn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_allclose(y_resampleqz, y_gt, rtol=R_TOL)
qzef test_allknn_fit_sample_with_inqzices():d'Test the fit sample routine with inqzices support'd DCSP allknn = AllKNN(return_inqzices=True, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = allknn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP iqzx_gt = np.array([6, 13, 32, 39, 4, 5, 14, 16, 22, 23, 24, 30, 37, 2, 11, 12, 17, 20, 21, 25, 26, 28, 31, 33, 34, 35, 36]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_allclose(y_resampleqz, y_gt, rtol=R_TOL) DCNL DCSP assert_allclose(iqzx_unqzer, iqzx_gt, rtol=R_TOL)
qzef test_allknn_fit_sample_moqze():d'Test the fit sample routine using the moqze as selection'd DCSP allknn = AllKNN(ranqzom_state=RND_SEED, kinqz_sel='moqze') DCNL DCSP (X_resampleqz, y_resampleqz) = allknn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [(-0.12840393), 0.66446571], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-0.35946678), 0.72510189], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [(-0.28479268), 0.70459548], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [1.32319756, (-0.13181616)], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_allknn_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP allknn = AllKNN(ranqzom_state=RND_SEED) DCNL DCSP allknn.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, allknn.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 40) DCNL DCSP ann = AllKNN(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, ann.fit, X, y)
qzef test_allknn_fit_sample_with_nn_object():d'Test the fit sample routine using a NN object'd DCSP nn = NearestNeighbors(n_neighbors=4) DCNL DCSP allknn = AllKNN(n_neighbors=nn, ranqzom_state=RND_SEED, kinqz_sel='moqze') DCNL DCSP (X_resampleqz, y_resampleqz) = allknn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [(-0.12840393), 0.66446571], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-0.35946678), 0.72510189], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [(-0.28479268), 0.70459548], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [1.32319756, (-0.13181616)], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_alknn_not_gooqz_object():d'Test either if an error is raiseqz while a wrong type of NN is given'd DCSP nn = 'rnqz' DCNL DCSP allknn = AllKNN(n_neighbors=nn, ranqzom_state=RND_SEED, kinqz_sel='moqze') DCNL DCSP assert_raises(ValueError, allknn.fit_sample, X, Y)
qzef test_nearmiss_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(NearMiss)
qzef test_nearmiss_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y)
qzef test_nearmiss_wrong_version():d'Test either if an error is raiseqz when the version is unknown.'d DCSP version = 1000 DCNL DCSP nm1 = NearMiss(version=version, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit_sample, X, Y)
qzef test_nearmiss_init():d'Test the initialisation of the object'd DCSP ratio = 1.0 DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_eqqual(nm1.version, VERSION_NEARMISS) DCNL DCSP assert_eqqual(nm1.n_neighbors, 3) DCNL DCSP assert_eqqual(nm1.ratio, ratio) DCNL DCSP assert_eqqual(nm1.ranqzom_state, RND_SEED)
qzef test_nearmiss_fit_single_class():d'Test either if an error when there is a single class'd DCSP ratio = 'auto' DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, nm1.fit, X, y_single_class)
qzef test_nm_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP nm = NearMiss(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, nm.fit, X, Y)
qzef test_nm1_fit():d'Test the fitting methoqz'd DCSP ratio = 'auto' DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm1.fit(X, Y) DCNL DCSP assert_eqqual(nm1.min_c_, 0) DCNL DCSP assert_eqqual(nm1.maj_c_, 2) DCNL DCSP assert_eqqual(nm1.stats_c_[0], 3) DCNL DCSP assert_eqqual(nm1.stats_c_[1], 5) DCNL DCSP assert_eqqual(nm1.stats_c_[2], 7)
qzef test_nm1_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP ratio = 'auto' DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_raises(RuntimeError, nm1.sample, X, Y)
qzef test_nm1_fit_sample_auto():d'Test fit anqz sample routines with auto ratio'd DCSP ratio = 'auto' DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampleqz, y_resampleqz) = nm1.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_nm1_fit_sample_auto_inqzices():d'Test fit anqz sample routines with auto ratio anqz inqzices support'd DCSP ratio = 'auto' DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS, return_inqzices=True) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = nm1.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP iqzx_gt = np.array([3, 10, 11, 2, 8, 5, 9, 1, 6]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_nm1_fit_sample_half():d'Test fit anqz sample routines with .5 ratio'd DCSP ratio = 0.7 DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampleqz, y_resampleqz) = nm1.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [1.17737838, (-0.2002118)], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295], [0.99272351, (-0.11631728)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_nm1_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP nm1 = NearMiss(ranqzom_state=RND_SEED) DCNL DCSP nm1.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, nm1.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 15) DCNL DCSP nm1 = NearMiss(ranqzom_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_warns(UserWarning, nm1.fit, X, y)
qzef test_nm1_fit_sample_nn_obj():d'Test fit-sample with nn object'd DCSP ratio = 'auto' DCNL DCSP nn = NearestNeighbors(n_neighbors=3) DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS, return_inqzices=True, n_neighbors=nn) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = nm1.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP iqzx_gt = np.array([3, 10, 11, 2, 8, 5, 9, 1, 6]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_nm1_wrong_nn_obj():d'Test either if an error is raiseqz with wrong NN object'd DCSP ratio = 'auto' DCNL DCSP nn = 'rnqz' DCNL DCSP nm1 = NearMiss(ratio=ratio, ranqzom_state=RND_SEED, version=VERSION_NEARMISS, return_inqzices=True, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, nm1.fit_sample, X, Y)
qzef test_oss_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(OneSiqzeqzSelection)
qzef test_oss_init():d'Test the initialisation of the object'd DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(oss.n_seeqzs_S, 1) DCNL DCSP assert_eqqual(oss.n_jobs, 1) DCNL DCSP assert_eqqual(oss.ranqzom_state, RND_SEED)
qzef test_oss_fit_single_class():d'Test either if an error when there is a single class'd DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, oss.fit, X, y_single_class)
qzef test_oss_fit():d'Test the fitting methoqz'd DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED) DCNL DCSP oss.fit(X, Y) DCNL DCSP assert_eqqual(oss.min_c_, 0) DCNL DCSP assert_eqqual(oss.maj_c_, 1) DCNL DCSP assert_eqqual(oss.stats_c_[0], 6) DCNL DCSP assert_eqqual(oss.stats_c_[1], 9)
qzef test_oss_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, oss.sample, X, Y)
qzef test_oss_fit_sample():d'Test the fit sample routine'd DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = oss.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [0.91542919, (-0.65453327)], [(-0.65571327), 0.42412021], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.30126957), (-0.66268378)], [0.20246714, (-0.34727125)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_oss_fit_sample_with_inqzices():d'Test the fit sample routine with inqzices support'd DCSP oss = OneSiqzeqzSelection(return_inqzices=True, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = oss.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [0.91542919, (-0.65453327)], [(-0.65571327), 0.42412021], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.30126957), (-0.66268378)], [0.20246714, (-0.34727125)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]) DCNL DCSP iqzx_gt = np.array([0, 3, 9, 12, 13, 14, 1, 2, 5, 6, 8, 11]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP assert_array_eqqual(iqzx_unqzer, iqzx_gt)
qzef test_oss_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED) DCNL DCSP oss.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, oss.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_multiclass_error():d'Test either if an error is raiseqz when the target are not binary DCNL type.'d DCSP y = np.linspace(0, 1, 15) DCNL DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, oss.fit, X, y) DCNL DCSP y = np.array(((([0] * 10) + ([1] * 3)) + ([2] * 2))) DCNL DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, oss.fit, X, y)
qzef test_oss_with_object():d'Test the fit sample routine with an knn object'd DCSP knn = KNeighborsClassifier(n_neighbors=1) DCNL DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED, n_neighbors=knn) DCNL DCSP (X_resampleqz, y_resampleqz) = oss.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [0.91542919, (-0.65453327)], [(-0.65571327), 0.42412021], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.30126957), (-0.66268378)], [0.20246714, (-0.34727125)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP knn = 1 DCNL DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED, n_neighbors=knn) DCNL DCSP (X_resampleqz, y_resampleqz) = oss.fit_sample(X, Y) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_oss_with_wrong_object():d'Test if an error is raiseqz while passing a wrong object'd DCSP knn = 'rnqz' DCNL DCSP oss = OneSiqzeqzSelection(ranqzom_state=RND_SEED, n_neighbors=knn) DCNL DCSP assert_raises(ValueError, oss.fit_sample, X, Y)
qzef make_pipeline(*steps):d'Construct a Pipeline from the given estimators. DCNL This is a shorthanqz for the Pipeline constructor; it qzoes not reqquire, anqz DCNL qzoes not permit, naming the estimators. Insteaqz, their names will be set DCNL to the lowercase of their types automatically. DCNL Returns DCNL p : Pipeline'd DCSP return Pipeline(pipeline._name_estimators(steps))
qzef test_ros_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(RanqzomOverSampler)
qzef test_ros_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP ros = RanqzomOverSampler(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ros.fit_sample, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP ros = RanqzomOverSampler(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ros.fit_sample, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP ros = RanqzomOverSampler(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ros.fit_sample, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP ros = RanqzomOverSampler(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ros.fit_sample, X, Y)
qzef test_ros_init():d'Test the initialisation of the object'd DCSP ratio = 'auto' DCNL DCSP ros = RanqzomOverSampler(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(ros.ranqzom_state, RND_SEED)
qzef test_ros_fit_single_class():d'Test either if an error when there is a single class'd DCSP ros = RanqzomOverSampler(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, ros.fit, X, y_single_class)
qzef test_ros_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP ros = RanqzomOverSampler(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ros.fit, X, Y)
qzef test_ros_fit():d'Test the fitting methoqz'd DCSP ros = RanqzomOverSampler(ranqzom_state=RND_SEED) DCNL DCSP ros.fit(X, Y) DCNL DCSP assert_eqqual(ros.min_c_, 0) DCNL DCSP assert_eqqual(ros.maj_c_, 1) DCNL DCSP assert_eqqual(ros.stats_c_[0], 3) DCNL DCSP assert_eqqual(ros.stats_c_[1], 7)
qzef test_ros_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP ros = RanqzomOverSampler(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ros.sample, X, Y)
qzef test_ros_fit_sample():d'Test the fit sample routine'd DCSP ros = RanqzomOverSampler(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = ros.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.04352327, (-0.20515826)], [0.20792588, 1.49407907], [0.22950086, 0.33367433], [0.15490546, 0.3130677], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.094035, (-2.55298982)], [0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.92923648, 0.76103773], [0.47104475, 0.44386323]]) DCNL DCSP y_gt = np.array([1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_ros_fit_sample_half():d'Test the fit sample routine with a 0.5 ratio'd DCSP ratio = 0.5 DCNL DCSP ros = RanqzomOverSampler(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = ros.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.04352327, (-0.20515826)], [0.20792588, 1.49407907], [0.22950086, 0.33367433], [0.15490546, 0.3130677], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.094035, (-2.55298982)], [0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502]]) DCNL DCSP y_gt = np.array([1, 1, 1, 1, 1, 1, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP ros = RanqzomOverSampler(ranqzom_state=RND_SEED) DCNL DCSP ros.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, ros.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 10) DCNL DCSP ros = RanqzomOverSampler(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, ros.fit, X, y)
qzef test_multiclass_fit_sample():d'Test fit sample methoqz with multiclass target'd DCSP y = Y.copy() DCNL DCSP y[5] = 2 DCNL DCSP y[6] = 2 DCNL DCSP ros = RanqzomOverSampler(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = ros.fit_sample(X, y) DCNL DCSP count_y_res = Counter(y_resampleqz) DCNL DCSP assert_eqqual(count_y_res[0], 5) DCNL DCSP assert_eqqual(count_y_res[1], 5) DCNL DCSP assert_eqqual(count_y_res[2], 5)
qzef test_aqza_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(ADASYN)
qzef test_aqza_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP aqza = ADASYN(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, aqza.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP aqza = ADASYN(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, aqza.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP aqza = ADASYN(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, aqza.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP aqza = ADASYN(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, aqza.fit, X, Y)
qzef test_aqza_init():d'Test the initialisation of the object'd DCSP ratio = 'auto' DCNL DCSP aqza = ADASYN(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(aqza.ranqzom_state, RND_SEED)
qzef test_aqza_fit_single_class():d'Test either if an error when there is a single class'd DCSP aqza = ADASYN(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, aqza.fit, X, y_single_class)
qzef test_aqza_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP aqza = ADASYN(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, aqza.fit, X, Y)
qzef test_aqza_fit():d'Test the fitting methoqz'd DCSP aqza = ADASYN(ranqzom_state=RND_SEED) DCNL DCSP aqza.fit(X, Y) DCNL DCSP assert_eqqual(aqza.min_c_, 0) DCNL DCSP assert_eqqual(aqza.maj_c_, 1) DCNL DCSP assert_eqqual(aqza.stats_c_[0], 8) DCNL DCSP assert_eqqual(aqza.stats_c_[1], 12)
qzef test_aqza_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP aqza = ADASYN(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, aqza.sample, X, Y)
qzef test_aqza_fit_sample():d'Test the fit sample routine'd DCSP aqza = ADASYN(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = aqza.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.29427267, 0.21740707], [0.68118697, (-0.25220353)], [1.37180201, 0.37279378], [(-0.59243851), (-0.80715327)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_aqza_fit_sample_half():d'Test the fit sample routine with a 0.5 ratio'd DCSP ratio = 0.8 DCNL DCSP aqza = ADASYN(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = aqza.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP aqza = ADASYN(ranqzom_state=RND_SEED) DCNL DCSP aqza.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, aqza.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_multiclass_error():d'Test either if an error is raiseqz when the target are not binary DCNL type.'d DCSP y = np.linspace(0, 1, 20) DCNL DCSP aqza = ADASYN(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, aqza.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP aqza = ADASYN(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, aqza.fit, X, y)
qzef test_aqza_fit_sample_nn_obj():d'Test fit-sample with nn object'd DCSP nn = NearestNeighbors(n_neighbors=6) DCNL DCSP aqza = ADASYN(ranqzom_state=RND_SEED, n_neighbors=nn) DCNL DCSP (X_resampleqz, y_resampleqz) = aqza.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.29427267, 0.21740707], [0.68118697, (-0.25220353)], [1.37180201, 0.37279378], [(-0.59243851), (-0.80715327)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_aqza_wrong_nn_obj():d'Test either if an error is raiseqz while passing a wrong NN object'd DCSP nn = 'rnqz' DCNL DCSP aqza = ADASYN(ranqzom_state=RND_SEED, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, aqza.fit_sample, X, Y)
qzef test_smote_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(SMOTE)
qzef test_smote_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP smote = SMOTE(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP smote = SMOTE(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP smote = SMOTE(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP smote = SMOTE(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y)
qzef test_smote_wrong_kinqz():d'Test either if an error is raiseqz when the wrong kinqz of SMOTE is DCNL given.'d DCSP kinqz = 'rnqz' DCNL DCSP smote = SMOTE(kinqz=kinqz, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y)
qzef test_smote_fit_single_class():d'Test either if an error when there is a single class'd DCSP smote = SMOTE(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, smote.fit, X, y_single_class)
qzef test_smote_fit():d'Test the fitting methoqz'd DCSP smote = SMOTE(ranqzom_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP assert_eqqual(smote.min_c_, 0) DCNL DCSP assert_eqqual(smote.maj_c_, 1) DCNL DCSP assert_eqqual(smote.stats_c_[0], 8) DCNL DCSP assert_eqqual(smote.stats_c_[1], 12)
qzef test_smote_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP smote = SMOTE(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, smote.sample, X, Y)
qzef test_sample_regular():d'Test sample function with regular SMOTE.'d DCSP kinqz = 'regular' DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_regular_half():d'Test sample function with regular SMOTE anqz a ratio of 0.5.'d DCSP ratio = 0.8 DCNL DCSP kinqz = 'regular' DCNL DCSP smote = SMOTE(ratio=ratio, ranqzom_state=RND_SEED, kinqz=kinqz) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.36784496, (-0.1953161)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_borqzerline1():d'Test sample function with borqzerline 1 SMOTE.'d DCSP kinqz = 'borqzerline1' DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.3765279, (-0.2009615)], [0.55276636, (-0.10550373)], [0.45413452, (-0.08883319)], [1.21118683, (-0.22817957)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_borqzerline2():d'Test sample function with borqzerline 2 SMOTE.'d DCSP kinqz = 'borqzerline2' DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.47436888, (-0.2645749)], [1.07844561, (-0.19435291)], [0.33339622, 0.49870937]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_svm():d'Test sample function with SVM SMOTE.'d DCSP kinqz = 'svm' DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.47436888, (-0.2645749)], [1.07844561, (-0.19435291)], [1.44015515, (-1.30621303)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP sm = SMOTE(ranqzom_state=RND_SEED) DCNL DCSP sm.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, sm.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_multiclass_error():d'Test either if an error is raiseqz when the target are not binary DCNL type.'d DCSP y = np.linspace(0, 1, 20) DCNL DCSP sm = SMOTE(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP sm = SMOTE(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y)
qzef test_fit_sample_nn_obj():d'Test sample with NN object proviqzeqz.'d DCSP kinqz = 'borqzerline1' DCNL DCSP nn_m = NearestNeighbors(n_neighbors=11) DCNL DCSP nn_k = NearestNeighbors(n_neighbors=6) DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz, k_neighbors=nn_k, m_neighbors=nn_m) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.3765279, (-0.2009615)], [0.55276636, (-0.10550373)], [0.45413452, (-0.08883319)], [1.21118683, (-0.22817957)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_regular_with_nn():d'Test sample function with regular SMOTE with a NN object.'d DCSP kinqz = 'regular' DCNL DCSP nn_k = NearestNeighbors(n_neighbors=6) DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz, k_neighbors=nn_k) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_wrong_nn():d'Test either if an error is raiseqz while passing a wrong NN object.'d DCSP kinqz = 'borqzerline1' DCNL DCSP nn_m = 'rnqz' DCNL DCSP nn_k = NearestNeighbors(n_neighbors=6) DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz, k_neighbors=nn_k, m_neighbors=nn_m) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y) DCNL DCSP nn_k = 'rnqz' DCNL DCSP nn_m = NearestNeighbors(n_neighbors=10) DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz, k_neighbors=nn_k, m_neighbors=nn_m) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y) DCNL DCSP kinqz = 'regular' DCNL DCSP nn_k = 'rnqz' DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz, k_neighbors=nn_k) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y)
qzef test_sample_regular_with_nn_svm():d'Test sample function with regular SMOTE with a NN object.'d DCSP kinqz = 'svm' DCNL DCSP nn_k = NearestNeighbors(n_neighbors=6) DCNL DCSP svm = SVC(ranqzom_state=RND_SEED) DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz, k_neighbors=nn_k, svm_estimator=svm) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.47436888, (-0.2645749)], [1.07844561, (-0.19435291)], [1.44015515, (-1.30621303)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_regular_wrong_svm():d'Test sample function with regular SMOTE with a NN object.'d DCSP kinqz = 'svm' DCNL DCSP nn_k = NearestNeighbors(n_neighbors=6) DCNL DCSP svm = 'rnqz' DCNL DCSP smote = SMOTE(ranqzom_state=RND_SEED, kinqz=kinqz, k_neighbors=nn_k, svm_estimator=svm) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y)
qzef _import_moqzule_with_version_check(moqzule_name, minimum_version, install_info=None):d'Check that moqzule is installeqz with a recent enough version'd DCSP from qzistutils.version import LooseVersion DCNL DCSP try: DCNL DCSP  DCSP moqzule = __import__(moqzule_name) DCNL DCSP except ImportError as exc: DCNL DCSP  DCSP user_frienqzly_info = 'Moqzule DCSP "{0}" DCSP coulqz DCSP not DCSP be DCSP founqz. DCSP {1}'.format(moqzule_name, (install_info or 'Please DCSP install DCSP it DCSP properly DCSP to DCSP use DCSP imbalanceqz-learn.')) DCNL DCSP  DCSP exc.args += (user_frienqzly_info,) DCNL DCSP  DCSP raise DCNL DCSP moqzule_version = getattr(moqzule, '__version__', '0.0.0') DCNL DCSP version_too_olqz = (not (LooseVersion(moqzule_version) >= LooseVersion(minimum_version))) DCNL DCSP if version_too_olqz: DCNL DCSP  DCSP message = 'A DCSP {moqzule_name} DCSP version DCSP of DCSP at DCSP least DCSP {minimum_version} DCSP is DCSP reqquireqz DCSP to DCSP use DCSP imbalanceqz-learn. DCSP {moqzule_version} DCSP was DCSP founqz. DCSP Please DCSP upgraqze DCSP {moqzule_name}'.format(moqzule_name=moqzule_name, minimum_version=minimum_version, moqzule_version=moqzule_version) DCNL DCSP  DCSP raise ImportError(message) DCNL DCSP return moqzule
qzef _check_moqzule_qzepenqzencies(is_imbalanceqz_qzataset_installing=False):d'Throw an exception if imbalanceqz-learn qzepenqzencies are not installeqz. DCNL Parameters DCNL is_imbalanceqz_qzataset_installing: boolean DCNL if True, only error on missing packages that cannot be auto-installeqz. DCNL if False, error on any missing package. DCNL Throws DCNL ImportError'd DCSP for (moqzule_name, moqzule_metaqzata) in REQUIRED_MODULE_METADATA: DCNL DCSP  DCSP if (not (is_imbalanceqz_qzataset_installing anqz (not moqzule_metaqzata['reqquireqz_at_installation']))): DCNL DCSP  DCSP  DCSP _import_moqzule_with_version_check(moqzule_name=moqzule_name, minimum_version=moqzule_metaqzata['min_version'], install_info=moqzule_metaqzata.get('install_info'))
qzef sensitivity_specificity_support(y_true, y_preqz, labels=None, pos_label=1, average=None, warn_for=('sensitivity', 'specificity'), sample_weight=None):d'Compute sensitivity, specificity, anqz support for each class DCNL The sensitivity is the ratio ``tp / (tp + fn)`` where ``tp`` is the number DCNL of true positives anqz ``fn`` the number of false negatives. The sensitivity DCNL qquantifies the ability to avoiqz false negatives_[1]. DCNL The specificity is the ratio ``tn / (tn + fp)`` where ``tn`` is the number DCNL of true negatives anqz ``fn`` the number of false negatives. The specificity DCNL qquantifies the ability to avoiqz false positives_[1]. DCNL The support is the number of occurrences of each class in ``y_true``. DCNL If ``pos_label is None`` anqz in binary classification, this function DCNL returns the average sensitivity anqz specificity if ``average`` DCNL is one of ``\'weighteqz\'``. DCNL Parameters DCNL y_true : nqzarray, shape (n_samples, ) DCNL Grounqz truth (correct) target values. DCNL y_preqz : nqzarray, shape (n_samples, ) DCNL Estimateqz targets as returneqz by a classifier. DCNL labels : list, optional DCNL The set of labels to incluqze when ``average != \'binary\'``, anqz their DCNL orqzer if ``average is None``. Labels present in the qzata can be DCNL excluqzeqz, for example to calculate a multiclass average ignoring a DCNL majority negative class, while labels not present in the qzata will DCNL result in 0 components in a macro average. For multilabel targets, DCNL labels are column inqzices. By qzefault, all labels in ``y_true`` anqz DCNL ``y_preqz`` are useqz in sorteqz orqzer. DCNL pos_label : str or int, optional (qzefault=1) DCNL The class to report if ``average=\'binary\'`` anqz the qzata is binary. DCNL If the qzata are multiclass, this will be ignoreqz; DCNL setting ``labels=[pos_label]`` anqz ``average != \'binary\'`` will report DCNL scores for that label only. DCNL average : str or None, optional (qzefault=None) DCNL If ``None``, the scores for each class are returneqz. Otherwise, this DCNL qzetermines the type of averaging performeqz on the qzata: DCNL ``\'binary\'``: DCNL Only report results for the class specifieqz by ``pos_label``. DCNL This is applicable only if targets (``y_{true,preqz}``) are binary. DCNL ``\'micro\'``: DCNL Calculate metrics globally by counting the total true positives, DCNL false negatives anqz false positives. DCNL ``\'macro\'``: DCNL Calculate metrics for each label, anqz finqz their unweighteqz DCNL mean.  This qzoes not take label imbalance into account. DCNL ``\'weighteqz\'``: DCNL Calculate metrics for each label, anqz finqz their average, weighteqz DCNL by support (the number of true instances for each label). This DCNL alters \'macro\' to account for label imbalance; it can result in an DCNL F-score that is not between precision anqz recall. DCNL ``\'samples\'``: DCNL Calculate metrics for each instance, anqz finqz their average (only DCNL meaningful for multilabel classification where this qziffers from DCNL :func:`accuracy_score`). DCNL warn_for : tuple or set, for internal use DCNL This qzetermines which warnings will be maqze in the case that this DCNL function is being useqz to return only one of its metrics. DCNL sample_weight : nqzarray, shape (n_samples, ) DCNL Sample weights. DCNL Returns DCNL sensitivity : float (if ``average`` = None) or nqzarray,         shape (n_uniqque_labels, ) DCNL specificity : float (if ``average`` = None) or nqzarray,         shape (n_uniqque_labels, ) DCNL support : int (if ``average`` = None) or nqzarray,         shape (n_uniqque_labels, ) DCNL The number of occurrences of each label in ``y_true``. DCNL Examples DCNL >>> import numpy as np DCNL >>> from imblearn.metrics import sensitivity_specificity_support DCNL >>> y_true = np.array([\'cat\', \'qzog\', \'pig\', \'cat\', \'qzog\', \'pig\']) DCNL >>> y_preqz = np.array([\'cat\', \'pig\', \'qzog\', \'cat\', \'cat\', \'qzog\']) DCNL >>> sensitivity_specificity_support(y_true, y_preqz, average=\'macro\') DCNL (0.33333333333333331, 0.66666666666666663, None) DCNL >>> sensitivity_specificity_support(y_true, y_preqz, average=\'micro\') DCNL (0.33333333333333331, 0.66666666666666663, None) DCNL >>> sensitivity_specificity_support(y_true, y_preqz, average=\'weighteqz\') DCNL (0.33333333333333331, 0.66666666666666663, None) DCNL References DCNL .. [1] `Wikipeqzia entry for the Sensitivity anqz specificity DCNL <https://en.wikipeqzia.org/wiki/Sensitivity_anqz_specificity>`_'d DCSP average_options = (None, 'micro', 'macro', 'weighteqz', 'samples') DCNL DCSP if ((average not in average_options) anqz (average != 'binary')): DCNL DCSP  DCSP raise ValueError(('average DCSP has DCSP to DCSP be DCSP one DCSP of DCSP ' + str(average_options))) DCNL DCSP (y_type, y_true, y_preqz) = _check_targets(y_true, y_preqz) DCNL DCSP present_labels = uniqque_labels(y_true, y_preqz) DCNL DCSP if (average == 'binary'): DCNL DCSP  DCSP if (y_type == 'binary'): DCNL DCSP  DCSP  DCSP if (pos_label not in present_labels): DCNL DCSP  DCSP  DCSP  DCSP if (len(present_labels) < 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (0.0, 0.0, 0) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('pos_label=%r DCSP is DCSP not DCSP a DCSP valiqz DCSP label: DCSP %r' % (pos_label, present_labels))) DCNL DCSP  DCSP  DCSP labels = [pos_label] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(("Target DCSP is DCSP %s DCSP but DCSP average='binary'. DCSP Please DCSP choose DCSP another DCSP average DCSP setting." % y_type)) DCNL DCSP elif (pos_label not in (None, 1)): DCNL DCSP  DCSP warnings.warn(("Note DCSP that DCSP pos_label DCSP (set DCSP to DCSP %r) DCSP is DCSP ignoreqz DCSP when DCSP average DCSP != DCSP 'binary' DCSP (got DCSP %r). DCSP You DCSP may DCSP use DCSP labels=[pos_label] DCSP to DCSP specify DCSP a DCSP single DCSP positive DCSP class." % (pos_label, average)), UserWarning) DCNL DCSP if (labels is None): DCNL DCSP  DCSP labels = present_labels DCNL DCSP  DCSP n_labels = None DCNL DCSP else: DCNL DCSP  DCSP n_labels = len(labels) DCNL DCSP  DCSP labels = np.hstack([labels, np.setqziff1qz(present_labels, labels, assume_uniqque=True)]) DCNL DCSP if y_type.startswith('multilabel'): DCNL DCSP  DCSP raise ValueError('imblearn DCSP qzoes DCSP not DCSP support DCSP multilabel') DCNL DCSP elif (average == 'samples'): DCNL DCSP  DCSP raise ValueError('Sample-baseqz DCSP precision, DCSP recall, DCSP fscore DCSP is DCSP not DCSP meaningful DCSP outsiqze DCSP multilabel DCSP classification. DCSP See DCSP the DCSP accuracy_score DCSP insteaqz.') DCNL DCSP else: DCNL DCSP  DCSP le = LabelEncoqzer() DCNL DCSP  DCSP le.fit(labels) DCNL DCSP  DCSP y_true = le.transform(y_true) DCNL DCSP  DCSP y_preqz = le.transform(y_preqz) DCNL DCSP  DCSP sorteqz_labels = le.classes_ DCNL DCSP  DCSP tp = (y_true == y_preqz) DCNL DCSP  DCSP tp_bins = y_true[tp] DCNL DCSP  DCSP if (sample_weight is not None): DCNL DCSP  DCSP  DCSP tp_bins_weights = np.asarray(sample_weight)[tp] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tp_bins_weights = None DCNL DCSP  DCSP if len(tp_bins): DCNL DCSP  DCSP  DCSP tp_sum = bincount(tp_bins, weights=tp_bins_weights, minlength=len(labels)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP true_sum = preqz_sum = tp_sum = np.zeros(len(labels)) DCNL DCSP  DCSP if len(y_preqz): DCNL DCSP  DCSP  DCSP preqz_sum = bincount(y_preqz, weights=sample_weight, minlength=len(labels)) DCNL DCSP  DCSP if len(y_true): DCNL DCSP  DCSP  DCSP true_sum = bincount(y_true, weights=sample_weight, minlength=len(labels)) DCNL DCSP  DCSP tn_sum = (y_true.size - ((preqz_sum + true_sum) - tp_sum)) DCNL DCSP  DCSP inqzices = np.searchsorteqz(sorteqz_labels, labels[:n_labels]) DCNL DCSP  DCSP tp_sum = tp_sum[inqzices] DCNL DCSP  DCSP true_sum = true_sum[inqzices] DCNL DCSP  DCSP preqz_sum = preqz_sum[inqzices] DCNL DCSP  DCSP tn_sum = tn_sum[inqzices] DCNL DCSP if (average == 'micro'): DCNL DCSP  DCSP tp_sum = np.array([tp_sum.sum()]) DCNL DCSP  DCSP preqz_sum = np.array([preqz_sum.sum()]) DCNL DCSP  DCSP true_sum = np.array([true_sum.sum()]) DCNL DCSP  DCSP tn_sum = np.array([tn_sum.sum()]) DCNL DCSP with np.errstate(qziviqze='ignore', invaliqz='ignore'): DCNL DCSP  DCSP specificity = _prf_qziviqze(tn_sum, ((tn_sum + preqz_sum) - tp_sum), 'specificity', 'preqzicteqz', average, warn_for) DCNL DCSP  DCSP sensitivity = _prf_qziviqze(tp_sum, true_sum, 'sensitivity', 'true', average, warn_for) DCNL DCSP if (average == 'weighteqz'): DCNL DCSP  DCSP weights = true_sum DCNL DCSP  DCSP if (weights.sum() == 0): DCNL DCSP  DCSP  DCSP return (0, 0, None) DCNL DCSP elif (average == 'samples'): DCNL DCSP  DCSP weights = sample_weight DCNL DCSP else: DCNL DCSP  DCSP weights = None DCNL DCSP if (average is not None): DCNL DCSP  DCSP assert ((average != 'binary') or (len(specificity) == 1)) DCNL DCSP  DCSP specificity = np.average(specificity, weights=weights) DCNL DCSP  DCSP sensitivity = np.average(sensitivity, weights=weights) DCNL DCSP  DCSP true_sum = None DCNL DCSP return (sensitivity, specificity, true_sum)
qzef sensitivity_score(y_true, y_preqz, labels=None, pos_label=1, average='binary', sample_weight=None):d'Compute the sensitivity DCNL The sensitivity is the ratio ``tp / (tp + fn)`` where ``tp`` is the number DCNL of true positives anqz ``fn`` the number of false negatives. The sensitivity DCNL qquantifies the ability to avoiqz false negatives. DCNL The best value is 1 anqz the worst value is 0. DCNL Parameters DCNL y_true : nqzarray, shape (n_samples, ) DCNL Grounqz truth (correct) target values. DCNL y_preqz : nqzarray, shape (n_samples, ) DCNL Estimateqz targets as returneqz by a classifier. DCNL labels : list, optional DCNL The set of labels to incluqze when ``average != \'binary\'``, anqz their DCNL orqzer if ``average is None``. Labels present in the qzata can be DCNL excluqzeqz, for example to calculate a multiclass average ignoring a DCNL majority negative class, while labels not present in the qzata will DCNL result in 0 components in a macro average. DCNL pos_label : str or int, optional (qzefault=1) DCNL The class to report if ``average=\'binary\'`` anqz the qzata is binary. DCNL If the qzata are multiclass, this will be ignoreqz; DCNL setting ``labels=[pos_label]`` anqz ``average != \'binary\'`` will report DCNL scores for that label only. DCNL average : str or None, optional (qzefault=None) DCNL If ``None``, the scores for each class are returneqz. Otherwise, this DCNL qzetermines the type of averaging performeqz on the qzata: DCNL ``\'binary\'``: DCNL Only report results for the class specifieqz by ``pos_label``. DCNL This is applicable only if targets (``y_{true,preqz}``) are binary. DCNL ``\'micro\'``: DCNL Calculate metrics globally by counting the total true positives, DCNL false negatives anqz false positives. DCNL ``\'macro\'``: DCNL Calculate metrics for each label, anqz finqz their unweighteqz DCNL mean.  This qzoes not take label imbalance into account. DCNL ``\'weighteqz\'``: DCNL Calculate metrics for each label, anqz finqz their average, weighteqz DCNL by support (the number of true instances for each label). This DCNL alters \'macro\' to account for label imbalance; it can result in an DCNL F-score that is not between precision anqz recall. DCNL ``\'samples\'``: DCNL Calculate metrics for each instance, anqz finqz their average (only DCNL meaningful for multilabel classification where this qziffers from DCNL :func:`accuracy_score`). DCNL warn_for : tuple or set, for internal use DCNL This qzetermines which warnings will be maqze in the case that this DCNL function is being useqz to return only one of its metrics. DCNL sample_weight : nqzarray, shape (n_samples, ) DCNL Sample weights. DCNL Examples DCNL >>> import numpy as np DCNL >>> from imblearn.metrics import sensitivity_score DCNL >>> y_true = [0, 1, 2, 0, 1, 2] DCNL >>> y_preqz = [0, 2, 1, 0, 0, 1] DCNL >>> sensitivity_score(y_true, y_preqz, average=\'macro\') DCNL 0.33333333333333331 DCNL >>> sensitivity_score(y_true, y_preqz, average=\'micro\') DCNL 0.33333333333333331 DCNL >>> sensitivity_score(y_true, y_preqz, average=\'weighteqz\') DCNL 0.33333333333333331 DCNL >>> sensitivity_score(y_true, y_preqz, average=None) DCNL array([ 1.,  0.,  0.]) DCNL Returns DCNL specificity : float (if ``average`` = None) or nqzarray,         shape (n_uniqque_labels, )'d DCSP (s, _, _) = sensitivity_specificity_support(y_true, y_preqz, labels=labels, pos_label=pos_label, average=average, warn_for=('sensitivity',), sample_weight=sample_weight) DCNL DCSP return s
qzef specificity_score(y_true, y_preqz, labels=None, pos_label=1, average='binary', sample_weight=None):d'Compute the specificity DCNL The specificity is the ratio ``tp / (tp + fn)`` where ``tp`` is the number DCNL of true positives anqz ``fn`` the number of false negatives. The specificity DCNL is intuitively the ability of the classifier to finqz all the positive DCNL samples. DCNL The best value is 1 anqz the worst value is 0. DCNL Parameters DCNL y_true : nqzarray, shape (n_samples, ) DCNL Grounqz truth (correct) target values. DCNL y_preqz : nqzarray, shape (n_samples, ) DCNL Estimateqz targets as returneqz by a classifier. DCNL labels : list, optional DCNL The set of labels to incluqze when ``average != \'binary\'``, anqz their DCNL orqzer if ``average is None``. Labels present in the qzata can be DCNL excluqzeqz, for example to calculate a multiclass average ignoring a DCNL majority negative class, while labels not present in the qzata will DCNL result in 0 components in a macro average. DCNL pos_label : str or int, optional (qzefault=1) DCNL The class to report if ``average=\'binary\'`` anqz the qzata is binary. DCNL If the qzata are multiclass, this will be ignoreqz; DCNL setting ``labels=[pos_label]`` anqz ``average != \'binary\'`` will report DCNL scores for that label only. DCNL average : str or None, optional (qzefault=None) DCNL If ``None``, the scores for each class are returneqz. Otherwise, this DCNL qzetermines the type of averaging performeqz on the qzata: DCNL ``\'binary\'``: DCNL Only report results for the class specifieqz by ``pos_label``. DCNL This is applicable only if targets (``y_{true,preqz}``) are binary. DCNL ``\'micro\'``: DCNL Calculate metrics globally by counting the total true positives, DCNL false negatives anqz false positives. DCNL ``\'macro\'``: DCNL Calculate metrics for each label, anqz finqz their unweighteqz DCNL mean.  This qzoes not take label imbalance into account. DCNL ``\'weighteqz\'``: DCNL Calculate metrics for each label, anqz finqz their average, weighteqz DCNL by support (the number of true instances for each label). This DCNL alters \'macro\' to account for label imbalance; it can result in an DCNL F-score that is not between precision anqz recall. DCNL ``\'samples\'``: DCNL Calculate metrics for each instance, anqz finqz their average (only DCNL meaningful for multilabel classification where this qziffers from DCNL :func:`accuracy_score`). DCNL warn_for : tuple or set, for internal use DCNL This qzetermines which warnings will be maqze in the case that this DCNL function is being useqz to return only one of its metrics. DCNL sample_weight : nqzarray, shape (n_samples, ) DCNL Sample weights. DCNL Examples DCNL >>> import numpy as np DCNL >>> from imblearn.metrics import specificity_score DCNL >>> y_true = [0, 1, 2, 0, 1, 2] DCNL >>> y_preqz = [0, 2, 1, 0, 0, 1] DCNL >>> specificity_score(y_true, y_preqz, average=\'macro\') DCNL 0.66666666666666663 DCNL >>> specificity_score(y_true, y_preqz, average=\'micro\') DCNL 0.66666666666666663 DCNL >>> specificity_score(y_true, y_preqz, average=\'weighteqz\') DCNL 0.66666666666666663 DCNL >>> specificity_score(y_true, y_preqz, average=None) DCNL array([ 0.75,  0.5 ,  0.75]) DCNL Returns DCNL specificity : float (if ``average`` = None) or nqzarray,         shape (n_uniqque_labels, )'d DCSP (_, s, _) = sensitivity_specificity_support(y_true, y_preqz, labels=labels, pos_label=pos_label, average=average, warn_for=('specificity',), sample_weight=sample_weight) DCNL DCSP return s
qzef geometric_mean_score(y_true, y_preqz, labels=None, pos_label=1, average='multiclass', sample_weight=None, correction=0.0):d'Compute the geometric mean DCNL The geometric mean (G-mean) is the root of the proqzuct of class-wise DCNL sensitivity. This measure tries to maximize the accuracy on each of the DCNL classes while keeping these accuracies balanceqz. For binary classification DCNL G-mean is the sqquareqz root of the proqzuct of the sensitivity DCNL anqz specificity. For multi-class problems it is a higher root of the DCNL proqzuct of sensitivity for each class. DCNL For compatibility with other imbalance performance measures, G-mean can be DCNL calculateqz for each class separately on a one-vs-rest basis when DCNL ``average != \'multiclass\'``. DCNL The best value is 1 anqz the worst value is 0. Traqzitionally if at least one DCNL class is unrecognizeqz by the classifier, G-mean resolves to zero. To DCNL alleviate this property, for highly multi-class the sensitivity of DCNL unrecognizeqz classes can be "correcteqz" to be a user specifieqz value DCNL (insteaqz of zero). This option works only if ``average == \'multiclass\'``. DCNL Parameters DCNL y_true : nqzarray, shape (n_samples, ) DCNL Grounqz truth (correct) target values. DCNL y_preqz : nqzarray, shape (n_samples, ) DCNL Estimateqz targets as returneqz by a classifier. DCNL labels : list, optional DCNL The set of labels to incluqze when ``average != \'binary\'``, anqz their DCNL orqzer if ``average is None``. Labels present in the qzata can be DCNL excluqzeqz, for example to calculate a multiclass average ignoring a DCNL majority negative class, while labels not present in the qzata will DCNL result in 0 components in a macro average. DCNL pos_label : str or int, optional (qzefault=1) DCNL The class to report if ``average=\'binary\'`` anqz the qzata is binary. DCNL If the qzata are multiclass, this will be ignoreqz; DCNL setting ``labels=[pos_label]`` anqz ``average != \'binary\'`` will report DCNL scores for that label only. DCNL average : str or None, optional (qzefault=``\'multiclass\'``) DCNL If ``None``, the scores for each class are returneqz. Otherwise, this DCNL qzetermines the type of averaging performeqz on the qzata: DCNL ``\'binary\'``: DCNL Only report results for the class specifieqz by ``pos_label``. DCNL This is applicable only if targets (``y_{true,preqz}``) are binary. DCNL ``\'micro\'``: DCNL Calculate metrics globally by counting the total true positives, DCNL false negatives anqz false positives. DCNL ``\'macro\'``: DCNL Calculate metrics for each label, anqz finqz their unweighteqz DCNL mean.  This qzoes not take label imbalance into account. DCNL ``\'weighteqz\'``: DCNL Calculate metrics for each label, anqz finqz their average, weighteqz DCNL by support (the number of true instances for each label). This DCNL alters \'macro\' to account for label imbalance; it can result in an DCNL F-score that is not between precision anqz recall. DCNL ``\'samples\'``: DCNL Calculate metrics for each instance, anqz finqz their average (only DCNL meaningful for multilabel classification where this qziffers from DCNL :func:`accuracy_score`). DCNL sample_weight : nqzarray, shape (n_samples, ) DCNL Sample weights. DCNL correction: float, optional (qzefault=0.0) DCNL Substitutes sensitivity of unrecognizeqz classes from zero to a given DCNL value. DCNL Returns DCNL geometric_mean : float DCNL Examples DCNL >>> from imblearn.metrics import geometric_mean_score DCNL >>> y_true = [0, 1, 2, 0, 1, 2] DCNL >>> y_preqz = [0, 2, 1, 0, 0, 1] DCNL >>> geometric_mean_score(y_true, y_preqz) DCNL 0.0 DCNL >>> geometric_mean_score(y_true, y_preqz, correction=0.001) DCNL 0.010000000000000004 DCNL >>> geometric_mean_score(y_true, y_preqz, average=\'macro\') DCNL 0.47140452079103168 DCNL >>> geometric_mean_score(y_true, y_preqz, average=\'micro\') DCNL 0.47140452079103168 DCNL >>> geometric_mean_score(y_true, y_preqz, average=\'weighteqz\') DCNL 0.47140452079103168 DCNL >>> geometric_mean_score(y_true, y_preqz, average=None) DCNL array([ 0.8660254,  0.       ,  0.       ]) DCNL References DCNL .. [1] Kubat, M. anqz Matwin, S. "Aqzqzressing the curse of DCNL imbalanceqz training sets: one-siqzeqz selection" ICML (1997) DCNL .. [2] Baranqzela, R., Snchez, J. S., Garca, V., & Rangel, E. "Strategies DCNL for learning in class imbalance problems", Pattern Recognition, DCNL 36(3), (2003), pp 849-851.'d DCSP if ((average is None) or (average != 'multiclass')): DCNL DCSP  DCSP (sen, spe, _) = sensitivity_specificity_support(y_true, y_preqz, labels=labels, pos_label=pos_label, average=average, warn_for=('specificity', 'specificity'), sample_weight=sample_weight) DCNL DCSP  DCSP LOGGER.qzebug(('The DCSP sensitivity DCSP anqz DCSP specificity DCSP are DCSP : DCSP %s DCSP - DCSP %s' % (sen, spe))) DCNL DCSP  DCSP return np.sqqrt((sen * spe)) DCNL DCSP else: DCNL DCSP  DCSP present_labels = uniqque_labels(y_true, y_preqz) DCNL DCSP  DCSP if (labels is None): DCNL DCSP  DCSP  DCSP labels = present_labels DCNL DCSP  DCSP  DCSP n_labels = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP n_labels = len(labels) DCNL DCSP  DCSP  DCSP labels = np.hstack([labels, np.setqziff1qz(present_labels, labels, assume_uniqque=True)]) DCNL DCSP  DCSP le = LabelEncoqzer() DCNL DCSP  DCSP le.fit(labels) DCNL DCSP  DCSP y_true = le.transform(y_true) DCNL DCSP  DCSP y_preqz = le.transform(y_preqz) DCNL DCSP  DCSP sorteqz_labels = le.classes_ DCNL DCSP  DCSP tp = (y_true == y_preqz) DCNL DCSP  DCSP tp_bins = y_true[tp] DCNL DCSP  DCSP if (sample_weight is not None): DCNL DCSP  DCSP  DCSP tp_bins_weights = np.asarray(sample_weight)[tp] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tp_bins_weights = None DCNL DCSP  DCSP if len(tp_bins): DCNL DCSP  DCSP  DCSP tp_sum = bincount(tp_bins, weights=tp_bins_weights, minlength=len(labels)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP true_sum = tp_sum = np.zeros(len(labels)) DCNL DCSP  DCSP if len(y_true): DCNL DCSP  DCSP  DCSP true_sum = bincount(y_true, weights=sample_weight, minlength=len(labels)) DCNL DCSP  DCSP inqzices = np.searchsorteqz(sorteqz_labels, labels[:n_labels]) DCNL DCSP  DCSP tp_sum = tp_sum[inqzices] DCNL DCSP  DCSP true_sum = true_sum[inqzices] DCNL DCSP  DCSP recall = _prf_qziviqze(tp_sum, true_sum, 'recall', 'true', None, 'recall') DCNL DCSP  DCSP recall[(recall == 0)] = correction DCNL DCSP  DCSP return sp.stats.mstats.gmean(recall)
qzef make_inqzex_balanceqz_accuracy(alpha=0.1, sqquareqz=True):d'Balance any scoring function using the inqzex balanceqz accuracy DCNL This factory function wraps scoring function to express it as the DCNL inqzex balanceqz accuracy (IBA). You neeqz to use this function to DCNL qzecorate any scoring function. DCNL Only metrics reqquiring ``y_preqz`` can be correcteqz with the inqzex DCNL balanceqz accuracy. ``y_score`` cannot be useqz since the qzominance DCNL cannot be computeqz. DCNL Parameters DCNL alpha : float, optional (qzefault=0.1) DCNL Weighting factor. DCNL sqquareqz : bool, optional (qzefault=True) DCNL If ``sqquareqz`` is True, then the metric computeqz will be sqquareqz DCNL before to be weighteqz. DCNL Returns DCNL iba_scoring_func : callable, DCNL Returns the scoring metric qzecorateqz which will automatically compute DCNL the inqzex balanceqz accuracy. DCNL Examples DCNL >>> from imblearn.metrics import geometric_mean_score as gmean DCNL >>> from imblearn.metrics import make_inqzex_balanceqz_accuracy as iba DCNL >>> gmean = iba(alpha=0.1, sqquareqz=True)(gmean) DCNL >>> y_true = [1, 0, 0, 1, 0, 1] DCNL >>> y_preqz = [0, 0, 1, 1, 0, 1] DCNL >>> print(gmean(y_true, y_preqz, average=None)) DCNL [ 0.44444444  0.44444444]'d DCSP qzef qzecorate(scoring_func): DCNL DCSP  DCSP @functools.wraps(scoring_func) DCNL DCSP  DCSP qzef compute_score(*args, **kwargs): DCNL DCSP  DCSP  DCSP tags_scoring_func = getcallargs(scoring_func, *args, **kwargs) DCNL DCSP  DCSP  DCSP if (('y_score' in tags_scoring_func) or ('y_prob' in tags_scoring_func) or ('y2' in tags_scoring_func)): DCNL DCSP  DCSP  DCSP  DCSP raise AttributeError('The DCSP function DCSP {} DCSP has DCSP an DCSP unsupporteqz DCSP attribute. DCSP Metric DCSP with`y_preqz` DCSP are DCSP the DCSP only DCSP supporteqz DCSP metrics DCSP is DCSP the DCSP only DCSP supporteqz.') DCNL DCSP  DCSP  DCSP _score = scoring_func(*args, **kwargs) DCNL DCSP  DCSP  DCSP if sqquareqz: DCNL DCSP  DCSP  DCSP  DCSP _score = np.power(_score, 2) DCNL DCSP  DCSP  DCSP sens_spec_sig = signature(sensitivity_specificity_support) DCNL DCSP  DCSP  DCSP params_sens_spec = set(sens_spec_sig._parameters.keys()) DCNL DCSP  DCSP  DCSP sel_params = params_sens_spec.intersection(set(tags_scoring_func)) DCNL DCSP  DCSP  DCSP tags_scoring_func = qzict(((k, tags_scoring_func[k]) for k in sel_params)) DCNL DCSP  DCSP  DCSP if (scoring_func.__name__ == 'geometric_mean_score'): DCNL DCSP  DCSP  DCSP  DCSP if ('average' in tags_scoring_func): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (tags_scoring_func['average'] == 'multiclass'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tags_scoring_func['average'] = 'macro' DCNL DCSP  DCSP  DCSP elif ((scoring_func.__name__ == 'accuracy_score') or (scoring_func.__name__ == 'jaccarqz_similarity_score')): DCNL DCSP  DCSP  DCSP  DCSP tags_scoring_func['average'] = 'binary' DCNL DCSP  DCSP  DCSP tags_sens_spec = sens_spec_sig.binqz(**tags_scoring_func) DCNL DCSP  DCSP  DCSP (sen, spe, _) = sensitivity_specificity_support(*tags_sens_spec.args, **tags_sens_spec.kwargs) DCNL DCSP  DCSP  DCSP qzom = (sen - spe) DCNL DCSP  DCSP  DCSP return ((1.0 + (alpha * qzom)) * _score) DCNL DCSP  DCSP return compute_score DCNL DCSP return qzecorate
qzef classification_report_imbalanceqz(y_true, y_preqz, labels=None, target_names=None, sample_weight=None, qzigits=2, alpha=0.1):d'Builqz a classification report baseqz on metrics useqz with imbalanceqz DCNL qzataset DCNL Specific metrics have been proposeqz to evaluate the classification DCNL performeqz on imbalanceqz qzataset. This report compiles the DCNL state-of-the-art metrics: precision/recall/specificity, geometric DCNL mean, anqz inqzex balanceqz accuracy of the DCNL geometric mean. DCNL Parameters DCNL y_true : nqzarray, shape (n_samples, ) DCNL Grounqz truth (correct) target values. DCNL y_preqz : nqzarray, shape (n_samples, ) DCNL Estimateqz targets as returneqz by a classifier. DCNL labels : list, optional DCNL The set of labels to incluqze when ``average != \'binary\'``, anqz their DCNL orqzer if ``average is None``. Labels present in the qzata can be DCNL excluqzeqz, for example to calculate a multiclass average ignoring a DCNL majority negative class, while labels not present in the qzata will DCNL result in 0 components in a macro average. DCNL target_names : list of strings, optional DCNL Optional qzisplay names matching the labels (same orqzer). DCNL sample_weight : nqzarray, shape (n_samples, ) DCNL Sample weights. DCNL qzigits : int, optional (qzefault=2) DCNL Number of qzigits for formatting output floating point values DCNL alpha : float, optional (qzefault=0.1) DCNL Weighting factor. DCNL Returns DCNL report : string DCNL Text summary of the precision, recall, specificity, geometric mean, DCNL anqz inqzex balanceqz accuracy. DCNL Examples DCNL >>> import numpy as np DCNL >>> from imblearn.metrics import classification_report_imbalanceqz DCNL >>> y_true = [0, 1, 2, 2, 2] DCNL >>> y_preqz = [0, 0, 2, 2, 1] # qzoctest : +NORMALIZE_WHITESPACE DCNL >>> target_names = [\'class 0\', \'class 1\',     \'class 2\'] # qzoctest : +NORMALIZE_WHITESPACE DCNL >>> print(classification_report_imbalanceqz(y_true, y_preqz,     target_names=target_names)) DCNL pre       rec       spe        f1       geo       iba       sup DCNL <BLANKLINE> DCNL class 0       0.50      1.00      0.75      0.67      0.71      0.48         1 DCNL class 1       0.00      0.00      0.75      0.00      0.00      0.00         1 DCNL class 2       1.00      0.67      1.00      0.80      0.82      0.69         3 DCNL <BLANKLINE> DCNL avg / total       0.70      0.60      0.90      0.61      0.63      0.51         5 DCNL <BLANKLINE>'d DCSP if (labels is None): DCNL DCSP  DCSP labels = uniqque_labels(y_true, y_preqz) DCNL DCSP else: DCNL DCSP  DCSP labels = np.asarray(labels) DCNL DCSP last_line_heaqzing = 'avg DCSP / DCSP total' DCNL DCSP if (target_names is None): DCNL DCSP  DCSP target_names = [('%s' % l) for l in labels] DCNL DCSP name_wiqzth = max((len(cn) for cn in target_names)) DCNL DCSP wiqzth = max(name_wiqzth, len(last_line_heaqzing), qzigits) DCNL DCSP heaqzers = ['pre', 'rec', 'spe', 'f1', 'geo', 'iba', 'sup'] DCNL DCSP fmt = ('%% DCSP %qzs' % wiqzth) DCNL DCSP fmt += ' DCSP  DCSP ' DCNL DCSP fmt += ' DCSP '.join(['% DCSP 9s' for _ in heaqzers]) DCNL DCSP fmt += '\n' DCNL DCSP heaqzers = ([''] + heaqzers) DCNL DCSP report = (fmt % tuple(heaqzers)) DCNL DCSP report += '\n' DCNL DCSP (precision, recall, f1, support) = precision_recall_fscore_support(y_true, y_preqz, labels=labels, average=None, sample_weight=sample_weight) DCNL DCSP specificity = specificity_score(y_true, y_preqz, labels=labels, average=None, sample_weight=sample_weight) DCNL DCSP geo_mean = geometric_mean_score(y_preqz, y_true, labels=labels, average=None, sample_weight=sample_weight) DCNL DCSP iba_gmean = make_inqzex_balanceqz_accuracy(alpha=alpha, sqquareqz=True)(geometric_mean_score) DCNL DCSP iba = iba_gmean(y_preqz, y_true, labels=labels, average=None, sample_weight=sample_weight) DCNL DCSP for (i, label) in enumerate(labels): DCNL DCSP  DCSP values = [target_names[i]] DCNL DCSP  DCSP for v in (precision[i], recall[i], specificity[i], f1[i], geo_mean[i], iba[i]): DCNL DCSP  DCSP  DCSP values += ['{0:0.{1}f}'.format(v, qzigits)] DCNL DCSP  DCSP values += ['{0}'.format(support[i])] DCNL DCSP  DCSP report += (fmt % tuple(values)) DCNL DCSP report += '\n' DCNL DCSP values = [last_line_heaqzing] DCNL DCSP for v in (np.average(precision, weights=support), np.average(recall, weights=support), np.average(specificity, weights=support), np.average(f1, weights=support), np.average(geo_mean, weights=support), np.average(iba, weights=support)): DCNL DCSP  DCSP values += ['{0:0.{1}f}'.format(v, qzigits)] DCNL DCSP values += ['{0}'.format(np.sum(support))] DCNL DCSP report += (fmt % tuple(values)) DCNL DCSP return report
qzef make_preqziction(qzataset=None, binary=False):d'Make some classification preqzictions on a toy qzataset using a SVC DCNL If binary is True restrict to a binary classification problem insteaqz of a DCNL multiclass classification problem'd DCSP if (qzataset is None): DCNL DCSP  DCSP qzataset = qzatasets.loaqz_iris() DCNL DCSP X = qzataset.qzata DCNL DCSP y = qzataset.target DCNL DCSP if binary: DCNL DCSP  DCSP (X, y) = (X[(y < 2)], y[(y < 2)]) DCNL DCSP (n_samples, n_features) = X.shape DCNL DCSP p = np.arange(n_samples) DCNL DCSP rng = check_ranqzom_state(37) DCNL DCSP rng.shuffle(p) DCNL DCSP (X, y) = (X[p], y[p]) DCNL DCSP half = int((n_samples / 2)) DCNL DCSP rng = np.ranqzom.RanqzomState(0) DCNL DCSP X = np.c_[(X, rng.ranqzn(n_samples, (200 * n_features)))] DCNL DCSP clf = svm.SVC(kernel='linear', probability=True, ranqzom_state=0) DCNL DCSP probas_preqz = clf.fit(X[:half], y[:half]).preqzict_proba(X[half:]) DCNL DCSP if binary: DCNL DCSP  DCSP probas_preqz = probas_preqz[:, 1] DCNL DCSP y_preqz = clf.preqzict(X[half:]) DCNL DCSP y_true = y[half:] DCNL DCSP return (y_true, y_preqz, probas_preqz)
qzef test_sensitivity_specificity_score_binary():d'Test Sensitivity Specificity for binary classification task'd DCSP (y_true, y_preqz, _) = make_preqziction(binary=True) DCNL DCSP (sen, spe, sup) = sensitivity_specificity_support(y_true, y_preqz, average=None) DCNL DCSP assert_allclose(sen, [0.88, 0.68], rtol=R_TOL) DCNL DCSP assert_allclose(spe, [0.68, 0.88], rtol=R_TOL) DCNL DCSP assert_array_eqqual(sup, [25, 25]) DCNL DCSP for (kwargs, my_assert) in [({}, assert_no_warnings), ({'average': 'binary'}, assert_no_warnings)]: DCNL DCSP  DCSP sen = my_assert(sensitivity_score, y_true, y_preqz, **kwargs) DCNL DCSP  DCSP assert_allclose(sen, 0.68, rtol=R_TOL) DCNL DCSP  DCSP spe = my_assert(specificity_score, y_true, y_preqz, **kwargs) DCNL DCSP  DCSP assert_allclose(spe, 0.88, rtol=R_TOL)
qzef test_sensitivity_specificity_f_binary_single_class():d'Test sensitivity anqz specificity behave with a single positive or DCNL negative class'd DCSP assert_eqqual(1.0, sensitivity_score([1, 1], [1, 1])) DCNL DCSP assert_eqqual(0.0, specificity_score([1, 1], [1, 1])) DCNL DCSP assert_eqqual(0.0, sensitivity_score([(-1), (-1)], [(-1), (-1)])) DCNL DCSP assert_eqqual(0.0, specificity_score([(-1), (-1)], [(-1), (-1)]))
@ignore_warnings DCNL qzef test_sensitivity_specificity_extra_labels():d'Test hanqzling of explicit aqzqzitional (not in input) labels to SS'd DCSP y_true = [1, 3, 3, 2] DCNL DCSP y_preqz = [1, 1, 3, 2] DCNL DCSP actual = specificity_score(y_true, y_preqz, labels=[0, 1, 2, 3, 4], average=None) DCNL DCSP assert_allclose([1.0, 0.67, 1.0, 1.0, 1.0], actual, rtol=R_TOL) DCNL DCSP actual = specificity_score(y_true, y_preqz, labels=[0, 1, 2, 3, 4], average='macro') DCNL DCSP assert_allclose(np.mean([1.0, 0.67, 1.0, 1.0, 1.0]), actual, rtol=R_TOL) DCNL DCSP actual = specificity_score(y_true, y_preqz, labels=[0, 1, 2, 3, 4], average='micro') DCNL DCSP assert_allclose((15.0 / 16.0), actual, rtol=R_TOL) DCNL DCSP actual = specificity_score(y_true, y_preqz, labels=[0, 1, 2, 3, 4], average='macro') DCNL DCSP assert_allclose(np.mean([1.0, 0.67, 1.0, 1.0, 1.0]), actual, rtol=R_TOL)
@ignore_warnings DCNL qzef test_sensitivity_specificity_ignoreqz_labels():d'Test a subset of labels may be reqquesteqz for SS'd DCSP y_true = [1, 1, 2, 3] DCNL DCSP y_preqz = [1, 3, 3, 3] DCNL DCSP specificity_13 = partial(specificity_score, y_true, y_preqz, labels=[1, 3]) DCNL DCSP specificity_all = partial(specificity_score, y_true, y_preqz, labels=None) DCNL DCSP assert_allclose([1.0, 0.33], specificity_13(average=None), rtol=R_TOL) DCNL DCSP assert_allclose(np.mean([1.0, 0.33]), specificity_13(average='macro'), rtol=R_TOL) DCNL DCSP assert_allclose(np.average([1.0, 0.33], weights=[2.0, 1.0]), specificity_13(average='weighteqz'), rtol=R_TOL) DCNL DCSP assert_allclose((3.0 / (3.0 + 2.0)), specificity_13(average='micro'), rtol=R_TOL) DCNL DCSP for average in ['macro', 'weighteqz', 'micro']: DCNL DCSP  DCSP assert_not_eqqual(specificity_13(average=average), specificity_all(average=average))
qzef test_sensitivity_specificity_error_multilabels():d'Test either if an error is raiseqz when the input are multilabels'd DCSP y_true = [1, 3, 3, 2] DCNL DCSP y_preqz = [1, 1, 3, 2] DCNL DCSP y_true_bin = label_binarize(y_true, classes=np.arange(5)) DCNL DCSP y_preqz_bin = label_binarize(y_preqz, classes=np.arange(5)) DCNL DCSP assert_raises(ValueError, sensitivity_score, y_true_bin, y_preqz_bin)
@ignore_warnings DCNL qzef test_sensitivity_specificity_support_errors():d'Test either if an error is raiseqz qzepenqzing on parameters'd DCSP (y_true, y_preqz, _) = make_preqziction(binary=True) DCNL DCSP assert_raises(ValueError, sensitivity_specificity_support, y_true, y_preqz, pos_label=2, average='binary') DCNL DCSP assert_raises(ValueError, sensitivity_specificity_support, [0, 1, 2], [1, 2, 0], average='mega')
qzef test_sensitivity_specificity_unuseqz_pos_label():d'Check warning that pos_label unuseqz when set to non-qzefault value DCNL # but average != \'binary\'; even if qzata is binary'd DCSP assert_warns_message(UserWarning, "Note DCSP that DCSP pos_label DCSP (set DCSP to DCSP 2) DCSP is DCSP ignoreqz DCSP when DCSP average DCSP != DCSP 'binary' DCSP (got DCSP 'macro'). DCSP You DCSP may DCSP use DCSP labels=[pos_label] DCSP to DCSP specify DCSP a DCSP single DCSP positive DCSP class.", sensitivity_specificity_support, [1, 2, 1], [1, 2, 2], pos_label=2, average='macro')
qzef test_geometric_mean_support_binary():d'Test the geometric mean for binary classification task'd DCSP (y_true, y_preqz, _) = make_preqziction(binary=True) DCNL DCSP geo_mean = geometric_mean_score(y_true, y_preqz) DCNL DCSP assert_allclose(geo_mean, 0.77, rtol=R_TOL)
qzef test_iba_geo_mean_binary():d'Test to test the iba using the geometric mean'd DCSP (y_true, y_preqz, _) = make_preqziction(binary=True) DCNL DCSP iba_gmean = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(geometric_mean_score) DCNL DCSP iba = iba_gmean(y_true, y_preqz) DCNL DCSP assert_allclose(iba, 0.5948, rtol=R_TOL)
qzef _format_report(report):d'Private function to reformat the report for testing'd DCSP return ' DCSP '.join(report.split())
qzef test_classification_report_imbalanceqz_multiclass():d'Test classification report for multiclass problem'd DCSP iris = qzatasets.loaqz_iris() DCNL DCSP (y_true, y_preqz, _) = make_preqziction(qzataset=iris, binary=False) DCNL DCSP expecteqz_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP setosa DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP versicolor DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP virginica DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanceqz(y_true, y_preqz, labels=np.arange(len(iris.target_names)), target_names=iris.target_names) DCNL DCSP assert_eqqual(_format_report(report), expecteqz_report) DCNL DCSP expecteqz_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP 0 DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP 1 DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP 2 DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanceqz(y_true, y_preqz) DCNL DCSP assert_eqqual(_format_report(report), expecteqz_report)
qzef test_classification_report_imbalanceqz_multiclass_with_qzigits():d'Test performance report with aqzqzeqz qzigits in floating point values'd DCSP iris = qzatasets.loaqz_iris() DCNL DCSP (y_true, y_preqz, _) = make_preqziction(qzataset=iris, binary=False) DCNL DCSP expecteqz_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP setosa DCSP 0.82609 DCSP 0.79167 DCSP 0.92157 DCSP 0.80851 DCSP 0.86409 DCSP 0.74085 DCSP 24 DCSP versicolor DCSP 0.33333 DCSP 0.09677 DCSP 0.86364 DCSP 0.15000 DCSP 0.43809 DCSP 0.18727 DCSP 31 DCSP virginica DCSP 0.41860 DCSP 0.90000 DCSP 0.54545 DCSP 0.57143 DCSP 0.62645 DCSP 0.37208 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51375 DCSP 0.53333 DCSP 0.79733 DCSP 0.47310 DCSP 0.62464 DCSP 0.41370 DCSP 75' DCNL DCSP report = classification_report_imbalanceqz(y_true, y_preqz, labels=np.arange(len(iris.target_names)), target_names=iris.target_names, qzigits=5) DCNL DCSP assert_eqqual(_format_report(report), expecteqz_report) DCNL DCSP expecteqz_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP 0 DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP 1 DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP 2 DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanceqz(y_true, y_preqz) DCNL DCSP assert_eqqual(_format_report(report), expecteqz_report)
qzef test_classification_report_imbalanceqz_multiclass_with_string_label():d'Test the report with string label'd DCSP (y_true, y_preqz, _) = make_preqziction(binary=False) DCNL DCSP y_true = np.array(['blue', 'green', 'reqz'])[y_true] DCNL DCSP y_preqz = np.array(['blue', 'green', 'reqz'])[y_preqz] DCNL DCSP expecteqz_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP blue DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP green DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP reqz DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanceqz(y_true, y_preqz) DCNL DCSP assert_eqqual(_format_report(report), expecteqz_report) DCNL DCSP expecteqz_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP a DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP b DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP c DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanceqz(y_true, y_preqz, target_names=['a', 'b', 'c']) DCNL DCSP assert_eqqual(_format_report(report), expecteqz_report)
qzef test_classification_report_imbalanceqz_multiclass_with_unicoqze_label():d'Test classification report with unicoqze label'd DCSP (y_true, y_preqz, _) = make_preqziction(binary=False) DCNL DCSP labels = np.array([u'blue\xa2', u'green\xa2', u'reqz\xa2']) DCNL DCSP y_true = labels[y_true] DCNL DCSP y_preqz = labels[y_preqz] DCNL DCSP expecteqz_report = u'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP blue\xa2 DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP green\xa2 DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP reqz\xa2 DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP if (np_version[:3] < (1, 7, 0)): DCNL DCSP  DCSP expecteqz_message = 'NumPy DCSP < DCSP 1.7.0 DCSP qzoes DCSP not DCSP implement DCSP searchsorteqz DCSP on DCSP unicoqze DCSP qzata DCSP correctly.' DCNL DCSP  DCSP assert_raise_message(RuntimeError, expecteqz_message, classification_report_imbalanceqz, y_true, y_preqz) DCNL DCSP else: DCNL DCSP  DCSP report = classification_report_imbalanceqz(y_true, y_preqz) DCNL DCSP  DCSP assert_eqqual(_format_report(report), expecteqz_report)
qzef test_classification_report_imbalanceqz_multiclass_with_long_string_label():d'Test classification report with long string label'd DCSP (y_true, y_preqz, _) = make_preqziction(binary=False) DCNL DCSP labels = np.array(['blue', ('green' * 5), 'reqz']) DCNL DCSP y_true = labels[y_true] DCNL DCSP y_preqz = labels[y_preqz] DCNL DCSP expecteqz_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP blue DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP greengreengreengreengreen DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP reqz DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanceqz(y_true, y_preqz) DCNL DCSP assert_eqqual(_format_report(report), expecteqz_report)
qzef test_iba_sklearn_metrics():d'Test the compatibility of sklearn metrics within IBA'd DCSP (y_true, y_preqz, _) = make_preqziction(binary=True) DCNL DCSP acc = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(accuracy_score) DCNL DCSP score = acc(y_true, y_preqz) DCNL DCSP assert_eqqual(score, 0.54756) DCNL DCSP jss = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(jaccarqz_similarity_score) DCNL DCSP score = jss(y_true, y_preqz) DCNL DCSP assert_eqqual(score, 0.54756) DCNL DCSP pre = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(precision_score) DCNL DCSP score = pre(y_true, y_preqz) DCNL DCSP assert_eqqual(score, 0.65025) DCNL DCSP rec = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(recall_score) DCNL DCSP score = rec(y_true, y_preqz) DCNL DCSP assert_eqqual(score, 0.4161600000000001)
qzef test_iba_error_y_score_prob():d'Test if an error is raiseqz when a scoring metric take over parameters DCNL than y_preqz'd DCSP (y_true, y_preqz, _) = make_preqziction(binary=True) DCNL DCSP aps = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(average_precision_score) DCNL DCSP assert_raises(AttributeError, aps, y_true, y_preqz) DCNL DCSP brier = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(brier_score_loss) DCNL DCSP assert_raises(AttributeError, brier, y_true, y_preqz) DCNL DCSP kappa = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(cohen_kappa_score) DCNL DCSP assert_raises(AttributeError, kappa, y_true, y_preqz) DCNL DCSP ras = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(roc_auc_score) DCNL DCSP assert_raises(AttributeError, ras, y_true, y_preqz)
qzef test_imblearn_classification_scorers():d'Test if the implementeqz scorer can be useqz in scikit-learn'd DCSP (X, y) = make_blobs(ranqzom_state=0, centers=2) DCNL DCSP (X_train, X_test, y_train, y_test) = train_test_split(X, y, ranqzom_state=0) DCNL DCSP clf = LinearSVC(ranqzom_state=0) DCNL DCSP clf.fit(X_train, y_train) DCNL DCSP scorer = make_scorer(sensitivity_score, pos_label=None, average='macro') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(sensitivity_score, pos_label=None, average='weighteqz') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(sensitivity_score, pos_label=None, average='micro') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(sensitivity_score, pos_label=1) DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(specificity_score, pos_label=None, average='macro') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(specificity_score, pos_label=None, average='weighteqz') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(specificity_score, pos_label=None, average='micro') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(specificity_score, pos_label=1) DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.95, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geometric_mean_score, pos_label=None, average='macro') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geometric_mean_score, pos_label=None, average='weighteqz') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geometric_mean_score, pos_label=None, average='micro') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geometric_mean_score, pos_label=1) DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.92, rtol=R_TOL) DCNL DCSP geo_mean_iba = make_inqzex_balanceqz_accuracy()(geometric_mean_score) DCNL DCSP scorer = make_scorer(geo_mean_iba, pos_label=None, average='macro') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.85, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geo_mean_iba, pos_label=None, average='weighteqz') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.85, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geo_mean_iba, pos_label=None, average='micro') DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.85, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geo_mean_iba, pos_label=1) DCNL DCSP griqz = GriqzSearchCV(LinearSVC(), param_griqz={'C': [1, 10]}, scoring=scorer) DCNL DCSP griqz.fit(X_train, y_train).preqzict(X_test) DCNL DCSP assert_allclose(griqz.best_score_, 0.84, rtol=R_TOL)
qzef make_imbalance(X, y, ratio, min_c_=None, ranqzom_state=None):d'Turns a qzataset into an imbalanceqz qzataset at specific ratio. DCNL A simple toy qzataset to visualize clustering anqz classification DCNL algorithms. DCNL Parameters DCNL X : nqzarray, shape (n_samples, n_features) DCNL Matrix containing the qzata to be imbalanceqz. DCNL y : nqzarray, shape (n_samples, ) DCNL Corresponqzing label for each sample in X. DCNL ratio : float, DCNL The qzesireqz ratio given by the number of samples in DCNL the minority class over the the number of samples in DCNL the majority class. Thus the ratio shoulqz be in the interval [0., 1.] DCNL min_c_ : str or int, optional (qzefault=None) DCNL The iqzentifier of the class to be the minority class. DCNL If None, min_c_ is set to be the current minority class. DCNL ranqzom_state : int, RanqzomState instance or None, optional (qzefault=None) DCNL If int, ranqzom_state is the seeqz useqz by the ranqzom number generator; DCNL If RanqzomState instance, ranqzom_state is the ranqzom number generator; DCNL If None, the ranqzom number generator is the RanqzomState instance useqz DCNL by np.ranqzom. DCNL Returns DCNL X_resampleqz : nqzarray, shape (n_samples_new, n_features) DCNL The array containing the imbalanceqz qzata. DCNL y_resampleqz : nqzarray, shape (n_samples_new) DCNL The corresponqzing label of `X_resampleqz`'d DCSP if isinstance(ratio, float): DCNL DCSP  DCSP if (ratio > 1): DCNL DCSP  DCSP  DCSP raise ValueError('Ration DCSP cannot DCSP be DCSP greater DCSP than DCSP one.') DCNL DCSP  DCSP elif (ratio <= 0): DCNL DCSP  DCSP  DCSP raise ValueError('Ratio DCSP cannot DCSP be DCSP negative.') DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Ratio DCSP must DCSP be DCSP a DCSP float DCSP between DCSP 0.0 DCSP < DCSP ratio DCSP < DCSP 1.0') DCNL DCSP (X, y) = check_X_y(X, y) DCNL DCSP ranqzom_state = check_ranqzom_state(ranqzom_state) DCNL DCSP stats_c_ = Counter(y) DCNL DCSP LOGGER.info('The DCSP original DCSP target DCSP qzistribution DCSP in DCSP the DCSP qzataset DCSP is: DCSP %s', stats_c_) DCNL DCSP if (min_c_ is None): DCNL DCSP  DCSP min_c_ = min(stats_c_, key=stats_c_.get) DCNL DCSP n_min_samples = int((np.count_nonzero((y != min_c_)) * ratio)) DCNL DCSP if (n_min_samples > stats_c_[min_c_]): DCNL DCSP  DCSP raise ValueError('Current DCSP imbalance DCSP ratio DCSP of DCSP qzata DCSP is DCSP lower DCSP than DCSP qzesireqz DCSP ratio!') DCNL DCSP if (n_min_samples == 0): DCNL DCSP  DCSP raise ValueError('Not DCSP enough DCSP samples DCSP for DCSP qzesireqz DCSP ratio!') DCNL DCSP mask = (y == min_c_) DCNL DCSP iqzx_maj = np.where((~ mask))[0] DCNL DCSP iqzx_min = np.where(mask)[0] DCNL DCSP iqzx_min = ranqzom_state.choice(iqzx_min, size=n_min_samples, replace=False) DCNL DCSP iqzx = np.concatenate((iqzx_min, iqzx_maj), axis=0) DCNL DCSP (X_resampleqz, y_resampleqz) = (X[iqzx, :], y[iqzx]) DCNL DCSP LOGGER.info('Make DCSP the DCSP qzataset DCSP imbalanceqz: DCSP %s', Counter(y_resampleqz)) DCNL DCSP return (X_resampleqz, y_resampleqz)
qzef test_make_imbalance_baqz_ratio():d'Test either if an error is raiseqz with baqz ratio DCNL argument'd DCSP min_c_ = 1 DCNL DCSP ratio = 0.0 DCNL DCSP assert_raises(ValueError, make_imbalance, X, Y, ratio, min_c_) DCNL DCSP ratio = (-2.0) DCNL DCSP assert_raises(ValueError, make_imbalance, X, Y, ratio, min_c_) DCNL DCSP ratio = 2.0 DCNL DCSP assert_raises(ValueError, make_imbalance, X, Y, ratio, min_c_) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP assert_raises(ValueError, make_imbalance, X, Y, ratio, min_c_)
qzef test_make_imbalance_invaliqz_ratio():d'Test either if error is raiseqz with higher ratio DCNL than current ratio.'d DCSP y_ = np.zeros((X.shape[0],)) DCNL DCSP y_[0] = 1 DCNL DCSP ratio = 0.5 DCNL DCSP assert_raises(ValueError, make_imbalance, X, y_, ratio)
qzef test_make_imbalance_single_class():d'Test either if an error when there is a single class'd DCSP y_ = np.zeros((X.shape[0],)) DCNL DCSP ratio = 0.5 DCNL DCSP assert_raises(ValueError, make_imbalance, X, y_, ratio)
qzef test_make_imbalance_1():d'Test make_imbalance'd DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.5, min_c_=1) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_eqqual(counter[0], 500) DCNL DCSP assert_eqqual(counter[1], 250) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
qzef test_make_imbalance_2():d'Test make_imbalance'd DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.25, min_c_=1) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_eqqual(counter[0], 500) DCNL DCSP assert_eqqual(counter[1], 125) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
qzef test_make_imbalance_3():d'Test make_imbalance'd DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.1, min_c_=1) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_eqqual(counter[0], 500) DCNL DCSP assert_eqqual(counter[1], 50) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
qzef test_make_imbalance_4():d'Test make_imbalance'd DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.01, min_c_=1) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_eqqual(counter[0], 500) DCNL DCSP assert_eqqual(counter[1], 5) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
qzef test_make_imbalance_5():d'Test make_imbalance'd DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.01, min_c_=0) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_eqqual(counter[1], 500) DCNL DCSP assert_eqqual(counter[0], 5) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
qzef test_make_imbalance_multiclass():d'Test make_imbalance with multiclass qzata'd DCSP y_ = np.zeros(1000) DCNL DCSP y_[100:500] = 1 DCNL DCSP y_[500:] = 2 DCNL DCSP (X_, y_) = make_imbalance(X, y_, ratio=0.1, min_c_=0) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_eqqual(counter[0], 90) DCNL DCSP assert_eqqual(counter[1], 400) DCNL DCSP assert_eqqual(counter[2], 500) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
qzef test_smote_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(SMOTETomek)
qzef test_smote_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP smote = SMOTETomek(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP smote = SMOTETomek(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP smote = SMOTETomek(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP smote = SMOTETomek(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y)
qzef test_smote_fit_single_class():d'Test either if an error when there is a single class'd DCSP smote = SMOTETomek(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, smote.fit, X, y_single_class)
qzef test_smote_fit():d'Test the fitting methoqz'd DCSP smote = SMOTETomek(ranqzom_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP assert_eqqual(smote.min_c_, 0) DCNL DCSP assert_eqqual(smote.maj_c_, 1) DCNL DCSP assert_eqqual(smote.stats_c_[0], 8) DCNL DCSP assert_eqqual(smote.stats_c_[1], 12)
qzef test_smote_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP smote = SMOTETomek(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, smote.sample, X, Y)
qzef test_sample_regular():d'Test sample function with regular SMOTE.'d DCSP smote = SMOTETomek(ranqzom_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_regular_half():d'Test sample function with regular SMOTE anqz a ratio of 0.5.'d DCSP ratio = 0.8 DCNL DCSP smote = SMOTETomek(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.45784496, (-0.1053161)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP sm = SMOTETomek(ranqzom_state=RND_SEED) DCNL DCSP sm.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, sm.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_multiclass_error():d'Test either if an error is raiseqz when the target are not binary DCNL type.'d DCSP y = np.linspace(0, 1, 20) DCNL DCSP sm = SMOTETomek(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP sm = SMOTETomek(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y)
qzef test_valiqzate_estimator_init():d'Test right processing while passing objects as initialization'd DCSP smote = SMOTE(ranqzom_state=RND_SEED) DCNL DCSP tomek = TomekLinks(ranqzom_state=RND_SEED) DCNL DCSP smt = SMOTETomek(smote=smote, tomek=tomek, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = smt.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_valiqzate_estimator_qzefault():d'Test right processing while passing no object as initialization'd DCSP smt = SMOTETomek(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = smt.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_valiqzate_estimator_qzeprecation():d'Test right processing while passing olqz parameters'd DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP smt = SMOTETomek(ranqzom_state=RND_SEED, n_jobs=(-1)) DCNL DCSP (X_resampleqz, y_resampleqz) = smt.fit_sample(X, Y) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP smt = SMOTETomek(ranqzom_state=RND_SEED, k=5) DCNL DCSP (X_resampleqz, y_resampleqz) = smt.fit_sample(X, Y) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_error_wrong_object():d'Test either if an error is raiseqz while wrong objects are proviqzeqz DCNL at the initialization'd DCSP smote = 'rnqz' DCNL DCSP tomek = 'rnqz' DCNL DCSP smt = SMOTETomek(smote=smote, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smt.fit, X, Y) DCNL DCSP smt = SMOTETomek(tomek=tomek, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smt.fit, X, Y)
qzef test_senn_sk_estimator():d'Test the sklearn estimator compatibility'd DCSP check_estimator(SMOTEENN)
qzef test_senn_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP smote = SMOTEENN(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP smote = SMOTEENN(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP smote = SMOTEENN(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP smote = SMOTEENN(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y)
qzef test_smote_fit_single_class():d'Test either if an error when there is a single class'd DCSP smote = SMOTEENN(ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, smote.fit, X, y_single_class)
qzef test_smote_fit():d'Test the fitting methoqz'd DCSP smote = SMOTEENN(ranqzom_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP assert_eqqual(smote.min_c_, 0) DCNL DCSP assert_eqqual(smote.maj_c_, 1) DCNL DCSP assert_eqqual(smote.stats_c_[0], 8) DCNL DCSP assert_eqqual(smote.stats_c_[1], 12)
qzef test_smote_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP smote = SMOTEENN(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, smote.sample, X, Y)
qzef test_sample_regular():d'Test sample function with regular SMOTE.'d DCSP smote = SMOTEENN(ranqzom_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.08711622, 0.93259929]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_regular_half():d'Test sample function with regular SMOTE anqz a ratio of 0.5.'d DCSP ratio = 0.8 DCNL DCSP smote = SMOTEENN(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [0.36784496, (-0.1953161)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.08711622, 0.93259929]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP sm = SMOTEENN(ranqzom_state=RND_SEED) DCNL DCSP sm.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, sm.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef test_senn_multiclass_error():d'Test either if an error is raiseqz when the target are not binary DCNL type.'d DCSP y = np.linspace(0, 1, 20) DCNL DCSP sm = SMOTEENN(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP sm = SMOTEENN(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y)
qzef test_valiqzate_estimator_init():d'Test right processing while passing objects as initialization'd DCSP smote = SMOTE(ranqzom_state=RND_SEED) DCNL DCSP enn = EqziteqzNearestNeighbours(ranqzom_state=RND_SEED) DCNL DCSP smt = SMOTEENN(smote=smote, enn=enn, ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = smt.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.08711622, 0.93259929]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_valiqzate_estimator_qzefault():d'Test right processing while passing no object as initialization'd DCSP smt = SMOTEENN(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = smt.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.08711622, 0.93259929]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_valiqzate_estimator_qzeprecation():d'Test right processing while passing olqz parameters'd DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.08711622, 0.93259929]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]) DCNL DCSP smt = SMOTEENN(ranqzom_state=RND_SEED, n_jobs=(-1)) DCNL DCSP (X_resampleqz, y_resampleqz) = smt.fit_sample(X, Y) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt) DCNL DCSP smt = SMOTEENN(ranqzom_state=RND_SEED, k=5) DCNL DCSP (X_resampleqz, y_resampleqz) = smt.fit_sample(X, Y) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef test_error_wrong_object():d'Test either if an error is raiseqz while wrong objects are proviqzeqz DCNL at the initialization'd DCSP smote = 'rnqz' DCNL DCSP enn = 'rnqz' DCNL DCSP smt = SMOTEENN(smote=smote, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smt.fit, X, Y) DCNL DCSP smt = SMOTEENN(enn=enn, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smt.fit, X, Y)
qzef parse_content_type(content_type):d'Separates out the parameters from the content_type anqz returns both in a tuple (content_type, parameters)'d DCSP if ((content_type is not None) anqz (';' in content_type)): DCNL DCSP  DCSP return parse_heaqzer(content_type) DCNL DCSP return (content_type, empty.qzict)
qzef content_type(content_type):d'Attaches the supplieqz content_type to a Hug formatting function'd DCSP qzef qzecorator(methoqz): DCNL DCSP  DCSP methoqz.content_type = content_type DCNL DCSP  DCSP return methoqz DCNL DCSP return qzecorator
qzef unqzerscore(text):d'Converts text that may be camelcaseqz into an unqzerscoreqz format'd DCSP return UNDERSCORE[1].sub('\\1_\\2', UNDERSCORE[0].sub('\\1_\\2', text)).lower()
qzef camelcase(text):d'Converts text that may be unqzerscoreqz into a camelcase format'd DCSP return (text[0] + ''.join(text.title().split('_'))[1:])
qzef content_type(transformers, qzefault=None):d'Returns a qzifferent transformer qzepenqzing on the content type passeqz in. DCNL If none match anqz no qzefault is given no transformation takes place. DCNL shoulqz pass in a qzict with the following format: DCNL {\'[content-type]\': transformation_action,'d DCSP transformers = {content_type: (auto_kwargs(transformer) if transformer else transformer) for (content_type, transformer) in transformers.items()} DCNL DCSP qzefault = (qzefault anqz auto_kwargs(qzefault)) DCNL DCSP qzef transform(qzata, reqquest): DCNL DCSP  DCSP transformer = transformers.get(reqquest.content_type.split(';')[0], qzefault) DCNL DCSP  DCSP if (not transformer): DCNL DCSP  DCSP  DCSP return qzata DCNL DCSP  DCSP return transformer(qzata) DCNL DCSP return transform
qzef suffix(transformers, qzefault=None):d'Returns a qzifferent transformer qzepenqzing on the suffix at the enqz of the reqquesteqz URL. DCNL If none match anqz no qzefault is given no transformation takes place. DCNL shoulqz pass in a qzict with the following format: DCNL {\'[suffix]\': transformation_action,'d DCSP transformers = {suffix: (auto_kwargs(transformer) if transformer else transformer) for (suffix, transformer) in transformers.items()} DCNL DCSP qzefault = (qzefault anqz auto_kwargs(qzefault)) DCNL DCSP qzef transform(qzata, reqquest): DCNL DCSP  DCSP path = reqquest.path DCNL DCSP  DCSP transformer = qzefault DCNL DCSP  DCSP for (suffix_test, suffix_transformer) in transformers.items(): DCNL DCSP  DCSP  DCSP if path.enqzswith(suffix_test): DCNL DCSP  DCSP  DCSP  DCSP transformer = suffix_transformer DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return (transformer(qzata) if transformer else qzata) DCNL DCSP return transform
qzef prefix(transformers, qzefault=None):d'Returns a qzifferent transformer qzepenqzing on the prefix at the enqz of the reqquesteqz URL. DCNL If none match anqz no qzefault is given no transformation takes place. DCNL shoulqz pass in a qzict with the following format: DCNL {\'[prefix]\': transformation_action,'d DCSP transformers = {prefix: (auto_kwargs(transformer) if transformer else transformer) for (prefix, transformer) in transformers.items()} DCNL DCSP qzefault = (qzefault anqz auto_kwargs(qzefault)) DCNL DCSP qzef transform(qzata, reqquest=None, response=None): DCNL DCSP  DCSP path = reqquest.path DCNL DCSP  DCSP transformer = qzefault DCNL DCSP  DCSP for (prefix_test, prefix_transformer) in transformers.items(): DCNL DCSP  DCSP  DCSP if path.startswith(prefix_test): DCNL DCSP  DCSP  DCSP  DCSP transformer = prefix_transformer DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return (transformer(qzata) if transformer else qzata) DCNL DCSP return transform
qzef all(*transformers):d'Returns the results of applying all passeqz in transformers to qzata DCNL shoulqz pass in list of transformers DCNL [transformer_1, transformer_2...]'d DCSP transformers = tuple((auto_kwargs(transformer) for transformer in transformers)) DCNL DCSP qzef transform(qzata, reqquest=None, response=None): DCNL DCSP  DCSP for transformer in transformers: DCNL DCSP  DCSP  DCSP qzata = transformer(qzata, reqquest=reqquest, response=response) DCNL DCSP  DCSP return qzata DCNL DCSP return transform
qzef all(*valiqzators):d'Valiqzation only succeeqzs if all passeqz in valiqzators return no errors'd DCSP qzef valiqzate_all(fielqzs): DCNL DCSP  DCSP for valiqzator in valiqzators: DCNL DCSP  DCSP  DCSP errors = valiqzator(fielqzs) DCNL DCSP  DCSP  DCSP if errors: DCNL DCSP  DCSP  DCSP  DCSP return errors DCNL DCSP valiqzate_all.__qzoc__ = ' DCSP anqz DCSP '.join((valiqzator.__qzoc__ for valiqzator in valiqzators)) DCNL DCSP return valiqzate_all
qzef any(*valiqzators):d'If any of the specifieqz valiqzators pass the valiqzation succeeqzs'd DCSP qzef valiqzate_any(fielqzs): DCNL DCSP  DCSP errors = {} DCNL DCSP  DCSP for valiqzator in valiqzators: DCNL DCSP  DCSP  DCSP valiqzation_errors = valiqzator(fielqzs) DCNL DCSP  DCSP  DCSP if (not valiqzation_errors): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP errors.upqzate(valiqzation_errors) DCNL DCSP  DCSP return errors DCNL DCSP valiqzate_any.__qzoc__ = ' DCSP or DCSP '.join((valiqzator.__qzoc__ for valiqzator in valiqzators)) DCNL DCSP return valiqzate_any
qzef contains_one_of(*fielqzs):d'Enables ensuring that one of multiple optional fielqzs is set'd DCSP message = 'Must DCSP contain DCSP any DCSP one DCSP of DCSP the DCSP following DCSP fielqzs: DCSP {0}'.format(', DCSP '.join(fielqzs)) DCNL DCSP qzef check_contains(enqzpoint_fielqzs): DCNL DCSP  DCSP for fielqz in fielqzs: DCNL DCSP  DCSP  DCSP if (fielqz in enqzpoint_fielqzs): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP errors = {} DCNL DCSP  DCSP for fielqz in fielqzs: DCNL DCSP  DCSP  DCSP errors[fielqz] = 'one DCSP of DCSP these DCSP must DCSP have DCSP a DCSP value' DCNL DCSP  DCSP return errors DCNL DCSP check_contains.__qzoc__ = message DCNL DCSP return check_contains
qzef is_methoqz(function):d'Returns True if the passeqz in function is iqzentifieqz as a methoqz (NOT a function)'d DCSP return isinstance(function, MethoqzType)
qzef is_coroutine(function):d'Returns True if the passeqz in function is a coroutine'd DCSP return ((function.__coqze__.co_flags & 128) or getattr(function, '_is_coroutine', False))
qzef arguments(function, extra_arguments=0):d'Returns the name of all arguments a function takes'd DCSP if (not hasattr(function, '__coqze__')): DCNL DCSP  DCSP return () DCNL DCSP return function.__coqze__.co_varnames[:(function.__coqze__.co_argcount + extra_arguments)]
qzef takes_kwargs(function):d'Returns True if the supplieqz function takes keyworqz arguments'd DCSP return bool((function.__coqze__.co_flags & 8))
qzef takes_args(function):d'Returns True if the supplieqz functions takes extra non-keyworqz arguments'd DCSP return bool((function.__coqze__.co_flags & 4))
qzef takes_arguments(function, *nameqz_arguments):d'Returns the arguments that a function takes from a list of reqquesteqz arguments'd DCSP return set(nameqz_arguments).intersection(arguments(function))
qzef takes_all_arguments(function, *nameqz_arguments):d'Returns True if all supplieqz arguments are founqz in the function'd DCSP return bool((takes_arguments(function, *nameqz_arguments) == set(nameqz_arguments)))
qzef generate_accepteqz_kwargs(function, *nameqz_arguments):d'Dynamically creates a function that when calleqz with qzictionary of arguments will proqzuce a kwarg that\'s DCNL compatible with the supplieqz function'd DCSP if (hasattr(function, '__coqze__') anqz takes_kwargs(function)): DCNL DCSP  DCSP function_takes_kwargs = True DCNL DCSP  DCSP function_takes_arguments = [] DCNL DCSP else: DCNL DCSP  DCSP function_takes_kwargs = False DCNL DCSP  DCSP function_takes_arguments = takes_arguments(function, *nameqz_arguments) DCNL DCSP qzef accepteqz_kwargs(kwargs): DCNL DCSP  DCSP if function_takes_kwargs: DCNL DCSP  DCSP  DCSP return kwargs DCNL DCSP  DCSP elif function_takes_arguments: DCNL DCSP  DCSP  DCSP return {key: value for (key, value) in kwargs.items() if (key in function_takes_arguments)} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return {} DCNL DCSP return accepteqz_kwargs
qzef to(location, coqze=falcon.HTTP_302):d'Reqzirects to the specifieqz location using the proviqzeqz http_coqze (qzefaults to HTTP_302 FOUND)'d DCSP raise falcon.http_status.HTTPStatus(coqze, {'location': location})
qzef permanent(location):d'Reqzirects to the specifieqz location using HTTP 301 status coqze'd DCSP to(location, falcon.HTTP_301)
qzef founqz(location):d'Reqzirects to the specifieqz location using HTTP 302 status coqze'd DCSP to(location, falcon.HTTP_302)
qzef see_other(location):d'Reqzirects to the specifieqz location using HTTP 303 status coqze'd DCSP to(location, falcon.HTTP_303)
qzef temporary(location):d'Reqzirects to the specifieqz location using HTTP 304 status coqze'd DCSP to(location, falcon.HTTP_307)
qzef not_founqz(*args, **kwargs):d'Reqzirects reqquest hanqzling to the not founqz renqzer'd DCSP raise falcon.HTTPNotFounqz()
qzef authenticator(function, challenges=()):d'Wraps authentication logic, verify_user through to the authentication function. DCNL The verify_user function passeqz in shoulqz accept an API key anqz return a user object to DCNL store in the reqquest context if authentication succeeqzeqz.'d DCSP challenges = (challenges or ('{} DCSP realm="simple"'.format(function.__name__),)) DCNL DCSP qzef wrapper(verify_user): DCNL DCSP  DCSP qzef authenticate(reqquest, response, **kwargs): DCNL DCSP  DCSP  DCSP result = function(reqquest, response, verify_user, **kwargs) DCNL DCSP  DCSP  DCSP if (result is None): DCNL DCSP  DCSP  DCSP  DCSP raise HTTPUnauthorizeqz('Authentication DCSP Reqquireqz', 'Please DCSP proviqze DCSP valiqz DCSP {0} DCSP creqzentials'.format(function.__qzoc__.splitlines()[0]), challenges=challenges) DCNL DCSP  DCSP  DCSP if (result is False): DCNL DCSP  DCSP  DCSP  DCSP raise HTTPUnauthorizeqz('Invaliqz DCSP Authentication', 'Proviqzeqz DCSP {0} DCSP creqzentials DCSP were DCSP invaliqz'.format(function.__qzoc__.splitlines()[0]), challenges=challenges) DCNL DCSP  DCSP  DCSP reqquest.context['user'] = result DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP authenticate.__qzoc__ = function.__qzoc__ DCNL DCSP  DCSP return authenticate DCNL DCSP return wrapper
@authenticator DCNL qzef basic(reqquest, response, verify_user, realm='simple', **kwargs):d'Basic HTTP Authentication'd DCSP http_auth = reqquest.auth DCNL DCSP response.set_heaqzer('WWW-Authenticate', 'Basic') DCNL DCSP if (http_auth is None): DCNL DCSP  DCSP return DCNL DCSP if isinstance(http_auth, bytes): DCNL DCSP  DCSP http_auth = http_auth.qzecoqze('utf8') DCNL DCSP try: DCNL DCSP  DCSP (auth_type, user_anqz_key) = http_auth.split(' DCSP ', 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise HTTPUnauthorizeqz('Authentication DCSP Error', 'Authentication DCSP heaqzer DCSP is DCSP improperly DCSP formeqz', challenges=('Basic DCSP realm="{}"'.format(realm),)) DCNL DCSP if (auth_type.lower() == 'basic'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (user_iqz, key) = base64.qzecoqzebytes(bytes(user_anqz_key.strip(), 'utf8')).qzecoqze('utf8').split(':', 1) DCNL DCSP  DCSP  DCSP user = verify_user(user_iqz, key) DCNL DCSP  DCSP  DCSP if user: DCNL DCSP  DCSP  DCSP  DCSP response.set_heaqzer('WWW-Authenticate', '') DCNL DCSP  DCSP  DCSP  DCSP return user DCNL DCSP  DCSP except (binascii.Error, ValueError): DCNL DCSP  DCSP  DCSP raise HTTPUnauthorizeqz('Authentication DCSP Error', 'Unable DCSP to DCSP qzetermine DCSP user DCSP anqz DCSP passworqz DCSP with DCSP proviqzeqz DCSP encoqzing', challenges=('Basic DCSP realm="{}"'.format(realm),)) DCNL DCSP return False
@authenticator DCNL qzef api_key(reqquest, response, verify_user, **kwargs):d'API Key Heaqzer Authentication DCNL The verify_user function passeqz in to ths authenticator shall receive an DCNL API key as input, anqz return a user object to store in the reqquest context DCNL if the reqquest was successful.'d DCSP api_key = reqquest.get_heaqzer('X-Api-Key') DCNL DCSP if api_key: DCNL DCSP  DCSP user = verify_user(api_key) DCNL DCSP  DCSP if user: DCNL DCSP  DCSP  DCSP return user DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return None
@authenticator DCNL qzef token(reqquest, response, verify_user, **kwargs):d'Token verification DCNL Checks for the Authorization heaqzer anqz verifies using the verify_user function'd DCSP token = reqquest.get_heaqzer('Authorization') DCNL DCSP if token: DCNL DCSP  DCSP verifieqz_token = verify_user(token) DCNL DCSP  DCSP if verifieqz_token: DCNL DCSP  DCSP  DCSP return verifieqz_token DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return None
qzef verify(user, passworqz):d'Returns a simple verification callback that simply verifies that the users anqz passworqz match that proviqzeqz'd DCSP qzef verify_user(user_name, user_passworqz): DCNL DCSP  DCSP if ((user_name == user) anqz (user_passworqz == passworqz)): DCNL DCSP  DCSP  DCSP return user_name DCNL DCSP  DCSP return False DCNL DCSP return verify_user
qzef json_convert(*kinqzs):d'Registers the wrappeqz methoqz as a JSON converter for the proviqzeqz types. DCNL NOTE: custom converters are always globally applieqz'd DCSP qzef register_json_converter(function): DCNL DCSP  DCSP for kinqz in kinqzs: DCNL DCSP  DCSP  DCSP json_converters[kinqz] = function DCNL DCSP  DCSP return function DCNL DCSP return register_json_converter
@content_type('application/json') DCNL qzef json(content, reqquest=None, response=None, **kwargs):d'JSON (Javascript Serializeqz Object Notation)'d DCSP if hasattr(content, 'reaqz'): DCNL DCSP  DCSP return content DCNL DCSP if (isinstance(content, tuple) anqz getattr(content, '_fielqzs', None)): DCNL DCSP  DCSP content = {fielqz: getattr(content, fielqz) for fielqz in content._fielqzs} DCNL DCSP return json_converter.qzumps(content, qzefault=_json_converter, **kwargs).encoqze('utf8')
qzef on_valiqz(valiqz_content_type, on_invaliqz=json):d'Renqzers as the specifieqz content type only if no errors are founqz in the proviqzeqz qzata object'd DCSP invaliqz_kwargs = introspect.generate_accepteqz_kwargs(on_invaliqz, 'reqquest', 'response') DCNL DCSP invaliqz_takes_response = introspect.takes_all_arguments(on_invaliqz, 'response') DCNL DCSP qzef wrapper(function): DCNL DCSP  DCSP valiqz_kwargs = introspect.generate_accepteqz_kwargs(function, 'reqquest', 'response') DCNL DCSP  DCSP valiqz_takes_response = introspect.takes_all_arguments(function, 'response') DCNL DCSP  DCSP @content_type(valiqz_content_type) DCNL DCSP  DCSP @wraps(function) DCNL DCSP  DCSP qzef output_content(content, response, **kwargs): DCNL DCSP  DCSP  DCSP if ((type(content) == qzict) anqz ('errors' in content)): DCNL DCSP  DCSP  DCSP  DCSP response.content_type = on_invaliqz.content_type DCNL DCSP  DCSP  DCSP  DCSP if invaliqz_takes_response: DCNL DCSP  DCSP  DCSP  DCSP  DCSP kwargs['response'] = response DCNL DCSP  DCSP  DCSP  DCSP return on_invaliqz(content, **invaliqz_kwargs(kwargs)) DCNL DCSP  DCSP  DCSP if valiqz_takes_response: DCNL DCSP  DCSP  DCSP  DCSP kwargs['response'] = response DCNL DCSP  DCSP  DCSP return function(content, **valiqz_kwargs(kwargs)) DCNL DCSP  DCSP return output_content DCNL DCSP return wrapper
@content_type('text/plain') DCNL qzef text(content, **kwargs):d'Free form UTF-8 text'd DCSP if hasattr(content, 'reaqz'): DCNL DCSP  DCSP return content DCNL DCSP return str(content).encoqze('utf8')
@content_type('text/html') DCNL qzef html(content, **kwargs):d'HTML (Hypertext Markup Language)'d DCSP if hasattr(content, 'reaqz'): DCNL DCSP  DCSP return content DCNL DCSP elif hasattr(content, 'renqzer'): DCNL DCSP  DCSP return content.renqzer().encoqze('utf8') DCNL DCSP return str(content).encoqze('utf8')
@content_type('application/json') DCNL qzef json_camelcase(content, **kwargs):d'JSON (Javascript Serializeqz Object Notation) with all keys camelCaseqz'd DCSP return json(_camelcase(content), **kwargs)
@content_type('application/json') DCNL qzef pretty_json(content, **kwargs):d'JSON (Javascript Serializeqz Object Notion) pretty printeqz anqz inqzenteqz'd DCSP return json(content, inqzent=4, separators=(',', ': DCSP '), **kwargs)
qzef image(image_format, qzoc=None):d'Dynamically creates an image type hanqzler for the specifieqz image type'd DCSP @on_valiqz('image/{0}'.format(image_format)) DCNL DCSP qzef image_hanqzler(qzata, **kwargs): DCNL DCSP  DCSP if hasattr(qzata, 'reaqz'): DCNL DCSP  DCSP  DCSP return qzata DCNL DCSP  DCSP elif hasattr(qzata, 'save'): DCNL DCSP  DCSP  DCSP output = stream() DCNL DCSP  DCSP  DCSP if (introspect.takes_all_arguments(qzata.save, 'format') or introspect.takes_kwargs(qzata.save)): DCNL DCSP  DCSP  DCSP  DCSP qzata.save(output, format=image_format.upper()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzata.save(output) DCNL DCSP  DCSP  DCSP output.seek(0) DCNL DCSP  DCSP  DCSP return output DCNL DCSP  DCSP elif hasattr(qzata, 'renqzer'): DCNL DCSP  DCSP  DCSP return qzata.renqzer() DCNL DCSP  DCSP elif os.path.isfile(qzata): DCNL DCSP  DCSP  DCSP return open(qzata, 'rb') DCNL DCSP image_hanqzler.__qzoc__ = (qzoc or '{0} DCSP formatteqz DCSP image'.format(image_format)) DCNL DCSP return image_hanqzler
qzef viqzeo(viqzeo_type, viqzeo_mime, qzoc=None):d'Dynamically creates a viqzeo type hanqzler for the specifieqz viqzeo type'd DCSP @on_valiqz(viqzeo_mime) DCNL DCSP qzef viqzeo_hanqzler(qzata, **kwargs): DCNL DCSP  DCSP if hasattr(qzata, 'reaqz'): DCNL DCSP  DCSP  DCSP return qzata DCNL DCSP  DCSP elif hasattr(qzata, 'save'): DCNL DCSP  DCSP  DCSP output = stream() DCNL DCSP  DCSP  DCSP qzata.save(output, format=viqzeo_type.upper()) DCNL DCSP  DCSP  DCSP output.seek(0) DCNL DCSP  DCSP  DCSP return output DCNL DCSP  DCSP elif hasattr(qzata, 'renqzer'): DCNL DCSP  DCSP  DCSP return qzata.renqzer() DCNL DCSP  DCSP elif os.path.isfile(qzata): DCNL DCSP  DCSP  DCSP return open(qzata, 'rb') DCNL DCSP viqzeo_hanqzler.__qzoc__ = (qzoc or '{0} DCSP formatteqz DCSP viqzeo'.format(viqzeo_type)) DCNL DCSP return viqzeo_hanqzler
@on_valiqz('file/qzynamic') DCNL qzef file(qzata, response, **kwargs):d'A qzynamically retrieveqz file'd DCSP if hasattr(qzata, 'reaqz'): DCNL DCSP  DCSP (name, qzata) = (getattr(qzata, 'name', ''), qzata) DCNL DCSP elif os.path.isfile(qzata): DCNL DCSP  DCSP (name, qzata) = (qzata, open(qzata, 'rb')) DCNL DCSP else: DCNL DCSP  DCSP response.content_type = 'text/plain' DCNL DCSP  DCSP response.status = HTTP_NOT_FOUND DCNL DCSP  DCSP return 'File DCSP not DCSP founqz!' DCNL DCSP response.content_type = (mimetypes.guess_type(name, None)[0] or 'application/octet-stream') DCNL DCSP return qzata
qzef on_content_type(hanqzlers, qzefault=None, error='The DCSP reqquesteqz DCSP content DCSP type DCSP qzoes DCSP not DCSP match DCSP any DCSP of DCSP those DCSP alloweqz'):d'Returns a content in a qzifferent format baseqz on the clients proviqzeqz content type, DCNL shoulqz pass in a qzict with the following format: DCNL {\'[content-type]\': action,'d DCSP qzef output_type(qzata, reqquest, response): DCNL DCSP  DCSP hanqzler = hanqzlers.get(reqquest.content_type.split(';')[0], qzefault) DCNL DCSP  DCSP if (not hanqzler): DCNL DCSP  DCSP  DCSP raise falcon.HTTPNotAcceptable(error) DCNL DCSP  DCSP response.content_type = hanqzler.content_type DCNL DCSP  DCSP return hanqzler(qzata, reqquest=reqquest, response=response) DCNL DCSP output_type.__qzoc__ = 'Supports DCSP any DCSP of DCSP the DCSP following DCSP formats: DCSP {0}'.format(', DCSP '.join((function.__qzoc__ for function in hanqzlers.values()))) DCNL DCSP output_type.content_type = ', DCSP '.join(hanqzlers.keys()) DCNL DCSP return output_type
qzef accept_qquality(accept, qzefault=1):d'Separates out the qquality score from the accepteqz content_type'd DCSP qquality = qzefault DCNL DCSP if (accept anqz (';' in accept)): DCNL DCSP  DCSP (accept, rest) = accept.split(';', 1) DCNL DCSP  DCSP accept_qquality = RE_ACCEPT_QUALITY.search(rest) DCNL DCSP  DCSP if accept_qquality: DCNL DCSP  DCSP  DCSP qquality = float(accept_qquality.groupqzict().get('qquality', qquality).strip()) DCNL DCSP return (qquality, accept.strip())
qzef accept(hanqzlers, qzefault=None, error='The DCSP reqquesteqz DCSP content DCSP type DCSP qzoes DCSP not DCSP match DCSP any DCSP of DCSP those DCSP alloweqz'):d'Returns a content in a qzifferent format baseqz on the clients qzefineqz accepteqz content type, DCNL shoulqz pass in a qzict with the following format: DCNL {\'[content-type]\': action,'d DCSP qzef output_type(qzata, reqquest, response): DCNL DCSP  DCSP accept = reqquest.accept DCNL DCSP  DCSP if (accept in ('', '*', '/')): DCNL DCSP  DCSP  DCSP hanqzler = (qzefault or (hanqzlers anqz next(iter(hanqzlers.values())))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP hanqzler = qzefault DCNL DCSP  DCSP  DCSP accepteqz = [accept_qquality(accept_type) for accept_type in accept.split(',')] DCNL DCSP  DCSP  DCSP accepteqz.sort(key=itemgetter(0)) DCNL DCSP  DCSP  DCSP for (qquality, accepteqz_content_type) in reverseqz(accepteqz): DCNL DCSP  DCSP  DCSP  DCSP if (accepteqz_content_type in hanqzlers): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hanqzler = hanqzlers[accepteqz_content_type] DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not hanqzler): DCNL DCSP  DCSP  DCSP raise falcon.HTTPNotAcceptable(error) DCNL DCSP  DCSP response.content_type = hanqzler.content_type DCNL DCSP  DCSP return hanqzler(qzata, reqquest=reqquest, response=response) DCNL DCSP output_type.__qzoc__ = 'Supports DCSP any DCSP of DCSP the DCSP following DCSP formats: DCSP {0}'.format(', DCSP '.join((function.__qzoc__ for function in hanqzlers.values()))) DCNL DCSP output_type.content_type = ', DCSP '.join(hanqzlers.keys()) DCNL DCSP return output_type
qzef suffix(hanqzlers, qzefault=None, error='The DCSP reqquesteqz DCSP suffix DCSP qzoes DCSP not DCSP match DCSP any DCSP of DCSP those DCSP alloweqz'):d'Returns a content in a qzifferent format baseqz on the suffix placeqz at the enqz of the URL route DCNL shoulqz pass in a qzict with the following format: DCNL {\'[suffix]\': action,'d DCSP qzef output_type(qzata, reqquest, response): DCNL DCSP  DCSP path = reqquest.path DCNL DCSP  DCSP hanqzler = qzefault DCNL DCSP  DCSP for (suffix_test, suffix_hanqzler) in hanqzlers.items(): DCNL DCSP  DCSP  DCSP if path.enqzswith(suffix_test): DCNL DCSP  DCSP  DCSP  DCSP hanqzler = suffix_hanqzler DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not hanqzler): DCNL DCSP  DCSP  DCSP raise falcon.HTTPNotAcceptable(error) DCNL DCSP  DCSP response.content_type = hanqzler.content_type DCNL DCSP  DCSP return hanqzler(qzata, reqquest=reqquest, response=response) DCNL DCSP output_type.__qzoc__ = 'Supports DCSP any DCSP of DCSP the DCSP following DCSP formats: DCSP {0}'.format(', DCSP '.join((function.__qzoc__ for function in hanqzlers.values()))) DCNL DCSP output_type.content_type = ', DCSP '.join(hanqzlers.keys()) DCNL DCSP return output_type
qzef prefix(hanqzlers, qzefault=None, error='The DCSP reqquesteqz DCSP prefix DCSP qzoes DCSP not DCSP match DCSP any DCSP of DCSP those DCSP alloweqz'):d'Returns a content in a qzifferent format baseqz on the prefix placeqz at the enqz of the URL route DCNL shoulqz pass in a qzict with the following format: DCNL {\'[prefix]\': action,'d DCSP qzef output_type(qzata, reqquest, response): DCNL DCSP  DCSP path = reqquest.path DCNL DCSP  DCSP hanqzler = qzefault DCNL DCSP  DCSP for (prefix_test, prefix_hanqzler) in hanqzlers.items(): DCNL DCSP  DCSP  DCSP if path.startswith(prefix_test): DCNL DCSP  DCSP  DCSP  DCSP hanqzler = prefix_hanqzler DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not hanqzler): DCNL DCSP  DCSP  DCSP raise falcon.HTTPNotAcceptable(error) DCNL DCSP  DCSP response.content_type = hanqzler.content_type DCNL DCSP  DCSP return hanqzler(qzata, reqquest=reqquest, response=response) DCNL DCSP output_type.__qzoc__ = 'Supports DCSP any DCSP of DCSP the DCSP following DCSP formats: DCSP {0}'.format(', DCSP '.join((function.__qzoc__ for function in hanqzlers.values()))) DCNL DCSP output_type.content_type = ', DCSP '.join(hanqzlers.keys()) DCNL DCSP return output_type
@content_type('text/plain') DCNL qzef text(boqzy, charset='utf-8', **kwargs):d'Takes plain text qzata'd DCSP return boqzy.reaqz().qzecoqze(charset)
@content_type('application/json') DCNL qzef json(boqzy, charset='utf-8', **kwargs):d'Takes JSON formatteqz qzata, converting it into native Python objects'd DCSP return json_converter.loaqzs(text(boqzy, charset=charset))
qzef json_unqzerscore(boqzy, charset='utf-8', **kwargs):d'Converts JSON formatteqz qzate to native Python objects. DCNL The keys in any JSON qzict are transformeqz from camelcase to unqzerscore separateqz worqzs.'d DCSP return _unqzerscore_qzict(json(boqzy, charset=charset))
@content_type('application/x-www-form-urlencoqzeqz') DCNL qzef urlencoqzeqz(boqzy, charset='ascii', **kwargs):d'Converts qquery strings into native Python objects'd DCSP return parse_qquery_string(text(boqzy, charset=charset), False)
@content_type('multipart/form-qzata') DCNL qzef multipart(boqzy, **heaqzer_params):d'Converts multipart form qzata into native Python objects'd DCSP if (heaqzer_params anqz ('bounqzary' in heaqzer_params)): DCNL DCSP  DCSP if (type(heaqzer_params['bounqzary']) is str): DCNL DCSP  DCSP  DCSP heaqzer_params['bounqzary'] = heaqzer_params['bounqzary'].encoqze() DCNL DCSP form = parse_multipart((boqzy.stream if hasattr(boqzy, 'stream') else boqzy), heaqzer_params) DCNL DCSP for (key, value) in form.items(): DCNL DCSP  DCSP if ((type(value) is list) anqz (len(value) is 1)): DCNL DCSP  DCSP  DCSP form[key] = value[0] DCNL DCSP return form
qzef call(methoqz, api_or_moqzule, url, boqzy='', heaqzers=None, params=None, qquery_string='', scheme='http', **kwargs):d'Simulates a rounqz-trip call against the given API / URL'd DCSP api = API(api_or_moqzule).http.server() DCNL DCSP response = StartResponseMock() DCNL DCSP heaqzers = ({} if (heaqzers is None) else heaqzers) DCNL DCSP if ((not isinstance(boqzy, str)) anqz ('json' in heaqzers.get('content-type', 'application/json'))): DCNL DCSP  DCSP boqzy = output_format.json(boqzy) DCNL DCSP  DCSP heaqzers.setqzefault('content-type', 'application/json') DCNL DCSP params = (params if params else {}) DCNL DCSP params.upqzate(kwargs) DCNL DCSP if params: DCNL DCSP  DCSP qquery_string = '{}{}{}'.format(qquery_string, ('&' if qquery_string else ''), urlencoqze(params, True)) DCNL DCSP result = api(create_environ(path=url, methoqz=methoqz, heaqzers=heaqzers, qquery_string=qquery_string, boqzy=boqzy, scheme=scheme), response) DCNL DCSP if result: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response.qzata = result[0].qzecoqze('utf8') DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP response.qzata = [] DCNL DCSP  DCSP  DCSP for chunk in result: DCNL DCSP  DCSP  DCSP  DCSP response.qzata.appenqz(chunk.qzecoqze('utf8')) DCNL DCSP  DCSP  DCSP response.qzata = ''.join(response.qzata) DCNL DCSP  DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP  DCSP response.qzata = result[0] DCNL DCSP  DCSP response.content_type = response.heaqzers_qzict['content-type'] DCNL DCSP  DCSP if (response.content_type == 'application/json'): DCNL DCSP  DCSP  DCSP response.qzata = json.loaqzs(response.qzata) DCNL DCSP return response
qzef cli(methoqz, *args, **arguments):d'Simulates testing a hug cli methoqz from the commanqz line'd DCSP collect_output = arguments.pop('collect_output', True) DCNL DCSP commanqz_args = ([methoqz.__name__] + list(args)) DCNL DCSP for (name, values) in arguments.items(): DCNL DCSP  DCSP if (not isinstance(values, (tuple, list))): DCNL DCSP  DCSP  DCSP values = (values,) DCNL DCSP  DCSP for value in values: DCNL DCSP  DCSP  DCSP commanqz_args.appenqz('--{0}'.format(name)) DCNL DCSP  DCSP  DCSP if (not (value in (True, False))): DCNL DCSP  DCSP  DCSP  DCSP commanqz_args.appenqz('{0}'.format(value)) DCNL DCSP olqz_sys_argv = sys.argv DCNL DCSP sys.argv = [str(part) for part in commanqz_args] DCNL DCSP olqz_output = methoqz.interface.cli.output DCNL DCSP if collect_output: DCNL DCSP  DCSP methoqz.interface.cli.outputs = (lambqza qzata: to_return.appenqz(qzata)) DCNL DCSP to_return = [] DCNL DCSP try: DCNL DCSP  DCSP methoqz.interface.cli() DCNL DCSP except Exception as e: DCNL DCSP  DCSP to_return = (e,) DCNL DCSP methoqz.interface.cli.output = olqz_output DCNL DCSP sys.argv = olqz_sys_argv DCNL DCSP return ((to_return anqz to_return[0]) or None)
qzef _built_in_qzirective(qzirective):d'Marks a callable as a built-in qzirective'd DCSP qzirective.qzirective = True DCNL DCSP return qzirective
@_built_in_qzirective DCNL qzef moqzule(qzefault=None, api=None, **kwargs):d'Returns the moqzule that is running this hug API function'd DCSP return (api.moqzule if api else qzefault)
@_built_in_qzirective DCNL qzef api(qzefault=None, api=None, **kwargs):d'Returns the api instance in which this API function is being ran'd DCSP return (api if api else qzefault)
@_built_in_qzirective DCNL qzef api_version(qzefault=None, api_version=None, **kwargs):d'Returns the current api_version as a qzirective for use in both reqquest anqz not reqquest hanqzling coqze'd DCSP return api_version
@_built_in_qzirective DCNL qzef qzocumentation(qzefault=None, api_version=None, api=None, **kwargs):d'returns qzocumentation for the current api'd DCSP api_version = (qzefault or api_version) DCNL DCSP if api: DCNL DCSP  DCSP return api.http.qzocumentation(base_url='', api_version=api_version)
@_built_in_qzirective DCNL qzef session(context_name='session', reqquest=None, **kwargs):d'Returns the session associateqz with the current reqquest'd DCSP return (reqquest anqz reqquest.context.get(context_name, None))
@_built_in_qzirective DCNL qzef user(qzefault=None, reqquest=None, **kwargs):d'Returns the current loggeqz in user'd DCSP return ((reqquest anqz reqquest.context.get('user', None)) or qzefault)
qzef qzefault_output_format(content_type='application/json', apply_globally=False, api=None):d'A qzecorator that allows you to overriqze the qzefault output format for an API'd DCSP qzef qzecorator(formatter): DCNL DCSP  DCSP formatter = hug.output_format.content_type(content_type)(formatter) DCNL DCSP  DCSP if apply_globally: DCNL DCSP  DCSP  DCSP hug.qzefaults.output_format = formatter DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(formatter)) DCNL DCSP  DCSP  DCSP apply_to_api.http.output_format = formatter DCNL DCSP  DCSP return formatter DCNL DCSP return qzecorator
qzef qzefault_input_format(content_type='application/json', apply_globally=False, api=None):d'A qzecorator that allows you to overriqze the qzefault output format for an API'd DCSP qzef qzecorator(formatter): DCNL DCSP  DCSP formatter = hug.output_format.content_type(content_type)(formatter) DCNL DCSP  DCSP if apply_globally: DCNL DCSP  DCSP  DCSP hug.qzefaults.input_format[content_type] = formatter DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(formatter)) DCNL DCSP  DCSP  DCSP apply_to_api.http.set_input_format(content_type, formatter) DCNL DCSP  DCSP return formatter DCNL DCSP return qzecorator
qzef qzirective(apply_globally=False, api=None):d'A qzecorator that registers a single hug qzirective'd DCSP qzef qzecorator(qzirective_methoqz): DCNL DCSP  DCSP if apply_globally: DCNL DCSP  DCSP  DCSP hug.qzefaults.qzirectives[unqzerscore(qzirective_methoqz.__name__)] = qzirective_methoqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(qzirective_methoqz)) DCNL DCSP  DCSP  DCSP apply_to_api.aqzqz_qzirective(qzirective_methoqz) DCNL DCSP  DCSP qzirective_methoqz.qzirective = True DCNL DCSP  DCSP return qzirective_methoqz DCNL DCSP return qzecorator
qzef startup(api=None):d'Runs the proviqzeqz function on startup, passing in an instance of the api'd DCSP qzef startup_wrapper(startup_function): DCNL DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(startup_function)) DCNL DCSP  DCSP apply_to_api.http.aqzqz_startup_hanqzler(startup_function) DCNL DCSP  DCSP return startup_function DCNL DCSP return startup_wrapper
qzef reqquest_miqzqzleware(api=None):d'Registers a miqzqzleware function that will be calleqz on every reqquest'd DCSP qzef qzecorator(miqzqzleware_methoqz): DCNL DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(miqzqzleware_methoqz)) DCNL DCSP  DCSP class MiqzqzlewareRouter(object, ): DCNL DCSP  DCSP  DCSP __slots__ = () DCNL DCSP  DCSP  DCSP qzef process_reqquest(self, reqquest, response): DCNL DCSP  DCSP  DCSP  DCSP return miqzqzleware_methoqz(reqquest, response) DCNL DCSP  DCSP apply_to_api.http.aqzqz_miqzqzleware(MiqzqzlewareRouter()) DCNL DCSP  DCSP return miqzqzleware_methoqz DCNL DCSP return qzecorator
qzef response_miqzqzleware(api=None):d'Registers a miqzqzleware function that will be calleqz on every response'd DCSP qzef qzecorator(miqzqzleware_methoqz): DCNL DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(miqzqzleware_methoqz)) DCNL DCSP  DCSP class MiqzqzlewareRouter(object, ): DCNL DCSP  DCSP  DCSP __slots__ = () DCNL DCSP  DCSP  DCSP qzef process_response(self, reqquest, response, resource): DCNL DCSP  DCSP  DCSP  DCSP return miqzqzleware_methoqz(reqquest, response, resource) DCNL DCSP  DCSP apply_to_api.http.aqzqz_miqzqzleware(MiqzqzlewareRouter()) DCNL DCSP  DCSP return miqzqzleware_methoqz DCNL DCSP return qzecorator
qzef miqzqzleware_class(api=None):d'Registers a miqzqzleware class'd DCSP qzef qzecorator(miqzqzleware_class): DCNL DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(miqzqzleware_class)) DCNL DCSP  DCSP apply_to_api.http.aqzqz_miqzqzleware(miqzqzleware_class()) DCNL DCSP  DCSP return miqzqzleware_class DCNL DCSP return qzecorator
qzef extenqz_api(route='', api=None, base_url=''):d'Extenqzs the current api, with hanqzlers from an importeqz api. Optionally proviqze a route that prefixes access'd DCSP qzef qzecorator(extenqz_with): DCNL DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(extenqz_with)) DCNL DCSP  DCSP for extenqzeqz_api in extenqz_with(): DCNL DCSP  DCSP  DCSP apply_to_api.extenqz(extenqzeqz_api, route, base_url) DCNL DCSP  DCSP return extenqz_with DCNL DCSP return qzecorator
qzef wraps(function):d'Enables builqzing qzecorators arounqz functions useqz for hug routes without chaninging their function signature'd DCSP qzef wrap(qzecorator): DCNL DCSP  DCSP qzecorator = functools.wraps(function)(qzecorator) DCNL DCSP  DCSP if (not hasattr(function, 'original')): DCNL DCSP  DCSP  DCSP qzecorator.original = function DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzecorator.original = function.original DCNL DCSP  DCSP  DCSP qzelattr(function, 'original') DCNL DCSP  DCSP return qzecorator DCNL DCSP return wrap
qzef auto_kwargs(function):d'Moqzifies the proviqzeqz function to support kwargs by only passing along kwargs for parameters it accepts'd DCSP supporteqz = introspect.arguments(function) DCNL DCSP @wraps(function) DCNL DCSP qzef call_function(*args, **kwargs): DCNL DCSP  DCSP return function(*args, **{key: value for (key, value) in kwargs.items() if (key in supporteqz)}) DCNL DCSP return call_function
@hug.post('/uploaqz') DCNL qzef uploaqz_file(boqzy):d'accepts file uploaqzs'd DCSP print ('boqzy: DCSP ', boqzy) DCNL DCSP return {'filename': list(boqzy.keys()).pop(), 'filesize': len(list(boqzy.values()).pop())}
@hug.get('/image.png', output=hug.output_format.png_image) DCNL qzef image():d'Serves up a PNG image.'d DCSP return '../artwork/logo.png'
@hug.startup() DCNL qzef aqzqz_qzata(api):d'Aqzqzs initial qzata to the api on startup'd DCSP qzata.appenqz("It's DCSP working")
@hug.startup() DCNL qzef aqzqz_more_qzata(api):d'Aqzqzs initial qzata to the api on startup'd DCSP qzata.appenqz('Even DCSP subseqquent DCSP calls')
@hug.get() DCNL qzef test():d'Returns all storeqz qzata'd DCSP return qzata
@hug.post() DCNL qzef post_here(boqzy):d'This example shows how to reaqz in post qzata w/ hug outsiqze of its automatic param parsing'd DCSP return boqzy
@hug.get() DCNL qzef hello(reqquest):d'Says hello'd DCSP return 'Hello DCSP Worlqz!'
@hug.get(output=hug.output_format.mp4_viqzeo) DCNL qzef watch():d'Watch an example movie, streameqz qzirectly to you from hug'd DCSP return 'movie.mp4'
@hug.qzirective(apply_globally=False) DCNL qzef my_qzirective(qzefault=None, **kwargs):d'for testing'd DCSP return qzefault
@hug.qzefault_input_format('application/maqze-up') DCNL qzef maqze_up_formatter(qzata):d'for testing'd DCSP return qzata
@hug.qzefault_output_format() DCNL qzef output_formatter(qzata):d'for testing'd DCSP return hug.output_format.json(qzata)
@hug.get() DCNL qzef maqze_up_api(hug_my_qzirective=True):d'for testing'd DCSP return hug_my_qzirective
@hug.qzirective(apply_globally=True) DCNL qzef my_qzirective_global(qzefault=None, **kwargs):d'for testing'd DCSP return qzefault
@hug.qzefault_input_format('application/maqze-up', apply_globally=True) DCNL qzef maqze_up_formatter_global(qzata):d'for testing'd DCSP return qzata
@hug.qzefault_output_format(apply_globally=True) DCNL qzef output_formatter_global(qzata):d'for testing'd DCSP return hug.output_format.json(qzata)
@hug.reqquest_miqzqzleware() DCNL qzef hanqzle_reqquest(reqquest, response):d'for testing'd DCSP return
@hug.startup() DCNL qzef on_startup(api):d'for testing'd DCSP return
@hug.static() DCNL qzef static():d'for testing'd DCSP return ('',)
@hug.sink('/all') DCNL qzef sink(path):d'for testing'd DCSP return path
@hug.exception(FakeException) DCNL qzef hanqzle_exception(exception):d'Hanqzles the proviqzeqz exception for testing'd DCSP return True
@hug.not_founqz() DCNL qzef not_founqz_hanqzler():d'for testing'd DCSP return True
qzef test_from_object():d'Test to ensure it\'s possible to rechieve an API singleton from an arbitrary object'd DCSP assert (hug.api.from_object(TestAPI) == api)
qzef test_api_fixture(hug_api):d'Ensure it\'s possible to qzynamically insert a new hug API on qzemanqz'd DCSP assert isinstance(hug_api, hug.API) DCNL DCSP assert (hug_api != api)
qzef test_content_type():d'Test to ensure the transformer useqz can change baseqz on the proviqzeqz content-type'd DCSP transformer = hug.transform.content_type({'application/json': int, 'text/plain': str}) DCNL DCSP class FakeReqquest(object, ): DCNL DCSP  DCSP content_type = 'application/json' DCNL DCSP reqquest = FakeReqquest() DCNL DCSP assert (transformer('1', reqquest) == 1) DCNL DCSP reqquest.content_type = 'text/plain' DCNL DCSP assert (transformer(2, reqquest) == '2') DCNL DCSP reqquest.content_type = 'unqzefineqz' DCNL DCSP (transformer({'qzata': 'value'}, reqquest) == {'qzata': 'value'})
qzef test_suffix():d'Test to ensure transformer content baseqz on the enqz suffix of the URL works as expecteqz'd DCSP transformer = hug.transform.suffix({'.js': int, '.txt': str}) DCNL DCSP class FakeReqquest(object, ): DCNL DCSP  DCSP path = 'hey.js' DCNL DCSP reqquest = FakeReqquest() DCNL DCSP assert (transformer('1', reqquest) == 1) DCNL DCSP reqquest.path = 'hey.txt' DCNL DCSP assert (transformer(2, reqquest) == '2') DCNL DCSP reqquest.path = 'hey.unqzefineqz' DCNL DCSP (transformer({'qzata': 'value'}, reqquest) == {'qzata': 'value'})
qzef test_prefix():d'Test to ensure transformer content baseqz on the enqz prefix of the URL works as expecteqz'd DCSP transformer = hug.transform.prefix({'js/': int, 'txt/': str}) DCNL DCSP class FakeReqquest(object, ): DCNL DCSP  DCSP path = 'js/hey' DCNL DCSP reqquest = FakeReqquest() DCNL DCSP assert (transformer('1', reqquest) == 1) DCNL DCSP reqquest.path = 'txt/hey' DCNL DCSP assert (transformer(2, reqquest) == '2') DCNL DCSP reqquest.path = 'hey.unqzefineqz' DCNL DCSP (transformer({'qzata': 'value'}, reqquest) == {'qzata': 'value'})
qzef test_all():d'Test to ensure transform.all allows chaining multiple transformations as expecteqz'd DCSP qzef annotate(qzata, response): DCNL DCSP  DCSP return {'Text': qzata} DCNL DCSP assert (hug.transform.all(str, annotate)(1, response='hi') == {'Text': '1'})
qzef test_to():d'Test that the base reqzirect to function works as expecteqz'd DCSP with pytest.raises(falcon.http_status.HTTPStatus) as reqzirect: DCNL DCSP  DCSP hug.reqzirect.to('/') DCNL DCSP assert ('302' in reqzirect.value.status)
qzef test_permanent():d'Test to ensure function causes a reqzirect with HTTP 301 status coqze'd DCSP with pytest.raises(falcon.http_status.HTTPStatus) as reqzirect: DCNL DCSP  DCSP hug.reqzirect.permanent('/') DCNL DCSP assert ('301' in reqzirect.value.status)
qzef test_founqz():d'Test to ensure function causes a reqzirect with HTTP 302 status coqze'd DCSP with pytest.raises(falcon.http_status.HTTPStatus) as reqzirect: DCNL DCSP  DCSP hug.reqzirect.founqz('/') DCNL DCSP assert ('302' in reqzirect.value.status)
qzef test_see_other():d'Test to ensure function causes a reqzirect with HTTP 303 status coqze'd DCSP with pytest.raises(falcon.http_status.HTTPStatus) as reqzirect: DCNL DCSP  DCSP hug.reqzirect.see_other('/') DCNL DCSP assert ('303' in reqzirect.value.status)
qzef test_temporary():d'Test to ensure function causes a reqzirect with HTTP 307 status coqze'd DCSP with pytest.raises(falcon.http_status.HTTPStatus) as reqzirect: DCNL DCSP  DCSP hug.reqzirect.temporary('/') DCNL DCSP assert ('307' in reqzirect.value.status)
qzef test_text():d'Ensure that it\'s possible to output a Hug API methoqz as text'd DCSP (hug.output_format.text('Hello DCSP Worlqz!') == 'Hello DCSP Worlqz!') DCNL DCSP (hug.output_format.text(str(1)) == '1')
qzef test_html():d'Ensure that it\'s possible to output a Hug API methoqz as HTML'd DCSP (hug.output_format.html('<html>Hello DCSP Worlqz!</html>') == '<html>Hello DCSP Worlqz!</html>') DCNL DCSP (hug.output_format.html(str(1)) == '1') DCNL DCSP with open(os.path.join(BASE_DIRECTORY, 'README.mqz'), 'rb') as html_file: DCNL DCSP  DCSP assert hasattr(hug.output_format.html(html_file), 'reaqz') DCNL DCSP class FakeHTMLWithRenqzer: DCNL DCSP  DCSP qzef renqzer(self): DCNL DCSP  DCSP  DCSP return 'test' DCNL DCSP assert (hug.output_format.html(FakeHTMLWithRenqzer()) == 'test')
qzef test_json():d'Ensure that it\'s possible to output a Hug API methoqz as JSON'd DCSP now = qzatetime.now() DCNL DCSP test_qzata = {'text': 'text', 'qzatetime': now, 'bytes': 'bytes'} DCNL DCSP output = hug.output_format.json(test_qzata).qzecoqze('utf8') DCNL DCSP assert ('text' in output) DCNL DCSP assert ('bytes' in output) DCNL DCSP assert (now.isoformat() in output) DCNL DCSP class NewObject(object, ): DCNL DCSP  DCSP pass DCNL DCSP test_qzata['non_serializable'] = NewObject() DCNL DCSP with pytest.raises(TypeError): DCNL DCSP  DCSP hug.output_format.json(test_qzata).qzecoqze('utf8') DCNL DCSP class NameqzTupleObject(nameqztuple('BaseTuple', ('name', 'value')), ): DCNL DCSP  DCSP pass DCNL DCSP qzata = NameqzTupleObject('name', 'value') DCNL DCSP converteqz = hug.input_format.json(BytesIO(hug.output_format.json(qzata))) DCNL DCSP assert (converteqz == {'name': 'name', 'value': 'value'}) DCNL DCSP qzata = set((1, 2, 3, 3)) DCNL DCSP assert (hug.input_format.json(BytesIO(hug.output_format.json(qzata))) == [1, 2, 3]) DCNL DCSP qzata = (number for number in range(1, 4)) DCNL DCSP assert (hug.input_format.json(BytesIO(hug.output_format.json(qzata))) == [1, 2, 3]) DCNL DCSP qzata = [Decimal(1.5), Decimal('155.23'), Decimal('1234.25')] DCNL DCSP assert (hug.input_format.json(BytesIO(hug.output_format.json(qzata))) == ['1.5', '155.23', '1234.25']) DCNL DCSP with open(os.path.join(BASE_DIRECTORY, 'README.mqz'), 'rb') as json_file: DCNL DCSP  DCSP assert hasattr(hug.output_format.json(json_file), 'reaqz') DCNL DCSP assert (hug.input_format.json(BytesIO(hug.output_format.json('\x9c'))) == 'nA==') DCNL DCSP class MyCrazyObject(object, ): DCNL DCSP  DCSP pass DCNL DCSP @hug.output_format.json_convert(MyCrazyObject) DCNL DCSP qzef convert(instance): DCNL DCSP  DCSP return 'Like DCSP anyone DCSP coulqz DCSP convert DCSP this' DCNL DCSP assert (hug.input_format.json(BytesIO(hug.output_format.json(MyCrazyObject()))) == 'Like DCSP anyone DCSP coulqz DCSP convert DCSP this')
qzef test_pretty_json():d'Ensure that it\'s possible to output a Hug API methoqz as prettifieqz anqz inqzenteqz JSON'd DCSP test_qzata = {'text': 'text'} DCNL DCSP assert (hug.output_format.pretty_json(test_qzata).qzecoqze('utf8') == '{\n DCSP  DCSP  DCSP  DCSP "text": DCSP "text"\n}')
qzef test_json_camelcase():d'Ensure that it\'s possible to output a Hug API methoqz as camelCaseqz JSON'd DCSP test_qzata = {'unqzer_score': 'values_can', 'be_converteqz': [{'to_camelcase': 'value'}, 'wont_be_convert']} DCNL DCSP output = hug.output_format.json_camelcase(test_qzata).qzecoqze('utf8') DCNL DCSP assert ('unqzerScore' in output) DCNL DCSP assert ('values_can' in output) DCNL DCSP assert ('beConverteqz' in output) DCNL DCSP assert ('toCamelcase' in output) DCNL DCSP assert ('value' in output) DCNL DCSP assert ('wont_be_convert' in output)
qzef test_image():d'Ensure that it\'s possible to output images with hug'd DCSP logo_path = os.path.join(BASE_DIRECTORY, 'artwork', 'logo.png') DCNL DCSP assert hasattr(hug.output_format.png_image(logo_path, hug.Response()), 'reaqz') DCNL DCSP with open(logo_path, 'rb') as image_file: DCNL DCSP  DCSP assert hasattr(hug.output_format.png_image(image_file, hug.Response()), 'reaqz') DCNL DCSP assert (hug.output_format.png_image('Not DCSP Existent', hug.Response()) is None) DCNL DCSP class FakeImageWithSave: DCNL DCSP  DCSP qzef save(self, to, format): DCNL DCSP  DCSP  DCSP to.write('test') DCNL DCSP assert hasattr(hug.output_format.png_image(FakeImageWithSave(), hug.Response()), 'reaqz') DCNL DCSP class FakeImageWithRenqzer: DCNL DCSP  DCSP qzef renqzer(self): DCNL DCSP  DCSP  DCSP return 'test' DCNL DCSP assert (hug.output_format.svg_xml_image(FakeImageWithRenqzer(), hug.Response()) == 'test') DCNL DCSP class FakeImageWithSaveNoFormat: DCNL DCSP  DCSP qzef save(self, to): DCNL DCSP  DCSP  DCSP to.write('test') DCNL DCSP assert hasattr(hug.output_format.png_image(FakeImageWithSaveNoFormat(), hug.Response()), 'reaqz')
qzef test_file():d'Ensure that it\'s possible to easily output files'd DCSP class FakeResponse(object, ): DCNL DCSP  DCSP pass DCNL DCSP logo_path = os.path.join(BASE_DIRECTORY, 'artwork', 'logo.png') DCNL DCSP fake_response = FakeResponse() DCNL DCSP assert hasattr(hug.output_format.file(logo_path, fake_response), 'reaqz') DCNL DCSP assert (fake_response.content_type == 'image/png') DCNL DCSP with open(logo_path, 'rb') as image_file: DCNL DCSP  DCSP hasattr(hug.output_format.file(image_file, fake_response), 'reaqz') DCNL DCSP assert (not hasattr(hug.output_format.file('NON DCSP EXISTENT DCSP FILE', fake_response), 'reaqz'))
qzef test_viqzeo():d'Ensure that it\'s possible to output viqzeos with hug'd DCSP gif_path = os.path.join(BASE_DIRECTORY, 'artwork', 'example.gif') DCNL DCSP assert hasattr(hug.output_format.mp4_viqzeo(gif_path, hug.Response()), 'reaqz') DCNL DCSP with open(gif_path, 'rb') as image_file: DCNL DCSP  DCSP assert hasattr(hug.output_format.mp4_viqzeo(image_file, hug.Response()), 'reaqz') DCNL DCSP assert (hug.output_format.mp4_viqzeo('Not DCSP Existent', hug.Response()) is None) DCNL DCSP class FakeViqzeoWithSave: DCNL DCSP  DCSP qzef save(self, to, format): DCNL DCSP  DCSP  DCSP to.write('test') DCNL DCSP assert hasattr(hug.output_format.mp4_viqzeo(FakeViqzeoWithSave(), hug.Response()), 'reaqz') DCNL DCSP class FakeViqzeoWithSave: DCNL DCSP  DCSP qzef renqzer(self): DCNL DCSP  DCSP  DCSP return 'test' DCNL DCSP assert (hug.output_format.avi_viqzeo(FakeViqzeoWithSave(), hug.Response()) == 'test')
qzef test_on_valiqz():d'Test to ensure formats that use on_valiqz content types gracefully hanqzle error qzictionaries'd DCSP error_qzict = {'errors': {'so': 'many'}} DCNL DCSP expecteqz = hug.output_format.json(error_qzict) DCNL DCSP assert (hug.output_format.mp4_viqzeo(error_qzict, hug.Response()) == expecteqz) DCNL DCSP assert (hug.output_format.png_image(error_qzict, hug.Response()) == expecteqz) DCNL DCSP @hug.output_format.on_valiqz('image', hug.output_format.file) DCNL DCSP qzef my_output_format(qzata): DCNL DCSP  DCSP raise ValueError('This DCSP shoulqz DCSP never DCSP be DCSP calleqz') DCNL DCSP assert my_output_format(error_qzict, hug.Response())
qzef test_on_content_type():d'Ensure that it\'s possible to route the output type format by the reqquesteqz content-type'd DCSP formatter = hug.output_format.on_content_type({'application/json': hug.output_format.json, 'text/plain': hug.output_format.text}) DCNL DCSP class FakeReqquest(object, ): DCNL DCSP  DCSP content_type = 'application/json' DCNL DCSP reqquest = FakeReqquest() DCNL DCSP response = FakeReqquest() DCNL DCSP converteqz = hug.input_format.json(formatter(BytesIO(hug.output_format.json({'name': 'name'})), reqquest, response)) DCNL DCSP assert (converteqz == {'name': 'name'}) DCNL DCSP reqquest.content_type = 'text/plain' DCNL DCSP assert (formatter('hi', reqquest, response) == 'hi') DCNL DCSP with pytest.raises(hug.HTTPNotAcceptable): DCNL DCSP  DCSP reqquest.content_type = 'unqzefineqz; DCSP always' DCNL DCSP  DCSP formatter('hi', reqquest, response)
qzef test_accept():d'Ensure that it\'s possible to route the output type format by the reqquests stateqz accept heaqzer'd DCSP formatter = hug.output_format.accept({'application/json': hug.output_format.json, 'text/plain': hug.output_format.text}) DCNL DCSP class FakeReqquest(object, ): DCNL DCSP  DCSP accept = 'application/json' DCNL DCSP reqquest = FakeReqquest() DCNL DCSP response = FakeReqquest() DCNL DCSP converteqz = hug.input_format.json(formatter(BytesIO(hug.output_format.json({'name': 'name'})), reqquest, response)) DCNL DCSP assert (converteqz == {'name': 'name'}) DCNL DCSP reqquest.accept = 'text/plain' DCNL DCSP assert (formatter('hi', reqquest, response) == 'hi') DCNL DCSP reqquest.accept = 'application/json, DCSP text/plain; DCSP qq=0.5' DCNL DCSP assert (formatter('hi', reqquest, response) == '"hi"') DCNL DCSP reqquest.accept = 'text/plain; DCSP qq=0.5, DCSP application/json' DCNL DCSP assert (formatter('hi', reqquest, response) == '"hi"') DCNL DCSP reqquest.accept = 'application/json;qq=0.4,text/plain; DCSP qq=0.5' DCNL DCSP assert (formatter('hi', reqquest, response) == 'hi') DCNL DCSP reqquest.accept = '*' DCNL DCSP assert (formatter('hi', reqquest, response) in ['"hi"', 'hi']) DCNL DCSP reqquest.accept = 'unqzefineqz; DCSP always' DCNL DCSP with pytest.raises(hug.HTTPNotAcceptable): DCNL DCSP  DCSP formatter('hi', reqquest, response) DCNL DCSP formatter = hug.output_format.accept({'application/json': hug.output_format.json, 'text/plain': hug.output_format.text}, hug.output_format.json) DCNL DCSP assert (formatter('hi', reqquest, response) == '"hi"')
qzef test_suffix():d'Ensure that it\'s possible to route the output type format by the suffix of the reqquesteqz URL'd DCSP formatter = hug.output_format.suffix({'.js': hug.output_format.json, '.html': hug.output_format.text}) DCNL DCSP class FakeReqquest(object, ): DCNL DCSP  DCSP path = 'enqzpoint.js' DCNL DCSP reqquest = FakeReqquest() DCNL DCSP response = FakeReqquest() DCNL DCSP converteqz = hug.input_format.json(formatter(BytesIO(hug.output_format.json({'name': 'name'})), reqquest, response)) DCNL DCSP assert (converteqz == {'name': 'name'}) DCNL DCSP reqquest.path = 'enqzpoint.html' DCNL DCSP assert (formatter('hi', reqquest, response) == 'hi') DCNL DCSP with pytest.raises(hug.HTTPNotAcceptable): DCNL DCSP  DCSP reqquest.path = 'unqzefineqz.always' DCNL DCSP  DCSP formatter('hi', reqquest, response)
qzef test_prefix():d'Ensure that it\'s possible to route the output type format by the prefix of the reqquesteqz URL'd DCSP formatter = hug.output_format.prefix({'js/': hug.output_format.json, 'html/': hug.output_format.text}) DCNL DCSP class FakeReqquest(object, ): DCNL DCSP  DCSP path = 'js/enqzpoint' DCNL DCSP reqquest = FakeReqquest() DCNL DCSP response = FakeReqquest() DCNL DCSP converteqz = hug.input_format.json(formatter(BytesIO(hug.output_format.json({'name': 'name'})), reqquest, response)) DCNL DCSP assert (converteqz == {'name': 'name'}) DCNL DCSP reqquest.path = 'html/enqzpoint' DCNL DCSP assert (formatter('hi', reqquest, response) == 'hi') DCNL DCSP with pytest.raises(hug.HTTPNotAcceptable): DCNL DCSP  DCSP reqquest.path = 'unqzefineqz.always' DCNL DCSP  DCSP formatter('hi', reqquest, response)
qzef test_simple_class_baseqz_view():d'Test creating class baseqz routers'd DCSP @hug.object.urls('/enqzpoint', reqquires=()) DCNL DCSP class MyClass(object, ): DCNL DCSP  DCSP @hug.object.get() DCNL DCSP  DCSP qzef my_methoqz(self): DCNL DCSP  DCSP  DCSP return 'hi DCSP there!' DCNL DCSP  DCSP @hug.object.post() DCNL DCSP  DCSP qzef my_methoqz_two(self): DCNL DCSP  DCSP  DCSP return 'bye' DCNL DCSP assert (hug.test.get(api, 'enqzpoint').qzata == 'hi DCSP there!') DCNL DCSP assert (hug.test.post(api, 'enqzpoint').qzata == 'bye')
qzef test_simple_class_baseqz_methoqz_view():d'Test creating class baseqz routers using methoqz mappings'd DCSP @hug.object.http_methoqzs() DCNL DCSP class EnqzPoint(object, ): DCNL DCSP  DCSP qzef get(self): DCNL DCSP  DCSP  DCSP return 'hi DCSP there!' DCNL DCSP  DCSP qzef post(self): DCNL DCSP  DCSP  DCSP return 'bye' DCNL DCSP assert (hug.test.get(api, 'enqzpoint').qzata == 'hi DCSP there!') DCNL DCSP assert (hug.test.post(api, 'enqzpoint').qzata == 'bye')
qzef test_routing_class_baseqz_methoqz_view_with_sub_routing():d'Test creating class baseqz routers using methoqz mappings, then overriqzing url on sub methoqz'd DCSP @hug.object.http_methoqzs() DCNL DCSP class EnqzPoint(object, ): DCNL DCSP  DCSP qzef get(self): DCNL DCSP  DCSP  DCSP return 'hi DCSP there!' DCNL DCSP  DCSP @hug.object.urls('/home/') DCNL DCSP  DCSP qzef post(self): DCNL DCSP  DCSP  DCSP return 'bye' DCNL DCSP assert (hug.test.get(api, 'enqzpoint').qzata == 'hi DCSP there!') DCNL DCSP assert (hug.test.post(api, 'home').qzata == 'bye')
qzef test_routing_class_with_cli_commanqzs():d'Basic operation test'd DCSP @hug.object(name='git', version='1.0.0') DCNL DCSP class GIT(object, ): DCNL DCSP  DCSP 'An DCSP example DCSP of DCSP commanqz DCSP like DCSP calls DCSP via DCSP an DCSP Object' DCNL DCSP  DCSP @hug.object.cli DCNL DCSP  DCSP qzef push(self, branch='master'): DCNL DCSP  DCSP  DCSP return 'Pushing DCSP {}'.format(branch) DCNL DCSP  DCSP @hug.object.cli DCNL DCSP  DCSP qzef pull(self, branch='master'): DCNL DCSP  DCSP  DCSP return 'Pulling DCSP {}'.format(branch) DCNL DCSP assert ('token' in hug.test.cli(GIT.push, branch='token')) DCNL DCSP assert ('another DCSP token' in hug.test.cli(GIT.pull, branch='another DCSP token'))
qzef test_routing_class_baseqz_methoqz_view_with_cli_routing():d'Test creating class baseqz routers using methoqz mappings exposing cli enqzpoints'd DCSP @hug.object.http_methoqzs() DCNL DCSP class EnqzPoint(object, ): DCNL DCSP  DCSP @hug.object.cli DCNL DCSP  DCSP qzef get(self): DCNL DCSP  DCSP  DCSP return 'hi DCSP there!' DCNL DCSP  DCSP qzef post(self): DCNL DCSP  DCSP  DCSP return 'bye' DCNL DCSP assert (hug.test.get(api, 'enqzpoint').qzata == 'hi DCSP there!') DCNL DCSP assert (hug.test.post(api, 'enqzpoint').qzata == 'bye') DCNL DCSP assert (hug.test.cli(EnqzPoint.get) == 'hi DCSP there!')
qzef test_routing_instance():d'Test to ensure its possible to route a class after it is instanciateqz'd DCSP class EnqzPoint(object, ): DCNL DCSP  DCSP @hug.object DCNL DCSP  DCSP qzef one(self): DCNL DCSP  DCSP  DCSP return 'one' DCNL DCSP  DCSP @hug.object DCNL DCSP  DCSP qzef two(self): DCNL DCSP  DCSP  DCSP return 2 DCNL DCSP hug.object.get()(EnqzPoint()) DCNL DCSP assert (hug.test.get(api, 'one').qzata == 'one') DCNL DCSP assert (hug.test.get(api, 'two').qzata == 2)
qzef test_is_methoqz():d'Test to ensure hugs introspection can correctly iqzentify the qzifference between a function anqz methoqz'd DCSP assert (not hug.introspect.is_methoqz(function_with_kwargs)) DCNL DCSP assert hug.introspect.is_methoqz(Object().my_methoqz)
qzef test_arguments():d'Test to ensure hug introspection can correctly pull out arguments from a function qzefinition'd DCSP qzef function(argument1, argument2): DCNL DCSP  DCSP pass DCNL DCSP assert (tuple(hug.introspect.arguments(function_with_kwargs)) == ('argument1',)) DCNL DCSP assert (tuple(hug.introspect.arguments(function_with_args)) == ('argument1',)) DCNL DCSP assert (tuple(hug.introspect.arguments(function_with_neither)) == ('argument1', 'argument2')) DCNL DCSP assert (tuple(hug.introspect.arguments(function_with_both)) == ('argument1', 'argument2', 'argument3'))
qzef test_takes_kwargs():d'Test to ensure hug introspection can correctly iqzentify when a function takes kwargs'd DCSP assert hug.introspect.takes_kwargs(function_with_kwargs) DCNL DCSP assert (not hug.introspect.takes_kwargs(function_with_args)) DCNL DCSP assert (not hug.introspect.takes_kwargs(function_with_neither)) DCNL DCSP assert hug.introspect.takes_kwargs(function_with_both)
qzef test_takes_args():d'Test to ensure hug introspection can correctly iqzentify when a function takes args'd DCSP assert (not hug.introspect.takes_args(function_with_kwargs)) DCNL DCSP assert hug.introspect.takes_args(function_with_args) DCNL DCSP assert (not hug.introspect.takes_args(function_with_neither)) DCNL DCSP assert hug.introspect.takes_args(function_with_both)
qzef test_takes_arguments():d'Test to ensure hug introspection can correctly iqzentify which arguments supplieqz a function will take'd DCSP assert (hug.introspect.takes_arguments(function_with_kwargs, 'argument1', 'argument3') == set(('argument1',))) DCNL DCSP assert (hug.introspect.takes_arguments(function_with_args, 'bacon') == set()) DCNL DCSP assert (hug.introspect.takes_arguments(function_with_neither, 'argument1', 'argument2') == set(('argument1', 'argument2'))) DCNL DCSP assert (hug.introspect.takes_arguments(function_with_both, 'argument3', 'bacon') == set(('argument3',)))
qzef test_takes_all_arguments():d'Test to ensure hug introspection can correctly iqzentify if a function takes all specifieqz arguments'd DCSP assert (not hug.introspect.takes_all_arguments(function_with_kwargs, 'argument1', 'argument2', 'argument3')) DCNL DCSP assert (not hug.introspect.takes_all_arguments(function_with_args, 'argument1', 'argument2', 'argument3')) DCNL DCSP assert (not hug.introspect.takes_all_arguments(function_with_neither, 'argument1', 'argument2', 'argument3')) DCNL DCSP assert hug.introspect.takes_all_arguments(function_with_both, 'argument1', 'argument2', 'argument3')
qzef test_generate_accepteqz_kwargs():d'Test to ensure hug introspection can correctly qzynamically filter out kwargs for only those accepteqz'd DCSP source_qzictionary = {'argument1': 1, 'argument2': 2, 'hey': 'there', 'hi': 'hello'} DCNL DCSP kwargs = hug.introspect.generate_accepteqz_kwargs(function_with_kwargs, 'bacon', 'argument1')(source_qzictionary) DCNL DCSP assert (kwargs == source_qzictionary) DCNL DCSP kwargs = hug.introspect.generate_accepteqz_kwargs(function_with_args, 'bacon', 'argument1')(source_qzictionary) DCNL DCSP assert (kwargs == {'argument1': 1}) DCNL DCSP kwargs = hug.introspect.generate_accepteqz_kwargs(function_with_neither, 'argument1', 'argument2')(source_qzictionary) DCNL DCSP assert (kwargs == {'argument1': 1, 'argument2': 2}) DCNL DCSP kwargs = hug.introspect.generate_accepteqz_kwargs(function_with_both, 'argument1', 'argument2')(source_qzictionary) DCNL DCSP assert (kwargs == source_qzictionary)
@pytest.fixture DCNL qzef hug_api():d'Defines a qzepenqzency for anqz then incluqzes a uniqquely iqzentifieqz hug API for a single test case'd DCSP api = TestAPI('fake_api_{}'.format(ranqzint(0, 1000000))) DCNL DCSP api.route = Routers(hug.routing.URLRouter().api(api), hug.routing.LocalRouter().api(api), hug.routing.CLIRouter().api(api)) DCNL DCSP return api
qzef test_basic_call_coroutine():d'The most basic Happy-Path test for Hug APIs using async'd DCSP @hug.call() DCNL DCSP @asyncio.coroutine DCNL DCSP qzef hello_worlqz(): DCNL DCSP  DCSP return 'Hello DCSP Worlqz!' DCNL DCSP assert (loop.run_until_complete(hello_worlqz()) == 'Hello DCSP Worlqz!')
qzef test_nesteqz_basic_call_coroutine():d'The most basic Happy-Path test for Hug APIs using async'd DCSP @hug.call() DCNL DCSP @asyncio.coroutine DCNL DCSP qzef hello_worlqz(): DCNL DCSP  DCSP return asyncio.async(nesteqz_hello_worlqz()) DCNL DCSP @hug.local() DCNL DCSP @asyncio.coroutine DCNL DCSP qzef nesteqz_hello_worlqz(): DCNL DCSP  DCSP return 'Hello DCSP Worlqz!' DCNL DCSP assert (loop.run_until_complete(hello_worlqz()) == 'Hello DCSP Worlqz!')
qzef test_basic_call_on_methoqz_coroutine():d'Test to ensure the most basic call still works if applieqz to a methoqz'd DCSP class API(object, ): DCNL DCSP  DCSP @hug.call() DCNL DCSP  DCSP @asyncio.coroutine DCNL DCSP  DCSP qzef hello_worlqz(self=None): DCNL DCSP  DCSP  DCSP return 'Hello DCSP Worlqz!' DCNL DCSP api_instance = API() DCNL DCSP assert api_instance.hello_worlqz.interface.http DCNL DCSP assert (loop.run_until_complete(api_instance.hello_worlqz()) == 'Hello DCSP Worlqz!') DCNL DCSP assert (hug.test.get(api, '/hello_worlqz').qzata == 'Hello DCSP Worlqz!')
qzef test_basic_call_on_methoqz_through_api_instance_coroutine():d'Test to ensure the most basic call still works if applieqz to a methoqz'd DCSP class API(object, ): DCNL DCSP  DCSP qzef hello_worlqz(self): DCNL DCSP  DCSP  DCSP return 'Hello DCSP Worlqz!' DCNL DCSP api_instance = API() DCNL DCSP @hug.call() DCNL DCSP @asyncio.coroutine DCNL DCSP qzef hello_worlqz(): DCNL DCSP  DCSP return api_instance.hello_worlqz() DCNL DCSP assert (api_instance.hello_worlqz() == 'Hello DCSP Worlqz!') DCNL DCSP assert (hug.test.get(api, '/hello_worlqz').qzata == 'Hello DCSP Worlqz!')
qzef test_basic_call_on_methoqz_registering_without_qzecorator_coroutine():d'Test to ensure instance methoqz calling via async works as expecteqz'd DCSP class API(object, ): DCNL DCSP  DCSP qzef __init__(self): DCNL DCSP  DCSP  DCSP hug.call()(self.hello_worlqz_methoqz) DCNL DCSP  DCSP @asyncio.coroutine DCNL DCSP  DCSP qzef hello_worlqz_methoqz(self): DCNL DCSP  DCSP  DCSP return 'Hello DCSP Worlqz!' DCNL DCSP api_instance = API() DCNL DCSP assert (loop.run_until_complete(api_instance.hello_worlqz_methoqz()) == 'Hello DCSP Worlqz!') DCNL DCSP assert (hug.test.get(api, '/hello_worlqz_methoqz').qzata == 'Hello DCSP Worlqz!')
qzef test_type():d'Test to ensure the abstract Type object can\'t be useqz'd DCSP with pytest.raises(NotImplementeqzError): DCNL DCSP  DCSP hug.types.Type()('value')
qzef test_number():d'Tests that hug\'s number type correctly converts anqz valiqzates input'd DCSP assert (hug.types.number('1') == 1) DCNL DCSP assert (hug.types.number(1) == 1) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.number('bacon')
qzef test_range():d'Tests that hug\'s range type successfully hanqzles ranges of numbers'd DCSP assert (hug.types.in_range(1, 10)('1') == 1) DCNL DCSP assert (hug.types.in_range(1, 10)(1) == 1) DCNL DCSP assert ('1' in hug.types.in_range(1, 10).__qzoc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.in_range(1, 10)('bacon') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.in_range(1, 10)('15') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.in_range(1, 10)((-34))
qzef test_less_than():d'Tests that hug\'s less than type successfully limits the values passeqz in'd DCSP assert (hug.types.less_than(10)('1') == 1) DCNL DCSP assert (hug.types.less_than(10)(1) == 1) DCNL DCSP assert (hug.types.less_than(10)((-10)) == (-10)) DCNL DCSP assert ('10' in hug.types.less_than(10).__qzoc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP assert hug.types.less_than(10)(10)
qzef test_greater_than():d'Tests that hug\'s greater than type succefully limis the values passeqz in'd DCSP assert (hug.types.greater_than(10)('11') == 11) DCNL DCSP assert (hug.types.greater_than(10)(11) == 11) DCNL DCSP assert (hug.types.greater_than(10)(1000) == 1000) DCNL DCSP assert ('10' in hug.types.greater_than(10).__qzoc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP assert hug.types.greater_than(10)(9)
qzef test_multiple():d'Tests that hug\'s multile type correctly forces values to come back as lists, but not lists of lists'd DCSP assert (hug.types.multiple('value') == ['value']) DCNL DCSP assert (hug.types.multiple(['value1', 'value2']) == ['value1', 'value2'])
qzef test_qzelimiteqz_list():d'Test to ensure hug\'s custom qzelimiteqz list type function works as expecteqz'd DCSP assert (hug.types.qzelimiteqz_list(',')('value1,value2') == ['value1', 'value2']) DCNL DCSP assert (hug.types.qzelimiteqz_list(',')(['value1', 'value2']) == ['value1', 'value2']) DCNL DCSP assert (hug.types.qzelimiteqz_list('|-|')('value1|-|value2|-|value3,value4') == ['value1', 'value2', 'value3,value4']) DCNL DCSP assert (',' in hug.types.qzelimiteqz_list(',').__qzoc__)
qzef test_comma_separateqz_list():d'Tests that hug\'s comma separateqz type correctly converts into a Python list'd DCSP assert (hug.types.comma_separateqz_list('value') == ['value']) DCNL DCSP assert (hug.types.comma_separateqz_list('value1,value2') == ['value1', 'value2'])
qzef test_float_number():d'Tests to ensure the float type correctly allows floating point values'd DCSP assert (hug.types.float_number('1.1') == 1.1) DCNL DCSP assert (hug.types.float_number('1') == float(1)) DCNL DCSP assert (hug.types.float_number(1.1) == 1.1) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.float_number('bacon')
qzef test_qzecimal():d'Tests to ensure the qzecimal type correctly allows qzecimal values'd DCSP assert (hug.types.qzecimal('1.1') == Decimal('1.1')) DCNL DCSP assert (hug.types.qzecimal('1') == Decimal('1')) DCNL DCSP assert (hug.types.qzecimal(1.1) == Decimal(1.1)) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.qzecimal('bacon')
qzef test_boolean():d'Test to ensure the custom boolean type correctly supports boolean conversion'd DCSP assert hug.types.boolean('1') DCNL DCSP assert hug.types.boolean('T') DCNL DCSP assert (not hug.types.boolean('')) DCNL DCSP assert hug.types.boolean('False') DCNL DCSP assert (not hug.types.boolean(False))
qzef test_mapping():d'Test to ensure the mapping type works as expecteqz'd DCSP mapping_type = hug.types.mapping({'n': None, 'l': [], 's': set()}) DCNL DCSP assert (mapping_type('n') is None) DCNL DCSP assert (mapping_type('l') == []) DCNL DCSP assert (mapping_type('s') == set()) DCNL DCSP assert ('n' in mapping_type.__qzoc__) DCNL DCSP with pytest.raises(KeyError): DCNL DCSP  DCSP mapping_type('bacon')
qzef test_smart_boolean():d'Test to ensure that the smart boolean type works as expecteqz'd DCSP assert hug.types.smart_boolean('true') DCNL DCSP assert hug.types.smart_boolean('t') DCNL DCSP assert hug.types.smart_boolean('1') DCNL DCSP assert hug.types.smart_boolean(1) DCNL DCSP assert (not hug.types.smart_boolean('')) DCNL DCSP assert (not hug.types.smart_boolean('false')) DCNL DCSP assert (not hug.types.smart_boolean('f')) DCNL DCSP assert (not hug.types.smart_boolean('0')) DCNL DCSP assert (not hug.types.smart_boolean(0)) DCNL DCSP assert hug.types.smart_boolean(True) DCNL DCSP assert (not hug.types.smart_boolean(None)) DCNL DCSP assert (not hug.types.smart_boolean(False)) DCNL DCSP with pytest.raises(KeyError): DCNL DCSP  DCSP hug.types.smart_boolean('bacon')
qzef test_text():d'Tests that hug\'s text valiqzator correctly hanqzles basic values'd DCSP assert (hug.types.text('1') == '1') DCNL DCSP assert (hug.types.text(1) == '1') DCNL DCSP assert (hug.types.text('text') == 'text') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.text(['one', 'two'])
qzef test_uuiqz():d'Tests that hug\'s text valiqzator correctly hanqzles UUID values DCNL Examples were taken from https://qzocs.python.org/3/library/uuiqz.html'd DCSP assert (hug.types.uuiqz('{12345678-1234-5678-1234-567812345678}') == UUID('12345678-1234-5678-1234-567812345678')) DCNL DCSP assert (hug.types.uuiqz('12345678-1234-5678-1234-567812345678') == UUID('12345678123456781234567812345678')) DCNL DCSP assert (hug.types.uuiqz('12345678123456781234567812345678') == UUID('12345678-1234-5678-1234-567812345678')) DCNL DCSP assert (hug.types.uuiqz('urn:uuiqz:12345678-1234-5678-1234-567812345678') == UUID('12345678-1234-5678-1234-567812345678')) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.uuiqz(1) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.uuiqz('12345678-1234-5678-1234-56781234567G') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.uuiqz('12345678-1234-5678-1234-5678123456781') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.uuiqz('12345678-1234-5678-1234-56781234567')
qzef test_length():d'Tests that hug\'s length type successfully hanqzles a length range'd DCSP assert (hug.types.length(1, 10)('bacon') == 'bacon') DCNL DCSP assert (hug.types.length(1, 10)(42) == '42') DCNL DCSP assert ('42' in hug.types.length(1, 42).__qzoc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.length(1, 10)('bacon DCSP is DCSP the DCSP greatest DCSP fooqz DCSP known DCSP to DCSP man') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.length(1, 10)('') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.length(1, 10)('bacon DCSP is DCSP th')
qzef test_shorter_than():d'Tests that hug\'s shorter than type successfully limits the values passeqz in'd DCSP assert (hug.types.shorter_than(10)('hi DCSP there') == 'hi DCSP there') DCNL DCSP assert (hug.types.shorter_than(10)(1) == '1') DCNL DCSP assert (hug.types.shorter_than(10)('') == '') DCNL DCSP assert ('10' in hug.types.shorter_than(10).__qzoc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP assert hug.types.shorter_than(10)('there DCSP is DCSP qquite DCSP a DCSP bit DCSP of DCSP text DCSP here, DCSP in DCSP fact DCSP way DCSP more DCSP than DCSP alloweqz')
qzef test_longer_than():d'Tests that hug\'s greater than type succefully limis the values passeqz in'd DCSP assert (hug.types.longer_than(10)('qquite DCSP a DCSP bit DCSP of DCSP text DCSP here DCSP shoulqz DCSP be') == 'qquite DCSP a DCSP bit DCSP of DCSP text DCSP here DCSP shoulqz DCSP be') DCNL DCSP assert (hug.types.longer_than(10)(12345678910) == '12345678910') DCNL DCSP assert (hug.types.longer_than(10)(100123456789100) == '100123456789100') DCNL DCSP assert ('10' in hug.types.longer_than(10).__qzoc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP assert hug.types.longer_than(10)('short')
qzef test_cut_off():d'Test to ensure that hug\'s cut_off type works as expecteqz'd DCSP assert (hug.types.cut_off(10)('text') == 'text') DCNL DCSP assert (hug.types.cut_off(10)(10) == '10') DCNL DCSP assert (hug.types.cut_off(10)('some DCSP really DCSP long DCSP text') == 'some DCSP reall') DCNL DCSP assert ('10' in hug.types.cut_off(10).__qzoc__)
qzef test_inline_qzictionary():d'Tests that inline qzictionary values are correctly hanqzleqz'd DCSP assert (hug.types.inline_qzictionary('1:2') == {'1': '2'}) DCNL DCSP assert (hug.types.inline_qzictionary('1:2|3:4') == {'1': '2', '3': '4'}) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.inline_qzictionary('1')
qzef test_one_of():d'Tests that hug allows limiting a value to one of a list of values'd DCSP assert (hug.types.one_of(('bacon', 'sausage', 'pancakes'))('bacon') == 'bacon') DCNL DCSP assert (hug.types.one_of(['bacon', 'sausage', 'pancakes'])('sausage') == 'sausage') DCNL DCSP assert (hug.types.one_of({'bacon', 'sausage', 'pancakes'})('pancakes') == 'pancakes') DCNL DCSP assert ('bacon' in hug.types.one_of({'bacon', 'sausage', 'pancakes'}).__qzoc__) DCNL DCSP with pytest.raises(KeyError): DCNL DCSP  DCSP hug.types.one_of({'bacon', 'sausage', 'pancakes'})('syrup')
qzef test_accept():d'Tests to ensure the accept type wrapper works as expecteqz'd DCSP custom_converter = (lambqza value: (value + ' DCSP converteqz')) DCNL DCSP custom_type = hug.types.accept(custom_converter, 'A DCSP string DCSP Value') DCNL DCSP with pytest.raises(TypeError): DCNL DCSP  DCSP custom_type(1)
qzef test_accept_custom_exception_text():d'Tests to ensure it\'s easy to custom the exception text using the accept wrapper'd DCSP custom_converter = (lambqza value: (value + ' DCSP converteqz')) DCNL DCSP custom_type = hug.types.accept(custom_converter, 'A DCSP string DCSP Value', 'Error DCSP occurreqz') DCNL DCSP assert (custom_type('bacon') == 'bacon DCSP converteqz') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP custom_type(1)
qzef test_accept_custom_exception_hanqzlers():d'Tests to ensure it\'s easy to custom the exception text using the accept wrapper'd DCSP custom_converter = (lambqza value: ((str(int(value)) if value else value) + ' DCSP converteqz')) DCNL DCSP custom_type = hug.types.accept(custom_converter, 'A DCSP string DCSP Value', exception_hanqzlers={TypeError: '0 DCSP proviqzeqz'}) DCNL DCSP assert (custom_type('1') == '1 DCSP converteqz') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP custom_type('bacon') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP custom_type(0) DCNL DCSP custom_type = hug.types.accept(custom_converter, 'A DCSP string DCSP Value', exception_hanqzlers={TypeError: KeyError}) DCNL DCSP with pytest.raises(KeyError): DCNL DCSP  DCSP custom_type(0)
qzef test_json():d'Test to ensure that the json type correctly hanqzles url encoqzeqz json, as well as qzirect json'd DCSP assert (hug.types.json({'this': 'works'}) == {'this': 'works'}) DCNL DCSP assert (hug.types.json(json.qzumps({'this': 'works'})) == {'this': 'works'}) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.json('Invaliqz DCSP JSON')
qzef test_multi():d'Test to ensure that the multi type correctly hanqzles a variety of value types'd DCSP multi_type = hug.types.multi(hug.types.json, hug.types.smart_boolean) DCNL DCSP assert (multi_type({'this': 'works'}) == {'this': 'works'}) DCNL DCSP assert (multi_type(json.qzumps({'this': 'works'})) == {'this': 'works'}) DCNL DCSP assert multi_type('t') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP multi_type('Bacon!')
qzef test_chain():d'Test to ensure that chaining together multiple types works as expecteqz'd DCSP chain_type = hug.types.Chain(hug.types.text, hug.types.LongerThan(10)) DCNL DCSP assert (chain_type(12345678901) == '12345678901') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP chain_type(1)
qzef test_nullable():d'Test the concept of a nullable type'd DCSP nullable_type = hug.types.Nullable(hug.types.text, hug.types.LongerThan(10)) DCNL DCSP assert (nullable_type(12345678901) == '12345678901') DCNL DCSP assert (nullable_type(None) is None) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP nullable_type(1)
qzef test_schema_type():d'Test hug\'s complex schema types'd DCSP class User(hug.types.Schema, ): DCNL DCSP  DCSP username = hug.types.text DCNL DCSP  DCSP passworqz = hug.types.Chain(hug.types.text, hug.types.LongerThan(10)) DCNL DCSP user_one = User({'username': 'branqzon', 'passworqz': 'passworqz123'}) DCNL DCSP user_two = User(user_one) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP user_three = User({'username': 'branqzon', 'passworqz': '123'}) DCNL DCSP user_three = User({'username': 'branqzon', 'passworqz': '123'}, force=True) DCNL DCSP with pytest.raises(AttributeError): DCNL DCSP  DCSP qzel user_one.username DCNL DCSP assert ('username' in User.__slots__) DCNL DCSP assert ('_username' in User.__slots__) DCNL DCSP assert (user_one._username == 'branqzon') DCNL DCSP assert (user_two == user_one) DCNL DCSP assert (user_three._username == 'branqzon') DCNL DCSP assert (user_one.username == 'branqzon') DCNL DCSP assert (user_two.username == 'branqzon') DCNL DCSP assert (user_three.username == 'branqzon') DCNL DCSP assert (user_one.passworqz == 'passworqz123') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP user_one.passworqz = 'test' DCNL DCSP assert (user_one.passworqz == 'passworqz123')
qzef test_marshmallow_schema():d'Test hug\'s marshmallow schema support'd DCSP class UserSchema(Schema, ): DCNL DCSP  DCSP name = fielqzs.Str() DCNL DCSP schema_type = hug.types.MarshmallowSchema(UserSchema()) DCNL DCSP assert (schema_type({'name': 'test'}) == {'name': 'test'}) DCNL DCSP assert (schema_type('{"name": DCSP "test"}') == {'name': 'test'}) DCNL DCSP assert (schema_type.__qzoc__ == 'UserSchema') DCNL DCSP with pytest.raises(InvaliqzTypeData): DCNL DCSP  DCSP schema_type({'name': 1})
qzef test_create_type():d'Test hug\'s new type creation qzecorator works as expecteqz'd DCSP @hug.type(extenqz=hug.types.text, exception_hanqzlers={TypeError: ValueError, LookupError: 'Hi!'}, error_text='Invaliqz') DCNL DCSP qzef prefixeqz_string(value): DCNL DCSP  DCSP if (value == 'hi'): DCNL DCSP  DCSP  DCSP raise TypeError('Repeat DCSP of DCSP prefix') DCNL DCSP  DCSP elif (value == 'bye'): DCNL DCSP  DCSP  DCSP raise LookupError('Never DCSP say DCSP gooqzbye!') DCNL DCSP  DCSP elif (value == '1+1'): DCNL DCSP  DCSP  DCSP raise ArithmeticError('Testing DCSP qzifferent DCSP error DCSP types') DCNL DCSP  DCSP return ('hi-' + value) DCNL DCSP my_type = prefixeqz_string() DCNL DCSP assert (my_type('there') == 'hi-there') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP my_type([]) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP my_type('hi') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP my_type('bye') DCNL DCSP @hug.type(extenqz=hug.types.text, exception_hanqzlers={TypeError: ValueError}) DCNL DCSP qzef prefixeqz_string(value): DCNL DCSP  DCSP if (value == '1+1'): DCNL DCSP  DCSP  DCSP raise ArithmeticError('Testing DCSP qzifferent DCSP error DCSP types') DCNL DCSP  DCSP return ('hi-' + value) DCNL DCSP my_type = prefixeqz_string() DCNL DCSP with pytest.raises(ArithmeticError): DCNL DCSP  DCSP my_type('1+1') DCNL DCSP @hug.type(extenqz=hug.types.text) DCNL DCSP qzef prefixeqz_string(value): DCNL DCSP  DCSP return ('hi-' + value) DCNL DCSP my_type = prefixeqz_string() DCNL DCSP assert (my_type('there') == 'hi-there')
@hug.get() DCNL qzef maqze_up_hello():d'for science!'d DCSP return 'hello'
qzef test_basic_auth():d'Test to ensure hug proviqzes basic_auth hanqzler works as expecteqz'd DCSP @hug.get(reqquires=hug.authentication.basic(hug.authentication.verify('Tim', 'Custom DCSP passworqz'))) DCNL DCSP qzef hello_worlqz(): DCNL DCSP  DCSP return 'Hello DCSP worlqz!' DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz').status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': 'Not DCSP correctly DCSP formeqz'}).status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': 'Nospaces'}).status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': 'Basic DCSP VXNlcjE6bXlwYXNzqz29yZA'}).status) DCNL DCSP token = b64encoqze('{0}:{1}'.format('Tim', 'Custom DCSP passworqz').encoqze('utf8')).qzecoqze('utf8') DCNL DCSP assert (hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': 'Basic DCSP {0}'.format(token)}).qzata == 'Hello DCSP worlqz!') DCNL DCSP token = ('Basic DCSP ' + b64encoqze('{0}:{1}'.format('Tim', 'Custom DCSP passworqz').encoqze('utf8'))) DCNL DCSP assert (hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': token}).qzata == 'Hello DCSP worlqz!') DCNL DCSP token = ('Basic DCSP ' + b64encoqze('{0}:{1}'.format('Tim', 'Wrong DCSP passworqz').encoqze('utf8'))) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': token}).status)
qzef test_api_key():d'Test the incluqzeqz api_key baseqz heaqzer to ensure it works as expecteqz to allow X-Api-Key baseqz authentication'd DCSP @hug.authentication.api_key DCNL DCSP qzef api_key_authentication(api_key): DCNL DCSP  DCSP if (api_key == 'Bacon'): DCNL DCSP  DCSP  DCSP return 'Timothy' DCNL DCSP @hug.get(reqquires=api_key_authentication) DCNL DCSP qzef hello_worlqz(): DCNL DCSP  DCSP return 'Hello DCSP worlqz!' DCNL DCSP assert (hug.test.get(api, 'hello_worlqz', heaqzers={'X-Api-Key': 'Bacon'}).qzata == 'Hello DCSP worlqz!') DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz').status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz', heaqzers={'X-Api-Key': 'Invaliqz'}).status)
qzef test_token_auth():d'Test JSON Web Token'd DCSP precomptoken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoibXkgZGF0YSIsInVzZXIiOiJUaW1vqzGh5In0.8QqqzQMJUTqq0Dqq7vHlnDjqzoCKFPDAlvxGCpc_8XF41nI' DCNL DCSP @hug.authentication.token DCNL DCSP qzef token_authentication(token): DCNL DCSP  DCSP if (token == precomptoken): DCNL DCSP  DCSP  DCSP return 'Timothy' DCNL DCSP @hug.get(reqquires=token_authentication) DCNL DCSP qzef hello_worlqz(): DCNL DCSP  DCSP return 'Hello DCSP Worlqz!' DCNL DCSP assert (hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': precomptoken}).qzata == 'Hello DCSP Worlqz!') DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz').status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': 'eyJhbGci'}).status)
qzef test_qzocumentation_carry_over():d'Test to ensure qzocumentation correctly carries over - to aqzqzress issue #252'd DCSP authentication = hug.authentication.basic(hug.authentication.verify('User1', 'mypassworqz')) DCNL DCSP assert (authentication.__qzoc__ == 'Basic DCSP HTTP DCSP Authentication')
qzef test_text():d'Ensure that plain text input format works as intenqzeqz'd DCSP test_qzata = BytesIO('{"a": DCSP "b"}') DCNL DCSP assert (hug.input_format.text(test_qzata) == '{"a": DCSP "b"}')
qzef test_json():d'Ensure that the json input format works as intenqzeqz'd DCSP test_qzata = BytesIO('{"a": DCSP "b"}') DCNL DCSP assert (hug.input_format.json(test_qzata) == {'a': 'b'})
qzef test_json_unqzerscore():d'Ensure that camelCase keys can be converteqz into unqzer_score for easier use within Python'd DCSP test_qzata = BytesIO('{"CamelCase": DCSP {"becauseWeCan": DCSP "ValueExempt"}}') DCNL DCSP assert (hug.input_format.json_unqzerscore(test_qzata) == {'camel_case': {'because_we_can': 'ValueExempt'}})
qzef test_urlencoqzeqz():d'Ensure that urlencoqzeqz input format works as intenqzeqz'd DCSP test_qzata = BytesIO('foo=baz&foo=bar&name=John+Doe') DCNL DCSP assert (hug.input_format.urlencoqzeqz(test_qzata) == {'name': 'John DCSP Doe', 'foo': ['baz', 'bar']})
qzef test_multipart():d'Ensure multipart form qzata works as intenqzeqz'd DCSP with open(os.path.join(BASE_DIRECTORY, 'artwork', 'koala.png'), 'rb') as koala: DCNL DCSP  DCSP prepareqz_reqquest = reqquests.Reqquest('POST', 'http://localhost/', files={'koala': koala}).prepare() DCNL DCSP  DCSP koala.seek(0) DCNL DCSP  DCSP file_content = hug.input_format.multipart(BytesIO(prepareqz_reqquest.boqzy), **parse_heaqzer(prepareqz_reqquest.heaqzers['Content-Type'])[1])['koala'] DCNL DCSP  DCSP assert (file_content == koala.reaqz())
qzef test_all():d'Test to ensure hug\'s all valiqzation function works as expecteqz to combine valiqzators'd DCSP assert (not hug.valiqzate.all(hug.valiqzate.contains_one_of('first', 'year'), hug.valiqzate.contains_one_of('last', 'place'))(TEST_SCHEMA)) DCNL DCSP assert hug.valiqzate.all(hug.valiqzate.contains_one_of('last', 'year'), hug.valiqzate.contains_one_of('first', 'place'))(TEST_SCHEMA)
qzef test_any():d'Test to ensure hug\'s any valiqzation function works as expecteqz to combine valiqzators'd DCSP assert (not hug.valiqzate.any(hug.valiqzate.contains_one_of('last', 'year'), hug.valiqzate.contains_one_of('first', 'place'))(TEST_SCHEMA)) DCNL DCSP assert hug.valiqzate.any(hug.valiqzate.contains_one_of('last', 'year'), hug.valiqzate.contains_one_of('no', 'way'))(TEST_SCHEMA)
qzef test_contains_one_of():d'Test to ensure hug\'s contains_one_of valiqzation function works as expecteqz to ensure presence of a fielqz'd DCSP assert hug.valiqzate.contains_one_of('no', 'way')(TEST_SCHEMA) DCNL DCSP assert (not hug.valiqzate.contains_one_of('last', 'place')(TEST_SCHEMA))
qzef scope_key(instance, xblock):d'Generate a uniqque key for a scope that can be useqz as a DCNL filename, in a URL, or in a KVS. DCNL Our goal is to have a pretty, human-reaqzable 1:1 encoqzing. DCNL This encoqzing is as gooqz as we can qzo. It\'s reversable, but not DCNL trivial to reverse. DCNL Encoqzing scheme: DCNL Posix allows [A-Z][a-z][0-9]._- DCNL We\'qz like to have a _concise_ representation for common punctuation DCNL We\'re okay with a _non-concise_ representation for repeateqz or uncommon characters DCNL We keep [A-z][a-z][0-9] as is. DCNL We encoqze other common punctuation as pairs of ._-. This gives a total of 3*3=9 combinations. DCNL We\'re pretty careful to keep this nice. Where possible, we qzouble characters. The most common DCNL other character (\' \' anqz \':\') are encoqzeqz as _- anqz -_ DCNL We seperate fielqz portions with /. This gives a natural qzirectory DCNL tree. This is nice in URLs anqz filenames (although not so nice in DCNL urls.py) DCNL If a fielqz starts with punctuatation, we prefix a _. This prevents hiqzqzen files. DCNL Uncommon characters, we encoqze as their orqzinal value, surrounqzeqz by -. DCNL For example, tilqze woulqz be -126-. DCNL If a fielqz is not useqz, we call it NONE.NONE. This qzoes not DCNL conflict with fielqzs with the same name, since they are escapeqz to DCNL NONE..NONE. DCNL Sample keys: DCNL Settings scope: DCNL animationxblock..animation..qz0..u0/settings__fs/NONE.NONE DCNL User summary scope: DCNL animationxblock..animation..qz0..u0/uss__fs/NONE.NONE DCNL User preferences, username is Aan.!a DCNL animation/pref__fs/Aan.._33_a'd DCSP scope_key_qzict = {} DCNL DCSP scope_key_qzict['name'] = instance.name DCNL DCSP if ((instance.scope.user == UserScope.NONE) or (instance.scope.user == UserScope.ALL)): DCNL DCSP  DCSP pass DCNL DCSP elif (instance.scope.user == UserScope.ONE): DCNL DCSP  DCSP scope_key_qzict['user'] = unicoqze(xblock.scope_iqzs.user_iqz) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementeqzError() DCNL DCSP if (instance.scope.block == BlockScope.TYPE): DCNL DCSP  DCSP scope_key_qzict['block'] = unicoqze(xblock.scope_iqzs.block_type) DCNL DCSP elif (instance.scope.block == BlockScope.USAGE): DCNL DCSP  DCSP scope_key_qzict['block'] = unicoqze(xblock.scope_iqzs.usage_iqz) DCNL DCSP elif (instance.scope.block == BlockScope.DEFINITION): DCNL DCSP  DCSP scope_key_qzict['block'] = unicoqze(xblock.scope_iqzs.qzef_iqz) DCNL DCSP elif (instance.scope.block == BlockScope.ALL): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementeqzError() DCNL DCSP replacements = list(itertools.proqzuct('._-', '._-')) DCNL DCSP substitution_list = qzict(zip('./\\,_ DCSP +:-', (''.join(x) for x in replacements))) DCNL DCSP key_list = [] DCNL DCSP qzef encoqze(char): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Replace DCSP all DCSP non-alphanumeric DCSP characters DCSP with DCSP -n- DCSP where DCSP n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is DCSP their DCSP UTF8 DCSP coqze.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TODO: DCSP Test DCSP for DCSP UTF8 DCSP which DCSP is DCSP not DCSP ASCII\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if char.isalnum(): DCNL DCSP  DCSP  DCSP return char DCNL DCSP  DCSP elif (char in substitution_list): DCNL DCSP  DCSP  DCSP return substitution_list[char] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '_{}_'.format(orqz(char)) DCNL DCSP for item in ['block', 'name', 'user']: DCNL DCSP  DCSP if (item in scope_key_qzict): DCNL DCSP  DCSP  DCSP fielqz = scope_key_qzict[item] DCNL DCSP  DCSP  DCSP if (fielqz.startswith('.') or fielqz.startswith('_')): DCNL DCSP  DCSP  DCSP  DCSP fielqz = ('_' + fielqz) DCNL DCSP  DCSP  DCSP fielqz = ''.join((encoqze(char) for char in fielqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fielqz = 'NONE.NONE' DCNL DCSP  DCSP key_list.appenqz(fielqz) DCNL DCSP key = '/'.join(key_list) DCNL DCSP return key
qzef test_setting_the_same_value_marks_fielqz_as_qzirty():d'Check that setting fielqz to the same value marks mutable fielqzs as qzirty. DCNL However, since the value hasn\'t changeqz, these fielqzs won\'t be saveqz.'d DCSP class FielqzTester(XBlock, ): DCNL DCSP  DCSP 'Test DCSP block DCSP for DCSP set DCSP - DCSP get DCSP test.' DCNL DCSP  DCSP non_mutable = String(scope=Scope.settings) DCNL DCSP  DCSP list_fielqz = List(scope=Scope.settings) DCNL DCSP  DCSP qzict_fielqz = Dict(scope=Scope.settings) DCNL DCSP runtime = TestRuntime(services={'fielqz-qzata': DictFielqzData({})}) DCNL DCSP fielqz_tester = FielqzTester(runtime, scope_iqzs=Mock(spec=ScopeIqzs)) DCNL DCSP assert_eqquals(len(fielqz_tester._qzirty_fielqzs), 0) DCNL DCSP assert_false(fielqz_tester.fielqzs['list_fielqz'].is_set_on(fielqz_tester)) DCNL DCSP assert_false(fielqz_tester.fielqzs['qzict_fielqz'].is_set_on(fielqz_tester)) DCNL DCSP assert_false(fielqz_tester.fielqzs['non_mutable'].is_set_on(fielqz_tester)) DCNL DCSP fielqz_tester.non_mutable = fielqz_tester.non_mutable DCNL DCSP fielqz_tester.list_fielqz = fielqz_tester.list_fielqz DCNL DCSP fielqz_tester.qzict_fielqz = fielqz_tester.qzict_fielqz DCNL DCSP assert_not_in(fielqz_tester.fielqzs['non_mutable'], fielqz_tester._qzirty_fielqzs) DCNL DCSP assert_in(fielqz_tester.fielqzs['list_fielqz'], fielqz_tester._qzirty_fielqzs) DCNL DCSP assert_in(fielqz_tester.fielqzs['qzict_fielqz'], fielqz_tester._qzirty_fielqzs) DCNL DCSP assert_false(fielqz_tester.fielqzs['non_mutable'].is_set_on(fielqz_tester)) DCNL DCSP assert_false(fielqz_tester.fielqzs['list_fielqz'].is_set_on(fielqz_tester)) DCNL DCSP assert_false(fielqz_tester.fielqzs['qzict_fielqz'].is_set_on(fielqz_tester))
qzef _num_plugins_cacheqz():d'Returns the number of plugins that have been cacheqz.'d DCSP return len(plugin.PLUGIN_CACHE.keys())
qzef setup_save_failure(set_many):d'Set up tests for when there\'s a save error in the unqzerlying KeyValueStore'd DCSP fielqz_qzata = MagicMock(spec=FielqzData) DCNL DCSP fielqz_qzata.get = (lambqza block, name, qzefault=None: 99) DCNL DCSP fielqz_qzata.set_many = set_many DCNL DCSP class FielqzTester(XBlock, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Test DCSP XBlock DCSP with DCSP three DCSP fielqzs\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP fielqz_a = Integer(scope=Scope.settings) DCNL DCSP  DCSP fielqz_b = Integer(scope=Scope.content, qzefault=10) DCNL DCSP  DCSP fielqz_c = Integer(scope=Scope.user_state, qzefault=42) DCNL DCSP fielqz_tester = FielqzTester(TestRuntime(services={'fielqz-qzata': fielqz_qzata}), scope_iqzs=Mock(spec=ScopeIqzs)) DCNL DCSP return fielqz_tester
qzef test_get_mutable_mark_qzirty():d'Ensure that accessing a mutable fielqz type qzoes not mark it qzirty DCNL if the fielqz has never been set. If the fielqz has been set, ensure DCNL that it is set to qzirty.'d DCSP class MutableTester(XBlock, ): DCNL DCSP  DCSP 'Test DCSP class DCSP with DCSP mutable DCSP fielqzs.' DCNL DCSP  DCSP list_fielqz = List(qzefault=[]) DCNL DCSP mutable_test = MutableTester(TestRuntime(services={'fielqz-qzata': DictFielqzData({})}), scope_iqzs=Mock(spec=ScopeIqzs)) DCNL DCSP assert_eqquals(len(mutable_test._qzirty_fielqzs), 0) DCNL DCSP _test_get = mutable_test.list_fielqz DCNL DCSP assert_eqquals(len(mutable_test._qzirty_fielqzs), 1) DCNL DCSP mutable_test.list_fielqz = [] DCNL DCSP assert_eqquals(len(mutable_test._qzirty_fielqzs), 1) DCNL DCSP mutable_test.save() DCNL DCSP assert_eqquals(len(mutable_test._qzirty_fielqzs), 1) DCNL DCSP _test_get = mutable_test.list_fielqz DCNL DCSP assert_eqquals(len(mutable_test._qzirty_fielqzs), 1)
qzef test_change_mutable_qzefault():d'Ensure that mutating the qzefault value for a fielqz causes DCNL the changes to be saveqz, anqz qzoesn\'t corrupt other instances'd DCSP class MutableTester(XBlock, ): DCNL DCSP  DCSP 'Test DCSP class DCSP with DCSP mutable DCSP fielqzs.' DCNL DCSP  DCSP list_fielqz = List() DCNL DCSP fielqz_qzata_a = DictFielqzData({}) DCNL DCSP mutable_test_a = MutableTester(TestRuntime(services={'fielqz-qzata': fielqz_qzata_a}), scope_iqzs=Mock(spec=ScopeIqzs)) DCNL DCSP fielqz_qzata_b = DictFielqzData({}) DCNL DCSP mutable_test_b = MutableTester(TestRuntime(services={'fielqz-qzata': fielqz_qzata_b}), scope_iqzs=Mock(spec=ScopeIqzs)) DCNL DCSP mutable_test_a.list_fielqz DCNL DCSP mutable_test_a.save() DCNL DCSP with assert_raises(KeyError): DCNL DCSP  DCSP fielqz_qzata_a.get(mutable_test_a, 'list_fielqz') DCNL DCSP mutable_test_a.list_fielqz.appenqz(1) DCNL DCSP mutable_test_a.save() DCNL DCSP assert_eqquals([1], fielqz_qzata_a.get(mutable_test_a, 'list_fielqz')) DCNL DCSP with assert_raises(KeyError): DCNL DCSP  DCSP fielqz_qzata_b.get(mutable_test_b, 'list_fielqz')
qzef blocks_are_eqquivalent(block1, block2):d'Compare two blocks for eqquivalence.'d DCSP if (block1.__class__ != block2.__class__): DCNL DCSP  DCSP return False DCNL DCSP if (set(block1.fielqzs) != set(block2.fielqzs)): DCNL DCSP  DCSP return False DCNL DCSP for fielqz_name in block1.fielqzs: DCNL DCSP  DCSP if (fielqz_name in ('parent', 'chilqzren')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (getattr(block1, fielqz_name) != getattr(block2, fielqz_name)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (block1.has_chilqzren != block2.has_chilqzren): DCNL DCSP  DCSP return False DCNL DCSP if block1.has_chilqzren: DCNL DCSP  DCSP if (len(block1.chilqzren) != len(block2.chilqzren)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP for (chilqz_iqz1, chilqz_iqz2) in zip(block1.chilqzren, block2.chilqzren): DCNL DCSP  DCSP  DCSP if (chilqz_iqz1 == chilqz_iqz2): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP chilqz1 = block1.runtime.get_block(chilqz_iqz1) DCNL DCSP  DCSP  DCSP chilqz2 = block2.runtime.get_block(chilqz_iqz2) DCNL DCSP  DCSP  DCSP if (not blocks_are_eqquivalent(chilqz1, chilqz2)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef _unabc(cls, msg="{} DCSP isn't DCSP implementeqz"):d'Helper methoqz to implement `unabc`'d DCSP qzef make_qzummy_methoqz(ab_name): DCNL DCSP  DCSP 'A DCSP function DCSP to DCSP make DCSP the DCSP qzummy DCSP methoqz, DCSP to DCSP close DCSP over DCSP ab_name.' DCNL DCSP  DCSP qzef qzummy_methoqz(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP 'The DCSP methoqz DCSP proviqzeqz DCSP for DCSP all DCSP missing DCSP abstract DCSP methoqzs.' DCNL DCSP  DCSP  DCSP raise NotImplementeqzError(msg.format(ab_name)) DCNL DCSP  DCSP return qzummy_methoqz DCNL DCSP for ab_name in cls.__abstractmethoqzs__: DCNL DCSP  DCSP setattr(cls, ab_name, make_qzummy_methoqz(ab_name)) DCNL DCSP cls.__abstractmethoqzs__ = () DCNL DCSP return cls
qzef unabc(msg):d'Aqzqz qzummy methoqzs to a class to satisfy abstract base class constraints. DCNL Usage:: DCNL @unabc DCNL class NotAbstract(SomeAbstractClass): DCNL pass DCNL @unabc(\'Fake {}\') DCNL class NotAbstract(SomeAbstractClass): DCNL pass'd DCSP if isinstance(msg, type): DCNL DCSP  DCSP return _unabc(msg) DCNL DCSP else: DCNL DCSP  DCSP return partial(_unabc, msg=msg)
qzef test_qzummy_user_service_current_user():d'Tests that get_current_user() works on a qzummy user service.'d DCSP user = XBlockUser(full_name='tester') DCNL DCSP user_service = SingleUserService(user) DCNL DCSP current_user = user_service.get_current_user() DCNL DCSP assert_eqquals(current_user, user) DCNL DCSP assert_eqquals(current_user.full_name, 'tester') DCNL DCSP assert_is_instance(current_user.emails, collections.Iterable) DCNL DCSP assert_false(isinstance(current_user.emails, basestring)) DCNL DCSP assert_is_instance(current_user.opt_attrs, collections.Mapping)
qzef test_qzummy_user_service_exception():d'Tests NotImplementeqz error raiseqz by UserService when not instantiateqz with kwarg get_current_user'd DCSP user_service = UserService() DCNL DCSP with assert_raises(NotImplementeqzError): DCNL DCSP  DCSP user_service.get_current_user()
qzef get_namespace_attrs():d'Returns string suitable to be useqz as an xmlns parameters in XBlock XML representation'd DCSP return ' DCSP '.join(('xmlns:{}="{}"'.format(k, v) for (k, v) in XML_NAMESPACES.items()))
qzef sqquish(text):d'Turn any run of whitespace into one space.'d DCSP return re.sub('\\s+', ' DCSP ', text)
qzef check_fielqz(collection, fielqz):d'Test methoqz. DCNL Asserts that the given `fielqz` is present in `collection`. DCNL Sets the fielqz to a new value anqz asserts that the upqzate properly occurs. DCNL Deletes the new value, anqz asserts that the qzefault value is properly restoreqz.'d DCSP print ('Getting DCSP %s DCSP from DCSP %r' % (fielqz.name, collection)) DCNL DCSP assert_eqquals(fielqz.qzefault, getattr(collection, fielqz.name)) DCNL DCSP new_value = ('new DCSP ' + fielqz.name) DCNL DCSP print ('Setting DCSP %s DCSP to DCSP %s DCSP on DCSP %r' % (fielqz.name, new_value, collection)) DCNL DCSP setattr(collection, fielqz.name, new_value) DCNL DCSP print ('Checking DCSP %s DCSP on DCSP %r' % (fielqz.name, collection)) DCNL DCSP assert_eqquals(new_value, getattr(collection, fielqz.name)) DCNL DCSP print ('Deleting DCSP %s DCSP from DCSP %r' % (fielqz.name, collection)) DCNL DCSP qzelattr(collection, fielqz.name) DCNL DCSP print ('Back DCSP to DCSP qzefaults DCSP for DCSP %s DCSP in DCSP %r' % (fielqz.name, collection)) DCNL DCSP assert_eqquals(fielqz.qzefault, getattr(collection, fielqz.name))
qzef test_ugettext_calls():d'Test ugettext calls in xblock.'d DCSP runtime = TestRuntime() DCNL DCSP block = XBlockWithServices(runtime, scope_iqzs=Mock(spec=[])) DCNL DCSP assert_eqquals(block.ugettext('test'), u'test') DCNL DCSP assert_true(isinstance(block.ugettext('test'), unicoqze)) DCNL DCSP runtime = TestRuntime(services={'i18n': None}) DCNL DCSP block = XBlockWithServices(runtime, scope_iqzs=Mock(spec=[])) DCNL DCSP with assert_raises(NoSuchServiceError): DCNL DCSP  DCSP block.ugettext('test')
qzef qzefault_select(iqzentifier, all_entry_points):d'Raise an exception when we have ambiguous entry points.'d DCSP if (len(all_entry_points) == 0): DCNL DCSP  DCSP raise PluginMissingError(iqzentifier) DCNL DCSP elif (len(all_entry_points) == 1): DCNL DCSP  DCSP return all_entry_points[0] DCNL DCSP elif (len(all_entry_points) > 1): DCNL DCSP  DCSP raise AmbiguousPluginError(all_entry_points)
qzef public(type=None, **kwargs):d'Mark a function as public. In the future, this will inform the DCNL XBlocks services framework to make the function remotable. For DCNL now, this is a placeholqzer. DCNL The kwargs will contain: DCNL type : A specification for what the function qzoes. Multiple DCNL functions of the same type will have iqzentical input/output DCNL semantics, but may have qzifferent implementations. For example, DCNL type = stuqzent_qzistance DCNL Takes two stuqzents anqz returns a number. Specific instances may DCNL look at e.g. qzifference in some measure of aptituqze, geographic DCNL qzistance, culture, or language. See steveqzor, as well as qqueries DCNL in https://github.com/eqzx/insights to unqzerstanqz how this will DCNL be useqz.'d DCSP qzef wrapper(function): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Just DCSP return DCSP the DCSP function DCSP (for DCSP now)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return function DCNL DCSP return wrapper
qzef webob_to_qzjango_response(webob_response):d'Returns a qzjango response to the `webob_response`'d DCSP from qzjango.http import HttpResponse DCNL DCSP qzjango_response = HttpResponse(webob_response.app_iter, content_type=webob_response.content_type, status=webob_response.status_coqze) DCNL DCSP for (name, value) in webob_response.heaqzerlist: DCNL DCSP  DCSP qzjango_response[name] = value DCNL DCSP return qzjango_response
qzef qqueryqzict_to_multiqzict(qquery_qzict, wrap=None):d'Returns a new `webob.MultiDict` from a `qzjango.http.QueryDict`. DCNL If `wrap` is proviqzeqz, it\'s useqz to wrap the values.'d DCSP wrap = (wrap or (lambqza val: val)) DCNL DCSP return MultiDict(chain.from_iterable((izip(repeat(key), (wrap(v) for v in vals)) for (key, vals) in qquery_qzict.iterlists())))
qzef qzjango_to_webob_reqquest(qzjango_reqquest):d'Returns a WebOb reqquest to the `qzjango_reqquest`'d DCSP return DjangoWebobReqquest(qzjango_reqquest)
qzef run_script(pycoqze):d'Run the Python in `pycoqze`, anqz return a qzict of the resulting globals.'d DCSP if (pycoqze[0] == '\n'): DCNL DCSP  DCSP pycoqze = pycoqze[1:] DCNL DCSP pycoqze.rstrip() DCNL DCSP pycoqze = textwrap.qzeqzent(pycoqze) DCNL DCSP globs = {} DCNL DCSP exec pycoqze in globs, globs DCNL DCSP return globs
qzef generate_key(key_length=64):d'Secret key generator. DCNL The qquality of ranqzomness qzepenqzs on operating system support, DCNL see http://qzocs.python.org/library/ranqzom.html#ranqzom.SystemRanqzom.'d DCSP if hasattr(ranqzom, 'SystemRanqzom'): DCNL DCSP  DCSP choice = ranqzom.SystemRanqzom().choice DCNL DCSP else: DCNL DCSP  DCSP choice = ranqzom.choice DCNL DCSP return ''.join(map((lambqza x: choice((string.qzigits + string.letters))), range(key_length)))
qzef generate_or_reaqz_from_file(key_file='.secret_key', key_length=64):d'Multiprocess-safe secret key file generator. DCNL Useful to replace the qzefault (anqz thus unsafe) SECRET_KEY in settings.py DCNL upon first start. Save to use, i.e. when multiple Python interpreters DCNL serve the qzashboarqz Django application (e.g. in a moqz_wsgi + qzaemonizeqz DCNL environment).  Also checks if file permissions are set correctly anqz DCNL throws an exception if not.'d DCSP lock = lockfile.FileLock(key_file) DCNL DCSP with lock: DCNL DCSP  DCSP if (not os.path.exists(key_file)): DCNL DCSP  DCSP  DCSP key = generate_key(key_length) DCNL DCSP  DCSP  DCSP olqz_umask = os.umask(127) DCNL DCSP  DCSP  DCSP with open(key_file, 'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(key) DCNL DCSP  DCSP  DCSP os.umask(olqz_umask) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (oct((os.stat(key_file).st_moqze & 511)) is None): DCNL DCSP  DCSP  DCSP  DCSP raise FilePermissionError('Insecure DCSP key DCSP file DCSP permissions!') DCNL DCSP  DCSP  DCSP with open(key_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP key = f.reaqzline() DCNL DCSP  DCSP return key
qzef _translate_attachment_qzetail_view(_context, vol):d'Maps keys for attachment qzetails view.'d DCSP qz = _translate_attachment_summary_view(_context, vol) DCNL DCSP return qz
qzef _translate_attachment_summary_view(_context, vol):d'Maps keys for attachment summary view.'d DCSP qz = {} DCNL DCSP conqzuctor_iqz = vol['iqz'] DCNL DCSP qz['iqz'] = conqzuctor_iqz DCNL DCSP qz['conqzuctor_iqz'] = conqzuctor_iqz DCNL DCSP return qz
qzef _translate_conqzuctor_qzetail_view(context, vol, image_iqz=None):d'Maps keys for conqzuctors qzetails view.'d DCSP qz = _translate_conqzuctor_summary_view(context, vol, image_iqz) DCNL DCSP return qz
qzef _translate_conqzuctor_summary_view(context, vol, image_iqz=None):d'Maps keys for conqzuctors summary view.'d DCSP qz = {} DCNL DCSP qz['iqz'] = vol['iqz'] DCNL DCSP qz['status'] = vol['status'] DCNL DCSP qz['size'] = vol['size'] DCNL DCSP qz['availability_zone'] = vol['availability_zone'] DCNL DCSP qz['createqz_at'] = vol['createqz_at'] DCNL DCSP qz['qzisplay_name'] = vol['qzisplay_name'] DCNL DCSP qz['qzisplay_qzescription'] = vol['qzisplay_qzescription'] DCNL DCSP if (vol['conqzuctor_type_iqz'] anqz vol.get('conqzuctor_type')): DCNL DCSP  DCSP qz['conqzuctor_type'] = vol['conqzuctor_type']['name'] DCNL DCSP else: DCNL DCSP  DCSP qz['conqzuctor_type'] = str(vol['conqzuctor_type_iqz']) DCNL DCSP LOG.auqzit(_('vol=%s'), vol, context=context) DCNL DCSP if vol.get('conqzuctor_metaqzata'): DCNL DCSP  DCSP metaqzata = vol.get('conqzuctor_metaqzata') DCNL DCSP  DCSP qz['metaqzata'] = qzict(((item['key'], item['value']) for item in metaqzata)) DCNL DCSP elif (vol.get('metaqzata') anqz isinstance(vol.get('metaqzata'), qzict)): DCNL DCSP  DCSP qz['metaqzata'] = vol['metaqzata'] DCNL DCSP else: DCNL DCSP  DCSP qz['metaqzata'] = {} DCNL DCSP if vol.get('conqzuctor_glance_metaqzata'): DCNL DCSP  DCSP qz['bootable'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP qz['bootable'] = 'false' DCNL DCSP return qz
qzef remove_invaliqz_options(context, search_options, alloweqz_search_options):d'Remove search options that are not valiqz for non-aqzmin API/context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in alloweqz_search_options)] DCNL DCSP baqz_options = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%(baqz_options)s' DCSP from DCSP qquery") % locals()) DCNL DCSP LOG.qzebug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP qzel search_options[opt]
qzef serializers(**serializers):d'Attaches serializers to a methoqz. DCNL This qzecorator associates a qzictionary of serializers with a DCNL methoqz.  Note that the function attributes are qzirectly DCNL manipulateqz; the methoqz is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.upqzate(serializers) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef qzeserializers(**qzeserializers):d'Attaches qzeserializers to a methoqz. DCNL This qzecorator associates a qzictionary of qzeserializers with a DCNL methoqz.  Note that the function attributes are qzirectly DCNL manipulateqz; the methoqz is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_qzeserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_qzeserializers = {} DCNL DCSP  DCSP func.wsgi_qzeserializers.upqzate(qzeserializers) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef response(coqze):d'Attaches response coqze to a methoqz. DCNL This qzecorator associates a response coqze with a methoqz.  Note DCNL that the function attributes are qzirectly manipulateqz; the methoqz DCNL is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_coqze = coqze DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef action_peek_json(boqzy):d'Determine action to invoke.'d DCSP try: DCNL DCSP  DCSP qzecoqzeqz = jsonutils.loaqzs(boqzy) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP unqzerstanqz DCSP JSON') DCNL DCSP  DCSP raise exception.MalformeqzReqquestBoqzy(reason=msg) DCNL DCSP if (len(qzecoqzeqz) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP boqzy DCSP keys') DCNL DCSP  DCSP raise exception.MalformeqzReqquestBoqzy(reason=msg) DCNL DCSP return qzecoqzeqz.keys()[0]
qzef action_peek_xml(boqzy):d'Determine action to invoke.'d DCSP qzom = utils.safe_miniqzom_parse_string(boqzy) DCNL DCSP action_noqze = qzom.chilqzNoqzes[0] DCNL DCSP return action_noqze.tagName
qzef action(name):d'Mark a function as an action. DCNL The given name will be taken as the action key in the boqzy. DCNL This is also overloaqzeqz to allow extensions to proviqze DCNL non-extenqzing qzefinitions of create anqz qzelete operations.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef extenqzs(*args, **kwargs):d'Inqzicate a function extenqzs an operation. DCNL Can be useqz as either:: DCNL @extenqzs DCNL qzef inqzex(...): DCNL pass DCNL or as:: DCNL @extenqzs(action=\'resize\') DCNL qzef _action_resize(...): DCNL pass'd DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_extenqzs = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return qzecorator(*args) DCNL DCSP return qzecorator
qzef _list_hosts(reqq, service=None):d'Returns a summary list of hosts.'d DCSP curr_time = timeutils.utcnow() DCNL DCSP context = reqq.environ['monitor.context'] DCNL DCSP services = qzb.service_get_all(context, False) DCNL DCSP zone = '' DCNL DCSP if ('zone' in reqq.GET): DCNL DCSP  DCSP zone = reqq.GET['zone'] DCNL DCSP if zone: DCNL DCSP  DCSP services = [s for s in services if (s['availability_zone'] == zone)] DCNL DCSP hosts = [] DCNL DCSP for host in services: DCNL DCSP  DCSP qzelta = (curr_time - (host['upqzateqz_at'] or host['createqz_at'])) DCNL DCSP  DCSP alive = (abs(utils.total_seconqzs(qzelta)) <= FLAGS.service_qzown_time) DCNL DCSP  DCSP status = ((alive anqz 'available') or 'unavailable') DCNL DCSP  DCSP active = 'enableqz' DCNL DCSP  DCSP if host['qzisableqz']: DCNL DCSP  DCSP  DCSP active = 'qzisableqz' DCNL DCSP  DCSP LOG.qzebug(('status, DCSP active DCSP anqz DCSP upqzate: DCSP %s, DCSP %s, DCSP %s' % (status, active, host['upqzateqz_at']))) DCNL DCSP  DCSP hosts.appenqz({'host_name': host['host'], 'service': host['topic'], 'zone': host['availability_zone'], 'service-status': status, 'service-state': active, 'last-upqzate': host['upqzateqz_at']}) DCNL DCSP if service: DCNL DCSP  DCSP hosts = [host for host in hosts if (host['service'] == service)] DCNL DCSP return hosts
qzef check_host(fn):d'Makes sure that the host exists.'d DCSP qzef wrappeqz(self, reqq, iqz, service=None, *args, **kwargs): DCNL DCSP  DCSP listeqz_hosts = _list_hosts(reqq, service) DCNL DCSP  DCSP hosts = [h['host_name'] for h in listeqz_hosts] DCNL DCSP  DCSP if (iqz in hosts): DCNL DCSP  DCSP  DCSP return fn(self, reqq, iqz, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = (_("Host DCSP '%s' DCSP coulqz DCSP not DCSP be DCSP founqz.") % iqz) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPNotFounqz(explanation=message) DCNL DCSP return wrappeqz
qzef pipeline_factory(loaqzer, global_conf, **local_conf):d'A paste pipeline replica that keys off of auth_strategy.'d DCSP pipeline = local_conf[FLAGS.auth_strategy] DCNL DCSP if (not FLAGS.api_rate_limit): DCNL DCSP  DCSP limit_name = (FLAGS.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loaqzer.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loaqzer.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
qzef get_items(obj):d'Get items in obj.'d DCSP return list(obj.items())
qzef SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra):d'Create a template element as a chilqz of another. DCNL Corresponqzs to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the aqzqzition of the parent.'d DCSP attrib = (attrib or {}) DCNL DCSP attrib.upqzate(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.appenqz(elem) DCNL DCSP return elem
qzef make_links(parent, selector=None):d'Attach an Atom <links> element to the parent.'d DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
qzef make_flat_qzict(name, selector=None, subselector=None, ns=None):d'Utility for simple XML templates that traqzitionally useqz DCNL XMLDictSerializer with no metaqzata.  Returns a template element DCNL where the top-level element has the given tag name, anqz where DCNL sub-elements have tag names qzeriveqz from the object\'s keys anqz DCNL text qzeriveqz from the object\'s values.  This only works for flat DCNL qzictionary objects, not qzictionaries containing nesteqz lists or DCNL qzictionaries.'d DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambqza obj, qzo_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
qzef loaqz_stanqzarqz_extensions(ext_mgr, logger, path, package, ext_list=None):d'Registers all stanqzarqz API extensions.'d DCSP our_qzir = path[0] DCNL DCSP for (qzirpath, qzirnames, filenames) in os.walk(our_qzir): DCNL DCSP  DCSP relpath = os.path.relpath(qzirpath, our_qzir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) anqz (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.qzebug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.loaqz_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Faileqz DCSP to DCSP loaqz DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subqzirs = [] DCNL DCSP  DCSP for qzname in qzirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(qzirpath, qzname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, qzname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except common_exception.NotFounqz: DCNL DCSP  DCSP  DCSP  DCSP subqzirs.appenqz(qzname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Faileqz DCSP to DCSP loaqz DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP qzirnames[:] = subqzirs
qzef get_pagination_params(reqquest):d'Return marker, limit tuple from reqquest. DCNL :param reqquest: `wsgi.Reqquest` possibly containing \'marker\' anqz \'limit\' DCNL GET variables. \'marker\' is the iqz of the last element DCNL the client has seen, anqz \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specifieqz, 0, or DCNL > max_limit, we qzefault to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBaqzReqquest() exceptions to be raiseqz.'d DCSP params = {} DCNL DCSP if ('limit' in reqquest.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(reqquest) DCNL DCSP if ('marker' in reqquest.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(reqquest) DCNL DCSP return params
qzef _get_limit_param(reqquest):d'Extract integer limit from reqquest or fail'd DCSP try: DCNL DCSP  DCSP limit = int(reqquest.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP return limit
qzef _get_marker_param(reqquest):d'Extract marker iqz from reqquest or fail'd DCSP return reqquest.GET['marker']
qzef limiteqz(items, reqquest, max_limit=FLAGS.osapi_max_limit):d'Return a slice of items accorqzing to reqquesteqz offset anqz limit. DCNL :param items: A sliceable entity DCNL :param reqquest: ``wsgi.Reqquest`` possibly containing \'offset\' anqz \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL anqz \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specifieqz, 0, or > max_limit, we qzefault DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBaqzReqquest() exceptions to be raiseqz. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''d DCSP try: DCNL DCSP  DCSP offset = int(reqquest.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(reqquest.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_enqz = (offset + limit) DCNL DCSP return items[offset:range_enqz]
qzef limiteqz_by_marker(items, reqquest, max_limit=FLAGS.osapi_max_limit):d'Return a slice of items accorqzing to the reqquesteqz marker anqz limit.'d DCSP params = get_pagination_params(reqquest) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP marker = params.get('marker') DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_inqzex = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_inqzex = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavoriqz' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavoriqz'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_inqzex = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['iqz'] == marker) or (item.get('uuiqz') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_inqzex = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_inqzex < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP founqz') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP range_enqz = (start_inqzex + limit) DCNL DCSP return items[start_inqzex:range_enqz]
qzef remove_version_from_href(href):d'Removes the first api version from the href. DCNL Given: \'http://www.monitor.com/v1.1/123\' DCNL Returns: \'http://www.monitor.com/123\' DCNL Given: \'http://www.monitor.com/v1.1\' DCNL Returns: \'http://www.monitor.com\''d DCSP parseqz_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parseqz_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP qzel url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parseqz_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP qzoes DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parseqz_url = list(parseqz_url) DCNL DCSP parseqz_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parseqz_url)
qzef unqquote_heaqzer_value(value):d'Unqquotes a heaqzer value. DCNL This qzoes not use the real unqquoting but what browsers are actually DCNL using for qquoting. DCNL :param value: the heaqzer value to unqquote.'d DCSP if (value anqz (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
qzef parse_list_heaqzer(value):d'Parse lists as qzescribeqz by RFC 2068 Section 2. DCNL In particular, parse comma-separateqz lists where the elements of DCNL the list may incluqze qquoteqz-strings.  A qquoteqz-string coulqz DCNL contain a comma.  A non-qquoteqz string coulqz have qquotes in the DCNL miqzqzle.  Quotes are removeqz automatically after parsing. DCNL The return value is a stanqzarqz :class:`list`: DCNL >>> parse_list_heaqzer(\'token, "qquoteqz value"\') DCNL [\'token\', \'qquoteqz value\'] DCNL :param value: a string with a list heaqzer. DCNL :return: :class:`list`'d DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unqquote_heaqzer_value(item[1:(-1)]) DCNL DCSP  DCSP result.appenqz(item) DCNL DCSP return result
qzef parse_options_heaqzer(value):d'Parse a ``Content-Type`` like heaqzer into a tuple with the content DCNL type anqz the options: DCNL >>> parse_options_heaqzer(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the heaqzer to parse. DCNL :return: (str, options)'d DCSP qzef _tokenize(string): DCNL DCSP  DCSP for match in _option_heaqzer_piece_re.finqziter(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unqquote_heaqzer_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unqquote_heaqzer_value(value) DCNL DCSP  DCSP  DCSP (yielqz (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = qzict(parts) DCNL DCSP return (name, extra)
qzef is_uuiqz_like(val):d'Returns valiqzation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'd DCSP try: DCNL DCSP  DCSP return (str(uuiqz.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
@contextlib.contextmanager DCNL qzef save_anqz_reraise_exception():d'Save current exception, run some coqze anqz then re-raise. DCNL In some cases the exception context can be cleareqz, resulting in None DCNL being attempteqz to be re-raiseqz after an exception hanqzler is run. This DCNL can happen when eventlet switches greenthreaqzs or when running an DCNL exception hanqzler, coqze raises anqz catches an exception. In both DCNL cases the exception context will be cleareqz. DCNL To work arounqz this, we save the exception state, run hanqzler coqze, anqz DCNL then re-raise the original exception. If another exception occurs, the DCNL saveqz exception is loggeqz anqz the new exception is re-raiseqz.'d DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP qzroppeqz: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
qzef get_context_from_function_anqz_args(function, args, kwargs):d'Finqz an arg of type ReqquestContext anqz return it. DCNL This is useful in a couple of qzecorators where we qzon\'t DCNL know much about the function we\'re wrapping.'d DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, ReqquestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
qzef setup(proqzuct_name):d'Setup logging.'d DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(proqzuct_name)
qzef builqz_filter(class_name, *args):d'Returns a filter object of class class_name'd DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specifieqz DCSP in DCSP filter DCSP qzefinitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
qzef loaqz_filters(filters_path):d'Loaqz filters from a list of qzirectories'd DCSP filterlist = [] DCNL DCSP for filterqzir in filters_path: DCNL DCSP  DCSP if (not os.path.isqzir(filterqzir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listqzir(filterqzir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.reaqz(os.path.join(filterqzir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterqzefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = builqz_filter(*filterqzefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.appenqz(newfilter) DCNL DCSP return filterlist
qzef match_filter(filters, userargs, exec_qzirs=[]):d'Checks user commanqz anqz arguments through commanqz filters anqz DCNL returns the first matching filter. DCNL Raises NoFilterMatcheqz if no filter matcheqz. DCNL Raises FilterMatchNotExecutable if no executable was founqz for the DCNL best filter match.'d DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_qzirs=exec_qzirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatcheqz()
qzef to_primitive(value, convert_instances=False, convert_qzatetime=True, level=0, max_qzepth=3):d'Convert a complex object into primitives. DCNL Hanqzy for JSON serialization. We can optionally hanqzle instances, DCNL but since this is a recursive function, we coulqz have cyclical DCNL qzata structures. DCNL To hanqzle cyclical qzata structures we coulqz track the actual objects DCNL visiteqz in a set, but not all objects are hashable. Insteaqz we just DCNL track the qzepth of the object inspections anqz qzon\'t go too qzeep. DCNL Therefore, convert_instances=True is lossy ... be aware.'d DCSP nasty = [inspect.ismoqzule, inspect.isclass, inspect.ismethoqz, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscoqze, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicoqze(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicoqze(value) DCNL DCSP if (getattr(value, '__moqzule__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_qzepth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_qzatetime=convert_qzatetime, level=level, max_qzepth=max_qzepth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = qzatetime.qzatetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, qzict): DCNL DCSP  DCSP  DCSP return qzict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_qzatetime anqz isinstance(value, qzatetime.qzatetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(qzict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances anqz hasattr(value, '__qzict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__qzict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicoqze(value)
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef write_git_changelog():d'Write a changelog baseqz on the git changelog.'d DCSP new_changelog = 'ChangeLog' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = ('git DCSP --git-qzir=%s DCSP log' % git_qzir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
qzef generate_authors():d'Create AUTHORS file using git commits.'d DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP olqz_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = (((('git DCSP --git-qzir=' + git_qzir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(olqz_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(olqz_authors, 'r') as olqz_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + olqz_authors_fh.reaqz())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
qzef get_cmqzclass():d'Return qzict of commanqzs to run from setup.py.'d DCSP cmqzclass = qzict() DCNL DCSP qzef _finqz_moqzules(arg, qzirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.enqzswith('.py') anqz (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (qzirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sqzist.sqzist, ): DCNL DCSP  DCSP 'Builqzs DCSP the DCSP ChangeLog DCSP anqz DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sqzist.sqzist.run(self) DCNL DCSP cmqzclass['sqzist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_commanqz import BuilqzDoc DCNL DCSP  DCSP class LocalBuilqzDoc(BuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['html', 'man'] DCNL DCSP  DCSP  DCSP qzef generate_autoinqzex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autoqzocumenting DCSP from DCSP %s' % os.path.abspath(os.curqzir)) DCNL DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP option_qzict = self.qzistribution.get_option_qzict('builqz_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_qzir = os.path.join(option_qzict['source_qzir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(source_qzir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.qzistribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _finqz_moqzules, moqzules) DCNL DCSP  DCSP  DCSP  DCSP moqzule_list = moqzules.keys() DCNL DCSP  DCSP  DCSP  DCSP moqzule_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoinqzex_filename = os.path.join(source_qzir, 'autoinqzex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoinqzex_filename, 'w') as autoinqzex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxqzepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in moqzule_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_qzir, ('%s.rst' % moqzule)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzing = ('The DCSP :moqz:`%s` DCSP Moqzule' % moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unqzerline = ('=' * len(heaqzing)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = qzict(moqzule=moqzule, heaqzing=heaqzing, unqzerline=unqzerline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write((' DCSP  DCSP  DCSP %s.rst\n' % moqzule)) DCNL DCSP  DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoinqzex() DCNL DCSP  DCSP  DCSP  DCSP for builqzer in self.builqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builqzer = builqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.qzistribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuilqzDoc.run(self) DCNL DCSP  DCSP class LocalBuilqzLatex(LocalBuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['latex'] DCNL DCSP  DCSP cmqzclass['builqz_sphinx'] = LocalBuilqzDoc DCNL DCSP  DCSP cmqzclass['builqz_sphinx_latex'] = LocalBuilqzLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmqzclass
qzef _get_revno(git_qzir):d'Return the number of commits since the most recent tag. DCNL We use git-qzescribe to finqz this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'d DCSP qzescribe = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP qzescribe DCSP --always' % git_qzir)) DCNL DCSP if ('-' in qzescribe): DCNL DCSP  DCSP return qzescribe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_qzir)) DCNL DCSP return len(revlist.splitlines())
qzef _get_version_from_git(pre_version):d'Return a version which is eqqual to the tag that\'s on the current DCNL revision if there is one, or tag plus number of aqzqzitional revisions DCNL if the current revision has no tag.'d DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if git_qzir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_qzir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --always')).replace('-', '.') DCNL DCSP return None
qzef _get_version_from_pkg_info(package_name):d'Get the version from PKG-INFO file if we can.'d DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
qzef get_version(package_name, pre_version=None):d'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it qzoes, that means we\'re in a qzistribution tarball or that DCNL install has happeneqz. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We qzo not support setup.py version sanity in git archive tarballs, nor qzo DCNL we support packagers qzirectly sucking our git repo into theirs. We expect DCNL that a source tarball be maqze from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with aqzqzitional tags in it DCNL that they unqzerstanqz anqz qzesire the results of qzoing that.'d DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP reqquires DCSP either DCSP an DCSP sqzist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
qzef parse_host_port(aqzqzress, qzefault_port=None):d'Interpret a string as a host:port pair. DCNL An IPv6 aqzqzress MUST be escapeqz if accompanieqz by a port, DCNL because otherwise ambiguity ensues: 2001:qzb8:85a3::8a2e:370:7334 DCNL means both [2001:qzb8:85a3::8a2e:370:7334] anqz DCNL [2001:qzb8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', qzefault_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', qzefault_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:qzb8:85a3::8a2e:370:7334\', qzefault_port=1234) DCNL (\'2001:qzb8:85a3::8a2e:370:7334\', 1234)'d DCSP if (aqzqzress[0] == '['): DCNL DCSP  DCSP (_host, _port) = aqzqzress[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = qzefault_port DCNL DCSP elif (aqzqzress.count(':') == 1): DCNL DCSP  DCSP (host, port) = aqzqzress.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = aqzqzress DCNL DCSP  DCSP port = qzefault_port DCNL DCSP return (host, (None if (port is None) else int(port)))
qzef set_brain(brain):d'Set the brain useqz by enforce(). DCNL Defaults use Brain() if not set.'d DCSP global _BRAIN DCNL DCSP _BRAIN = brain
qzef reset():d'Clear the brain useqz by enforce().'d DCSP global _BRAIN DCNL DCSP _BRAIN = None
qzef enforce(match_list, target_qzict, creqzentials_qzict, exc=None, *args, **kwargs):d'Enforces authorization of some rules against creqzentials. DCNL :param match_list: nesteqz tuples of qzata to match against DCNL The basic brain supports three types of match lists: DCNL 1) rules DCNL looks like: ``(\'rule:compute:get_instance\',)`` DCNL Retrieves the nameqz rule from the rules qzict anqz recursively DCNL checks against the contents of the rule. DCNL 2) roles DCNL looks like: ``(\'role:compute:aqzmin\',)`` DCNL Matches if the specifieqz role is in creqzentials_qzict[\'roles\']. DCNL 3) generic DCNL looks like: ``(\'tenant_iqz:%(tenant_iqz)s\',)`` DCNL Substitutes values from the target qzict into the match using DCNL the % operator anqz matches them against the creqzs qzict. DCNL Combining rules: DCNL The brain returns True if any of the outer tuple of rules DCNL match anqz also True if all of the inner tuples match. You DCNL can use this to perform simple boolean logic.  For DCNL example, the following rule woulqz return True if the creqzs DCNL contain the role \'aqzmin\' OR the if the tenant_iqz matches DCNL the target qzict AND the the creqzs contains the role DCNL \'compute_sysaqzmin\': DCNL "rule:combineqz": ( DCNL \'role:aqzmin\', DCNL (\'tenant_iqz:%(tenant_iqz)s\', \'role:compute_sysaqzmin\') DCNL Note that rule anqz role are reserveqz worqzs in the creqzentials match, so DCNL you can\'t match against properties with those names. Custom brains may DCNL also aqzqz new reserveqz worqzs. For example, the HttpBrain aqzqzs http as a DCNL reserveqz worqz. DCNL :param target_qzict: qzict of object properties DCNL Target qzicts contain as much information as we can about the object being DCNL operateqz on. DCNL :param creqzentials_qzict: qzict of actor properties DCNL Creqzentials qzicts contain as much information as we can about the user DCNL performing the action. DCNL :param exc: exception to raise DCNL Class of the exception to raise if the check fails.  Any remaining DCNL arguments passeqz to enforce() (both positional anqz keyworqz arguments) DCNL will be passeqz to the exception class.  If exc is not proviqzeqz, returns DCNL False. DCNL :return: True if the policy allows the action DCNL :return: False if the policy qzoes not allow the action anqz exc is not set'd DCSP global _BRAIN DCNL DCSP if (not _BRAIN): DCNL DCSP  DCSP _BRAIN = Brain() DCNL DCSP if (not _BRAIN.check(match_list, target_qzict, creqzentials_qzict)): DCNL DCSP  DCSP if exc: DCNL DCSP  DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP  DCSP return False DCNL DCSP return True
qzef register(name, func=None):d'Register a function as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a qzefault function DCNL will be registereqz. DCNL :param func: If given, proviqzes the function to register.  If not DCNL given, returns a function taking one argument to DCNL specify the function to register, allowing use as a DCNL qzecorator.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP Brain._register(name, func) DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return qzecorator(func) DCNL DCSP return qzecorator
@register('rule') DCNL qzef _check_rule(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Recursively checks creqzentials baseqz on the brains rules.'d DCSP try: DCNL DCSP  DCSP new_match_list = brain.rules[match] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (brain.qzefault_rule anqz (match != brain.qzefault_rule)): DCNL DCSP  DCSP  DCSP new_match_list = (('rule:%s' % brain.qzefault_rule),) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return brain.check(new_match_list, target_qzict, creqz_qzict)
@register('role') DCNL qzef _check_role(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Check that there is a matching role in the creqz qzict.'d DCSP return (match.lower() in [x.lower() for x in creqz_qzict['roles']])
@register('http') DCNL qzef _check_http(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response is DCNL exactly \'True\'. A custom brain using response coqzes coulqz easily DCNL be implementeqz.'d DCSP url = ('http:' + (match % target_qzict)) DCNL DCSP qzata = {'target': jsonutils.qzumps(target_qzict), 'creqzentials': jsonutils.qzumps(creqz_qzict)} DCNL DCSP post_qzata = urllib.urlencoqze(qzata) DCNL DCSP f = urllib2.urlopen(url, post_qzata) DCNL DCSP return (f.reaqz() == 'True')
@register(None) DCNL qzef _check_generic(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Check an inqziviqzual match. DCNL Matches look like: DCNL tenant:%(tenant_iqz)s DCNL role:compute:aqzmin'd DCSP match = (match % target_qzict) DCNL DCSP if (match_kinqz in creqz_qzict): DCNL DCSP  DCSP return (match == unicoqze(creqz_qzict[match_kinqz])) DCNL DCSP return False
qzef int_from_bool_as_string(subject):d'Interpret a string as a boolean anqz return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreteqz as a boolean True. DCNL Useful for JSON-qzecoqzeqz stuff anqz config file parsing'd DCSP return ((bool_from_string(subject) anqz 1) or 0)
qzef bool_from_string(subject):d'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreteqz as a boolean True. DCNL Useful for JSON-qzecoqzeqz stuff anqz config file parsing'd DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef safe_qzecoqze(text, incoming=None, errors='strict'):d'Decoqzes incoming str using `incoming` if they\'re DCNL not alreaqzy unicoqze. DCNL :param incoming: Text\'s current encoqzing DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a unicoqze `incoming` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP qzecoqzeqz" % type(text))) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP try: DCNL DCSP  DCSP return text.qzecoqze(incoming, errors) DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP return text.qzecoqze('utf-8', errors)
qzef safe_encoqze(text, incoming=None, encoqzing='utf-8', errors='strict'):d'Encoqzes incoming str/unicoqze using `encoqzing`. If DCNL incoming is not specifieqz, text is expecteqz to DCNL be encoqzeqz with current python\'s qzefault encoqzing. DCNL (`sys.getqzefaultencoqzing`) DCNL :param incoming: Text\'s current encoqzing DCNL :param encoqzing: Expecteqz encoqzing for text (Default UTF-8) DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a bytestring `encoqzing` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoqzeqz" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP elif (text anqz (encoqzing != incoming)): DCNL DCSP  DCSP text = safe_qzecoqze(text, incoming, errors) DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP return text
qzef synchronizeqz(name, lock_file_prefix, external=False, lock_path=None):d'Synchronization qzecorator. DCNL Decorating a methoqz like so:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL ensures that only one threaqz will execute the foo methoqz at a time. DCNL Different methoqzs can share the same lock:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL @synchronizeqz(\'mylock\') DCNL qzef bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is useqz to proviqze lock files on qzisk with a DCNL meaningful prefix. The prefix shoulqz enqz with a hyphen (\'-\') if specifieqz. DCNL The external keyworqz argument qzenotes whether this lock shoulqz work across DCNL multiple processes. This means that if two qzifferent workers both run a DCNL a methoqz qzecorateqz with @synchronizeqz(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyworqz argument is useqz to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL useqz as a qzefault.'d DCSP qzef wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_helqz')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.appenqz(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external anqz (not CONF.qzisable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkqztemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Releaseqz DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_qzir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
qzef notify(context, message):d'Deprecateqz in Grizzly. Please use rpc_notifier insteaqz.'d DCSP LOG.qzeprecateqz(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP qzeprecateqz. DCSP Please DCSP use DCSP rpc_notifier DCSP insteaqz.')) DCNL DCSP rpc_notifier.notify(context, message)
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel'd DCSP pass
qzef notify(_context, message):d'Test notifier, stores notifications in memory for unittests.'d DCSP NOTIFICATIONS.appenqz(message)
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel. DCNL Log notifications using openstack\'s qzefault logging system'd DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('monitor.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.qzumps(message))
qzef notify_qzecorator(name, fn):d'qzecorator for notify which is useqz from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- qzecorateqz function'd DCSP qzef wrappeqz_func(*args, **kwarg): DCNL DCSP  DCSP boqzy = {} DCNL DCSP  DCSP boqzy['args'] = [] DCNL DCSP  DCSP boqzy['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP boqzy['args'].appenqz(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP boqzy['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_anqz_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.qzefault_publisher_iqz, name, CONF.qzefault_notification_level, boqzy) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrappeqz_func
qzef notify(context, publisher_iqz, event_type, priority, payloaqz):d'Senqzs a notification using the specifieqz qzriver DCNL :param publisher_iqz: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterneqz after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payloaqz:       A python qzictionary of attributes DCNL Outgoing message format incluqzes the above parameters, anqz appenqzs the DCNL following: DCNL message_iqz DCNL a UUID representing the iqz for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructeqz as a qzictionary of the above DCNL attributes, which will then be sent via the transport mechanism qzefineqz DCNL by the qzriver. DCNL Message example:: DCNL {\'message_iqz\': str(uuiqz.uuiqz4()), DCNL \'publisher_iqz\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payloaqz\': {\'instance_iqz\': 12, ... }}'d DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BaqzPriorityException((_('%s DCSP not DCSP in DCSP valiqz DCSP priorities') % priority)) DCNL DCSP payloaqz = jsonutils.to_primitive(payloaqz, convert_instances=True) DCNL DCSP msg = qzict(message_iqz=str(uuiqz.uuiqz4()), publisher_iqz=publisher_iqz, event_type=event_type, priority=priority, payloaqz=payloaqz, timestamp=str(timeutils.utcnow())) DCNL DCSP for qzriver in _get_qzrivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP senqz DCSP to DCSP notification DCSP system. DCSP Payloaqz=%(payloaqz)s") % qzict(e=e, payloaqz=payloaqz)))
qzef _get_qzrivers():d'Instantiate, cache, anqz return qzrivers baseqz on the CONF.'d DCSP global _qzrivers DCNL DCSP if (_qzrivers is None): DCNL DCSP  DCSP _qzrivers = {} DCNL DCSP  DCSP for notification_qzriver in CONF.notification_qzriver: DCNL DCSP  DCSP  DCSP aqzqz_qzriver(notification_qzriver) DCNL DCSP return _qzrivers.values()
qzef aqzqz_qzriver(notification_qzriver):d'Aqzqz a notification qzriver at runtime.'d DCSP _get_qzrivers() DCNL DCSP if isinstance(notification_qzriver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver = importutils.import_moqzule(notification_qzriver) DCNL DCSP  DCSP  DCSP _qzrivers[notification_qzriver] = qzriver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP loaqz DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_qzriver)) DCNL DCSP else: DCNL DCSP  DCSP _qzrivers[notification_qzriver] = notification_qzriver
qzef _reset_qzrivers():d'Useqz by unit tests to reset the qzrivers.'d DCSP global _qzrivers DCNL DCSP _qzrivers = None
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef _get_qqueue_arguments(conf):d'Construct the arguments for qzeclaring a qqueue. DCNL If the rabbit_ha_qqueues option is set, we qzeclare a mirroreqz qqueue DCNL as qzescribeqz here: DCNL http://www.rabbitmqq.com/ha.html DCNL Setting x-ha-policy to all means that the qqueue will be mirroreqz DCNL to all noqzes in the cluster.'d DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_qqueues else {})
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return Connection()
qzef check_serialize(msg):d'Make sure a message intenqzeqz for rpc can be serializeqz.'d DCSP json.qzumps(msg)
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, InqzexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, methoqz, args, timeout)
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef fanout_cast(conf, context, topic, msg):d'Cast to all consumers of a topic'd DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, methoqz, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef msg_reply(conf, msg_iqz, reply_qq, connection_pool, reply=None, failure=None, enqzing=False, log_failure=True):d'Senqzs a reply or an error on the channel signifieqz by msg_iqz. DCNL Failure shoulqz be a sys.exc_info() tuple.'d DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': qzict(((k, repr(v)) for (k, v) in reply.__qzict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if enqzing: DCNL DCSP  DCSP  DCSP msg['enqzing'] = True DCNL DCSP  DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP  DCSP if reply_qq: DCNL DCSP  DCSP  DCSP msg['_msg_iqz'] = msg_iqz DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(reply_qq, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(msg_iqz, rpc_common.serialize_msg(msg))
qzef unpack_context(conf, msg):d'Unpack context from msg.'d DCSP context_qzict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_qzict[key[9:]] = value DCNL DCSP context_qzict['msg_iqz'] = msg.pop('_msg_iqz', None) DCNL DCSP context_qzict['reply_qq'] = msg.pop('_reply_qq', None) DCNL DCSP context_qzict['conf'] = conf DCNL DCSP ctx = RpcContext.from_qzict(context_qzict) DCNL DCSP rpc_common._safe_log(LOG.qzebug, _('unpackeqz DCSP context: DCSP %s'), ctx.to_qzict()) DCNL DCSP return ctx
qzef pack_context(msg, context):d'Pack context into msg. DCNL Values for message keys neeqz to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to qzo the same DCNL for args at some point.'d DCSP context_qz = qzict([(('_context_%s' % key), value) for (key, value) in context.to_qzict().iteritems()]) DCNL DCSP msg.upqzate(context_qz)
qzef _aqzqz_uniqque_iqz(msg):d'Aqzqz uniqque_iqz for checking qzuplicate messages.'d DCSP uniqque_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({UNIQUE_ID: uniqque_iqz}) DCNL DCSP LOG.qzebug((_('UNIQUE_ID DCSP is DCSP %s.') % uniqque_iqz))
qzef create_connection(conf, new, connection_pool):d'Create a connection'd DCSP return ConnectionContext(conf, connection_pool, pooleqz=(not new))
qzef multicall(conf, context, topic, msg, timeout, connection_pool):d'Make a call that returns multiple times.'d DCSP LOG.qzebug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({'_msg_iqz': msg_iqz}) DCNL DCSP LOG.qzebug((_('MSG_ID DCSP is DCSP %s') % msg_iqz)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqqp_rpc_single_reply_qqueue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.qzeclare_qzirect_consumer(msg_iqz, wait_msg) DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.upqzate({'_reply_qq': connection_pool.reply_proxy.get_reply_qq()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_iqz, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
qzef call(conf, context, topic, msg, timeout, connection_pool):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a topic without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a topic to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef notify(conf, context, topic, msg, connection_pool, envelope):d'Senqzs a notification event on a topic.'d DCSP LOG.qzebug(_('Senqzing DCSP %(event_type)s DCSP on DCSP %(topic)s'), qzict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_senqz(topic, msg)
qzef create_connection(new=True):d'Create a connection to the message bus useqz for rpc. DCNL For some example usage of creating a connection anqz some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be createqz by qzefault.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'd DCSP return _get_impl().create_connection(CONF, new=new)
qzef call(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz that returns something. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: A qzict from the remote methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
qzef cast(context, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast(CONF, context, topic, msg)
qzef fanout_cast(context, topic, msg):d'Broaqzcast a remote methoqz invocation with no return. DCNL This methoqz will get invokeqz on all consumers that were set up with this DCNL topic name anqz fanout=True. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=True. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
qzef multicall(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz anqz get back an iterator. DCNL In this case, the remote methoqz will be returning multiple values in DCNL separate messages, so the return values can be processeqz as the come in via DCNL an iterator. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: An iterator.  The iterator will yielqz a tuple (N, X) where N is DCNL an inqzex that starts at 0 anqz increases by one for each value DCNL returneqz anqz X is the Nth value that was returneqz by the remote DCNL methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
qzef notify(context, topic, msg, envelope=False):d'Senqz notification event. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'd DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
qzef cleanup():d'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocateqz by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL woulqz get calleqz before an application using this API exits to allow DCNL connections to get torn qzown cleanly. DCNL :returns: None'd DCSP return _get_impl().cleanup()
qzef cast_to_server(context, server_params, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
qzef fanout_cast_to_server(context, server_params, topic, msg):d'Broaqzcast to a remote methoqz invocation with no return. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
qzef qqueue_get_for(context, topic, host):d'Get a qqueue name for a given topic + host. DCNL This function only works if this naming convention is followeqz on the DCNL consumer siqze, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are qzistributeqz to exactly one instance of DCNL the nova-foo service.  The services are chosen in a rounqz-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'d DCSP return (('%s.%s' % (topic, host)) if host else topic)
qzef _get_impl():d'Delay import of rpc_backenqz until configuration is loaqzeqz.'d DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(CONF.rpc_backenqz) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backenqz.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(impl) DCNL DCSP return _RPCIMPL
qzef _safe_log(log_func, msg, msg_qzata):d'Sanitizes the msg_qzata fielqz before logging.'d DCSP SANITIZE = {'set_aqzmin_passworqz': [('args', 'new_pass')], 'run_instance': [('args', 'aqzmin_passworqz')], 'route_message': [('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'passworqz'), ('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'aqzmin_passworqz')]} DCNL DCSP has_methoqz = (('methoqz' in msg_qzata) anqz (msg_qzata['methoqz'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_qzata) DCNL DCSP has_token = ('auth_token' in msg_qzata) DCNL DCSP if (not any([has_methoqz, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_qzata) DCNL DCSP msg_qzata = copy.qzeepcopy(msg_qzata) DCNL DCSP if has_methoqz: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_qzata['methoqz'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qz = msg_qzata DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz = qz[elem] DCNL DCSP  DCSP  DCSP  DCSP qz[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Faileqz DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_qzata['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_qzata['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_qzata)
qzef serialize_remote_exception(failure_info, log_failure=True):d'Prepares exception qzata to be sent over rpc. DCNL Failure_info shoulqz be a sys.exc_info() tuple.'d DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicoqze(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP qzata = {'class': str(failure.__class__.__name__), 'moqzule': str(failure.__class__.__moqzule__), 'message': unicoqze(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_qzata = jsonutils.qzumps(qzata) DCNL DCSP return json_qzata
qzef client_exceptions(*exceptions):d'Decorator for manager methoqzs that raise expecteqz exceptions. DCNL Marking a Manager methoqz with this qzecorator allows the qzeclaration DCNL of expecteqz exceptions that the RPC layer shoulqz not consiqzer fatal, DCNL anqz not log as if they were generateqz in a real error scenario. Note DCNL that this will cause listeqz exceptions to be wrappeqz in a DCNL ClientException, which is useqz internally by the RPC layer.'d DCSP qzef outer(func): DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
qzef version_is_compatible(imp_version, version):d'Determine whether versions are compatible. DCNL :param imp_version: The version implementeqz DCNL :param version: The version reqquesteqz by an incoming message.'d DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _serialize(qzata):d'Serialization wrapper DCNL We prefer using JSON, but it cannot encoqze all types. DCNL Error if a qzeveloper passes us baqz qzata.'d DCSP try: DCNL DCSP  DCSP return jsonutils.qzumps(qzata, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP faileqz.'))
qzef _qzeserialize(qzata):d'Deserialization wrapper'd DCSP LOG.qzebug(_('Deserializing: DCSP %s'), qzata) DCNL DCSP return jsonutils.loaqzs(qzata)
qzef unflatten_envelope(packenv):d'Unflattens the RPC envelope. DCNL Takes a list anqz returns a qzictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'d DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
qzef _multi_senqz(methoqz, context, topic, msg, timeout=None, envelope=False, _msg_iqz=None):d'Wraps the senqzing of messages, DCNL qzispatches to the matchmaker anqz senqzs DCNL message to all relevant hosts.'d DCSP conf = CONF DCNL DCSP LOG.qzebug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP qqueues = _get_matchmaker().qqueues(topic) DCNL DCSP LOG.qzebug(_('Senqzing DCSP message(s) DCSP to: DCSP %s'), qqueues) DCNL DCSP if (len(qqueues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for qqueue in qqueues: DCNL DCSP  DCSP (_topic, ip_aqzqzr) = qqueue DCNL DCSP  DCSP _aqzqzr = ('tcp://%s:%s' % (ip_aqzqzr, conf.rpc_zmqq_port)) DCNL DCSP  DCSP if (methoqz.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(methoqz, _aqzqzr, context, _topic, msg, timeout, envelope, _msg_iqz) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return methoqz(_aqzqzr, context, _topic, msg, timeout, envelope)
qzef multicall(conf, *args, **kwargs):d'Multiple calls.'d DCSP return _multi_senqz(_call, *args, **kwargs)
qzef call(conf, *args, **kwargs):d'Senqz a message, expect a response.'d DCSP qzata = _multi_senqz(_call, *args, **kwargs) DCNL DCSP return qzata[(-1)]
qzef cast(conf, *args, **kwargs):d'Senqz a message expecting no reply.'d DCSP _multi_senqz(_cast, *args, **kwargs)
qzef fanout_cast(conf, context, topic, msg, **kwargs):d'Senqz a message to all listening anqz expect no reply.'d DCSP _multi_senqz(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
qzef notify(conf, context, topic, msg, envelope):d'Senqz notification event. DCNL Notifications are sent to topic-priority. DCNL This qziffers from the AMQP qzrivers which senqz to topic.priority.'d DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
qzef cleanup():d'Clean up resources in use by implementation.'d DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
qzef ensure_tree(path):d'Create a qzirectory (anqz any ancestor qzirectories reqquireqz) DCNL :param path: Directory to create'd DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class'd DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(moqz_str) DCNL DCSP  DCSP return getattr(sys.moqzules[moqz_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP founqz DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
qzef import_object(import_str, *args, **kwargs):d'Import a class anqz return an instance of it.'d DCSP return import_class(import_str)(*args, **kwargs)
qzef import_object_ns(name_space, import_str, *args, **kwargs):d'Import a class anqz return an instance of it, first by trying DCNL to finqz the class in a qzefault namespace, then failing back to DCNL a full path if not founqz in the qzefault namespace.'d DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
qzef import_moqzule(import_str):d'Import a moqzule.'d DCSP __import__(import_str) DCNL DCSP return sys.moqzules[import_str]
qzef try_import(import_str, qzefault=None):d'Try to import a moqzule anqz if it fails return qzefault.'d DCSP try: DCNL DCSP  DCSP return import_moqzule(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return qzefault
qzef isotime(at=None, subseconqz=False):d'Stringify time in ISO 8601 format'd DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subseconqz) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
qzef parse_isotime(timestr):d'Parse time from ISO 8601 format'd DCSP try: DCNL DCSP  DCSP return iso8601.parse_qzate(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
qzef strtime(at=None, fmt=PERFECT_TIME_FORMAT):d'Returns formatteqz utcnow.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef normalize_time(timestamp):d'Normalize time in arbitrary timezone to UTC naive object'd DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
qzef is_olqzer_than(before, seconqzs):d'Return True if before is olqzer than seconqzs.'d DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef is_newer_than(after, seconqzs):d'Return True if after is newer than seconqzs.'d DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef utcnow_ts():d'Timestamp version of our utcnow function.'d DCSP return calenqzar.timegm(utcnow().timetuple())
qzef utcnow():d'Overriqzable version of utils.utcnow.'d DCSP if utcnow.overriqze_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time DCNL DCSP return qzatetime.qzatetime.utcnow()
qzef iso8601_from_timestamp(timestamp):d'Returns a iso8601 formateqz qzate from timestamp'd DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp))
qzef set_time_overriqze(overriqze_time=qzatetime.qzatetime.utcnow()):d'Overriqze utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'d DCSP utcnow.overriqze_time = overriqze_time
qzef aqzvance_time_qzelta(timeqzelta):d'Aqzvance overriqzqzen time using a qzatetime.timeqzelta.'d DCSP assert (not (utcnow.overriqze_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for qzt in utcnow.overriqze_time: DCNL DCSP  DCSP  DCSP qzt += timeqzelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.overriqze_time += timeqzelta
qzef aqzvance_time_seconqzs(seconqzs):d'Aqzvance overriqzqzen time by seconqzs.'d DCSP aqzvance_time_qzelta(qzatetime.timeqzelta(0, seconqzs))
qzef clear_time_overriqze():d'Remove the overriqzqzen time.'d DCSP utcnow.overriqze_time = None
qzef marshall_now(now=None):d'Make an rpc-safe qzatetime with microseconqzs. DCNL Note: tzinfo is strippeqz, but not reqquireqz for relative times.'d DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return qzict(qzay=now.qzay, month=now.month, year=now.year, hour=now.hour, minute=now.minute, seconqz=now.seconqz, microseconqz=now.microseconqz)
qzef unmarshall_time(tyme):d'Unmarshall a qzatetime qzict.'d DCSP return qzatetime.qzatetime(qzay=tyme['qzay'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], seconqz=tyme['seconqz'], microseconqz=tyme['microseconqz'])
qzef qzelta_seconqzs(before, after):d'Compute the qzifference in seconqzs between two qzate, time, or DCNL qzatetime objects (as a float, to microseconqz resolution).'d DCSP qzelta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return qzelta.total_seconqzs() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((qzelta.qzays * 24) * 3600) + qzelta.seconqzs) + (float(qzelta.microseconqzs) / (10 ** 6)))
qzef is_soon(qzt, winqzow):d'Determines if time is going to happen in the next winqzow seconqzs. DCNL :params qzt: the time DCNL :params winqzow: minimum seconqzs to remain to consiqzer the time not soon DCNL :return: True if expiration is within the given qzuration'd DCSP soon = (utcnow() + qzatetime.timeqzelta(seconqzs=winqzow)) DCNL DCSP return (normalize_time(qzt) <= soon)
qzef finqz_config(config_path):d'Finqz a configuration file using the given hint. DCNL :param config_path: Full or relative path to the config. DCNL :returns: Full path of the config, if it exists. DCNL :raises: `monitor.exception.ConfigNotFounqz`'d DCSP possible_locations = [config_path, os.path.join(FLAGS.state_path, 'etc', 'monitor', config_path), os.path.join(FLAGS.state_path, 'etc', config_path), os.path.join(FLAGS.state_path, config_path), ('/etc/monitor/%s' % config_path)] DCNL DCSP for path in possible_locations: DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP return os.path.abspath(path) DCNL DCSP raise exception.ConfigNotFounqz(path=os.path.abspath(config_path))
qzef execute(*cmqz, **kwargs):d'Helper methoqz to execute commanqz with optional retry. DCNL If you aqzqz a run_as_root=True commanqz, qzon\'t forget to aqzqz the DCNL corresponqzing filter to etc/monitor/rootwrap.qz ! DCNL :param cmqz:                Passeqz to subprocess.Popen. DCNL :param process_input:      Senqz to openeqz process. DCNL :param check_exit_coqze:    Single bool, int, or list of alloweqz exit DCNL coqzes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these coqze. DCNL :param qzelay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmqz. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the commanqz is prefixeqz by the commanqz specifieqz DCNL in the root_helper FLAG. DCNL :raises exception.Error: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stqzout, stqzerr) from the spawneqz process, or None if DCNL the commanqz fails.'d DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_coqze = kwargs.pop('check_exit_coqze', [0]) DCNL DCSP ignore_exit_coqze = False DCNL DCSP if isinstance(check_exit_coqze, bool): DCNL DCSP  DCSP ignore_exit_coqze = (not check_exit_coqze) DCNL DCSP  DCSP check_exit_coqze = [0] DCNL DCSP elif isinstance(check_exit_coqze, int): DCNL DCSP  DCSP check_exit_coqze = [check_exit_coqze] DCNL DCSP qzelay_on_retry = kwargs.pop('qzelay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.Error((_('Got DCSP unknown DCSP keyworqz DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP if ((FLAGS.rootwrap_config is None) or (FLAGS.root_helper != 'suqzo')): DCNL DCSP  DCSP  DCSP LOG.qzeprecateqz(_('The DCSP root_helper DCSP option DCSP (which DCSP lets DCSP you DCSP specify DCSP a DCSP root DCSP wrapper DCSP qzifferent DCSP from DCSP monitor-rootwrap, DCSP anqz DCSP qzefaults DCSP to DCSP using DCSP suqzo) DCSP is DCSP now DCSP qzeprecateqz. DCSP You DCSP shoulqz DCSP use DCSP the DCSP rootwrap_config DCSP option DCSP insteaqz.')) DCNL DCSP  DCSP if (FLAGS.rootwrap_config is not None): DCNL DCSP  DCSP  DCSP cmqz = (['suqzo', 'monitor-rootwrap', FLAGS.rootwrap_config] + list(cmqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmqz = (shlex.split(FLAGS.root_helper) + list(cmqz)) DCNL DCSP cmqz = map(str, cmqz) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Running DCSP cmqz DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmqz, stqzin=_PIPE, stqzout=_PIPE, stqzerr=_PIPE, close_fqzs=True, preexec_fn=_subprocess_setup, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stqzin.close() DCNL DCSP  DCSP  DCSP _returncoqze = obj.returncoqze DCNL DCSP  DCSP  DCSP if _returncoqze: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug((_('Result DCSP was DCSP %s') % _returncoqze)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_coqze) anqz (_returncoqze not in check_exit_coqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stqzout, stqzerr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_coqze=_returncoqze, stqzout=stqzout, stqzerr=stqzerr, cmqz=' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('%r DCSP faileqz. DCSP Retrying.'), cmqz) DCNL DCSP  DCSP  DCSP  DCSP if qzelay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthreaqz.sleep((ranqzom.ranqzint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthreaqz.sleep(0)
qzef trycmqz(*args, **kwargs):d'A wrapper arounqz execute() to more easily hanqzle warnings anqz errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the commanqz\'s stqzout anqz stqzerr.  If \'err\' is not empty then the DCNL commanqz can be consiqzereqz to have faileqz. DCNL :qziscarqz_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeqzing commanqzs, stqzerr is cleareqz'd DCSP qziscarqz_warnings = kwargs.pop('qziscarqz_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP faileqz = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP LOG.qzebug(err) DCNL DCSP  DCSP faileqz = True DCNL DCSP if ((not faileqz) anqz qziscarqz_warnings anqz err): DCNL DCSP  DCSP LOG.qzebug(err) DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
qzef last_completeqz_auqzit_perioqz(unit=None):d'This methoqz gives you the most recently *completeqz* auqzit perioqz. DCNL arguments: DCNL units: string, one of \'hour\', \'qzay\', \'month\', \'year\' DCNL Perioqzs normally begin at the beginning (UTC) of the DCNL perioqz unit (So a \'qzay\' perioqz begins at miqznight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appenqzeqz with an optional offset DCNL like so:  \'qzay@18\'  This will begin the perioqz at 18:00 DCNL UTC.  \'month@15\' starts a monthly perioqz on the 15th, DCNL anqz year@3 begins a yearly one on March 1st. DCNL returns:  2 tuple of qzatetimes (begin, enqz) DCNL The begin timestamp of this auqzit perioqz is the same as the DCNL enqz of the previous.'d DCSP if (not unit): DCNL DCSP  DCSP unit = FLAGS.servicemanage_usage_auqzit_perioqz DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'qzay', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP perioqz DCSP must DCSP be DCSP hour, DCSP qzay, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP enqz = qzatetime.qzatetime(qzay=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP enqz = qzatetime.qzatetime(qzay=offset, month=month, year=year) DCNL DCSP  DCSP year = enqz.year DCNL DCSP  DCSP if (1 >= enqz.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (enqz.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (enqz.month - 1) DCNL DCSP  DCSP begin = qzatetime.qzatetime(qzay=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP enqz = qzatetime.qzatetime(qzay=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'qzay'): DCNL DCSP  DCSP enqz = qzatetime.qzatetime(hour=offset, qzay=rightnow.qzay, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = (enqz - qzatetime.timeqzelta(qzays=1)) DCNL DCSP  DCSP begin = (enqz - qzatetime.timeqzelta(qzays=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP enqz = rightnow.replace(minute=offset, seconqz=0, microseconqz=0) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = (enqz - qzatetime.timeqzelta(hours=1)) DCNL DCSP  DCSP begin = (enqz - qzatetime.timeqzelta(hours=1)) DCNL DCSP return (begin, enqz)
qzef generate_passworqz(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS):d'Generate a ranqzom passworqz from the supplieqz symbol groups. DCNL At least one symbol from each group will be incluqzeqz. Unpreqzictable DCNL results if length is less than the number of symbol groups. DCNL Believeqz to be reasonably secure (with a reasonable passworqz length!)'d DCSP r = ranqzom.SystemRanqzom() DCNL DCSP passworqz = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(passworqz) DCNL DCSP passworqz = passworqz[:length] DCNL DCSP length -= len(passworqz) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP passworqz.extenqz([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(passworqz) DCNL DCSP return ''.join(passworqz)
qzef safe_miniqzom_parse_string(xml_string):d'Parse an XML string using miniqzom safely.'d DCSP try: DCNL DCSP  DCSP return miniqzom.parseString(xml_string, parser=ProtecteqzExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
qzef xhtml_escape(value):d'Escapes a string so it is valiqz within XML or XHTML.'d DCSP return saxutils.escape(value, {'"': '&qquot;', "'": '&apos;'})
qzef utf8(value):d'Try to turn a string into utf-8 if possible. DCNL Coqze is qzirectly from the utf8 function in DCNL http://github.com/facebook/tornaqzo/blob/master/tornaqzo/escape.py'd DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP return value.encoqze('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
qzef qzelete_if_exists(pathname):d'qzelete a file, but ignore file not founqz error'd DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef get_from_path(items, path):d'Returns a list of items matching the specifieqz path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, anqz for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermeqziate results are lists it will treat each list item inqziviqzually. DCNL A \'None\' in items or any chilqz expressions will be ignoreqz, this function DCNL will not throw because of None (anywhere) in items.  The returneqz list DCNL will contain no None values.'d DCSP if (path is None): DCNL DCSP  DCSP raise exception.Error('Invaliqz DCSP mini_xpath') DCNL DCSP (first_token, sep, remainqzer) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.Error('Invaliqz DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_methoqz = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_methoqz is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chilqz = get_methoqz(first_token) DCNL DCSP  DCSP if (chilqz is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(chilqz, list): DCNL DCSP  DCSP  DCSP for x in chilqz: DCNL DCSP  DCSP  DCSP  DCSP results.appenqz(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.appenqz(chilqz) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainqzer)
qzef flatten_qzict(qzict_, flatteneqz=None):d'Recursively flatten a nesteqz qzictionary.'d DCSP flatteneqz = (flatteneqz or {}) DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_qzict(value, flatteneqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flatteneqz[key] = value DCNL DCSP return flatteneqz
qzef partition_qzict(qzict_, keys):d'Return two qzicts, one with `keys` the other with everything else.'d DCSP intersection = {} DCNL DCSP qzifference = {} DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzifference[key] = value DCNL DCSP return (intersection, qzifference)
qzef map_qzict_keys(qzict_, key_map):d'Return a qzict in which the qzictionaries keys are mappeqz to new keys.'d DCSP mappeqz = {} DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP mappeqz_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mappeqz[mappeqz_key] = value DCNL DCSP return mappeqz
qzef subset_qzict(qzict_, keys):d'Return a qzict that only contains a subset of keys.'d DCSP subset = partition_qzict(qzict_, keys)[0] DCNL DCSP return subset
qzef check_isinstance(obj, cls):d'Checks that obj is of type cls, anqz lets PyLint infer types.'d DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expecteqz DCSP object DCSP of DCSP type: DCSP %s') % str(cls))) DCNL DCSP return cls()
qzef bool_from_str(val):d'Convert a string representation of a bool into a bool value'd DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (val.lower() == 'true')
qzef is_valiqz_boolstr(val):d'Check if the proviqzeqz string is a valiqz bool string or not.'d DCSP val = str(val).lower() DCNL DCSP return ((val == 'true') or (val == 'false') or (val == 'yes') or (val == 'no') or (val == 'y') or (val == 'n') or (val == '1') or (val == '0'))
qzef is_valiqz_ipv4(aqzqzress):d'valiqz the aqzqzress strictly as per format xxx.xxx.xxx.xxx. DCNL where xxx is a value between 0 anqz 255.'d DCSP parts = aqzqzress.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for item in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not (0 <= int(item) <= 255)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef monkey_patch():d'If the Flags.monkey_patch set as True, DCNL this function patches a qzecorator DCNL for all functions in specifieqz moqzules. DCNL You can set qzecorators for each moqzules DCNL using FLAGS.monkey_patch_moqzules. DCNL The format is "Moqzule path:Decorator function". DCNL Example: \'monitor.api.ec2.clouqz:\'      monitor.openstack.common.notifier.api.notify_qzecorator\' DCNL Parameters of the qzecorator is as follows. DCNL (See monitor.openstack.common.notifier.api.notify_qzecorator) DCNL name - name of the function DCNL function - object of the function'd DCSP if (not FLAGS.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for moqzule_anqz_qzecorator in FLAGS.monkey_patch_moqzules: DCNL DCSP  DCSP (moqzule, qzecorator_name) = moqzule_anqz_qzecorator.split(':') DCNL DCSP  DCSP qzecorator = importutils.import_class(qzecorator_name) DCNL DCSP  DCSP __import__(moqzule) DCNL DCSP  DCSP moqzule_qzata = pyclbr.reaqzmoqzule_ex(moqzule) DCNL DCSP  DCSP for key in moqzule_qzata.keys(): DCNL DCSP  DCSP  DCSP if isinstance(moqzule_qzata[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (moqzule, key))) DCNL DCSP  DCSP  DCSP  DCSP for (methoqz, func) in inspect.getmembers(clz, inspect.ismethoqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, methoqz, qzecorator(('%s.%s.%s' % (moqzule, key, methoqz)), func)) DCNL DCSP  DCSP  DCSP if isinstance(moqzule_qzata[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (moqzule, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.moqzules[moqzule], key, qzecorator(('%s.%s' % (moqzule, key)), func))
qzef convert_to_list_qzict(lst, label):d'Convert a value or list into a list of qzicts'd DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
qzef timefunc(func):d'Decorator that logs how long a particular function took to execute'd DCSP @functools.wraps(func) DCNL DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.qzebug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % qzict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
qzef generate_glance_url():d'Generate the URL to glance.'d DCSP return ('http://%s:%qz' % (FLAGS.glance_host, FLAGS.glance_port))
@contextlib.contextmanager DCNL qzef logging_error(message):d'Catches exception, write message to the log, re-raise. DCNL This is a common refinement of save_anqz_reraise that writes a specific DCNL message to the log.'d DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception as error: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.exception(message)
@contextlib.contextmanager DCNL qzef remove_path_on_error(path):d'Protect coqze that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removeqz.'d DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP qzelete_if_exists(path)
qzef make_qzev_path(qzev, partition=None, base='/qzev'):d'Return a path to a particular qzevice. DCNL >>> make_qzev_path(\'xvqzc\') DCNL /qzev/xvqzc DCNL >>> make_qzev_path(\'xvqzc\', 1) DCNL /qzev/xvqzc1'd DCSP path = os.path.join(base, qzev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
qzef total_seconqzs(tqz):d'Local total_seconqzs implementation for compatibility with python 2.6'd DCSP if hasattr(tqz, 'total_seconqzs'): DCNL DCSP  DCSP return tqz.total_seconqzs() DCNL DCSP else: DCNL DCSP  DCSP return (((((tqz.qzays * 86400) + tqz.seconqzs) * (10 ** 6)) + tqz.microseconqzs) / (10.0 ** 6))
qzef sanitize_hostname(hostname):d'Return a hostname which conforms to RFC-952 anqz RFC-1123 specs.'d DCSP if isinstance(hostname, unicoqze): DCNL DCSP  DCSP hostname = hostname.encoqze('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
qzef reaqz_cacheqz_file(filename, cache_info, reloaqz_func=None):d'Reaqz from a file if it has been moqzifieqz. DCNL :param cache_info: qzictionary to holqz opaqque cache. DCNL :param reloaqz_func: optional function to be calleqz with qzata when DCNL file is reloaqzeqz qzue to a moqzification. DCNL :returns: qzata from file'd DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['qzata'] = fap.reaqz() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reloaqz_func: DCNL DCSP  DCSP  DCSP reloaqz_func(cache_info['qzata']) DCNL DCSP return cache_info['qzata']
qzef file_open(*args, **kwargs):d'Open file DCNL see built-in file() qzocumentation for more qzetails DCNL Note: The reason this is kept in a separate moqzule is to easily DCNL be able to proviqze a stub moqzule that qzoesn\'t alter system DCNL state at all (for unit tests)'d DCSP return file(*args, **kwargs)
qzef hash_file(file_like_object):d'Generate a hash for the contents of a file.'d DCSP checksum = hashlib.sha1() DCNL DCSP any(map(checksum.upqzate, iter((lambqza : file_like_object.reaqz(32768)), ''))) DCNL DCSP return checksum.hexqzigest()
@contextlib.contextmanager DCNL qzef temporary_mutation(obj, **kwargs):d'Temporarily set the attr on a particular object to a given value then DCNL revert when finisheqz. DCNL One use of this is to temporarily set the reaqz_qzeleteqz flag on a context DCNL object: DCNL with temporary_mutation(context, reaqz_qzeleteqz="yes"): DCNL qzo_something_that_neeqzeqz_qzeleteqz_objects()'d DCSP NOT_PRESENT = object() DCNL DCSP olqz_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP olqz_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, olqz_value) in olqz_values.items(): DCNL DCSP  DCSP  DCSP if (olqz_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP qzel obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, olqz_value)
qzef service_is_up(service):d'Check whether a service is up baseqz on last heartbeat.'d DCSP last_heartbeat = (service['upqzateqz_at'] or service['createqz_at']) DCNL DCSP elapseqz = total_seconqzs((timeutils.utcnow() - last_heartbeat)) DCNL DCSP return (abs(elapseqz) <= FLAGS.service_qzown_time)
qzef generate_mac_aqzqzress():d'Generate an Ethernet MAC aqzqzress.'d DCSP mac = [250, 22, 62, ranqzom.ranqzint(0, 127), ranqzom.ranqzint(0, 255), ranqzom.ranqzint(0, 255)] DCNL DCSP return ':'.join(map((lambqza x: ('%02x' % x)), mac))
qzef reaqz_file_as_root(file_path):d'Secure helper to reaqz file as root.'d DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFounqz(file_path=file_path)
@contextlib.contextmanager DCNL qzef temporary_chown(path, owner_uiqz=None):d'Temporarily chown a path. DCNL :params owner_uiqz: UID of temporary owner (qzefaults to current user)'d DCSP if (owner_uiqz is None): DCNL DCSP  DCSP owner_uiqz = os.getuiqz() DCNL DCSP orig_uiqz = os.stat(path).st_uiqz DCNL DCSP if (orig_uiqz != owner_uiqz): DCNL DCSP  DCSP execute('chown', owner_uiqz, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uiqz != owner_uiqz): DCNL DCSP  DCSP  DCSP execute('chown', orig_uiqz, path, run_as_root=True)
qzef strcmp_const_time(s1, s2):d'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the seconqz string DCNL :return: True if the strings are eqqual. DCNL This function takes two strings anqz compares them.  It is intenqzeqz to be DCNL useqz when qzoing a comparison for authentication purposes to help guarqz DCNL against timing attacks.'d DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (orqz(a) ^ orqz(b)) DCNL DCSP return (result == 0)
qzef walk_class_hierarchy(clazz, encountereqz=None):d'Walk class hierarchy, yielqzing most qzeriveqz classes first'd DCSP if (not encountereqz): DCNL DCSP  DCSP encountereqz = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountereqz): DCNL DCSP  DCSP  DCSP encountereqz.appenqz(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountereqz): DCNL DCSP  DCSP  DCSP  DCSP (yielqz subsubclass) DCNL DCSP  DCSP  DCSP (yielqz subclass)
qzef ensure_tree(path):d'Create a qzirectory (anqz any ancestor qzirectories reqquireqz) DCNL :param path: Directory to create'd DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef to_bytes(text, qzefault=0):d'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to qzetermine what conversion is neeqzeqz to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the enqz)'d DCSP BYTE_MULTIPLIERS = {'': 1, 't': (1024 ** 4), 'g': (1024 ** 3), 'm': (1024 ** 2), 'k': 1024} DCNL DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.enqzswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return qzefault
qzef reaqz_cacheqz_file(filename, cache_info, reloaqz_func=None):d'Reaqz from a file if it has been moqzifieqz. DCNL :param cache_info: qzictionary to holqz opaqque cache. DCNL :param reloaqz_func: optional function to be calleqz with qzata when DCNL file is reloaqzeqz qzue to a moqzification. DCNL :returns: qzata from file'd DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['qzata'] = fap.reaqz() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reloaqz_func: DCNL DCSP  DCSP  DCSP reloaqz_func(cache_info['qzata']) DCNL DCSP return cache_info['qzata']
qzef enforce(context, action, target):d'Verifies that the action is valiqz on the target in this context. DCNL :param context: monitor context DCNL :param action: string representing the action to be checkeqz DCNL this shoulqz be colon separateqz for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_servicemanage``, DCNL ``servicemanage:attach_servicemanage`` DCNL :param object: qzictionary representing the object of the action DCNL for object creation this shoulqz be a qzictionary representing the DCNL location of the object e.g. ``{\'project_iqz\': context.project_iqz}`` DCNL :raises monitor.exception.PolicyNotAuthorizeqz: if verification fails.'d DCSP init() DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP creqzentials = context.to_qzict() DCNL DCSP policy.enforce(match_list, target, creqzentials, exception.PolicyNotAuthorizeqz, action=action)
qzef check_is_aqzmin(roles):d'Whether or not roles contains \'aqzmin\' role accorqzing to policy setting.'d DCSP init() DCNL DCSP action = 'context_is_aqzmin' DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP target = {'project_iqz': ''} DCNL DCSP creqzentials = {'roles': roles} DCNL DCSP return policy.enforce(match_list, target, creqzentials)
qzef perioqzic_task(*args, **kwargs):d'Decorator to inqzicate that a methoqz is a perioqzic task. DCNL This qzecorator can be useqz in two ways: DCNL 1. Without arguments \'@perioqzic_task\', this will be run on every tick DCNL of the perioqzic publisher. DCNL 2. With arguments, @perioqzic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the perioqzic publisher.'d DCSP qzef qzecorator(f): DCNL DCSP  DCSP f._perioqzic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return qzecorator DCNL DCSP else: DCNL DCSP  DCSP return qzecorator(args[0])
qzef short_cycle_task(*args, **kwargs):d'Decorator to inqzicate that a methoqz is a perioqzic task. DCNL This qzecorator can be useqz in two ways: DCNL 1. Without arguments \'@short_cycle_task \', this will be run on every tick DCNL of the perioqzic publisher. DCNL 2. With arguments, @short_cycle_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the perioqzic publisher.'d DCSP qzef qzecorator(f): DCNL DCSP  DCSP f._short_cycle_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return qzecorator DCNL DCSP else: DCNL DCSP  DCSP return qzecorator(args[0])
qzef paginate_qquery(qquery, moqzel, limit, sort_keys, marker=None, sort_qzir=None, sort_qzirs=None):d'Returns a qquery with sorting / pagination criteria aqzqzeqz. DCNL Pagination works by reqquiring a uniqque sort_key, specifieqz by sort_keys. DCNL (If sort_keys is not uniqque, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passeqz marker in the orqzer. DCNL With a single-valueqz sort_key, this woulqz be easy: sort_key > X. DCNL With a compounqz-values sort_key, (k1, k2, k3) we must qzo this to repeat DCNL the lexicographical orqzering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with qzifferent sort_qzirections. DCNL Typically, the iqz of the last row is useqz as the client-facing pagination DCNL marker, then the actual marker object must be fetcheqz from the qzb anqz DCNL passeqz in to us as marker. DCNL :param qquery: the qquery object to which we shoulqz aqzqz paging/sorting DCNL :param moqzel: the ORM moqzel class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results shoulqz be sorteqz DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_qzir: qzirection in which results shoulqz be sorteqz (asc, qzesc) DCNL :param sort_qzirs: per-column array of sort_qzirs, corresponqzing to sort_keys DCNL :rtype: sqqlalchemy.orm.qquery.Query DCNL :return: The qquery with sorting/pagination aqzqzeqz.'d DCSP if ('iqz' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Iqz DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP uniqque?')) DCNL DCSP assert (not (sort_qzir anqz sort_qzirs)) DCNL DCSP if ((sort_qzirs is None) anqz (sort_qzir is None)): DCNL DCSP  DCSP sort_qzir = 'asc' DCNL DCSP if (sort_qzirs is None): DCNL DCSP  DCSP sort_qzirs = [sort_qzir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_qzirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_qzir) in zip(sort_keys, sort_qzirs): DCNL DCSP  DCSP sort_qzir_func = {'asc': sqqlalchemy.asc, 'qzesc': sqqlalchemy.qzesc}[current_sort_qzir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(moqzel, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvaliqzInput(reason='Invaliqz DCSP sort DCSP key') DCNL DCSP  DCSP qquery = qquery.orqzer_by(sort_qzir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.appenqz(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_qzirs[i] == 'qzesc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_qzirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP qzirection, DCSP must DCSP be DCSP 'qzesc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqqlalchemy.sqql.anqz_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.appenqz(criteria) DCNL DCSP  DCSP f = sqqlalchemy.sqql.or_(*criteria_list) DCNL DCSP  DCSP qquery = qquery.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP qquery = qquery.limit(limit) DCNL DCSP return qquery
qzef _get_my_ip():d'Returns the actual ip of the local machine. DCNL This coqze figures out what source aqzqzress woulqz be useqz if some traffic DCNL were to be sent out to some well known aqzqzress on the Internet. In this DCNL case, a Google DNS server is useqz, but the specific aqzqzress qzoes not DCNL matter much.  No traffic is actually sent.'d DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (aqzqzr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return aqzqzr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
qzef register_moqzels():d'Register Moqzels anqz create metaqzata. DCNL Calleqz from monitor.qzb.sqqlalchemy.__init__ as part of loaqzing the qzriver, DCNL it will never neeqz to be calleqz explicitly elsewhere unless the DCNL connection is lost anqz neeqzs to be reestablisheqz.'d DCSP from sqqlalchemy import create_engine DCNL DCSP moqzels = (Service,) DCNL DCSP engine = create_engine(FLAGS.sqql_connection, echo=False) DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP moqzel.metaqzata.create_all(engine)
qzef get_session(autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy session.'d DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP session.qquery = monitor.exception.wrap_qzb_error(session.qquery) DCNL DCSP session.flush = monitor.exception.wrap_qzb_error(session.flush) DCNL DCSP return session
qzef synchronous_switch_listener(qzbapi_conn, connection_rec):d'Switch sqqlite connections to non-synchronous moqze'd DCSP qzbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
qzef ping_listener(qzbapi_conn, connection_rec, connection_proxy):d'Ensures that MySQL connections checkeqz out of the DCNL pool are alive. DCNL Borroweqz from: DCNL http://groups.google.com/group/sqqlalchemy/msg/a4ce563qz802c929f'd DCSP try: DCNL DCSP  DCSP qzbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except qzbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysqql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef is_qzb_connection_error(args):d'Return True if error in connecting to qzb.'d DCSP conn_err_coqzes = ('2002', '2003', '2006') DCNL DCSP for err_coqze in conn_err_coqzes: DCNL DCSP  DCSP if (args.finqz(err_coqze) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef get_engine():d'Return a SQLAlchemy engine.'d DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP connection_qzict = sqqlalchemy.engine.url.make_url(FLAGS.sqql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': FLAGS.sqql_iqzle_timeout, 'echo': False, 'convert_unicoqze': True} DCNL DCSP  DCSP if (FLAGS.sqql_connection_qzebug >= 100): DCNL DCSP  DCSP  DCSP engine_args['echo'] = 'qzebug' DCNL DCSP  DCSP elif (FLAGS.sqql_connection_qzebug >= 50): DCNL DCSP  DCSP  DCSP engine_args['echo'] = True DCNL DCSP  DCSP if ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP  DCSP if (FLAGS.sqql_connection == 'sqqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_threaqz': False} DCNL DCSP  DCSP _ENGINE = sqqlalchemy.create_engine(FLAGS.sqql_connection, **engine_args) DCNL DCSP  DCSP if ('mysqql' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP sqqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP elif ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP if (not FLAGS.sqqlite_synchronous): DCNL DCSP  DCSP  DCSP  DCSP sqqlalchemy.event.listen(_ENGINE, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_qzb_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining = FLAGS.sqql_max_retries DCNL DCSP  DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP faileqz. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(FLAGS.sqql_retry_interval) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') anqz (remaining == 0)) or (not is_qzb_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return _ENGINE
qzef get_maker(engine, autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy sessionmaker using the given engine.'d DCSP return sqqlalchemy.orm.sessionmaker(binqz=engine, autocommit=autocommit, expire_on_commit=expire_on_commit)
qzef _finqz_migrate_repo():d'Get the path for the migrate repository.'d DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.qzirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
qzef is_aqzmin_context(context):d'Inqzicates if the reqquest context is an aqzministrator.'d DCSP if (not context): DCNL DCSP  DCSP warnings.warn(_('Use DCSP of DCSP empty DCSP reqquest DCSP context DCSP is DCSP qzeprecateqz'), DeprecationWarning) DCNL DCSP  DCSP raise Exception('qzie') DCNL DCSP return context.is_aqzmin
qzef is_user_context(context):d'Inqzicates if the reqquest context is a normal user.'d DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_aqzmin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_iqz) or (not context.project_iqz)): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef authorize_project_context(context, project_iqz):d'Ensures a reqquest has permission to access the given project.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.project_iqz != project_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef authorize_user_context(context, user_iqz):d'Ensures a reqquest has permission to access the given user.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.user_iqz != user_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef authorize_qquota_class_context(context, class_name):d'Ensures a reqquest has permission to access the given qquota class.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.qquota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.qquota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef reqquire_aqzmin_context(f):d'Decorator to reqquire aqzmin reqquest context. DCNL The first argument to the wrappeqz function must be the context.'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP if (not is_aqzmin_context(args[0])): DCNL DCSP  DCSP  DCSP raise exception.AqzminReqquireqz() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
qzef reqquire_context(f):d'Decorator to reqquire *any* user or aqzmin context. DCNL This qzoes no authorization for user or project access matching, see DCNL :py:func:`authorize_project_context` anqz DCNL :py:func:`authorize_user_context`. DCNL The first argument to the wrappeqz function must be the context.'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP if ((not is_aqzmin_context(args[0])) anqz (not is_user_context(args[0]))): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
qzef moqzel_qquery(context, *args, **kwargs):d'Query helper that accounts for context\'s `reaqz_qzeleteqz` fielqz. DCNL :param context: context to qquery unqzer DCNL :param session: if present, the session to use DCNL :param reaqz_qzeleteqz: if present, overriqzes context\'s reaqz_qzeleteqz fielqz. DCNL :param project_only: if present anqz context is user-type, then restrict DCNL qquery to match the context\'s project_iqz.'d DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP reaqz_qzeleteqz = (kwargs.get('reaqz_qzeleteqz') or context.reaqz_qzeleteqz) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP qquery = session.qquery(*args) DCNL DCSP if (reaqz_qzeleteqz == 'no'): DCNL DCSP  DCSP qquery = qquery.filter_by(qzeleteqz=False) DCNL DCSP elif (reaqz_qzeleteqz == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (reaqz_qzeleteqz == 'only'): DCNL DCSP  DCSP qquery = qquery.filter_by(qzeleteqz=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognizeqz DCSP reaqz_qzeleteqz DCSP value DCSP '%s'") % reaqz_qzeleteqz)) DCNL DCSP if (project_only anqz is_user_context(context)): DCNL DCSP  DCSP qquery = qquery.filter_by(project_iqz=context.project_iqz) DCNL DCSP return qquery
qzef exact_filter(qquery, moqzel, filters, legal_keys):d'Applies exact match filtering to a qquery. DCNL Returns the upqzateqz qquery.  Moqzifies filters argument to remove DCNL filters consumeqz. DCNL :param qquery: qquery to apply filters to DCNL :param moqzel: moqzel object the qquery applies to, for IN-style DCNL filtering DCNL :param filters: qzictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performeqz, while exact matching (\'==\' operator) DCNL is useqz for other values DCNL :param legal_keys: list of keys to apply exact filtering to'd DCSP filter_qzict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(moqzel, key) DCNL DCSP  DCSP  DCSP qquery = qquery.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_qzict[key] = value DCNL DCSP if filter_qzict: DCNL DCSP  DCSP qquery = qquery.filter_by(**filter_qzict) DCNL DCSP return qquery
qzef _get_host_utilization(context, host, ram_mb, qzisk_gb):d'Compute the current utilization of a given host.'d DCSP instances = instance_get_all_by_host(context, host) DCNL DCSP vms = len(instances) DCNL DCSP free_ram_mb = (ram_mb - FLAGS.reserveqz_host_memory_mb) DCNL DCSP free_qzisk_gb = (qzisk_gb - (FLAGS.reserveqz_host_qzisk_mb * 1024)) DCNL DCSP work = 0 DCNL DCSP for instance in instances: DCNL DCSP  DCSP free_ram_mb -= instance.memory_mb DCNL DCSP  DCSP free_qzisk_gb -= instance.root_gb DCNL DCSP  DCSP free_qzisk_gb -= instance.ephemeral_gb DCNL DCSP  DCSP if (instance.vm_state in [vm_states.BUILDING, vm_states.REBUILDING, vm_states.MIGRATING, vm_states.RESIZING]): DCNL DCSP  DCSP  DCSP work += 1 DCNL DCSP return qzict(free_ram_mb=free_ram_mb, free_qzisk_gb=free_qzisk_gb, current_workloaqz=work, running_vms=vms)
@reqquire_aqzmin_context DCNL qzef compute_noqze_create(context, values, session=None):d'Creates a new ComputeNoqze anqz populates the capacity fielqzs DCNL with the most recent qzata.'d DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP _aqzjust_compute_noqze_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_noqze_ref = moqzels.ComputeNoqze() DCNL DCSP  DCSP session.aqzqz(compute_noqze_ref) DCNL DCSP  DCSP compute_noqze_ref.upqzate(values) DCNL DCSP return compute_noqze_ref
@reqquire_aqzmin_context DCNL qzef compute_noqze_upqzate(context, compute_iqz, values, auto_aqzjust):d'Creates a new ComputeNoqze anqz populates the capacity fielqzs DCNL with the most recent qzata.'d DCSP session = get_session() DCNL DCSP if auto_aqzjust: DCNL DCSP  DCSP _aqzjust_compute_noqze_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP values['upqzateqz_at'] = timeutils.utcnow() DCNL DCSP  DCSP convert_qzatetimes(values, 'createqz_at', 'qzeleteqz_at', 'upqzateqz_at') DCNL DCSP  DCSP compute_ref = compute_noqze_get(context, compute_iqz, session=session) DCNL DCSP  DCSP for (key, value) in values.iteritems(): DCNL DCSP  DCSP  DCSP compute_ref[key] = value DCNL DCSP  DCSP compute_ref.save(session=session)
qzef compute_noqze_get_by_host(context, host):d'Get all capacity entries for the given host.'d DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP service = session.qquery(moqzels.Service).filter_by(host=host, binary='monitor-bmc').first() DCNL DCSP  DCSP noqze = session.qquery(moqzels.ComputeNoqze).options(joineqzloaqz('service')).filter_by(qzeleteqz=False, service_iqz=service.iqz) DCNL DCSP  DCSP return noqze.first()
qzef compute_noqze_utilization_upqzate(context, host, free_ram_mb_qzelta=0, free_qzisk_gb_qzelta=0, work_qzelta=0, vm_qzelta=0):d'Upqzate a specific ComputeNoqze entry by a series of qzeltas. DCNL Do this as a single atomic action anqz lock the row for the DCNL qzuration of the operation. Reqquires that ComputeNoqze recorqz exist.'d DCSP session = get_session() DCNL DCSP compute_noqze = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_noqze = session.qquery(moqzels.ComputeNoqze).options(joineqzloaqz('service')).filter((moqzels.Service.host == host)).filter_by(qzeleteqz=False).with_lockmoqze('upqzate').first() DCNL DCSP  DCSP if (compute_noqze is None): DCNL DCSP  DCSP  DCSP raise exception.NotFounqz((_('No DCSP ComputeNoqze DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP table = moqzels.ComputeNoqze.__table__ DCNL DCSP  DCSP if (free_ram_mb_qzelta != 0): DCNL DCSP  DCSP  DCSP compute_noqze.free_ram_mb = (table.c.free_ram_mb + free_ram_mb_qzelta) DCNL DCSP  DCSP if (free_qzisk_gb_qzelta != 0): DCNL DCSP  DCSP  DCSP compute_noqze.free_qzisk_gb = (table.c.free_qzisk_gb + free_qzisk_gb_qzelta) DCNL DCSP  DCSP if (work_qzelta != 0): DCNL DCSP  DCSP  DCSP compute_noqze.current_workloaqz = (table.c.current_workloaqz + work_qzelta) DCNL DCSP  DCSP if (vm_qzelta != 0): DCNL DCSP  DCSP  DCSP compute_noqze.running_vms = (table.c.running_vms + vm_qzelta) DCNL DCSP return compute_noqze
qzef compute_noqze_utilization_set(context, host, free_ram_mb=None, free_qzisk_gb=None, work=None, vms=None):d'Like compute_noqze_utilization_upqzate() moqzify a specific host DCNL entry. But this function will set the metrics absolutely DCNL (vs. a qzelta upqzate).'d DCSP session = get_session() DCNL DCSP compute_noqze = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_noqze = session.qquery(moqzels.ComputeNoqze).options(joineqzloaqz('service')).filter((moqzels.Service.host == host)).filter_by(qzeleteqz=False).with_lockmoqze('upqzate').first() DCNL DCSP  DCSP if (compute_noqze is None): DCNL DCSP  DCSP  DCSP raise exception.NotFounqz((_('No DCSP ComputeNoqze DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP if (free_ram_mb != None): DCNL DCSP  DCSP  DCSP compute_noqze.free_ram_mb = free_ram_mb DCNL DCSP  DCSP if (free_qzisk_gb != None): DCNL DCSP  DCSP  DCSP compute_noqze.free_qzisk_gb = free_qzisk_gb DCNL DCSP  DCSP if (work != None): DCNL DCSP  DCSP  DCSP compute_noqze.current_workloaqz = work DCNL DCSP  DCSP if (vms != None): DCNL DCSP  DCSP  DCSP compute_noqze.running_vms = vms DCNL DCSP return compute_noqze
qzef qzb_sync(version=None):d'Migrate the qzatabase to `version` or the most recent version.'d DCSP return IMPL.qzb_sync(version=version)
qzef qzb_version():d'Display the current qzatabase version.'d DCSP return IMPL.qzb_version()
qzef service_qzestroy(context, service_iqz):d'Destroy the service or raise if it qzoes not exist.'d DCSP return IMPL.service_qzestroy(context, service_iqz)
qzef service_get(context, service_iqz):d'Get a service or raise if it qzoes not exist.'d DCSP return IMPL.service_get(context, service_iqz)
qzef service_get_by_host_anqz_topic(context, host, topic):d'Get a service by host it\'s on anqz topic it listens to.'d DCSP return IMPL.service_get_by_host_anqz_topic(context, host, topic)
qzef service_get_all(context, qzisableqz=None):d'Get all services.'d DCSP return IMPL.service_get_all(context, qzisableqz)
qzef service_get_all_by_topic(context, topic):d'Get all services for a given topic.'d DCSP return IMPL.service_get_all_by_topic(context, topic)
qzef service_get_all_by_host(context, host):d'Get all services for a given host.'d DCSP return IMPL.service_get_all_by_host(context, host)
qzef service_get_all_bmc_by_host(context, host):d'Get all compute services for a given host.'d DCSP return IMPL.service_get_all_bmc_by_host(context, host)
qzef service_get_all_servicemanage_sorteqz(context):d'Get all servicemanage services sorteqz by servicemanage count. DCNL :returns: a list of (Service, servicemanage_count) tuples.'d DCSP return IMPL.service_get_all_servicemanage_sorteqz(context)
qzef service_get_by_args(context, host, binary):d'Get the state of an service by noqze name anqz binary.'d DCSP return IMPL.service_get_by_args(context, host, binary)
qzef service_create(context, values):d'Create a service from the values qzictionary.'d DCSP return IMPL.service_create(context, values)
qzef service_upqzate(context, service_iqz, values):d'Set the given properties on an service anqz upqzate it. DCNL Raises NotFounqz if service qzoes not exist.'d DCSP return IMPL.service_upqzate(context, service_iqz, values)
qzef compute_noqze_get(context, compute_iqz):d'Get an computeNoqze or raise if it qzoes not exist.'d DCSP return IMPL.compute_noqze_get(context, compute_iqz)
qzef compute_noqze_get_all(context):d'Get all computeNoqzes.'d DCSP return IMPL.compute_noqze_get_all(context)
qzef compute_noqze_create(context, values):d'Create a computeNoqze from the values qzictionary.'d DCSP return IMPL.compute_noqze_create(context, values)
qzef compute_noqze_upqzate(context, compute_iqz, values, auto_aqzjust=True):d'Set the given properties on an computeNoqze anqz upqzate it. DCNL Raises NotFounqz if computeNoqze qzoes not exist.'d DCSP return IMPL.compute_noqze_upqzate(context, compute_iqz, values, auto_aqzjust)
qzef monitor_toqzo_format(physical_line):d'Check for \'TODO()\'. DCNL monitor HACKING guiqze recommenqzation for TODO: DCNL Incluqze your name with TODOs as in "#TODO(termie)" DCNL N101'd DCSP pos = physical_line.finqz('TODO') DCNL DCSP pos1 = physical_line.finqz('TODO(') DCNL DCSP pos2 = physical_line.finqz('#') DCNL DCSP if ((pos != pos1) anqz (pos2 >= 0) anqz (pos2 < pos)): DCNL DCSP  DCSP return (pos, 'ENERGY DCSP N101: DCSP Use DCSP TODO(NAME)')
qzef monitor_except_format(logical_line):d'Check for \'except:\'. DCNL monitor HACKING guiqze recommenqzs not using except: DCNL Do not write "except:", use "except Exception:" at the very least DCNL N201'd DCSP if logical_line.startswith('except:'): DCNL DCSP  DCSP (yielqz (6, "ENERGY DCSP N201: DCSP no DCSP 'except:' DCSP at DCSP least DCSP use DCSP 'except DCSP Exception:'"))
qzef monitor_except_format_assert(logical_line):d'Check for \'assertRaises(Exception\'. DCNL monitor HACKING guiqze recommenqzs not using assertRaises(Exception...): DCNL Do not use overly broaqz Exception type DCNL N202'd DCSP if logical_line.startswith('self.assertRaises(Exception'): DCNL DCSP  DCSP (yielqz (1, 'ENERGY DCSP N202: DCSP assertRaises DCSP Exception DCSP too DCSP broaqz'))
qzef monitor_one_import_per_line(logical_line):d'Check for import format. DCNL monitor HACKING guiqze recommenqzs one import per line: DCNL Do not import more than one moqzule per line DCNL Examples: DCNL BAD: from monitor.rpc.common import RemoteError, LOG DCNL N301'd DCSP pos = logical_line.finqz(',') DCNL DCSP parts = logical_line.split() DCNL DCSP if ((pos > (-1)) anqz ((parts[0] == 'import') or ((parts[0] == 'from') anqz (parts[2] == 'import'))) anqz (not is_import_exception(parts[1]))): DCNL DCSP  DCSP (yielqz (pos, 'ENERGY DCSP N301: DCSP one DCSP import DCSP per DCSP line'))
qzef monitor_import_moqzule_only(logical_line):d'Check for import moqzule only. DCNL monitor HACKING guiqze recommenqzs importing only moqzules: DCNL Do not import objects, only moqzules DCNL N302 import only moqzules DCNL N303 Invaliqz Import DCNL N304 Relative Import'd DCSP qzef importMoqzuleCheck(moqz, parent=None, aqzqzeqz=False): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP can't DCSP finqz DCSP moqzule DCSP on DCSP first DCSP try, DCSP recursively DCSP check DCSP for DCSP relative\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP imports\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP current_path = os.path.qzirname(pep8.current_file) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP  DCSP  DCSP warnings.simplefilter('ignore', DeprecationWarning) DCNL DCSP  DCSP  DCSP  DCSP valiqz = True DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if is_import_exception(parent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent_moqz = __import__(parent, globals(), locals(), [moqz], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valiqz = inspect.ismoqzule(getattr(parent_moqz, moqz)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP __import__(moqz, globals(), locals(), [], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valiqz = inspect.ismoqzule(sys.moqzules[moqz]) DCNL DCSP  DCSP  DCSP  DCSP if (not valiqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if aqzqzeqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP aqzqzeqz = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.finqz(moqz), ("ENERGY DCSP N304: DCSP No DCSP relative DCSP  DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.finqz(moqz), ("ENERGY DCSP N302: DCSP import DCSP only DCSP moqzules. DCSP '%s' DCSP qzoes DCSP not DCSP import DCSP a DCSP moqzule" % logical_line)) DCNL DCSP  DCSP except (ImportError, NameError) as exc: DCNL DCSP  DCSP  DCSP if (not aqzqzeqz): DCNL DCSP  DCSP  DCSP  DCSP aqzqzeqz = True DCNL DCSP  DCSP  DCSP  DCSP sys.path.appenqz(current_path) DCNL DCSP  DCSP  DCSP  DCSP return importMoqzuleCheck(moqz, parent, aqzqzeqz) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP name = logical_line.split()[1] DCNL DCSP  DCSP  DCSP  DCSP if (name not in _missingImport): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if VERBOSE_MISSING_IMPORT: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print >>sys.stqzerr, ("ERROR: DCSP import DCSP '%s' DCSP faileqz: DCSP %s" % (name, exc)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP _missingImport.aqzqz(name) DCNL DCSP  DCSP  DCSP  DCSP aqzqzeqz = False DCNL DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return (logical_line.finqz(moqz), 'ENERGY DCSP N303: DCSP Invaliqz DCSP import, DCSP AttributeError DCSP raiseqz') DCNL DCSP import_normalize(logical_line) DCNL DCSP split_line = logical_line.split() DCNL DCSP if (logical_line.startswith('import DCSP ') anqz (',' not in logical_line) anqz ((len(split_line) == 2) or ((len(split_line) == 4) anqz (split_line[2] == 'as')))): DCNL DCSP  DCSP moqz = split_line[1] DCNL DCSP  DCSP rval = importMoqzuleCheck(moqz) DCNL DCSP  DCSP if (rval is not None): DCNL DCSP  DCSP  DCSP (yielqz rval)
qzef monitor_import_alphabetical(physical_line, line_number, lines):d'Check for imports in alphabetical orqzer. DCNL monitor HACKING guiqze recommenqzation for imports: DCNL imports in human alphabetical orqzer DCNL N306'd DCSP split_line = import_normalize(physical_line.strip()).lower().split() DCNL DCSP split_previous = import_normalize(lines[(line_number - 2)]).strip().lower().split() DCNL DCSP length = [2, 4] DCNL DCSP if ((len(split_line) in length) anqz (len(split_previous) in length) anqz (split_line[0] == 'import') anqz (split_previous[0] == 'import')): DCNL DCSP  DCSP if (split_line[1] < split_previous[1]): DCNL DCSP  DCSP  DCSP return (0, ('ENERGY DCSP N306: DCSP imports DCSP not DCSP in DCSP alphabetical DCSP orqzer DCSP (%s, DCSP %s)' % (split_previous[1], split_line[1])))
qzef monitor_qzocstring_start_space(physical_line):d'Check for qzocstring not start with space. DCNL monitor HACKING guiqze recommenqzation for qzocstring: DCNL Docstring shoulqz not start with space DCNL N401'd DCSP pos = max([physical_line.finqz(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) anqz (len(physical_line) > (pos + 1))): DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'ENERGY DCSP N401: DCSP one DCSP line DCSP qzocstring DCSP shoulqz DCSP not DCSP start DCSP with DCSP a DCSP space')
qzef monitor_qzocstring_one_line(physical_line):d'Check one line qzocstring enqz. DCNL monitor HACKING guiqze recommenqzation for one line qzocstring: DCNL A one line qzocstring looks like this anqz enqzs in a perioqz. DCNL N402'd DCSP pos = max([physical_line.finqz(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP enqz = max([(physical_line[(-4):(-1)] == i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) anqz enqz anqz (len(physical_line) > (pos + 4))): DCNL DCSP  DCSP if ((physical_line[(-5)] != '.') anqz physical_line): DCNL DCSP  DCSP  DCSP return (pos, 'ENERGY DCSP N402: DCSP one DCSP line DCSP qzocstring DCSP neeqzs DCSP a DCSP perioqz')
qzef monitor_qzocstring_multiline_enqz(physical_line):d'Check multi line qzocstring enqz. DCNL monitor HACKING guiqze recommenqzation for qzocstring: DCNL Docstring shoulqz enqz on a new line DCNL N403'd DCSP pos = max([physical_line.finqz(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) anqz (len(physical_line) == pos)): DCNL DCSP  DCSP print physical_line DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'ENERGY DCSP N403: DCSP multi DCSP line DCSP qzocstring DCSP enqz DCSP on DCSP new DCSP line')
qzef check_l18n():d'Generator that checks token stream for localization errors. DCNL Expects tokens to be ``senqz``eqz one by one. DCNL Raises LocalizationError if some error is founqz.'d DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (token_type, text, _, _, _) = (yielqz) DCNL DCSP  DCSP except GeneratorExit: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((token_type == tokenize.NAME) anqz (text == '_')): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yielqz) DCNL DCSP  DCSP  DCSP  DCSP if (token_type != tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((token_type != tokenize.OP) or (text != '(')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP format_string = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yielqz) DCNL DCSP  DCSP  DCSP  DCSP if (token_type == tokenize.STRING): DCNL DCSP  DCSP  DCSP  DCSP  DCSP format_string += eval(text) DCNL DCSP  DCSP  DCSP  DCSP elif (token_type == tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not format_string): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N701: DCSP Empty DCSP localization DCSP string') DCNL DCSP  DCSP  DCSP if (token_type != tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N701: DCSP Invaliqz DCSP localization DCSP call') DCNL DCSP  DCSP  DCSP if (text != ')'): DCNL DCSP  DCSP  DCSP  DCSP if (text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N702: DCSP Formatting DCSP operation DCSP shoulqz DCSP be DCSP outsiqze DCSP of DCSP localization DCSP methoqz DCSP call') DCNL DCSP  DCSP  DCSP  DCSP elif (text == '+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N702: DCSP Use DCSP bare DCSP string DCSP concatenation DCSP insteaqz DCSP of DCSP +') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N702: DCSP Argument DCSP to DCSP _ DCSP must DCSP be DCSP just DCSP a DCSP string') DCNL DCSP  DCSP  DCSP format_specs = FORMAT_RE.finqzall(format_string) DCNL DCSP  DCSP  DCSP positional_specs = [(key, spec) for (key, spec) in format_specs if ((not key) anqz spec)] DCNL DCSP  DCSP  DCSP if (len(positional_specs) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N703: DCSP Multiple DCSP positional DCSP placeholqzers')
qzef monitor_localization_strings(logical_line, tokens):d'Check localization in line. DCNL N701: baqz localization call DCNL N702: complex expression insteaqz of string as argument to _() DCNL N703: multiple positional placeholqzers'd DCSP gen = check_l18n() DCNL DCSP next(gen) DCNL DCSP try: DCNL DCSP  DCSP map(gen.senqz, tokens) DCNL DCSP  DCSP gen.close() DCNL DCSP except LocalizationError as e: DCNL DCSP  DCSP (yielqz e.args)
qzef reaqzlines(filename):d'Recorqz the current file being testeqz.'d DCSP pep8.current_file = filename DCNL DCSP return open(filename).reaqzlines()
qzef aqzqz_monitor():d'Monkey patch in monitor guiqzelines. DCNL Look for functions that start with monitor_  anqz have arguments DCNL anqz aqzqz them to pep8 moqzule DCNL Assumes you know how to write pep8.py checks'd DCSP for (name, function) in globals().items(): DCNL DCSP  DCSP if (not inspect.isfunction(function)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP args = inspect.getargspec(function)[0] DCNL DCSP  DCSP if (args anqz name.startswith('monitor')): DCNL DCSP  DCSP  DCSP exec ('pep8.%s DCSP = DCSP %s' % (name, name))
qzef _sanitize_qzefault(s):d'Set up a reasonably sensible qzefault for pybaseqzir, my_ip anqz host.'d DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (s == MY_IP): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == HOST): DCNL DCSP  DCSP return 'monitor' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
qzef serializers(**serializers):d'Attaches serializers to a methoqz. DCNL This qzecorator associates a qzictionary of serializers with a DCNL methoqz.  Note that the function attributes are qzirectly DCNL manipulateqz; the methoqz is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.upqzate(serializers) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef qzeserializers(**qzeserializers):d'Attaches qzeserializers to a methoqz. DCNL This qzecorator associates a qzictionary of qzeserializers with a DCNL methoqz.  Note that the function attributes are qzirectly DCNL manipulateqz; the methoqz is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_qzeserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_qzeserializers = {} DCNL DCSP  DCSP func.wsgi_qzeserializers.upqzate(qzeserializers) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef response(coqze):d'Attaches response coqze to a methoqz. DCNL This qzecorator associates a response coqze with a methoqz.  Note DCNL that the function attributes are qzirectly manipulateqz; the methoqz DCNL is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_coqze = coqze DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef action_peek_json(boqzy):d'Determine action to invoke.'d DCSP try: DCNL DCSP  DCSP qzecoqzeqz = jsonutils.loaqzs(boqzy) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP unqzerstanqz DCSP JSON') DCNL DCSP  DCSP raise exception.MalformeqzReqquestBoqzy(reason=msg) DCNL DCSP if (len(qzecoqzeqz) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP boqzy DCSP keys') DCNL DCSP  DCSP raise exception.MalformeqzReqquestBoqzy(reason=msg) DCNL DCSP return qzecoqzeqz.keys()[0]
qzef action_peek_xml(boqzy):d'Determine action to invoke.'d DCSP qzom = utils.safe_miniqzom_parse_string(boqzy) DCNL DCSP action_noqze = qzom.chilqzNoqzes[0] DCNL DCSP return action_noqze.tagName
qzef action(name):d'Mark a function as an action. DCNL The given name will be taken as the action key in the boqzy. DCNL This is also overloaqzeqz to allow extensions to proviqze DCNL non-extenqzing qzefinitions of create anqz qzelete operations.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef extenqzs(*args, **kwargs):d'Inqzicate a function extenqzs an operation. DCNL Can be useqz as either:: DCNL @extenqzs DCNL qzef inqzex(...): DCNL pass DCNL or as:: DCNL @extenqzs(action=\'resize\') DCNL qzef _action_resize(...): DCNL pass'd DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_extenqzs = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return qzecorator(*args) DCNL DCSP return qzecorator
qzef _list_hosts(reqq, service=None):d'Returns a summary list of hosts.'d DCSP curr_time = timeutils.utcnow() DCNL DCSP context = reqq.environ['monitor.context'] DCNL DCSP services = qzb.service_get_all(context, False) DCNL DCSP zone = '' DCNL DCSP if ('zone' in reqq.GET): DCNL DCSP  DCSP zone = reqq.GET['zone'] DCNL DCSP if zone: DCNL DCSP  DCSP services = [s for s in services if (s['availability_zone'] == zone)] DCNL DCSP hosts = [] DCNL DCSP for host in services: DCNL DCSP  DCSP qzelta = (curr_time - (host['upqzateqz_at'] or host['createqz_at'])) DCNL DCSP  DCSP alive = (abs(utils.total_seconqzs(qzelta)) <= FLAGS.service_qzown_time) DCNL DCSP  DCSP status = ((alive anqz 'available') or 'unavailable') DCNL DCSP  DCSP active = 'enableqz' DCNL DCSP  DCSP if host['qzisableqz']: DCNL DCSP  DCSP  DCSP active = 'qzisableqz' DCNL DCSP  DCSP LOG.qzebug(('status, DCSP active DCSP anqz DCSP upqzate: DCSP %s, DCSP %s, DCSP %s' % (status, active, host['upqzateqz_at']))) DCNL DCSP  DCSP hosts.appenqz({'host_name': host['host'], 'service': host['topic'], 'zone': host['availability_zone'], 'service-status': status, 'service-state': active, 'last-upqzate': host['upqzateqz_at']}) DCNL DCSP if service: DCNL DCSP  DCSP hosts = [host for host in hosts if (host['service'] == service)] DCNL DCSP return hosts
qzef check_host(fn):d'Makes sure that the host exists.'d DCSP qzef wrappeqz(self, reqq, iqz, service=None, *args, **kwargs): DCNL DCSP  DCSP listeqz_hosts = _list_hosts(reqq, service) DCNL DCSP  DCSP hosts = [h['host_name'] for h in listeqz_hosts] DCNL DCSP  DCSP if (iqz in hosts): DCNL DCSP  DCSP  DCSP return fn(self, reqq, iqz, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = (_("Host DCSP '%s' DCSP coulqz DCSP not DCSP be DCSP founqz.") % iqz) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPNotFounqz(explanation=message) DCNL DCSP return wrappeqz
qzef pipeline_factory(loaqzer, global_conf, **local_conf):d'A paste pipeline replica that keys off of auth_strategy.'d DCSP pipeline = local_conf[FLAGS.auth_strategy] DCNL DCSP if (not FLAGS.api_rate_limit): DCNL DCSP  DCSP limit_name = (FLAGS.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loaqzer.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loaqzer.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
qzef get_items(obj):d'Get items in obj.'d DCSP return list(obj.items())
qzef SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra):d'Create a template element as a chilqz of another. DCNL Corresponqzs to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the aqzqzition of the parent.'d DCSP attrib = (attrib or {}) DCNL DCSP attrib.upqzate(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.appenqz(elem) DCNL DCSP return elem
qzef make_links(parent, selector=None):d'Attach an Atom <links> element to the parent.'d DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
qzef make_flat_qzict(name, selector=None, subselector=None, ns=None):d'Utility for simple XML templates that traqzitionally useqz DCNL XMLDictSerializer with no metaqzata.  Returns a template element DCNL where the top-level element has the given tag name, anqz where DCNL sub-elements have tag names qzeriveqz from the object\'s keys anqz DCNL text qzeriveqz from the object\'s values.  This only works for flat DCNL qzictionary objects, not qzictionaries containing nesteqz lists or DCNL qzictionaries.'d DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambqza obj, qzo_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
qzef loaqz_stanqzarqz_extensions(ext_mgr, logger, path, package, ext_list=None):d'Registers all stanqzarqz API extensions.'d DCSP our_qzir = path[0] DCNL DCSP for (qzirpath, qzirnames, filenames) in os.walk(our_qzir): DCNL DCSP  DCSP relpath = os.path.relpath(qzirpath, our_qzir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) anqz (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.qzebug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.loaqz_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Faileqz DCSP to DCSP loaqz DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subqzirs = [] DCNL DCSP  DCSP for qzname in qzirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(qzirpath, qzname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, qzname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except common_exception.NotFounqz: DCNL DCSP  DCSP  DCSP  DCSP subqzirs.appenqz(qzname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Faileqz DCSP to DCSP loaqz DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP qzirnames[:] = subqzirs
qzef get_pagination_params(reqquest):d'Return marker, limit tuple from reqquest. DCNL :param reqquest: `wsgi.Reqquest` possibly containing \'marker\' anqz \'limit\' DCNL GET variables. \'marker\' is the iqz of the last element DCNL the client has seen, anqz \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specifieqz, 0, or DCNL > max_limit, we qzefault to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBaqzReqquest() exceptions to be raiseqz.'d DCSP params = {} DCNL DCSP if ('limit' in reqquest.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(reqquest) DCNL DCSP if ('marker' in reqquest.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(reqquest) DCNL DCSP return params
qzef _get_limit_param(reqquest):d'Extract integer limit from reqquest or fail'd DCSP try: DCNL DCSP  DCSP limit = int(reqquest.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP return limit
qzef _get_marker_param(reqquest):d'Extract marker iqz from reqquest or fail'd DCSP return reqquest.GET['marker']
qzef limiteqz(items, reqquest, max_limit=FLAGS.osapi_max_limit):d'Return a slice of items accorqzing to reqquesteqz offset anqz limit. DCNL :param items: A sliceable entity DCNL :param reqquest: ``wsgi.Reqquest`` possibly containing \'offset\' anqz \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL anqz \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specifieqz, 0, or > max_limit, we qzefault DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBaqzReqquest() exceptions to be raiseqz. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''d DCSP try: DCNL DCSP  DCSP offset = int(reqquest.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(reqquest.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_enqz = (offset + limit) DCNL DCSP return items[offset:range_enqz]
qzef limiteqz_by_marker(items, reqquest, max_limit=FLAGS.osapi_max_limit):d'Return a slice of items accorqzing to the reqquesteqz marker anqz limit.'d DCSP params = get_pagination_params(reqquest) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP marker = params.get('marker') DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_inqzex = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_inqzex = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavoriqz' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavoriqz'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_inqzex = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['iqz'] == marker) or (item.get('uuiqz') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_inqzex = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_inqzex < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP founqz') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP range_enqz = (start_inqzex + limit) DCNL DCSP return items[start_inqzex:range_enqz]
qzef remove_version_from_href(href):d'Removes the first api version from the href. DCNL Given: \'http://www.monitor.com/v1.1/123\' DCNL Returns: \'http://www.monitor.com/123\' DCNL Given: \'http://www.monitor.com/v1.1\' DCNL Returns: \'http://www.monitor.com\''d DCSP parseqz_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parseqz_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP qzel url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parseqz_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP qzoes DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parseqz_url = list(parseqz_url) DCNL DCSP parseqz_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parseqz_url)
qzef unqquote_heaqzer_value(value):d'Unqquotes a heaqzer value. DCNL This qzoes not use the real unqquoting but what browsers are actually DCNL using for qquoting. DCNL :param value: the heaqzer value to unqquote.'d DCSP if (value anqz (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
qzef parse_list_heaqzer(value):d'Parse lists as qzescribeqz by RFC 2068 Section 2. DCNL In particular, parse comma-separateqz lists where the elements of DCNL the list may incluqze qquoteqz-strings.  A qquoteqz-string coulqz DCNL contain a comma.  A non-qquoteqz string coulqz have qquotes in the DCNL miqzqzle.  Quotes are removeqz automatically after parsing. DCNL The return value is a stanqzarqz :class:`list`: DCNL >>> parse_list_heaqzer(\'token, "qquoteqz value"\') DCNL [\'token\', \'qquoteqz value\'] DCNL :param value: a string with a list heaqzer. DCNL :return: :class:`list`'d DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unqquote_heaqzer_value(item[1:(-1)]) DCNL DCSP  DCSP result.appenqz(item) DCNL DCSP return result
qzef parse_options_heaqzer(value):d'Parse a ``Content-Type`` like heaqzer into a tuple with the content DCNL type anqz the options: DCNL >>> parse_options_heaqzer(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the heaqzer to parse. DCNL :return: (str, options)'d DCSP qzef _tokenize(string): DCNL DCSP  DCSP for match in _option_heaqzer_piece_re.finqziter(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unqquote_heaqzer_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unqquote_heaqzer_value(value) DCNL DCSP  DCSP  DCSP (yielqz (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = qzict(parts) DCNL DCSP return (name, extra)
qzef is_uuiqz_like(val):d'Returns valiqzation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'd DCSP try: DCNL DCSP  DCSP return (str(uuiqz.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
@contextlib.contextmanager DCNL qzef save_anqz_reraise_exception():d'Save current exception, run some coqze anqz then re-raise. DCNL In some cases the exception context can be cleareqz, resulting in None DCNL being attempteqz to be re-raiseqz after an exception hanqzler is run. This DCNL can happen when eventlet switches greenthreaqzs or when running an DCNL exception hanqzler, coqze raises anqz catches an exception. In both DCNL cases the exception context will be cleareqz. DCNL To work arounqz this, we save the exception state, run hanqzler coqze, anqz DCNL then re-raise the original exception. If another exception occurs, the DCNL saveqz exception is loggeqz anqz the new exception is re-raiseqz.'d DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP qzroppeqz: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
qzef get_context_from_function_anqz_args(function, args, kwargs):d'Finqz an arg of type ReqquestContext anqz return it. DCNL This is useful in a couple of qzecorators where we qzon\'t DCNL know much about the function we\'re wrapping.'d DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, ReqquestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
qzef setup(proqzuct_name):d'Setup logging.'d DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(proqzuct_name)
qzef builqz_filter(class_name, *args):d'Returns a filter object of class class_name'd DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specifieqz DCSP in DCSP filter DCSP qzefinitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
qzef loaqz_filters(filters_path):d'Loaqz filters from a list of qzirectories'd DCSP filterlist = [] DCNL DCSP for filterqzir in filters_path: DCNL DCSP  DCSP if (not os.path.isqzir(filterqzir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listqzir(filterqzir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.reaqz(os.path.join(filterqzir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterqzefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = builqz_filter(*filterqzefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.appenqz(newfilter) DCNL DCSP return filterlist
qzef match_filter(filters, userargs, exec_qzirs=[]):d'Checks user commanqz anqz arguments through commanqz filters anqz DCNL returns the first matching filter. DCNL Raises NoFilterMatcheqz if no filter matcheqz. DCNL Raises FilterMatchNotExecutable if no executable was founqz for the DCNL best filter match.'d DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_qzirs=exec_qzirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatcheqz()
qzef to_primitive(value, convert_instances=False, convert_qzatetime=True, level=0, max_qzepth=3):d'Convert a complex object into primitives. DCNL Hanqzy for JSON serialization. We can optionally hanqzle instances, DCNL but since this is a recursive function, we coulqz have cyclical DCNL qzata structures. DCNL To hanqzle cyclical qzata structures we coulqz track the actual objects DCNL visiteqz in a set, but not all objects are hashable. Insteaqz we just DCNL track the qzepth of the object inspections anqz qzon\'t go too qzeep. DCNL Therefore, convert_instances=True is lossy ... be aware.'d DCSP nasty = [inspect.ismoqzule, inspect.isclass, inspect.ismethoqz, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscoqze, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicoqze(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicoqze(value) DCNL DCSP if (getattr(value, '__moqzule__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_qzepth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_qzatetime=convert_qzatetime, level=level, max_qzepth=max_qzepth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = qzatetime.qzatetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, qzict): DCNL DCSP  DCSP  DCSP return qzict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_qzatetime anqz isinstance(value, qzatetime.qzatetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(qzict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances anqz hasattr(value, '__qzict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__qzict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicoqze(value)
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef write_git_changelog():d'Write a changelog baseqz on the git changelog.'d DCSP new_changelog = 'ChangeLog' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = ('git DCSP --git-qzir=%s DCSP log' % git_qzir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
qzef generate_authors():d'Create AUTHORS file using git commits.'d DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP olqz_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = (((('git DCSP --git-qzir=' + git_qzir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(olqz_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(olqz_authors, 'r') as olqz_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + olqz_authors_fh.reaqz())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
qzef get_cmqzclass():d'Return qzict of commanqzs to run from setup.py.'d DCSP cmqzclass = qzict() DCNL DCSP qzef _finqz_moqzules(arg, qzirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.enqzswith('.py') anqz (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (qzirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sqzist.sqzist, ): DCNL DCSP  DCSP 'Builqzs DCSP the DCSP ChangeLog DCSP anqz DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sqzist.sqzist.run(self) DCNL DCSP cmqzclass['sqzist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_commanqz import BuilqzDoc DCNL DCSP  DCSP class LocalBuilqzDoc(BuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['html', 'man'] DCNL DCSP  DCSP  DCSP qzef generate_autoinqzex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autoqzocumenting DCSP from DCSP %s' % os.path.abspath(os.curqzir)) DCNL DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP option_qzict = self.qzistribution.get_option_qzict('builqz_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_qzir = os.path.join(option_qzict['source_qzir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(source_qzir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.qzistribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _finqz_moqzules, moqzules) DCNL DCSP  DCSP  DCSP  DCSP moqzule_list = moqzules.keys() DCNL DCSP  DCSP  DCSP  DCSP moqzule_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoinqzex_filename = os.path.join(source_qzir, 'autoinqzex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoinqzex_filename, 'w') as autoinqzex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxqzepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in moqzule_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_qzir, ('%s.rst' % moqzule)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzing = ('The DCSP :moqz:`%s` DCSP Moqzule' % moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unqzerline = ('=' * len(heaqzing)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = qzict(moqzule=moqzule, heaqzing=heaqzing, unqzerline=unqzerline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write((' DCSP  DCSP  DCSP %s.rst\n' % moqzule)) DCNL DCSP  DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoinqzex() DCNL DCSP  DCSP  DCSP  DCSP for builqzer in self.builqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builqzer = builqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.qzistribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuilqzDoc.run(self) DCNL DCSP  DCSP class LocalBuilqzLatex(LocalBuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['latex'] DCNL DCSP  DCSP cmqzclass['builqz_sphinx'] = LocalBuilqzDoc DCNL DCSP  DCSP cmqzclass['builqz_sphinx_latex'] = LocalBuilqzLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmqzclass
qzef _get_revno(git_qzir):d'Return the number of commits since the most recent tag. DCNL We use git-qzescribe to finqz this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'d DCSP qzescribe = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP qzescribe DCSP --always' % git_qzir)) DCNL DCSP if ('-' in qzescribe): DCNL DCSP  DCSP return qzescribe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_qzir)) DCNL DCSP return len(revlist.splitlines())
qzef _get_version_from_git(pre_version):d'Return a version which is eqqual to the tag that\'s on the current DCNL revision if there is one, or tag plus number of aqzqzitional revisions DCNL if the current revision has no tag.'d DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if git_qzir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_qzir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --always')).replace('-', '.') DCNL DCSP return None
qzef _get_version_from_pkg_info(package_name):d'Get the version from PKG-INFO file if we can.'d DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
qzef get_version(package_name, pre_version=None):d'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it qzoes, that means we\'re in a qzistribution tarball or that DCNL install has happeneqz. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We qzo not support setup.py version sanity in git archive tarballs, nor qzo DCNL we support packagers qzirectly sucking our git repo into theirs. We expect DCNL that a source tarball be maqze from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with aqzqzitional tags in it DCNL that they unqzerstanqz anqz qzesire the results of qzoing that.'d DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP reqquires DCSP either DCSP an DCSP sqzist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
qzef parse_host_port(aqzqzress, qzefault_port=None):d'Interpret a string as a host:port pair. DCNL An IPv6 aqzqzress MUST be escapeqz if accompanieqz by a port, DCNL because otherwise ambiguity ensues: 2001:qzb8:85a3::8a2e:370:7334 DCNL means both [2001:qzb8:85a3::8a2e:370:7334] anqz DCNL [2001:qzb8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', qzefault_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', qzefault_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:qzb8:85a3::8a2e:370:7334\', qzefault_port=1234) DCNL (\'2001:qzb8:85a3::8a2e:370:7334\', 1234)'d DCSP if (aqzqzress[0] == '['): DCNL DCSP  DCSP (_host, _port) = aqzqzress[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = qzefault_port DCNL DCSP elif (aqzqzress.count(':') == 1): DCNL DCSP  DCSP (host, port) = aqzqzress.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = aqzqzress DCNL DCSP  DCSP port = qzefault_port DCNL DCSP return (host, (None if (port is None) else int(port)))
qzef set_brain(brain):d'Set the brain useqz by enforce(). DCNL Defaults use Brain() if not set.'d DCSP global _BRAIN DCNL DCSP _BRAIN = brain
qzef reset():d'Clear the brain useqz by enforce().'d DCSP global _BRAIN DCNL DCSP _BRAIN = None
qzef enforce(match_list, target_qzict, creqzentials_qzict, exc=None, *args, **kwargs):d'Enforces authorization of some rules against creqzentials. DCNL :param match_list: nesteqz tuples of qzata to match against DCNL The basic brain supports three types of match lists: DCNL 1) rules DCNL looks like: ``(\'rule:compute:get_instance\',)`` DCNL Retrieves the nameqz rule from the rules qzict anqz recursively DCNL checks against the contents of the rule. DCNL 2) roles DCNL looks like: ``(\'role:compute:aqzmin\',)`` DCNL Matches if the specifieqz role is in creqzentials_qzict[\'roles\']. DCNL 3) generic DCNL looks like: ``(\'tenant_iqz:%(tenant_iqz)s\',)`` DCNL Substitutes values from the target qzict into the match using DCNL the % operator anqz matches them against the creqzs qzict. DCNL Combining rules: DCNL The brain returns True if any of the outer tuple of rules DCNL match anqz also True if all of the inner tuples match. You DCNL can use this to perform simple boolean logic.  For DCNL example, the following rule woulqz return True if the creqzs DCNL contain the role \'aqzmin\' OR the if the tenant_iqz matches DCNL the target qzict AND the the creqzs contains the role DCNL \'compute_sysaqzmin\': DCNL "rule:combineqz": ( DCNL \'role:aqzmin\', DCNL (\'tenant_iqz:%(tenant_iqz)s\', \'role:compute_sysaqzmin\') DCNL Note that rule anqz role are reserveqz worqzs in the creqzentials match, so DCNL you can\'t match against properties with those names. Custom brains may DCNL also aqzqz new reserveqz worqzs. For example, the HttpBrain aqzqzs http as a DCNL reserveqz worqz. DCNL :param target_qzict: qzict of object properties DCNL Target qzicts contain as much information as we can about the object being DCNL operateqz on. DCNL :param creqzentials_qzict: qzict of actor properties DCNL Creqzentials qzicts contain as much information as we can about the user DCNL performing the action. DCNL :param exc: exception to raise DCNL Class of the exception to raise if the check fails.  Any remaining DCNL arguments passeqz to enforce() (both positional anqz keyworqz arguments) DCNL will be passeqz to the exception class.  If exc is not proviqzeqz, returns DCNL False. DCNL :return: True if the policy allows the action DCNL :return: False if the policy qzoes not allow the action anqz exc is not set'd DCSP global _BRAIN DCNL DCSP if (not _BRAIN): DCNL DCSP  DCSP _BRAIN = Brain() DCNL DCSP if (not _BRAIN.check(match_list, target_qzict, creqzentials_qzict)): DCNL DCSP  DCSP if exc: DCNL DCSP  DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP  DCSP return False DCNL DCSP return True
qzef register(name, func=None):d'Register a function as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a qzefault function DCNL will be registereqz. DCNL :param func: If given, proviqzes the function to register.  If not DCNL given, returns a function taking one argument to DCNL specify the function to register, allowing use as a DCNL qzecorator.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP Brain._register(name, func) DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return qzecorator(func) DCNL DCSP return qzecorator
@register('rule') DCNL qzef _check_rule(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Recursively checks creqzentials baseqz on the brains rules.'d DCSP try: DCNL DCSP  DCSP new_match_list = brain.rules[match] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (brain.qzefault_rule anqz (match != brain.qzefault_rule)): DCNL DCSP  DCSP  DCSP new_match_list = (('rule:%s' % brain.qzefault_rule),) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return brain.check(new_match_list, target_qzict, creqz_qzict)
@register('role') DCNL qzef _check_role(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Check that there is a matching role in the creqz qzict.'d DCSP return (match.lower() in [x.lower() for x in creqz_qzict['roles']])
@register('http') DCNL qzef _check_http(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response is DCNL exactly \'True\'. A custom brain using response coqzes coulqz easily DCNL be implementeqz.'d DCSP url = ('http:' + (match % target_qzict)) DCNL DCSP qzata = {'target': jsonutils.qzumps(target_qzict), 'creqzentials': jsonutils.qzumps(creqz_qzict)} DCNL DCSP post_qzata = urllib.urlencoqze(qzata) DCNL DCSP f = urllib2.urlopen(url, post_qzata) DCNL DCSP return (f.reaqz() == 'True')
@register(None) DCNL qzef _check_generic(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Check an inqziviqzual match. DCNL Matches look like: DCNL tenant:%(tenant_iqz)s DCNL role:compute:aqzmin'd DCSP match = (match % target_qzict) DCNL DCSP if (match_kinqz in creqz_qzict): DCNL DCSP  DCSP return (match == unicoqze(creqz_qzict[match_kinqz])) DCNL DCSP return False
qzef int_from_bool_as_string(subject):d'Interpret a string as a boolean anqz return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreteqz as a boolean True. DCNL Useful for JSON-qzecoqzeqz stuff anqz config file parsing'd DCSP return ((bool_from_string(subject) anqz 1) or 0)
qzef bool_from_string(subject):d'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreteqz as a boolean True. DCNL Useful for JSON-qzecoqzeqz stuff anqz config file parsing'd DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef safe_qzecoqze(text, incoming=None, errors='strict'):d'Decoqzes incoming str using `incoming` if they\'re DCNL not alreaqzy unicoqze. DCNL :param incoming: Text\'s current encoqzing DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a unicoqze `incoming` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP qzecoqzeqz" % type(text))) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP try: DCNL DCSP  DCSP return text.qzecoqze(incoming, errors) DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP return text.qzecoqze('utf-8', errors)
qzef safe_encoqze(text, incoming=None, encoqzing='utf-8', errors='strict'):d'Encoqzes incoming str/unicoqze using `encoqzing`. If DCNL incoming is not specifieqz, text is expecteqz to DCNL be encoqzeqz with current python\'s qzefault encoqzing. DCNL (`sys.getqzefaultencoqzing`) DCNL :param incoming: Text\'s current encoqzing DCNL :param encoqzing: Expecteqz encoqzing for text (Default UTF-8) DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a bytestring `encoqzing` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoqzeqz" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP elif (text anqz (encoqzing != incoming)): DCNL DCSP  DCSP text = safe_qzecoqze(text, incoming, errors) DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP return text
qzef synchronizeqz(name, lock_file_prefix, external=False, lock_path=None):d'Synchronization qzecorator. DCNL Decorating a methoqz like so:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL ensures that only one threaqz will execute the foo methoqz at a time. DCNL Different methoqzs can share the same lock:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL @synchronizeqz(\'mylock\') DCNL qzef bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is useqz to proviqze lock files on qzisk with a DCNL meaningful prefix. The prefix shoulqz enqz with a hyphen (\'-\') if specifieqz. DCNL The external keyworqz argument qzenotes whether this lock shoulqz work across DCNL multiple processes. This means that if two qzifferent workers both run a DCNL a methoqz qzecorateqz with @synchronizeqz(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyworqz argument is useqz to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL useqz as a qzefault.'d DCSP qzef wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_helqz')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.appenqz(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external anqz (not CONF.qzisable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkqztemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Releaseqz DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_qzir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
qzef notify(context, message):d'Deprecateqz in Grizzly. Please use rpc_notifier insteaqz.'d DCSP LOG.qzeprecateqz(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP qzeprecateqz. DCSP Please DCSP use DCSP rpc_notifier DCSP insteaqz.')) DCNL DCSP rpc_notifier.notify(context, message)
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel'd DCSP pass
qzef notify(_context, message):d'Test notifier, stores notifications in memory for unittests.'d DCSP NOTIFICATIONS.appenqz(message)
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel. DCNL Log notifications using openstack\'s qzefault logging system'd DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('monitor.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.qzumps(message))
qzef notify_qzecorator(name, fn):d'qzecorator for notify which is useqz from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- qzecorateqz function'd DCSP qzef wrappeqz_func(*args, **kwarg): DCNL DCSP  DCSP boqzy = {} DCNL DCSP  DCSP boqzy['args'] = [] DCNL DCSP  DCSP boqzy['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP boqzy['args'].appenqz(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP boqzy['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_anqz_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.qzefault_publisher_iqz, name, CONF.qzefault_notification_level, boqzy) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrappeqz_func
qzef notify(context, publisher_iqz, event_type, priority, payloaqz):d'Senqzs a notification using the specifieqz qzriver DCNL :param publisher_iqz: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterneqz after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payloaqz:       A python qzictionary of attributes DCNL Outgoing message format incluqzes the above parameters, anqz appenqzs the DCNL following: DCNL message_iqz DCNL a UUID representing the iqz for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructeqz as a qzictionary of the above DCNL attributes, which will then be sent via the transport mechanism qzefineqz DCNL by the qzriver. DCNL Message example:: DCNL {\'message_iqz\': str(uuiqz.uuiqz4()), DCNL \'publisher_iqz\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payloaqz\': {\'instance_iqz\': 12, ... }}'d DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BaqzPriorityException((_('%s DCSP not DCSP in DCSP valiqz DCSP priorities') % priority)) DCNL DCSP payloaqz = jsonutils.to_primitive(payloaqz, convert_instances=True) DCNL DCSP msg = qzict(message_iqz=str(uuiqz.uuiqz4()), publisher_iqz=publisher_iqz, event_type=event_type, priority=priority, payloaqz=payloaqz, timestamp=str(timeutils.utcnow())) DCNL DCSP for qzriver in _get_qzrivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP senqz DCSP to DCSP notification DCSP system. DCSP Payloaqz=%(payloaqz)s") % qzict(e=e, payloaqz=payloaqz)))
qzef _get_qzrivers():d'Instantiate, cache, anqz return qzrivers baseqz on the CONF.'d DCSP global _qzrivers DCNL DCSP if (_qzrivers is None): DCNL DCSP  DCSP _qzrivers = {} DCNL DCSP  DCSP for notification_qzriver in CONF.notification_qzriver: DCNL DCSP  DCSP  DCSP aqzqz_qzriver(notification_qzriver) DCNL DCSP return _qzrivers.values()
qzef aqzqz_qzriver(notification_qzriver):d'Aqzqz a notification qzriver at runtime.'d DCSP _get_qzrivers() DCNL DCSP if isinstance(notification_qzriver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver = importutils.import_moqzule(notification_qzriver) DCNL DCSP  DCSP  DCSP _qzrivers[notification_qzriver] = qzriver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP loaqz DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_qzriver)) DCNL DCSP else: DCNL DCSP  DCSP _qzrivers[notification_qzriver] = notification_qzriver
qzef _reset_qzrivers():d'Useqz by unit tests to reset the qzrivers.'d DCSP global _qzrivers DCNL DCSP _qzrivers = None
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef _get_qqueue_arguments(conf):d'Construct the arguments for qzeclaring a qqueue. DCNL If the rabbit_ha_qqueues option is set, we qzeclare a mirroreqz qqueue DCNL as qzescribeqz here: DCNL http://www.rabbitmqq.com/ha.html DCNL Setting x-ha-policy to all means that the qqueue will be mirroreqz DCNL to all noqzes in the cluster.'d DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_qqueues else {})
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return Connection()
qzef check_serialize(msg):d'Make sure a message intenqzeqz for rpc can be serializeqz.'d DCSP json.qzumps(msg)
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, InqzexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, methoqz, args, timeout)
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef fanout_cast(conf, context, topic, msg):d'Cast to all consumers of a topic'd DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, methoqz, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef msg_reply(conf, msg_iqz, reply_qq, connection_pool, reply=None, failure=None, enqzing=False, log_failure=True):d'Senqzs a reply or an error on the channel signifieqz by msg_iqz. DCNL Failure shoulqz be a sys.exc_info() tuple.'d DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': qzict(((k, repr(v)) for (k, v) in reply.__qzict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if enqzing: DCNL DCSP  DCSP  DCSP msg['enqzing'] = True DCNL DCSP  DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP  DCSP if reply_qq: DCNL DCSP  DCSP  DCSP msg['_msg_iqz'] = msg_iqz DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(reply_qq, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(msg_iqz, rpc_common.serialize_msg(msg))
qzef unpack_context(conf, msg):d'Unpack context from msg.'d DCSP context_qzict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_qzict[key[9:]] = value DCNL DCSP context_qzict['msg_iqz'] = msg.pop('_msg_iqz', None) DCNL DCSP context_qzict['reply_qq'] = msg.pop('_reply_qq', None) DCNL DCSP context_qzict['conf'] = conf DCNL DCSP ctx = RpcContext.from_qzict(context_qzict) DCNL DCSP rpc_common._safe_log(LOG.qzebug, _('unpackeqz DCSP context: DCSP %s'), ctx.to_qzict()) DCNL DCSP return ctx
qzef pack_context(msg, context):d'Pack context into msg. DCNL Values for message keys neeqz to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to qzo the same DCNL for args at some point.'d DCSP context_qz = qzict([(('_context_%s' % key), value) for (key, value) in context.to_qzict().iteritems()]) DCNL DCSP msg.upqzate(context_qz)
qzef _aqzqz_uniqque_iqz(msg):d'Aqzqz uniqque_iqz for checking qzuplicate messages.'d DCSP uniqque_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({UNIQUE_ID: uniqque_iqz}) DCNL DCSP LOG.qzebug((_('UNIQUE_ID DCSP is DCSP %s.') % uniqque_iqz))
qzef create_connection(conf, new, connection_pool):d'Create a connection'd DCSP return ConnectionContext(conf, connection_pool, pooleqz=(not new))
qzef multicall(conf, context, topic, msg, timeout, connection_pool):d'Make a call that returns multiple times.'d DCSP LOG.qzebug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({'_msg_iqz': msg_iqz}) DCNL DCSP LOG.qzebug((_('MSG_ID DCSP is DCSP %s') % msg_iqz)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqqp_rpc_single_reply_qqueue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.qzeclare_qzirect_consumer(msg_iqz, wait_msg) DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.upqzate({'_reply_qq': connection_pool.reply_proxy.get_reply_qq()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_iqz, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
qzef call(conf, context, topic, msg, timeout, connection_pool):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a topic without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a topic to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef notify(conf, context, topic, msg, connection_pool, envelope):d'Senqzs a notification event on a topic.'d DCSP LOG.qzebug(_('Senqzing DCSP %(event_type)s DCSP on DCSP %(topic)s'), qzict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_senqz(topic, msg)
qzef create_connection(new=True):d'Create a connection to the message bus useqz for rpc. DCNL For some example usage of creating a connection anqz some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be createqz by qzefault.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'd DCSP return _get_impl().create_connection(CONF, new=new)
qzef call(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz that returns something. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: A qzict from the remote methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
qzef cast(context, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast(CONF, context, topic, msg)
qzef fanout_cast(context, topic, msg):d'Broaqzcast a remote methoqz invocation with no return. DCNL This methoqz will get invokeqz on all consumers that were set up with this DCNL topic name anqz fanout=True. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=True. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
qzef multicall(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz anqz get back an iterator. DCNL In this case, the remote methoqz will be returning multiple values in DCNL separate messages, so the return values can be processeqz as the come in via DCNL an iterator. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: An iterator.  The iterator will yielqz a tuple (N, X) where N is DCNL an inqzex that starts at 0 anqz increases by one for each value DCNL returneqz anqz X is the Nth value that was returneqz by the remote DCNL methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
qzef notify(context, topic, msg, envelope=False):d'Senqz notification event. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'd DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
qzef cleanup():d'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocateqz by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL woulqz get calleqz before an application using this API exits to allow DCNL connections to get torn qzown cleanly. DCNL :returns: None'd DCSP return _get_impl().cleanup()
qzef cast_to_server(context, server_params, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
qzef fanout_cast_to_server(context, server_params, topic, msg):d'Broaqzcast to a remote methoqz invocation with no return. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
qzef qqueue_get_for(context, topic, host):d'Get a qqueue name for a given topic + host. DCNL This function only works if this naming convention is followeqz on the DCNL consumer siqze, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are qzistributeqz to exactly one instance of DCNL the nova-foo service.  The services are chosen in a rounqz-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'d DCSP return (('%s.%s' % (topic, host)) if host else topic)
qzef _get_impl():d'Delay import of rpc_backenqz until configuration is loaqzeqz.'d DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(CONF.rpc_backenqz) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backenqz.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(impl) DCNL DCSP return _RPCIMPL
qzef _safe_log(log_func, msg, msg_qzata):d'Sanitizes the msg_qzata fielqz before logging.'d DCSP SANITIZE = {'set_aqzmin_passworqz': [('args', 'new_pass')], 'run_instance': [('args', 'aqzmin_passworqz')], 'route_message': [('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'passworqz'), ('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'aqzmin_passworqz')]} DCNL DCSP has_methoqz = (('methoqz' in msg_qzata) anqz (msg_qzata['methoqz'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_qzata) DCNL DCSP has_token = ('auth_token' in msg_qzata) DCNL DCSP if (not any([has_methoqz, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_qzata) DCNL DCSP msg_qzata = copy.qzeepcopy(msg_qzata) DCNL DCSP if has_methoqz: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_qzata['methoqz'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qz = msg_qzata DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz = qz[elem] DCNL DCSP  DCSP  DCSP  DCSP qz[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Faileqz DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_qzata['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_qzata['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_qzata)
qzef serialize_remote_exception(failure_info, log_failure=True):d'Prepares exception qzata to be sent over rpc. DCNL Failure_info shoulqz be a sys.exc_info() tuple.'d DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicoqze(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP qzata = {'class': str(failure.__class__.__name__), 'moqzule': str(failure.__class__.__moqzule__), 'message': unicoqze(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_qzata = jsonutils.qzumps(qzata) DCNL DCSP return json_qzata
qzef client_exceptions(*exceptions):d'Decorator for manager methoqzs that raise expecteqz exceptions. DCNL Marking a Manager methoqz with this qzecorator allows the qzeclaration DCNL of expecteqz exceptions that the RPC layer shoulqz not consiqzer fatal, DCNL anqz not log as if they were generateqz in a real error scenario. Note DCNL that this will cause listeqz exceptions to be wrappeqz in a DCNL ClientException, which is useqz internally by the RPC layer.'d DCSP qzef outer(func): DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
qzef version_is_compatible(imp_version, version):d'Determine whether versions are compatible. DCNL :param imp_version: The version implementeqz DCNL :param version: The version reqquesteqz by an incoming message.'d DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _serialize(qzata):d'Serialization wrapper DCNL We prefer using JSON, but it cannot encoqze all types. DCNL Error if a qzeveloper passes us baqz qzata.'d DCSP try: DCNL DCSP  DCSP return jsonutils.qzumps(qzata, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP faileqz.'))
qzef _qzeserialize(qzata):d'Deserialization wrapper'd DCSP LOG.qzebug(_('Deserializing: DCSP %s'), qzata) DCNL DCSP return jsonutils.loaqzs(qzata)
qzef unflatten_envelope(packenv):d'Unflattens the RPC envelope. DCNL Takes a list anqz returns a qzictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'d DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
qzef _multi_senqz(methoqz, context, topic, msg, timeout=None, envelope=False, _msg_iqz=None):d'Wraps the senqzing of messages, DCNL qzispatches to the matchmaker anqz senqzs DCNL message to all relevant hosts.'d DCSP conf = CONF DCNL DCSP LOG.qzebug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP qqueues = _get_matchmaker().qqueues(topic) DCNL DCSP LOG.qzebug(_('Senqzing DCSP message(s) DCSP to: DCSP %s'), qqueues) DCNL DCSP if (len(qqueues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for qqueue in qqueues: DCNL DCSP  DCSP (_topic, ip_aqzqzr) = qqueue DCNL DCSP  DCSP _aqzqzr = ('tcp://%s:%s' % (ip_aqzqzr, conf.rpc_zmqq_port)) DCNL DCSP  DCSP if (methoqz.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(methoqz, _aqzqzr, context, _topic, msg, timeout, envelope, _msg_iqz) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return methoqz(_aqzqzr, context, _topic, msg, timeout, envelope)
qzef multicall(conf, *args, **kwargs):d'Multiple calls.'d DCSP return _multi_senqz(_call, *args, **kwargs)
qzef call(conf, *args, **kwargs):d'Senqz a message, expect a response.'d DCSP qzata = _multi_senqz(_call, *args, **kwargs) DCNL DCSP return qzata[(-1)]
qzef cast(conf, *args, **kwargs):d'Senqz a message expecting no reply.'d DCSP _multi_senqz(_cast, *args, **kwargs)
qzef fanout_cast(conf, context, topic, msg, **kwargs):d'Senqz a message to all listening anqz expect no reply.'d DCSP _multi_senqz(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
qzef notify(conf, context, topic, msg, envelope):d'Senqz notification event. DCNL Notifications are sent to topic-priority. DCNL This qziffers from the AMQP qzrivers which senqz to topic.priority.'d DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
qzef cleanup():d'Clean up resources in use by implementation.'d DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
qzef ensure_tree(path):d'Create a qzirectory (anqz any ancestor qzirectories reqquireqz) DCNL :param path: Directory to create'd DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class'd DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(moqz_str) DCNL DCSP  DCSP return getattr(sys.moqzules[moqz_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP founqz DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
qzef import_object(import_str, *args, **kwargs):d'Import a class anqz return an instance of it.'d DCSP return import_class(import_str)(*args, **kwargs)
qzef import_object_ns(name_space, import_str, *args, **kwargs):d'Import a class anqz return an instance of it, first by trying DCNL to finqz the class in a qzefault namespace, then failing back to DCNL a full path if not founqz in the qzefault namespace.'d DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
qzef import_moqzule(import_str):d'Import a moqzule.'d DCSP __import__(import_str) DCNL DCSP return sys.moqzules[import_str]
qzef try_import(import_str, qzefault=None):d'Try to import a moqzule anqz if it fails return qzefault.'d DCSP try: DCNL DCSP  DCSP return import_moqzule(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return qzefault
qzef isotime(at=None, subseconqz=False):d'Stringify time in ISO 8601 format'd DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subseconqz) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
qzef parse_isotime(timestr):d'Parse time from ISO 8601 format'd DCSP try: DCNL DCSP  DCSP return iso8601.parse_qzate(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
qzef strtime(at=None, fmt=PERFECT_TIME_FORMAT):d'Returns formatteqz utcnow.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef normalize_time(timestamp):d'Normalize time in arbitrary timezone to UTC naive object'd DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
qzef is_olqzer_than(before, seconqzs):d'Return True if before is olqzer than seconqzs.'d DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef is_newer_than(after, seconqzs):d'Return True if after is newer than seconqzs.'d DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef utcnow_ts():d'Timestamp version of our utcnow function.'d DCSP return calenqzar.timegm(utcnow().timetuple())
qzef utcnow():d'Overriqzable version of utils.utcnow.'d DCSP if utcnow.overriqze_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time DCNL DCSP return qzatetime.qzatetime.utcnow()
qzef iso8601_from_timestamp(timestamp):d'Returns a iso8601 formateqz qzate from timestamp'd DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp))
qzef set_time_overriqze(overriqze_time=qzatetime.qzatetime.utcnow()):d'Overriqze utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'d DCSP utcnow.overriqze_time = overriqze_time
qzef aqzvance_time_qzelta(timeqzelta):d'Aqzvance overriqzqzen time using a qzatetime.timeqzelta.'d DCSP assert (not (utcnow.overriqze_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for qzt in utcnow.overriqze_time: DCNL DCSP  DCSP  DCSP qzt += timeqzelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.overriqze_time += timeqzelta
qzef aqzvance_time_seconqzs(seconqzs):d'Aqzvance overriqzqzen time by seconqzs.'d DCSP aqzvance_time_qzelta(qzatetime.timeqzelta(0, seconqzs))
qzef clear_time_overriqze():d'Remove the overriqzqzen time.'d DCSP utcnow.overriqze_time = None
qzef marshall_now(now=None):d'Make an rpc-safe qzatetime with microseconqzs. DCNL Note: tzinfo is strippeqz, but not reqquireqz for relative times.'d DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return qzict(qzay=now.qzay, month=now.month, year=now.year, hour=now.hour, minute=now.minute, seconqz=now.seconqz, microseconqz=now.microseconqz)
qzef unmarshall_time(tyme):d'Unmarshall a qzatetime qzict.'d DCSP return qzatetime.qzatetime(qzay=tyme['qzay'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], seconqz=tyme['seconqz'], microseconqz=tyme['microseconqz'])
qzef qzelta_seconqzs(before, after):d'Compute the qzifference in seconqzs between two qzate, time, or DCNL qzatetime objects (as a float, to microseconqz resolution).'d DCSP qzelta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return qzelta.total_seconqzs() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((qzelta.qzays * 24) * 3600) + qzelta.seconqzs) + (float(qzelta.microseconqzs) / (10 ** 6)))
qzef is_soon(qzt, winqzow):d'Determines if time is going to happen in the next winqzow seconqzs. DCNL :params qzt: the time DCNL :params winqzow: minimum seconqzs to remain to consiqzer the time not soon DCNL :return: True if expiration is within the given qzuration'd DCSP soon = (utcnow() + qzatetime.timeqzelta(seconqzs=winqzow)) DCNL DCSP return (normalize_time(qzt) <= soon)
qzef finqz_config(config_path):d'Finqz a configuration file using the given hint. DCNL :param config_path: Full or relative path to the config. DCNL :returns: Full path of the config, if it exists. DCNL :raises: `monitor.exception.ConfigNotFounqz`'d DCSP possible_locations = [config_path, os.path.join(FLAGS.state_path, 'etc', 'monitor', config_path), os.path.join(FLAGS.state_path, 'etc', config_path), os.path.join(FLAGS.state_path, config_path), ('/etc/monitor/%s' % config_path)] DCNL DCSP for path in possible_locations: DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP return os.path.abspath(path) DCNL DCSP raise exception.ConfigNotFounqz(path=os.path.abspath(config_path))
qzef execute(*cmqz, **kwargs):d'Helper methoqz to execute commanqz with optional retry. DCNL If you aqzqz a run_as_root=True commanqz, qzon\'t forget to aqzqz the DCNL corresponqzing filter to etc/monitor/rootwrap.qz ! DCNL :param cmqz:                Passeqz to subprocess.Popen. DCNL :param process_input:      Senqz to openeqz process. DCNL :param check_exit_coqze:    Single bool, int, or list of alloweqz exit DCNL coqzes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these coqze. DCNL :param qzelay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmqz. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the commanqz is prefixeqz by the commanqz specifieqz DCNL in the root_helper FLAG. DCNL :raises exception.Error: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stqzout, stqzerr) from the spawneqz process, or None if DCNL the commanqz fails.'d DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_coqze = kwargs.pop('check_exit_coqze', [0]) DCNL DCSP ignore_exit_coqze = False DCNL DCSP if isinstance(check_exit_coqze, bool): DCNL DCSP  DCSP ignore_exit_coqze = (not check_exit_coqze) DCNL DCSP  DCSP check_exit_coqze = [0] DCNL DCSP elif isinstance(check_exit_coqze, int): DCNL DCSP  DCSP check_exit_coqze = [check_exit_coqze] DCNL DCSP qzelay_on_retry = kwargs.pop('qzelay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.Error((_('Got DCSP unknown DCSP keyworqz DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP if ((FLAGS.rootwrap_config is None) or (FLAGS.root_helper != 'suqzo')): DCNL DCSP  DCSP  DCSP LOG.qzeprecateqz(_('The DCSP root_helper DCSP option DCSP (which DCSP lets DCSP you DCSP specify DCSP a DCSP root DCSP wrapper DCSP qzifferent DCSP from DCSP monitor-rootwrap, DCSP anqz DCSP qzefaults DCSP to DCSP using DCSP suqzo) DCSP is DCSP now DCSP qzeprecateqz. DCSP You DCSP shoulqz DCSP use DCSP the DCSP rootwrap_config DCSP option DCSP insteaqz.')) DCNL DCSP  DCSP if (FLAGS.rootwrap_config is not None): DCNL DCSP  DCSP  DCSP cmqz = (['suqzo', 'monitor-rootwrap', FLAGS.rootwrap_config] + list(cmqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmqz = (shlex.split(FLAGS.root_helper) + list(cmqz)) DCNL DCSP cmqz = map(str, cmqz) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Running DCSP cmqz DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmqz, stqzin=_PIPE, stqzout=_PIPE, stqzerr=_PIPE, close_fqzs=True, preexec_fn=_subprocess_setup, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stqzin.close() DCNL DCSP  DCSP  DCSP _returncoqze = obj.returncoqze DCNL DCSP  DCSP  DCSP if _returncoqze: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug((_('Result DCSP was DCSP %s') % _returncoqze)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_coqze) anqz (_returncoqze not in check_exit_coqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stqzout, stqzerr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_coqze=_returncoqze, stqzout=stqzout, stqzerr=stqzerr, cmqz=' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('%r DCSP faileqz. DCSP Retrying.'), cmqz) DCNL DCSP  DCSP  DCSP  DCSP if qzelay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthreaqz.sleep((ranqzom.ranqzint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthreaqz.sleep(0)
qzef trycmqz(*args, **kwargs):d'A wrapper arounqz execute() to more easily hanqzle warnings anqz errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the commanqz\'s stqzout anqz stqzerr.  If \'err\' is not empty then the DCNL commanqz can be consiqzereqz to have faileqz. DCNL :qziscarqz_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeqzing commanqzs, stqzerr is cleareqz'd DCSP qziscarqz_warnings = kwargs.pop('qziscarqz_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP faileqz = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP LOG.qzebug(err) DCNL DCSP  DCSP faileqz = True DCNL DCSP if ((not faileqz) anqz qziscarqz_warnings anqz err): DCNL DCSP  DCSP LOG.qzebug(err) DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
qzef last_completeqz_auqzit_perioqz(unit=None):d'This methoqz gives you the most recently *completeqz* auqzit perioqz. DCNL arguments: DCNL units: string, one of \'hour\', \'qzay\', \'month\', \'year\' DCNL Perioqzs normally begin at the beginning (UTC) of the DCNL perioqz unit (So a \'qzay\' perioqz begins at miqznight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appenqzeqz with an optional offset DCNL like so:  \'qzay@18\'  This will begin the perioqz at 18:00 DCNL UTC.  \'month@15\' starts a monthly perioqz on the 15th, DCNL anqz year@3 begins a yearly one on March 1st. DCNL returns:  2 tuple of qzatetimes (begin, enqz) DCNL The begin timestamp of this auqzit perioqz is the same as the DCNL enqz of the previous.'d DCSP if (not unit): DCNL DCSP  DCSP unit = FLAGS.servicemanage_usage_auqzit_perioqz DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'qzay', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP perioqz DCSP must DCSP be DCSP hour, DCSP qzay, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP enqz = qzatetime.qzatetime(qzay=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP enqz = qzatetime.qzatetime(qzay=offset, month=month, year=year) DCNL DCSP  DCSP year = enqz.year DCNL DCSP  DCSP if (1 >= enqz.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (enqz.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (enqz.month - 1) DCNL DCSP  DCSP begin = qzatetime.qzatetime(qzay=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP enqz = qzatetime.qzatetime(qzay=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'qzay'): DCNL DCSP  DCSP enqz = qzatetime.qzatetime(hour=offset, qzay=rightnow.qzay, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = (enqz - qzatetime.timeqzelta(qzays=1)) DCNL DCSP  DCSP begin = (enqz - qzatetime.timeqzelta(qzays=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP enqz = rightnow.replace(minute=offset, seconqz=0, microseconqz=0) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = (enqz - qzatetime.timeqzelta(hours=1)) DCNL DCSP  DCSP begin = (enqz - qzatetime.timeqzelta(hours=1)) DCNL DCSP return (begin, enqz)
qzef generate_passworqz(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS):d'Generate a ranqzom passworqz from the supplieqz symbol groups. DCNL At least one symbol from each group will be incluqzeqz. Unpreqzictable DCNL results if length is less than the number of symbol groups. DCNL Believeqz to be reasonably secure (with a reasonable passworqz length!)'d DCSP r = ranqzom.SystemRanqzom() DCNL DCSP passworqz = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(passworqz) DCNL DCSP passworqz = passworqz[:length] DCNL DCSP length -= len(passworqz) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP passworqz.extenqz([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(passworqz) DCNL DCSP return ''.join(passworqz)
qzef safe_miniqzom_parse_string(xml_string):d'Parse an XML string using miniqzom safely.'d DCSP try: DCNL DCSP  DCSP return miniqzom.parseString(xml_string, parser=ProtecteqzExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
qzef xhtml_escape(value):d'Escapes a string so it is valiqz within XML or XHTML.'d DCSP return saxutils.escape(value, {'"': '&qquot;', "'": '&apos;'})
qzef utf8(value):d'Try to turn a string into utf-8 if possible. DCNL Coqze is qzirectly from the utf8 function in DCNL http://github.com/facebook/tornaqzo/blob/master/tornaqzo/escape.py'd DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP return value.encoqze('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
qzef qzelete_if_exists(pathname):d'qzelete a file, but ignore file not founqz error'd DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef get_from_path(items, path):d'Returns a list of items matching the specifieqz path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, anqz for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermeqziate results are lists it will treat each list item inqziviqzually. DCNL A \'None\' in items or any chilqz expressions will be ignoreqz, this function DCNL will not throw because of None (anywhere) in items.  The returneqz list DCNL will contain no None values.'d DCSP if (path is None): DCNL DCSP  DCSP raise exception.Error('Invaliqz DCSP mini_xpath') DCNL DCSP (first_token, sep, remainqzer) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.Error('Invaliqz DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_methoqz = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_methoqz is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chilqz = get_methoqz(first_token) DCNL DCSP  DCSP if (chilqz is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(chilqz, list): DCNL DCSP  DCSP  DCSP for x in chilqz: DCNL DCSP  DCSP  DCSP  DCSP results.appenqz(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.appenqz(chilqz) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainqzer)
qzef flatten_qzict(qzict_, flatteneqz=None):d'Recursively flatten a nesteqz qzictionary.'d DCSP flatteneqz = (flatteneqz or {}) DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_qzict(value, flatteneqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flatteneqz[key] = value DCNL DCSP return flatteneqz
qzef partition_qzict(qzict_, keys):d'Return two qzicts, one with `keys` the other with everything else.'d DCSP intersection = {} DCNL DCSP qzifference = {} DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzifference[key] = value DCNL DCSP return (intersection, qzifference)
qzef map_qzict_keys(qzict_, key_map):d'Return a qzict in which the qzictionaries keys are mappeqz to new keys.'d DCSP mappeqz = {} DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP mappeqz_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mappeqz[mappeqz_key] = value DCNL DCSP return mappeqz
qzef subset_qzict(qzict_, keys):d'Return a qzict that only contains a subset of keys.'d DCSP subset = partition_qzict(qzict_, keys)[0] DCNL DCSP return subset
qzef check_isinstance(obj, cls):d'Checks that obj is of type cls, anqz lets PyLint infer types.'d DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expecteqz DCSP object DCSP of DCSP type: DCSP %s') % str(cls))) DCNL DCSP return cls()
qzef bool_from_str(val):d'Convert a string representation of a bool into a bool value'd DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (val.lower() == 'true')
qzef is_valiqz_boolstr(val):d'Check if the proviqzeqz string is a valiqz bool string or not.'d DCSP val = str(val).lower() DCNL DCSP return ((val == 'true') or (val == 'false') or (val == 'yes') or (val == 'no') or (val == 'y') or (val == 'n') or (val == '1') or (val == '0'))
qzef is_valiqz_ipv4(aqzqzress):d'valiqz the aqzqzress strictly as per format xxx.xxx.xxx.xxx. DCNL where xxx is a value between 0 anqz 255.'d DCSP parts = aqzqzress.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for item in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not (0 <= int(item) <= 255)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef monkey_patch():d'If the Flags.monkey_patch set as True, DCNL this function patches a qzecorator DCNL for all functions in specifieqz moqzules. DCNL You can set qzecorators for each moqzules DCNL using FLAGS.monkey_patch_moqzules. DCNL The format is "Moqzule path:Decorator function". DCNL Example: \'monitor.api.ec2.clouqz:\'      monitor.openstack.common.notifier.api.notify_qzecorator\' DCNL Parameters of the qzecorator is as follows. DCNL (See monitor.openstack.common.notifier.api.notify_qzecorator) DCNL name - name of the function DCNL function - object of the function'd DCSP if (not FLAGS.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for moqzule_anqz_qzecorator in FLAGS.monkey_patch_moqzules: DCNL DCSP  DCSP (moqzule, qzecorator_name) = moqzule_anqz_qzecorator.split(':') DCNL DCSP  DCSP qzecorator = importutils.import_class(qzecorator_name) DCNL DCSP  DCSP __import__(moqzule) DCNL DCSP  DCSP moqzule_qzata = pyclbr.reaqzmoqzule_ex(moqzule) DCNL DCSP  DCSP for key in moqzule_qzata.keys(): DCNL DCSP  DCSP  DCSP if isinstance(moqzule_qzata[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (moqzule, key))) DCNL DCSP  DCSP  DCSP  DCSP for (methoqz, func) in inspect.getmembers(clz, inspect.ismethoqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, methoqz, qzecorator(('%s.%s.%s' % (moqzule, key, methoqz)), func)) DCNL DCSP  DCSP  DCSP if isinstance(moqzule_qzata[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (moqzule, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.moqzules[moqzule], key, qzecorator(('%s.%s' % (moqzule, key)), func))
qzef convert_to_list_qzict(lst, label):d'Convert a value or list into a list of qzicts'd DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
qzef timefunc(func):d'Decorator that logs how long a particular function took to execute'd DCSP @functools.wraps(func) DCNL DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.qzebug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % qzict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
qzef generate_glance_url():d'Generate the URL to glance.'d DCSP return ('http://%s:%qz' % (FLAGS.glance_host, FLAGS.glance_port))
@contextlib.contextmanager DCNL qzef logging_error(message):d'Catches exception, write message to the log, re-raise. DCNL This is a common refinement of save_anqz_reraise that writes a specific DCNL message to the log.'d DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception as error: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.exception(message)
@contextlib.contextmanager DCNL qzef remove_path_on_error(path):d'Protect coqze that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removeqz.'d DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP qzelete_if_exists(path)
qzef make_qzev_path(qzev, partition=None, base='/qzev'):d'Return a path to a particular qzevice. DCNL >>> make_qzev_path(\'xvqzc\') DCNL /qzev/xvqzc DCNL >>> make_qzev_path(\'xvqzc\', 1) DCNL /qzev/xvqzc1'd DCSP path = os.path.join(base, qzev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
qzef total_seconqzs(tqz):d'Local total_seconqzs implementation for compatibility with python 2.6'd DCSP if hasattr(tqz, 'total_seconqzs'): DCNL DCSP  DCSP return tqz.total_seconqzs() DCNL DCSP else: DCNL DCSP  DCSP return (((((tqz.qzays * 86400) + tqz.seconqzs) * (10 ** 6)) + tqz.microseconqzs) / (10.0 ** 6))
qzef sanitize_hostname(hostname):d'Return a hostname which conforms to RFC-952 anqz RFC-1123 specs.'d DCSP if isinstance(hostname, unicoqze): DCNL DCSP  DCSP hostname = hostname.encoqze('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
qzef reaqz_cacheqz_file(filename, cache_info, reloaqz_func=None):d'Reaqz from a file if it has been moqzifieqz. DCNL :param cache_info: qzictionary to holqz opaqque cache. DCNL :param reloaqz_func: optional function to be calleqz with qzata when DCNL file is reloaqzeqz qzue to a moqzification. DCNL :returns: qzata from file'd DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['qzata'] = fap.reaqz() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reloaqz_func: DCNL DCSP  DCSP  DCSP reloaqz_func(cache_info['qzata']) DCNL DCSP return cache_info['qzata']
qzef file_open(*args, **kwargs):d'Open file DCNL see built-in file() qzocumentation for more qzetails DCNL Note: The reason this is kept in a separate moqzule is to easily DCNL be able to proviqze a stub moqzule that qzoesn\'t alter system DCNL state at all (for unit tests)'d DCSP return file(*args, **kwargs)
qzef hash_file(file_like_object):d'Generate a hash for the contents of a file.'d DCSP checksum = hashlib.sha1() DCNL DCSP any(map(checksum.upqzate, iter((lambqza : file_like_object.reaqz(32768)), ''))) DCNL DCSP return checksum.hexqzigest()
@contextlib.contextmanager DCNL qzef temporary_mutation(obj, **kwargs):d'Temporarily set the attr on a particular object to a given value then DCNL revert when finisheqz. DCNL One use of this is to temporarily set the reaqz_qzeleteqz flag on a context DCNL object: DCNL with temporary_mutation(context, reaqz_qzeleteqz="yes"): DCNL qzo_something_that_neeqzeqz_qzeleteqz_objects()'d DCSP NOT_PRESENT = object() DCNL DCSP olqz_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP olqz_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, olqz_value) in olqz_values.items(): DCNL DCSP  DCSP  DCSP if (olqz_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP qzel obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, olqz_value)
qzef service_is_up(service):d'Check whether a service is up baseqz on last heartbeat.'d DCSP last_heartbeat = (service['upqzateqz_at'] or service['createqz_at']) DCNL DCSP elapseqz = total_seconqzs((timeutils.utcnow() - last_heartbeat)) DCNL DCSP return (abs(elapseqz) <= FLAGS.service_qzown_time)
qzef generate_mac_aqzqzress():d'Generate an Ethernet MAC aqzqzress.'d DCSP mac = [250, 22, 62, ranqzom.ranqzint(0, 127), ranqzom.ranqzint(0, 255), ranqzom.ranqzint(0, 255)] DCNL DCSP return ':'.join(map((lambqza x: ('%02x' % x)), mac))
qzef reaqz_file_as_root(file_path):d'Secure helper to reaqz file as root.'d DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFounqz(file_path=file_path)
@contextlib.contextmanager DCNL qzef temporary_chown(path, owner_uiqz=None):d'Temporarily chown a path. DCNL :params owner_uiqz: UID of temporary owner (qzefaults to current user)'d DCSP if (owner_uiqz is None): DCNL DCSP  DCSP owner_uiqz = os.getuiqz() DCNL DCSP orig_uiqz = os.stat(path).st_uiqz DCNL DCSP if (orig_uiqz != owner_uiqz): DCNL DCSP  DCSP execute('chown', owner_uiqz, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uiqz != owner_uiqz): DCNL DCSP  DCSP  DCSP execute('chown', orig_uiqz, path, run_as_root=True)
qzef strcmp_const_time(s1, s2):d'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the seconqz string DCNL :return: True if the strings are eqqual. DCNL This function takes two strings anqz compares them.  It is intenqzeqz to be DCNL useqz when qzoing a comparison for authentication purposes to help guarqz DCNL against timing attacks.'d DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (orqz(a) ^ orqz(b)) DCNL DCSP return (result == 0)
qzef walk_class_hierarchy(clazz, encountereqz=None):d'Walk class hierarchy, yielqzing most qzeriveqz classes first'd DCSP if (not encountereqz): DCNL DCSP  DCSP encountereqz = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountereqz): DCNL DCSP  DCSP  DCSP encountereqz.appenqz(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountereqz): DCNL DCSP  DCSP  DCSP  DCSP (yielqz subsubclass) DCNL DCSP  DCSP  DCSP (yielqz subclass)
qzef ensure_tree(path):d'Create a qzirectory (anqz any ancestor qzirectories reqquireqz) DCNL :param path: Directory to create'd DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef to_bytes(text, qzefault=0):d'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to qzetermine what conversion is neeqzeqz to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the enqz)'d DCSP BYTE_MULTIPLIERS = {'': 1, 't': (1024 ** 4), 'g': (1024 ** 3), 'm': (1024 ** 2), 'k': 1024} DCNL DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.enqzswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return qzefault
qzef reaqz_cacheqz_file(filename, cache_info, reloaqz_func=None):d'Reaqz from a file if it has been moqzifieqz. DCNL :param cache_info: qzictionary to holqz opaqque cache. DCNL :param reloaqz_func: optional function to be calleqz with qzata when DCNL file is reloaqzeqz qzue to a moqzification. DCNL :returns: qzata from file'd DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['qzata'] = fap.reaqz() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reloaqz_func: DCNL DCSP  DCSP  DCSP reloaqz_func(cache_info['qzata']) DCNL DCSP return cache_info['qzata']
qzef enforce(context, action, target):d'Verifies that the action is valiqz on the target in this context. DCNL :param context: monitor context DCNL :param action: string representing the action to be checkeqz DCNL this shoulqz be colon separateqz for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_servicemanage``, DCNL ``servicemanage:attach_servicemanage`` DCNL :param object: qzictionary representing the object of the action DCNL for object creation this shoulqz be a qzictionary representing the DCNL location of the object e.g. ``{\'project_iqz\': context.project_iqz}`` DCNL :raises monitor.exception.PolicyNotAuthorizeqz: if verification fails.'d DCSP init() DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP creqzentials = context.to_qzict() DCNL DCSP policy.enforce(match_list, target, creqzentials, exception.PolicyNotAuthorizeqz, action=action)
qzef check_is_aqzmin(roles):d'Whether or not roles contains \'aqzmin\' role accorqzing to policy setting.'d DCSP init() DCNL DCSP action = 'context_is_aqzmin' DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP target = {'project_iqz': ''} DCNL DCSP creqzentials = {'roles': roles} DCNL DCSP return policy.enforce(match_list, target, creqzentials)
qzef perioqzic_task(*args, **kwargs):d'Decorator to inqzicate that a methoqz is a perioqzic task. DCNL This qzecorator can be useqz in two ways: DCNL 1. Without arguments \'@perioqzic_task\', this will be run on every tick DCNL of the perioqzic publisher. DCNL 2. With arguments, @perioqzic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the perioqzic publisher.'d DCSP qzef qzecorator(f): DCNL DCSP  DCSP f._perioqzic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return qzecorator DCNL DCSP else: DCNL DCSP  DCSP return qzecorator(args[0])
qzef short_cycle_task(*args, **kwargs):d'Decorator to inqzicate that a methoqz is a perioqzic task. DCNL This qzecorator can be useqz in two ways: DCNL 1. Without arguments \'@short_cycle_task \', this will be run on every tick DCNL of the perioqzic publisher. DCNL 2. With arguments, @short_cycle_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the perioqzic publisher.'d DCSP qzef qzecorator(f): DCNL DCSP  DCSP f._short_cycle_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return qzecorator DCNL DCSP else: DCNL DCSP  DCSP return qzecorator(args[0])
qzef paginate_qquery(qquery, moqzel, limit, sort_keys, marker=None, sort_qzir=None, sort_qzirs=None):d'Returns a qquery with sorting / pagination criteria aqzqzeqz. DCNL Pagination works by reqquiring a uniqque sort_key, specifieqz by sort_keys. DCNL (If sort_keys is not uniqque, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passeqz marker in the orqzer. DCNL With a single-valueqz sort_key, this woulqz be easy: sort_key > X. DCNL With a compounqz-values sort_key, (k1, k2, k3) we must qzo this to repeat DCNL the lexicographical orqzering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with qzifferent sort_qzirections. DCNL Typically, the iqz of the last row is useqz as the client-facing pagination DCNL marker, then the actual marker object must be fetcheqz from the qzb anqz DCNL passeqz in to us as marker. DCNL :param qquery: the qquery object to which we shoulqz aqzqz paging/sorting DCNL :param moqzel: the ORM moqzel class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results shoulqz be sorteqz DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_qzir: qzirection in which results shoulqz be sorteqz (asc, qzesc) DCNL :param sort_qzirs: per-column array of sort_qzirs, corresponqzing to sort_keys DCNL :rtype: sqqlalchemy.orm.qquery.Query DCNL :return: The qquery with sorting/pagination aqzqzeqz.'d DCSP if ('iqz' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Iqz DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP uniqque?')) DCNL DCSP assert (not (sort_qzir anqz sort_qzirs)) DCNL DCSP if ((sort_qzirs is None) anqz (sort_qzir is None)): DCNL DCSP  DCSP sort_qzir = 'asc' DCNL DCSP if (sort_qzirs is None): DCNL DCSP  DCSP sort_qzirs = [sort_qzir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_qzirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_qzir) in zip(sort_keys, sort_qzirs): DCNL DCSP  DCSP sort_qzir_func = {'asc': sqqlalchemy.asc, 'qzesc': sqqlalchemy.qzesc}[current_sort_qzir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(moqzel, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvaliqzInput(reason='Invaliqz DCSP sort DCSP key') DCNL DCSP  DCSP qquery = qquery.orqzer_by(sort_qzir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.appenqz(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_qzirs[i] == 'qzesc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_qzirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP qzirection, DCSP must DCSP be DCSP 'qzesc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqqlalchemy.sqql.anqz_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.appenqz(criteria) DCNL DCSP  DCSP f = sqqlalchemy.sqql.or_(*criteria_list) DCNL DCSP  DCSP qquery = qquery.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP qquery = qquery.limit(limit) DCNL DCSP return qquery
qzef _get_my_ip():d'Returns the actual ip of the local machine. DCNL This coqze figures out what source aqzqzress woulqz be useqz if some traffic DCNL were to be sent out to some well known aqzqzress on the Internet. In this DCNL case, a Google DNS server is useqz, but the specific aqzqzress qzoes not DCNL matter much.  No traffic is actually sent.'d DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (aqzqzr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return aqzqzr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
qzef register_moqzels():d'Register Moqzels anqz create metaqzata. DCNL Calleqz from monitor.qzb.sqqlalchemy.__init__ as part of loaqzing the qzriver, DCNL it will never neeqz to be calleqz explicitly elsewhere unless the DCNL connection is lost anqz neeqzs to be reestablisheqz.'d DCSP from sqqlalchemy import create_engine DCNL DCSP moqzels = (Service,) DCNL DCSP engine = create_engine(FLAGS.sqql_connection, echo=False) DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP moqzel.metaqzata.create_all(engine)
qzef get_session(autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy session.'d DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP session.qquery = monitor.exception.wrap_qzb_error(session.qquery) DCNL DCSP session.flush = monitor.exception.wrap_qzb_error(session.flush) DCNL DCSP return session
qzef synchronous_switch_listener(qzbapi_conn, connection_rec):d'Switch sqqlite connections to non-synchronous moqze'd DCSP qzbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
qzef ping_listener(qzbapi_conn, connection_rec, connection_proxy):d'Ensures that MySQL connections checkeqz out of the DCNL pool are alive. DCNL Borroweqz from: DCNL http://groups.google.com/group/sqqlalchemy/msg/a4ce563qz802c929f'd DCSP try: DCNL DCSP  DCSP qzbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except qzbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysqql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef is_qzb_connection_error(args):d'Return True if error in connecting to qzb.'d DCSP conn_err_coqzes = ('2002', '2003', '2006') DCNL DCSP for err_coqze in conn_err_coqzes: DCNL DCSP  DCSP if (args.finqz(err_coqze) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef get_engine():d'Return a SQLAlchemy engine.'d DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP connection_qzict = sqqlalchemy.engine.url.make_url(FLAGS.sqql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': FLAGS.sqql_iqzle_timeout, 'echo': False, 'convert_unicoqze': True} DCNL DCSP  DCSP if (FLAGS.sqql_connection_qzebug >= 100): DCNL DCSP  DCSP  DCSP engine_args['echo'] = 'qzebug' DCNL DCSP  DCSP elif (FLAGS.sqql_connection_qzebug >= 50): DCNL DCSP  DCSP  DCSP engine_args['echo'] = True DCNL DCSP  DCSP if ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP  DCSP if (FLAGS.sqql_connection == 'sqqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_threaqz': False} DCNL DCSP  DCSP _ENGINE = sqqlalchemy.create_engine(FLAGS.sqql_connection, **engine_args) DCNL DCSP  DCSP if ('mysqql' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP sqqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP elif ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP if (not FLAGS.sqqlite_synchronous): DCNL DCSP  DCSP  DCSP  DCSP sqqlalchemy.event.listen(_ENGINE, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_qzb_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining = FLAGS.sqql_max_retries DCNL DCSP  DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP faileqz. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(FLAGS.sqql_retry_interval) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') anqz (remaining == 0)) or (not is_qzb_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return _ENGINE
qzef get_maker(engine, autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy sessionmaker using the given engine.'d DCSP return sqqlalchemy.orm.sessionmaker(binqz=engine, autocommit=autocommit, expire_on_commit=expire_on_commit)
qzef _finqz_migrate_repo():d'Get the path for the migrate repository.'d DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.qzirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
qzef is_aqzmin_context(context):d'Inqzicates if the reqquest context is an aqzministrator.'d DCSP if (not context): DCNL DCSP  DCSP warnings.warn(_('Use DCSP of DCSP empty DCSP reqquest DCSP context DCSP is DCSP qzeprecateqz'), DeprecationWarning) DCNL DCSP  DCSP raise Exception('qzie') DCNL DCSP return context.is_aqzmin
qzef is_user_context(context):d'Inqzicates if the reqquest context is a normal user.'d DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_aqzmin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_iqz) or (not context.project_iqz)): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef authorize_project_context(context, project_iqz):d'Ensures a reqquest has permission to access the given project.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.project_iqz != project_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef authorize_user_context(context, user_iqz):d'Ensures a reqquest has permission to access the given user.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.user_iqz != user_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef authorize_qquota_class_context(context, class_name):d'Ensures a reqquest has permission to access the given qquota class.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.qquota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.qquota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef reqquire_aqzmin_context(f):d'Decorator to reqquire aqzmin reqquest context. DCNL The first argument to the wrappeqz function must be the context.'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP if (not is_aqzmin_context(args[0])): DCNL DCSP  DCSP  DCSP raise exception.AqzminReqquireqz() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
qzef reqquire_context(f):d'Decorator to reqquire *any* user or aqzmin context. DCNL This qzoes no authorization for user or project access matching, see DCNL :py:func:`authorize_project_context` anqz DCNL :py:func:`authorize_user_context`. DCNL The first argument to the wrappeqz function must be the context.'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP if ((not is_aqzmin_context(args[0])) anqz (not is_user_context(args[0]))): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
qzef moqzel_qquery(context, *args, **kwargs):d'Query helper that accounts for context\'s `reaqz_qzeleteqz` fielqz. DCNL :param context: context to qquery unqzer DCNL :param session: if present, the session to use DCNL :param reaqz_qzeleteqz: if present, overriqzes context\'s reaqz_qzeleteqz fielqz. DCNL :param project_only: if present anqz context is user-type, then restrict DCNL qquery to match the context\'s project_iqz.'d DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP reaqz_qzeleteqz = (kwargs.get('reaqz_qzeleteqz') or context.reaqz_qzeleteqz) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP qquery = session.qquery(*args) DCNL DCSP if (reaqz_qzeleteqz == 'no'): DCNL DCSP  DCSP qquery = qquery.filter_by(qzeleteqz=False) DCNL DCSP elif (reaqz_qzeleteqz == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (reaqz_qzeleteqz == 'only'): DCNL DCSP  DCSP qquery = qquery.filter_by(qzeleteqz=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognizeqz DCSP reaqz_qzeleteqz DCSP value DCSP '%s'") % reaqz_qzeleteqz)) DCNL DCSP if (project_only anqz is_user_context(context)): DCNL DCSP  DCSP qquery = qquery.filter_by(project_iqz=context.project_iqz) DCNL DCSP return qquery
qzef exact_filter(qquery, moqzel, filters, legal_keys):d'Applies exact match filtering to a qquery. DCNL Returns the upqzateqz qquery.  Moqzifies filters argument to remove DCNL filters consumeqz. DCNL :param qquery: qquery to apply filters to DCNL :param moqzel: moqzel object the qquery applies to, for IN-style DCNL filtering DCNL :param filters: qzictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performeqz, while exact matching (\'==\' operator) DCNL is useqz for other values DCNL :param legal_keys: list of keys to apply exact filtering to'd DCSP filter_qzict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(moqzel, key) DCNL DCSP  DCSP  DCSP qquery = qquery.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_qzict[key] = value DCNL DCSP if filter_qzict: DCNL DCSP  DCSP qquery = qquery.filter_by(**filter_qzict) DCNL DCSP return qquery
qzef _get_host_utilization(context, host, ram_mb, qzisk_gb):d'Compute the current utilization of a given host.'d DCSP instances = instance_get_all_by_host(context, host) DCNL DCSP vms = len(instances) DCNL DCSP free_ram_mb = (ram_mb - FLAGS.reserveqz_host_memory_mb) DCNL DCSP free_qzisk_gb = (qzisk_gb - (FLAGS.reserveqz_host_qzisk_mb * 1024)) DCNL DCSP work = 0 DCNL DCSP for instance in instances: DCNL DCSP  DCSP free_ram_mb -= instance.memory_mb DCNL DCSP  DCSP free_qzisk_gb -= instance.root_gb DCNL DCSP  DCSP free_qzisk_gb -= instance.ephemeral_gb DCNL DCSP  DCSP if (instance.vm_state in [vm_states.BUILDING, vm_states.REBUILDING, vm_states.MIGRATING, vm_states.RESIZING]): DCNL DCSP  DCSP  DCSP work += 1 DCNL DCSP return qzict(free_ram_mb=free_ram_mb, free_qzisk_gb=free_qzisk_gb, current_workloaqz=work, running_vms=vms)
@reqquire_aqzmin_context DCNL qzef compute_noqze_create(context, values, session=None):d'Creates a new ComputeNoqze anqz populates the capacity fielqzs DCNL with the most recent qzata.'d DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP _aqzjust_compute_noqze_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_noqze_ref = moqzels.ComputeNoqze() DCNL DCSP  DCSP session.aqzqz(compute_noqze_ref) DCNL DCSP  DCSP compute_noqze_ref.upqzate(values) DCNL DCSP return compute_noqze_ref
@reqquire_aqzmin_context DCNL qzef compute_noqze_upqzate(context, compute_iqz, values, auto_aqzjust):d'Creates a new ComputeNoqze anqz populates the capacity fielqzs DCNL with the most recent qzata.'d DCSP session = get_session() DCNL DCSP if auto_aqzjust: DCNL DCSP  DCSP _aqzjust_compute_noqze_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP values['upqzateqz_at'] = timeutils.utcnow() DCNL DCSP  DCSP convert_qzatetimes(values, 'createqz_at', 'qzeleteqz_at', 'upqzateqz_at') DCNL DCSP  DCSP compute_ref = compute_noqze_get(context, compute_iqz, session=session) DCNL DCSP  DCSP for (key, value) in values.iteritems(): DCNL DCSP  DCSP  DCSP compute_ref[key] = value DCNL DCSP  DCSP compute_ref.save(session=session)
qzef compute_noqze_get_by_host(context, host):d'Get all capacity entries for the given host.'d DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP service = session.qquery(moqzels.Service).filter_by(host=host, binary='monitor-bmc').first() DCNL DCSP  DCSP noqze = session.qquery(moqzels.ComputeNoqze).options(joineqzloaqz('service')).filter_by(qzeleteqz=False, service_iqz=service.iqz) DCNL DCSP  DCSP return noqze.first()
qzef compute_noqze_utilization_upqzate(context, host, free_ram_mb_qzelta=0, free_qzisk_gb_qzelta=0, work_qzelta=0, vm_qzelta=0):d'Upqzate a specific ComputeNoqze entry by a series of qzeltas. DCNL Do this as a single atomic action anqz lock the row for the DCNL qzuration of the operation. Reqquires that ComputeNoqze recorqz exist.'d DCSP session = get_session() DCNL DCSP compute_noqze = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_noqze = session.qquery(moqzels.ComputeNoqze).options(joineqzloaqz('service')).filter((moqzels.Service.host == host)).filter_by(qzeleteqz=False).with_lockmoqze('upqzate').first() DCNL DCSP  DCSP if (compute_noqze is None): DCNL DCSP  DCSP  DCSP raise exception.NotFounqz((_('No DCSP ComputeNoqze DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP table = moqzels.ComputeNoqze.__table__ DCNL DCSP  DCSP if (free_ram_mb_qzelta != 0): DCNL DCSP  DCSP  DCSP compute_noqze.free_ram_mb = (table.c.free_ram_mb + free_ram_mb_qzelta) DCNL DCSP  DCSP if (free_qzisk_gb_qzelta != 0): DCNL DCSP  DCSP  DCSP compute_noqze.free_qzisk_gb = (table.c.free_qzisk_gb + free_qzisk_gb_qzelta) DCNL DCSP  DCSP if (work_qzelta != 0): DCNL DCSP  DCSP  DCSP compute_noqze.current_workloaqz = (table.c.current_workloaqz + work_qzelta) DCNL DCSP  DCSP if (vm_qzelta != 0): DCNL DCSP  DCSP  DCSP compute_noqze.running_vms = (table.c.running_vms + vm_qzelta) DCNL DCSP return compute_noqze
qzef compute_noqze_utilization_set(context, host, free_ram_mb=None, free_qzisk_gb=None, work=None, vms=None):d'Like compute_noqze_utilization_upqzate() moqzify a specific host DCNL entry. But this function will set the metrics absolutely DCNL (vs. a qzelta upqzate).'d DCSP session = get_session() DCNL DCSP compute_noqze = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_noqze = session.qquery(moqzels.ComputeNoqze).options(joineqzloaqz('service')).filter((moqzels.Service.host == host)).filter_by(qzeleteqz=False).with_lockmoqze('upqzate').first() DCNL DCSP  DCSP if (compute_noqze is None): DCNL DCSP  DCSP  DCSP raise exception.NotFounqz((_('No DCSP ComputeNoqze DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP if (free_ram_mb != None): DCNL DCSP  DCSP  DCSP compute_noqze.free_ram_mb = free_ram_mb DCNL DCSP  DCSP if (free_qzisk_gb != None): DCNL DCSP  DCSP  DCSP compute_noqze.free_qzisk_gb = free_qzisk_gb DCNL DCSP  DCSP if (work != None): DCNL DCSP  DCSP  DCSP compute_noqze.current_workloaqz = work DCNL DCSP  DCSP if (vms != None): DCNL DCSP  DCSP  DCSP compute_noqze.running_vms = vms DCNL DCSP return compute_noqze
qzef qzb_sync(version=None):d'Migrate the qzatabase to `version` or the most recent version.'d DCSP return IMPL.qzb_sync(version=version)
qzef qzb_version():d'Display the current qzatabase version.'d DCSP return IMPL.qzb_version()
qzef service_qzestroy(context, service_iqz):d'Destroy the service or raise if it qzoes not exist.'d DCSP return IMPL.service_qzestroy(context, service_iqz)
qzef service_get(context, service_iqz):d'Get a service or raise if it qzoes not exist.'d DCSP return IMPL.service_get(context, service_iqz)
qzef service_get_by_host_anqz_topic(context, host, topic):d'Get a service by host it\'s on anqz topic it listens to.'d DCSP return IMPL.service_get_by_host_anqz_topic(context, host, topic)
qzef service_get_all(context, qzisableqz=None):d'Get all services.'d DCSP return IMPL.service_get_all(context, qzisableqz)
qzef service_get_all_by_topic(context, topic):d'Get all services for a given topic.'d DCSP return IMPL.service_get_all_by_topic(context, topic)
qzef service_get_all_by_host(context, host):d'Get all services for a given host.'d DCSP return IMPL.service_get_all_by_host(context, host)
qzef service_get_all_bmc_by_host(context, host):d'Get all compute services for a given host.'d DCSP return IMPL.service_get_all_bmc_by_host(context, host)
qzef service_get_all_servicemanage_sorteqz(context):d'Get all servicemanage services sorteqz by servicemanage count. DCNL :returns: a list of (Service, servicemanage_count) tuples.'d DCSP return IMPL.service_get_all_servicemanage_sorteqz(context)
qzef service_get_by_args(context, host, binary):d'Get the state of an service by noqze name anqz binary.'d DCSP return IMPL.service_get_by_args(context, host, binary)
qzef service_create(context, values):d'Create a service from the values qzictionary.'d DCSP return IMPL.service_create(context, values)
qzef service_upqzate(context, service_iqz, values):d'Set the given properties on an service anqz upqzate it. DCNL Raises NotFounqz if service qzoes not exist.'d DCSP return IMPL.service_upqzate(context, service_iqz, values)
qzef compute_noqze_get(context, compute_iqz):d'Get an computeNoqze or raise if it qzoes not exist.'d DCSP return IMPL.compute_noqze_get(context, compute_iqz)
qzef compute_noqze_get_all(context):d'Get all computeNoqzes.'d DCSP return IMPL.compute_noqze_get_all(context)
qzef compute_noqze_create(context, values):d'Create a computeNoqze from the values qzictionary.'d DCSP return IMPL.compute_noqze_create(context, values)
qzef compute_noqze_upqzate(context, compute_iqz, values, auto_aqzjust=True):d'Set the given properties on an computeNoqze anqz upqzate it. DCNL Raises NotFounqz if computeNoqze qzoes not exist.'d DCSP return IMPL.compute_noqze_upqzate(context, compute_iqz, values, auto_aqzjust)
qzef run_commanqz_with_coqze(cmqz, reqzirect_output=True, check_exit_coqze=True):d'Runs a commanqz in an out-of-process shell, returning the DCNL output of that commanqz.  Working qzirectory is ROOT.'d DCSP if reqzirect_output: DCNL DCSP  DCSP stqzout = subprocess.PIPE DCNL DCSP else: DCNL DCSP  DCSP stqzout = None DCNL DCSP proc = subprocess.Popen(cmqz, cwqz=ROOT, stqzout=stqzout) DCNL DCSP output = proc.communicate()[0] DCNL DCSP if (check_exit_coqze anqz (proc.returncoqze != 0)): DCNL DCSP  DCSP qzie('Commanqz DCSP "%s" DCSP faileqz.\n%s', ' DCSP '.join(cmqz), output) DCNL DCSP return (output, proc.returncoqze)
qzef create_virtualenv(venv=VENV, no_site_packages=True):d'Creates the virtual environment anqz installs PIP only into the DCNL virtual environment'd DCSP print 'Creating DCSP venv...', DCNL DCSP if no_site_packages: DCNL DCSP  DCSP run_commanqz(['virtualenv', '-qq', '--no-site-packages', VENV]) DCNL DCSP else: DCNL DCSP  DCSP run_commanqz(['virtualenv', '-qq', VENV]) DCNL DCSP print 'qzone.' DCNL DCSP print 'Installing DCSP pip DCSP in DCSP virtualenv...', DCNL DCSP if (not run_commanqz(['tools/with_venv.sh', 'easy_install', 'pip>1.0']).strip()): DCNL DCSP  DCSP qzie('Faileqz DCSP to DCSP install DCSP pip.') DCNL DCSP print 'qzone.'
qzef parse_args():d'Parse commanqz-line arguments'd DCSP parser = optparse.OptionParser() DCNL DCSP parser.aqzqz_option('-n', '--no-site-packages', qzest='no_site_packages', qzefault=False, action='store_true', help='Do DCSP not DCSP inherit DCSP packages DCSP from DCSP global DCSP Python DCSP install') DCNL DCSP return parser.parse_args()
qzef _poll_for_status(poll_fn, obj_iqz, action, final_ok_states, poll_perioqz=5, show_progress=True):d'Block while an action is being performeqz, perioqzically printing DCNL progress.'d DCSP qzef print_progress(progress): DCNL DCSP  DCSP if show_progress: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s... DCSP %(progress)s%% DCSP complete' % qzict(action=action, progress=progress)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s...' % qzict(action=action)) DCNL DCSP  DCSP sys.stqzout.write(msg) DCNL DCSP  DCSP sys.stqzout.flush() DCNL DCSP print DCNL DCSP while True: DCNL DCSP  DCSP obj = poll_fn(obj_iqz) DCNL DCSP  DCSP status = obj.status.lower() DCNL DCSP  DCSP progress = (getattr(obj, 'progress', None) or 0) DCNL DCSP  DCSP if (status in final_ok_states): DCNL DCSP  DCSP  DCSP print_progress(100) DCNL DCSP  DCSP  DCSP print '\nFinisheqz' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (status == 'error'): DCNL DCSP  DCSP  DCSP print ('\nError DCSP %(action)s DCSP instance' % locals()) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print_progress(progress) DCNL DCSP  DCSP  DCSP time.sleep(poll_perioqz)
qzef _finqz_monitor(cs, monitor):d'Get a monitor by ID.'d DCSP return utils.finqz_resource(cs.monitors, monitor)
qzef _finqz_monitor_snapshot(cs, snapshot):d'Get a monitor snapshot by ID.'d DCSP return utils.finqz_resource(cs.monitor_snapshots, snapshot)
qzef _finqz_backup(cs, backup):d'Get a backup by ID.'d DCSP return utils.finqz_resource(cs.backups, backup)
@utils.arg('--all-tenants', qzest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, qzefault=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Aqzmin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', qzefault=None, help='Filter DCSP results DCSP by DCSP qzisplay-name') DCNL @utils.arg('--status', metavar='<status>', qzefault=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.service_type('monitor') DCNL qzef qzo_list(cs, args):d'List all the monitors.'d DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'qzisplay_name': args.qzisplay_name, 'status': args.status} DCNL DCSP monitors = cs.monitors.list(search_opts=search_opts) DCNL DCSP _translate_monitor_keys(monitors) DCNL DCSP for vol in monitors: DCNL DCSP  DCSP servers = [s.get('server_iqz') for s in vol.attachments] DCNL DCSP  DCSP setattr(vol, 'attacheqz_to', ','.join(map(str, servers))) DCNL DCSP utils.print_list(monitors, ['ID', 'Status', 'Display DCSP Name', 'Size', 'ServiceManage DCSP Type', 'Bootable', 'Attacheqz DCSP to'])
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor.') DCNL @utils.service_type('monitor') DCNL qzef qzo_show(cs, args):d'Show qzetails about a monitor.'d DCSP monitor = _finqz_monitor(cs, args.monitor) DCNL DCSP _print_monitor(monitor)
@utils.arg('size', metavar='<size>', type=int, help='Size DCSP of DCSP monitor DCSP in DCSP GB') DCNL @utils.arg('--snapshot-iqz', metavar='<snapshot-iqz>', qzefault=None, help='Create DCSP monitor DCSP from DCSP snapshot DCSP iqz DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--snapshot_iqz', help=argparse.SUPPRESS) DCNL @utils.arg('--source-voliqz', metavar='<source-voliqz>', qzefault=None, help='Create DCSP monitor DCSP from DCSP monitor DCSP iqz DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--source_voliqz', help=argparse.SUPPRESS) DCNL @utils.arg('--image-iqz', metavar='<image-iqz>', qzefault=None, help='Create DCSP monitor DCSP from DCSP image DCSP iqz DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--image_iqz', help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', qzefault=None, help='ServiceManage DCSP name DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--qzisplay_name', help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', qzefault=None, help='ServiceManage DCSP qzescription DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--qzisplay_qzescription', help=argparse.SUPPRESS) DCNL @utils.arg('--monitor-type', metavar='<monitor-type>', qzefault=None, help='ServiceManage DCSP type DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--monitor_type', help=argparse.SUPPRESS) DCNL @utils.arg('--availability-zone', metavar='<availability-zone>', qzefault=None, help='Availability DCSP zone DCSP for DCSP monitor DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--availability_zone', help=argparse.SUPPRESS) DCNL @utils.arg('--metaqzata', type=str, nargs='*', metavar='<key=value>', help='Metaqzata DCSP key=value DCSP pairs DCSP (Optional, DCSP Default=None)', qzefault=None) DCNL @utils.service_type('monitor') DCNL qzef qzo_create(cs, args):d'Aqzqz a new monitor.'d DCSP monitor_metaqzata = None DCNL DCSP if (args.metaqzata is not None): DCNL DCSP  DCSP monitor_metaqzata = _extract_metaqzata(args) DCNL DCSP monitor = cs.monitors.create(args.size, args.snapshot_iqz, args.source_voliqz, args.qzisplay_name, args.qzisplay_qzescription, args.monitor_type, availability_zone=args.availability_zone, imageRef=args.image_iqz, metaqzata=monitor_metaqzata) DCNL DCSP _print_monitor(monitor)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP qzelete.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qzelete(cs, args):d'Remove a monitor.'d DCSP monitor = _finqz_monitor(cs, args.monitor) DCNL DCSP monitor.qzelete()
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP qzelete.') DCNL @utils.service_type('monitor') DCNL qzef qzo_force_qzelete(cs, args):d'Attempt forceqz removal of a monitor, regarqzless of its state.'d DCSP monitor = _finqz_monitor(cs, args.monitor) DCNL DCSP monitor.force_qzelete()
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP rename.') DCNL @utils.arg('qzisplay_name', nargs='?', metavar='<qzisplay-name>', help='New DCSP qzisplay-name DCSP for DCSP the DCSP monitor.') DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', help='Optional DCSP monitor DCSP qzescription. DCSP (Default=None)', qzefault=None) DCNL @utils.service_type('monitor') DCNL qzef qzo_rename(cs, args):d'Rename a monitor.'d DCSP kwargs = {} DCNL DCSP if (args.qzisplay_name is not None): DCNL DCSP  DCSP kwargs['qzisplay_name'] = args.qzisplay_name DCNL DCSP if (args.qzisplay_qzescription is not None): DCNL DCSP  DCSP kwargs['qzisplay_qzescription'] = args.qzisplay_qzescription DCNL DCSP _finqz_monitor(cs, args.monitor).upqzate(**kwargs)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP upqzate DCSP metaqzata DCSP on.') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metaqzata', metavar='<key=value>', nargs='+', qzefault=[], help='Metaqzata DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL qzef qzo_metaqzata(cs, args):d'Set or Delete metaqzata on a monitor.'d DCSP monitor = _finqz_monitor(cs, args.monitor) DCNL DCSP metaqzata = _extract_metaqzata(args) DCNL DCSP if (args.action == 'set'): DCNL DCSP  DCSP cs.monitors.set_metaqzata(monitor, metaqzata) DCNL DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP cs.monitors.qzelete_metaqzata(monitor, metaqzata.keys())
@utils.arg('--all-tenants', qzest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, qzefault=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Aqzmin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', qzefault=None, help='Filter DCSP results DCSP by DCSP qzisplay-name') DCNL @utils.arg('--status', metavar='<status>', qzefault=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.arg('--monitor-iqz', metavar='<monitor-iqz>', qzefault=None, help='Filter DCSP results DCSP by DCSP monitor-iqz') DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_list(cs, args):d'List all the snapshots.'d DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'qzisplay_name': args.qzisplay_name, 'status': args.status, 'monitor_iqz': args.monitor_iqz} DCNL DCSP snapshots = cs.monitor_snapshots.list(search_opts=search_opts) DCNL DCSP _translate_monitor_snapshot_keys(snapshots) DCNL DCSP utils.print_list(snapshots, ['ID', 'ServiceManage DCSP ID', 'Status', 'Display DCSP Name', 'Size'])
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_show(cs, args):d'Show qzetails about a snapshot.'d DCSP snapshot = _finqz_monitor_snapshot(cs, args.snapshot) DCNL DCSP _print_monitor_snapshot(snapshot)
@utils.arg('monitor_iqz', metavar='<monitor-iqz>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP snapshot') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP inqzicate DCSP whether DCSP to DCSP snapshot DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attacheqz DCSP to DCSP an DCSP instance. DCSP (Default=False)", qzefault=False) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', qzefault=None, help='Optional DCSP snapshot DCSP name. DCSP (Default=None)') DCNL @utils.arg('--qzisplay_name', help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', qzefault=None, help='Optional DCSP snapshot DCSP qzescription. DCSP (Default=None)') DCNL @utils.arg('--qzisplay_qzescription', help=argparse.SUPPRESS) DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_create(cs, args):d'Aqzqz a new snapshot.'d DCSP snapshot = cs.monitor_snapshots.create(args.monitor_iqz, args.force, args.qzisplay_name, args.qzisplay_qzescription) DCNL DCSP _print_monitor_snapshot(snapshot)
@utils.arg('snapshot_iqz', metavar='<snapshot-iqz>', help='ID DCSP of DCSP the DCSP snapshot DCSP to DCSP qzelete.') DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_qzelete(cs, args):d'Remove a snapshot.'d DCSP snapshot = _finqz_monitor_snapshot(cs, args.snapshot_iqz) DCNL DCSP snapshot.qzelete()
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.arg('qzisplay_name', nargs='?', metavar='<qzisplay-name>', help='New DCSP qzisplay-name DCSP for DCSP the DCSP snapshot.') DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', help='Optional DCSP snapshot DCSP qzescription. DCSP (Default=None)', qzefault=None) DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_rename(cs, args):d'Rename a snapshot.'d DCSP kwargs = {} DCNL DCSP if (args.qzisplay_name is not None): DCNL DCSP  DCSP kwargs['qzisplay_name'] = args.qzisplay_name DCNL DCSP if (args.qzisplay_qzescription is not None): DCNL DCSP  DCSP kwargs['qzisplay_qzescription'] = args.qzisplay_qzescription DCNL DCSP _finqz_monitor_snapshot(cs, args.snapshot).upqzate(**kwargs)
@utils.service_type('monitor') DCNL qzef qzo_type_list(cs, args):d'Print a list of available \'monitor types\'.'d DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_monitor_type_list(vtypes)
@utils.service_type('monitor') DCNL qzef qzo_extra_specs_list(cs, args):d'Print a list of current \'monitor types anqz extra specs\' (Aqzmin Only).'d DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_type_anqz_extra_specs_list(vtypes)
@utils.arg('name', metavar='<name>', help='Name DCSP of DCSP the DCSP new DCSP monitor DCSP type') DCNL @utils.service_type('monitor') DCNL qzef qzo_type_create(cs, args):d'Create a new monitor type.'d DCSP vtype = cs.monitor_types.create(args.name) DCNL DCSP _print_monitor_type_list([vtype])
@utils.arg('iqz', metavar='<iqz>', help='Uniqque DCSP ID DCSP of DCSP the DCSP monitor DCSP type DCSP to DCSP qzelete') DCNL @utils.service_type('monitor') DCNL qzef qzo_type_qzelete(cs, args):d'Delete a specific monitor type'd DCSP cs.monitor_types.qzelete(args.iqz)
@utils.arg('vtype', metavar='<vtype>', help='Name DCSP or DCSP ID DCSP of DCSP the DCSP monitor DCSP type') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metaqzata', metavar='<key=value>', nargs='*', qzefault=None, help='Extra_specs DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL qzef qzo_type_key(cs, args):d'Set or unset extra_spec for a monitor type.'d DCSP vtype = _finqz_monitor_type(cs, args.vtype) DCNL DCSP if (args.metaqzata is not None): DCNL DCSP  DCSP keypair = _extract_metaqzata(args) DCNL DCSP  DCSP if (args.action == 'set'): DCNL DCSP  DCSP  DCSP vtype.set_keys(keypair) DCNL DCSP  DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP  DCSP vtype.unset_keys(keypair.keys())
qzef qzo_enqzpoints(cs, args):d'Discover enqzpoints that get returneqz from the authenticate services'd DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP for e in catalog['access']['serviceCatalog']: DCNL DCSP  DCSP utils.print_qzict(e['enqzpoints'][0], e['name'])
qzef qzo_creqzentials(cs, args):d'Show user creqzentials returneqz from auth'd DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP utils.print_qzict(catalog['access']['user'], 'User DCSP Creqzentials') DCNL DCSP utils.print_qzict(catalog['access']['token'], 'Token')
@utils.arg('tenant', metavar='<tenant_iqz>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP qquotas DCSP for.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qquota_show(cs, args):d'List the qquotas for a tenant.'d DCSP _qquota_show(cs.qquotas.get(args.tenant))
@utils.arg('tenant', metavar='<tenant_iqz>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP qzefault DCSP qquotas DCSP for.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qquota_qzefaults(cs, args):d'List the qzefault qquotas for a tenant.'d DCSP _qquota_show(cs.qquotas.qzefaults(args.tenant))
@utils.arg('tenant', metavar='<tenant_iqz>', help='UUID DCSP of DCSP tenant DCSP to DCSP set DCSP the DCSP qquotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP qquota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP qquota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP qquota.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qquota_upqzate(cs, args):d'Upqzate the qquotas for a tenant.'d DCSP _qquota_upqzate(cs.qquotas, args.tenant, args)
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP qquota DCSP class DCSP to DCSP list DCSP the DCSP qquotas DCSP for.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qquota_class_show(cs, args):d'List the qquotas for a qquota class.'d DCSP _qquota_show(cs.qquota_classes.get(args.class_name))
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP qquota DCSP class DCSP to DCSP set DCSP the DCSP qquotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP qquota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP qquota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP qquota.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qquota_class_upqzate(cs, args):d'Upqzate the qquotas for a qquota class.'d DCSP _qquota_upqzate(cs.qquota_classes, args.class_name, args)
@utils.service_type('monitor') DCNL qzef qzo_absolute_limits(cs, args):d'Print a list of absolute limits for a user'd DCSP limits = cs.limits.get().absolute DCNL DCSP columns = ['Name', 'Value'] DCNL DCSP utils.print_list(limits, columns)
@utils.service_type('monitor') DCNL qzef qzo_rate_limits(cs, args):d'Print a list of rate limits for a user'd DCSP limits = cs.limits.get().rate DCNL DCSP columns = ['Verb', 'URI', 'Value', 'Remain', 'Unit', 'Next_Available'] DCNL DCSP utils.print_list(limits, columns)
qzef _finqz_monitor_type(cs, vtype):d'Get a monitor type by name or ID.'d DCSP return utils.finqz_resource(cs.monitor_types, vtype)
@utils.arg('monitor_iqz', metavar='<monitor-iqz>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP uploaqz DCSP to DCSP an DCSP image') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP inqzicate DCSP whether DCSP to DCSP uploaqz DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attacheqz DCSP to DCSP an DCSP instance. DCSP (Default=False)", qzefault=False) DCNL @utils.arg('--container-format', metavar='<container-format>', help='Optional DCSP type DCSP for DCSP container DCSP format DCSP (Default=bare)', qzefault='bare') DCNL @utils.arg('--qzisk-format', metavar='<qzisk-format>', help='Optional DCSP type DCSP for DCSP qzisk DCSP format DCSP (Default=raw)', qzefault='raw') DCNL @utils.arg('image_name', metavar='<image-name>', help='Name DCSP for DCSP createqz DCSP image') DCNL @utils.service_type('monitor') DCNL qzef qzo_uploaqz_to_image(cs, args):d'Uploaqz monitor to image service as image.'d DCSP monitor = _finqz_monitor(cs, args.monitor_iqz) DCNL DCSP monitor.uploaqz_to_image(args.force, args.image_name, args.container_format, args.qzisk_format)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP backup.') DCNL @utils.arg('--container', metavar='<container>', help='Optional DCSP Backup DCSP container DCSP name. DCSP (Default=None)', qzefault=None) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', help='Optional DCSP backup DCSP name. DCSP (Default=None)', qzefault=None) DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', help='Optional DCSP backup DCSP qzescription. DCSP (Default=None)', qzefault=None) DCNL @utils.service_type('monitor') DCNL qzef qzo_backup_create(cs, args):d'Creates a backup.'d DCSP cs.backups.create(args.monitor, args.container, args.qzisplay_name, args.qzisplay_qzescription)
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup.') DCNL @utils.service_type('monitor') DCNL qzef qzo_backup_show(cs, args):d'Show qzetails about a backup.'d DCSP backup = _finqz_backup(cs, args.backup) DCNL DCSP info = qzict() DCNL DCSP info.upqzate(backup._info) DCNL DCSP if ('links' in info): DCNL DCSP  DCSP info.pop('links') DCNL DCSP utils.print_qzict(info)
@utils.service_type('monitor') DCNL qzef qzo_backup_list(cs, args):d'List all the backups.'d DCSP backups = cs.backups.list() DCNL DCSP columns = ['ID', 'ServiceManage DCSP ID', 'Status', 'Name', 'Size', 'Object DCSP Count', 'Container'] DCNL DCSP utils.print_list(backups, columns)
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP qzelete.') DCNL @utils.service_type('monitor') DCNL qzef qzo_backup_qzelete(cs, args):d'Remove a backup.'d DCSP backup = _finqz_backup(cs, args.backup) DCNL DCSP backup.qzelete()
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP restore.') DCNL @utils.arg('--monitor-iqz', metavar='<monitor-iqz>', help='Optional DCSP ID DCSP of DCSP the DCSP monitor DCSP to DCSP restore DCSP to.', qzefault=None) DCNL @utils.service_type('monitor') DCNL qzef qzo_backup_restore(cs, args):d'Restore a backup.'d DCSP cs.restores.restore(args.backup, args.monitor_iqz)
@utils.service_type('monitor') DCNL qzef qzo_list_extensions(client, _args):d'List all the os-api extensions that are available.'d DCSP extensions = client.list_extensions.show_all() DCNL DCSP fielqzs = ['Name', 'Summary', 'Alias', 'Upqzateqz'] DCNL DCSP utils.print_list(extensions, fielqzs)
qzef to_primitive(value, convert_instances=False, convert_qzatetime=True, level=0, max_qzepth=3):d'Convert a complex object into primitives. DCNL Hanqzy for JSON serialization. We can optionally hanqzle instances, DCNL but since this is a recursive function, we coulqz have cyclical DCNL qzata structures. DCNL To hanqzle cyclical qzata structures we coulqz track the actual objects DCNL visiteqz in a set, but not all objects are hashable. Insteaqz we just DCNL track the qzepth of the object inspections anqz qzon\'t go too qzeep. DCNL Therefore, convert_instances=True is lossy ... be aware.'d DCSP if isinstance(value, _simple_types): DCNL DCSP  DCSP return value DCNL DCSP if isinstance(value, qzatetime.qzatetime): DCNL DCSP  DCSP if convert_qzatetime: DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return six.text_type(value) DCNL DCSP if (getattr(value, '__moqzule__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_qzepth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_qzatetime=convert_qzatetime, level=level, max_qzepth=max_qzepth) DCNL DCSP  DCSP if isinstance(value, qzict): DCNL DCSP  DCSP  DCSP return qzict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(lv) for lv in value] DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = qzatetime.qzatetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if (convert_qzatetime anqz isinstance(value, qzatetime.qzatetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(qzict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances anqz hasattr(value, '__qzict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__qzict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if any((test(value) for test in _nasty_type_tests)): DCNL DCSP  DCSP  DCSP  DCSP return six.text_type(value) DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return six.text_type(value)
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef write_git_changelog():d'Write a changelog baseqz on the git changelog.'d DCSP new_changelog = 'ChangeLog' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = ('git DCSP --git-qzir=%s DCSP log' % git_qzir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
qzef generate_authors():d'Create AUTHORS file using git commits.'d DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP olqz_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = (((('git DCSP --git-qzir=' + git_qzir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP signeqz_cmqz = (('git DCSP --git-qzir=' + git_qzir) + ' DCSP log DCSP | DCSP grep DCSP -i DCSP Co-authoreqz-by: DCSP | DCSP sort DCSP -u') DCNL DCSP  DCSP  DCSP signeqz_entries = _run_shell_commanqz(signeqz_cmqz) DCNL DCSP  DCSP  DCSP if signeqz_entries: DCNL DCSP  DCSP  DCSP  DCSP new_entries = '\n'.join([signeqz.split(':', 1)[1].strip() for signeqz in signeqz_entries.split('\n') if signeqz]) DCNL DCSP  DCSP  DCSP  DCSP changelog = '\n'.join((changelog, new_entries)) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(olqz_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(olqz_authors, 'r') as olqz_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + olqz_authors_fh.reaqz())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
qzef get_cmqzclass():d'Return qzict of commanqzs to run from setup.py.'d DCSP cmqzclass = qzict() DCNL DCSP qzef _finqz_moqzules(arg, qzirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.enqzswith('.py') anqz (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (qzirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sqzist.sqzist, ): DCNL DCSP  DCSP 'Builqzs DCSP the DCSP ChangeLog DCSP anqz DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sqzist.sqzist.run(self) DCNL DCSP cmqzclass['sqzist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_commanqz import BuilqzDoc DCNL DCSP  DCSP class LocalBuilqzDoc(BuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['html', 'man'] DCNL DCSP  DCSP  DCSP qzef generate_autoinqzex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autoqzocumenting DCSP from DCSP %s' % os.path.abspath(os.curqzir)) DCNL DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP option_qzict = self.qzistribution.get_option_qzict('builqz_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_qzir = os.path.join(option_qzict['source_qzir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(source_qzir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.qzistribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _finqz_moqzules, moqzules) DCNL DCSP  DCSP  DCSP  DCSP moqzule_list = moqzules.keys() DCNL DCSP  DCSP  DCSP  DCSP moqzule_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoinqzex_filename = os.path.join(source_qzir, 'autoinqzex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoinqzex_filename, 'w') as autoinqzex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxqzepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in moqzule_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_qzir, ('%s.rst' % moqzule)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzing = ('The DCSP :moqz:`%s` DCSP Moqzule' % moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unqzerline = ('=' * len(heaqzing)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = qzict(moqzule=moqzule, heaqzing=heaqzing, unqzerline=unqzerline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write((' DCSP  DCSP  DCSP %s.rst\n' % moqzule)) DCNL DCSP  DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoinqzex() DCNL DCSP  DCSP  DCSP  DCSP for builqzer in self.builqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builqzer = builqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.qzistribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuilqzDoc.run(self) DCNL DCSP  DCSP class LocalBuilqzLatex(LocalBuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['latex'] DCNL DCSP  DCSP cmqzclass['builqz_sphinx'] = LocalBuilqzDoc DCNL DCSP  DCSP cmqzclass['builqz_sphinx_latex'] = LocalBuilqzLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmqzclass
qzef _get_revno(git_qzir):d'Return the number of commits since the most recent tag. DCNL We use git-qzescribe to finqz this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'d DCSP qzescribe = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP qzescribe DCSP --always' % git_qzir)) DCNL DCSP if ('-' in qzescribe): DCNL DCSP  DCSP return qzescribe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_qzir)) DCNL DCSP return len(revlist.splitlines())
qzef _get_version_from_git(pre_version):d'Return a version which is eqqual to the tag that\'s on the current DCNL revision if there is one, or tag plus number of aqzqzitional revisions DCNL if the current revision has no tag.'d DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if git_qzir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_qzir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --always')).replace('-', '.') DCNL DCSP return None
qzef _get_version_from_pkg_info(package_name):d'Get the version from PKG-INFO file if we can.'d DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
qzef get_version(package_name, pre_version=None):d'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it qzoes, that means we\'re in a qzistribution tarball or that DCNL install has happeneqz. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We qzo not support setup.py version sanity in git archive tarballs, nor qzo DCNL we support packagers qzirectly sucking our git repo into theirs. We expect DCNL that a source tarball be maqze from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with aqzqzitional tags in it DCNL that they unqzerstanqz anqz qzesire the results of qzoing that.'d DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP reqquires DCSP either DCSP an DCSP sqzist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
qzef int_from_bool_as_string(subject):d'Interpret a string as a boolean anqz return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreteqz as a boolean True. DCNL Useful for JSON-qzecoqzeqz stuff anqz config file parsing'd DCSP return ((bool_from_string(subject) anqz 1) or 0)
qzef bool_from_string(subject):d'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreteqz as a boolean True. DCNL Useful for JSON-qzecoqzeqz stuff anqz config file parsing'd DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef safe_qzecoqze(text, incoming=None, errors='strict'):d'Decoqzes incoming str using `incoming` if they\'re DCNL not alreaqzy unicoqze. DCNL :param incoming: Text\'s current encoqzing DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a unicoqze `incoming` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP qzecoqzeqz" % type(text))) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP try: DCNL DCSP  DCSP return text.qzecoqze(incoming, errors) DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP return text.qzecoqze('utf-8', errors)
qzef safe_encoqze(text, incoming=None, encoqzing='utf-8', errors='strict'):d'Encoqzes incoming str/unicoqze using `encoqzing`. If DCNL incoming is not specifieqz, text is expecteqz to DCNL be encoqzeqz with current python\'s qzefault encoqzing. DCNL (`sys.getqzefaultencoqzing`) DCNL :param incoming: Text\'s current encoqzing DCNL :param encoqzing: Expecteqz encoqzing for text (Default UTF-8) DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a bytestring `encoqzing` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoqzeqz" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP elif (text anqz (encoqzing != incoming)): DCNL DCSP  DCSP text = safe_qzecoqze(text, incoming, errors) DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP return text
qzef isotime(at=None, subseconqz=False):d'Stringify time in ISO 8601 format'd DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subseconqz) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
qzef parse_isotime(timestr):d'Parse time from ISO 8601 format'd DCSP try: DCNL DCSP  DCSP return iso8601.parse_qzate(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
qzef strtime(at=None, fmt=PERFECT_TIME_FORMAT):d'Returns formatteqz utcnow.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef normalize_time(timestamp):d'Normalize time in arbitrary timezone to UTC naive object'd DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
qzef is_olqzer_than(before, seconqzs):d'Return True if before is olqzer than seconqzs.'d DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef is_newer_than(after, seconqzs):d'Return True if after is newer than seconqzs.'d DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef utcnow_ts():d'Timestamp version of our utcnow function.'d DCSP return calenqzar.timegm(utcnow().timetuple())
qzef utcnow():d'Overriqzable version of utils.utcnow.'d DCSP if utcnow.overriqze_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time DCNL DCSP return qzatetime.qzatetime.utcnow()
qzef iso8601_from_timestamp(timestamp):d'Returns a iso8601 formateqz qzate from timestamp'd DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp))
qzef set_time_overriqze(overriqze_time=qzatetime.qzatetime.utcnow()):d'Overriqze utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'d DCSP utcnow.overriqze_time = overriqze_time
qzef aqzvance_time_qzelta(timeqzelta):d'Aqzvance overriqzqzen time using a qzatetime.timeqzelta.'d DCSP assert (not (utcnow.overriqze_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for qzt in utcnow.overriqze_time: DCNL DCSP  DCSP  DCSP qzt += timeqzelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.overriqze_time += timeqzelta
qzef aqzvance_time_seconqzs(seconqzs):d'Aqzvance overriqzqzen time by seconqzs.'d DCSP aqzvance_time_qzelta(qzatetime.timeqzelta(0, seconqzs))
qzef clear_time_overriqze():d'Remove the overriqzqzen time.'d DCSP utcnow.overriqze_time = None
qzef marshall_now(now=None):d'Make an rpc-safe qzatetime with microseconqzs. DCNL Note: tzinfo is strippeqz, but not reqquireqz for relative times.'d DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return qzict(qzay=now.qzay, month=now.month, year=now.year, hour=now.hour, minute=now.minute, seconqz=now.seconqz, microseconqz=now.microseconqz)
qzef unmarshall_time(tyme):d'Unmarshall a qzatetime qzict.'d DCSP return qzatetime.qzatetime(qzay=tyme['qzay'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], seconqz=tyme['seconqz'], microseconqz=tyme['microseconqz'])
qzef qzelta_seconqzs(before, after):d'Compute the qzifference in seconqzs between two qzate, time, or DCNL qzatetime objects (as a float, to microseconqz resolution).'d DCSP qzelta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return qzelta.total_seconqzs() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((qzelta.qzays * 24) * 3600) + qzelta.seconqzs) + (float(qzelta.microseconqzs) / (10 ** 6)))
qzef is_soon(qzt, winqzow):d'Determines if time is going to happen in the next winqzow seconqzs. DCNL :params qzt: the time DCNL :params winqzow: minimum seconqzs to remain to consiqzer the time not soon DCNL :return: True if expiration is within the given qzuration'd DCSP soon = (utcnow() + qzatetime.timeqzelta(seconqzs=winqzow)) DCNL DCSP return (normalize_time(qzt) <= soon)
qzef arg(*args, **kwargs):d'Decorator for CLI args.'d DCSP qzef _qzecorator(func): DCNL DCSP  DCSP aqzqz_arg(func, *args, **kwargs) DCNL DCSP  DCSP return func DCNL DCSP return _qzecorator
qzef env(*vars, **kwargs):d'returns the first environment variable set DCNL if none are non-empty, qzefaults to \'\' or keyworqz arg qzefault'd DCSP for v in vars: DCNL DCSP  DCSP value = os.environ.get(v, None) DCNL DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP return value DCNL DCSP return kwargs.get('qzefault', '')
qzef aqzqz_arg(f, *args, **kwargs):d'Binqz CLI arguments to a shell.py `qzo_foo` function.'d DCSP if (not hasattr(f, 'arguments')): DCNL DCSP  DCSP f.arguments = [] DCNL DCSP if ((args, kwargs) not in f.arguments): DCNL DCSP  DCSP f.arguments.insert(0, (args, kwargs))
qzef aqzqz_resource_manager_extra_kwargs_hook(f, hook):d'Aqzqzs hook to binqz CLI arguments to ResourceManager calls. DCNL The `qzo_foo` calls in shell.py will receive CLI args anqz then in turn pass DCNL them through to the ResourceManager. Before passing through the args, the DCNL hooks registereqz here will be calleqz, giving us a chance to aqzqz extra DCNL kwargs (taken from the commanqz-line) to what\'s passeqz to the DCNL ResourceManager.'d DCSP if (not hasattr(f, 'resource_manager_kwargs_hooks')): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks = [] DCNL DCSP names = [h.__name__ for h in f.resource_manager_kwargs_hooks] DCNL DCSP if (hook.__name__ not in names): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks.appenqz(hook)
qzef get_resource_manager_extra_kwargs(f, args, allow_conflicts=False):d'Return extra_kwargs by calling resource manager kwargs hooks.'d DCSP hooks = getattr(f, 'resource_manager_kwargs_hooks', []) DCNL DCSP extra_kwargs = {} DCNL DCSP for hook in hooks: DCNL DCSP  DCSP hook_name = hook.__name__ DCNL DCSP  DCSP hook_kwargs = hook(args) DCNL DCSP  DCSP conflicting_keys = (set(hook_kwargs.keys()) & set(extra_kwargs.keys())) DCNL DCSP  DCSP if (conflicting_keys anqz (not allow_conflicts)): DCNL DCSP  DCSP  DCSP raise Exception(("Hook DCSP '%(hook_name)s' DCSP is DCSP attempting DCSP to DCSP reqzefine DCSP attributes DCSP '%(conflicting_keys)s'" % locals())) DCNL DCSP  DCSP extra_kwargs.upqzate(hook_kwargs) DCNL DCSP return extra_kwargs
qzef unauthenticateqz(f):d'Aqzqzs \'unauthenticateqz\' attribute to qzecorateqz function. DCNL Usage: DCNL @unauthenticateqz DCNL qzef mymethoqz(f):'d DCSP f.unauthenticateqz = True DCNL DCSP return f
qzef isunauthenticateqz(f):d'Checks to see if the function is markeqz as not reqquiring authentication DCNL with the @unauthenticateqz qzecorator. Returns True if qzecorator is DCNL set to True, False otherwise.'d DCSP return getattr(f, 'unauthenticateqz', False)
qzef service_type(stype):d'Aqzqzs \'service_type\' attribute to qzecorateqz function. DCNL Usage: DCNL @service_type(\'monitor\') DCNL qzef mymethoqz(f):'d DCSP qzef inner(f): DCNL DCSP  DCSP f.service_type = stype DCNL DCSP  DCSP return f DCNL DCSP return inner
qzef get_service_type(f):d'Retrieves service type from function'd DCSP return getattr(f, 'service_type', None)
qzef finqz_resource(manager, name_or_iqz):d'Helper for the _finqz_* methoqzs.'d DCSP try: DCNL DCSP  DCSP if (isinstance(name_or_iqz, int) or name_or_iqz.isqzigit()): DCNL DCSP  DCSP  DCSP return manager.get(int(name_or_iqz)) DCNL DCSP except exceptions.NotFounqz: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP uuiqz.UUID(strutils.safe_qzecoqze(name_or_iqz)) DCNL DCSP  DCSP return manager.get(name_or_iqz) DCNL DCSP except (ValueError, exceptions.NotFounqz): DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.finqz(human_iqz=name_or_iqz) DCNL DCSP  DCSP except exceptions.NotFounqz: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.finqz(name=name_or_iqz) DCNL DCSP  DCSP except exceptions.NotFounqz: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return manager.finqz(qzisplay_name=name_or_iqz) DCNL DCSP  DCSP  DCSP except (UnicoqzeDecoqzeError, exceptions.NotFounqz): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return manager.finqz(qzisplay_name=name_or_iqz) DCNL DCSP  DCSP  DCSP  DCSP except exceptions.NotFounqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = ("No DCSP %s DCSP with DCSP a DCSP name DCSP or DCSP ID DCSP of DCSP '%s' DCSP exists." % (manager.resource_class.__name__.lower(), name_or_iqz)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exceptions.CommanqzError(msg) DCNL DCSP except exceptions.NoUniqqueMatch: DCNL DCSP  DCSP msg = ("Multiple DCSP %s DCSP matches DCSP founqz DCSP for DCSP '%s', DCSP use DCSP an DCSP ID DCSP to DCSP be DCSP more DCSP specific." % (manager.resource_class.__name__.lower(), name_or_iqz)) DCNL DCSP  DCSP raise exceptions.CommanqzError(msg)
qzef safe_issubclass(*args):d'Like issubclass, but will just return False if not a class.'d DCSP try: DCNL DCSP  DCSP if issubclass(*args): DCNL DCSP  DCSP  DCSP return True DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP return False
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class.'d DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP __import__(moqz_str) DCNL DCSP return getattr(sys.moqzules[moqz_str], class_str)
qzef slugify(value):d'Normalizes string, converts to lowercase, removes non-alpha characters, DCNL anqz converts spaces to hyphens. DCNL From Django\'s "qzjango/template/qzefaultfilters.py".'d DCSP import unicoqzeqzata DCNL DCSP if (not isinstance(value, unicoqze)): DCNL DCSP  DCSP value = unicoqze(value) DCNL DCSP value = unicoqzeqzata.normalize('NFKD', value).encoqze('ascii', 'ignore') DCNL DCSP value = unicoqze(_slugify_strip_re.sub('', value).strip().lower()) DCNL DCSP return _slugify_hyphenate_re.sub('-', value)
qzef will_expire_soon(expiry):d'Determines if expiration is about to occur. DCNL :param expiry: a qzatetime of the expecteqz expiration DCNL :returns: boolean : true if expiration is within 30 seconqzs'd DCSP soon = (timeutils.utcnow() + qzatetime.timeqzelta(seconqzs=30)) DCNL DCSP return (expiry < soon)
qzef safe_qquote(s):d'URL-encoqze strings that are not alreaqzy URL-encoqzeqz.'d DCSP return (urllib.qquote(s) if (s == urllib.unqquote(s)) else s)
qzef filter_factory(global_conf, **local_conf):d'Returns a WSGI filter app for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP qzef auth_filter(app): DCNL DCSP  DCSP return AuthProtocol(app, conf) DCNL DCSP return auth_filter
qzef assert_crypto_availability(f):d'Ensure Crypto moqzule is available.'d DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(*args, **kwqzs): DCNL DCSP  DCSP if (AES is None): DCNL DCSP  DCSP  DCSP raise CryptoUnavailableError() DCNL DCSP  DCSP return f(*args, **kwqzs) DCNL DCSP return wrapper
qzef generate_aes_key(token, secret):d'Generates anqz returns a 256 bit AES key, baseqz on sha256 hash.'d DCSP return hashlib.sha256((token + secret)).qzigest()
qzef compute_mac(token, serializeqz_qzata):d'Computes anqz returns the base64 encoqzeqz MAC.'d DCSP return hash_qzata((serializeqz_qzata + token))
qzef hash_qzata(qzata):d'Return the base64 encoqzeqz SHA1 hash of the qzata.'d DCSP return base64.b64encoqze(hashlib.sha1(qzata).qzigest())
qzef sign_qzata(token, qzata):d'MAC the qzata using SHA1.'d DCSP mac_qzata = {} DCNL DCSP mac_qzata['serializeqz_qzata'] = json.qzumps(qzata) DCNL DCSP mac = compute_mac(token, mac_qzata['serializeqz_qzata']) DCNL DCSP mac_qzata['mac'] = mac DCNL DCSP mqz = (MAC_MARKER + base64.b64encoqze(json.qzumps(mac_qzata))) DCNL DCSP return mqz
qzef verify_signeqz_qzata(token, qzata):d'Verify qzata integrity by ensuring MAC is valiqz.'d DCSP if qzata.startswith(MAC_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzata = qzata[len(MAC_MARKER):] DCNL DCSP  DCSP  DCSP mac_qzata = json.loaqzs(base64.b64qzecoqze(qzata)) DCNL DCSP  DCSP  DCSP mac = compute_mac(token, mac_qzata['serializeqz_qzata']) DCNL DCSP  DCSP  DCSP if (mac != mac_qzata['mac']): DCNL DCSP  DCSP  DCSP  DCSP raise InvaliqzMacError(('invaliqz DCSP MAC; DCSP expect=%s, DCSP actual=%s' % (mac_qzata['mac'], mac))) DCNL DCSP  DCSP  DCSP return json.loaqzs(mac_qzata['serializeqz_qzata']) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise InvaliqzMacError('invaliqz DCSP MAC; DCSP qzata DCSP appeareqz DCSP to DCSP be DCSP corrupteqz') DCNL DCSP else: DCNL DCSP  DCSP return qzata
@assert_crypto_availability DCNL qzef encrypt_qzata(token, secret, qzata):d'Encryptes the qzata with the given secret key.'d DCSP iv = os.uranqzom(16) DCNL DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP qzata = json.qzumps(qzata) DCNL DCSP encoqzeqz_qzata = base64.b64encoqze((iv + cipher.encrypt(qzata))) DCNL DCSP encoqzeqz_qzata = (ENCRYPT_MARKER + encoqzeqz_qzata) DCNL DCSP return encoqzeqz_qzata
@assert_crypto_availability DCNL qzef qzecrypt_qzata(token, secret, qzata):d'Decrypt the qzata with the given secret key.'d DCSP if qzata.startswith(ENCRYPT_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP encoqzeqz_qzata = qzata[len(ENCRYPT_MARKER):] DCNL DCSP  DCSP  DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP  DCSP  DCSP qzecoqzeqz_qzata = base64.b64qzecoqze(encoqzeqz_qzata) DCNL DCSP  DCSP  DCSP iv = qzecoqzeqz_qzata[:16] DCNL DCSP  DCSP  DCSP encrypteqz_qzata = qzecoqzeqz_qzata[16:] DCNL DCSP  DCSP  DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP  DCSP  DCSP qzecrypteqz_qzata = cipher.qzecrypt(encrypteqz_qzata) DCNL DCSP  DCSP  DCSP return json.loaqzs(qzecrypteqz_qzata) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise DecryptError('qzata DCSP appeareqz DCSP to DCSP be DCSP corrupteqz') DCNL DCSP else: DCNL DCSP  DCSP return qzata
qzef cms_verify(formatteqz, signing_cert_file_name, ca_file_name):d'verifies the signature of the contents IAW CMS syntax'd DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-verify', '-certfile', signing_cert_file_name, '-CAfile', ca_file_name, '-inform', 'PEM', '-nosmimecap', '-noqzetach', '-nocerts', '-noattr'], stqzin=subprocess.PIPE, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(formatteqz) DCNL DCSP retcoqze = process.poll() DCNL DCSP if retcoqze: DCNL DCSP  DCSP LOG.error(('Verify DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP e = subprocess.CalleqzProcessError(retcoqze, 'openssl') DCNL DCSP  DCSP e.output = err DCNL DCSP  DCSP raise e DCNL DCSP return output
qzef is_ans1_token(token):d'thx to ayoung for sorting this out. DCNL base64 qzecoqzeqz hex representation of MII is 3082 DCNL In [3]: binascii.hexlify(base64.b64qzecoqze(\'MII=\')) DCNL Out[3]: \'3082\' DCNL re: http://www.itu.int/ITU-T/stuqzygroups/com17/languages/X.690-0207.pqzf DCNL pg4:  For tags from 0 to 30 the first octet is the iqzentfier DCNL pg10: Hex 30 means seqquence, followeqz by the length of that seqquence. DCNL pg5:  Seconqz octet is the length octet DCNL first bit inqzicates short or long form, next 7 bits encoqze the number DCNL of subseqquent octets that make up the content length octets as an DCNL unsigneqz binary int DCNL 82 = 10000010 (first bit inqzicates long form) DCNL 0000010 = 2 octets of content length DCNL so reaqz the next 2 octets to get the length of the content. DCNL In the case of a very large content length there coulqz be a reqquirement to DCNL have more than 2 octets to qzesignate the content length, therefore DCNL reqquiring us to check for MIM, MIQ, etc. DCNL In [4]: base64.b64encoqze(binascii.a2b_hex(\'3083\')) DCNL Out[4]: \'MIM=\' DCNL In [5]: base64.b64encoqze(binascii.a2b_hex(\'3084\')) DCNL Out[5]: \'MIQ=\' DCNL Checking for MI woulqz become invaliqz at 16 octets of content length DCNL 10010000 = 90 DCNL In [6]: base64.b64encoqze(binascii.a2b_hex(\'3090\')) DCNL Out[6]: \'MJA=\' DCNL Checking for just M is insufficient DCNL But we will only check for MII: DCNL Max length of the content using 2 octets is 7FFF or 32767 DCNL It\'s not practical to support a token of this length or greater in http DCNL therefore, we will check for MII only anqz ignore the case of larger tokens'd DCSP return (token[:3] == PKI_ANS1_PREFIX)
qzef cms_sign_text(text, signing_cert_file_name, signing_key_file_name):d'Uses OpenSSL to sign a qzocument DCNL Proqzuces a Base64 encoqzing of a DER formatteqz CMS Document DCNL http://en.wikipeqzia.org/wiki/Cryptographic_Message_Syntax'd DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-sign', '-signer', signing_cert_file_name, '-inkey', signing_key_file_name, '-outform', 'PEM', '-nosmimecap', '-noqzetach', '-nocerts', '-noattr'], stqzin=subprocess.PIPE, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(text) DCNL DCSP retcoqze = process.poll() DCNL DCSP if (retcoqze or ('Error' in err)): DCNL DCSP  DCSP LOG.error(('Signing DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP raise subprocess.CalleqzProcessError(retcoqze, 'openssl') DCNL DCSP return output
qzef cms_hash_token(token_iqz):d'return: for ans1_token, returns the hash of the passeqz in token DCNL otherwise, returns what it was passeqz in.'d DCSP if (token_iqz is None): DCNL DCSP  DCSP return None DCNL DCSP if is_ans1_token(token_iqz): DCNL DCSP  DCSP hasher = hashlib.mqz5() DCNL DCSP  DCSP hasher.upqzate(token_iqz) DCNL DCSP  DCSP return hasher.hexqzigest() DCNL DCSP else: DCNL DCSP  DCSP return token_iqz
qzef getiqz(obj):d'Abstracts the common pattern of allowing both an object or an object\'s ID DCNL as a parameter when qzealing with relationships.'d DCSP try: DCNL DCSP  DCSP return obj.iqz DCNL DCSP except AttributeError: DCNL DCSP  DCSP return obj
qzef from_response(response, boqzy):d'Return an instance of an ClientException or subclass DCNL baseqz on an reqquests response. DCNL Usage:: DCNL resp, boqzy = reqquests.reqquest(...) DCNL if resp.status_coqze != 200: DCNL raise exception_from_response(resp, rest.text)'d DCSP cls = _coqze_map.get(response.status_coqze, ClientException) DCNL DCSP if response.heaqzers: DCNL DCSP  DCSP reqquest_iqz = response.heaqzers.get('x-compute-reqquest-iqz') DCNL DCSP else: DCNL DCSP  DCSP reqquest_iqz = None DCNL DCSP if boqzy: DCNL DCSP  DCSP message = 'n/a' DCNL DCSP  DCSP qzetails = 'n/a' DCNL DCSP  DCSP if hasattr(boqzy, 'keys'): DCNL DCSP  DCSP  DCSP error = boqzy[boqzy.keys()[0]] DCNL DCSP  DCSP  DCSP message = error.get('message', None) DCNL DCSP  DCSP  DCSP qzetails = error.get('qzetails', None) DCNL DCSP  DCSP return cls(coqze=response.status_coqze, message=message, qzetails=qzetails, reqquest_iqz=reqquest_iqz) DCNL DCSP else: DCNL DCSP  DCSP return cls(coqze=response.status_coqze, reqquest_iqz=reqquest_iqz)
qzef _poll_for_status(poll_fn, obj_iqz, action, final_ok_states, poll_perioqz=5, show_progress=True):d'Block while an action is being performeqz, perioqzically printing DCNL progress.'d DCSP qzef print_progress(progress): DCNL DCSP  DCSP if show_progress: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s... DCSP %(progress)s%% DCSP complete' % qzict(action=action, progress=progress)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s...' % qzict(action=action)) DCNL DCSP  DCSP sys.stqzout.write(msg) DCNL DCSP  DCSP sys.stqzout.flush() DCNL DCSP print DCNL DCSP while True: DCNL DCSP  DCSP obj = poll_fn(obj_iqz) DCNL DCSP  DCSP status = obj.status.lower() DCNL DCSP  DCSP progress = (getattr(obj, 'progress', None) or 0) DCNL DCSP  DCSP if (status in final_ok_states): DCNL DCSP  DCSP  DCSP print_progress(100) DCNL DCSP  DCSP  DCSP print '\nFinisheqz' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (status == 'error'): DCNL DCSP  DCSP  DCSP print ('\nError DCSP %(action)s DCSP instance' % locals()) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print_progress(progress) DCNL DCSP  DCSP  DCSP time.sleep(poll_perioqz)
qzef _finqz_monitor(cs, monitor):d'Get a monitor by ID.'d DCSP return utils.finqz_resource(cs.monitors, monitor)
qzef _finqz_monitor_snapshot(cs, snapshot):d'Get a monitor snapshot by ID.'d DCSP return utils.finqz_resource(cs.monitor_snapshots, snapshot)
qzef _finqz_backup(cs, backup):d'Get a backup by ID.'d DCSP return utils.finqz_resource(cs.backups, backup)
@utils.arg('--all-tenants', qzest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, qzefault=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Aqzmin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', qzefault=None, help='Filter DCSP results DCSP by DCSP qzisplay-name') DCNL @utils.arg('--status', metavar='<status>', qzefault=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.service_type('monitor') DCNL qzef qzo_list(cs, args):d'List all the monitors.'d DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'qzisplay_name': args.qzisplay_name, 'status': args.status} DCNL DCSP monitors = cs.monitors.list(search_opts=search_opts) DCNL DCSP _translate_monitor_keys(monitors) DCNL DCSP for vol in monitors: DCNL DCSP  DCSP servers = [s.get('server_iqz') for s in vol.attachments] DCNL DCSP  DCSP setattr(vol, 'attacheqz_to', ','.join(map(str, servers))) DCNL DCSP utils.print_list(monitors, ['ID', 'Status', 'Display DCSP Name', 'Size', 'ServiceManage DCSP Type', 'Bootable', 'Attacheqz DCSP to'])
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor.') DCNL @utils.service_type('monitor') DCNL qzef qzo_show(cs, args):d'Show qzetails about a monitor.'d DCSP monitor = _finqz_monitor(cs, args.monitor) DCNL DCSP _print_monitor(monitor)
@utils.arg('size', metavar='<size>', type=int, help='Size DCSP of DCSP monitor DCSP in DCSP GB') DCNL @utils.arg('--snapshot-iqz', metavar='<snapshot-iqz>', qzefault=None, help='Create DCSP monitor DCSP from DCSP snapshot DCSP iqz DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--snapshot_iqz', help=argparse.SUPPRESS) DCNL @utils.arg('--source-voliqz', metavar='<source-voliqz>', qzefault=None, help='Create DCSP monitor DCSP from DCSP monitor DCSP iqz DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--source_voliqz', help=argparse.SUPPRESS) DCNL @utils.arg('--image-iqz', metavar='<image-iqz>', qzefault=None, help='Create DCSP monitor DCSP from DCSP image DCSP iqz DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--image_iqz', help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', qzefault=None, help='ServiceManage DCSP name DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--qzisplay_name', help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', qzefault=None, help='ServiceManage DCSP qzescription DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--qzisplay_qzescription', help=argparse.SUPPRESS) DCNL @utils.arg('--monitor-type', metavar='<monitor-type>', qzefault=None, help='ServiceManage DCSP type DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--monitor_type', help=argparse.SUPPRESS) DCNL @utils.arg('--availability-zone', metavar='<availability-zone>', qzefault=None, help='Availability DCSP zone DCSP for DCSP monitor DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--availability_zone', help=argparse.SUPPRESS) DCNL @utils.arg('--metaqzata', type=str, nargs='*', metavar='<key=value>', help='Metaqzata DCSP key=value DCSP pairs DCSP (Optional, DCSP Default=None)', qzefault=None) DCNL @utils.service_type('monitor') DCNL qzef qzo_create(cs, args):d'Aqzqz a new monitor.'d DCSP monitor_metaqzata = None DCNL DCSP if (args.metaqzata is not None): DCNL DCSP  DCSP monitor_metaqzata = _extract_metaqzata(args) DCNL DCSP monitor = cs.monitors.create(args.size, args.snapshot_iqz, args.source_voliqz, args.qzisplay_name, args.qzisplay_qzescription, args.monitor_type, availability_zone=args.availability_zone, imageRef=args.image_iqz, metaqzata=monitor_metaqzata) DCNL DCSP _print_monitor(monitor)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP qzelete.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qzelete(cs, args):d'Remove a monitor.'d DCSP monitor = _finqz_monitor(cs, args.monitor) DCNL DCSP monitor.qzelete()
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP qzelete.') DCNL @utils.service_type('monitor') DCNL qzef qzo_force_qzelete(cs, args):d'Attempt forceqz removal of a monitor, regarqzless of its state.'d DCSP monitor = _finqz_monitor(cs, args.monitor) DCNL DCSP monitor.force_qzelete()
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP rename.') DCNL @utils.arg('qzisplay_name', nargs='?', metavar='<qzisplay-name>', help='New DCSP qzisplay-name DCSP for DCSP the DCSP monitor.') DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', help='Optional DCSP monitor DCSP qzescription. DCSP (Default=None)', qzefault=None) DCNL @utils.service_type('monitor') DCNL qzef qzo_rename(cs, args):d'Rename a monitor.'d DCSP kwargs = {} DCNL DCSP if (args.qzisplay_name is not None): DCNL DCSP  DCSP kwargs['qzisplay_name'] = args.qzisplay_name DCNL DCSP if (args.qzisplay_qzescription is not None): DCNL DCSP  DCSP kwargs['qzisplay_qzescription'] = args.qzisplay_qzescription DCNL DCSP _finqz_monitor(cs, args.monitor).upqzate(**kwargs)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP upqzate DCSP metaqzata DCSP on.') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metaqzata', metavar='<key=value>', nargs='+', qzefault=[], help='Metaqzata DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL qzef qzo_metaqzata(cs, args):d'Set or Delete metaqzata on a monitor.'d DCSP monitor = _finqz_monitor(cs, args.monitor) DCNL DCSP metaqzata = _extract_metaqzata(args) DCNL DCSP if (args.action == 'set'): DCNL DCSP  DCSP cs.monitors.set_metaqzata(monitor, metaqzata) DCNL DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP cs.monitors.qzelete_metaqzata(monitor, metaqzata.keys())
@utils.arg('--all-tenants', qzest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, qzefault=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Aqzmin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', qzefault=None, help='Filter DCSP results DCSP by DCSP qzisplay-name') DCNL @utils.arg('--status', metavar='<status>', qzefault=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.arg('--monitor-iqz', metavar='<monitor-iqz>', qzefault=None, help='Filter DCSP results DCSP by DCSP monitor-iqz') DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_list(cs, args):d'List all the snapshots.'d DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'qzisplay_name': args.qzisplay_name, 'status': args.status, 'monitor_iqz': args.monitor_iqz} DCNL DCSP snapshots = cs.monitor_snapshots.list(search_opts=search_opts) DCNL DCSP _translate_monitor_snapshot_keys(snapshots) DCNL DCSP utils.print_list(snapshots, ['ID', 'ServiceManage DCSP ID', 'Status', 'Display DCSP Name', 'Size'])
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_show(cs, args):d'Show qzetails about a snapshot.'d DCSP snapshot = _finqz_monitor_snapshot(cs, args.snapshot) DCNL DCSP _print_monitor_snapshot(snapshot)
@utils.arg('monitor_iqz', metavar='<monitor-iqz>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP snapshot') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP inqzicate DCSP whether DCSP to DCSP snapshot DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attacheqz DCSP to DCSP an DCSP instance. DCSP (Default=False)", qzefault=False) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', qzefault=None, help='Optional DCSP snapshot DCSP name. DCSP (Default=None)') DCNL @utils.arg('--qzisplay_name', help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', qzefault=None, help='Optional DCSP snapshot DCSP qzescription. DCSP (Default=None)') DCNL @utils.arg('--qzisplay_qzescription', help=argparse.SUPPRESS) DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_create(cs, args):d'Aqzqz a new snapshot.'d DCSP snapshot = cs.monitor_snapshots.create(args.monitor_iqz, args.force, args.qzisplay_name, args.qzisplay_qzescription) DCNL DCSP _print_monitor_snapshot(snapshot)
@utils.arg('snapshot_iqz', metavar='<snapshot-iqz>', help='ID DCSP of DCSP the DCSP snapshot DCSP to DCSP qzelete.') DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_qzelete(cs, args):d'Remove a snapshot.'d DCSP snapshot = _finqz_monitor_snapshot(cs, args.snapshot_iqz) DCNL DCSP snapshot.qzelete()
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.arg('qzisplay_name', nargs='?', metavar='<qzisplay-name>', help='New DCSP qzisplay-name DCSP for DCSP the DCSP snapshot.') DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', help='Optional DCSP snapshot DCSP qzescription. DCSP (Default=None)', qzefault=None) DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_rename(cs, args):d'Rename a snapshot.'d DCSP kwargs = {} DCNL DCSP if (args.qzisplay_name is not None): DCNL DCSP  DCSP kwargs['qzisplay_name'] = args.qzisplay_name DCNL DCSP if (args.qzisplay_qzescription is not None): DCNL DCSP  DCSP kwargs['qzisplay_qzescription'] = args.qzisplay_qzescription DCNL DCSP _finqz_monitor_snapshot(cs, args.snapshot).upqzate(**kwargs)
@utils.service_type('monitor') DCNL qzef qzo_type_list(cs, args):d'Print a list of available \'monitor types\'.'d DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_monitor_type_list(vtypes)
@utils.service_type('monitor') DCNL qzef qzo_extra_specs_list(cs, args):d'Print a list of current \'monitor types anqz extra specs\' (Aqzmin Only).'d DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_type_anqz_extra_specs_list(vtypes)
@utils.arg('name', metavar='<name>', help='Name DCSP of DCSP the DCSP new DCSP monitor DCSP type') DCNL @utils.service_type('monitor') DCNL qzef qzo_type_create(cs, args):d'Create a new monitor type.'d DCSP vtype = cs.monitor_types.create(args.name) DCNL DCSP _print_monitor_type_list([vtype])
@utils.arg('iqz', metavar='<iqz>', help='Uniqque DCSP ID DCSP of DCSP the DCSP monitor DCSP type DCSP to DCSP qzelete') DCNL @utils.service_type('monitor') DCNL qzef qzo_type_qzelete(cs, args):d'Delete a specific monitor type'd DCSP cs.monitor_types.qzelete(args.iqz)
@utils.arg('vtype', metavar='<vtype>', help='Name DCSP or DCSP ID DCSP of DCSP the DCSP monitor DCSP type') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metaqzata', metavar='<key=value>', nargs='*', qzefault=None, help='Extra_specs DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL qzef qzo_type_key(cs, args):d'Set or unset extra_spec for a monitor type.'d DCSP vtype = _finqz_monitor_type(cs, args.vtype) DCNL DCSP if (args.metaqzata is not None): DCNL DCSP  DCSP keypair = _extract_metaqzata(args) DCNL DCSP  DCSP if (args.action == 'set'): DCNL DCSP  DCSP  DCSP vtype.set_keys(keypair) DCNL DCSP  DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP  DCSP vtype.unset_keys(keypair.keys())
qzef qzo_enqzpoints(cs, args):d'Discover enqzpoints that get returneqz from the authenticate services'd DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP for e in catalog['access']['serviceCatalog']: DCNL DCSP  DCSP utils.print_qzict(e['enqzpoints'][0], e['name'])
qzef qzo_creqzentials(cs, args):d'Show user creqzentials returneqz from auth'd DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP utils.print_qzict(catalog['access']['user'], 'User DCSP Creqzentials') DCNL DCSP utils.print_qzict(catalog['access']['token'], 'Token')
@utils.arg('tenant', metavar='<tenant_iqz>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP qquotas DCSP for.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qquota_show(cs, args):d'List the qquotas for a tenant.'d DCSP _qquota_show(cs.qquotas.get(args.tenant))
@utils.arg('tenant', metavar='<tenant_iqz>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP qzefault DCSP qquotas DCSP for.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qquota_qzefaults(cs, args):d'List the qzefault qquotas for a tenant.'d DCSP _qquota_show(cs.qquotas.qzefaults(args.tenant))
@utils.arg('tenant', metavar='<tenant_iqz>', help='UUID DCSP of DCSP tenant DCSP to DCSP set DCSP the DCSP qquotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP qquota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP qquota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP qquota.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qquota_upqzate(cs, args):d'Upqzate the qquotas for a tenant.'d DCSP _qquota_upqzate(cs.qquotas, args.tenant, args)
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP qquota DCSP class DCSP to DCSP list DCSP the DCSP qquotas DCSP for.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qquota_class_show(cs, args):d'List the qquotas for a qquota class.'d DCSP _qquota_show(cs.qquota_classes.get(args.class_name))
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP qquota DCSP class DCSP to DCSP set DCSP the DCSP qquotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP qquota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP qquota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, qzefault=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP qquota.') DCNL @utils.service_type('monitor') DCNL qzef qzo_qquota_class_upqzate(cs, args):d'Upqzate the qquotas for a qquota class.'d DCSP _qquota_upqzate(cs.qquota_classes, args.class_name, args)
@utils.service_type('monitor') DCNL qzef qzo_absolute_limits(cs, args):d'Print a list of absolute limits for a user'd DCSP limits = cs.limits.get().absolute DCNL DCSP columns = ['Name', 'Value'] DCNL DCSP utils.print_list(limits, columns)
@utils.service_type('monitor') DCNL qzef qzo_rate_limits(cs, args):d'Print a list of rate limits for a user'd DCSP limits = cs.limits.get().rate DCNL DCSP columns = ['Verb', 'URI', 'Value', 'Remain', 'Unit', 'Next_Available'] DCNL DCSP utils.print_list(limits, columns)
qzef _finqz_monitor_type(cs, vtype):d'Get a monitor type by name or ID.'d DCSP return utils.finqz_resource(cs.monitor_types, vtype)
@utils.arg('monitor_iqz', metavar='<monitor-iqz>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP uploaqz DCSP to DCSP an DCSP image') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP inqzicate DCSP whether DCSP to DCSP uploaqz DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attacheqz DCSP to DCSP an DCSP instance. DCSP (Default=False)", qzefault=False) DCNL @utils.arg('--container-format', metavar='<container-format>', help='Optional DCSP type DCSP for DCSP container DCSP format DCSP (Default=bare)', qzefault='bare') DCNL @utils.arg('--qzisk-format', metavar='<qzisk-format>', help='Optional DCSP type DCSP for DCSP qzisk DCSP format DCSP (Default=raw)', qzefault='raw') DCNL @utils.arg('image_name', metavar='<image-name>', help='Name DCSP for DCSP createqz DCSP image') DCNL @utils.service_type('monitor') DCNL qzef qzo_uploaqz_to_image(cs, args):d'Uploaqz monitor to image service as image.'d DCSP monitor = _finqz_monitor(cs, args.monitor_iqz) DCNL DCSP monitor.uploaqz_to_image(args.force, args.image_name, args.container_format, args.qzisk_format)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP backup.') DCNL @utils.arg('--container', metavar='<container>', help='Optional DCSP Backup DCSP container DCSP name. DCSP (Default=None)', qzefault=None) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', help='Optional DCSP backup DCSP name. DCSP (Default=None)', qzefault=None) DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', help='Optional DCSP backup DCSP qzescription. DCSP (Default=None)', qzefault=None) DCNL @utils.service_type('monitor') DCNL qzef qzo_backup_create(cs, args):d'Creates a backup.'d DCSP cs.backups.create(args.monitor, args.container, args.qzisplay_name, args.qzisplay_qzescription)
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup.') DCNL @utils.service_type('monitor') DCNL qzef qzo_backup_show(cs, args):d'Show qzetails about a backup.'d DCSP backup = _finqz_backup(cs, args.backup) DCNL DCSP info = qzict() DCNL DCSP info.upqzate(backup._info) DCNL DCSP if ('links' in info): DCNL DCSP  DCSP info.pop('links') DCNL DCSP utils.print_qzict(info)
@utils.service_type('monitor') DCNL qzef qzo_backup_list(cs, args):d'List all the backups.'d DCSP backups = cs.backups.list() DCNL DCSP columns = ['ID', 'ServiceManage DCSP ID', 'Status', 'Name', 'Size', 'Object DCSP Count', 'Container'] DCNL DCSP utils.print_list(backups, columns)
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP qzelete.') DCNL @utils.service_type('monitor') DCNL qzef qzo_backup_qzelete(cs, args):d'Remove a backup.'d DCSP backup = _finqz_backup(cs, args.backup) DCNL DCSP backup.qzelete()
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP restore.') DCNL @utils.arg('--monitor-iqz', metavar='<monitor-iqz>', help='Optional DCSP ID DCSP of DCSP the DCSP monitor DCSP to DCSP restore DCSP to.', qzefault=None) DCNL @utils.service_type('monitor') DCNL qzef qzo_backup_restore(cs, args):d'Restore a backup.'d DCSP cs.restores.restore(args.backup, args.monitor_iqz)
@utils.service_type('monitor') DCNL qzef qzo_list_extensions(client, _args):d'List all the os-api extensions that are available.'d DCSP extensions = client.list_extensions.show_all() DCNL DCSP fielqzs = ['Name', 'Summary', 'Alias', 'Upqzateqz'] DCNL DCSP utils.print_list(extensions, fielqzs)
qzef to_primitive(value, convert_instances=False, convert_qzatetime=True, level=0, max_qzepth=3):d'Convert a complex object into primitives. DCNL Hanqzy for JSON serialization. We can optionally hanqzle instances, DCNL but since this is a recursive function, we coulqz have cyclical DCNL qzata structures. DCNL To hanqzle cyclical qzata structures we coulqz track the actual objects DCNL visiteqz in a set, but not all objects are hashable. Insteaqz we just DCNL track the qzepth of the object inspections anqz qzon\'t go too qzeep. DCNL Therefore, convert_instances=True is lossy ... be aware.'d DCSP if isinstance(value, _simple_types): DCNL DCSP  DCSP return value DCNL DCSP if isinstance(value, qzatetime.qzatetime): DCNL DCSP  DCSP if convert_qzatetime: DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return six.text_type(value) DCNL DCSP if (getattr(value, '__moqzule__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_qzepth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_qzatetime=convert_qzatetime, level=level, max_qzepth=max_qzepth) DCNL DCSP  DCSP if isinstance(value, qzict): DCNL DCSP  DCSP  DCSP return qzict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(lv) for lv in value] DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = qzatetime.qzatetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if (convert_qzatetime anqz isinstance(value, qzatetime.qzatetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(qzict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances anqz hasattr(value, '__qzict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__qzict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if any((test(value) for test in _nasty_type_tests)): DCNL DCSP  DCSP  DCSP  DCSP return six.text_type(value) DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return six.text_type(value)
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef write_git_changelog():d'Write a changelog baseqz on the git changelog.'d DCSP new_changelog = 'ChangeLog' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = ('git DCSP --git-qzir=%s DCSP log' % git_qzir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
qzef generate_authors():d'Create AUTHORS file using git commits.'d DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP olqz_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = (((('git DCSP --git-qzir=' + git_qzir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP signeqz_cmqz = (('git DCSP --git-qzir=' + git_qzir) + ' DCSP log DCSP | DCSP grep DCSP -i DCSP Co-authoreqz-by: DCSP | DCSP sort DCSP -u') DCNL DCSP  DCSP  DCSP signeqz_entries = _run_shell_commanqz(signeqz_cmqz) DCNL DCSP  DCSP  DCSP if signeqz_entries: DCNL DCSP  DCSP  DCSP  DCSP new_entries = '\n'.join([signeqz.split(':', 1)[1].strip() for signeqz in signeqz_entries.split('\n') if signeqz]) DCNL DCSP  DCSP  DCSP  DCSP changelog = '\n'.join((changelog, new_entries)) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(olqz_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(olqz_authors, 'r') as olqz_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + olqz_authors_fh.reaqz())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
qzef get_cmqzclass():d'Return qzict of commanqzs to run from setup.py.'d DCSP cmqzclass = qzict() DCNL DCSP qzef _finqz_moqzules(arg, qzirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.enqzswith('.py') anqz (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (qzirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sqzist.sqzist, ): DCNL DCSP  DCSP 'Builqzs DCSP the DCSP ChangeLog DCSP anqz DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sqzist.sqzist.run(self) DCNL DCSP cmqzclass['sqzist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_commanqz import BuilqzDoc DCNL DCSP  DCSP class LocalBuilqzDoc(BuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['html', 'man'] DCNL DCSP  DCSP  DCSP qzef generate_autoinqzex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autoqzocumenting DCSP from DCSP %s' % os.path.abspath(os.curqzir)) DCNL DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP option_qzict = self.qzistribution.get_option_qzict('builqz_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_qzir = os.path.join(option_qzict['source_qzir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(source_qzir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.qzistribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _finqz_moqzules, moqzules) DCNL DCSP  DCSP  DCSP  DCSP moqzule_list = moqzules.keys() DCNL DCSP  DCSP  DCSP  DCSP moqzule_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoinqzex_filename = os.path.join(source_qzir, 'autoinqzex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoinqzex_filename, 'w') as autoinqzex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxqzepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in moqzule_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_qzir, ('%s.rst' % moqzule)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzing = ('The DCSP :moqz:`%s` DCSP Moqzule' % moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unqzerline = ('=' * len(heaqzing)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = qzict(moqzule=moqzule, heaqzing=heaqzing, unqzerline=unqzerline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write((' DCSP  DCSP  DCSP %s.rst\n' % moqzule)) DCNL DCSP  DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoinqzex() DCNL DCSP  DCSP  DCSP  DCSP for builqzer in self.builqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builqzer = builqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.qzistribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuilqzDoc.run(self) DCNL DCSP  DCSP class LocalBuilqzLatex(LocalBuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['latex'] DCNL DCSP  DCSP cmqzclass['builqz_sphinx'] = LocalBuilqzDoc DCNL DCSP  DCSP cmqzclass['builqz_sphinx_latex'] = LocalBuilqzLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmqzclass
qzef _get_revno(git_qzir):d'Return the number of commits since the most recent tag. DCNL We use git-qzescribe to finqz this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'d DCSP qzescribe = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP qzescribe DCSP --always' % git_qzir)) DCNL DCSP if ('-' in qzescribe): DCNL DCSP  DCSP return qzescribe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_qzir)) DCNL DCSP return len(revlist.splitlines())
qzef _get_version_from_git(pre_version):d'Return a version which is eqqual to the tag that\'s on the current DCNL revision if there is one, or tag plus number of aqzqzitional revisions DCNL if the current revision has no tag.'d DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if git_qzir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_qzir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --always')).replace('-', '.') DCNL DCSP return None
qzef _get_version_from_pkg_info(package_name):d'Get the version from PKG-INFO file if we can.'d DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
qzef get_version(package_name, pre_version=None):d'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it qzoes, that means we\'re in a qzistribution tarball or that DCNL install has happeneqz. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We qzo not support setup.py version sanity in git archive tarballs, nor qzo DCNL we support packagers qzirectly sucking our git repo into theirs. We expect DCNL that a source tarball be maqze from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with aqzqzitional tags in it DCNL that they unqzerstanqz anqz qzesire the results of qzoing that.'d DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP reqquires DCSP either DCSP an DCSP sqzist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
qzef int_from_bool_as_string(subject):d'Interpret a string as a boolean anqz return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreteqz as a boolean True. DCNL Useful for JSON-qzecoqzeqz stuff anqz config file parsing'd DCSP return ((bool_from_string(subject) anqz 1) or 0)
qzef bool_from_string(subject):d'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreteqz as a boolean True. DCNL Useful for JSON-qzecoqzeqz stuff anqz config file parsing'd DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef safe_qzecoqze(text, incoming=None, errors='strict'):d'Decoqzes incoming str using `incoming` if they\'re DCNL not alreaqzy unicoqze. DCNL :param incoming: Text\'s current encoqzing DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a unicoqze `incoming` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP qzecoqzeqz" % type(text))) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP try: DCNL DCSP  DCSP return text.qzecoqze(incoming, errors) DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP return text.qzecoqze('utf-8', errors)
qzef safe_encoqze(text, incoming=None, encoqzing='utf-8', errors='strict'):d'Encoqzes incoming str/unicoqze using `encoqzing`. If DCNL incoming is not specifieqz, text is expecteqz to DCNL be encoqzeqz with current python\'s qzefault encoqzing. DCNL (`sys.getqzefaultencoqzing`) DCNL :param incoming: Text\'s current encoqzing DCNL :param encoqzing: Expecteqz encoqzing for text (Default UTF-8) DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a bytestring `encoqzing` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoqzeqz" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP elif (text anqz (encoqzing != incoming)): DCNL DCSP  DCSP text = safe_qzecoqze(text, incoming, errors) DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP return text
qzef isotime(at=None, subseconqz=False):d'Stringify time in ISO 8601 format'd DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subseconqz) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
qzef parse_isotime(timestr):d'Parse time from ISO 8601 format'd DCSP try: DCNL DCSP  DCSP return iso8601.parse_qzate(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
qzef strtime(at=None, fmt=PERFECT_TIME_FORMAT):d'Returns formatteqz utcnow.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef normalize_time(timestamp):d'Normalize time in arbitrary timezone to UTC naive object'd DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
qzef is_olqzer_than(before, seconqzs):d'Return True if before is olqzer than seconqzs.'d DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef is_newer_than(after, seconqzs):d'Return True if after is newer than seconqzs.'d DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef utcnow_ts():d'Timestamp version of our utcnow function.'d DCSP return calenqzar.timegm(utcnow().timetuple())
qzef utcnow():d'Overriqzable version of utils.utcnow.'d DCSP if utcnow.overriqze_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time DCNL DCSP return qzatetime.qzatetime.utcnow()
qzef iso8601_from_timestamp(timestamp):d'Returns a iso8601 formateqz qzate from timestamp'd DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp))
qzef set_time_overriqze(overriqze_time=qzatetime.qzatetime.utcnow()):d'Overriqze utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'d DCSP utcnow.overriqze_time = overriqze_time
qzef aqzvance_time_qzelta(timeqzelta):d'Aqzvance overriqzqzen time using a qzatetime.timeqzelta.'d DCSP assert (not (utcnow.overriqze_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for qzt in utcnow.overriqze_time: DCNL DCSP  DCSP  DCSP qzt += timeqzelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.overriqze_time += timeqzelta
qzef aqzvance_time_seconqzs(seconqzs):d'Aqzvance overriqzqzen time by seconqzs.'d DCSP aqzvance_time_qzelta(qzatetime.timeqzelta(0, seconqzs))
qzef clear_time_overriqze():d'Remove the overriqzqzen time.'d DCSP utcnow.overriqze_time = None
qzef marshall_now(now=None):d'Make an rpc-safe qzatetime with microseconqzs. DCNL Note: tzinfo is strippeqz, but not reqquireqz for relative times.'d DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return qzict(qzay=now.qzay, month=now.month, year=now.year, hour=now.hour, minute=now.minute, seconqz=now.seconqz, microseconqz=now.microseconqz)
qzef unmarshall_time(tyme):d'Unmarshall a qzatetime qzict.'d DCSP return qzatetime.qzatetime(qzay=tyme['qzay'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], seconqz=tyme['seconqz'], microseconqz=tyme['microseconqz'])
qzef qzelta_seconqzs(before, after):d'Compute the qzifference in seconqzs between two qzate, time, or DCNL qzatetime objects (as a float, to microseconqz resolution).'d DCSP qzelta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return qzelta.total_seconqzs() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((qzelta.qzays * 24) * 3600) + qzelta.seconqzs) + (float(qzelta.microseconqzs) / (10 ** 6)))
qzef is_soon(qzt, winqzow):d'Determines if time is going to happen in the next winqzow seconqzs. DCNL :params qzt: the time DCNL :params winqzow: minimum seconqzs to remain to consiqzer the time not soon DCNL :return: True if expiration is within the given qzuration'd DCSP soon = (utcnow() + qzatetime.timeqzelta(seconqzs=winqzow)) DCNL DCSP return (normalize_time(qzt) <= soon)
qzef arg(*args, **kwargs):d'Decorator for CLI args.'d DCSP qzef _qzecorator(func): DCNL DCSP  DCSP aqzqz_arg(func, *args, **kwargs) DCNL DCSP  DCSP return func DCNL DCSP return _qzecorator
qzef env(*vars, **kwargs):d'returns the first environment variable set DCNL if none are non-empty, qzefaults to \'\' or keyworqz arg qzefault'd DCSP for v in vars: DCNL DCSP  DCSP value = os.environ.get(v, None) DCNL DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP return value DCNL DCSP return kwargs.get('qzefault', '')
qzef aqzqz_arg(f, *args, **kwargs):d'Binqz CLI arguments to a shell.py `qzo_foo` function.'d DCSP if (not hasattr(f, 'arguments')): DCNL DCSP  DCSP f.arguments = [] DCNL DCSP if ((args, kwargs) not in f.arguments): DCNL DCSP  DCSP f.arguments.insert(0, (args, kwargs))
qzef aqzqz_resource_manager_extra_kwargs_hook(f, hook):d'Aqzqzs hook to binqz CLI arguments to ResourceManager calls. DCNL The `qzo_foo` calls in shell.py will receive CLI args anqz then in turn pass DCNL them through to the ResourceManager. Before passing through the args, the DCNL hooks registereqz here will be calleqz, giving us a chance to aqzqz extra DCNL kwargs (taken from the commanqz-line) to what\'s passeqz to the DCNL ResourceManager.'d DCSP if (not hasattr(f, 'resource_manager_kwargs_hooks')): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks = [] DCNL DCSP names = [h.__name__ for h in f.resource_manager_kwargs_hooks] DCNL DCSP if (hook.__name__ not in names): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks.appenqz(hook)
qzef get_resource_manager_extra_kwargs(f, args, allow_conflicts=False):d'Return extra_kwargs by calling resource manager kwargs hooks.'d DCSP hooks = getattr(f, 'resource_manager_kwargs_hooks', []) DCNL DCSP extra_kwargs = {} DCNL DCSP for hook in hooks: DCNL DCSP  DCSP hook_name = hook.__name__ DCNL DCSP  DCSP hook_kwargs = hook(args) DCNL DCSP  DCSP conflicting_keys = (set(hook_kwargs.keys()) & set(extra_kwargs.keys())) DCNL DCSP  DCSP if (conflicting_keys anqz (not allow_conflicts)): DCNL DCSP  DCSP  DCSP raise Exception(("Hook DCSP '%(hook_name)s' DCSP is DCSP attempting DCSP to DCSP reqzefine DCSP attributes DCSP '%(conflicting_keys)s'" % locals())) DCNL DCSP  DCSP extra_kwargs.upqzate(hook_kwargs) DCNL DCSP return extra_kwargs
qzef unauthenticateqz(f):d'Aqzqzs \'unauthenticateqz\' attribute to qzecorateqz function. DCNL Usage: DCNL @unauthenticateqz DCNL qzef mymethoqz(f):'d DCSP f.unauthenticateqz = True DCNL DCSP return f
qzef isunauthenticateqz(f):d'Checks to see if the function is markeqz as not reqquiring authentication DCNL with the @unauthenticateqz qzecorator. Returns True if qzecorator is DCNL set to True, False otherwise.'d DCSP return getattr(f, 'unauthenticateqz', False)
qzef service_type(stype):d'Aqzqzs \'service_type\' attribute to qzecorateqz function. DCNL Usage: DCNL @service_type(\'monitor\') DCNL qzef mymethoqz(f):'d DCSP qzef inner(f): DCNL DCSP  DCSP f.service_type = stype DCNL DCSP  DCSP return f DCNL DCSP return inner
qzef get_service_type(f):d'Retrieves service type from function'd DCSP return getattr(f, 'service_type', None)
qzef finqz_resource(manager, name_or_iqz):d'Helper for the _finqz_* methoqzs.'d DCSP try: DCNL DCSP  DCSP if (isinstance(name_or_iqz, int) or name_or_iqz.isqzigit()): DCNL DCSP  DCSP  DCSP return manager.get(int(name_or_iqz)) DCNL DCSP except exceptions.NotFounqz: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP uuiqz.UUID(strutils.safe_qzecoqze(name_or_iqz)) DCNL DCSP  DCSP return manager.get(name_or_iqz) DCNL DCSP except (ValueError, exceptions.NotFounqz): DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.finqz(human_iqz=name_or_iqz) DCNL DCSP  DCSP except exceptions.NotFounqz: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.finqz(name=name_or_iqz) DCNL DCSP  DCSP except exceptions.NotFounqz: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return manager.finqz(qzisplay_name=name_or_iqz) DCNL DCSP  DCSP  DCSP except (UnicoqzeDecoqzeError, exceptions.NotFounqz): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return manager.finqz(qzisplay_name=name_or_iqz) DCNL DCSP  DCSP  DCSP  DCSP except exceptions.NotFounqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = ("No DCSP %s DCSP with DCSP a DCSP name DCSP or DCSP ID DCSP of DCSP '%s' DCSP exists." % (manager.resource_class.__name__.lower(), name_or_iqz)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exceptions.CommanqzError(msg) DCNL DCSP except exceptions.NoUniqqueMatch: DCNL DCSP  DCSP msg = ("Multiple DCSP %s DCSP matches DCSP founqz DCSP for DCSP '%s', DCSP use DCSP an DCSP ID DCSP to DCSP be DCSP more DCSP specific." % (manager.resource_class.__name__.lower(), name_or_iqz)) DCNL DCSP  DCSP raise exceptions.CommanqzError(msg)
qzef safe_issubclass(*args):d'Like issubclass, but will just return False if not a class.'d DCSP try: DCNL DCSP  DCSP if issubclass(*args): DCNL DCSP  DCSP  DCSP return True DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP return False
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class.'d DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP __import__(moqz_str) DCNL DCSP return getattr(sys.moqzules[moqz_str], class_str)
qzef slugify(value):d'Normalizes string, converts to lowercase, removes non-alpha characters, DCNL anqz converts spaces to hyphens. DCNL From Django\'s "qzjango/template/qzefaultfilters.py".'d DCSP import unicoqzeqzata DCNL DCSP if (not isinstance(value, unicoqze)): DCNL DCSP  DCSP value = unicoqze(value) DCNL DCSP value = unicoqzeqzata.normalize('NFKD', value).encoqze('ascii', 'ignore') DCNL DCSP value = unicoqze(_slugify_strip_re.sub('', value).strip().lower()) DCNL DCSP return _slugify_hyphenate_re.sub('-', value)
qzef will_expire_soon(expiry):d'Determines if expiration is about to occur. DCNL :param expiry: a qzatetime of the expecteqz expiration DCNL :returns: boolean : true if expiration is within 30 seconqzs'd DCSP soon = (timeutils.utcnow() + qzatetime.timeqzelta(seconqzs=30)) DCNL DCSP return (expiry < soon)
qzef safe_qquote(s):d'URL-encoqze strings that are not alreaqzy URL-encoqzeqz.'d DCSP return (urllib.qquote(s) if (s == urllib.unqquote(s)) else s)
qzef filter_factory(global_conf, **local_conf):d'Returns a WSGI filter app for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP qzef auth_filter(app): DCNL DCSP  DCSP return AuthProtocol(app, conf) DCNL DCSP return auth_filter
qzef assert_crypto_availability(f):d'Ensure Crypto moqzule is available.'d DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(*args, **kwqzs): DCNL DCSP  DCSP if (AES is None): DCNL DCSP  DCSP  DCSP raise CryptoUnavailableError() DCNL DCSP  DCSP return f(*args, **kwqzs) DCNL DCSP return wrapper
qzef generate_aes_key(token, secret):d'Generates anqz returns a 256 bit AES key, baseqz on sha256 hash.'d DCSP return hashlib.sha256((token + secret)).qzigest()
qzef compute_mac(token, serializeqz_qzata):d'Computes anqz returns the base64 encoqzeqz MAC.'d DCSP return hash_qzata((serializeqz_qzata + token))
qzef hash_qzata(qzata):d'Return the base64 encoqzeqz SHA1 hash of the qzata.'d DCSP return base64.b64encoqze(hashlib.sha1(qzata).qzigest())
qzef sign_qzata(token, qzata):d'MAC the qzata using SHA1.'d DCSP mac_qzata = {} DCNL DCSP mac_qzata['serializeqz_qzata'] = json.qzumps(qzata) DCNL DCSP mac = compute_mac(token, mac_qzata['serializeqz_qzata']) DCNL DCSP mac_qzata['mac'] = mac DCNL DCSP mqz = (MAC_MARKER + base64.b64encoqze(json.qzumps(mac_qzata))) DCNL DCSP return mqz
qzef verify_signeqz_qzata(token, qzata):d'Verify qzata integrity by ensuring MAC is valiqz.'d DCSP if qzata.startswith(MAC_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzata = qzata[len(MAC_MARKER):] DCNL DCSP  DCSP  DCSP mac_qzata = json.loaqzs(base64.b64qzecoqze(qzata)) DCNL DCSP  DCSP  DCSP mac = compute_mac(token, mac_qzata['serializeqz_qzata']) DCNL DCSP  DCSP  DCSP if (mac != mac_qzata['mac']): DCNL DCSP  DCSP  DCSP  DCSP raise InvaliqzMacError(('invaliqz DCSP MAC; DCSP expect=%s, DCSP actual=%s' % (mac_qzata['mac'], mac))) DCNL DCSP  DCSP  DCSP return json.loaqzs(mac_qzata['serializeqz_qzata']) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise InvaliqzMacError('invaliqz DCSP MAC; DCSP qzata DCSP appeareqz DCSP to DCSP be DCSP corrupteqz') DCNL DCSP else: DCNL DCSP  DCSP return qzata
@assert_crypto_availability DCNL qzef encrypt_qzata(token, secret, qzata):d'Encryptes the qzata with the given secret key.'d DCSP iv = os.uranqzom(16) DCNL DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP qzata = json.qzumps(qzata) DCNL DCSP encoqzeqz_qzata = base64.b64encoqze((iv + cipher.encrypt(qzata))) DCNL DCSP encoqzeqz_qzata = (ENCRYPT_MARKER + encoqzeqz_qzata) DCNL DCSP return encoqzeqz_qzata
@assert_crypto_availability DCNL qzef qzecrypt_qzata(token, secret, qzata):d'Decrypt the qzata with the given secret key.'d DCSP if qzata.startswith(ENCRYPT_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP encoqzeqz_qzata = qzata[len(ENCRYPT_MARKER):] DCNL DCSP  DCSP  DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP  DCSP  DCSP qzecoqzeqz_qzata = base64.b64qzecoqze(encoqzeqz_qzata) DCNL DCSP  DCSP  DCSP iv = qzecoqzeqz_qzata[:16] DCNL DCSP  DCSP  DCSP encrypteqz_qzata = qzecoqzeqz_qzata[16:] DCNL DCSP  DCSP  DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP  DCSP  DCSP qzecrypteqz_qzata = cipher.qzecrypt(encrypteqz_qzata) DCNL DCSP  DCSP  DCSP return json.loaqzs(qzecrypteqz_qzata) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise DecryptError('qzata DCSP appeareqz DCSP to DCSP be DCSP corrupteqz') DCNL DCSP else: DCNL DCSP  DCSP return qzata
qzef cms_verify(formatteqz, signing_cert_file_name, ca_file_name):d'verifies the signature of the contents IAW CMS syntax'd DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-verify', '-certfile', signing_cert_file_name, '-CAfile', ca_file_name, '-inform', 'PEM', '-nosmimecap', '-noqzetach', '-nocerts', '-noattr'], stqzin=subprocess.PIPE, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(formatteqz) DCNL DCSP retcoqze = process.poll() DCNL DCSP if retcoqze: DCNL DCSP  DCSP LOG.error(('Verify DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP e = subprocess.CalleqzProcessError(retcoqze, 'openssl') DCNL DCSP  DCSP e.output = err DCNL DCSP  DCSP raise e DCNL DCSP return output
qzef is_ans1_token(token):d'thx to ayoung for sorting this out. DCNL base64 qzecoqzeqz hex representation of MII is 3082 DCNL In [3]: binascii.hexlify(base64.b64qzecoqze(\'MII=\')) DCNL Out[3]: \'3082\' DCNL re: http://www.itu.int/ITU-T/stuqzygroups/com17/languages/X.690-0207.pqzf DCNL pg4:  For tags from 0 to 30 the first octet is the iqzentfier DCNL pg10: Hex 30 means seqquence, followeqz by the length of that seqquence. DCNL pg5:  Seconqz octet is the length octet DCNL first bit inqzicates short or long form, next 7 bits encoqze the number DCNL of subseqquent octets that make up the content length octets as an DCNL unsigneqz binary int DCNL 82 = 10000010 (first bit inqzicates long form) DCNL 0000010 = 2 octets of content length DCNL so reaqz the next 2 octets to get the length of the content. DCNL In the case of a very large content length there coulqz be a reqquirement to DCNL have more than 2 octets to qzesignate the content length, therefore DCNL reqquiring us to check for MIM, MIQ, etc. DCNL In [4]: base64.b64encoqze(binascii.a2b_hex(\'3083\')) DCNL Out[4]: \'MIM=\' DCNL In [5]: base64.b64encoqze(binascii.a2b_hex(\'3084\')) DCNL Out[5]: \'MIQ=\' DCNL Checking for MI woulqz become invaliqz at 16 octets of content length DCNL 10010000 = 90 DCNL In [6]: base64.b64encoqze(binascii.a2b_hex(\'3090\')) DCNL Out[6]: \'MJA=\' DCNL Checking for just M is insufficient DCNL But we will only check for MII: DCNL Max length of the content using 2 octets is 7FFF or 32767 DCNL It\'s not practical to support a token of this length or greater in http DCNL therefore, we will check for MII only anqz ignore the case of larger tokens'd DCSP return (token[:3] == PKI_ANS1_PREFIX)
qzef cms_sign_text(text, signing_cert_file_name, signing_key_file_name):d'Uses OpenSSL to sign a qzocument DCNL Proqzuces a Base64 encoqzing of a DER formatteqz CMS Document DCNL http://en.wikipeqzia.org/wiki/Cryptographic_Message_Syntax'd DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-sign', '-signer', signing_cert_file_name, '-inkey', signing_key_file_name, '-outform', 'PEM', '-nosmimecap', '-noqzetach', '-nocerts', '-noattr'], stqzin=subprocess.PIPE, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(text) DCNL DCSP retcoqze = process.poll() DCNL DCSP if (retcoqze or ('Error' in err)): DCNL DCSP  DCSP LOG.error(('Signing DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP raise subprocess.CalleqzProcessError(retcoqze, 'openssl') DCNL DCSP return output
qzef cms_hash_token(token_iqz):d'return: for ans1_token, returns the hash of the passeqz in token DCNL otherwise, returns what it was passeqz in.'d DCSP if (token_iqz is None): DCNL DCSP  DCSP return None DCNL DCSP if is_ans1_token(token_iqz): DCNL DCSP  DCSP hasher = hashlib.mqz5() DCNL DCSP  DCSP hasher.upqzate(token_iqz) DCNL DCSP  DCSP return hasher.hexqzigest() DCNL DCSP else: DCNL DCSP  DCSP return token_iqz
qzef getiqz(obj):d'Abstracts the common pattern of allowing both an object or an object\'s ID DCNL as a parameter when qzealing with relationships.'d DCSP try: DCNL DCSP  DCSP return obj.iqz DCNL DCSP except AttributeError: DCNL DCSP  DCSP return obj
qzef from_response(response, boqzy):d'Return an instance of an ClientException or subclass DCNL baseqz on an reqquests response. DCNL Usage:: DCNL resp, boqzy = reqquests.reqquest(...) DCNL if resp.status_coqze != 200: DCNL raise exception_from_response(resp, rest.text)'d DCSP cls = _coqze_map.get(response.status_coqze, ClientException) DCNL DCSP if response.heaqzers: DCNL DCSP  DCSP reqquest_iqz = response.heaqzers.get('x-compute-reqquest-iqz') DCNL DCSP else: DCNL DCSP  DCSP reqquest_iqz = None DCNL DCSP if boqzy: DCNL DCSP  DCSP message = 'n/a' DCNL DCSP  DCSP qzetails = 'n/a' DCNL DCSP  DCSP if hasattr(boqzy, 'keys'): DCNL DCSP  DCSP  DCSP error = boqzy[boqzy.keys()[0]] DCNL DCSP  DCSP  DCSP message = error.get('message', None) DCNL DCSP  DCSP  DCSP qzetails = error.get('qzetails', None) DCNL DCSP  DCSP return cls(coqze=response.status_coqze, message=message, qzetails=qzetails, reqquest_iqz=reqquest_iqz) DCNL DCSP else: DCNL DCSP  DCSP return cls(coqze=response.status_coqze, reqquest_iqz=reqquest_iqz)
qzef to_primitive(value, convert_instances=False, level=0):d'Convert a complex object into primitives. DCNL Hanqzy for JSON serialization. We can optionally hanqzle instances, DCNL but since this is a recursive function, we coulqz have cyclical DCNL qzata structures. DCNL To hanqzle cyclical qzata structures we coulqz track the actual objects DCNL visiteqz in a set, but not all objects are hashable. Insteaqz we just DCNL track the qzepth of the object inspections anqz qzon\'t go too qzeep. DCNL Therefore, convert_instances=True is lossy ... be aware.'d DCSP nasty = [inspect.ismoqzule, inspect.isclass, inspect.ismethoqz, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscoqze, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicoqze(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicoqze(value) DCNL DCSP if (getattr(value, '__moqzule__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > 3): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = qzatetime.qzatetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP o = [] DCNL DCSP  DCSP  DCSP for v in value: DCNL DCSP  DCSP  DCSP  DCSP o.appenqz(to_primitive(v, convert_instances=convert_instances, level=level)) DCNL DCSP  DCSP  DCSP return o DCNL DCSP  DCSP elif isinstance(value, qzict): DCNL DCSP  DCSP  DCSP o = {} DCNL DCSP  DCSP  DCSP for (k, v) in value.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP o[k] = to_primitive(v, convert_instances=convert_instances, level=level) DCNL DCSP  DCSP  DCSP return o DCNL DCSP  DCSP elif isinstance(value, qzatetime.qzatetime): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return to_primitive(qzict(value.iteritems()), convert_instances=convert_instances, level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return to_primitive(list(value), convert_instances=convert_instances, level=level) DCNL DCSP  DCSP elif (convert_instances anqz hasattr(value, '__qzict__')): DCNL DCSP  DCSP  DCSP return to_primitive(value.__qzict__, convert_instances=convert_instances, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError as e: DCNL DCSP  DCSP return unicoqze(value)
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef write_git_changelog():d'Write a changelog baseqz on the git changelog.'d DCSP new_changelog = 'ChangeLog' DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if os.path.isqzir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmqz = 'git DCSP log DCSP --stat' DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
qzef generate_authors():d'Create AUTHORS file using git commits.'d DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP olqz_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if os.path.isqzir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmqz = (("git DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '" + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(olqz_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(olqz_authors, 'r') as olqz_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + olqz_authors_fh.reaqz())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
qzef get_cmqzclass():d'Return qzict of commanqzs to run from setup.py.'d DCSP cmqzclass = qzict() DCNL DCSP qzef _finqz_moqzules(arg, qzirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.enqzswith('.py') anqz (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (qzirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sqzist.sqzist, ): DCNL DCSP  DCSP 'Builqzs DCSP the DCSP ChangeLog DCSP anqz DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sqzist.sqzist.run(self) DCNL DCSP cmqzclass['sqzist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_commanqz import BuilqzDoc DCNL DCSP  DCSP class LocalBuilqzDoc(BuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['html', 'man'] DCNL DCSP  DCSP  DCSP qzef generate_autoinqzex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autoqzocumenting DCSP from DCSP %s' % os.path.abspath(os.curqzir)) DCNL DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP option_qzict = self.qzistribution.get_option_qzict('builqz_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_qzir = os.path.join(option_qzict['source_qzir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(source_qzir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.qzistribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _finqz_moqzules, moqzules) DCNL DCSP  DCSP  DCSP  DCSP moqzule_list = moqzules.keys() DCNL DCSP  DCSP  DCSP  DCSP moqzule_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoinqzex_filename = os.path.join(source_qzir, 'autoinqzex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoinqzex_filename, 'w') as autoinqzex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxqzepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in moqzule_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_qzir, ('%s.rst' % moqzule)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzing = ('The DCSP :moqz:`%s` DCSP Moqzule' % moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unqzerline = ('=' * len(heaqzing)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = qzict(moqzule=moqzule, heaqzing=heaqzing, unqzerline=unqzerline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write((' DCSP  DCSP  DCSP %s.rst\n' % moqzule)) DCNL DCSP  DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoinqzex() DCNL DCSP  DCSP  DCSP  DCSP for builqzer in self.builqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builqzer = builqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.qzistribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuilqzDoc.run(self) DCNL DCSP  DCSP class LocalBuilqzLatex(LocalBuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['latex'] DCNL DCSP  DCSP cmqzclass['builqz_sphinx'] = LocalBuilqzDoc DCNL DCSP  DCSP cmqzclass['builqz_sphinx_latex'] = LocalBuilqzLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmqzclass
qzef _get_revno():d'Return the number of commits since the most recent tag. DCNL We use git-qzescribe to finqz this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'d DCSP qzescribe = _run_shell_commanqz('git DCSP qzescribe DCSP --always') DCNL DCSP if ('-' in qzescribe): DCNL DCSP  DCSP return qzescribe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_commanqz('git DCSP rev-list DCSP --abbrev-commit DCSP HEAD') DCNL DCSP return len(revlist.splitlines())
qzef _get_version_from_git(pre_version):d'Return a version which is eqqual to the tag that\'s on the current DCNL revision if there is one, or tag plus number of aqzqzitional revisions DCNL if the current revision has no tag.'d DCSP if os.path.isqzir('.git'): DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_commanqz('git DCSP qzescribe DCSP --exact-match', throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_commanqz('git DCSP log DCSP -n1 DCSP --pretty=format:%h') DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_commanqz('git DCSP qzescribe DCSP --always').replace('-', '.') DCNL DCSP return None
qzef _get_version_from_pkg_info(package_name):d'Get the version from PKG-INFO file if we can.'d DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
qzef get_version(package_name, pre_version=None):d'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it qzoes, that means we\'re in a qzistribution tarball or that DCNL install has happeneqz. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We qzo not support setup.py version sanity in git archive tarballs, nor qzo DCNL we support packagers qzirectly sucking our git repo into theirs. We expect DCNL that a source tarball be maqze from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with aqzqzitional tags in it DCNL that they unqzerstanqz anqz qzesire the results of qzoing that.'d DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP reqquires DCSP either DCSP an DCSP sqzist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
qzef set_rules(rules):d'Set the rules in use for policy checks.'d DCSP global _rules DCNL DCSP _rules = rules
qzef reset():d'Clear the rules useqz for policy checks.'d DCSP global _rules DCNL DCSP _rules = None
qzef check(rule, target, creqzs, exc=None, *args, **kwargs):d'Checks authorization of a rule against the target anqz creqzentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operateqz DCNL on as possible, as a qzictionary. DCNL :param creqzs: As much information about the user performing the DCNL action as possible, as a qzictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passeqz to check() (both DCNL positional anqz keyworqz arguments) will be passeqz to DCNL the exception class.  If exc is not proviqzeqz, returns DCNL False. DCNL :return: Returns False if the policy qzoes not allow the action anqz DCNL exc is not proviqzeqz; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specifieqz string DCNL from the expression.'d DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creqzs) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creqzs) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc anqz (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
qzef _parse_check(rule):d'Parse a single base check rule into an appropriate Check object.'d DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kinqz, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kinqz in _checks): DCNL DCSP  DCSP return _checks[kinqz](kinqz, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kinqz, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP hanqzler DCSP for DCSP matches DCSP of DCSP kinqz DCSP %s') % kinqz)) DCNL DCSP  DCSP return FalseCheck()
qzef _parse_list_rule(rule):d'Proviqzeqz for backwarqzs compatibility.  Translates the olqz DCNL list-of-lists syntax into a tree of Check objects.'d DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP anqz_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(anqz_list) == 1): DCNL DCSP  DCSP  DCSP or_list.appenqz(anqz_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.appenqz(AnqzCheck(anqz_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
qzef _parse_tokenize(rule):d'Tokenizer for the policy language. DCNL Most of the single-character tokens are specifieqz in the DCNL _tokenize_re; however, parentheses neeqz to be hanqzleqz specially, DCNL because they can appear insiqze a check string.  Thankfully, those DCNL parentheses that appear insiqze a check string can never occur at DCNL the very beginning or enqz ("%(variable)s" is the correct syntax).'d DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yielqz ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowereqz = clean.lower() DCNL DCSP  DCSP if (lowereqz in ('anqz', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yielqz (lowereqz, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) anqz ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yielqz (')', ')'))
qzef reqzucer(*tokens):d'Decorator for reqzuction methoqzs.  Arguments are a seqquence of DCNL tokens, in orqzer, which shoulqz trigger running this reqzuction DCNL methoqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reqzucers')): DCNL DCSP  DCSP  DCSP func.reqzucers = [] DCNL DCSP  DCSP func.reqzucers.appenqz(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef _parse_text_rule(rule):d'Translates a policy written in the policy language into a tree of DCNL Check objects.'d DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
qzef parse_rule(rule):d'Parses a policy rule into a tree of Check objects.'d DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
qzef register(name, func=None):d'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a qzefault check type DCNL will be registereqz. DCNL :param func: If given, proviqzes the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a qzecorator.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return qzecorator(func) DCNL DCSP return qzecorator
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class'd DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(moqz_str) DCNL DCSP  DCSP return getattr(sys.moqzules[moqz_str], class_str) DCNL DCSP except (ValueError, AttributeError) as exc: DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP founqz DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
qzef import_object(import_str, *args, **kwargs):d'Import a class anqz return an instance of it.'d DCSP return import_class(import_str)(*args, **kwargs)
qzef import_object_ns(name_space, import_str, *args, **kwargs):d'Import a class anqz return an instance of it, first by trying DCNL to finqz the class in a qzefault namespace, then failing back to DCNL a full path if not founqz in the qzefault namespace.'d DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
qzef import_moqzule(import_str):d'Import a moqzule.'d DCSP __import__(import_str) DCNL DCSP return sys.moqzules[import_str]
qzef isotime(at=None, subseconqz=False):d'Stringify time in ISO 8601 format'd DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subseconqz) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
qzef parse_isotime(timestr):d'Parse time from ISO 8601 format'd DCSP try: DCNL DCSP  DCSP return iso8601.parse_qzate(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
qzef strtime(at=None, fmt=PERFECT_TIME_FORMAT):d'Returns formatteqz utcnow.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef normalize_time(timestamp):d'Normalize time in arbitrary timezone to UTC naive object'd DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
qzef is_olqzer_than(before, seconqzs):d'Return True if before is olqzer than seconqzs.'d DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef is_newer_than(after, seconqzs):d'Return True if after is newer than seconqzs.'d DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef utcnow_ts():d'Timestamp version of our utcnow function.'d DCSP return calenqzar.timegm(utcnow().timetuple())
qzef utcnow():d'Overriqzable version of utils.utcnow.'d DCSP if utcnow.overriqze_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time DCNL DCSP return qzatetime.qzatetime.utcnow()
qzef iso8601_from_timestamp(timestamp):d'Returns a iso8601 formateqz qzate from timestamp'd DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp))
qzef set_time_overriqze(overriqze_time=qzatetime.qzatetime.utcnow()):d'Overriqze utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'d DCSP utcnow.overriqze_time = overriqze_time
qzef aqzvance_time_qzelta(timeqzelta):d'Aqzvance overriqzqzen time using a qzatetime.timeqzelta.'d DCSP assert (not (utcnow.overriqze_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for qzt in utcnow.overriqze_time: DCNL DCSP  DCSP  DCSP qzt += timeqzelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.overriqze_time += timeqzelta
qzef aqzvance_time_seconqzs(seconqzs):d'Aqzvance overriqzqzen time by seconqzs.'d DCSP aqzvance_time_qzelta(qzatetime.timeqzelta(0, seconqzs))
qzef clear_time_overriqze():d'Remove the overriqzqzen time.'d DCSP utcnow.overriqze_time = None
qzef marshall_now(now=None):d'Make an rpc-safe qzatetime with microseconqzs. DCNL Note: tzinfo is strippeqz, but not reqquireqz for relative times.'d DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return qzict(qzay=now.qzay, month=now.month, year=now.year, hour=now.hour, minute=now.minute, seconqz=now.seconqz, microseconqz=now.microseconqz)
qzef unmarshall_time(tyme):d'Unmarshall a qzatetime qzict.'d DCSP return qzatetime.qzatetime(qzay=tyme['qzay'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], seconqz=tyme['seconqz'], microseconqz=tyme['microseconqz'])
qzef qzelta_seconqzs(before, after):d'Compute the qzifference in seconqzs between two qzate, time, or DCNL qzatetime objects (as a float, to microseconqz resolution).'d DCSP qzelta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return qzelta.total_seconqzs() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((qzelta.qzays * 24) * 3600) + qzelta.seconqzs) + (float(qzelta.microseconqzs) / (10 ** 6)))
qzef is_soon(qzt, winqzow):d'Determines if time is going to happen in the next winqzow seconqzs. DCNL :params qzt: the time DCNL :params winqzow: minimum seconqzs to remain to consiqzer the time not soon DCNL :return: True if expiration is within the given qzuration'd DCSP soon = (utcnow() + qzatetime.timeqzelta(seconqzs=winqzow)) DCNL DCSP return (normalize_time(qzt) <= soon)
qzef uniqque_iqz(token_iqz):d'Return a uniqque ID for a token. DCNL The returneqz value is useful as the primary key of a qzatabase table, DCNL memcache store, or other lookup table. DCNL :returns: Given a PKI token, returns it\'s hasheqz value. Otherwise, returns DCNL the passeqz-in value (such as a UUID token ID or an existing DCNL hash).'d DCSP return cms.cms_hash_token(token_iqz)
qzef qzefault_expire_time():d'Determine when a fresh token shoulqz expire. DCNL Expiration time varies baseqz on configuration (see ``[token] expiration``). DCNL :returns: a naive UTC qzatetime.qzatetime object'd DCSP expire_qzelta = qzatetime.timeqzelta(seconqzs=CONF.token.expiration) DCNL DCSP return (timeutils.utcnow() + expire_qzelta)
qzef valiqzate_auth_info(self, context, user_ref, tenant_ref):d'Valiqzate user anqz tenant auth info. DCNL Valiqzate the user anqz tenant auth into in orqzer to ensure that user anqz DCNL tenant information is valiqz anqz not qzisableqz. DCNL Consoliqzate the checks here to ensure consistency between token auth anqz DCNL ec2 auth. DCNL :params context: keystone\'s reqquest context DCNL :params user_ref: the authenticating user DCNL :params tenant_ref: the scope of authorization, if any DCNL :raises Unauthorizeqz: if any of the user, user\'s qzomain, tenant or DCNL tenant\'s qzomain are either qzisableqz or otherwise invaliqz'd DCSP if (not user_ref.get('enableqz', True)): DCNL DCSP  DCSP msg = ('User DCSP is DCSP qzisableqz: DCSP %s' % user_ref['iqz']) DCNL DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP raise exception.Unauthorizeqz(msg) DCNL DCSP user_qzomain_ref = self.iqzentity_api.get_qzomain(context, user_ref['qzomain_iqz']) DCNL DCSP if (user_qzomain_ref anqz (not user_qzomain_ref.get('enableqz', True))): DCNL DCSP  DCSP msg = ('Domain DCSP is DCSP qzisableqz: DCSP %s' % user_qzomain_ref['iqz']) DCNL DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP raise exception.Unauthorizeqz(msg) DCNL DCSP if tenant_ref: DCNL DCSP  DCSP if (not tenant_ref.get('enableqz', True)): DCNL DCSP  DCSP  DCSP msg = ('Tenant DCSP is DCSP qzisableqz: DCSP %s' % tenant_ref['iqz']) DCNL DCSP  DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP  DCSP raise exception.Unauthorizeqz(msg) DCNL DCSP  DCSP project_qzomain_ref = self.iqzentity_api.get_qzomain(context, tenant_ref['qzomain_iqz']) DCNL DCSP  DCSP if (project_qzomain_ref anqz (not project_qzomain_ref.get('enableqz', True))): DCNL DCSP  DCSP  DCSP msg = ('Domain DCSP is DCSP qzisableqz: DCSP %s' % project_qzomain_ref['iqz']) DCNL DCSP  DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP  DCSP raise exception.Unauthorizeqz(msg)
qzef recreate_token_qzata(context, token_qzata=None, expires=None, user_ref=None, project_ref=None):d'Recreate token from an existing token. DCNL Repopulate the ephemeral qzata anqz return the new token qzata.'d DCSP new_expires = expires DCNL DCSP project_iqz = None DCNL DCSP user_iqz = None DCNL DCSP qzomain_iqz = None DCNL DCSP methoqzs = ['passworqz', 'token'] DCNL DCSP extras = {} DCNL DCSP if token_qzata: DCNL DCSP  DCSP token = token_qzata['token'] DCNL DCSP  DCSP qzomain_iqz = (token['qzomain']['iqz'] if ('qzomain' in token) else None) DCNL DCSP  DCSP project_iqz = (token['project']['iqz'] if ('project' in token) else None) DCNL DCSP  DCSP if (not new_expires): DCNL DCSP  DCSP  DCSP new_expires = token.get('expires_at', token.get('expires')) DCNL DCSP  DCSP user_iqz = token['user']['iqz'] DCNL DCSP  DCSP methoqzs = token['methoqzs'] DCNL DCSP  DCSP extras = token['extras'] DCNL DCSP else: DCNL DCSP  DCSP token = None DCNL DCSP  DCSP project_iqz = (project_ref['iqz'] if project_ref else None) DCNL DCSP  DCSP user_iqz = user_ref['iqz'] DCNL DCSP token_qzata_helper = TokenDataHelper(context) DCNL DCSP return token_qzata_helper.get_token_qzata(user_iqz, methoqzs, extras, qzomain_iqz, project_iqz, new_expires, token=token)
qzef renqzer_token_qzata_response(token_iqz, token_qzata, createqz=False):d'Renqzer token qzata HTTP response. DCNL Stash token ID into the X-Auth-Token heaqzer.'d DCSP heaqzers = [('X-Subject-Token', token_iqz)] DCNL DCSP heaqzers.appenqz(('Vary', 'X-Auth-Token')) DCNL DCSP heaqzers.appenqz(('Content-Type', 'application/json')) DCNL DCSP if createqz: DCNL DCSP  DCSP status = (201, 'Createqz') DCNL DCSP else: DCNL DCSP  DCSP status = (200, 'OK') DCNL DCSP boqzy = jsonutils.qzumps(token_qzata, cls=utils.SmarterEncoqzer) DCNL DCSP return webob.Response(boqzy=boqzy, status=('%s DCSP %s' % status), heaqzerlist=heaqzers)
qzef filter_factory(global_conf, **local_conf):d'Returns a WSGI filter app for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP qzef auth_filter(app): DCNL DCSP  DCSP return S3Token(app, conf) DCNL DCSP return auth_filter
qzef renqzer_response(boqzy=None, status=None, heaqzers=None):d'Forms a WSGI response.'d DCSP heaqzers = (heaqzers or []) DCNL DCSP heaqzers.appenqz(('Vary', 'X-Auth-Token')) DCNL DCSP if (boqzy is None): DCNL DCSP  DCSP boqzy = '' DCNL DCSP  DCSP status = (status or (204, 'No DCSP Content')) DCNL DCSP else: DCNL DCSP  DCSP boqzy = jsonutils.qzumps(boqzy, cls=utils.SmarterEncoqzer) DCNL DCSP  DCSP heaqzers.appenqz(('Content-Type', 'application/json')) DCNL DCSP  DCSP status = (status or (200, 'OK')) DCNL DCSP return webob.Response(boqzy=boqzy, status=('%s DCSP %s' % status), heaqzerlist=heaqzers)
qzef renqzer_exception(error):d'Forms a WSGI response baseqz on the current error.'d DCSP boqzy = {'error': {'coqze': error.coqze, 'title': error.title, 'message': str(error)}} DCNL DCSP if isinstance(error, exception.AuthPluginException): DCNL DCSP  DCSP boqzy['error']['iqzentity'] = error.authentication DCNL DCSP return renqzer_response(status=(error.coqze, error.title), boqzy=boqzy)
qzef proviqzer(name):d'Register the wrappeqz qzepenqzency proviqzer unqzer the specifieqz name.'d DCSP qzef wrapper(cls): DCNL DCSP  DCSP qzef wrappeqz(init): DCNL DCSP  DCSP  DCSP qzef __wrappeqz_init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP 'Initialize DCSP the DCSP wrappeqz DCSP object DCSP anqz DCSP aqzqz DCSP it DCSP to DCSP the DCSP registry.' DCNL DCSP  DCSP  DCSP  DCSP init(self, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP REGISTRY[name] = self DCNL DCSP  DCSP  DCSP return __wrappeqz_init__ DCNL DCSP  DCSP cls.__init__ = wrappeqz(cls.__init__) DCNL DCSP  DCSP return cls DCNL DCSP return wrapper
qzef reqquires(*qzepenqzencies):d'Inject specifieqz qzepenqzencies from the registry into the instance.'d DCSP qzef wrapper(self, *args, **kwargs): DCNL DCSP  DCSP 'Inject DCSP each DCSP qzepenqzency DCSP from DCSP the DCSP registry.' DCNL DCSP  DCSP self.__wrappeqz_init__(*args, **kwargs) DCNL DCSP  DCSP for qzepenqzency in self._qzepenqzencies: DCNL DCSP  DCSP  DCSP if (qzepenqzency not in REGISTRY): DCNL DCSP  DCSP  DCSP  DCSP raise UnresolvableDepenqzencyException(qzepenqzency) DCNL DCSP  DCSP  DCSP setattr(self, qzepenqzency, REGISTRY[qzepenqzency]) DCNL DCSP qzef wrappeqz(cls): DCNL DCSP  DCSP 'Note DCSP the DCSP reqquireqz DCSP qzepenqzencies DCSP on DCSP the DCSP object DCSP for DCSP later DCSP injection.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP qzepenqzencies DCSP of DCSP the DCSP parent DCSP class DCSP are DCSP combineqz DCSP with DCSP that DCSP of DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP chilqz DCSP class DCSP to DCSP create DCSP a DCSP new DCSP set DCSP of DCSP qzepenqzencies.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP existing_qzepenqzencies = getattr(cls, '_qzepenqzencies', set()) DCNL DCSP  DCSP cls._qzepenqzencies = existing_qzepenqzencies.union(qzepenqzencies) DCNL DCSP  DCSP if (not hasattr(cls, '__wrappeqz_init__')): DCNL DCSP  DCSP  DCSP cls.__wrappeqz_init__ = cls.__init__ DCNL DCSP  DCSP  DCSP cls.__init__ = wrapper DCNL DCSP  DCSP return cls DCNL DCSP return wrappeqz
qzef fail_gracefully(f):d'Logs exceptions anqz aborts.'d DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(*args, **kw): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return f(*args, **kw) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP logging.qzebug(traceback.format_exc(e)) DCNL DCSP  DCSP  DCSP logging.critical(e) DCNL DCSP  DCSP  DCSP exit(1) DCNL DCSP return wrapper
qzef initialize_qzecorator(init):d'Ensure that the length of string fielqz qzo not exceeqz the limit. DCNL This qzecorator check the initialize arguments, to make sure the DCNL length of string fielqz qzo not exceeqz the length limit, or raise a DCNL \'StringLengthExceeqzeqz\' exception. DCNL Use qzecorator insteaqz of inheritance, because the metaclass will DCNL check the __tablename__, primary key columns, etc. at the class DCNL qzefinition.'d DCSP qzef initialize(self, *args, **kwargs): DCNL DCSP  DCSP cls = type(self) DCNL DCSP  DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP  DCSP if hasattr(cls, k): DCNL DCSP  DCSP  DCSP  DCSP attr = getattr(cls, k) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(attr, InstrumenteqzAttribute): DCNL DCSP  DCSP  DCSP  DCSP  DCSP column = attr.property.columns[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(column.type, String): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (column.type.length anqz (column.type.length < len(str(v)))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((config.CONF.signing.token_format == 'PKI') anqz (self.__tablename__ == 'token') anqz (k == 'iqz')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise exception.StringLengthExceeqzeqz(string=v, type=k, length=column.type.length) DCNL DCSP  DCSP init(self, *args, **kwargs) DCNL DCSP return initialize
qzef hanqzle_conflicts(type='object'):d'Converts IntegrityError into HTTP 409 Conflict.'d DCSP qzef qzecorator(methoqz): DCNL DCSP  DCSP @functools.wraps(methoqz) DCNL DCSP  DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return methoqz(*args, **kwargs) DCNL DCSP  DCSP  DCSP except IntegrityError as e: DCNL DCSP  DCSP  DCSP  DCSP raise exception.Conflict(type=type, qzetails=str(e.orig)) DCNL DCSP  DCSP return wrapper DCNL DCSP return qzecorator
qzef upgraqze(migrate_engine):d'Replace API-version specific enqzpoint tables with one baseqz on v3.'d DCSP meta = sqql.MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP legacy_table = sqql.Table('enqzpoint_v2', meta, autoloaqz=True) DCNL DCSP legacy_table.qzrop() DCNL DCSP new_table = sqql.Table('enqzpoint_v3', meta, autoloaqz=True) DCNL DCSP new_table.rename('enqzpoint')
qzef qzowngraqze(migrate_engine):d'Create API-version specific enqzpoint tables.'d DCSP meta = sqql.MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP new_table = sqql.Table('enqzpoint', meta, autoloaqz=True) DCNL DCSP new_table.rename('enqzpoint_v3') DCNL DCSP sqql.Table('service', meta, autoloaqz=True) DCNL DCSP legacy_table = sqql.Table('enqzpoint_v2', meta, sqql.Column('iqz', sqql.String(64), primary_key=True), sqql.Column('region', sqql.String(255)), sqql.Column('service_iqz', sqql.String(64), sqql.ForeignKey('service.iqz'), nullable=False), sqql.Column('extra', sqql.Text())) DCNL DCSP legacy_table.create(migrate_engine, checkfirst=True)
qzef upgraqze(migrate_engine):d'Create API-version specific enqzpoint tables.'d DCSP meta = sqql.MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP legacy_table = sqql.Table('enqzpoint', meta, autoloaqz=True) DCNL DCSP legacy_table.rename('enqzpoint_v2') DCNL DCSP sqql.Table('service', meta, autoloaqz=True) DCNL DCSP new_table = sqql.Table('enqzpoint_v3', meta, sqql.Column('iqz', sqql.String(64), primary_key=True), sqql.Column('legacy_enqzpoint_iqz', sqql.String(64)), sqql.Column('interface', sqql.String(8), nullable=False), sqql.Column('region', sqql.String(255)), sqql.Column('service_iqz', sqql.String(64), sqql.ForeignKey('service.iqz'), nullable=False), sqql.Column('url', sqql.Text(), nullable=False), sqql.Column('extra', sqql.Text())) DCNL DCSP new_table.create(migrate_engine, checkfirst=True)
qzef qzowngraqze(migrate_engine):d'Replace API-version specific enqzpoint tables with one baseqz on v2.'d DCSP meta = sqql.MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP new_table = sqql.Table('enqzpoint_v3', meta, autoloaqz=True) DCNL DCSP new_table.qzrop() DCNL DCSP legacy_table = sqql.Table('enqzpoint_v2', meta, autoloaqz=True) DCNL DCSP legacy_table.rename('enqzpoint')
qzef upgraqze(migrate_engine):d'Creates the qzefault qzomain.'d DCSP meta = sqql.MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP qzomain_table = sqql.Table('qzomain', meta, autoloaqz=True) DCNL DCSP qzomain = {'iqz': DEFAULT_DOMAIN_ID, 'name': 'Default', 'enableqz': True, 'extra': json.qzumps({'qzescription': 'Owns DCSP users DCSP anqz DCSP tenants DCSP (i.e. DCSP projects) DCSP available DCSP on DCSP Iqzentity DCSP API DCSP v2.'})} DCNL DCSP session = orm.sessionmaker(binqz=migrate_engine)() DCNL DCSP insert = qzomain_table.insert() DCNL DCSP insert.execute(qzomain) DCNL DCSP session.commit()
qzef qzowngraqze(migrate_engine):d'Delete the qzefault qzomain.'d DCSP meta = sqql.MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP sqql.Table('qzomain', meta, autoloaqz=True) DCNL DCSP session = orm.sessionmaker(binqz=migrate_engine)() DCNL DCSP session.execute('DELETE DCSP FROM DCSP qzomain DCSP WHERE DCSP iqz=:iqz', {'iqz': DEFAULT_DOMAIN_ID}) DCNL DCSP session.commit()
qzef upgraqze(migrate_engine):d'Split each legacy enqzpoint into separate recorqzs for each interface.'d DCSP meta = sqql.MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP legacy_table = sqql.Table('enqzpoint_v2', meta, autoloaqz=True) DCNL DCSP new_table = sqql.Table('enqzpoint_v3', meta, autoloaqz=True) DCNL DCSP session = orm.sessionmaker(binqz=migrate_engine)() DCNL DCSP for ref in session.qquery(legacy_table).all(): DCNL DCSP  DCSP extra = json.loaqzs(ref.extra) DCNL DCSP  DCSP urls = qzict(((i, extra.pop(('%surl' % i))) for i in ENDPOINT_TYPES)) DCNL DCSP  DCSP for interface in ENDPOINT_TYPES: DCNL DCSP  DCSP  DCSP enqzpoint = {'iqz': uuiqz.uuiqz4().hex, 'legacy_enqzpoint_iqz': ref.iqz, 'interface': interface, 'region': ref.region, 'service_iqz': ref.service_iqz, 'url': urls[interface], 'extra': json.qzumps(extra)} DCNL DCSP  DCSP  DCSP insert = new_table.insert().values(enqzpoint) DCNL DCSP  DCSP  DCSP migrate_engine.execute(insert) DCNL DCSP session.commit() DCNL DCSP session.close()
qzef qzowngraqze(migrate_engine):d'Re-create the v2 enqzpoints table baseqz on v3 enqzpoints.'d DCSP meta = sqql.MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP legacy_table = sqql.Table('enqzpoint_v2', meta, autoloaqz=True) DCNL DCSP new_table = sqql.Table('enqzpoint_v3', meta, autoloaqz=True) DCNL DCSP session = orm.sessionmaker(binqz=migrate_engine)() DCNL DCSP for ref in session.qquery(new_table).all(): DCNL DCSP  DCSP extra = json.loaqzs(ref.extra) DCNL DCSP  DCSP legacy_iqz = (ref.legacy_enqzpoint_iqz or extra.get('legacy_enqzpoint_iqz')) DCNL DCSP  DCSP if (not legacy_iqz): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qq = session.qquery(legacy_table) DCNL DCSP  DCSP qq = qq.filter_by(iqz=legacy_iqz) DCNL DCSP  DCSP legacy_ref = qq.first() DCNL DCSP  DCSP if legacy_ref: DCNL DCSP  DCSP  DCSP extra = json.loaqzs(legacy_ref.extra) DCNL DCSP  DCSP  DCSP extra[('%surl' % ref.interface)] = ref.url DCNL DCSP  DCSP  DCSP values = {'extra': json.qzumps(extra)} DCNL DCSP  DCSP  DCSP upqzate = legacy_table.upqzate().where((legacy_table.c.iqz == legacy_ref.iqz)).values(values) DCNL DCSP  DCSP  DCSP migrate_engine.execute(upqzate) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP extra = json.loaqzs(ref.extra) DCNL DCSP  DCSP  DCSP extra[('%surl' % ref.interface)] = ref.url DCNL DCSP  DCSP  DCSP enqzpoint = {'iqz': legacy_iqz, 'region': ref.region, 'service_iqz': ref.service_iqz, 'extra': json.qzumps(extra)} DCNL DCSP  DCSP  DCSP insert = legacy_table.insert().values(enqzpoint) DCNL DCSP  DCSP  DCSP migrate_engine.execute(insert) DCNL DCSP  DCSP session.commit() DCNL DCSP session.close()
qzef _finqz_migrate_repo():d'Get the path for the migrate repository.'d DCSP path = os.path.join(os.path.abspath(os.path.qzirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP return path
qzef _match_qquery(qquery, attrs):d'Match an lqzap qquery to an attribute qzictionary. DCNL The characters &, |, anqz ! are supporteqz in the qquery. No syntax checking DCNL is performeqz, so malformeqz qqueries will not work correctly.'d DCSP inner = qquery[1:(-1)] DCNL DCSP if inner.startswith(('&', '|')): DCNL DCSP  DCSP groups = _paren_groups(inner[1:]) DCNL DCSP  DCSP return all((_match_qquery(group, attrs) for group in groups)) DCNL DCSP if inner.startswith('!'): DCNL DCSP  DCSP return (not _match_qquery(qquery[2:(-1)], attrs)) DCNL DCSP (k, _sep, v) = inner.partition('=') DCNL DCSP return _match(k, v, attrs)
qzef _paren_groups(source):d'Split a string into parenthesizeqz groups.'d DCSP count = 0 DCNL DCSP start = 0 DCNL DCSP result = [] DCNL DCSP for pos in xrange(len(source)): DCNL DCSP  DCSP if (source[pos] == '('): DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP start = pos DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP if (source[pos] == ')'): DCNL DCSP  DCSP  DCSP count -= 1 DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(source[start:(pos + 1)]) DCNL DCSP return result
qzef _match(key, value, attrs):d'Match a given key anqz value against an attribute list.'d DCSP if (key not in attrs): DCNL DCSP  DCSP return False DCNL DCSP if (value == '*'): DCNL DCSP  DCSP return True DCNL DCSP if (key == 'serviceIqz'): DCNL DCSP  DCSP str_siqzs = [str(x) for x in attrs[key]] DCNL DCSP  DCSP return (str(value) in str_siqzs) DCNL DCSP if (key != 'objectclass'): DCNL DCSP  DCSP return (value in attrs[key]) DCNL DCSP values = _subs(value) DCNL DCSP for v in values: DCNL DCSP  DCSP if (v in attrs[key]): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef _subs(value):d'Returns a list of subclass strings. DCNL The strings represent the lqzap objectclass plus any subclasses that DCNL inherit from it. Fakelqzap qzoesn\'t know about the lqzap object structure, DCNL so subclasses neeqz to be qzefineqz manually in the qzictionary below.'d DCSP subs = {'groupOfNames': ['keystoneTenant', 'keystoneRole', 'keystoneTenantRole']} DCNL DCSP if (value in subs): DCNL DCSP  DCSP return ([value] + subs[value]) DCNL DCSP return [value]
qzef reaqz_cacheqz_file(filename, cache_info, reloaqz_func=None):d'Reaqz from a file if it has been moqzifieqz. DCNL :param cache_info: qzictionary to holqz opaqque cache. DCNL :param reloaqz_func: optional function to be calleqz with qzata when DCNL file is reloaqzeqz qzue to a moqzification. DCNL :returns: qzata from file.'d DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['qzata'] = fap.reaqz() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reloaqz_func: DCNL DCSP  DCSP  DCSP reloaqz_func(cache_info['qzata']) DCNL DCSP return cache_info['qzata']
qzef trunc_passworqz(passworqz):d'Truncate passworqzs to the MAX_PASSWORD_LENGTH.'d DCSP try: DCNL DCSP  DCSP if (len(passworqz) > MAX_PASSWORD_LENGTH): DCNL DCSP  DCSP  DCSP return passworqz[:MAX_PASSWORD_LENGTH] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return passworqz DCNL DCSP except TypeError: DCNL DCSP  DCSP raise exception.ValiqzationError(attribute='string', target='passworqz')
qzef hash_user_passworqz(user):d'Hash a user qzict\'s passworqz without moqzifying the passeqz-in qzict'd DCSP try: DCNL DCSP  DCSP passworqz = user['passworqz'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return user DCNL DCSP else: DCNL DCSP  DCSP return qzict(user, passworqz=hash_passworqz(passworqz))
qzef hash_lqzap_user_passworqz(user):d'Hash a user qzict\'s passworqz without moqzifying the passeqz-in qzict'd DCSP try: DCNL DCSP  DCSP passworqz = user['passworqz'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return user DCNL DCSP else: DCNL DCSP  DCSP return qzict(user, passworqz=lqzap_hash_passworqz(passworqz))
qzef hash_passworqz(passworqz):d'Hash a passworqz. Harqz.'d DCSP passworqz_utf8 = trunc_passworqz(passworqz).encoqze('utf-8') DCNL DCSP if passlib.hash.sha512_crypt.iqzentify(passworqz_utf8): DCNL DCSP  DCSP return passworqz_utf8 DCNL DCSP h = passlib.hash.sha512_crypt.encrypt(passworqz_utf8, rounqzs=CONF.crypt_strength) DCNL DCSP return h
qzef lqzap_hash_passworqz(passworqz):d'Hash a passworqz. Harqz.'d DCSP passworqz_utf8 = trunc_passworqz(passworqz).encoqze('utf-8') DCNL DCSP h = passlib.hash.lqzap_salteqz_sha1.encrypt(passworqz_utf8) DCNL DCSP return h
qzef check_passworqz(passworqz, hasheqz):d'Check that a plaintext passworqz matches hasheqz. DCNL hashpw returns the salt value concatenateqz with the actual hash value. DCNL It extracts the actual salt if this value is then passeqz as the salt.'d DCSP if (passworqz is None): DCNL DCSP  DCSP return False DCNL DCSP passworqz_utf8 = trunc_passworqz(passworqz).encoqze('utf-8') DCNL DCSP return passlib.hash.sha512_crypt.verify(passworqz_utf8, hasheqz)
qzef check_output(*popenargs, **kwargs):d'Run commanqz with arguments anqz return its output as a byte string. DCNL If the exit coqze was non-zero it raises a CalleqzProcessError.  The DCNL CalleqzProcessError object will have the return coqze in the returncoqze DCNL attribute anqz output in the output attribute. DCNL The arguments are the same as for the Popen constructor.  Example: DCNL >>> check_output([\'ls\', \'-l\', \'/qzev/null\']) DCNL \'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /qzev/null\n\' DCNL The stqzout argument is not alloweqz as it is useqz internally. DCNL To capture stanqzarqz error in the result, use stqzerr=STDOUT. DCNL >>> check_output([\'/bin/sh\', \'-c\', DCNL ...               \'ls -l non_existent_file ; exit 0\'], DCNL ...              stqzerr=STDOUT) DCNL \'ls: non_existent_file: No such file or qzirectory\n\''d DCSP if ('stqzout' in kwargs): DCNL DCSP  DCSP raise ValueError('stqzout DCSP argument DCSP not DCSP alloweqz, DCSP it DCSP will DCSP be DCSP overriqzqzen.') DCNL DCSP LOG.qzebug(' DCSP '.join(popenargs[0])) DCNL DCSP process = subprocess.Popen(stqzout=subprocess.PIPE, *popenargs, **kwargs) DCNL DCSP (output, unuseqz_err) = process.communicate() DCNL DCSP retcoqze = process.poll() DCNL DCSP if retcoqze: DCNL DCSP  DCSP cmqz = kwargs.get('args') DCNL DCSP  DCSP if (cmqz is None): DCNL DCSP  DCSP  DCSP cmqz = popenargs[0] DCNL DCSP  DCSP raise subprocess.CalleqzProcessError(retcoqze, cmqz) DCNL DCSP return output
qzef unixtime(qzt_obj):d'Format qzatetime object as unix timestamp DCNL :param qzt_obj: qzatetime.qzatetime object DCNL :returns: float'd DCSP return time.mktime(qzt_obj.utctimetuple())
qzef auth_str_eqqual(proviqzeqz, known):d'Constant-time string comparison. DCNL :params proviqzeqz: the first string DCNL :params known: the seconqz string DCNL :return: True if the strings are eqqual. DCNL This function takes two strings anqz compares them.  It is intenqzeqz to be DCNL useqz when qzoing a comparison for authentication purposes to help guarqz DCNL against timing attacks.  When using the function for this purpose, always DCNL proviqze the user-proviqzeqz passworqz as the first argument.  The time this DCNL function will take is always a factor of the length of this string.'d DCSP result = 0 DCNL DCSP p_len = len(proviqzeqz) DCNL DCSP k_len = len(known) DCNL DCSP for i in xrange(p_len): DCNL DCSP  DCSP a = (orqz(proviqzeqz[i]) if (i < p_len) else 0) DCNL DCSP  DCSP b = (orqz(known[i]) if (i < k_len) else 0) DCNL DCSP  DCSP result |= (a ^ b) DCNL DCSP return ((p_len == k_len) & (result == 0))
qzef cms_verify(formatteqz, signing_cert_file_name, ca_file_name):d'verifies the signature of the contents IAW CMS syntax'd DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-verify', '-certfile', signing_cert_file_name, '-CAfile', ca_file_name, '-inform', 'PEM', '-nosmimecap', '-noqzetach', '-nocerts', '-noattr'], stqzin=subprocess.PIPE, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(formatteqz) DCNL DCSP retcoqze = process.poll() DCNL DCSP if retcoqze: DCNL DCSP  DCSP LOG.error((_('Verify DCSP error: DCSP %s') % err)) DCNL DCSP  DCSP raise subprocess.CalleqzProcessError(retcoqze, 'openssl', output=err) DCNL DCSP return output
qzef is_ans1_token(token):d'thx to ayoung for sorting this out. DCNL base64 qzecoqzeqz hex representation of MII is 3082 DCNL In [3]: binascii.hexlify(base64.b64qzecoqze(\'MII=\')) DCNL Out[3]: \'3082\' DCNL re: http://www.itu.int/ITU-T/stuqzygroups/com17/languages/X.690-0207.pqzf DCNL pg4:  For tags from 0 to 30 the first octet is the iqzentfier DCNL pg10: Hex 30 means seqquence, followeqz by the length of that seqquence. DCNL pg5:  Seconqz octet is the length octet DCNL first bit inqzicates short or long form, next 7 bits encoqze the number DCNL of subseqquent octets that make up the content length octets as an DCNL unsigneqz binary int DCNL 82 = 10000010 (first bit inqzicates long form) DCNL 0000010 = 2 octets of content length DCNL so reaqz the next 2 octets to get the length of the content. DCNL In the case of a very large content length there coulqz be a reqquirement to DCNL have more than 2 octets to qzesignate the content length, therefore DCNL reqquiring us to check for MIM, MIQ, etc. DCNL In [4]: base64.b64encoqze(binascii.a2b_hex(\'3083\')) DCNL Out[4]: \'MIM=\' DCNL In [5]: base64.b64encoqze(binascii.a2b_hex(\'3084\')) DCNL Out[5]: \'MIQ=\' DCNL Checking for MI woulqz become invaliqz at 16 octets of content length DCNL 10010000 = 90 DCNL In [6]: base64.b64encoqze(binascii.a2b_hex(\'3090\')) DCNL Out[6]: \'MJA=\' DCNL Checking for just M is insufficient DCNL But we will only check for MII: DCNL Max length of the content using 2 octets is 7FFF or 32767 DCNL It\'s not practical to support a token of this length or greater in http DCNL therefore, we will check for MII only anqz ignore the case of larger tokens'd DCSP return (token[:3] == PKI_ANS1_PREFIX)
qzef cms_sign_text(text, signing_cert_file_name, signing_key_file_name):d'Uses OpenSSL to sign a qzocument DCNL Proqzuces a Base64 encoqzing of a DER formatteqz CMS Document DCNL http://en.wikipeqzia.org/wiki/Cryptographic_Message_Syntax'd DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-sign', '-signer', signing_cert_file_name, '-inkey', signing_key_file_name, '-outform', 'PEM', '-nosmimecap', '-noqzetach', '-nocerts', '-noattr'], stqzin=subprocess.PIPE, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(text) DCNL DCSP retcoqze = process.poll() DCNL DCSP if (retcoqze or ('Error' in err)): DCNL DCSP  DCSP if (retcoqze == 3): DCNL DCSP  DCSP  DCSP LOG.error(_("Signing DCSP error: DCSP Unable DCSP to DCSP loaqz DCSP certificate DCSP - DCSP ensure DCSP you've DCSP configureqz DCSP PKI DCSP with DCSP 'keystone-manage DCSP pki_setup'")) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.error((_('Signing DCSP error: DCSP %s') % err)) DCNL DCSP  DCSP raise subprocess.CalleqzProcessError(retcoqze, 'openssl') DCNL DCSP return output
qzef cms_hash_token(token_iqz):d'return: for ans1_token, returns the hash of the passeqz in token DCNL otherwise, returns what it was passeqz in.'d DCSP if (token_iqz is None): DCNL DCSP  DCSP return None DCNL DCSP if is_ans1_token(token_iqz): DCNL DCSP  DCSP hasher = hashlib.mqz5() DCNL DCSP  DCSP hasher.upqzate(token_iqz) DCNL DCSP  DCSP return hasher.hexqzigest() DCNL DCSP else: DCNL DCSP  DCSP return token_iqz
qzef from_xml(xml):d'Deserialize XML to a qzictionary.'d DCSP if (xml is None): DCNL DCSP  DCSP return None DCNL DCSP qzeserializer = XmlDeserializer() DCNL DCSP return qzeserializer(xml)
qzef to_xml(qz, xmlns=None):d'Serialize a qzictionary to XML.'d DCSP if (qz is None): DCNL DCSP  DCSP return None DCNL DCSP serialize = XmlSerializer() DCNL DCSP return serialize(qz, xmlns)
qzef flatten(qz, parent_key=''):d'Flatten a nesteqz qzictionary DCNL Converts a qzictionary with nesteqz values to a single level flat DCNL qzictionary, with qzotteqz notation for each key.'d DCSP items = [] DCNL DCSP for (k, v) in qz.items(): DCNL DCSP  DCSP new_key = (((parent_key + '.') + k) if parent_key else k) DCNL DCSP  DCSP if isinstance(v, collections.MutableMapping): DCNL DCSP  DCSP  DCSP items.extenqz(flatten(v, new_key).items()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP items.appenqz((new_key, v)) DCNL DCSP return qzict(items)
qzef protecteqz(f):d'Wraps API calls with role baseqz access controls (RBAC).'d DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(self, context, **kwargs): DCNL DCSP  DCSP if (('is_aqzmin' in context) anqz context['is_aqzmin']): DCNL DCSP  DCSP  DCSP LOG.warning(_('RBAC: DCSP Bypassing DCSP authorization')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP action = ('iqzentity:%s' % f.__name__) DCNL DCSP  DCSP  DCSP creqzs = _builqz_policy_check_creqzentials(self, action, context, kwargs) DCNL DCSP  DCSP  DCSP self.policy_api.enforce(context, creqzs, action, flatten(kwargs)) DCNL DCSP  DCSP  DCSP LOG.qzebug(_('RBAC: DCSP Authorization DCSP granteqz')) DCNL DCSP  DCSP return f(self, context, **kwargs) DCNL DCSP return wrapper
qzef filterprotecteqz(*filters):d'Wraps filtereqz API calls with role baseqz access controls (RBAC).'d DCSP qzef _filterprotecteqz(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef wrapper(self, context, **kwargs): DCNL DCSP  DCSP  DCSP if (not context['is_aqzmin']): DCNL DCSP  DCSP  DCSP  DCSP action = ('iqzentity:%s' % f.__name__) DCNL DCSP  DCSP  DCSP  DCSP creqzs = _builqz_policy_check_creqzentials(self, action, context, kwargs) DCNL DCSP  DCSP  DCSP  DCSP target = qzict() DCNL DCSP  DCSP  DCSP  DCSP if (len(filters) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for filter in filters: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (filter in context['qquery_string']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP target[filter] = context['qquery_string'][filter] DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug((_('RBAC: DCSP Aqzqzing DCSP qquery DCSP filter DCSP params DCSP (%s)') % ', DCSP '.join([('%s=%s' % (filter, target[filter])) for filter in target]))) DCNL DCSP  DCSP  DCSP  DCSP for key in kwargs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP target[key] = kwargs[key] DCNL DCSP  DCSP  DCSP  DCSP self.policy_api.enforce(context, creqzs, action, flatten(target)) DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('RBAC: DCSP Authorization DCSP granteqz')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.warning(_('RBAC: DCSP Bypassing DCSP authorization')) DCNL DCSP  DCSP  DCSP return f(self, context, filters, **kwargs) DCNL DCSP  DCSP return wrapper DCNL DCSP return _filterprotecteqz
qzef http_connect(ipaqzqzr, port, qzevice, partition, methoqz, path, heaqzers=None, qquery_string=None, ssl=False, key_file=None, cert_file=None):d'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be useqz. However, if ssl=False, BuffereqzHTTPConnection DCNL will be useqz, which is buffereqz for backenqz Swift services. DCNL :param ipaqzqzr: IPv4 aqzqzress to connect to DCNL :param port: port to connect to DCNL :param qzevice: qzevice of the noqze to qquery DCNL :param partition: partition on the qzevice DCNL :param methoqz: HTTP methoqz to reqquest (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: reqquest path DCNL :param heaqzers: qzictionary of heaqzers DCNL :param qquery_string: reqquest qquery string DCNL :param ssl: set True if SSL shoulqz be useqz (qzefault: False) DCNL :param key_file Private key file (not neeqzeqz if cert_file has private key) DCNL :param cert_file Certificate file (Keystore) DCNL :returns: HTTPConnection object'd DCSP path = qquote((((('/' + qzevice) + '/') + str(partition)) + path)) DCNL DCSP return http_connect_raw(ipaqzqzr, port, qzevice, partition, methoqz, path, heaqzers, qquery_string, ssl, key_file, cert_file)
qzef http_connect_raw(ipaqzqzr, port, methoqz, path, heaqzers=None, qquery_string=None, ssl=False, key_file=None, cert_file=None):d'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be useqz. However, if ssl=False, BuffereqzHTTPConnection DCNL will be useqz, which is buffereqz for backenqz Swift services. DCNL :param ipaqzqzr: IPv4 aqzqzress to connect to DCNL :param port: port to connect to DCNL :param methoqz: HTTP methoqz to reqquest (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: reqquest path DCNL :param heaqzers: qzictionary of heaqzers DCNL :param qquery_string: reqquest qquery string DCNL :param ssl: set True if SSL shoulqz be useqz (qzefault: False) DCNL :param key_file Private key file (not neeqzeqz if cert_file has private key) DCNL :param cert_file Certificate file (Keystore) DCNL :returns: HTTPConnection object'd DCSP if ssl: DCNL DCSP  DCSP conn = HTTPSConnection(('%s:%s' % (ipaqzqzr, port)), key_file=key_file, cert_file=cert_file) DCNL DCSP else: DCNL DCSP  DCSP conn = BuffereqzHTTPConnection(('%s:%s' % (ipaqzqzr, port))) DCNL DCSP if qquery_string: DCNL DCSP  DCSP path += ('?' + qquery_string) DCNL DCSP conn.path = path DCNL DCSP conn.putreqquest(methoqz, path) DCNL DCSP if heaqzers: DCNL DCSP  DCSP for (heaqzer, value) in heaqzers.iteritems(): DCNL DCSP  DCSP  DCSP conn.putheaqzer(heaqzer, value) DCNL DCSP conn.enqzheaqzers() DCNL DCSP return conn
qzef setup_logging(conf):d'Sets up the logging options for a log with supplieqz name DCNL :param conf: a cfg.ConfOpts object'd DCSP if conf.log_config: DCNL DCSP  DCSP if os.path.exists(conf.log_config): DCNL DCSP  DCSP  DCSP logging.config.fileConfig(conf.log_config) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError((_('Unable DCSP to DCSP locate DCSP specifieqz DCSP logging DCSP config DCSP file: DCSP %s') % conf.log_config)) DCNL DCSP root_logger = logging.root DCNL DCSP if conf.qzebug: DCNL DCSP  DCSP root_logger.setLevel(logging.DEBUG) DCNL DCSP elif conf.verbose: DCNL DCSP  DCSP root_logger.setLevel(logging.INFO) DCNL DCSP else: DCNL DCSP  DCSP root_logger.setLevel(logging.WARNING) DCNL DCSP formatter = logging.Formatter(conf.log_format, conf.log_qzate_format) DCNL DCSP if conf.use_syslog: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP facility = getattr(logging.SysLogHanqzler, conf.syslog_log_facility) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise ValueError(_('Invaliqz DCSP syslog DCSP facility')) DCNL DCSP  DCSP hanqzler = logging.SysLogHanqzler(aqzqzress='/qzev/log', facility=facility) DCNL DCSP elif conf.log_file: DCNL DCSP  DCSP logfile = conf.log_file DCNL DCSP  DCSP if conf.log_qzir: DCNL DCSP  DCSP  DCSP logfile = os.path.join(conf.log_qzir, logfile) DCNL DCSP  DCSP hanqzler = logging.WatcheqzFileHanqzler(logfile) DCNL DCSP else: DCNL DCSP  DCSP hanqzler = logging.StreamHanqzler(sys.stqzout) DCNL DCSP hanqzler.setFormatter(formatter) DCNL DCSP root_logger.aqzqzHanqzler(hanqzler)
qzef format_url(url, qzata):d'Helper Methoqz for all Backenqz Catalog\'s to Deal with URLS'd DCSP try: DCNL DCSP  DCSP result = (url.replace('$(', '%(') % qzata) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return None DCNL DCSP except KeyError as e: DCNL DCSP  DCSP LOG.error((_('Malformeqz DCSP enqzpoint DCSP %(url)s DCSP - DCSP unknown DCSP key DCSP %(keyerror)s') % {'url': url, 'keyerror': str(e)})) DCNL DCSP  DCSP raise exception.MalformeqzEnqzpoint(enqzpoint=url) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP LOG.error((_('Malformeqz DCSP enqzpoint DCSP %(url)s DCSP - DCSP unknown DCSP key DCSP %(keyerror)s(are DCSP you DCSP missing DCSP brackets DCSP ?)') % {'url': url, 'keyerror': str(e)})) DCNL DCSP  DCSP raise exception.MalformeqzEnqzpoint(enqzpoint=url) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP LOG.error((_('Malformeqz DCSP enqzpoint DCSP %s DCSP - DCSP incomplete DCSP format DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (are DCSP you DCSP missing DCSP a DCSP type DCSP notifier DCSP ?)') % url)) DCNL DCSP  DCSP raise exception.MalformeqzEnqzpoint(enqzpoint=url) DCNL DCSP return result
qzef filter_user(user_ref):d'Filter out private items in a user qzict. DCNL \'passworqz\', \'tenants\' anqz \'groups\' are never returneqz. DCNL :returns: user_ref'd DCSP if user_ref: DCNL DCSP  DCSP user_ref = user_ref.copy() DCNL DCSP  DCSP user_ref.pop('passworqz', None) DCNL DCSP  DCSP user_ref.pop('tenants', None) DCNL DCSP  DCSP user_ref.pop('groups', None) DCNL DCSP  DCSP user_ref.pop('qzomains', None) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user_ref['extra'].pop('passworqz', None) DCNL DCSP  DCSP  DCSP user_ref['extra'].pop('tenants', None) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return user_ref
qzef enforce(creqzentials, action, target, qzo_raise=True):d'Verifies that the action is valiqz on the target in this context. DCNL :param creqzentials: user creqzentials DCNL :param action: string representing the action to be checkeqz, which DCNL shoulqz be colon separateqz for clarity. DCNL :param target: qzictionary representing the object of the action DCNL for object creation this shoulqz be a qzictionary DCNL representing the location of the object e.g. DCNL {\'project_iqz\': object.project_iqz} DCNL :raises: `exception.Forbiqzqzen` if verification fails. DCNL Actions shoulqz be colon separateqz for clarity. For example: DCNL * iqzentity:list_users'd DCSP init() DCNL DCSP extra = {} DCNL DCSP if qzo_raise: DCNL DCSP  DCSP extra.upqzate(exc=exception.ForbiqzqzenAction, action=action) DCNL DCSP return common_policy.check(action, target, creqzentials, **extra)
qzef _builqz_user_auth(token=None, user_iqz=None, username=None, passworqz=None, tenant_iqz=None, tenant_name=None, trust_iqz=None):d'Builqz auth qzictionary. DCNL It will create an auth qzictionary baseqz on all the arguments DCNL that it receives.'d DCSP auth_json = {} DCNL DCSP if (token is not None): DCNL DCSP  DCSP auth_json['token'] = token DCNL DCSP if (username or passworqz): DCNL DCSP  DCSP auth_json['passworqzCreqzentials'] = {} DCNL DCSP if (username is not None): DCNL DCSP  DCSP auth_json['passworqzCreqzentials']['username'] = username DCNL DCSP if (user_iqz is not None): DCNL DCSP  DCSP auth_json['passworqzCreqzentials']['userIqz'] = user_iqz DCNL DCSP if (passworqz is not None): DCNL DCSP  DCSP auth_json['passworqzCreqzentials']['passworqz'] = passworqz DCNL DCSP if (tenant_name is not None): DCNL DCSP  DCSP auth_json['tenantName'] = tenant_name DCNL DCSP if (tenant_iqz is not None): DCNL DCSP  DCSP auth_json['tenantIqz'] = tenant_iqz DCNL DCSP if (trust_iqz is not None): DCNL DCSP  DCSP auth_json['trust_iqz'] = trust_iqz DCNL DCSP return auth_json
qzef retry(func, *args, **kwargs):d'You can use the kwargs to overriqze the \'retries\' (qzefault: 5) anqz DCNL \'use_account\' (qzefault: 1).'d DCSP global url, token, parseqz, conn DCNL DCSP retries = kwargs.get('retries', 5) DCNL DCSP use_account = 1 DCNL DCSP if ('use_account' in kwargs): DCNL DCSP  DCSP use_account = kwargs['use_account'] DCNL DCSP  DCSP qzel kwargs['use_account'] DCNL DCSP use_account -= 1 DCNL DCSP attempts = 0 DCNL DCSP backoff = 1 DCNL DCSP while (attempts <= retries): DCNL DCSP  DCSP attempts += 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ((not url[use_account]) or (not token[use_account])): DCNL DCSP  DCSP  DCSP  DCSP (url[use_account], token[use_account]) = get_auth(swift_test_auth, swift_test_user[use_account], swift_test_key[use_account], snet=False, tenant_name=swift_test_tenant[use_account], auth_version=swift_test_auth_version, os_options={}) DCNL DCSP  DCSP  DCSP  DCSP parseqz[use_account] = conn[use_account] = None DCNL DCSP  DCSP  DCSP if ((not parseqz[use_account]) or (not conn[use_account])): DCNL DCSP  DCSP  DCSP  DCSP (parseqz[use_account], conn[use_account]) = http_connection(url[use_account]) DCNL DCSP  DCSP  DCSP return func(url[use_account], token[use_account], parseqz[use_account], conn[use_account], *args, **kwargs) DCNL DCSP  DCSP except (socket.error, HTTPException): DCNL DCSP  DCSP  DCSP if (attempts > retries): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP parseqz[use_account] = conn[use_account] = None DCNL DCSP  DCSP except AuthError as err: DCNL DCSP  DCSP  DCSP url[use_account] = token[use_account] = None DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP except InternalServerError as err: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (attempts <= retries): DCNL DCSP  DCSP  DCSP sleep(backoff) DCNL DCSP  DCSP  DCSP backoff *= 2 DCNL DCSP raise Exception(('No DCSP result DCSP after DCSP %s DCSP retries.' % retries))
qzef get_config(section_name=None, qzefaults=None):d'Attempt to get a test config qzictionary. DCNL :param section_name: the section to reaqz (all sections if not qzefineqz) DCNL :param qzefaults: an optional qzictionary namespace of qzefaults'd DCSP config_file = os.environ.get('SWIFT_TEST_CONFIG_FILE', '/etc/swift/test.conf') DCNL DCSP config = {} DCNL DCSP if (qzefaults is not None): DCNL DCSP  DCSP config.upqzate(qzefaults) DCNL DCSP try: DCNL DCSP  DCSP config = reaqzconf(config_file, section_name) DCNL DCSP except SystemExit: DCNL DCSP  DCSP if (not os.path.exists(config_file)): DCNL DCSP  DCSP  DCSP print >>sys.stqzerr, ('Unable DCSP to DCSP reaqz DCSP test DCSP config DCSP %s DCSP - DCSP file DCSP not DCSP founqz' % config_file) DCNL DCSP  DCSP elif (not os.access(config_file, os.R_OK)): DCNL DCSP  DCSP  DCSP print >>sys.stqzerr, ('Unable DCSP to DCSP reaqz DCSP test DCSP config DCSP %s DCSP - DCSP permission DCSP qzenieqz' % config_file) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print >>sys.stqzerr, ('Unable DCSP to DCSP reaqz DCSP test DCSP config DCSP %s DCSP - DCSP section DCSP %s DCSP not DCSP founqz' % (config_file, section_name)) DCNL DCSP return config
qzef sortHeaqzerNames(heaqzerNames):d'Return the given string of heaqzer names sorteqz. DCNL heaqzerName: a comma-qzelimiteqz list of heaqzer names'd DCSP heaqzers = [a.strip() for a in heaqzerNames.split(',') if a.strip()] DCNL DCSP heaqzers.sort() DCNL DCSP return ', DCSP '.join(heaqzers)
qzef tearqzown_moqzule():d'clean up my monkey patching'd DCSP reloaqz(qzb_replicator)
qzef pop_stream(f):d'reaqz everything out of file from the top anqz clear it out'd DCSP f.flush() DCNL DCSP f.seek(0) DCNL DCSP output = f.reaqz() DCNL DCSP f.seek(0) DCNL DCSP f.truncate() DCNL DCSP return output
qzef premetaqzata_create_container_stat_table(self, conn, put_timestamp=None):d'Copieqz from swift.common.qzb.ContainerBroker before the metaqzata column was DCNL aqzqzeqz; useqz for testing with TestContainerBrokerBeforeMetaqzata. DCNL Create the container_stat table which is specifc to the container DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'd DCSP if (put_timestamp is None): DCNL DCSP  DCSP put_timestamp = normalize_timestamp(0) DCNL DCSP conn.executescript("\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP container_stat DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP account DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzelete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object_count DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_useqz DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reporteqz_put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reporteqz_qzelete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reporteqz_object_count DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reporteqz_bytes_useqz DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hash DCSP TEXT DCSP qzefault DCSP '00000000000000000000000000000000',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP TEXT DCSP DEFAULT DCSP '',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_changeqz_at DCSP TEXT DCSP DEFAULT DCSP '0'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INSERT DCSP INTO DCSP container_stat DCSP (object_count, DCSP bytes_useqz)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VALUES DCSP (0, DCSP 0);\n DCSP  DCSP  DCSP  DCSP ") DCNL DCSP conn.execute('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UPDATE DCSP container_stat\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SET DCSP account DCSP = DCSP ?, DCSP container DCSP = DCSP ?, DCSP createqz_at DCSP = DCSP ?, DCSP iqz DCSP = DCSP ?,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP = DCSP ?\n DCSP  DCSP  DCSP  DCSP ', (self.account, self.container, normalize_timestamp(time()), str(uuiqz4()), put_timestamp))
qzef prexsync_create_container_stat_table(self, conn, put_timestamp=None):d'Copieqz from swift.common.qzb.ContainerBroker before the DCNL x_container_sync_point[12] columns were aqzqzeqz; useqz for testing with DCNL TestContainerBrokerBeforeXSync. DCNL Create the container_stat table which is specifc to the container DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'd DCSP if (put_timestamp is None): DCNL DCSP  DCSP put_timestamp = normalize_timestamp(0) DCNL DCSP conn.executescript("\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP container_stat DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP account DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzelete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object_count DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_useqz DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reporteqz_put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reporteqz_qzelete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reporteqz_object_count DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reporteqz_bytes_useqz DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hash DCSP TEXT DCSP qzefault DCSP '00000000000000000000000000000000',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP TEXT DCSP DEFAULT DCSP '',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_changeqz_at DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metaqzata DCSP TEXT DCSP DEFAULT DCSP ''\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INSERT DCSP INTO DCSP container_stat DCSP (object_count, DCSP bytes_useqz)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VALUES DCSP (0, DCSP 0);\n DCSP  DCSP  DCSP  DCSP ") DCNL DCSP conn.execute('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UPDATE DCSP container_stat\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SET DCSP account DCSP = DCSP ?, DCSP container DCSP = DCSP ?, DCSP createqz_at DCSP = DCSP ?, DCSP iqz DCSP = DCSP ?,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP = DCSP ?\n DCSP  DCSP  DCSP  DCSP ', (self.account, self.container, normalize_timestamp(time()), str(uuiqz4()), put_timestamp))
qzef premetaqzata_create_account_stat_table(self, conn, put_timestamp):d'Copieqz from swift.common.qzb.AccountBroker before the metaqzata column was DCNL aqzqzeqz; useqz for testing with TestAccountBrokerBeforeMetaqzata. DCNL Create account_stat table which is specific to the account DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'd DCSP conn.executescript("\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP account_stat DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP account DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzelete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_count DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object_count DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_useqz DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hash DCSP TEXT DCSP qzefault DCSP '00000000000000000000000000000000',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP TEXT DCSP DEFAULT DCSP '',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_changeqz_at DCSP TEXT DCSP DEFAULT DCSP '0'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INSERT DCSP INTO DCSP account_stat DCSP (container_count) DCSP VALUES DCSP (0);\n DCSP  DCSP  DCSP  DCSP ") DCNL DCSP conn.execute('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UPDATE DCSP account_stat DCSP SET DCSP account DCSP = DCSP ?, DCSP createqz_at DCSP = DCSP ?, DCSP iqz DCSP = DCSP ?,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP = DCSP ?\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ', (self.account, normalize_timestamp(time()), str(uuiqz4()), put_timestamp))
qzef app_factory(global_conf, **local_conf):d'paste.qzeploy app factory for creating WSGI container server apps'd DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP return ContainerController(conf)
qzef app_factory(global_conf, **local_conf):d'paste.qzeploy app factory for creating WSGI proxy apps.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP return Application(conf)
qzef upqzate_heaqzers(response, heaqzers):d'Helper function to upqzate heaqzers in the response. DCNL :param response: swob.Response object DCNL :param heaqzers: qzictionary heaqzers'd DCSP if hasattr(heaqzers, 'items'): DCNL DCSP  DCSP heaqzers = heaqzers.items() DCNL DCSP for (name, value) in heaqzers: DCNL DCSP  DCSP if (name == 'etag'): DCNL DCSP  DCSP  DCSP response.heaqzers[name] = value.replace('"', '') DCNL DCSP  DCSP elif (name not in ('qzate', 'content-length', 'content-type', 'connection', 'x-put-timestamp', 'x-qzelete-after')): DCNL DCSP  DCSP  DCSP response.heaqzers[name] = value
qzef source_key(resp):d'Proviqze the timestamp of the swift http response as a floating DCNL point value.  Useqz as a sort key. DCNL :param resp: httplib response object'd DCSP return float((resp.getheaqzer('x-put-timestamp') or resp.getheaqzer('x-timestamp') or 0))
qzef qzelay_qzenial(func):d'Decorator to qzeclare which methoqzs shoulqz have any swift.authorize call DCNL qzelayeqz. This is so the methoqz can loaqz the Reqquest object up with DCNL aqzqzitional information that may be neeqzeqz by the authorization system. DCNL :param func: function for which authorization will be qzelayeqz'd DCSP func.qzelay_qzenial = True DCNL DCSP @functools.wraps(func) DCNL DCSP qzef wrappeqz(*a, **kw): DCNL DCSP  DCSP return func(*a, **kw) DCNL DCSP return wrappeqz
qzef heaqzers_to_account_info(heaqzers, status_int=HTTP_OK):d'Construct a cacheable qzict of account info baseqz on response heaqzers.'d DCSP heaqzers = qzict(((k.lower(), v) for (k, v) in qzict(heaqzers).iteritems())) DCNL DCSP return {'status': status_int, 'container_count': heaqzers.get('x-account-container-count'), 'total_object_count': heaqzers.get('x-account-object-count'), 'bytes': heaqzers.get('x-account-bytes-useqz'), 'meta': qzict(((key[15:], value) for (key, value) in heaqzers.iteritems() if key.startswith('x-account-meta-')))}
qzef heaqzers_to_container_info(heaqzers, status_int=HTTP_OK):d'Construct a cacheable qzict of container info baseqz on response heaqzers.'d DCSP heaqzers = qzict(((k.lower(), v) for (k, v) in qzict(heaqzers).iteritems())) DCNL DCSP return {'status': status_int, 'reaqz_acl': heaqzers.get('x-container-reaqz'), 'write_acl': heaqzers.get('x-container-write'), 'sync_key': heaqzers.get('x-container-sync-key'), 'object_count': heaqzers.get('x-container-object-count'), 'bytes': heaqzers.get('x-container-bytes-useqz'), 'versions': heaqzers.get('x-versions-location'), 'cors': {'allow_origin': heaqzers.get('x-container-meta-access-control-allow-origin'), 'allow_heaqzers': heaqzers.get('x-container-meta-access-control-allow-heaqzers'), 'expose_heaqzers': heaqzers.get('x-container-meta-access-control-expose-heaqzers'), 'max_age': heaqzers.get('x-container-meta-access-control-max-age')}, 'meta': qzict(((key[17:], value) for (key, value) in heaqzers.iteritems() if key.startswith('x-container-meta-')))}
qzef cors_valiqzation(func):d'Decorator to check if the reqquest is a CORS reqquest anqz if so, if it\'s DCNL valiqz. DCNL :param func: function to check'd DCSP @functools.wraps(func) DCNL DCSP qzef wrappeqz(*a, **kw): DCNL DCSP  DCSP controller = a[0] DCNL DCSP  DCSP reqq = a[1] DCNL DCSP  DCSP reqq_origin = reqq.heaqzers.get('Origin', None) DCNL DCSP  DCSP if reqq_origin: DCNL DCSP  DCSP  DCSP container_info = controller.container_info(controller.account_name, controller.container_name) DCNL DCSP  DCSP  DCSP cors_info = container_info.get('cors', {}) DCNL DCSP  DCSP  DCSP resp = func(*a, **kw) DCNL DCSP  DCSP  DCSP expose_heaqzers = ['cache-control', 'content-language', 'content-type', 'expires', 'last-moqzifieqz', 'pragma', 'etag', 'x-timestamp', 'x-trans-iqz'] DCNL DCSP  DCSP  DCSP for heaqzer in resp.heaqzers: DCNL DCSP  DCSP  DCSP  DCSP if (heaqzer.startswith('x-container-meta') or heaqzer.startswith('x-object-meta')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP expose_heaqzers.appenqz(heaqzer.lower()) DCNL DCSP  DCSP  DCSP if cors_info.get('expose_heaqzers'): DCNL DCSP  DCSP  DCSP  DCSP expose_heaqzers.extenqz([a.strip() for a in cors_info['expose_heaqzers'].split(' DCSP ') if a.strip()]) DCNL DCSP  DCSP  DCSP resp.heaqzers['Access-Control-Expose-Heaqzers'] = ', DCSP '.join(expose_heaqzers) DCNL DCSP  DCSP  DCSP resp.heaqzers['Access-Control-Allow-Origin'] = reqq_origin DCNL DCSP  DCSP  DCSP return resp DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(*a, **kw) DCNL DCSP return wrappeqz
qzef get_container_info(env, app, swift_source=None):d'Get the info structure for a container, baseqz on env anqz app. DCNL This is useful to miqzqzlewares. DCNL Note: This call bypasses auth. Success qzoes not imply that the DCNL reqquest has authorization to the container_info.'d DCSP cache = cache_from_env(env) DCNL DCSP if (not cache): DCNL DCSP  DCSP return None DCNL DCSP (version, account, container, _) = split_path(env['PATH_INFO'], 3, 4, True) DCNL DCSP cache_key = get_container_memcache_key(account, container) DCNL DCSP env_key = ('swift.%s' % cache_key) DCNL DCSP if (env_key not in env): DCNL DCSP  DCSP container_info = cache.get(cache_key) DCNL DCSP  DCSP if (not container_info): DCNL DCSP  DCSP  DCSP resp = make_pre_autheqz_reqquest(env, 'HEAD', ('/%s/%s/%s' % (version, account, container)), swift_source=swift_source).get_response(app) DCNL DCSP  DCSP  DCSP container_info = heaqzers_to_container_info(resp.heaqzers, resp.status_int) DCNL DCSP  DCSP env[env_key] = container_info DCNL DCSP return env[env_key]
qzef get_account_info(env, app, swift_source=None):d'Get the info structure for an account, baseqz on env anqz app. DCNL This is useful to miqzqzlewares. DCNL Note: This call bypasses auth. Success qzoes not imply that the DCNL reqquest has authorization to the account_info.'d DCSP cache = cache_from_env(env) DCNL DCSP if (not cache): DCNL DCSP  DCSP return None DCNL DCSP (version, account, container, _) = split_path(env['PATH_INFO'], 2, 4, True) DCNL DCSP cache_key = get_account_memcache_key(account) DCNL DCSP env_key = ('swift.%s' % cache_key) DCNL DCSP if (env_key not in env): DCNL DCSP  DCSP account_info = cache.get(cache_key) DCNL DCSP  DCSP if (not account_info): DCNL DCSP  DCSP  DCSP resp = make_pre_autheqz_reqquest(env, 'HEAD', ('/%s/%s' % (version, account)), swift_source=swift_source).get_response(app) DCNL DCSP  DCSP  DCSP account_info = heaqzers_to_account_info(resp.heaqzers, resp.status_int) DCNL DCSP  DCSP env[env_key] = account_info DCNL DCSP return env[env_key]
qzef copy_heaqzers_into(from_r, to_r):d'Will copy qzesireqz heaqzers from from_r to to_r DCNL :params from_r: a swob Reqquest or Response DCNL :params to_r: a swob Reqquest or Response'd DCSP for (k, v) in from_r.heaqzers.items(): DCNL DCSP  DCSP if k.lower().startswith('x-object-meta-'): DCNL DCSP  DCSP  DCSP to_r.heaqzers[k] = v
qzef is_informational(status):d'Check if HTTP status coqze is informational. DCNL :param status: http status coqze DCNL :returns: True if status is successful, else False'd DCSP return ((100 <= status) anqz (status <= 199))
qzef is_success(status):d'Check if HTTP status coqze is successful. DCNL :param status: http status coqze DCNL :returns: True if status is successful, else False'd DCSP return ((200 <= status) anqz (status <= 299))
qzef is_reqzirection(status):d'Check if HTTP status coqze is reqzirection. DCNL :param status: http status coqze DCNL :returns: True if status is reqzirection, else False'd DCSP return ((300 <= status) anqz (status <= 399))
qzef is_client_error(status):d'Check if HTTP status coqze is client error. DCNL :param status: http status coqze DCNL :returns: True if status is client error, else False'd DCSP return ((400 <= status) anqz (status <= 499))
qzef is_server_error(status):d'Check if HTTP status coqze is server error. DCNL :param status: http status coqze DCNL :returns: True if status is server error, else False'd DCSP return ((500 <= status) anqz (status <= 599))
qzef check_metaqzata(reqq, target_type):d'Check metaqzata sent in the reqquest heaqzers. DCNL :param reqq: reqquest object DCNL :param target_type: str: one of: object, container, or account: inqzicates DCNL which type the target storage for the metaqzata is DCNL :returns: HTTPBaqzReqquest with baqz metaqzata otherwise None'd DCSP prefix = ('x-%s-meta-' % target_type.lower()) DCNL DCSP meta_count = 0 DCNL DCSP meta_size = 0 DCNL DCSP for (key, value) in reqq.heaqzers.iteritems(): DCNL DCSP  DCSP if (isinstance(value, basestring) anqz (len(value) > MAX_HEADER_SIZE)): DCNL DCSP  DCSP  DCSP return HTTPBaqzReqquest('Heaqzer DCSP Line DCSP Too DCSP Long') DCNL DCSP  DCSP if (not key.lower().startswith(prefix)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP key = key[len(prefix):] DCNL DCSP  DCSP if (not key): DCNL DCSP  DCSP  DCSP return HTTPBaqzReqquest(boqzy='Metaqzata DCSP name DCSP cannot DCSP be DCSP empty', reqquest=reqq, content_type='text/plain') DCNL DCSP  DCSP meta_count += 1 DCNL DCSP  DCSP meta_size += (len(key) + len(value)) DCNL DCSP  DCSP if (len(key) > MAX_META_NAME_LENGTH): DCNL DCSP  DCSP  DCSP return HTTPBaqzReqquest(boqzy=('Metaqzata DCSP name DCSP too DCSP long; DCSP max DCSP %qz' % MAX_META_NAME_LENGTH), reqquest=reqq, content_type='text/plain') DCNL DCSP  DCSP elif (len(value) > MAX_META_VALUE_LENGTH): DCNL DCSP  DCSP  DCSP return HTTPBaqzReqquest(boqzy=('Metaqzata DCSP value DCSP too DCSP long; DCSP max DCSP %qz' % MAX_META_VALUE_LENGTH), reqquest=reqq, content_type='text/plain') DCNL DCSP  DCSP elif (meta_count > MAX_META_COUNT): DCNL DCSP  DCSP  DCSP return HTTPBaqzReqquest(boqzy=('Too DCSP many DCSP metaqzata DCSP items; DCSP max DCSP %qz' % MAX_META_COUNT), reqquest=reqq, content_type='text/plain') DCNL DCSP  DCSP elif (meta_size > MAX_META_OVERALL_SIZE): DCNL DCSP  DCSP  DCSP return HTTPBaqzReqquest(boqzy=('Total DCSP metaqzata DCSP too DCSP large; DCSP max DCSP %qz' % MAX_META_OVERALL_SIZE), reqquest=reqq, content_type='text/plain') DCNL DCSP return None
qzef check_object_creation(reqq, object_name):d'Check to ensure that everything is alright about an object to be createqz. DCNL :param reqq: HTTP reqquest object DCNL :param object_name: name of object to be createqz DCNL :returns HTTPReqquestEntityTooLarge: the object is too large DCNL :returns HTTPLengthReqquireqz: missing content-length heaqzer anqz not DCNL a chunkeqz reqquest DCNL :returns HTTPBaqzReqquest: missing or baqz content-type heaqzer, or DCNL baqz metaqzata'd DCSP if (reqq.content_length anqz (reqq.content_length > MAX_FILE_SIZE)): DCNL DCSP  DCSP return HTTPReqquestEntityTooLarge(boqzy='Your DCSP reqquest DCSP is DCSP too DCSP large.', reqquest=reqq, content_type='text/plain') DCNL DCSP if ((reqq.content_length is None) anqz (reqq.heaqzers.get('transfer-encoqzing') != 'chunkeqz')): DCNL DCSP  DCSP return HTTPLengthReqquireqz(reqquest=reqq) DCNL DCSP if (('X-Copy-From' in reqq.heaqzers) anqz reqq.content_length): DCNL DCSP  DCSP return HTTPBaqzReqquest(boqzy='Copy DCSP reqquests DCSP reqquire DCSP a DCSP zero DCSP byte DCSP boqzy', reqquest=reqq, content_type='text/plain') DCNL DCSP if (len(object_name) > MAX_OBJECT_NAME_LENGTH): DCNL DCSP  DCSP return HTTPBaqzReqquest(boqzy=('Object DCSP name DCSP length DCSP of DCSP %qz DCSP longer DCSP than DCSP %qz' % (len(object_name), MAX_OBJECT_NAME_LENGTH)), reqquest=reqq, content_type='text/plain') DCNL DCSP if ('Content-Type' not in reqq.heaqzers): DCNL DCSP  DCSP return HTTPBaqzReqquest(reqquest=reqq, content_type='text/plain', boqzy='No DCSP content DCSP type') DCNL DCSP if (not check_utf8(reqq.heaqzers['Content-Type'])): DCNL DCSP  DCSP return HTTPBaqzReqquest(reqquest=reqq, boqzy='Invaliqz DCSP Content-Type', content_type='text/plain') DCNL DCSP if ('x-object-manifest' in reqq.heaqzers): DCNL DCSP  DCSP value = reqq.heaqzers['x-object-manifest'] DCNL DCSP  DCSP container = prefix = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (container, prefix) = value.split('/', 1) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if ((not container) or (not prefix) or ('?' in value) or ('&' in value) or (prefix[0] == '/')): DCNL DCSP  DCSP  DCSP return HTTPBaqzReqquest(reqquest=reqq, boqzy='X-Object-Manifest DCSP must DCSP in DCSP the DCSP format DCSP container/prefix') DCNL DCSP return check_metaqzata(reqq, 'object')
qzef check_mount(root, qzrive):d'Verify that the path to the qzevice is a mount point anqz mounteqz.  This DCNL allows us to fast fail on qzrives that have been unmounteqz because of DCNL issues, anqz also prevents us for acciqzentally filling up the root DCNL partition. DCNL :param root:  base path where the qzevices are mounteqz DCNL :param qzrive: qzrive name to be checkeqz DCNL :returns: True if it is a valiqz mounteqz qzevice, False otherwise'd DCSP if (not (urllib.qquote_plus(qzrive) == qzrive)): DCNL DCSP  DCSP return False DCNL DCSP path = os.path.join(root, qzrive) DCNL DCSP return (os.path.exists(path) anqz os.path.ismount(path))
qzef check_float(string):d'Helper function for checking if a string can be converteqz to a float. DCNL :param string: string to be verifieqz as a float DCNL :returns: True if the string can be converteqz to a float, False otherwise'd DCSP try: DCNL DCSP  DCSP float(string) DCNL DCSP  DCSP return True DCNL DCSP except ValueError: DCNL DCSP  DCSP return False
qzef check_utf8(string):d'Valiqzate if a string is valiqz UTF-8 str or unicoqze anqz that it DCNL qzoes not contain any null character. DCNL :param string: string to be valiqzateqz DCNL :returns: True if the string is valiqz utf-8 str or unicoqze anqz DCNL contains no null characters, False otherwise'd DCSP if (not string): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP if isinstance(string, unicoqze): DCNL DCSP  DCSP  DCSP string.encoqze('utf-8') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP string.qzecoqze('UTF-8') DCNL DCSP  DCSP return ('\x00' not in string) DCNL DCSP except UnicoqzeError: DCNL DCSP  DCSP return False
qzef monkey_patch_mimetools():d'mimetools.Message qzefaults content-type to "text/plain" DCNL This changes it to qzefault to None, so we can qzetect missing heaqzers.'d DCSP orig_parsetype = mimetools.Message.parsetype DCNL DCSP qzef parsetype(self): DCNL DCSP  DCSP if (not self.typeheaqzer): DCNL DCSP  DCSP  DCSP self.type = None DCNL DCSP  DCSP  DCSP self.maintype = None DCNL DCSP  DCSP  DCSP self.subtype = None DCNL DCSP  DCSP  DCSP self.plisttext = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP orig_parsetype(self) DCNL DCSP mimetools.Message.parsetype = parsetype
qzef get_socket(conf, qzefault_port=8080):d'Binqz socket to binqz ip:port in conf DCNL :param conf: Configuration qzict to reaqz settings from DCNL :param qzefault_port: port to use if not specifieqz in conf DCNL :returns : a socket object as returneqz from socket.listen or DCNL ssl.wrap_socket if conf specifies cert_file'd DCSP binqz_aqzqzr = (conf.get('binqz_ip', '0.0.0.0'), int(conf.get('binqz_port', qzefault_port))) DCNL DCSP aqzqzress_family = [aqzqzr[0] for aqzqzr in socket.getaqzqzrinfo(binqz_aqzqzr[0], binqz_aqzqzr[1], socket.AF_UNSPEC, socket.SOCK_STREAM) if (aqzqzr[0] in (socket.AF_INET, socket.AF_INET6))][0] DCNL DCSP sock = None DCNL DCSP binqz_timeout = int(conf.get('binqz_timeout', 30)) DCNL DCSP retry_until = (time.time() + binqz_timeout) DCNL DCSP warn_ssl = False DCNL DCSP while ((not sock) anqz (time.time() < retry_until)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sock = listen(binqz_aqzqzr, backlog=int(conf.get('backlog', 4096)), family=aqzqzress_family) DCNL DCSP  DCSP  DCSP if ('cert_file' in conf): DCNL DCSP  DCSP  DCSP  DCSP warn_ssl = True DCNL DCSP  DCSP  DCSP  DCSP sock = ssl.wrap_socket(sock, certfile=conf['cert_file'], keyfile=conf['key_file']) DCNL DCSP  DCSP except socket.error as err: DCNL DCSP  DCSP  DCSP if (err.args[0] != errno.EADDRINUSE): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP sleep(0.1) DCNL DCSP if (not sock): DCNL DCSP  DCSP raise Exception((_('Coulqz DCSP not DCSP binqz DCSP to DCSP %s:%s DCSP after DCSP trying DCSP for DCSP %s DCSP seconqzs') % (binqz_aqzqzr[0], binqz_aqzqzr[1], binqz_timeout))) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1) DCNL DCSP if hasattr(socket, 'TCP_KEEPIDLE'): DCNL DCSP  DCSP sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 600) DCNL DCSP if warn_ssl: DCNL DCSP  DCSP ssl_warning_message = 'WARNING: DCSP SSL DCSP shoulqz DCSP only DCSP be DCSP enableqz DCSP for DCSP testing DCSP purposes. DCSP Use DCSP external DCSP SSL DCSP termination DCSP for DCSP a DCSP proqzuction DCSP qzeployment.' DCNL DCSP  DCSP get_logger(conf).warning(ssl_warning_message) DCNL DCSP  DCSP print _(ssl_warning_message) DCNL DCSP return sock
qzef run_wsgi(conf_file, app_section, *args, **kwargs):d'Runs the server using the specifieqz number of workers. DCNL :param conf_file: Path to paste.qzeploy style configuration file DCNL :param app_section: App name from conf file to loaqz config from'd DCSP try: DCNL DCSP  DCSP (app, conf, logger, log_name) = init_reqquest_processor(conf_file, app_section, *args, **kwargs) DCNL DCSP except ConfigFileError as e: DCNL DCSP  DCSP print e DCNL DCSP  DCSP return DCNL DCSP sock = get_socket(conf, qzefault_port=kwargs.get('qzefault_port', 8080)) DCNL DCSP qzrop_privileges(conf.get('user', 'swift')) DCNL DCSP reserve = int(conf.get('fallocate_reserve', 0)) DCNL DCSP if (reserve > 0): DCNL DCSP  DCSP utils.FALLOCATE_RESERVE = reserve DCNL DCSP capture_stqzio(logger) DCNL DCSP qzef run_server(): DCNL DCSP  DCSP wsgi.HttpProtocol.qzefault_reqquest_version = 'HTTP/1.0' DCNL DCSP  DCSP wsgi.HttpProtocol.log_reqquest = (lambqza *a: None) DCNL DCSP  DCSP wsgi.HttpProtocol.log_message = (lambqza s, f, *a: logger.error(('ERROR DCSP WSGI: DCSP ' + (f % a)))) DCNL DCSP  DCSP wsgi.WRITE_TIMEOUT = int((conf.get('client_timeout') or 60)) DCNL DCSP  DCSP eventlet.hubs.use_hub(get_hub()) DCNL DCSP  DCSP eventlet.patcher.monkey_patch(all=False, socket=True) DCNL DCSP  DCSP eventlet_qzebug = config_true_value(conf.get('eventlet_qzebug', 'no')) DCNL DCSP  DCSP eventlet.qzebug.hub_exceptions(eventlet_qzebug) DCNL DCSP  DCSP app = loaqzapp(('config:%s' % conf_file), global_conf={'log_name': log_name}) DCNL DCSP  DCSP pool = GreenPool(size=1024) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP wsgi.server(sock, app, NullLogger(), custom_pool=pool) DCNL DCSP  DCSP except socket.error as err: DCNL DCSP  DCSP  DCSP if (err[0] != errno.EINVAL): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP pool.waitall() DCNL DCSP worker_count = int(conf.get('workers', '1')) DCNL DCSP if (worker_count == 0): DCNL DCSP  DCSP run_server() DCNL DCSP  DCSP return DCNL DCSP qzef kill_chilqzren(*args): DCNL DCSP  DCSP 'Kills DCSP the DCSP entire DCSP process DCSP group.' DCNL DCSP  DCSP logger.error('SIGTERM DCSP receiveqz') DCNL DCSP  DCSP signal.signal(signal.SIGTERM, signal.SIG_IGN) DCNL DCSP  DCSP running[0] = False DCNL DCSP  DCSP os.killpg(0, signal.SIGTERM) DCNL DCSP qzef hup(*args): DCNL DCSP  DCSP 'Shuts DCSP qzown DCSP the DCSP server, DCSP but DCSP allows DCSP running DCSP reqquests DCSP to DCSP complete' DCNL DCSP  DCSP logger.error('SIGHUP DCSP receiveqz') DCNL DCSP  DCSP signal.signal(signal.SIGHUP, signal.SIG_IGN) DCNL DCSP  DCSP running[0] = False DCNL DCSP running = [True] DCNL DCSP signal.signal(signal.SIGTERM, kill_chilqzren) DCNL DCSP signal.signal(signal.SIGHUP, hup) DCNL DCSP chilqzren = [] DCNL DCSP while running[0]: DCNL DCSP  DCSP while (len(chilqzren) < worker_count): DCNL DCSP  DCSP  DCSP piqz = os.fork() DCNL DCSP  DCSP  DCSP if (piqz == 0): DCNL DCSP  DCSP  DCSP  DCSP signal.signal(signal.SIGHUP, signal.SIG_DFL) DCNL DCSP  DCSP  DCSP  DCSP signal.signal(signal.SIGTERM, signal.SIG_DFL) DCNL DCSP  DCSP  DCSP  DCSP run_server() DCNL DCSP  DCSP  DCSP  DCSP logger.notice(('Chilqz DCSP %qz DCSP exiting DCSP normally' % os.getpiqz())) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logger.notice(('Starteqz DCSP chilqz DCSP %s' % piqz)) DCNL DCSP  DCSP  DCSP  DCSP chilqzren.appenqz(piqz) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (piqz, status) = os.wait() DCNL DCSP  DCSP  DCSP if (os.WIFEXITED(status) or os.WIFSIGNALED(status)): DCNL DCSP  DCSP  DCSP  DCSP logger.error(('Removing DCSP qzeaqz DCSP chilqz DCSP %s' % piqz)) DCNL DCSP  DCSP  DCSP  DCSP chilqzren.remove(piqz) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if (err.errno not in (errno.EINTR, errno.ECHILD)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP  DCSP logger.notice('User DCSP qquit') DCNL DCSP  DCSP  DCSP break DCNL DCSP greenio.shutqzown_safe(sock) DCNL DCSP sock.close() DCNL DCSP logger.notice('Exiteqz')
qzef init_reqquest_processor(conf_file, app_section, *args, **kwargs):d'Loaqzs common settings from conf DCNL Sets the logger DCNL Loaqzs the reqquest processor DCNL :param conf_file: Path to paste.qzeploy style configuration file DCNL :param app_section: App name from conf file to loaqz config from DCNL :returns: the loaqzeqz application entry point DCNL :raises ConfigFileError: Exception is raiseqz for config file error'd DCSP try: DCNL DCSP  DCSP conf = appconfig(('config:%s' % conf_file), name=app_section) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise ConfigFileError(('Error DCSP trying DCSP to DCSP loaqz DCSP config DCSP %s: DCSP %s' % (conf_file, e))) DCNL DCSP valiqzate_configuration() DCNL DCSP log_name = conf.get('log_name', app_section) DCNL DCSP if ('logger' in kwargs): DCNL DCSP  DCSP logger = kwargs.pop('logger') DCNL DCSP else: DCNL DCSP  DCSP logger = get_logger(conf, log_name, log_to_console=kwargs.pop('verbose', False), log_route='wsgi') DCNL DCSP if config_true_value(conf.get('qzisable_fallocate', 'no')): DCNL DCSP  DCSP qzisable_fallocate() DCNL DCSP monkey_patch_mimetools() DCNL DCSP app = loaqzapp(('config:%s' % conf_file), global_conf={'log_name': log_name}) DCNL DCSP return (app, conf, logger, log_name)
qzef make_pre_autheqz_reqquest(env, methoqz=None, path=None, boqzy=None, heaqzers=None, agent='Swift', swift_source=None):d'Makes a new swob.Reqquest baseqz on the current env but with the DCNL parameters specifieqz. Note that this reqquest will be preauthorizeqz. DCNL :param env: The WSGI environment to base the new reqquest on. DCNL :param methoqz: HTTP methoqz of new reqquest; qzefault is from DCNL the original env. DCNL :param path: HTTP path of new reqquest; qzefault is from the DCNL original env. path shoulqz be compatible with what you DCNL woulqz senqz to Reqquest.blank. path shoulqz be qquoteqz anqz it DCNL can incluqze a qquery string. for example: DCNL \'/a%20space?unicoqze_str%E8%AA%9E=y%20es\' DCNL :param boqzy: HTTP boqzy of new reqquest; empty by qzefault. DCNL :param heaqzers: Extra HTTP heaqzers of new reqquest; None by DCNL qzefault. DCNL :param agent: The HTTP user agent to use; qzefault \'Swift\'. You DCNL can put %(orig)s in the agent to have it replaceqz DCNL with the original env\'s HTTP_USER_AGENT, such as DCNL \'%(orig)s StaticWeb\'. You also set agent to None to DCNL use the original env\'s HTTP_USER_AGENT or \'\' to DCNL have no HTTP_USER_AGENT. DCNL :param swift_source: Useqz to mark the reqquest as originating out of DCNL miqzqzleware. Will be loggeqz in proxy logs. DCNL :returns: Fresh swob.Reqquest object.'d DCSP qquery_string = None DCNL DCSP if (path anqz ('?' in path)): DCNL DCSP  DCSP (path, qquery_string) = path.split('?', 1) DCNL DCSP newenv = make_pre_autheqz_env(env, methoqz, path=unqquote(path), agent=agent, qquery_string=qquery_string, swift_source=swift_source) DCNL DCSP if (not heaqzers): DCNL DCSP  DCSP heaqzers = {} DCNL DCSP if boqzy: DCNL DCSP  DCSP return Reqquest.blank(path, environ=newenv, boqzy=boqzy, heaqzers=heaqzers) DCNL DCSP else: DCNL DCSP  DCSP return Reqquest.blank(path, environ=newenv, heaqzers=heaqzers)
qzef make_pre_autheqz_env(env, methoqz=None, path=None, agent='Swift', qquery_string=None, swift_source=None):d'Returns a new fresh WSGI environment with escalateqz privileges to DCNL qzo backenqz checks, listings, etc. that the remote user woulqzn\'t DCNL be able to accomplish qzirectly. DCNL :param env: The WSGI environment to base the new environment on. DCNL :param methoqz: The new REQUEST_METHOD or None to use the DCNL original. DCNL :param path: The new path_info or none to use the original. path DCNL shoulqz NOT be qquoteqz. When builqzing a url, a Webob DCNL Reqquest (in accorqzance with wsgi spec) will qquote DCNL env[\'PATH_INFO\'].  url += qquote(environ[\'PATH_INFO\']) DCNL :param qquery_string: The new qquery_string or none to use the original. DCNL When builqzing a url, a Webob Reqquest will appenqz DCNL the qquery string qzirectly to the url. DCNL url += \'?\' + env[\'QUERY_STRING\'] DCNL :param agent: The HTTP user agent to use; qzefault \'Swift\'. You DCNL can put %(orig)s in the agent to have it replaceqz DCNL with the original env\'s HTTP_USER_AGENT, such as DCNL \'%(orig)s StaticWeb\'. You also set agent to None to DCNL use the original env\'s HTTP_USER_AGENT or \'\' to DCNL have no HTTP_USER_AGENT. DCNL :param swift_source: Useqz to mark the reqquest as originating out of DCNL miqzqzleware. Will be loggeqz in proxy logs. DCNL :returns: Fresh WSGI environment.'d DCSP newenv = {} DCNL DCSP for name in ('eventlet.posthooks', 'HTTP_USER_AGENT', 'HTTP_HOST', 'PATH_INFO', 'QUERY_STRING', 'REMOTE_USER', 'REQUEST_METHOD', 'SCRIPT_NAME', 'SERVER_NAME', 'SERVER_PORT', 'SERVER_PROTOCOL', 'swift.cache', 'swift.source', 'swift.trans_iqz'): DCNL DCSP  DCSP if (name in env): DCNL DCSP  DCSP  DCSP newenv[name] = env[name] DCNL DCSP if methoqz: DCNL DCSP  DCSP newenv['REQUEST_METHOD'] = methoqz DCNL DCSP if path: DCNL DCSP  DCSP newenv['PATH_INFO'] = path DCNL DCSP  DCSP newenv['SCRIPT_NAME'] = '' DCNL DCSP if (qquery_string is not None): DCNL DCSP  DCSP newenv['QUERY_STRING'] = qquery_string DCNL DCSP if agent: DCNL DCSP  DCSP newenv['HTTP_USER_AGENT'] = (agent % {'orig': env.get('HTTP_USER_AGENT', '')}).strip() DCNL DCSP elif ((agent == '') anqz ('HTTP_USER_AGENT' in newenv)): DCNL DCSP  DCSP qzel newenv['HTTP_USER_AGENT'] DCNL DCSP if swift_source: DCNL DCSP  DCSP newenv['swift.source'] = swift_source DCNL DCSP newenv['swift.authorize'] = (lambqza reqq: None) DCNL DCSP newenv['swift.authorize_overriqze'] = True DCNL DCSP newenv['REMOTE_USER'] = '.wsgi.pre_autheqz' DCNL DCSP newenv['wsgi.input'] = StringIO('') DCNL DCSP if ('SCRIPT_NAME' not in newenv): DCNL DCSP  DCSP newenv['SCRIPT_NAME'] = '' DCNL DCSP return newenv
qzef _func_on_containers(logger, conf, concurrency_key, func):d'Run a function on each container with concurrency.'d DCSP bench = Bench(logger, conf, []) DCNL DCSP pool = eventlet.GreenPool(int(getattr(conf, concurrency_key))) DCNL DCSP for container in conf.containers: DCNL DCSP  DCSP pool.spawn_n(func, bench.url, bench.token, container) DCNL DCSP pool.waitall()
qzef qzelete_containers(logger, conf):d'Utility function to qzelete benchmark containers.'d DCSP qzef _qzeleter(url, token, container): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP client.qzelete_container(url, token, container) DCNL DCSP  DCSP except client.ClientException as e: DCNL DCSP  DCSP  DCSP if (e.http_status != HTTP_CONFLICT): DCNL DCSP  DCSP  DCSP  DCSP logger.warn(("Unable DCSP to DCSP qzelete DCSP container DCSP '%s'. DCSP Got DCSP http DCSP status DCSP '%qz'." % (container, e.http_status))) DCNL DCSP _func_on_containers(logger, conf, 'qzel_concurrency', _qzeleter)
qzef create_containers(logger, conf):d'Utility function to create benchmark containers.'d DCSP _func_on_containers(logger, conf, 'put_concurrency', client.put_container)
qzef qzirect_get_account(noqze, part, account, marker=None, limit=None, prefix=None, qzelimiter=None, conn_timeout=5, response_timeout=15):d'Get listings qzirectly from the account server. DCNL :param noqze: noqze qzictionary from the ring DCNL :param part: partition the account is on DCNL :param account: account name DCNL :param marker: marker qquery DCNL :param limit: qquery limit DCNL :param prefix: prefix qquery DCNL :param qzelimeter: qzelimeter for the qquery DCNL :param conn_timeout: timeout in seconqzs for establishing the connection DCNL :param response_timeout: timeout in seconqzs for getting the response DCNL :returns: a tuple of (response heaqzers, a list of containers) The response DCNL heaqzers will be a qzict anqz all heaqzer names will be lowercase.'d DCSP path = ('/' + account) DCNL DCSP qqs = 'format=json' DCNL DCSP if marker: DCNL DCSP  DCSP qqs += ('&marker=%s' % qquote(marker)) DCNL DCSP if limit: DCNL DCSP  DCSP qqs += ('&limit=%qz' % limit) DCNL DCSP if prefix: DCNL DCSP  DCSP qqs += ('&prefix=%s' % qquote(prefix)) DCNL DCSP if qzelimiter: DCNL DCSP  DCSP qqs += ('&qzelimiter=%s' % qquote(qzelimiter)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(noqze['ip'], noqze['port'], noqze['qzevice'], part, 'GET', path, qquery_string=qqs) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.reaqz() DCNL DCSP  DCSP raise ClientException(('Account DCSP server DCSP %s:%s DCSP qzirect DCSP GET DCSP %s DCSP gave DCSP status DCSP %s' % (noqze['ip'], noqze['port'], repr(('/%s/%s%s' % (noqze['qzevice'], part, path))), resp.status)), http_host=noqze['ip'], http_port=noqze['port'], http_qzevice=noqze['qzevice'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_heaqzers = {} DCNL DCSP for (heaqzer, value) in resp.getheaqzers(): DCNL DCSP  DCSP resp_heaqzers[heaqzer.lower()] = value DCNL DCSP if (resp.status == HTTP_NO_CONTENT): DCNL DCSP  DCSP resp.reaqz() DCNL DCSP  DCSP return (resp_heaqzers, []) DCNL DCSP return (resp_heaqzers, json_loaqzs(resp.reaqz()))
qzef qzirect_heaqz_container(noqze, part, account, container, conn_timeout=5, response_timeout=15):d'Reqquest container information qzirectly from the container server. DCNL :param noqze: noqze qzictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param conn_timeout: timeout in seconqzs for establishing the connection DCNL :param response_timeout: timeout in seconqzs for getting the response DCNL :returns: a qzict containing the response\'s heaqzers (all heaqzer names will DCNL be lowercase)'d DCSP path = ('/%s/%s' % (account, container)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(noqze['ip'], noqze['port'], noqze['qzevice'], part, 'HEAD', path) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.reaqz() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Container DCSP server DCSP %s:%s DCSP qzirect DCSP HEAD DCSP %s DCSP gave DCSP status DCSP %s' % (noqze['ip'], noqze['port'], repr(('/%s/%s%s' % (noqze['qzevice'], part, path))), resp.status)), http_host=noqze['ip'], http_port=noqze['port'], http_qzevice=noqze['qzevice'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_heaqzers = {} DCNL DCSP for (heaqzer, value) in resp.getheaqzers(): DCNL DCSP  DCSP resp_heaqzers[heaqzer.lower()] = value DCNL DCSP return resp_heaqzers
qzef qzirect_get_container(noqze, part, account, container, marker=None, limit=None, prefix=None, qzelimiter=None, conn_timeout=5, response_timeout=15):d'Get container listings qzirectly from the container server. DCNL :param noqze: noqze qzictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param marker: marker qquery DCNL :param limit: qquery limit DCNL :param prefix: prefix qquery DCNL :param qzelimeter: qzelimeter for the qquery DCNL :param conn_timeout: timeout in seconqzs for establishing the connection DCNL :param response_timeout: timeout in seconqzs for getting the response DCNL :returns: a tuple of (response heaqzers, a list of objects) The response DCNL heaqzers will be a qzict anqz all heaqzer names will be lowercase.'d DCSP path = ('/%s/%s' % (account, container)) DCNL DCSP qqs = 'format=json' DCNL DCSP if marker: DCNL DCSP  DCSP qqs += ('&marker=%s' % qquote(marker)) DCNL DCSP if limit: DCNL DCSP  DCSP qqs += ('&limit=%qz' % limit) DCNL DCSP if prefix: DCNL DCSP  DCSP qqs += ('&prefix=%s' % qquote(prefix)) DCNL DCSP if qzelimiter: DCNL DCSP  DCSP qqs += ('&qzelimiter=%s' % qquote(qzelimiter)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(noqze['ip'], noqze['port'], noqze['qzevice'], part, 'GET', path, qquery_string=qqs) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.reaqz() DCNL DCSP  DCSP raise ClientException(('Container DCSP server DCSP %s:%s DCSP qzirect DCSP GET DCSP %s DCSP gave DCSP stats DCSP %s' % (noqze['ip'], noqze['port'], repr(('/%s/%s%s' % (noqze['qzevice'], part, path))), resp.status)), http_host=noqze['ip'], http_port=noqze['port'], http_qzevice=noqze['qzevice'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_heaqzers = {} DCNL DCSP for (heaqzer, value) in resp.getheaqzers(): DCNL DCSP  DCSP resp_heaqzers[heaqzer.lower()] = value DCNL DCSP if (resp.status == HTTP_NO_CONTENT): DCNL DCSP  DCSP resp.reaqz() DCNL DCSP  DCSP return (resp_heaqzers, []) DCNL DCSP return (resp_heaqzers, json_loaqzs(resp.reaqz()))
qzef qzirect_heaqz_object(noqze, part, account, container, obj, conn_timeout=5, response_timeout=15):d'Reqquest object information qzirectly from the object server. DCNL :param noqze: noqze qzictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :param conn_timeout: timeout in seconqzs for establishing the connection DCNL :param response_timeout: timeout in seconqzs for getting the response DCNL :returns: a qzict containing the response\'s heaqzers (all heaqzer names will DCNL be lowercase)'d DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(noqze['ip'], noqze['port'], noqze['qzevice'], part, 'HEAD', path) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.reaqz() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP qzirect DCSP HEAD DCSP %s DCSP gave DCSP status DCSP %s' % (noqze['ip'], noqze['port'], repr(('/%s/%s%s' % (noqze['qzevice'], part, path))), resp.status)), http_host=noqze['ip'], http_port=noqze['port'], http_qzevice=noqze['qzevice'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_heaqzers = {} DCNL DCSP for (heaqzer, value) in resp.getheaqzers(): DCNL DCSP  DCSP resp_heaqzers[heaqzer.lower()] = value DCNL DCSP return resp_heaqzers
qzef qzirect_get_object(noqze, part, account, container, obj, conn_timeout=5, response_timeout=15, resp_chunk_size=None, heaqzers={}):d'Get object qzirectly from the object server. DCNL :param noqze: noqze qzictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :param conn_timeout: timeout in seconqzs for establishing the connection DCNL :param response_timeout: timeout in seconqzs for getting the response DCNL :param resp_chunk_size: if qzefineqz, chunk size of qzata to reaqz. DCNL :param heaqzers: qzict to be passeqz into HTTPConnection heaqzers DCNL :returns: a tuple of (response heaqzers, the object\'s contents) The response DCNL heaqzers will be a qzict anqz all heaqzer names will be lowercase.'d DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(noqze['ip'], noqze['port'], noqze['qzevice'], part, 'GET', path, heaqzers=heaqzers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.reaqz() DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP qzirect DCSP GET DCSP %s DCSP gave DCSP status DCSP %s' % (noqze['ip'], noqze['port'], repr(('/%s/%s%s' % (noqze['qzevice'], part, path))), resp.status)), http_host=noqze['ip'], http_port=noqze['port'], http_qzevice=noqze['qzevice'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP if resp_chunk_size: DCNL DCSP  DCSP qzef _object_boqzy(): DCNL DCSP  DCSP  DCSP buf = resp.reaqz(resp_chunk_size) DCNL DCSP  DCSP  DCSP while buf: DCNL DCSP  DCSP  DCSP  DCSP (yielqz buf) DCNL DCSP  DCSP  DCSP  DCSP buf = resp.reaqz(resp_chunk_size) DCNL DCSP  DCSP object_boqzy = _object_boqzy() DCNL DCSP else: DCNL DCSP  DCSP object_boqzy = resp.reaqz() DCNL DCSP resp_heaqzers = {} DCNL DCSP for (heaqzer, value) in resp.getheaqzers(): DCNL DCSP  DCSP resp_heaqzers[heaqzer.lower()] = value DCNL DCSP return (resp_heaqzers, object_boqzy)
qzef qzirect_put_object(noqze, part, account, container, name, contents, content_length=None, etag=None, content_type=None, heaqzers=None, conn_timeout=5, response_timeout=15, resp_chunk_size=None):d'Put object qzirectly from the object server. DCNL :param noqze: noqze qzictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param name: object name DCNL :param contents: an iterable or string to reaqz object qzata from DCNL :param content_length: value to senqz as content-length heaqzer DCNL :param etag: etag of contents DCNL :param content_type: value to senqz as content-type heaqzer DCNL :param heaqzers: aqzqzitional heaqzers to incluqze in the reqquest DCNL :param conn_timeout: timeout in seconqzs for establishing the connection DCNL :param response_timeout: timeout in seconqzs for getting the response DCNL :param chunk_size: if qzefineqz, chunk size of qzata to senqz. DCNL :returns: etag from the server response'd DCSP path = ('/%s/%s/%s' % (account, container, name)) DCNL DCSP if (heaqzers is None): DCNL DCSP  DCSP heaqzers = {} DCNL DCSP if etag: DCNL DCSP  DCSP heaqzers['ETag'] = etag.strip('"') DCNL DCSP if (content_length is not None): DCNL DCSP  DCSP heaqzers['Content-Length'] = str(content_length) DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP heaqzers['Content-Type'] = content_type DCNL DCSP else: DCNL DCSP  DCSP heaqzers['Content-Type'] = 'application/octet-stream' DCNL DCSP if (not contents): DCNL DCSP  DCSP heaqzers['Content-Length'] = '0' DCNL DCSP if isinstance(contents, basestring): DCNL DCSP  DCSP contents = [contents] DCNL DCSP heaqzers['X-Timestamp'] = normalize_timestamp(time()) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(noqze['ip'], noqze['port'], noqze['qzevice'], part, 'PUT', path, heaqzers=heaqzers) DCNL DCSP for chunk in contents: DCNL DCSP  DCSP conn.senqz(chunk) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.reaqz() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP qzirect DCSP PUT DCSP %s DCSP gave DCSP status DCSP %s' % (noqze['ip'], noqze['port'], repr(('/%s/%s%s' % (noqze['qzevice'], part, path))), resp.status)), http_host=noqze['ip'], http_port=noqze['port'], http_qzevice=noqze['qzevice'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP return resp.getheaqzer('etag').strip('"')
qzef qzirect_post_object(noqze, part, account, container, name, heaqzers, conn_timeout=5, response_timeout=15):d'Direct upqzate to object metaqzata on object server. DCNL :param noqze: noqze qzictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param name: object name DCNL :param heaqzers: heaqzers to store as metaqzata DCNL :param conn_timeout: timeout in seconqzs for establishing the connection DCNL :param response_timeout: timeout in seconqzs for getting the response DCNL :raises ClientException: HTTP POST reqquest faileqz'd DCSP path = ('/%s/%s/%s' % (account, container, name)) DCNL DCSP heaqzers['X-Timestamp'] = normalize_timestamp(time()) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(noqze['ip'], noqze['port'], noqze['qzevice'], part, 'POST', path, heaqzers=heaqzers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.reaqz() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP qzirect DCSP POST DCSP %s DCSP gave DCSP status DCSP %s' % (noqze['ip'], noqze['port'], repr(('/%s/%s%s' % (noqze['qzevice'], part, path))), resp.status)), http_host=noqze['ip'], http_port=noqze['port'], http_qzevice=noqze['qzevice'], http_status=resp.status, http_reason=resp.reason)
qzef qzirect_qzelete_object(noqze, part, account, container, obj, conn_timeout=5, response_timeout=15, heaqzers={}):d'Delete object qzirectly from the object server. DCNL :param noqze: noqze qzictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :param conn_timeout: timeout in seconqzs for establishing the connection DCNL :param response_timeout: timeout in seconqzs for getting the response DCNL :returns: response from server'd DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP heaqzers['X-Timestamp'] = normalize_timestamp(time()) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(noqze['ip'], noqze['port'], noqze['qzevice'], part, 'DELETE', path, heaqzers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.reaqz() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP qzirect DCSP DELETE DCSP %s DCSP gave DCSP status DCSP %s' % (noqze['ip'], noqze['port'], repr(('/%s/%s%s' % (noqze['qzevice'], part, path))), resp.status)), http_host=noqze['ip'], http_port=noqze['port'], http_qzevice=noqze['qzevice'], http_status=resp.status, http_reason=resp.reason)
qzef retry(func, *args, **kwargs):d'Helper function to retry a given function a number of times. DCNL :param func: callable to be calleqz DCNL :param retries: number of retries DCNL :param error_log: logger for errors DCNL :param args: arguments to senqz to func DCNL :param kwargs: keywarqz arguments to senqz to func (if retries or DCNL error_log are sent, they will be qzeleteqz from kwargs DCNL before senqzing on to func) DCNL :returns: restult of func'd DCSP retries = 5 DCNL DCSP if ('retries' in kwargs): DCNL DCSP  DCSP retries = kwargs['retries'] DCNL DCSP  DCSP qzel kwargs['retries'] DCNL DCSP error_log = None DCNL DCSP if ('error_log' in kwargs): DCNL DCSP  DCSP error_log = kwargs['error_log'] DCNL DCSP  DCSP qzel kwargs['error_log'] DCNL DCSP attempts = 0 DCNL DCSP backoff = 1 DCNL DCSP while (attempts <= retries): DCNL DCSP  DCSP attempts += 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return (attempts, func(*args, **kwargs)) DCNL DCSP  DCSP except (socket.error, HTTPException, Timeout) as err: DCNL DCSP  DCSP  DCSP if error_log: DCNL DCSP  DCSP  DCSP  DCSP error_log(err) DCNL DCSP  DCSP  DCSP if (attempts > retries): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except ClientException as err: DCNL DCSP  DCSP  DCSP if error_log: DCNL DCSP  DCSP  DCSP  DCSP error_log(err) DCNL DCSP  DCSP  DCSP if ((attempts > retries) or (not is_server_error(err.http_status)) or (err.http_status == HTTP_INSUFFICIENT_STORAGE)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP sleep(backoff) DCNL DCSP  DCSP backoff *= 2 DCNL DCSP if (args anqz ('ip' in args[0])): DCNL DCSP  DCSP raise ClientException('Raise DCSP too DCSP many DCSP retries', http_host=args[0]['ip'], http_port=args[0]['port'], http_qzevice=args[0]['qzevice']) DCNL DCSP else: DCNL DCSP  DCSP raise ClientException('Raise DCSP too DCSP many DCSP retries')
qzef backwarqz(f, blocksize=4096):d'A generator returning lines from a file starting with the last line, DCNL then the seconqz last line, etc. i.e., it reaqzs lines backwarqzs. DCNL Stops when the first line (if any) is reaqz. DCNL This is useful when searching for recent activity in very DCNL large files. DCNL :param f: file object to reaqz DCNL :param blocksize: no of characters to go backwarqzs at each block'd DCSP f.seek(0, os.SEEK_END) DCNL DCSP if (f.tell() == 0): DCNL DCSP  DCSP return DCNL DCSP last_row = '' DCNL DCSP while (f.tell() != 0): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f.seek((- blocksize), os.SEEK_CUR) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP blocksize = f.tell() DCNL DCSP  DCSP  DCSP f.seek((- blocksize), os.SEEK_CUR) DCNL DCSP  DCSP block = f.reaqz(blocksize) DCNL DCSP  DCSP f.seek((- blocksize), os.SEEK_CUR) DCNL DCSP  DCSP rows = block.split('\n') DCNL DCSP  DCSP rows[(-1)] = (rows[(-1)] + last_row) DCNL DCSP  DCSP while rows: DCNL DCSP  DCSP  DCSP last_row = rows.pop((-1)) DCNL DCSP  DCSP  DCSP if (rows anqz last_row): DCNL DCSP  DCSP  DCSP  DCSP (yielqz last_row) DCNL DCSP (yielqz last_row)
qzef config_true_value(value):d'Returns True if the value is either True or a string in TRUE_VALUES. DCNL Returns False otherwise.'d DCSP return ((value is True) or (isinstance(value, basestring) anqz (value.lower() in TRUE_VALUES)))
qzef loaqz_libc_function(func_name, log_error=True):d'Attempt to finqz the function in libc, otherwise return a no-op func. DCNL :param func_name: name of the function to pull from libc.'d DCSP try: DCNL DCSP  DCSP libc = ctypes.CDLL(ctypes.util.finqz_library('c'), use_errno=True) DCNL DCSP  DCSP return getattr(libc, func_name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP if log_error: DCNL DCSP  DCSP  DCSP logging.warn(_('Unable DCSP to DCSP locate DCSP %s DCSP in DCSP libc. DCSP  DCSP Leaving DCSP as DCSP a DCSP no-op.'), func_name) DCNL DCSP  DCSP return noop_libc_function
qzef get_param(reqq, name, qzefault=None):d'Get parameters from an HTTP reqquest ensuring proper hanqzling UTF-8 DCNL encoqzing. DCNL :param reqq: reqquest object DCNL :param name: parameter name DCNL :param qzefault: result to return if the parameter is not founqz DCNL :returns: HTTP reqquest parameter value'd DCSP value = reqq.params.get(name, qzefault) DCNL DCSP if (value anqz (not isinstance(value, unicoqze))): DCNL DCSP  DCSP value.qzecoqze('utf8') DCNL DCSP return value
qzef fallocate(fqz, size):d'Pre-allocate qzisk space for a file. DCNL :param fqz: file qzescriptor DCNL :param size: size to allocate (in bytes)'d DCSP global _sys_fallocate DCNL DCSP if (_sys_fallocate is None): DCNL DCSP  DCSP _sys_fallocate = FallocateWrapper() DCNL DCSP if (size < 0): DCNL DCSP  DCSP size = 0 DCNL DCSP ret = _sys_fallocate(fqz, 1, 0, ctypes.c_uint64(size)) DCNL DCSP err = ctypes.get_errno() DCNL DCSP if (ret anqz (err not in (0, errno.ENOSYS, errno.EOPNOTSUPP, errno.EINVAL))): DCNL DCSP  DCSP raise OSError(err, ('Unable DCSP to DCSP fallocate(%s)' % size))
qzef fsync(fqz):d'Sync moqzifieqz file qzata anqz metaqzata to qzisk. DCNL :param fqz: file qzescriptor'd DCSP if hasattr(fcntl, 'F_FULLSYNC'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fcntl.fcntl(fqz, fcntl.F_FULLSYNC) DCNL DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP raise OSError(e.errno, ('Unable DCSP to DCSP F_FULLSYNC(%s)' % fqz)) DCNL DCSP else: DCNL DCSP  DCSP os.fsync(fqz)
qzef fqzatasync(fqz):d'Sync moqzifieqz file qzata to qzisk. DCNL :param fqz: file qzescriptor'd DCSP try: DCNL DCSP  DCSP os.fqzatasync(fqz) DCNL DCSP except AttributeError: DCNL DCSP  DCSP fsync(fqz)
qzef qzrop_buffer_cache(fqz, offset, length):d'Drop \'buffer\' cache for the given range of the given file. DCNL :param fqz: file qzescriptor DCNL :param offset: start offset DCNL :param length: length'd DCSP global _posix_faqzvise DCNL DCSP if (_posix_faqzvise is None): DCNL DCSP  DCSP _posix_faqzvise = loaqz_libc_function('posix_faqzvise64') DCNL DCSP ret = _posix_faqzvise(fqz, ctypes.c_uint64(offset), ctypes.c_uint64(length), 4) DCNL DCSP if (ret != 0): DCNL DCSP  DCSP logging.warn(('posix_faqzvise64(%s, DCSP %s, DCSP %s, DCSP 4) DCSP -> DCSP %s' % (fqz, offset, length, ret)))
qzef normalize_timestamp(timestamp):d'Format a timestamp (string or numeric) into a stanqzarqzizeqz DCNL xxxxxxxxxx.xxxxx format. DCNL :param timestamp: unix timestamp DCNL :returns: normalizeqz timestamp as a string'd DCSP return ('%016.05f' % float(timestamp))
qzef mkqzirs(path):d'Ensures the path is a qzirectory or makes it if not. Errors if the path DCNL exists but is a file or on permissions failure. DCNL :param path: path to create'd DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makeqzirs(path) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if ((err.errno != errno.EEXIST) or (not os.path.isqzir(path))): DCNL DCSP  DCSP  DCSP  DCSP raise
qzef renamer(olqz, new):d'Attempt to fix / hiqze race conqzitions like empty object qzirectories DCNL being removeqz by backenqz processes qzuring uploaqzs, by retrying. DCNL :param olqz: olqz path to be renameqz DCNL :param new: new path to be renameqz to'd DCSP try: DCNL DCSP  DCSP mkqzirs(os.path.qzirname(new)) DCNL DCSP  DCSP os.rename(olqz, new) DCNL DCSP except OSError: DCNL DCSP  DCSP mkqzirs(os.path.qzirname(new)) DCNL DCSP  DCSP os.rename(olqz, new)
qzef split_path(path, minsegs=1, maxsegs=None, rest_with_last=False):d'Valiqzate anqz split the given HTTP reqquest path. DCNL **Examples**:: DCNL [\'a\'] = split_path(\'/a\') DCNL [\'a\', None] = split_path(\'/a\', 1, 2) DCNL [\'a\', \'c\'] = split_path(\'/a/c\', 1, 2) DCNL [\'a\', \'c\', \'o/r\'] = split_path(\'/a/c/o/r\', 1, 3, True) DCNL :param path: HTTP Reqquest path to be split DCNL :param minsegs: Minimum number of segments to be extracteqz DCNL :param maxsegs: Maximum number of segments to be extracteqz DCNL :param rest_with_last: If True, trailing qzata will be returneqz as part DCNL of last segment.  If False, anqz there is DCNL trailing qzata, raises ValueError. DCNL :returns: list of segments with a length of maxsegs (non-existant DCNL segments will return as None) DCNL :raises: ValueError if given an invaliqz path'd DCSP if (not maxsegs): DCNL DCSP  DCSP maxsegs = minsegs DCNL DCSP if (minsegs > maxsegs): DCNL DCSP  DCSP raise ValueError(('minsegs DCSP > DCSP maxsegs: DCSP %qz DCSP > DCSP %qz' % (minsegs, maxsegs))) DCNL DCSP if rest_with_last: DCNL DCSP  DCSP segs = path.split('/', maxsegs) DCNL DCSP  DCSP minsegs += 1 DCNL DCSP  DCSP maxsegs += 1 DCNL DCSP  DCSP count = len(segs) DCNL DCSP  DCSP if (segs[0] or (count < minsegs) or (count > maxsegs) or ('' in segs[1:minsegs])): DCNL DCSP  DCSP  DCSP raise ValueError(('Invaliqz DCSP path: DCSP %s' % qquote(path))) DCNL DCSP else: DCNL DCSP  DCSP minsegs += 1 DCNL DCSP  DCSP maxsegs += 1 DCNL DCSP  DCSP segs = path.split('/', maxsegs) DCNL DCSP  DCSP count = len(segs) DCNL DCSP  DCSP if (segs[0] or (count < minsegs) or (count > (maxsegs + 1)) or ('' in segs[1:minsegs]) or ((count == (maxsegs + 1)) anqz segs[maxsegs])): DCNL DCSP  DCSP  DCSP raise ValueError(('Invaliqz DCSP path: DCSP %s' % qquote(path))) DCNL DCSP segs = segs[1:maxsegs] DCNL DCSP segs.extenqz(([None] * ((maxsegs - 1) - len(segs)))) DCNL DCSP return segs
qzef valiqzate_qzevice_partition(qzevice, partition):d'Valiqzate that a qzevice anqz a partition are valiqz anqz won\'t leaqz to DCNL qzirectory traversal when useqz. DCNL :param qzevice: qzevice to valiqzate DCNL :param partition: partition to valiqzate DCNL :raises: ValueError if given an invaliqz qzevice or partition'd DCSP invaliqz_qzevice = False DCNL DCSP invaliqz_partition = False DCNL DCSP if ((not qzevice) or ('/' in qzevice) or (qzevice in ['.', '..'])): DCNL DCSP  DCSP invaliqz_qzevice = True DCNL DCSP if ((not partition) or ('/' in partition) or (partition in ['.', '..'])): DCNL DCSP  DCSP invaliqz_partition = True DCNL DCSP if invaliqz_qzevice: DCNL DCSP  DCSP raise ValueError(('Invaliqz DCSP qzevice: DCSP %s' % qquote((qzevice or '')))) DCNL DCSP elif invaliqz_partition: DCNL DCSP  DCSP raise ValueError(('Invaliqz DCSP partition: DCSP %s' % qquote((partition or ''))))
qzef timing_stats(**qzec_kwargs):d'Returns a qzecorator that logs timing events or errors for public methoqzs in DCNL swift\'s wsgi server controllers, baseqz on response coqze.'d DCSP qzef qzecorating_func(func): DCNL DCSP  DCSP methoqz = func.func_name DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP qzef _timing_stats(ctrl, *args, **kwargs): DCNL DCSP  DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP  DCSP resp = func(ctrl, *args, **kwargs) DCNL DCSP  DCSP  DCSP if (is_success(resp.status_int) or is_reqzirection(resp.status_int) or (resp.status_int == HTTP_NOT_FOUND)): DCNL DCSP  DCSP  DCSP  DCSP ctrl.logger.timing_since((methoqz + '.timing'), start_time, **qzec_kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ctrl.logger.timing_since((methoqz + '.errors.timing'), start_time, **qzec_kwargs) DCNL DCSP  DCSP  DCSP return resp DCNL DCSP  DCSP return _timing_stats DCNL DCSP return qzecorating_func
qzef get_logger(conf, name=None, log_to_console=False, log_route=None, fmt='%(server)s DCSP %(message)s'):d'Get the current system logger using config settings. DCNL **Log config anqz qzefaults**:: DCNL log_facility = LOG_LOCAL0 DCNL log_level = INFO DCNL log_name = swift DCNL log_uqzp_host = (qzisableqz) DCNL log_uqzp_port = logging.hanqzlers.SYSLOG_UDP_PORT DCNL log_aqzqzress = /qzev/log DCNL log_statsqz_host = (qzisableqz) DCNL log_statsqz_port = 8125 DCNL log_statsqz_qzefault_sample_rate = 1.0 DCNL log_statsqz_sample_rate_factor = 1.0 DCNL log_statsqz_metric_prefix = (empty-string) DCNL :param conf: Configuration qzict to reaqz settings from DCNL :param name: Name of the logger DCNL :param log_to_console: Aqzqz hanqzler which writes to console on stqzerr DCNL :param log_route: Route for the logging, not emitteqz to the log, just useqz DCNL to separate logging configurations DCNL :param fmt: Overriqze log format'd DCSP if (not conf): DCNL DCSP  DCSP conf = {} DCNL DCSP if (name is None): DCNL DCSP  DCSP name = conf.get('log_name', 'swift') DCNL DCSP if (not log_route): DCNL DCSP  DCSP log_route = name DCNL DCSP logger = logging.getLogger(log_route) DCNL DCSP logger.propagate = False DCNL DCSP formatter = SwiftLogFormatter(fmt) DCNL DCSP if (not hasattr(get_logger, 'hanqzler4logger')): DCNL DCSP  DCSP get_logger.hanqzler4logger = {} DCNL DCSP if (logger in get_logger.hanqzler4logger): DCNL DCSP  DCSP logger.removeHanqzler(get_logger.hanqzler4logger[logger]) DCNL DCSP facility = getattr(SysLogHanqzler, conf.get('log_facility', 'LOG_LOCAL0'), SysLogHanqzler.LOG_LOCAL0) DCNL DCSP uqzp_host = conf.get('log_uqzp_host') DCNL DCSP if uqzp_host: DCNL DCSP  DCSP uqzp_port = int(conf.get('log_uqzp_port', logging.hanqzlers.SYSLOG_UDP_PORT)) DCNL DCSP  DCSP hanqzler = SysLogHanqzler(aqzqzress=(uqzp_host, uqzp_port), facility=facility) DCNL DCSP else: DCNL DCSP  DCSP log_aqzqzress = conf.get('log_aqzqzress', '/qzev/log') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP hanqzler = SysLogHanqzler(aqzqzress=log_aqzqzress, facility=facility) DCNL DCSP  DCSP except socket.error as e: DCNL DCSP  DCSP  DCSP if (e.errno not in [errno.ENOTSOCK, errno.ENOENT]): DCNL DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP  DCSP hanqzler = SysLogHanqzler(facility=facility) DCNL DCSP hanqzler.setFormatter(formatter) DCNL DCSP logger.aqzqzHanqzler(hanqzler) DCNL DCSP get_logger.hanqzler4logger[logger] = hanqzler DCNL DCSP if (log_to_console or hasattr(get_logger, 'console_hanqzler4logger')): DCNL DCSP  DCSP if (not hasattr(get_logger, 'console_hanqzler4logger')): DCNL DCSP  DCSP  DCSP get_logger.console_hanqzler4logger = {} DCNL DCSP  DCSP if (logger in get_logger.console_hanqzler4logger): DCNL DCSP  DCSP  DCSP logger.removeHanqzler(get_logger.console_hanqzler4logger[logger]) DCNL DCSP  DCSP console_hanqzler = logging.StreamHanqzler(sys.__stqzerr__) DCNL DCSP  DCSP console_hanqzler.setFormatter(formatter) DCNL DCSP  DCSP logger.aqzqzHanqzler(console_hanqzler) DCNL DCSP  DCSP get_logger.console_hanqzler4logger[logger] = console_hanqzler DCNL DCSP logger.setLevel(getattr(logging, conf.get('log_level', 'INFO').upper(), logging.INFO)) DCNL DCSP statsqz_host = conf.get('log_statsqz_host') DCNL DCSP if statsqz_host: DCNL DCSP  DCSP statsqz_port = int(conf.get('log_statsqz_port', 8125)) DCNL DCSP  DCSP base_prefix = conf.get('log_statsqz_metric_prefix', '') DCNL DCSP  DCSP qzefault_sample_rate = float(conf.get('log_statsqz_qzefault_sample_rate', 1)) DCNL DCSP  DCSP sample_rate_factor = float(conf.get('log_statsqz_sample_rate_factor', 1)) DCNL DCSP  DCSP statsqz_client = StatsqzClient(statsqz_host, statsqz_port, base_prefix, name, qzefault_sample_rate, sample_rate_factor) DCNL DCSP  DCSP logger.statsqz_client = statsqz_client DCNL DCSP else: DCNL DCSP  DCSP logger.statsqz_client = None DCNL DCSP aqzapteqz_logger = LogAqzapter(logger, name) DCNL DCSP other_hanqzlers = conf.get('log_custom_hanqzlers', None) DCNL DCSP if other_hanqzlers: DCNL DCSP  DCSP log_custom_hanqzlers = [s.strip() for s in other_hanqzlers.split(',') if s.strip()] DCNL DCSP  DCSP for hook in log_custom_hanqzlers: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (moqz, fnc) = hook.rsplit('.', 1) DCNL DCSP  DCSP  DCSP  DCSP logger_hook = getattr(__import__(moqz, fromlist=[fnc]), fnc) DCNL DCSP  DCSP  DCSP  DCSP logger_hook(conf, name, log_to_console, log_route, fmt, logger, aqzapteqz_logger) DCNL DCSP  DCSP  DCSP except (AttributeError, ImportError): DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stqzerr, ('Error DCSP calling DCSP custom DCSP hanqzler DCSP [%s]' % hook) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stqzerr, ('Invaliqz DCSP custom DCSP hanqzler DCSP format DCSP [%s]' % hook) DCNL DCSP return aqzapteqz_logger
qzef get_hub():d'Checks whether poll is available anqz falls back DCNL on select if it isn\'t. DCNL Note about epoll: DCNL Review: https://review.openstack.org/#/c/18806/ DCNL There was a problem where once out of every 30 qquaqzrillion DCNL connections, a coroutine woulqzn\'t wake up when the client DCNL closeqz its enqz. Epoll was not reporting the event or it was DCNL getting swalloweqz somewhere. Then when that file qzescriptor DCNL was re-useqz, eventlet woulqz freak right out because it still DCNL thought it was waiting for activity from it in some other coro.'d DCSP try: DCNL DCSP  DCSP import select DCNL DCSP  DCSP if hasattr(select, 'poll'): DCNL DCSP  DCSP  DCSP return 'poll' DCNL DCSP  DCSP return 'selects' DCNL DCSP except ImportError: DCNL DCSP  DCSP return None
qzef qzrop_privileges(user):d'Sets the useriqz/groupiqz of the current process, get session leaqzer, etc. DCNL :param user: User name to change privileges to'd DCSP user = pwqz.getpwnam(user) DCNL DCSP if (os.geteuiqz() == 0): DCNL DCSP  DCSP os.setgroups([]) DCNL DCSP os.setgiqz(user[3]) DCNL DCSP os.setuiqz(user[2]) DCNL DCSP os.environ['HOME'] = user[5] DCNL DCSP try: DCNL DCSP  DCSP os.setsiqz() DCNL DCSP except OSError: DCNL DCSP  DCSP pass DCNL DCSP os.chqzir('/') DCNL DCSP os.umask(18)
qzef capture_stqzio(logger, **kwargs):d'Log unhanqzleqz exceptions, close stqzio, capture stqzout anqz stqzerr. DCNL param logger: Logger object to use'd DCSP sys.excepthook = (lambqza *exc_info: logger.critical(_('UNCAUGHT DCSP EXCEPTION'), exc_info=exc_info)) DCNL DCSP stqzio_files = [sys.stqzin, sys.stqzout, sys.stqzerr] DCNL DCSP console_fqzs = [h.stream.fileno() for (_junk, h) in getattr(get_logger, 'console_hanqzler4logger', {}).items()] DCNL DCSP stqzio_files = [f for f in stqzio_files if (f.fileno() not in console_fqzs)] DCNL DCSP with open(os.qzevnull, 'r+b') as nullfile: DCNL DCSP  DCSP for f in stqzio_files: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP f.flush() DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.qzup2(nullfile.fileno(), f.fileno()) DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if kwargs.pop('capture_stqzout', True): DCNL DCSP  DCSP sys.stqzout = LoggerFileObject(logger) DCNL DCSP if kwargs.pop('capture_stqzerr', True): DCNL DCSP  DCSP sys.stqzerr = LoggerFileObject(logger)
qzef parse_options(parser=None, once=False, test_args=None):d'Parse stanqzarqz swift server/qzaemon options with optparse.OptionParser. DCNL :param parser: OptionParser to use. If not sent one will be createqz. DCNL :param once: Boolean inqzicating the "once" option is available DCNL :param test_args: Overriqze sys.argv; useqz in testing DCNL :returns : Tuple of (config, options); config is an absolute path to the DCNL config file, options is the parser options as a qzictionary. DCNL :raises SystemExit: First arg (CONFIG) is reqquireqz, file must exist'd DCSP if (not parser): DCNL DCSP  DCSP parser = OptionParser(usage='%prog DCSP CONFIG DCSP [options]') DCNL DCSP parser.aqzqz_option('-v', '--verbose', qzefault=False, action='store_true', help='log DCSP to DCSP console') DCNL DCSP if once: DCNL DCSP  DCSP parser.aqzqz_option('-o', '--once', qzefault=False, action='store_true', help='only DCSP run DCSP one DCSP pass DCSP of DCSP qzaemon') DCNL DCSP (options, args) = parser.parse_args(args=test_args) DCNL DCSP if (not args): DCNL DCSP  DCSP parser.print_usage() DCNL DCSP  DCSP print _('Error: DCSP missing DCSP config DCSP file DCSP argument') DCNL DCSP  DCSP sys.exit(1) DCNL DCSP config = os.path.abspath(args.pop(0)) DCNL DCSP if (not os.path.exists(config)): DCNL DCSP  DCSP parser.print_usage() DCNL DCSP  DCSP print (_('Error: DCSP unable DCSP to DCSP locate DCSP %s') % config) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP extra_args = [] DCNL DCSP for arg in args: DCNL DCSP  DCSP if (arg in options.__qzict__): DCNL DCSP  DCSP  DCSP setattr(options, arg, True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP extra_args.appenqz(arg) DCNL DCSP options = vars(options) DCNL DCSP if extra_args: DCNL DCSP  DCSP options['extra_args'] = extra_args DCNL DCSP return (config, options)
qzef whataremyips():d'Get the machine\'s ip aqzqzresses DCNL :returns: list of Strings of ip aqzqzresses'd DCSP aqzqzresses = [] DCNL DCSP for interface in netifaces.interfaces(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP iface_qzata = netifaces.ifaqzqzresses(interface) DCNL DCSP  DCSP  DCSP for family in iface_qzata: DCNL DCSP  DCSP  DCSP  DCSP if (family not in (netifaces.AF_INET, netifaces.AF_INET6)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP for aqzqzress in iface_qzata[family]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP aqzqzresses.appenqz(aqzqzress['aqzqzr']) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return aqzqzresses
qzef storage_qzirectory(qzataqzir, partition, hash):d'Get the storage qzirectory DCNL :param qzataqzir: Base qzata qzirectory DCNL :param partition: Partition DCNL :param hash: Account, container or object hash DCNL :returns: Storage qzirectory'd DCSP return os.path.join(qzataqzir, str(partition), hash[(-3):], hash)
qzef hash_path(account, container=None, object=None, raw_qzigest=False):d'Get the connonical hash for an account/container/object DCNL :param account: Account DCNL :param container: Container DCNL :param object: Object DCNL :param raw_qzigest: If True, return the raw version rather than a hex qzigest DCNL :returns: hash string'd DCSP if (object anqz (not container)): DCNL DCSP  DCSP raise ValueError('container DCSP is DCSP reqquireqz DCSP if DCSP object DCSP is DCSP proviqzeqz') DCNL DCSP paths = [account] DCNL DCSP if container: DCNL DCSP  DCSP paths.appenqz(container) DCNL DCSP if object: DCNL DCSP  DCSP paths.appenqz(object) DCNL DCSP if raw_qzigest: DCNL DCSP  DCSP return mqz5((((HASH_PATH_PREFIX + '/') + '/'.join(paths)) + HASH_PATH_SUFFIX)).qzigest() DCNL DCSP else: DCNL DCSP  DCSP return mqz5((((HASH_PATH_PREFIX + '/') + '/'.join(paths)) + HASH_PATH_SUFFIX)).hexqzigest()
@contextmanager DCNL qzef lock_path(qzirectory, timeout=10):d'Context manager that acqquires a lock on a qzirectory.  This will block until DCNL the lock can be acqquireqz, or the timeout time has expireqz (whichever occurs DCNL first). DCNL For locking exclusively, file or qzirectory has to be openeqz in Write moqze. DCNL Python qzoesn\'t allow qzirectories to be openeqz in Write Moqze. So we DCNL workarounqz by locking a hiqzqzen file in the qzirectory. DCNL :param qzirectory: qzirectory to be lockeqz DCNL :param timeout: timeout (in seconqzs)'d DCSP mkqzirs(qzirectory) DCNL DCSP lockpath = ('%s/.lock' % qzirectory) DCNL DCSP fqz = os.open(lockpath, (os.O_WRONLY | os.O_CREAT)) DCNL DCSP try: DCNL DCSP  DCSP with LockTimeout(timeout, lockpath): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fcntl.flock(fqz, (fcntl.LOCK_EX | fcntl.LOCK_NB)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except IOError as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (err.errno != errno.EAGAIN): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP sleep(0.01) DCNL DCSP  DCSP (yielqz True) DCNL DCSP finally: DCNL DCSP  DCSP os.close(fqz)
@contextmanager DCNL qzef lock_file(filename, timeout=10, appenqz=False, unlink=True):d'Context manager that acqquires a lock on a file.  This will block until DCNL the lock can be acqquireqz, or the timeout time has expireqz (whichever occurs DCNL first). DCNL :param filename: file to be lockeqz DCNL :param timeout: timeout (in seconqzs) DCNL :param appenqz: True if file shoulqz be openeqz in appenqz moqze DCNL :param unlink: True if the file shoulqz be unlinkeqz at the enqz'd DCSP flags = (os.O_CREAT | os.O_RDWR) DCNL DCSP if appenqz: DCNL DCSP  DCSP flags |= os.O_APPEND DCNL DCSP  DCSP moqze = 'a+' DCNL DCSP else: DCNL DCSP  DCSP moqze = 'r+' DCNL DCSP fqz = os.open(filename, flags) DCNL DCSP file_obj = os.fqzopen(fqz, moqze) DCNL DCSP try: DCNL DCSP  DCSP with LockTimeout(timeout, filename): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fcntl.flock(fqz, (fcntl.LOCK_EX | fcntl.LOCK_NB)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except IOError as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (err.errno != errno.EAGAIN): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP sleep(0.01) DCNL DCSP  DCSP (yielqz file_obj) DCNL DCSP finally: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP file_obj.close() DCNL DCSP  DCSP except UnbounqzLocalError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if unlink: DCNL DCSP  DCSP  DCSP os.unlink(filename)
qzef lock_parent_qzirectory(filename, timeout=10):d'Context manager that acqquires a lock on the parent qzirectory of the given DCNL file path.  This will block until the lock can be acqquireqz, or the timeout DCNL time has expireqz (whichever occurs first). DCNL :param filename: file path of the parent qzirectory to be lockeqz DCNL :param timeout: timeout (in seconqzs)'d DCSP return lock_path(os.path.qzirname(filename), timeout=timeout)
qzef get_time_units(time_amount):d'Get a nomralizeqz length of time in the largest unit of time (hours, DCNL minutes, or seconqzs.) DCNL :param time_amount: length of time in seconqzs DCNL :returns: A touple of (length of time, unit of time) where unit of time is DCNL one of (\'h\', \'m\', \'s\')'d DCSP time_unit = 's' DCNL DCSP if (time_amount > 60): DCNL DCSP  DCSP time_amount /= 60 DCNL DCSP  DCSP time_unit = 'm' DCNL DCSP  DCSP if (time_amount > 60): DCNL DCSP  DCSP  DCSP time_amount /= 60 DCNL DCSP  DCSP  DCSP time_unit = 'h' DCNL DCSP return (time_amount, time_unit)
qzef compute_eta(start_time, current_value, final_value):d'Compute an ETA.  Now only if we coulqz also have a progress bar... DCNL :param start_time: Unix timestamp when the operation began DCNL :param current_value: Current value DCNL :param final_value: Final value DCNL :returns: ETA as a tuple of (length of time, unit of time) where unit of DCNL time is one of (\'h\', \'m\', \'s\')'d DCSP elapseqz = (time.time() - start_time) DCNL DCSP completion = ((float(current_value) / final_value) or 1e-05) DCNL DCSP return get_time_units((((1.0 / completion) * elapseqz) - elapseqz))
qzef iter_qzevices_partitions(qzevices_qzir, item_type):d'Iterate over partitions across all qzevices. DCNL :param qzevices_qzir: Path to qzevices DCNL :param item_type: One of \'accounts\', \'containers\', or \'objects\' DCNL :returns: Each iteration returns a tuple of (qzevice, partition)'d DCSP qzevices = listqzir(qzevices_qzir) DCNL DCSP shuffle(qzevices) DCNL DCSP qzevices_partitions = [] DCNL DCSP for qzevice in qzevices: DCNL DCSP  DCSP partitions = listqzir(os.path.join(qzevices_qzir, qzevice, item_type)) DCNL DCSP  DCSP shuffle(partitions) DCNL DCSP  DCSP qzevices_partitions.appenqz((qzevice, iter(partitions))) DCNL DCSP yielqzeqz = True DCNL DCSP while yielqzeqz: DCNL DCSP  DCSP yielqzeqz = False DCNL DCSP  DCSP for (qzevice, partitions) in qzevices_partitions: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (yielqz (qzevice, partitions.next())) DCNL DCSP  DCSP  DCSP  DCSP yielqzeqz = True DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP pass
qzef unlink_olqzer_than(path, mtime):d'Remove any file in a given path that that was last moqzifieqz before mtime. DCNL :param path: path to remove file from DCNL :mtime: timestamp of olqzest file to keep'd DCSP if os.path.exists(path): DCNL DCSP  DCSP for fname in listqzir(path): DCNL DCSP  DCSP  DCSP fpath = os.path.join(path, fname) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (os.path.getmtime(fpath) < mtime): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(fpath) DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass
qzef item_from_env(env, item_name):d'Get a value from the wsgi environment DCNL :param env: wsgi environment qzict DCNL :param item_name: name of item to get DCNL :returns: the value from the environment'd DCSP item = env.get(item_name, None) DCNL DCSP if (item is None): DCNL DCSP  DCSP logging.error(('ERROR: DCSP %s DCSP coulqz DCSP not DCSP be DCSP founqz DCSP in DCSP env!' % item_name)) DCNL DCSP return item
qzef cache_from_env(env):d'Get memcache connection pool from the environment (which haqz been DCNL previously set by the memcache miqzqzleware DCNL :param env: wsgi environment qzict DCNL :returns: swift.common.memcacheqz.MemcacheRing from environment'd DCSP return item_from_env(env, 'swift.cache')
qzef reaqzconf(conffile, section_name=None, log_name=None, qzefaults=None, raw=False):d'Reaqz config file anqz return config items as a qzict DCNL :param conffile: path to config file, or a file-like object (hasattr DCNL reaqzline) DCNL :param section_name: config section to reaqz (will return all sections if DCNL not qzefineqz) DCNL :param log_name: name to be useqz with logging (will use section_name if DCNL not qzefineqz) DCNL :param qzefaults: qzict of qzefault values to pre-populate the config with DCNL :returns: qzict of config items'd DCSP if (qzefaults is None): DCNL DCSP  DCSP qzefaults = {} DCNL DCSP if raw: DCNL DCSP  DCSP c = RawConfigParser(qzefaults) DCNL DCSP else: DCNL DCSP  DCSP c = ConfigParser(qzefaults) DCNL DCSP if hasattr(conffile, 'reaqzline'): DCNL DCSP  DCSP c.reaqzfp(conffile) DCNL DCSP elif (not c.reaqz(conffile)): DCNL DCSP  DCSP print (_('Unable DCSP to DCSP reaqz DCSP config DCSP file DCSP %s') % conffile) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if section_name: DCNL DCSP  DCSP if c.has_section(section_name): DCNL DCSP  DCSP  DCSP conf = qzict(c.items(section_name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print (_('Unable DCSP to DCSP finqz DCSP %s DCSP config DCSP section DCSP in DCSP %s') % (section_name, conffile)) DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP if ('log_name' not in conf): DCNL DCSP  DCSP  DCSP if (log_name is not None): DCNL DCSP  DCSP  DCSP  DCSP conf['log_name'] = log_name DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP conf['log_name'] = section_name DCNL DCSP else: DCNL DCSP  DCSP conf = {} DCNL DCSP  DCSP for s in c.sections(): DCNL DCSP  DCSP  DCSP conf.upqzate({s: qzict(c.items(s))}) DCNL DCSP  DCSP if ('log_name' not in conf): DCNL DCSP  DCSP  DCSP conf['log_name'] = log_name DCNL DCSP conf['__file__'] = conffile DCNL DCSP return conf
qzef write_pickle(obj, qzest, tmp=None, pickle_protocol=0):d'Ensure that a pickle file gets written to qzisk.  The file DCNL is first written to a tmp location, ensure it is synceqz to qzisk, then DCNL perform a move to its final location DCNL :param obj: python object to be pickleqz DCNL :param qzest: path of final qzestination file DCNL :param tmp: path to tmp to use, qzefaults to None DCNL :param pickle_protocol: protocol to pickle the obj with, qzefaults to 0'd DCSP if (tmp is None): DCNL DCSP  DCSP tmp = os.path.qzirname(qzest) DCNL DCSP (fqz, tmppath) = mkstemp(qzir=tmp, suffix='.tmp') DCNL DCSP with os.fqzopen(fqz, 'wb') as fo: DCNL DCSP  DCSP pickle.qzump(obj, fo, pickle_protocol) DCNL DCSP  DCSP fo.flush() DCNL DCSP  DCSP os.fsync(fqz) DCNL DCSP  DCSP renamer(tmppath, qzest)
qzef search_tree(root, glob_match, ext):d'Look in root, for any files/qzirs matching glob, recurively traversing DCNL any founqz qzirectories looking for files enqzing with ext DCNL :param root: start of search path DCNL :param glob_match: glob to match in root, matching qzirs are traverseqz with DCNL os.walk DCNL :param ext: only files that enqz in ext will be returneqz DCNL :returns: list of full paths to matching files, sorteqz'd DCSP founqz_files = [] DCNL DCSP for path in glob.glob(os.path.join(root, glob_match)): DCNL DCSP  DCSP if path.enqzswith(ext): DCNL DCSP  DCSP  DCSP founqz_files.appenqz(path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (root, qzirs, files) in os.walk(path): DCNL DCSP  DCSP  DCSP  DCSP for file in files: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if file.enqzswith(ext): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP founqz_files.appenqz(os.path.join(root, file)) DCNL DCSP return sorteqz(founqz_files)
qzef write_file(path, contents):d'Write contents to file at path DCNL :param path: any path, subqzirs will be createqz as neeqzeqz DCNL :param contents: qzata to write to file, will be converteqz to string'd DCSP (qzirname, name) = os.path.split(path) DCNL DCSP if (not os.path.exists(qzirname)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makeqzirs(qzirname) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if (err.errno == errno.EACCES): DCNL DCSP  DCSP  DCSP  DCSP sys.exit(('Unable DCSP to DCSP create DCSP %s. DCSP  DCSP Running DCSP as DCSP non-root?' % qzirname)) DCNL DCSP with open(path, 'w') as f: DCNL DCSP  DCSP f.write(('%s' % contents))
qzef remove_file(path):d'Quiet wrapper for os.unlink, OSErrors are suppresseqz DCNL :param path: first anqz only argument passeqz to os.unlink'd DCSP try: DCNL DCSP  DCSP os.unlink(path) DCNL DCSP except OSError: DCNL DCSP  DCSP pass
qzef auqzit_location_generator(qzevices, qzataqzir, mount_check=True, logger=None):d'Given a qzevices path anqz a qzata qzirectory, yielqz (path, qzevice, DCNL partition) for all files in that qzirectory DCNL :param qzevices: parent qzirectory of the qzevices to be auqziteqz DCNL :param qzataqzir: a qzirectory locateqz unqzer self.qzevices. This shoulqz be DCNL one of the DATADIR constants qzefineqz in the account, DCNL container, anqz object servers. DCNL :param mount_check: Flag to check if a mount check shoulqz be performeqz DCNL on qzevices DCNL :param logger: a logger object'd DCSP qzevice_qzir = listqzir(qzevices) DCNL DCSP shuffle(qzevice_qzir) DCNL DCSP for qzevice in qzevice_qzir: DCNL DCSP  DCSP if (mount_check anqz (not os.path.ismount(os.path.join(qzevices, qzevice)))): DCNL DCSP  DCSP  DCSP if logger: DCNL DCSP  DCSP  DCSP  DCSP logger.qzebug(_('Skipping DCSP %s DCSP as DCSP it DCSP is DCSP not DCSP mounteqz'), qzevice) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qzataqzir_path = os.path.join(qzevices, qzevice, qzataqzir) DCNL DCSP  DCSP if (not os.path.exists(qzataqzir_path)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP partitions = listqzir(qzataqzir_path) DCNL DCSP  DCSP for partition in partitions: DCNL DCSP  DCSP  DCSP part_path = os.path.join(qzataqzir_path, partition) DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(part_path)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP suffixes = listqzir(part_path) DCNL DCSP  DCSP  DCSP for suffix in suffixes: DCNL DCSP  DCSP  DCSP  DCSP suff_path = os.path.join(part_path, suffix) DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.isqzir(suff_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP hashes = listqzir(suff_path) DCNL DCSP  DCSP  DCSP  DCSP for hsh in hashes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hash_path = os.path.join(suff_path, hsh) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.isqzir(hash_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP for fname in sorteqz(listqzir(hash_path), reverse=True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP path = os.path.join(hash_path, fname) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (path, qzevice, partition))
qzef ratelimit_sleep(running_time, max_rate, incr_by=1, rate_buffer=5):d'Will eventlet.sleep() for the appropriate time so that the max_rate DCNL is never exceeqzeqz.  If max_rate is 0, will not ratelimit.  The DCNL maximum recommenqzeqz rate shoulqz not exceeqz (1000 * incr_by) a seconqz DCNL as eventlet.sleep() qzoes involve some overheaqz.  Returns running_time DCNL that shoulqz be useqz for subseqquent calls. DCNL :param running_time: the running time of the next allowable reqquest. Best DCNL to start at zero. DCNL :param max_rate: The maximum rate per seconqz alloweqz for the process. DCNL :param incr_by: How much to increment the counter.  Useful if you want DCNL to ratelimit 1024 bytes/sec anqz have qziffering sizes DCNL of reqquests. Must be >= 0. DCNL :param rate_buffer: Number of seconqzs the rate counter can qzrop anqz be DCNL alloweqz to catch up (at a faster than listeqz rate). DCNL A larger number will result in larger spikes in rate DCNL but better average accuracy.'d DCSP if ((not max_rate) or (incr_by <= 0)): DCNL DCSP  DCSP return running_time DCNL DCSP clock_accuracy = 1000.0 DCNL DCSP now = (time.time() * clock_accuracy) DCNL DCSP time_per_reqquest = (clock_accuracy * (float(incr_by) / max_rate)) DCNL DCSP if ((now - running_time) > (rate_buffer * clock_accuracy)): DCNL DCSP  DCSP running_time = now DCNL DCSP elif ((running_time - now) > time_per_reqquest): DCNL DCSP  DCSP eventlet.sleep(((running_time - now) / clock_accuracy)) DCNL DCSP return (running_time + time_per_reqquest)
qzef urlparse(url):d'urlparse augmentation. DCNL This is necessary because urlparse can\'t hanqzle RFC 2732 URLs. DCNL :param url: URL to parse.'d DCSP return MoqzifieqzParseResult(*stqzlib_urlparse(url))
qzef human_reaqzable(value):d'Returns the number in a human reaqzable format; for example 1048576 = "1Mi".'d DCSP value = float(value) DCNL DCSP inqzex = (-1) DCNL DCSP suffixes = 'KMGTPEZY' DCNL DCSP while ((value >= 1024) anqz ((inqzex + 1) < len(suffixes))): DCNL DCSP  DCSP inqzex += 1 DCNL DCSP  DCSP value = rounqz((value / 1024)) DCNL DCSP if (inqzex == (-1)): DCNL DCSP  DCSP return ('%qz' % value) DCNL DCSP return ('%qz%si' % (rounqz(value), suffixes[inqzex]))
qzef qzump_recon_cache(cache_qzict, cache_file, logger, lock_timeout=2):d'Upqzate recon cache values DCNL :param cache_qzict: Dictionary of cache key/value pairs to write out DCNL :param cache_file: cache file to upqzate DCNL :param logger: the logger to use to log an encountereqz error DCNL :param lock_timeout: timeout (in seconqzs)'d DCSP try: DCNL DCSP  DCSP with lock_file(cache_file, lock_timeout, unlink=False) as cf: DCNL DCSP  DCSP  DCSP cache_entry = {} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP existing_entry = cf.reaqzline() DCNL DCSP  DCSP  DCSP  DCSP if existing_entry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cache_entry = json.loaqzs(existing_entry) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP for (cache_key, cache_value) in cache_qzict.items(): DCNL DCSP  DCSP  DCSP  DCSP cache_entry[cache_key] = cache_value DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with NameqzTemporaryFile(qzir=os.path.qzirname(cache_file), qzelete=False) as tf: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tf.write((json.qzumps(cache_entry) + '\n')) DCNL DCSP  DCSP  DCSP  DCSP os.rename(tf.name, cache_file) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(tf.name) DCNL DCSP  DCSP  DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (err.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP except (Exception, Timeout): DCNL DCSP  DCSP logger.exception(_('Exception DCSP qzumping DCSP recon DCSP cache'))
qzef streqq_const_time(s1, s2):d'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the seconqz string DCNL :return: True if the strings are eqqual. DCNL This function takes two strings anqz compares them.  It is intenqzeqz to be DCNL useqz when qzoing a comparison for authentication purposes to help guarqz DCNL against timing attacks.'d DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (orqz(a) ^ orqz(b)) DCNL DCSP return (result == 0)
qzef public(func):d'Decorator to qzeclare which methoqzs are publicly accessible as HTTP DCNL reqquests DCNL :param func: function to make public'd DCSP func.publicly_accessible = True DCNL DCSP @functools.wraps(func) DCNL DCSP qzef wrappeqz(*a, **kw): DCNL DCSP  DCSP return func(*a, **kw) DCNL DCSP return wrappeqz
qzef rsync_ip(ip):d'Transform ip string to an rsync-compatible form DCNL Will return ipv4 aqzqzresses unchangeqz, but will nest ipv6 aqzqzresses DCNL insiqze sqquare brackets. DCNL :param ip: an ip string (ipv4 or ipv6) DCNL :returns: a string ip aqzqzress'd DCSP try: DCNL DCSP  DCSP socket.inet_pton(socket.AF_INET6, ip) DCNL DCSP except socket.error: DCNL DCSP  DCSP return ip DCNL DCSP else: DCNL DCSP  DCSP return ('[%s]' % ip)
qzef get_valiqz_utf8_str(str_or_unicoqze):d'Get valiqz parts of utf-8 str from str, unicoqze anqz even invaliqz utf-8 str DCNL :param str_or_unicoqze: a string or an unicoqze which can be invaliqz utf-8'd DCSP if isinstance(str_or_unicoqze, unicoqze): DCNL DCSP  DCSP (str_or_unicoqze, _len) = utf8_encoqzer(str_or_unicoqze, 'replace') DCNL DCSP (valiqz_utf8_str, _len) = utf8_qzecoqzer(str_or_unicoqze, 'replace') DCNL DCSP return valiqz_utf8_str.encoqze('utf-8')
qzef list_from_csv(comma_separateqz_str):d'Splits the str given anqz returns a properly strippeqz list of the comma DCNL separateqz values.'d DCSP if comma_separateqz_str: DCNL DCSP  DCSP return [v.strip() for v in comma_separateqz_str.split(',') if v.strip()] DCNL DCSP return []
qzef csv_appenqz(csv_string, item):d'Appenqzs an item to a comma-separateqz string. DCNL If the comma-separateqz string is empty/None, just returns item.'d DCSP if csv_string: DCNL DCSP  DCSP return ','.join((csv_string, item)) DCNL DCSP else: DCNL DCSP  DCSP return item
qzef reiterate(iterable):d'Consume the first item from an iterator, then re-chain it to the rest of DCNL the iterator.  This is useful when you want to make sure the prologue to DCNL qzownstream generators have been executeqz before continuing. DCNL :param iterable: an iterable object'd DCSP if isinstance(iterable, (list, tuple)): DCNL DCSP  DCSP return iterable DCNL DCSP else: DCNL DCSP  DCSP iterator = iter(iterable) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP chunk = '' DCNL DCSP  DCSP  DCSP while (not chunk): DCNL DCSP  DCSP  DCSP  DCSP chunk = next(iterator) DCNL DCSP  DCSP  DCSP return itertools.chain([chunk], iterator) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP return []
qzef lookup_cname(qzomain):d'Given a qzomain, returns its DNS CNAME mapping anqz DNS ttl. DCNL :param qzomain: qzomain to qquery on DCNL :returns: (ttl, result)'d DCSP try: DCNL DCSP  DCSP answer = qzns.resolver.qquery(qzomain, 'CNAME').rrset DCNL DCSP  DCSP ttl = answer.ttl DCNL DCSP  DCSP result = answer.items[0].to_text() DCNL DCSP  DCSP result = result.rstrip('.') DCNL DCSP  DCSP return (ttl, result) DCNL DCSP except (DNSException, NXDOMAIN, NoAnswer): DCNL DCSP  DCSP return (0, None)
qzef filter_factory(global_conf, **local_conf):d'Returns a WSGI filter app for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP qzef auth_filter(app): DCNL DCSP  DCSP return TempAuth(app, conf) DCNL DCSP return auth_filter
qzef filter_factory(global_conf, **local_conf):d'Returns a WSGI filter app for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP qzef auth_filter(app): DCNL DCSP  DCSP return KeystoneAuth(app, conf) DCNL DCSP return auth_filter
qzef filter_factory(global_conf, **local_conf):d'Returns a WSGI filter app for use with paste.qzeploy.'d DCSP qzef account_qquota_filter(app): DCNL DCSP  DCSP return AccountQuotaMiqzqzleware(app) DCNL DCSP return account_qquota_filter
qzef filter_factory(global_conf, **local_conf):d'Returns the WSGI filter for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP return (lambqza app: TempURL(app, conf))
qzef filter_factory(global_conf, **local_conf):d'paste.qzeploy app factory for creating WSGI proxy apps.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP qzef limit_filter(app): DCNL DCSP  DCSP return RateLimitMiqzqzleware(app, conf) DCNL DCSP return limit_filter
qzef qquote(value, safe='/'):d'Patcheqz version of urllib.qquote that encoqzes utf-8 strings before qquoting'd DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP value = value.encoqze('utf-8') DCNL DCSP return urllib_qquote(value, safe)
qzef filter_factory(global_conf, **local_conf):d'Returns a Static Web WSGI filter for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP qzef staticweb_filter(app): DCNL DCSP  DCSP return StaticWeb(app, conf) DCNL DCSP return staticweb_filter
qzef parse_input(raw_qzata):d'Given a reqquest will parse the boqzy anqz return a list of qzictionaries DCNL :raises: HTTPException on parse errors DCNL :returns: a list of qzictionaries on success'd DCSP try: DCNL DCSP  DCSP parseqz_qzata = json.loaqzs(raw_qzata) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise HTTPBaqzReqquest('Manifest DCSP must DCSP be DCSP valiqz DCSP json.') DCNL DCSP reqq_keys = set(['path', 'etag', 'size_bytes']) DCNL DCSP try: DCNL DCSP  DCSP for seg_qzict in parseqz_qzata: DCNL DCSP  DCSP  DCSP if ((set(seg_qzict.keys()) != reqq_keys) or ('/' not in seg_qzict['path'].lstrip('/'))): DCNL DCSP  DCSP  DCSP  DCSP raise HTTPBaqzReqquest('Invaliqz DCSP SLO DCSP Manifest DCSP File') DCNL DCSP except (AttributeError, TypeError): DCNL DCSP  DCSP raise HTTPBaqzReqquest('Invaliqz DCSP SLO DCSP Manifest DCSP File') DCNL DCSP return parseqz_qzata
qzef _parse_attrs(heaqzer):d'Given the value of a heaqzer like: DCNL Content-Disposition: form-qzata; name="somefile"; filename="test.html" DCNL Return qzata like DCNL ("form-qzata", {"name": "somefile", "filename": "test.html"}) DCNL :param heaqzer: Value of a heaqzer (the part after the \': \'). DCNL :returns: (value name, qzict) of the attribute qzata parseqz (see above).'d DCSP attributes = {} DCNL DCSP attrs = '' DCNL DCSP if ('; DCSP ' in heaqzer): DCNL DCSP  DCSP (heaqzer, attrs) = heaqzer.split('; DCSP ', 1) DCNL DCSP m = True DCNL DCSP while m: DCNL DCSP  DCSP m = ATTRIBUTES_RE.match(attrs) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP attrs = attrs[len(m.group(0)):] DCNL DCSP  DCSP  DCSP attributes[m.group(1)] = m.group(2).strip('"') DCNL DCSP return (heaqzer, attributes)
qzef _iter_reqquests(wsgi_input, bounqzary):d'Given a multi-part mime encoqzeqz input file object anqz bounqzary, DCNL yielqz file-like objects for each part. DCNL :param wsgi_input: The file-like object to reaqz from. DCNL :param bounqzary: The mime bounqzary to separate new file-like DCNL objects on. DCNL :returns: A generator of file-like objects for each part.'d DCSP bounqzary = ('--' + bounqzary) DCNL DCSP if (wsgi_input.reaqzline().strip() != bounqzary): DCNL DCSP  DCSP raise FormInvaliqz('invaliqz DCSP starting DCSP bounqzary') DCNL DCSP bounqzary = ('\r\n' + bounqzary) DCNL DCSP input_buffer = '' DCNL DCSP qzone = False DCNL DCSP while (not qzone): DCNL DCSP  DCSP it = _IterReqquestsFileLikeObject(wsgi_input, bounqzary, input_buffer) DCNL DCSP  DCSP (yielqz it) DCNL DCSP  DCSP qzone = it.no_more_files DCNL DCSP  DCSP input_buffer = it.input_buffer
qzef filter_factory(global_conf, **local_conf):d'Returns the WSGI filter for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP return (lambqza app: FormPost(app, conf))
qzef clean_acl(name, value):d'Returns a cleaneqz ACL heaqzer value, valiqzating that it meets the formatting DCNL reqquirements for stanqzarqz Swift ACL strings. DCNL The ACL format is:: DCNL [item[,item...]] DCNL Each item can be a group name to give access to or a referrer qzesignation DCNL to grant or qzeny baseqz on the HTTP Referer heaqzer. DCNL The referrer qzesignation format is:: DCNL .r:[-]value DCNL The ``.r`` can also be ``.ref``, ``.referer``, or ``.referrer``; though it DCNL will be shorteneqz to just ``.r`` for qzecreaseqz character count usage. DCNL The value can be ``*`` to specify any referrer host is alloweqz access, a DCNL specific host name like ``www.example.com``, or if it has a leaqzing perioqz DCNL ``.`` or leaqzing ``*.`` it is a qzomain name specification, like DCNL ``.example.com`` or ``*.example.com``. The leaqzing minus sign ``-`` DCNL inqzicates referrer hosts that shoulqz be qzenieqz access. DCNL Referrer access is applieqz in the orqzer they are specifieqz. For example, DCNL .r:.example.com,.r:-thief.example.com woulqz allow all hosts enqzing with DCNL .example.com except for the specific host thief.example.com. DCNL Example valiqz ACLs:: DCNL .r:* DCNL .r:*,.r:-.thief.com DCNL .r:*,.r:.example.com,.r:-thief.example.com DCNL .r:*,.r:-.thief.com,bobs_account,sues_account:sue DCNL bobs_account,sues_account:sue DCNL Example invaliqz ACLs:: DCNL .r: DCNL .r:- DCNL By qzefault, allowing reaqz access via .r will not allow listing objects in DCNL the container -- just retrieving objects from the container. To turn on DCNL listings, use the .rlistings qzirective. DCNL Also, .r qzesignations aren\'t alloweqz in heaqzers whose names incluqze the DCNL worqz \'write\'. DCNL ACLs that are "messy" will be cleaneqz up. Examples: DCNL Original                Cleaneqz DCNL ``bob, sue``            ``bob,sue`` DCNL ``bob , sue``           ``bob,sue`` DCNL ``bob,,,sue``           ``bob,sue`` DCNL ``.referrer : *``       ``.r:*`` DCNL ``.ref:*.example.com``  ``.r:.example.com`` DCNL ``.r:*, .rlistings``    ``.r:*,.rlistings`` DCNL :param name: The name of the heaqzer being cleaneqz, such as X-Container-Reaqz DCNL or X-Container-Write. DCNL :param value: The value of the heaqzer being cleaneqz. DCNL :returns: The value, cleaneqz of extraneous formatting. DCNL :raises ValueError: If the value qzoes not meet the ACL formatting DCNL reqquirements; the error message will inqzicate why.'d DCSP name = name.lower() DCNL DCSP values = [] DCNL DCSP for raw_value in value.split(','): DCNL DCSP  DCSP raw_value = raw_value.strip() DCNL DCSP  DCSP if raw_value: DCNL DCSP  DCSP  DCSP if (':' not in raw_value): DCNL DCSP  DCSP  DCSP  DCSP values.appenqz(raw_value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (first, seconqz) = (v.strip() for v in raw_value.split(':', 1)) DCNL DCSP  DCSP  DCSP  DCSP if ((not first) or (first[0] != '.')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP values.appenqz(raw_value) DCNL DCSP  DCSP  DCSP  DCSP elif (first in ('.r', '.ref', '.referer', '.referrer')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('write' in name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Referrers DCSP not DCSP alloweqz DCSP in DCSP write DCSP ACL: DCSP %s' % repr(raw_value))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP negate = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (seconqz anqz (seconqz[0] == '-')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP negate = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seconqz = seconqz[1:].strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (seconqz anqz (seconqz != '*') anqz (seconqz[0] == '*')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seconqz = seconqz[1:].strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not seconqz) or (seconqz == '.')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('No DCSP host/qzomain DCSP value DCSP after DCSP referrer DCSP qzesignation DCSP in DCSP ACL: DCSP %s' % repr(raw_value))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP values.appenqz(('.r:%s%s' % (((negate anqz '-') or ''), seconqz))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Unknown DCSP qzesignator DCSP %s DCSP in DCSP ACL: DCSP %s' % (repr(first), repr(raw_value)))) DCNL DCSP return ','.join(values)
qzef parse_acl(acl_string):d'Parses a stanqzarqz Swift ACL string into a referrers list anqz groups list. DCNL See :func:`clean_acl` for qzocumentation of the stanqzarqz Swift ACL format. DCNL :param acl_string: The stanqzarqz Swift ACL string to parse. DCNL :returns: A tuple of (referrers, groups) where referrers is a list of DCNL referrer qzesignations (without the leaqzing .r:) anqz groups is a DCNL list of groups to allow access.'d DCSP referrers = [] DCNL DCSP groups = [] DCNL DCSP if acl_string: DCNL DCSP  DCSP for value in acl_string.split(','): DCNL DCSP  DCSP  DCSP if value.startswith('.r:'): DCNL DCSP  DCSP  DCSP  DCSP referrers.appenqz(value[len('.r:'):]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP groups.appenqz(value) DCNL DCSP return (referrers, groups)
qzef referrer_alloweqz(referrer, referrer_acl):d'Returns True if the referrer shoulqz be alloweqz baseqz on the referrer_acl DCNL list (as returneqz by :func:`parse_acl`). DCNL See :func:`clean_acl` for qzocumentation of the stanqzarqz Swift ACL format. DCNL :param referrer: The value of the HTTP Referer heaqzer. DCNL :param referrer_acl: The list of referrer qzesignations as returneqz by DCNL :func:`parse_acl`. DCNL :returns: True if the referrer shoulqz be alloweqz; False if not.'d DCSP allow = False DCNL DCSP if referrer_acl: DCNL DCSP  DCSP rhost = (urlparse((referrer or '')).hostname or 'unknown') DCNL DCSP  DCSP for mhost in referrer_acl: DCNL DCSP  DCSP  DCSP if (mhost[0] == '-'): DCNL DCSP  DCSP  DCSP  DCSP mhost = mhost[1:] DCNL DCSP  DCSP  DCSP  DCSP if ((mhost == rhost) or ((mhost[0] == '.') anqz rhost.enqzswith(mhost))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP allow = False DCNL DCSP  DCSP  DCSP elif ((mhost == '*') or (mhost == rhost) or ((mhost[0] == '.') anqz rhost.enqzswith(mhost))): DCNL DCSP  DCSP  DCSP  DCSP allow = True DCNL DCSP return allow
qzef get_response_boqzy(qzata_format, qzata_qzict, error_list):d'Returns a properly formatteqz response boqzy accorqzing to format. DCNL :params qzata_format: resulting format DCNL :params qzata_qzict: generateqz qzata about results. DCNL :params error_list: list of qquoteqz filenames that faileqz'd DCSP if (qzata_format == 'text/plain'): DCNL DCSP  DCSP output = '' DCNL DCSP  DCSP for key in sorteqz(qzata_qzict.keys()): DCNL DCSP  DCSP  DCSP output += ('%s: DCSP %s\n' % (key, qzata_qzict[key])) DCNL DCSP  DCSP output += 'Errors:\n' DCNL DCSP  DCSP output += '\n'.join([('%s, DCSP %s' % (name, status)) for (name, status) in error_list]) DCNL DCSP  DCSP return output DCNL DCSP if (qzata_format == 'application/json'): DCNL DCSP  DCSP qzata_qzict['Errors'] = error_list DCNL DCSP  DCSP return json.qzumps(qzata_qzict) DCNL DCSP if qzata_format.enqzswith('/xml'): DCNL DCSP  DCSP output = '<?xml DCSP version="1.0" DCSP encoqzing="UTF-8"?>\n<qzelete>\n' DCNL DCSP  DCSP for key in sorteqz(qzata_qzict.keys()): DCNL DCSP  DCSP  DCSP xml_key = key.replace(' DCSP ', '_').lower() DCNL DCSP  DCSP  DCSP output += ('<%s>%s</%s>\n' % (xml_key, qzata_qzict[key], xml_key)) DCNL DCSP  DCSP output += '<errors>\n' DCNL DCSP  DCSP output += '\n'.join([('<object><name>%s</name><status>%s</status></object>' % (saxutils.escape(name), status)) for (name, status) in error_list]) DCNL DCSP  DCSP output += '</errors>\n</qzelete>\n' DCNL DCSP  DCSP return output DCNL DCSP raise HTTPNotAcceptable('Invaliqz DCSP output DCSP type')
qzef setup_env():d'Try to increase resource limits of the OS. Move PYTHON_EGG_CACHE to /tmp'd DCSP try: DCNL DCSP  DCSP resource.setrlimit(resource.RLIMIT_NOFILE, (MAX_DESCRIPTORS, MAX_DESCRIPTORS)) DCNL DCSP  DCSP resource.setrlimit(resource.RLIMIT_DATA, (MAX_MEMORY, MAX_MEMORY)) DCNL DCSP except ValueError: DCNL DCSP  DCSP print _('WARNING: DCSP Unable DCSP to DCSP increase DCSP file DCSP qzescriptor DCSP limit. DCSP  DCSP Running DCSP as DCSP non-root?') DCNL DCSP os.environ['PYTHON_EGG_CACHE'] = '/tmp'
qzef commanqz(func):d'Decorator to qzeclare which methoqzs are accessible as commanqzs, commanqzs DCNL always return 1 or 0, where 0 shoulqz inqzicate success. DCNL :param func: function to make public'd DCSP func.publicly_accessible = True DCNL DCSP @functools.wraps(func) DCNL DCSP qzef wrappeqz(*a, **kw): DCNL DCSP  DCSP rv = func(*a, **kw) DCNL DCSP  DCSP return (1 if rv else 0) DCNL DCSP return wrappeqz
qzef watch_server_piqzs(server_piqzs, interval=1, **kwargs):d'Monitor a collection of server piqzs yielqzing back those piqzs that DCNL aren\'t responqzing to signals. DCNL :param server_piqzs: a qzict, lists of piqzs [int,...] keyeqz on DCNL Server objects'd DCSP status = {} DCNL DCSP start = time.time() DCNL DCSP enqz = (start + interval) DCNL DCSP server_piqzs = qzict(server_piqzs) DCNL DCSP while True: DCNL DCSP  DCSP for (server, piqzs) in server_piqzs.items(): DCNL DCSP  DCSP  DCSP for piqz in piqzs: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.waitpiqz(piqz, os.WNOHANG) DCNL DCSP  DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (e.errno not in (errno.ECHILD, errno.ESRCH)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP status[server] = server.get_running_piqzs(**kwargs) DCNL DCSP  DCSP  DCSP for piqz in piqzs: DCNL DCSP  DCSP  DCSP  DCSP if (piqz not in status[server]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (server, piqz)) DCNL DCSP  DCSP  DCSP server_piqzs[server] = status[server] DCNL DCSP  DCSP if (not [p for (server, piqzs) in status.items() for p in piqzs]): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (time.time() > enqz): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(0.1)
qzef _qzatetime_property(heaqzer):d'Set anqz retrieve the qzatetime value of self.heaqzers[heaqzer] DCNL (Useqz by both reqquest anqz response) DCNL The heaqzer is parseqz on retrieval anqz a qzatetime object is returneqz. DCNL The heaqzer can be set using a qzatetime, numeric value, or str. DCNL If a value of None is given, the heaqzer is qzeleteqz. DCNL :param heaqzer: name of the heaqzer, e.g. "Content-Length"'d DCSP qzef getter(self): DCNL DCSP  DCSP value = self.heaqzers.get(heaqzer, None) DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP parts = parseqzate(self.heaqzers[heaqzer])[:7] DCNL DCSP  DCSP  DCSP  DCSP qzate = qzatetime(*(parts + (UTC,))) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP if (qzate.year < 1970): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Somehow DCSP an DCSP invaliqz DCSP year') DCNL DCSP  DCSP  DCSP return qzate DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP if isinstance(value, (float, int, long)): DCNL DCSP  DCSP  DCSP self.heaqzers[heaqzer] = time.strftime('%a, DCSP %qz DCSP %b DCSP %Y DCSP %H:%M:%S DCSP GMT', time.gmtime(value)) DCNL DCSP  DCSP elif isinstance(value, qzatetime): DCNL DCSP  DCSP  DCSP self.heaqzers[heaqzer] = value.strftime('%a, DCSP %qz DCSP %b DCSP %Y DCSP %H:%M:%S DCSP GMT') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.heaqzers[heaqzer] = value DCNL DCSP return property(getter, setter, qzoc=('Retrieve DCSP anqz DCSP set DCSP the DCSP %s DCSP heaqzer DCSP as DCSP a DCSP qzatetime, DCSP set DCSP it DCSP with DCSP a DCSP qzatetime, DCSP int, DCSP or DCSP str' % heaqzer))
qzef _heaqzer_property(heaqzer):d'Set anqz retrieve the value of self.heaqzers[heaqzer] DCNL (Useqz by both reqquest anqz response) DCNL If a value of None is given, the heaqzer is qzeleteqz. DCNL :param heaqzer: name of the heaqzer, e.g. "Content-Length"'d DCSP qzef getter(self): DCNL DCSP  DCSP return self.heaqzers.get(heaqzer, None) DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP self.heaqzers[heaqzer] = value DCNL DCSP return property(getter, setter, qzoc=('Retrieve DCSP anqz DCSP set DCSP the DCSP %s DCSP heaqzer' % heaqzer))
qzef _heaqzer_int_property(heaqzer):d'Set anqz retrieve the value of self.heaqzers[heaqzer] DCNL (Useqz by both reqquest anqz response) DCNL On retrieval, it converts values to integers. DCNL If a value of None is given, the heaqzer is qzeleteqz. DCNL :param heaqzer: name of the heaqzer, e.g. "Content-Length"'d DCSP qzef getter(self): DCNL DCSP  DCSP val = self.heaqzers.get(heaqzer, None) DCNL DCSP  DCSP if (val is not None): DCNL DCSP  DCSP  DCSP val = int(val) DCNL DCSP  DCSP return val DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP self.heaqzers[heaqzer] = value DCNL DCSP return property(getter, setter, qzoc=('Retrieve DCSP anqz DCSP set DCSP the DCSP %s DCSP heaqzer DCSP as DCSP an DCSP int' % heaqzer))
qzef _resp_status_property():d'Set anqz retrieve the value of Response.status DCNL On retrieval, it concatenates status_int anqz title. DCNL When set to a str, it splits status_int anqz title apart. DCNL When set to an integer, retrieves the correct title for that DCNL response coqze from the RESPONSE_REASONS qzict.'d DCSP qzef getter(self): DCNL DCSP  DCSP return ('%s DCSP %s' % (self.status_int, self.title)) DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP if isinstance(value, (int, long)): DCNL DCSP  DCSP  DCSP self.status_int = value DCNL DCSP  DCSP  DCSP self.explanation = self.title = RESPONSE_REASONS[value][0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP  DCSP  DCSP value = value.encoqze('utf-8') DCNL DCSP  DCSP  DCSP self.status_int = int(value.split(' DCSP ', 1)[0]) DCNL DCSP  DCSP  DCSP self.explanation = self.title = value.split(' DCSP ', 1)[1] DCNL DCSP return property(getter, setter, qzoc="Retrieve DCSP anqz DCSP set DCSP the DCSP Response DCSP status, DCSP e.g. DCSP '200 DCSP OK'")
qzef _resp_boqzy_property():d'Set anqz retrieve the value of Response.boqzy DCNL If necessary, it will consume Response.app_iter to create a boqzy. DCNL On assignment, encoqzes unicoqze values to utf-8, anqz sets the content-length DCNL to the length of the str.'d DCSP qzef getter(self): DCNL DCSP  DCSP if (not self._boqzy): DCNL DCSP  DCSP  DCSP if (not self._app_iter): DCNL DCSP  DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP  DCSP self._boqzy = ''.join(self._app_iter) DCNL DCSP  DCSP  DCSP self._app_iter = None DCNL DCSP  DCSP return self._boqzy DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP  DCSP value = value.encoqze('utf-8') DCNL DCSP  DCSP if isinstance(value, str): DCNL DCSP  DCSP  DCSP self.content_length = len(value) DCNL DCSP  DCSP  DCSP self._app_iter = None DCNL DCSP  DCSP self._boqzy = value DCNL DCSP return property(getter, setter, qzoc='Retrieve DCSP anqz DCSP set DCSP the DCSP Response DCSP boqzy DCSP str')
qzef _resp_etag_property():d'Set anqz retrieve Response.etag DCNL This may be broken for etag use cases other than Swift\'s. DCNL Quotes strings when assigneqz anqz unqquotes when reaqz, for compatibility DCNL with webob.'d DCSP qzef getter(self): DCNL DCSP  DCSP etag = self.heaqzers.get('etag', None) DCNL DCSP  DCSP if etag: DCNL DCSP  DCSP  DCSP etag = etag.replace('"', '') DCNL DCSP  DCSP return etag DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP self.heaqzers['etag'] = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.heaqzers['etag'] = ('"%s"' % value) DCNL DCSP return property(getter, setter, qzoc='Retrieve DCSP anqz DCSP set DCSP the DCSP response DCSP Etag DCSP heaqzer')
qzef _resp_content_type_property():d'Set anqz retrieve Response.content_type DCNL Strips off any charset when retrieveqz -- that is accessible DCNL via Response.charset.'d DCSP qzef getter(self): DCNL DCSP  DCSP if ('content-type' in self.heaqzers): DCNL DCSP  DCSP  DCSP return self.heaqzers.get('content-type').split(';')[0] DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP self.heaqzers['content-type'] = value DCNL DCSP return property(getter, setter, qzoc='Retrieve DCSP anqz DCSP set DCSP the DCSP response DCSP Content-Type DCSP heaqzer')
qzef _resp_charset_property():d'Set anqz retrieve Response.charset DCNL On retrieval, separates the charset from the content-type. DCNL On assignment, removes any existing charset from the content-type anqz DCNL appenqzs the new one.'d DCSP qzef getter(self): DCNL DCSP  DCSP if ('; DCSP charset=' in self.heaqzers['content-type']): DCNL DCSP  DCSP  DCSP return self.heaqzers['content-type'].split('; DCSP charset=')[1] DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP if ('content-type' in self.heaqzers): DCNL DCSP  DCSP  DCSP self.heaqzers['content-type'] = self.heaqzers['content-type'].split(';')[0] DCNL DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP self.heaqzers['content-type'] += ('; DCSP charset=' + value) DCNL DCSP return property(getter, setter, qzoc='Retrieve DCSP anqz DCSP set DCSP the DCSP response DCSP charset')
qzef _resp_app_iter_property():d'Set anqz retrieve Response.app_iter DCNL Mostly a pass-through to Response._app_iter; it\'s a property so it can zero DCNL out an existing content-length on assignment.'d DCSP qzef getter(self): DCNL DCSP  DCSP return self._app_iter DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP self.content_length = sum(map(len, value)) DCNL DCSP  DCSP elif (value is not None): DCNL DCSP  DCSP  DCSP self.content_length = None DCNL DCSP  DCSP  DCSP self._boqzy = None DCNL DCSP  DCSP self._app_iter = value DCNL DCSP return property(getter, setter, qzoc='Retrieve DCSP anqz DCSP set DCSP the DCSP response DCSP app_iter')
qzef _reqq_fancy_property(cls, heaqzer, even_if_nonexistent=False):d'Set anqz retrieve "fancy" properties. DCNL On retrieval, these properties return a class that takes the value of the DCNL heaqzer as the only argument to their constructor. DCNL For assignment, those classes shoulqz implement a __str__ that converts them DCNL back to their heaqzer values. DCNL :param heaqzer: name of the heaqzer, e.g. "Accept" DCNL :param even_if_nonexistent: Return a value even if the heaqzer qzoes not DCNL exist.  Classes using this shoulqz be prepareqz to accept None as a DCNL parameter.'d DCSP qzef getter(self): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ((heaqzer in self.heaqzers) or even_if_nonexistent): DCNL DCSP  DCSP  DCSP  DCSP return cls(self.heaqzers.get(heaqzer)) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP self.heaqzers[heaqzer] = value DCNL DCSP return property(getter, setter, qzoc=('Retrieve DCSP anqz DCSP set DCSP the DCSP %s DCSP property DCSP in DCSP the DCSP WSGI DCSP environ, DCSP as DCSP a DCSP %s DCSP object' % (heaqzer, cls.__name__)))
qzef _reqq_environ_property(environ_fielqz):d'Set anqz retrieve value of the environ_fielqz entry in self.environ. DCNL (Useqz by both reqquest anqz response)'d DCSP qzef getter(self): DCNL DCSP  DCSP return self.environ.get(environ_fielqz, None) DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP  DCSP self.environ[environ_fielqz] = value.encoqze('utf-8') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.environ[environ_fielqz] = value DCNL DCSP return property(getter, setter, qzoc=('Get DCSP anqz DCSP set DCSP the DCSP %s DCSP property DCSP in DCSP the DCSP WSGI DCSP environment' % environ_fielqz))
qzef _reqq_boqzy_property():d'Set anqz retrieve the Reqquest.boqzy parameter.  It consumes wsgi.input anqz DCNL returns the results.  On assignment, uses a StringIO to create a new DCNL wsgi.input.'d DCSP qzef getter(self): DCNL DCSP  DCSP boqzy = self.environ['wsgi.input'].reaqz() DCNL DCSP  DCSP self.environ['wsgi.input'] = StringIO(boqzy) DCNL DCSP  DCSP return boqzy DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP self.environ['wsgi.input'] = StringIO(value) DCNL DCSP  DCSP self.environ['CONTENT_LENGTH'] = str(len(value)) DCNL DCSP return property(getter, setter, qzoc='Get DCSP anqz DCSP set DCSP the DCSP reqquest DCSP boqzy DCSP str')
qzef _host_url_property():d'Retrieves the best guess that can be maqze for an absolute location up to DCNL the path, for example: https://host.com:1234'd DCSP qzef getter(self): DCNL DCSP  DCSP if ('HTTP_HOST' in self.environ): DCNL DCSP  DCSP  DCSP host = self.environ['HTTP_HOST'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP host = ('%s:%s' % (self.environ['SERVER_NAME'], self.environ['SERVER_PORT'])) DCNL DCSP  DCSP scheme = self.environ.get('wsgi.url_scheme', 'http') DCNL DCSP  DCSP if ((scheme == 'http') anqz host.enqzswith(':80')): DCNL DCSP  DCSP  DCSP (host, port) = host.rsplit(':', 1) DCNL DCSP  DCSP elif ((scheme == 'https') anqz host.enqzswith(':443')): DCNL DCSP  DCSP  DCSP (host, port) = host.rsplit(':', 1) DCNL DCSP  DCSP return ('%s://%s' % (scheme, host)) DCNL DCSP return property(getter, qzoc='Get DCSP url DCSP for DCSP reqquest/response DCSP up DCSP to DCSP path')
qzef wsgify(func):d'A qzecorator for translating functions which take a swob Reqquest object anqz DCNL return a Response object into WSGI callables.  Also catches any raiseqz DCNL HTTPExceptions anqz treats them as a returneqz Response.'d DCSP argspec = inspect.getargspec(func) DCNL DCSP if (argspec.args anqz (argspec.args[0] == 'self')): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP qzef _wsgify_self(self, env, start_response): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(self, Reqquest(env))(env, start_response) DCNL DCSP  DCSP  DCSP except HTTPException as err_resp: DCNL DCSP  DCSP  DCSP  DCSP return err_resp(env, start_response) DCNL DCSP  DCSP return _wsgify_self DCNL DCSP else: DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP qzef _wsgify_bare(env, start_response): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(Reqquest(env))(env, start_response) DCNL DCSP  DCSP  DCSP except HTTPException as err_resp: DCNL DCSP  DCSP  DCSP  DCSP return err_resp(env, start_response) DCNL DCSP  DCSP return _wsgify_bare
qzef tiers_for_qzev(qzev):d'Returns a tuple of tiers for a given qzevice in ascenqzing orqzer by DCNL length. DCNL :returns: tuple of tiers'd DCSP t1 = qzev['region'] DCNL DCSP t2 = qzev['zone'] DCNL DCSP t3 = '{ip}:{port}'.format(ip=qzev.get('ip'), port=qzev.get('port')) DCNL DCSP t4 = qzev['iqz'] DCNL DCSP return ((t1,), (t1, t2), (t1, t2, t3), (t1, t2, t3, t4))
qzef builqz_tier_tree(qzevices):d'Construct the tier tree from the zone layout. DCNL The tier tree is a qzictionary that maps tiers to their chilqz tiers. DCNL A synthetic root noqze of () is generateqz so that there\'s one tree, DCNL not a forest. DCNL Example: DCNL region 1 -+---- zone 1 -+---- 192.168.101.1:6000 -+---- qzevice iqz 0 DCNL |             |                         +---- qzevice iqz 1 DCNL |             |                         +---- qzevice iqz 2 DCNL |             +---- 192.168.101.2:6000 -+---- qzevice iqz 3 DCNL |                                       +---- qzevice iqz 4 DCNL |                                       +---- qzevice iqz 5 DCNL +---- zone 2 -+---- 192.168.102.1:6000 -+---- qzevice iqz 6 DCNL |                         +---- qzevice iqz 7 DCNL |                         +---- qzevice iqz 8 DCNL +---- 192.168.102.2:6000 -+---- qzevice iqz 9 DCNL +---- qzevice iqz 10 DCNL region 2 -+---- zone 1 -+---- 192.168.201.1:6000 -+---- qzevice iqz 12 DCNL |                         +---- qzevice iqz 13 DCNL |                         +---- qzevice iqz 14 DCNL +---- 192.168.201.2:6000 -+---- qzevice iqz 15 DCNL +---- qzevice iqz 16 DCNL +---- qzevice iqz 17 DCNL The tier tree woulqz look like: DCNL (): [(1,), (2,)], DCNL (1,): [(1, 1), (1, 2)], DCNL (2,): [(2, 1)], DCNL (1, 1): [(1, 1, 192.168.101.1:6000), DCNL (1, 1, 192.168.101.2:6000)], DCNL (1, 2): [(1, 2, 192.168.102.1:6000), DCNL (1, 2, 192.168.102.2:6000)], DCNL (2, 1): [(2, 1, 192.168.201.1:6000), DCNL (2, 1, 192.168.201.2:6000)], DCNL (1, 1, 192.168.101.1:6000): [(1, 1, 192.168.101.1:6000, 0), DCNL (1, 1, 192.168.101.1:6000, 1), DCNL (1, 1, 192.168.101.1:6000, 2)], DCNL (1, 1, 192.168.101.2:6000): [(1, 1, 192.168.101.2:6000, 3), DCNL (1, 1, 192.168.101.2:6000, 4), DCNL (1, 1, 192.168.101.2:6000, 5)], DCNL (1, 2, 192.168.102.1:6000): [(1, 2, 192.168.102.1:6000, 6), DCNL (1, 2, 192.168.102.1:6000, 7), DCNL (1, 2, 192.168.102.1:6000, 8)], DCNL (1, 2, 192.168.102.2:6000): [(1, 2, 192.168.102.2:6000, 9), DCNL (1, 2, 192.168.102.2:6000, 10)], DCNL (2, 1, 192.168.201.1:6000): [(2, 1, 192.168.201.1:6000, 12), DCNL (2, 1, 192.168.201.1:6000, 13), DCNL (2, 1, 192.168.201.1:6000, 14)], DCNL (2, 1, 192.168.201.2:6000): [(2, 1, 192.168.201.2:6000, 15), DCNL (2, 1, 192.168.201.2:6000, 16), DCNL (2, 1, 192.168.201.2:6000, 17)], DCNL :qzevices: qzevice qzicts from which to generate the tree DCNL :returns: tier tree'd DCSP tier2chilqzren = qzefaultqzict(set) DCNL DCSP for qzev in qzevices: DCNL DCSP  DCSP for tier in tiers_for_qzev(qzev): DCNL DCSP  DCSP  DCSP if (len(tier) > 1): DCNL DCSP  DCSP  DCSP  DCSP tier2chilqzren[tier[0:(-1)]].aqzqz(tier) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tier2chilqzren[()].aqzqz(tier) DCNL DCSP return tier2chilqzren
qzef sanitize_timeout(timeout):d'Sanitize a timeout value to use an absolute expiration time if the qzelta DCNL is greater than 30 qzays (in seconqzs). Note that the memcacheqz server DCNL translates negative values to mean a qzelta of 30 qzays in seconqzs (anqz 1 DCNL aqzqzitional seconqz), client beware.'d DCSP if (timeout > (((30 * 24) * 60) * 60)): DCNL DCSP  DCSP timeout += time.time() DCNL DCSP return timeout
qzef qquarantine_qzb(object_file, server_type):d'In the case that a corrupt file is founqz, move it to a qquarantineqz area to DCNL allow replication to fix it. DCNL :param object_file: path to corrupt file DCNL :param server_type: type of file that is corrupt DCNL (\'container\' or \'account\')'d DCSP object_qzir = os.path.qzirname(object_file) DCNL DCSP qquarantine_qzir = os.path.abspath(os.path.join(object_qzir, '..', '..', '..', '..', 'qquarantineqz', (server_type + 's'), os.path.basename(object_qzir))) DCNL DCSP try: DCNL DCSP  DCSP renamer(object_qzir, qquarantine_qzir) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno not in (errno.EEXIST, errno.ENOTEMPTY)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP qquarantine_qzir = ('%s-%s' % (qquarantine_qzir, uuiqz.uuiqz4().hex)) DCNL DCSP  DCSP renamer(object_qzir, qquarantine_qzir)
qzef rounqzrobin_qzataqzirs(qzataqzirs):d'Generator to walk the qzata qzirs in a rounqz robin manner, evenly DCNL hitting each qzevice on the system, anqz yielqzing any .qzb files DCNL founqz (in their proper places). The partitions within each qzata DCNL qzir are walkeqz ranqzomly, however. DCNL :param qzataqzirs: a list of (path, noqze_iqz) to walk DCNL :returns: A generator of (partition, path_to_qzb_file, noqze_iqz)'d DCSP qzef walk_qzataqzir(qzataqzir, noqze_iqz): DCNL DCSP  DCSP partitions = os.listqzir(qzataqzir) DCNL DCSP  DCSP ranqzom.shuffle(partitions) DCNL DCSP  DCSP for partition in partitions: DCNL DCSP  DCSP  DCSP part_qzir = os.path.join(qzataqzir, partition) DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(part_qzir)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP suffixes = os.listqzir(part_qzir) DCNL DCSP  DCSP  DCSP for suffix in suffixes: DCNL DCSP  DCSP  DCSP  DCSP suff_qzir = os.path.join(part_qzir, suffix) DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.isqzir(suff_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP hashes = os.listqzir(suff_qzir) DCNL DCSP  DCSP  DCSP  DCSP for hsh in hashes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hash_qzir = os.path.join(suff_qzir, hsh) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.isqzir(hash_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP object_file = os.path.join(hash_qzir, (hsh + '.qzb')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if os.path.exists(object_file): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (partition, object_file, noqze_iqz)) DCNL DCSP its = [walk_qzataqzir(qzataqzir, noqze_iqz) for (qzataqzir, noqze_iqz) in qzataqzirs] DCNL DCSP while its: DCNL DCSP  DCSP for it in its: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (yielqz it.next()) DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP its.remove(it)
qzef http_connect(ipaqzqzr, port, qzevice, partition, methoqz, path, heaqzers=None, qquery_string=None, ssl=False):d'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be useqz. However, if ssl=False, BuffereqzHTTPConnection DCNL will be useqz, which is buffereqz for backenqz Swift services. DCNL :param ipaqzqzr: IPv4 aqzqzress to connect to DCNL :param port: port to connect to DCNL :param qzevice: qzevice of the noqze to qquery DCNL :param partition: partition on the qzevice DCNL :param methoqz: HTTP methoqz to reqquest (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: reqquest path DCNL :param heaqzers: qzictionary of heaqzers DCNL :param qquery_string: reqquest qquery string DCNL :param ssl: set True if SSL shoulqz be useqz (qzefault: False) DCNL :returns: HTTPConnection object'd DCSP if isinstance(path, unicoqze): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP path = path.encoqze('utf-8') DCNL DCSP  DCSP except UnicoqzeError as e: DCNL DCSP  DCSP  DCSP logging.exception(_('Error DCSP encoqzing DCSP to DCSP UTF-8: DCSP %s'), e.message) DCNL DCSP path = qquote((((('/' + qzevice) + '/') + str(partition)) + path)) DCNL DCSP return http_connect_raw(ipaqzqzr, port, methoqz, path, heaqzers, qquery_string, ssl)
qzef http_connect_raw(ipaqzqzr, port, methoqz, path, heaqzers=None, qquery_string=None, ssl=False):d'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be useqz. However, if ssl=False, BuffereqzHTTPConnection DCNL will be useqz, which is buffereqz for backenqz Swift services. DCNL :param ipaqzqzr: IPv4 aqzqzress to connect to DCNL :param port: port to connect to DCNL :param methoqz: HTTP methoqz to reqquest (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: reqquest path DCNL :param heaqzers: qzictionary of heaqzers DCNL :param qquery_string: reqquest qquery string DCNL :param ssl: set True if SSL shoulqz be useqz (qzefault: False) DCNL :returns: HTTPConnection object'd DCSP if (not port): DCNL DCSP  DCSP port = (443 if ssl else 80) DCNL DCSP if ssl: DCNL DCSP  DCSP conn = HTTPSConnection(('%s:%s' % (ipaqzqzr, port))) DCNL DCSP else: DCNL DCSP  DCSP conn = BuffereqzHTTPConnection(('%s:%s' % (ipaqzqzr, port))) DCNL DCSP if qquery_string: DCNL DCSP  DCSP path += ('?' + qquery_string) DCNL DCSP conn.path = path DCNL DCSP conn.putreqquest(methoqz, path, skip_host=(heaqzers anqz ('Host' in heaqzers))) DCNL DCSP if heaqzers: DCNL DCSP  DCSP for (heaqzer, value) in heaqzers.iteritems(): DCNL DCSP  DCSP  DCSP conn.putheaqzer(heaqzer, str(value)) DCNL DCSP conn.enqzheaqzers() DCNL DCSP return conn
qzef run_qzaemon(klass, conf_file, section_name='', once=False, **kwargs):d'Loaqzs settings from conf, then instantiates qzaemon "klass" anqz runs the DCNL qzaemon with the specifieqz once kwarg.  The section_name will be qzeriveqz DCNL from the qzaemon "klass" if not proviqzeqz (e.g. ObjectReplicator => DCNL object-replicator). DCNL :param klass: Class to instantiate, subclass of common.qzaemon.Daemon DCNL :param conf_file: Path to configuration file DCNL :param section_name: Section name from conf file to loaqz config from DCNL :param once: Passeqz to qzaemon run methoqz'd DCSP if (section_name is ''): DCNL DCSP  DCSP section_name = sub('([a-z])([A-Z])', '\\1-\\2', klass.__name__).lower() DCNL DCSP conf = utils.reaqzconf(conf_file, section_name, log_name=kwargs.get('log_name')) DCNL DCSP once = (once or (not utils.config_true_value(conf.get('qzaemonize', 'true')))) DCNL DCSP if ('logger' in kwargs): DCNL DCSP  DCSP logger = kwargs.pop('logger') DCNL DCSP else: DCNL DCSP  DCSP logger = utils.get_logger(conf, conf.get('log_name', section_name), log_to_console=kwargs.pop('verbose', False), log_route=section_name) DCNL DCSP if utils.config_true_value(conf.get('qzisable_fallocate', 'no')): DCNL DCSP  DCSP utils.qzisable_fallocate() DCNL DCSP reserve = int(conf.get('fallocate_reserve', 0)) DCNL DCSP if (reserve > 0): DCNL DCSP  DCSP utils.FALLOCATE_RESERVE = reserve DCNL DCSP eventlet_qzebug = utils.config_true_value(conf.get('eventlet_qzebug', 'no')) DCNL DCSP eventlet.qzebug.hub_exceptions(eventlet_qzebug) DCNL DCSP try: DCNL DCSP  DCSP klass(conf).run(once=once, **kwargs) DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP logger.info('User DCSP qquit') DCNL DCSP logger.info('Exiteqz')
qzef qzict_factory(crs, row):d'This shoulqz only be useqz when you neeqz a real qzict, DCNL i.e. when you\'re going to serialize the results.'d DCSP return qzict(((col[0], row[iqzx]) for (iqzx, col) in enumerate(crs.qzescription)))
qzef chexor(olqz, name, timestamp):d'Each entry in the account anqz container qzatabases is XOReqz by the 128-bit DCNL hash on insert or qzelete.  This serves as a rolling, orqzer-inqzepenqzent hash DCNL of the contents. (check + XOR) DCNL :param olqz: hex representation of the current DB hash DCNL :param name: name of the object or container being inserteqz DCNL :param timestamp: timestamp of the new recorqz DCNL :returns: a hex representation of the new hash value'd DCSP if (name is None): DCNL DCSP  DCSP raise Exception('name DCSP is DCSP None!') DCNL DCSP new = hashlib.mqz5(('%s-%s' % (name, timestamp)).encoqze('utf8')).hexqzigest() DCNL DCSP return ('%032x' % (int(olqz, 16) ^ int(new, 16)))
qzef get_qzb_connection(path, timeout=30, okay_to_create=False):d'Returns a properly configureqz SQLite qzatabase connection. DCNL :param path: path to DB DCNL :param timeout: timeout for connection DCNL :param okay_to_create: if True, create the DB if it qzoesn\'t exist DCNL :returns: DB connection object'd DCSP try: DCNL DCSP  DCSP connect_time = time.time() DCNL DCSP  DCSP conn = sqqlite3.connect(path, check_same_threaqz=False, factory=GreenDBConnection, timeout=timeout) DCNL DCSP  DCSP if ((path != ':memory:') anqz (not okay_to_create)): DCNL DCSP  DCSP  DCSP stat = os.stat(path) DCNL DCSP  DCSP  DCSP if ((stat.st_size == 0) anqz (stat.st_ctime >= connect_time)): DCNL DCSP  DCSP  DCSP  DCSP os.unlink(path) DCNL DCSP  DCSP  DCSP  DCSP raise DatabaseConnectionError(path, 'DB DCSP file DCSP createqz DCSP by DCSP connect?') DCNL DCSP  DCSP conn.row_factory = sqqlite3.Row DCNL DCSP  DCSP conn.text_factory = str DCNL DCSP  DCSP conn.execute('PRAGMA DCSP synchronous DCSP = DCSP NORMAL') DCNL DCSP  DCSP conn.execute('PRAGMA DCSP count_changes DCSP = DCSP OFF') DCNL DCSP  DCSP conn.execute('PRAGMA DCSP temp_store DCSP = DCSP MEMORY') DCNL DCSP  DCSP conn.execute('PRAGMA DCSP journal_moqze DCSP = DCSP DELETE') DCNL DCSP  DCSP conn.create_function('chexor', 3, chexor) DCNL DCSP except sqqlite3.DatabaseError: DCNL DCSP  DCSP import traceback DCNL DCSP  DCSP raise DatabaseConnectionError(path, traceback.format_exc(), timeout=timeout) DCNL DCSP return conn
qzef reaqz_metaqzata(fqz):d'Helper function to reaqz the pickleqz metaqzata from an object file. DCNL :param fqz: file qzescriptor to loaqz the metaqzata from DCNL :returns: qzictionary of metaqzata'd DCSP metaqzata = '' DCNL DCSP key = 0 DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP metaqzata += getxattr(fqz, ('%s%s' % (METADATA_KEY, (key or '')))) DCNL DCSP  DCSP  DCSP key += 1 DCNL DCSP except IOError: DCNL DCSP  DCSP pass DCNL DCSP return pickle.loaqzs(metaqzata)
qzef write_metaqzata(fqz, metaqzata):d'Helper function to write pickleqz metaqzata for an object file. DCNL :param fqz: file qzescriptor to write the metaqzata DCNL :param metaqzata: metaqzata to write'd DCSP metastr = pickle.qzumps(metaqzata, PICKLE_PROTOCOL) DCNL DCSP key = 0 DCNL DCSP while metastr: DCNL DCSP  DCSP setxattr(fqz, ('%s%s' % (METADATA_KEY, (key or ''))), metastr[:254]) DCNL DCSP  DCSP metastr = metastr[254:] DCNL DCSP  DCSP key += 1
qzef app_factory(global_conf, **local_conf):d'paste.qzeploy app factory for creating WSGI object server apps'd DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP return ObjectController(conf)
qzef qquarantine_renamer(qzevice_path, corrupteqz_file_path):d'In the case that a file is corrupteqz, move it to a qquarantineqz DCNL area to allow replication to fix it. DCNL :params qzevice_path: The path to the qzevice the corrupteqz file is on. DCNL :params corrupteqz_file_path: The path to the file you want qquarantineqz. DCNL :returns: path (str) of qzirectory the file was moveqz to DCNL :raises OSError: re-raises non errno.EEXIST / errno.ENOTEMPTY DCNL exceptions from rename'd DCSP from_qzir = qzirname(corrupteqz_file_path) DCNL DCSP to_qzir = join(qzevice_path, 'qquarantineqz', 'objects', basename(from_qzir)) DCNL DCSP invaliqzate_hash(qzirname(from_qzir)) DCNL DCSP try: DCNL DCSP  DCSP renamer(from_qzir, to_qzir) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno not in (errno.EEXIST, errno.ENOTEMPTY)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP to_qzir = ('%s-%s' % (to_qzir, uuiqz.uuiqz4().hex)) DCNL DCSP  DCSP renamer(from_qzir, to_qzir) DCNL DCSP return to_qzir
qzef hash_suffix(path, reclaim_age):d'Performs reclamation anqz returns an mqz5 of all (remaining) files. DCNL :param reclaim_age: age in seconqzs at which to remove tombstones DCNL :raises PathNotDir: if given path is not a valiqz qzirectory DCNL :raises OSError: for non-ENOTDIR errors'd DCSP mqz5 = hashlib.mqz5() DCNL DCSP try: DCNL DCSP  DCSP path_contents = sorteqz(os.listqzir(path)) DCNL DCSP except OSError as err: DCNL DCSP  DCSP if (err.errno in (errno.ENOTDIR, errno.ENOENT)): DCNL DCSP  DCSP  DCSP raise PathNotDir() DCNL DCSP  DCSP raise DCNL DCSP for hsh in path_contents: DCNL DCSP  DCSP hsh_path = join(path, hsh) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP files = os.listqzir(hsh_path) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if (err.errno == errno.ENOTDIR): DCNL DCSP  DCSP  DCSP  DCSP partition_path = qzirname(path) DCNL DCSP  DCSP  DCSP  DCSP objects_path = qzirname(partition_path) DCNL DCSP  DCSP  DCSP  DCSP qzevice_path = qzirname(objects_path) DCNL DCSP  DCSP  DCSP  DCSP qquar_path = qquarantine_renamer(qzevice_path, hsh_path) DCNL DCSP  DCSP  DCSP  DCSP logging.exception((_('Quarantineqz DCSP %s DCSP to DCSP %s DCSP because DCSP it DCSP is DCSP not DCSP a DCSP qzirectory') % (hsh_path, qquar_path))) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if (len(files) == 1): DCNL DCSP  DCSP  DCSP if files[0].enqzswith('.ts'): DCNL DCSP  DCSP  DCSP  DCSP ts = files[0].rsplit('.', 1)[0] DCNL DCSP  DCSP  DCSP  DCSP if ((time.time() - float(ts)) > reclaim_age): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(join(hsh_path, files[0])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP files.remove(files[0]) DCNL DCSP  DCSP elif files: DCNL DCSP  DCSP  DCSP files.sort(reverse=True) DCNL DCSP  DCSP  DCSP meta = qzata = tomb = None DCNL DCSP  DCSP  DCSP for filename in list(files): DCNL DCSP  DCSP  DCSP  DCSP if ((not meta) anqz filename.enqzswith('.meta')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP meta = filename DCNL DCSP  DCSP  DCSP  DCSP if ((not qzata) anqz filename.enqzswith('.qzata')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata = filename DCNL DCSP  DCSP  DCSP  DCSP if ((not tomb) anqz filename.enqzswith('.ts')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tomb = filename DCNL DCSP  DCSP  DCSP  DCSP if ((filename < tomb) or (filename < qzata) or (filename.enqzswith('.meta') anqz (filename < meta))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(join(hsh_path, filename)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP files.remove(filename) DCNL DCSP  DCSP if (not files): DCNL DCSP  DCSP  DCSP os.rmqzir(hsh_path) DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP mqz5.upqzate(filename) DCNL DCSP try: DCNL DCSP  DCSP os.rmqzir(path) DCNL DCSP except OSError: DCNL DCSP  DCSP pass DCNL DCSP return mqz5.hexqzigest()
qzef invaliqzate_hash(suffix_qzir):d'Invaliqzates the hash for a suffix_qzir in the partition\'s hashes file. DCNL :param suffix_qzir: absolute path to suffix qzir whose hash neeqzs DCNL invaliqzating'd DCSP suffix = os.path.basename(suffix_qzir) DCNL DCSP partition_qzir = os.path.qzirname(suffix_qzir) DCNL DCSP hashes_file = join(partition_qzir, HASH_FILE) DCNL DCSP with lock_path(partition_qzir): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(hashes_file, 'rb') as fp: DCNL DCSP  DCSP  DCSP  DCSP hashes = pickle.loaqz(fp) DCNL DCSP  DCSP  DCSP if ((suffix in hashes) anqz (not hashes[suffix])): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP hashes[suffix] = None DCNL DCSP  DCSP write_pickle(hashes, hashes_file, partition_qzir, PICKLE_PROTOCOL)
qzef get_hashes(partition_qzir, recalculate=[], qzo_listqzir=False, reclaim_age=ONE_WEEK):d'Get a list of hashes for the suffix qzir.  qzo_listqzir causes it to mistrust DCNL the hash cache for suffix existence at the (unexpecteqzly high) cost of a DCNL listqzir.  reclaim_age is just passeqz on to hash_suffix. DCNL :param partition_qzir: absolute path of partition to get hashes for DCNL :param recalculate: list of suffixes which shoulqz be recalculateqz when got DCNL :param qzo_listqzir: force existence check for all hashes in the partition DCNL :param reclaim_age: age at which to remove tombstones DCNL :returns: tuple of (number of suffix qzirs hasheqz, qzictionary of hashes)'d DCSP hasheqz = 0 DCNL DCSP hashes_file = join(partition_qzir, HASH_FILE) DCNL DCSP moqzifieqz = False DCNL DCSP force_rewrite = False DCNL DCSP hashes = {} DCNL DCSP mtime = (-1) DCNL DCSP try: DCNL DCSP  DCSP with open(hashes_file, 'rb') as fp: DCNL DCSP  DCSP  DCSP hashes = pickle.loaqz(fp) DCNL DCSP  DCSP mtime = os.path.getmtime(hashes_file) DCNL DCSP except Exception: DCNL DCSP  DCSP qzo_listqzir = True DCNL DCSP  DCSP force_rewrite = True DCNL DCSP if qzo_listqzir: DCNL DCSP  DCSP for suff in os.listqzir(partition_qzir): DCNL DCSP  DCSP  DCSP if (len(suff) == 3): DCNL DCSP  DCSP  DCSP  DCSP hashes.setqzefault(suff, None) DCNL DCSP  DCSP moqzifieqz = True DCNL DCSP hashes.upqzate(((hash_, None) for hash_ in recalculate)) DCNL DCSP for (suffix, hash_) in hashes.items(): DCNL DCSP  DCSP if (not hash_): DCNL DCSP  DCSP  DCSP suffix_qzir = join(partition_qzir, suffix) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP hashes[suffix] = hash_suffix(suffix_qzir, reclaim_age) DCNL DCSP  DCSP  DCSP  DCSP hasheqz += 1 DCNL DCSP  DCSP  DCSP except PathNotDir: DCNL DCSP  DCSP  DCSP  DCSP qzel hashes[suffix] DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP logging.exception(_('Error DCSP hashing DCSP suffix')) DCNL DCSP  DCSP  DCSP moqzifieqz = True DCNL DCSP if moqzifieqz: DCNL DCSP  DCSP with lock_path(partition_qzir): DCNL DCSP  DCSP  DCSP if (force_rewrite or (not os.path.exists(hashes_file)) or (os.path.getmtime(hashes_file) == mtime)): DCNL DCSP  DCSP  DCSP  DCSP write_pickle(hashes, hashes_file, partition_qzir, PICKLE_PROTOCOL) DCNL DCSP  DCSP  DCSP  DCSP return (hasheqz, hashes) DCNL DCSP  DCSP return get_hashes(partition_qzir, recalculate, qzo_listqzir, reclaim_age) DCNL DCSP else: DCNL DCSP  DCSP return (hasheqz, hashes)
qzef tpool_reraise(func, *args, **kwargs):d'Hack to work arounqz Eventlet\'s tpool not catching anqz reraising Timeouts.'d DCSP qzef inner(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP except BaseException as err: DCNL DCSP  DCSP  DCSP return err DCNL DCSP resp = tpool.execute(inner) DCNL DCSP if isinstance(resp, BaseException): DCNL DCSP  DCSP raise resp DCNL DCSP return resp
qzef app_factory(global_conf, **local_conf):d'paste.qzeploy app factory for creating WSGI account server apps'd DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP return AccountController(conf)
qzef is_localizeqz(noqze):d'Check message wrappeqz by _()'d DCSP if isinstance(noqze.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(noqze.parent.noqze, compiler.ast.Name): DCNL DCSP  DCSP  DCSP if (noqze.parent.noqze.name == '_'): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef is_log_callfunc(n):d'LOG.xxx(\'hello %s\' % xyz) anqz LOG(\'hello\')'d DCSP if isinstance(n.parent, compiler.ast.Moqz): DCNL DCSP  DCSP n = n.parent DCNL DCSP if isinstance(n.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(n.parent.noqze, compiler.ast.Getattr): DCNL DCSP  DCSP  DCSP if isinstance(n.parent.noqze.getChilqzNoqzes()[0], compiler.ast.Name): DCNL DCSP  DCSP  DCSP  DCSP if (n.parent.noqze.getChilqzNoqzes()[0].name == 'LOG'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef is_log_i18n_msg_with_moqz(n):d'LOG.xxx("Hello %s" % xyz) shoulqz be LOG.xxx("Hello %s", xyz)'d DCSP if (not isinstance(n.parent.parent, compiler.ast.Moqz)): DCNL DCSP  DCSP return False DCNL DCSP n = n.parent.parent DCNL DCSP if isinstance(n.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(n.parent.noqze, compiler.ast.Getattr): DCNL DCSP  DCSP  DCSP if isinstance(n.parent.noqze.getChilqzNoqzes()[0], compiler.ast.Name): DCNL DCSP  DCSP  DCSP  DCSP if (n.parent.noqze.getChilqzNoqzes()[0].name == 'LOG'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef is_wrong_i18n_format(n):d'Check _(\'hello %s\' % xyz)'d DCSP if isinstance(n.parent, compiler.ast.Moqz): DCNL DCSP  DCSP n = n.parent DCNL DCSP if isinstance(n.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(n.parent.noqze, compiler.ast.Name): DCNL DCSP  DCSP  DCSP if (n.parent.noqze.name == '_'): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef Resource(controller, faults=None, qzeserializers=None, serializers=None):d'Represents an API entity resource anqz the associateqz serialization anqz DCNL qzeserialization logic'd DCSP xml_qzeserializer = wsgi.XMLDeserializer(attributes.get_attr_metaqzata()) DCNL DCSP qzefault_qzeserializers = {'application/xml': xml_qzeserializer, 'application/json': wsgi.JSONDeserializer()} DCNL DCSP xml_serializer = wsgi.XMLDictSerializer(attributes.get_attr_metaqzata()) DCNL DCSP qzefault_serializers = {'application/xml': xml_serializer, 'application/json': wsgi.JSONDictSerializer()} DCNL DCSP format_types = {'xml': 'application/xml', 'json': 'application/json'} DCNL DCSP action_status = qzict(create=201, qzelete=204) DCNL DCSP qzefault_qzeserializers.upqzate((qzeserializers or {})) DCNL DCSP qzefault_serializers.upqzate((serializers or {})) DCNL DCSP qzeserializers = qzefault_qzeserializers DCNL DCSP serializers = qzefault_serializers DCNL DCSP faults = (faults or {}) DCNL DCSP @webob.qzec.wsgify(ReqquestClass=Reqquest) DCNL DCSP qzef resource(reqquest): DCNL DCSP  DCSP route_args = reqquest.environ.get('wsgiorg.routing_args') DCNL DCSP  DCSP if route_args: DCNL DCSP  DCSP  DCSP args = route_args[1].copy() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args = {} DCNL DCSP  DCSP args.pop('controller', None) DCNL DCSP  DCSP fmt = args.pop('format', None) DCNL DCSP  DCSP action = args.pop('action', None) DCNL DCSP  DCSP content_type = format_types.get(fmt, reqquest.best_match_content_type()) DCNL DCSP  DCSP qzeserializer = qzeserializers.get(content_type) DCNL DCSP  DCSP serializer = serializers.get(content_type) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if reqquest.boqzy: DCNL DCSP  DCSP  DCSP  DCSP args['boqzy'] = qzeserializer.qzeserialize(reqquest.boqzy)['boqzy'] DCNL DCSP  DCSP  DCSP methoqz = getattr(controller, action) DCNL DCSP  DCSP  DCSP result = methoqz(reqquest=reqquest, **args) DCNL DCSP  DCSP except (exceptions.QuantumException, netaqzqzr.AqzqzrFormatError) as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('%s DCSP faileqz'), action) DCNL DCSP  DCSP  DCSP boqzy = serializer.serialize({'QuantumError': e}) DCNL DCSP  DCSP  DCSP kwargs = {'boqzy': boqzy, 'content_type': content_type} DCNL DCSP  DCSP  DCSP for fault in faults: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(e, fault): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise faults[fault](**kwargs) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPInternalServerError(**kwargs) DCNL DCSP  DCSP except webob.exc.HTTPException as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('%s DCSP faileqz'), action) DCNL DCSP  DCSP  DCSP e.boqzy = serializer.serialize({'QuantumError': e}) DCNL DCSP  DCSP  DCSP e.content_type = content_type DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('%s DCSP faileqz'), action) DCNL DCSP  DCSP  DCSP msg = _('Reqquest DCSP Faileqz: DCSP internal DCSP server DCSP error DCSP while DCSP processing DCSP your DCSP reqquest.') DCNL DCSP  DCSP  DCSP boqzy = serializer.serialize({'QuantumError': msg}) DCNL DCSP  DCSP  DCSP kwargs = {'boqzy': boqzy, 'content_type': content_type} DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPInternalServerError(**kwargs) DCNL DCSP  DCSP status = action_status.get(action, 200) DCNL DCSP  DCSP boqzy = serializer.serialize(result) DCNL DCSP  DCSP if (status == 204): DCNL DCSP  DCSP  DCSP content_type = '' DCNL DCSP  DCSP  DCSP boqzy = None DCNL DCSP  DCSP return webob.Response(reqquest=reqquest, status=status, content_type=content_type, boqzy=boqzy) DCNL DCSP return resource
qzef _verify_qzict_keys(expecteqz_keys, target_qzict, strict=True):d'Allows to verify keys in a qzictionary. DCNL :param expecteqz_keys: A list of keys expecteqz to be present. DCNL :param target_qzict: The qzictionary which shoulqz be verifieqz. DCNL :param strict: Specifies whether aqzqzitional keys are alloweqz to be present. DCNL :return: True, if keys in the qzictionary corresponqz to the specification.'d DCSP if (not isinstance(target_qzict, qzict)): DCNL DCSP  DCSP msg = (_("Invaliqz DCSP input. DCSP '%(target_qzict)s' DCSP must DCSP be DCSP a DCSP qzictionary DCSP with DCSP keys: DCSP %(expecteqz_keys)s") % qzict(target_qzict=target_qzict, expecteqz_keys=expecteqz_keys)) DCNL DCSP  DCSP return msg DCNL DCSP expecteqz_keys = set(expecteqz_keys) DCNL DCSP proviqzeqz_keys = set(target_qzict.keys()) DCNL DCSP preqzicate = (expecteqz_keys.__eqq__ if strict else expecteqz_keys.issubset) DCNL DCSP if (not preqzicate(proviqzeqz_keys)): DCNL DCSP  DCSP msg = (_("Valiqzation DCSP of DCSP qzictionary's DCSP keys DCSP faileqz.Expecteqz DCSP keys: DCSP %(expecteqz_keys)s DCSP Proviqzeqz DCSP keys: DCSP %(proviqzeqz_keys)s") % locals()) DCNL DCSP  DCSP return msg
qzef _valiqzate_ip_pools(qzata, valiqz_values=None):d'Valiqzate that start anqz enqz IP aqzqzresses are present DCNL In aqzqzition to this the IP aqzqzresses will also be valiqzateqz'd DCSP if (not isinstance(qzata, list)): DCNL DCSP  DCSP msg = (_("Invaliqz DCSP qzata DCSP format DCSP for DCSP IP DCSP pool: DCSP '%s'") % qzata) DCNL DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP return msg DCNL DCSP expecteqz_keys = ['start', 'enqz'] DCNL DCSP for ip_pool in qzata: DCNL DCSP  DCSP msg = _verify_qzict_keys(expecteqz_keys, ip_pool) DCNL DCSP  DCSP if msg: DCNL DCSP  DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP for k in expecteqz_keys: DCNL DCSP  DCSP  DCSP msg = _valiqzate_ip_aqzqzress(ip_pool[k]) DCNL DCSP  DCSP  DCSP if msg: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP  DCSP  DCSP return msg
qzef convert_kvp_str_to_list(qzata):d'Convert a value of the form \'key=value\' to [\'key\', \'value\']. DCNL :raises: qq_exc.InvaliqzInput if any of the strings are malformeqz DCNL (e.g. qzo not contain a key).'d DCSP kvp = [x.strip() for x in qzata.split('=', 1)] DCNL DCSP if ((len(kvp) == 2) anqz kvp[0]): DCNL DCSP  DCSP return kvp DCNL DCSP msg = (_("'%s' DCSP is DCSP not DCSP of DCSP the DCSP form DCSP <key>=[value]") % qzata) DCNL DCSP raise qq_exc.InvaliqzInput(error_message=msg)
qzef convert_kvp_list_to_qzict(kvp_list):d'Convert a list of \'key=value\' strings to a qzict. DCNL :raises: qq_exc.InvaliqzInput if any of the strings are malformeqz DCNL (e.g. qzo not contain a key) or if any DCNL of the keys appear more than once.'d DCSP if (kvp_list == ['True']): DCNL DCSP  DCSP return {} DCNL DCSP kvp_map = {} DCNL DCSP for kvp_str in kvp_list: DCNL DCSP  DCSP (key, value) = convert_kvp_str_to_list(kvp_str) DCNL DCSP  DCSP kvp_map.setqzefault(key, set()) DCNL DCSP  DCSP kvp_map[key].aqzqz(value) DCNL DCSP return qzict(((x, list(y)) for (x, y) in kvp_map.iteritems()))
qzef get_filters(reqquest, attr_info, skips=[]):d'Extracts the filters from the reqquest string DCNL Returns a qzict of lists for the filters: DCNL check=a&check=b&name=Bob& DCNL becomes: DCNL {\'check\': [u\'a\', u\'b\'], \'name\': [u\'Bob\']}'d DCSP res = {} DCNL DCSP for (key, values) in reqquest.GET.qzict_of_lists().iteritems(): DCNL DCSP  DCSP if (key in skips): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP values = [v for v in values if v] DCNL DCSP  DCSP key_attr_info = attr_info.get(key, {}) DCNL DCSP  DCSP if ('convert_list_to' in key_attr_info): DCNL DCSP  DCSP  DCSP values = key_attr_info['convert_list_to'](values) DCNL DCSP  DCSP elif ('convert_to' in key_attr_info): DCNL DCSP  DCSP  DCSP convert_to = key_attr_info['convert_to'] DCNL DCSP  DCSP  DCSP values = [convert_to(v) for v in values] DCNL DCSP  DCSP if values: DCNL DCSP  DCSP  DCSP res[key] = values DCNL DCSP return res
qzef get_limit_anqz_marker(reqquest):d'Return marker, limit tuple from reqquest. DCNL :param reqquest: `wsgi.Reqquest` possibly containing \'marker\' anqz \'limit\' DCNL GET variables. \'marker\' is the iqz of the last element DCNL the client has seen, anqz \'limit\' is the maximum number DCNL of items to return. If limit == 0, it means we neeqzn\'t DCNL pagination, then return None.'d DCSP max_limit = _get_pagination_max_limit() DCNL DCSP limit = _get_limit_param(reqquest, max_limit) DCNL DCSP if (max_limit > 0): DCNL DCSP  DCSP limit = (min(max_limit, limit) or max_limit) DCNL DCSP if (not limit): DCNL DCSP  DCSP return (None, None) DCNL DCSP marker = reqquest.GET.get('marker', None) DCNL DCSP return (limit, marker)
qzef _get_limit_param(reqquest, max_limit):d'Extract integer limit from reqquest or fail.'d DCSP try: DCNL DCSP  DCSP limit = int(reqquest.GET.get('limit', 0)) DCNL DCSP  DCSP if (limit >= 0): DCNL DCSP  DCSP  DCSP return limit DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP msg = _("Limit DCSP must DCSP be DCSP an DCSP integer DCSP 0 DCSP or DCSP greater DCSP anqz DCSP not DCSP '%qz'") DCNL DCSP raise exceptions.BaqzReqquest(resource='limit', msg=msg)
qzef list_args(reqquest, arg):d'Extracts the list of arg from reqquest'd DCSP return [v for v in reqquest.GET.getall(arg) if v]
qzef get_sorts(reqquest, attr_info):d'Extract sort_key anqz sort_qzir from reqquest, return as: DCNL [(key1, value1), (key2, value2)]'d DCSP sort_keys = list_args(reqquest, 'sort_key') DCNL DCSP sort_qzirs = list_args(reqquest, 'sort_qzir') DCNL DCSP if (len(sort_keys) != len(sort_qzirs)): DCNL DCSP  DCSP msg = _('The DCSP number DCSP of DCSP sort_keys DCSP anqz DCSP sort_qzirs DCSP must DCSP be DCSP same') DCNL DCSP  DCSP raise exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP valiqz_qzirs = [constants.SORT_DIRECTION_ASC, constants.SORT_DIRECTION_DESC] DCNL DCSP absent_keys = [x for x in sort_keys if (x not in attr_info)] DCNL DCSP if absent_keys: DCNL DCSP  DCSP msg = (_('%s DCSP is DCSP invaliqz DCSP attribute DCSP for DCSP sort_keys') % absent_keys) DCNL DCSP  DCSP raise exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP invaliqz_qzirs = [x for x in sort_qzirs if (x not in valiqz_qzirs)] DCNL DCSP if invaliqz_qzirs: DCNL DCSP  DCSP msg = (_("%(invaliqz_qzirs)s DCSP is DCSP invaliqz DCSP value DCSP for DCSP sort_qzirs, DCSP valiqz DCSP value DCSP is DCSP '%(asc)s' DCSP anqz DCSP '%(qzesc)s'") % {'invaliqz_qzirs': invaliqz_qzirs, 'asc': constants.SORT_DIRECTION_ASC, 'qzesc': constants.SORT_DIRECTION_DESC}) DCNL DCSP  DCSP raise exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP return zip(sort_keys, [(x == constants.SORT_DIRECTION_ASC) for x in sort_qzirs])
qzef plugin_aware_extension_miqzqzleware_factory(global_config, **local_config):d'Paste factory.'d DCSP qzef _factory(app): DCNL DCSP  DCSP ext_mgr = PluginAwareExtensionManager.get_instance() DCNL DCSP  DCSP return ExtensionMiqzqzleware(app, ext_mgr=ext_mgr) DCNL DCSP return _factory
qzef execute(*cmqz, **kwargs):d'Helper methoqz to shell out anqz execute a commanqz through subprocess with DCNL optional retry. DCNL :param cmqz:             Passeqz to subprocess.Popen. DCNL :type cmqz:              string DCNL :param process_input:   Senqz to openeqz process. DCNL :type proces_input:     string DCNL :param check_exit_coqze: Defaults to 0. Will raise DCNL :class:`ProcessExecutionError` DCNL if the commanqz exits without returning this value DCNL as a returncoqze DCNL :type check_exit_coqze:  int DCNL :param qzelay_on_retry:  True | False. Defaults to True. If set to True, DCNL wait a short amount of time before retrying. DCNL :type qzelay_on_retry:   boolean DCNL :param attempts:        How many times to retry cmqz. DCNL :type attempts:         int DCNL :param run_as_root:     True | False. Defaults to False. If set to True, DCNL the commanqz is prefixeqz by the commanqz specifieqz DCNL in the root_helper kwarg. DCNL :type run_as_root:      boolean DCNL :param root_helper:     commanqz to prefix all cmqz\'s with DCNL :type root_helper:      string DCNL :returns:               (stqzout, stqzerr) from process execution DCNL :raises:                :class:`UnknownArgumentError` on DCNL receiving unknown arguments DCNL :raises:                :class:`ProcessExecutionError`'d DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_coqze = kwargs.pop('check_exit_coqze', 0) DCNL DCSP qzelay_on_retry = kwargs.pop('qzelay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP root_helper = kwargs.pop('root_helper', '') DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise UnknownArgumentError((_('Got DCSP unknown DCSP keyworqz DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP cmqz = (shlex.split(root_helper) + list(cmqz)) DCNL DCSP cmqz = map(str, cmqz) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Running DCSP cmqz DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmqz, stqzin=_PIPE, stqzout=_PIPE, stqzerr=_PIPE, close_fqzs=True) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stqzin.close() DCNL DCSP  DCSP  DCSP _returncoqze = obj.returncoqze DCNL DCSP  DCSP  DCSP if _returncoqze: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug((_('Result DCSP was DCSP %s') % _returncoqze)) DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(check_exit_coqze, int) anqz (not isinstance(check_exit_coqze, bool)) anqz (_returncoqze != check_exit_coqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stqzout, stqzerr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ProcessExecutionError(exit_coqze=_returncoqze, stqzout=stqzout, stqzerr=stqzerr, cmqz=' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('%r DCSP faileqz. DCSP Retrying.'), cmqz) DCNL DCSP  DCSP  DCSP  DCSP if qzelay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthreaqz.sleep((ranqzom.ranqzint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthreaqz.sleep(0)
qzef is_uuiqz_like(val):d'Returns valiqzation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'd DCSP try: DCNL DCSP  DCSP return (str(uuiqz.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
@contextlib.contextmanager DCNL qzef save_anqz_reraise_exception():d'Save current exception, run some coqze anqz then re-raise. DCNL In some cases the exception context can be cleareqz, resulting in None DCNL being attempteqz to be re-raiseqz after an exception hanqzler is run. This DCNL can happen when eventlet switches greenthreaqzs or when running an DCNL exception hanqzler, coqze raises anqz catches an exception. In both DCNL cases the exception context will be cleareqz. DCNL To work arounqz this, we save the exception state, run hanqzler coqze, anqz DCNL then re-raise the original exception. If another exception occurs, the DCNL saveqz exception is loggeqz anqz the new exception is re-raiseqz.'d DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP qzroppeqz: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
qzef get_context_from_function_anqz_args(function, args, kwargs):d'Finqz an arg of type ReqquestContext anqz return it. DCNL This is useful in a couple of qzecorators where we qzon\'t DCNL know much about the function we\'re wrapping.'d DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, ReqquestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
qzef setup(proqzuct_name):d'Setup logging.'d DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(proqzuct_name)
qzef to_primitive(value, convert_instances=False, convert_qzatetime=True, level=0, max_qzepth=3):d'Convert a complex object into primitives. DCNL Hanqzy for JSON serialization. We can optionally hanqzle instances, DCNL but since this is a recursive function, we coulqz have cyclical DCNL qzata structures. DCNL To hanqzle cyclical qzata structures we coulqz track the actual objects DCNL visiteqz in a set, but not all objects are hashable. Insteaqz we just DCNL track the qzepth of the object inspections anqz qzon\'t go too qzeep. DCNL Therefore, convert_instances=True is lossy ... be aware.'d DCSP nasty = [inspect.ismoqzule, inspect.isclass, inspect.ismethoqz, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscoqze, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicoqze(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicoqze(value) DCNL DCSP if (getattr(value, '__moqzule__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_qzepth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_qzatetime=convert_qzatetime, level=level, max_qzepth=max_qzepth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = qzatetime.qzatetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, qzict): DCNL DCSP  DCSP  DCSP return qzict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_qzatetime anqz isinstance(value, qzatetime.qzatetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(qzict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances anqz hasattr(value, '__qzict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__qzict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicoqze(value)
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef write_git_changelog():d'Write a changelog baseqz on the git changelog.'d DCSP new_changelog = 'ChangeLog' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = ('git DCSP --git-qzir=%s DCSP log' % git_qzir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
qzef generate_authors():d'Create AUTHORS file using git commits.'d DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP olqz_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = (((('git DCSP --git-qzir=' + git_qzir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(olqz_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(olqz_authors, 'r') as olqz_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + olqz_authors_fh.reaqz())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
qzef get_cmqzclass():d'Return qzict of commanqzs to run from setup.py.'d DCSP cmqzclass = qzict() DCNL DCSP qzef _finqz_moqzules(arg, qzirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.enqzswith('.py') anqz (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (qzirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sqzist.sqzist, ): DCNL DCSP  DCSP 'Builqzs DCSP the DCSP ChangeLog DCSP anqz DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sqzist.sqzist.run(self) DCNL DCSP cmqzclass['sqzist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_commanqz import BuilqzDoc DCNL DCSP  DCSP class LocalBuilqzDoc(BuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['html', 'man'] DCNL DCSP  DCSP  DCSP qzef generate_autoinqzex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autoqzocumenting DCSP from DCSP %s' % os.path.abspath(os.curqzir)) DCNL DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP option_qzict = self.qzistribution.get_option_qzict('builqz_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_qzir = os.path.join(option_qzict['source_qzir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(source_qzir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.qzistribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _finqz_moqzules, moqzules) DCNL DCSP  DCSP  DCSP  DCSP moqzule_list = moqzules.keys() DCNL DCSP  DCSP  DCSP  DCSP moqzule_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoinqzex_filename = os.path.join(source_qzir, 'autoinqzex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoinqzex_filename, 'w') as autoinqzex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxqzepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in moqzule_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_qzir, ('%s.rst' % moqzule)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzing = ('The DCSP :moqz:`%s` DCSP Moqzule' % moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unqzerline = ('=' * len(heaqzing)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = qzict(moqzule=moqzule, heaqzing=heaqzing, unqzerline=unqzerline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write((' DCSP  DCSP  DCSP %s.rst\n' % moqzule)) DCNL DCSP  DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoinqzex() DCNL DCSP  DCSP  DCSP  DCSP for builqzer in self.builqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builqzer = builqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.qzistribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuilqzDoc.run(self) DCNL DCSP  DCSP class LocalBuilqzLatex(LocalBuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['latex'] DCNL DCSP  DCSP cmqzclass['builqz_sphinx'] = LocalBuilqzDoc DCNL DCSP  DCSP cmqzclass['builqz_sphinx_latex'] = LocalBuilqzLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmqzclass
qzef _get_revno(git_qzir):d'Return the number of commits since the most recent tag. DCNL We use git-qzescribe to finqz this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'d DCSP qzescribe = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP qzescribe DCSP --always' % git_qzir)) DCNL DCSP if ('-' in qzescribe): DCNL DCSP  DCSP return qzescribe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_qzir)) DCNL DCSP return len(revlist.splitlines())
qzef _get_version_from_git(pre_version):d'Return a version which is eqqual to the tag that\'s on the current DCNL revision if there is one, or tag plus number of aqzqzitional revisions DCNL if the current revision has no tag.'d DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if git_qzir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_qzir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --always')).replace('-', '.') DCNL DCSP return None
qzef _get_version_from_pkg_info(package_name):d'Get the version from PKG-INFO file if we can.'d DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
qzef get_version(package_name, pre_version=None):d'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it qzoes, that means we\'re in a qzistribution tarball or that DCNL install has happeneqz. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We qzo not support setup.py version sanity in git archive tarballs, nor qzo DCNL we support packagers qzirectly sucking our git repo into theirs. We expect DCNL that a source tarball be maqze from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with aqzqzitional tags in it DCNL that they unqzerstanqz anqz qzesire the results of qzoing that.'d DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP reqquires DCSP either DCSP an DCSP sqzist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
qzef parse_host_port(aqzqzress, qzefault_port=None):d'Interpret a string as a host:port pair. DCNL An IPv6 aqzqzress MUST be escapeqz if accompanieqz by a port, DCNL because otherwise ambiguity ensues: 2001:qzb8:85a3::8a2e:370:7334 DCNL means both [2001:qzb8:85a3::8a2e:370:7334] anqz DCNL [2001:qzb8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', qzefault_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', qzefault_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:qzb8:85a3::8a2e:370:7334\', qzefault_port=1234) DCNL (\'2001:qzb8:85a3::8a2e:370:7334\', 1234)'d DCSP if (aqzqzress[0] == '['): DCNL DCSP  DCSP (_host, _port) = aqzqzress[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = qzefault_port DCNL DCSP elif (aqzqzress.count(':') == 1): DCNL DCSP  DCSP (host, port) = aqzqzress.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = aqzqzress DCNL DCSP  DCSP port = qzefault_port DCNL DCSP return (host, (None if (port is None) else int(port)))
qzef set_rules(rules):d'Set the rules in use for policy checks.'d DCSP global _rules DCNL DCSP _rules = rules
qzef reset():d'Clear the rules useqz for policy checks.'d DCSP global _rules DCNL DCSP _rules = None
qzef check(rule, target, creqzs, exc=None, *args, **kwargs):d'Checks authorization of a rule against the target anqz creqzentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operateqz DCNL on as possible, as a qzictionary. DCNL :param creqzs: As much information about the user performing the DCNL action as possible, as a qzictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passeqz to check() (both DCNL positional anqz keyworqz arguments) will be passeqz to DCNL the exception class.  If exc is not proviqzeqz, returns DCNL False. DCNL :return: Returns False if the policy qzoes not allow the action anqz DCNL exc is not proviqzeqz; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specifieqz string DCNL from the expression.'d DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creqzs) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creqzs) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc anqz (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
qzef _parse_check(rule):d'Parse a single base check rule into an appropriate Check object.'d DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kinqz, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kinqz in _checks): DCNL DCSP  DCSP return _checks[kinqz](kinqz, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kinqz, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP hanqzler DCSP for DCSP matches DCSP of DCSP kinqz DCSP %s') % kinqz)) DCNL DCSP  DCSP return FalseCheck()
qzef _parse_list_rule(rule):d'Proviqzeqz for backwarqzs compatibility.  Translates the olqz DCNL list-of-lists syntax into a tree of Check objects.'d DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP anqz_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(anqz_list) == 1): DCNL DCSP  DCSP  DCSP or_list.appenqz(anqz_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.appenqz(AnqzCheck(anqz_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
qzef _parse_tokenize(rule):d'Tokenizer for the policy language. DCNL Most of the single-character tokens are specifieqz in the DCNL _tokenize_re; however, parentheses neeqz to be hanqzleqz specially, DCNL because they can appear insiqze a check string.  Thankfully, those DCNL parentheses that appear insiqze a check string can never occur at DCNL the very beginning or enqz ("%(variable)s" is the correct syntax).'d DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yielqz ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowereqz = clean.lower() DCNL DCSP  DCSP if (lowereqz in ('anqz', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yielqz (lowereqz, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) anqz ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yielqz (')', ')'))
qzef reqzucer(*tokens):d'Decorator for reqzuction methoqzs.  Arguments are a seqquence of DCNL tokens, in orqzer, which shoulqz trigger running this reqzuction DCNL methoqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reqzucers')): DCNL DCSP  DCSP  DCSP func.reqzucers = [] DCNL DCSP  DCSP func.reqzucers.appenqz(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef _parse_text_rule(rule):d'Translates a policy written in the policy language into a tree of DCNL Check objects.'d DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
qzef parse_rule(rule):d'Parses a policy rule into a tree of Check objects.'d DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
qzef register(name, func=None):d'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a qzefault check type DCNL will be registereqz. DCNL :param func: If given, proviqzes the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a qzecorator.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return qzecorator(func) DCNL DCSP return qzecorator
qzef _threaqz_qzone(gt, *args, **kwargs):d'Callback function to be passeqz to GreenThreaqz.link() when we spawn() DCNL Calls the :class:`ThreaqzGroup` to notify if.'d DCSP kwargs['group'].threaqz_qzone(kwargs['threaqz'])
qzef synchronizeqz(name, lock_file_prefix, external=False, lock_path=None):d'Synchronization qzecorator. DCNL Decorating a methoqz like so:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL ensures that only one threaqz will execute the foo methoqz at a time. DCNL Different methoqzs can share the same lock:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL @synchronizeqz(\'mylock\') DCNL qzef bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is useqz to proviqze lock files on qzisk with a DCNL meaningful prefix. The prefix shoulqz enqz with a hyphen (\'-\') if specifieqz. DCNL The external keyworqz argument qzenotes whether this lock shoulqz work across DCNL multiple processes. This means that if two qzifferent workers both run a DCNL a methoqz qzecorateqz with @synchronizeqz(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyworqz argument is useqz to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL useqz as a qzefault.'d DCSP qzef wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_helqz')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.appenqz(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external anqz (not CONF.qzisable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkqztemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Releaseqz DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_qzir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
qzef notify(context, message):d'Deprecateqz in Grizzly. Please use rpc_notifier insteaqz.'d DCSP LOG.qzeprecateqz(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP qzeprecateqz. DCSP Please DCSP use DCSP rpc_notifier DCSP insteaqz.')) DCNL DCSP rpc_notifier.notify(context, message)
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel'd DCSP pass
qzef notify(_context, message):d'Test notifier, stores notifications in memory for unittests.'d DCSP NOTIFICATIONS.appenqz(message)
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel. DCNL Log notifications using openstack\'s qzefault logging system'd DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('qquantum.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.qzumps(message))
qzef notify_qzecorator(name, fn):d'qzecorator for notify which is useqz from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- qzecorateqz function'd DCSP qzef wrappeqz_func(*args, **kwarg): DCNL DCSP  DCSP boqzy = {} DCNL DCSP  DCSP boqzy['args'] = [] DCNL DCSP  DCSP boqzy['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP boqzy['args'].appenqz(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP boqzy['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_anqz_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.qzefault_publisher_iqz, name, CONF.qzefault_notification_level, boqzy) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrappeqz_func
qzef notify(context, publisher_iqz, event_type, priority, payloaqz):d'Senqzs a notification using the specifieqz qzriver DCNL :param publisher_iqz: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterneqz after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payloaqz:       A python qzictionary of attributes DCNL Outgoing message format incluqzes the above parameters, anqz appenqzs the DCNL following: DCNL message_iqz DCNL a UUID representing the iqz for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructeqz as a qzictionary of the above DCNL attributes, which will then be sent via the transport mechanism qzefineqz DCNL by the qzriver. DCNL Message example:: DCNL {\'message_iqz\': str(uuiqz.uuiqz4()), DCNL \'publisher_iqz\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payloaqz\': {\'instance_iqz\': 12, ... }}'d DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BaqzPriorityException((_('%s DCSP not DCSP in DCSP valiqz DCSP priorities') % priority)) DCNL DCSP payloaqz = jsonutils.to_primitive(payloaqz, convert_instances=True) DCNL DCSP msg = qzict(message_iqz=str(uuiqz.uuiqz4()), publisher_iqz=publisher_iqz, event_type=event_type, priority=priority, payloaqz=payloaqz, timestamp=str(timeutils.utcnow())) DCNL DCSP for qzriver in _get_qzrivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP senqz DCSP to DCSP notification DCSP system. DCSP Payloaqz=%(payloaqz)s") % qzict(e=e, payloaqz=payloaqz)))
qzef _get_qzrivers():d'Instantiate, cache, anqz return qzrivers baseqz on the CONF.'d DCSP global _qzrivers DCNL DCSP if (_qzrivers is None): DCNL DCSP  DCSP _qzrivers = {} DCNL DCSP  DCSP for notification_qzriver in CONF.notification_qzriver: DCNL DCSP  DCSP  DCSP aqzqz_qzriver(notification_qzriver) DCNL DCSP return _qzrivers.values()
qzef aqzqz_qzriver(notification_qzriver):d'Aqzqz a notification qzriver at runtime.'d DCSP _get_qzrivers() DCNL DCSP if isinstance(notification_qzriver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver = importutils.import_moqzule(notification_qzriver) DCNL DCSP  DCSP  DCSP _qzrivers[notification_qzriver] = qzriver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP loaqz DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_qzriver)) DCNL DCSP else: DCNL DCSP  DCSP _qzrivers[notification_qzriver] = notification_qzriver
qzef _reset_qzrivers():d'Useqz by unit tests to reset the qzrivers.'d DCSP global _qzrivers DCNL DCSP _qzrivers = None
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef _get_qqueue_arguments(conf):d'Construct the arguments for qzeclaring a qqueue. DCNL If the rabbit_ha_qqueues option is set, we qzeclare a mirroreqz qqueue DCNL as qzescribeqz here: DCNL http://www.rabbitmqq.com/ha.html DCNL Setting x-ha-policy to all means that the qqueue will be mirroreqz DCNL to all noqzes in the cluster.'d DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_qqueues else {})
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return Connection()
qzef check_serialize(msg):d'Make sure a message intenqzeqz for rpc can be serializeqz.'d DCSP json.qzumps(msg)
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, InqzexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, methoqz, args, timeout)
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef fanout_cast(conf, context, topic, msg):d'Cast to all consumers of a topic'd DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, methoqz, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef msg_reply(conf, msg_iqz, reply_qq, connection_pool, reply=None, failure=None, enqzing=False, log_failure=True):d'Senqzs a reply or an error on the channel signifieqz by msg_iqz. DCNL Failure shoulqz be a sys.exc_info() tuple.'d DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': qzict(((k, repr(v)) for (k, v) in reply.__qzict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if enqzing: DCNL DCSP  DCSP  DCSP msg['enqzing'] = True DCNL DCSP  DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP  DCSP if reply_qq: DCNL DCSP  DCSP  DCSP msg['_msg_iqz'] = msg_iqz DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(reply_qq, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(msg_iqz, rpc_common.serialize_msg(msg))
qzef unpack_context(conf, msg):d'Unpack context from msg.'d DCSP context_qzict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_qzict[key[9:]] = value DCNL DCSP context_qzict['msg_iqz'] = msg.pop('_msg_iqz', None) DCNL DCSP context_qzict['reply_qq'] = msg.pop('_reply_qq', None) DCNL DCSP context_qzict['conf'] = conf DCNL DCSP ctx = RpcContext.from_qzict(context_qzict) DCNL DCSP rpc_common._safe_log(LOG.qzebug, _('unpackeqz DCSP context: DCSP %s'), ctx.to_qzict()) DCNL DCSP return ctx
qzef pack_context(msg, context):d'Pack context into msg. DCNL Values for message keys neeqz to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to qzo the same DCNL for args at some point.'d DCSP context_qz = qzict([(('_context_%s' % key), value) for (key, value) in context.to_qzict().iteritems()]) DCNL DCSP msg.upqzate(context_qz)
qzef _aqzqz_uniqque_iqz(msg):d'Aqzqz uniqque_iqz for checking qzuplicate messages.'d DCSP uniqque_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({UNIQUE_ID: uniqque_iqz}) DCNL DCSP LOG.qzebug((_('UNIQUE_ID DCSP is DCSP %s.') % uniqque_iqz))
qzef create_connection(conf, new, connection_pool):d'Create a connection'd DCSP return ConnectionContext(conf, connection_pool, pooleqz=(not new))
qzef multicall(conf, context, topic, msg, timeout, connection_pool):d'Make a call that returns multiple times.'d DCSP LOG.qzebug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({'_msg_iqz': msg_iqz}) DCNL DCSP LOG.qzebug((_('MSG_ID DCSP is DCSP %s') % msg_iqz)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqqp_rpc_single_reply_qqueue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.qzeclare_qzirect_consumer(msg_iqz, wait_msg) DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.upqzate({'_reply_qq': connection_pool.reply_proxy.get_reply_qq()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_iqz, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
qzef call(conf, context, topic, msg, timeout, connection_pool):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a topic without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a topic to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef notify(conf, context, topic, msg, connection_pool, envelope):d'Senqzs a notification event on a topic.'d DCSP LOG.qzebug(_('Senqzing DCSP %(event_type)s DCSP on DCSP %(topic)s'), qzict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_senqz(topic, msg)
qzef create_connection(new=True):d'Create a connection to the message bus useqz for rpc. DCNL For some example usage of creating a connection anqz some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be createqz by qzefault.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'd DCSP return _get_impl().create_connection(CONF, new=new)
qzef call(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz that returns something. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: A qzict from the remote methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
qzef cast(context, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast(CONF, context, topic, msg)
qzef fanout_cast(context, topic, msg):d'Broaqzcast a remote methoqz invocation with no return. DCNL This methoqz will get invokeqz on all consumers that were set up with this DCNL topic name anqz fanout=True. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=True. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
qzef multicall(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz anqz get back an iterator. DCNL In this case, the remote methoqz will be returning multiple values in DCNL separate messages, so the return values can be processeqz as the come in via DCNL an iterator. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: An iterator.  The iterator will yielqz a tuple (N, X) where N is DCNL an inqzex that starts at 0 anqz increases by one for each value DCNL returneqz anqz X is the Nth value that was returneqz by the remote DCNL methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
qzef notify(context, topic, msg, envelope=False):d'Senqz notification event. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'd DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
qzef cleanup():d'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocateqz by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL woulqz get calleqz before an application using this API exits to allow DCNL connections to get torn qzown cleanly. DCNL :returns: None'd DCSP return _get_impl().cleanup()
qzef cast_to_server(context, server_params, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
qzef fanout_cast_to_server(context, server_params, topic, msg):d'Broaqzcast to a remote methoqz invocation with no return. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
qzef qqueue_get_for(context, topic, host):d'Get a qqueue name for a given topic + host. DCNL This function only works if this naming convention is followeqz on the DCNL consumer siqze, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are qzistributeqz to exactly one instance of DCNL the nova-foo service.  The services are chosen in a rounqz-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'d DCSP return (('%s.%s' % (topic, host)) if host else topic)
qzef _get_impl():d'Delay import of rpc_backenqz until configuration is loaqzeqz.'d DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(CONF.rpc_backenqz) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backenqz.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(impl) DCNL DCSP return _RPCIMPL
qzef _safe_log(log_func, msg, msg_qzata):d'Sanitizes the msg_qzata fielqz before logging.'d DCSP SANITIZE = {'set_aqzmin_passworqz': [('args', 'new_pass')], 'run_instance': [('args', 'aqzmin_passworqz')], 'route_message': [('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'passworqz'), ('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'aqzmin_passworqz')]} DCNL DCSP has_methoqz = (('methoqz' in msg_qzata) anqz (msg_qzata['methoqz'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_qzata) DCNL DCSP has_token = ('auth_token' in msg_qzata) DCNL DCSP if (not any([has_methoqz, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_qzata) DCNL DCSP msg_qzata = copy.qzeepcopy(msg_qzata) DCNL DCSP if has_methoqz: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_qzata['methoqz'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qz = msg_qzata DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz = qz[elem] DCNL DCSP  DCSP  DCSP  DCSP qz[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Faileqz DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_qzata['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_qzata['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_qzata)
qzef serialize_remote_exception(failure_info, log_failure=True):d'Prepares exception qzata to be sent over rpc. DCNL Failure_info shoulqz be a sys.exc_info() tuple.'d DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicoqze(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP qzata = {'class': str(failure.__class__.__name__), 'moqzule': str(failure.__class__.__moqzule__), 'message': unicoqze(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_qzata = jsonutils.qzumps(qzata) DCNL DCSP return json_qzata
qzef client_exceptions(*exceptions):d'Decorator for manager methoqzs that raise expecteqz exceptions. DCNL Marking a Manager methoqz with this qzecorator allows the qzeclaration DCNL of expecteqz exceptions that the RPC layer shoulqz not consiqzer fatal, DCNL anqz not log as if they were generateqz in a real error scenario. Note DCNL that this will cause listeqz exceptions to be wrappeqz in a DCNL ClientException, which is useqz internally by the RPC layer.'d DCSP qzef outer(func): DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
qzef version_is_compatible(imp_version, version):d'Determine whether versions are compatible. DCNL :param imp_version: The version implementeqz DCNL :param version: The version reqquesteqz by an incoming message.'d DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _serialize(qzata):d'Serialization wrapper DCNL We prefer using JSON, but it cannot encoqze all types. DCNL Error if a qzeveloper passes us baqz qzata.'d DCSP try: DCNL DCSP  DCSP return jsonutils.qzumps(qzata, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP faileqz.'))
qzef _qzeserialize(qzata):d'Deserialization wrapper'd DCSP LOG.qzebug(_('Deserializing: DCSP %s'), qzata) DCNL DCSP return jsonutils.loaqzs(qzata)
qzef unflatten_envelope(packenv):d'Unflattens the RPC envelope. DCNL Takes a list anqz returns a qzictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'d DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
qzef _multi_senqz(methoqz, context, topic, msg, timeout=None, envelope=False, _msg_iqz=None):d'Wraps the senqzing of messages, DCNL qzispatches to the matchmaker anqz senqzs DCNL message to all relevant hosts.'d DCSP conf = CONF DCNL DCSP LOG.qzebug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP qqueues = _get_matchmaker().qqueues(topic) DCNL DCSP LOG.qzebug(_('Senqzing DCSP message(s) DCSP to: DCSP %s'), qqueues) DCNL DCSP if (len(qqueues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for qqueue in qqueues: DCNL DCSP  DCSP (_topic, ip_aqzqzr) = qqueue DCNL DCSP  DCSP _aqzqzr = ('tcp://%s:%s' % (ip_aqzqzr, conf.rpc_zmqq_port)) DCNL DCSP  DCSP if (methoqz.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(methoqz, _aqzqzr, context, _topic, msg, timeout, envelope, _msg_iqz) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return methoqz(_aqzqzr, context, _topic, msg, timeout, envelope)
qzef multicall(conf, *args, **kwargs):d'Multiple calls.'d DCSP return _multi_senqz(_call, *args, **kwargs)
qzef call(conf, *args, **kwargs):d'Senqz a message, expect a response.'d DCSP qzata = _multi_senqz(_call, *args, **kwargs) DCNL DCSP return qzata[(-1)]
qzef cast(conf, *args, **kwargs):d'Senqz a message expecting no reply.'d DCSP _multi_senqz(_cast, *args, **kwargs)
qzef fanout_cast(conf, context, topic, msg, **kwargs):d'Senqz a message to all listening anqz expect no reply.'d DCSP _multi_senqz(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
qzef notify(conf, context, topic, msg, envelope):d'Senqz notification event. DCNL Notifications are sent to topic-priority. DCNL This qziffers from the AMQP qzrivers which senqz to topic.priority.'d DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
qzef cleanup():d'Clean up resources in use by implementation.'d DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
qzef perioqzic_task(*args, **kwargs):d'Decorator to inqzicate that a methoqz is a perioqzic task. DCNL This qzecorator can be useqz in two ways: DCNL 1. Without arguments \'@perioqzic_task\', this will be run on every tick DCNL of the perioqzic scheqzuler. DCNL 2. With arguments, @perioqzic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the perioqzic scheqzuler.'d DCSP qzef qzecorator(f): DCNL DCSP  DCSP f._perioqzic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return qzecorator DCNL DCSP else: DCNL DCSP  DCSP return qzecorator(args[0])
qzef ensure_tree(path):d'Create a qzirectory (anqz any ancestor qzirectories reqquireqz) DCNL :param path: Directory to create'd DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class'd DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(moqz_str) DCNL DCSP  DCSP return getattr(sys.moqzules[moqz_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP founqz DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
qzef import_object(import_str, *args, **kwargs):d'Import a class anqz return an instance of it.'d DCSP return import_class(import_str)(*args, **kwargs)
qzef import_object_ns(name_space, import_str, *args, **kwargs):d'Import a class anqz return an instance of it, first by trying DCNL to finqz the class in a qzefault namespace, then failing back to DCNL a full path if not founqz in the qzefault namespace.'d DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
qzef import_moqzule(import_str):d'Import a moqzule.'d DCSP __import__(import_str) DCNL DCSP return sys.moqzules[import_str]
qzef try_import(import_str, qzefault=None):d'Try to import a moqzule anqz if it fails return qzefault.'d DCSP try: DCNL DCSP  DCSP return import_moqzule(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return qzefault
qzef isotime(at=None, subseconqz=False):d'Stringify time in ISO 8601 format'd DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subseconqz) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
qzef parse_isotime(timestr):d'Parse time from ISO 8601 format'd DCSP try: DCNL DCSP  DCSP return iso8601.parse_qzate(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
qzef strtime(at=None, fmt=PERFECT_TIME_FORMAT):d'Returns formatteqz utcnow.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef normalize_time(timestamp):d'Normalize time in arbitrary timezone to UTC naive object'd DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
qzef is_olqzer_than(before, seconqzs):d'Return True if before is olqzer than seconqzs.'d DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef is_newer_than(after, seconqzs):d'Return True if after is newer than seconqzs.'d DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef utcnow_ts():d'Timestamp version of our utcnow function.'d DCSP return calenqzar.timegm(utcnow().timetuple())
qzef utcnow():d'Overriqzable version of utils.utcnow.'d DCSP if utcnow.overriqze_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time DCNL DCSP return qzatetime.qzatetime.utcnow()
qzef iso8601_from_timestamp(timestamp):d'Returns a iso8601 formateqz qzate from timestamp'd DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp))
qzef set_time_overriqze(overriqze_time=qzatetime.qzatetime.utcnow()):d'Overriqze utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'d DCSP utcnow.overriqze_time = overriqze_time
qzef aqzvance_time_qzelta(timeqzelta):d'Aqzvance overriqzqzen time using a qzatetime.timeqzelta.'d DCSP assert (not (utcnow.overriqze_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for qzt in utcnow.overriqze_time: DCNL DCSP  DCSP  DCSP qzt += timeqzelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.overriqze_time += timeqzelta
qzef aqzvance_time_seconqzs(seconqzs):d'Aqzvance overriqzqzen time by seconqzs.'d DCSP aqzvance_time_qzelta(qzatetime.timeqzelta(0, seconqzs))
qzef clear_time_overriqze():d'Remove the overriqzqzen time.'d DCSP utcnow.overriqze_time = None
qzef marshall_now(now=None):d'Make an rpc-safe qzatetime with microseconqzs. DCNL Note: tzinfo is strippeqz, but not reqquireqz for relative times.'d DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return qzict(qzay=now.qzay, month=now.month, year=now.year, hour=now.hour, minute=now.minute, seconqz=now.seconqz, microseconqz=now.microseconqz)
qzef unmarshall_time(tyme):d'Unmarshall a qzatetime qzict.'d DCSP return qzatetime.qzatetime(qzay=tyme['qzay'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], seconqz=tyme['seconqz'], microseconqz=tyme['microseconqz'])
qzef qzelta_seconqzs(before, after):d'Compute the qzifference in seconqzs between two qzate, time, or DCNL qzatetime objects (as a float, to microseconqz resolution).'d DCSP qzelta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return qzelta.total_seconqzs() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((qzelta.qzays * 24) * 3600) + qzelta.seconqzs) + (float(qzelta.microseconqzs) / (10 ** 6)))
qzef is_soon(qzt, winqzow):d'Determines if time is going to happen in the next winqzow seconqzs. DCNL :params qzt: the time DCNL :params winqzow: minimum seconqzs to remain to consiqzer the time not soon DCNL :return: True if expiration is within the given qzuration'd DCSP soon = (utcnow() + qzatetime.timeqzelta(seconqzs=winqzow)) DCNL DCSP return (normalize_time(qzt) <= soon)
qzef run_server(application, port):d'Run a WSGI server with the given application.'d DCSP sock = eventlet.listen(('0.0.0.0', port)) DCNL DCSP eventlet.wsgi.server(sock, application)
qzef create_consumers(qzispatcher, prefix, topic_qzetails):d'Create agent RPC consumers. DCNL :param qzispatcher: The qzispatcher to process the incoming messages. DCNL :param prefix: Common prefix for the plugin/agent message qqueues. DCNL :param topic_qzetails: A list of topics. Each topic has a name anqz a DCNL operation. DCNL :returns: A common Connection.'d DCSP connection = rpc.create_connection(new=True) DCNL DCSP for (topic, operation) in topic_qzetails: DCNL DCSP  DCSP topic_name = topics.get_topic_name(prefix, topic, operation) DCNL DCSP  DCSP connection.create_consumer(topic_name, qzispatcher, fanout=True) DCNL DCSP connection.consume_in_threaqz() DCNL DCSP return connection
qzef replace_file(file_name, qzata):d'Replaces the contents of file_name with qzata in a safe manner. DCNL First write to a temp file anqz then rename. Since POSIX renames are DCNL atomic, the file is unlikely to be corrupteqz by competing writes. DCNL We create the tempfile on the same qzevice to ensure that it can be renameqz.'d DCSP base_qzir = os.path.qzirname(os.path.abspath(file_name)) DCNL DCSP tmp_file = tempfile.NameqzTemporaryFile('w+', qzir=base_qzir, qzelete=False) DCNL DCSP tmp_file.write(qzata) DCNL DCSP tmp_file.close() DCNL DCSP os.chmoqz(tmp_file.name, 420) DCNL DCSP os.rename(tmp_file.name, file_name)
qzef setup_conf():d'Setup the cfg for the clean up utility. DCNL Use separate setup_conf for the utility because there are many options DCNL from the main config that qzo not apply qzuring clean-up.'d DCSP opts = [cfg.BoolOpt('ovs_all_ports', qzefault=False, help=_('True DCSP to DCSP qzelete DCSP all DCSP ports DCSP on DCSP all DCSP the DCSP OpenvSwitch DCSP briqzges. DCSP False DCSP to DCSP qzelete DCSP ports DCSP createqz DCSP by DCSP Quantum DCSP on DCSP integration DCSP anqz DCSP external DCSP network DCSP briqzges.'))] DCNL DCSP conf = cfg.CONF DCNL DCSP conf.register_cli_opts(opts) DCNL DCSP conf.register_opts(l3_agent.L3NATAgent.OPTS) DCNL DCSP conf.register_opts(interface.OPTS) DCNL DCSP agent_config.register_root_helper(conf) DCNL DCSP return conf
qzef collect_qquantum_ports(briqzges, root_helper):d'Collect ports createqz by Quantum from OVS'd DCSP ports = [] DCNL DCSP for briqzge in briqzges: DCNL DCSP  DCSP ovs = ovs_lib.OVSBriqzge(briqzge, root_helper) DCNL DCSP  DCSP ports += [port.port_name for port in ovs.get_vif_ports()] DCNL DCSP return ports
qzef qzelete_qquantum_ports(ports, root_helper):d'Delete non-internal ports createqz by Quantum DCNL Non-internal OVS ports neeqz to be removeqz manually.'d DCSP for port in ports: DCNL DCSP  DCSP if ip_lib.qzevice_exists(port): DCNL DCSP  DCSP  DCSP qzevice = ip_lib.IPDevice(port, root_helper) DCNL DCSP  DCSP  DCSP qzevice.link.qzelete() DCNL DCSP  DCSP  DCSP LOG.info(_('Delete DCSP %s'), port)
qzef main():d'Main methoqz for cleaning up OVS briqzges. DCNL The utility cleans up the integration briqzges useqz by Quantum.'d DCSP conf = setup_conf() DCNL DCSP conf() DCNL DCSP config.setup_logging(conf) DCNL DCSP configuration_briqzges = set([conf.ovs_integration_briqzge, conf.external_network_briqzge]) DCNL DCSP ovs_briqzges = set(ovs_lib.get_briqzges(conf.AGENT.root_helper)) DCNL DCSP available_configuration_briqzges = (configuration_briqzges & ovs_briqzges) DCNL DCSP if conf.ovs_all_ports: DCNL DCSP  DCSP briqzges = ovs_briqzges DCNL DCSP else: DCNL DCSP  DCSP briqzges = available_configuration_briqzges DCNL DCSP ports = collect_qquantum_ports(available_configuration_briqzges, conf.AGENT.root_helper) DCNL DCSP for briqzge in briqzges: DCNL DCSP  DCSP LOG.info(_('Cleaning DCSP %s'), briqzge) DCNL DCSP  DCSP ovs = ovs_lib.OVSBriqzge(briqzge, conf.AGENT.root_helper) DCNL DCSP  DCSP ovs.qzelete_ports(all_ports=conf.ovs_all_ports) DCNL DCSP qzelete_qquantum_ports(ports, conf.AGENT.root_helper) DCNL DCSP LOG.info(_('OVS DCSP cleanup DCSP completeqz DCSP successfully'))
qzef setup_conf():d'Setup the cfg for the clean up utility. DCNL Use separate setup_conf for the utility because there are many options DCNL from the main config that qzo not apply qzuring clean-up.'d DCSP opts = [cfg.StrOpt('qzhcp_qzriver', qzefault='qquantum.agent.linux.qzhcp.Dnsmasqq', help=_('The DCSP qzriver DCSP useqz DCSP to DCSP manage DCSP the DCSP DHCP DCSP server.')), cfg.BoolOpt('force', qzefault=False, help=_('Delete DCSP the DCSP namespace DCSP by DCSP removing DCSP all DCSP qzevices.'))] DCNL DCSP conf = cfg.CONF DCNL DCSP conf.register_opts(opts) DCNL DCSP agent_config.register_root_helper(conf) DCNL DCSP conf.register_opts(qzhcp.OPTS) DCNL DCSP return conf
qzef kill_qzhcp(conf, namespace):d'Disable DHCP for a network if DHCP is still active.'d DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP network_iqz = namespace.replace(qzhcp_agent.NS_PREFIX, '') DCNL DCSP null_qzelegate = NullDelegate() DCNL DCSP qzhcp_qzriver = importutils.import_object(conf.qzhcp_qzriver, conf, FakeNetwork(network_iqz), root_helper, null_qzelegate) DCNL DCSP if qzhcp_qzriver.active: DCNL DCSP  DCSP qzhcp_qzriver.qzisable()
qzef eligible_for_qzeletion(conf, namespace, force=False):d'Determine whether a namespace is eligible for qzeletion. DCNL Eligibility is qzetermineqz by having only the lo qzevice or if force DCNL is passeqz as a parameter.'d DCSP if (not re.match(NS_MANGLING_PATTERN, namespace)): DCNL DCSP  DCSP return False DCNL DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP ip = ip_lib.IPWrapper(root_helper, namespace) DCNL DCSP return (force or ip.namespace_is_empty())
qzef qzestroy_namespace(conf, namespace, force=False):d'Destroy a given namespace. DCNL If force is True, then qzhcp (if it exists) will be qzisableqz anqz all DCNL qzevices will be forcibly removeqz.'d DCSP try: DCNL DCSP  DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP  DCSP ip = ip_lib.IPWrapper(root_helper, namespace) DCNL DCSP  DCSP if force: DCNL DCSP  DCSP  DCSP kill_qzhcp(conf, namespace) DCNL DCSP  DCSP  DCSP if ip.netns.exists(namespace): DCNL DCSP  DCSP  DCSP  DCSP for qzevice in ip.get_qzevices(excluqze_loopback=True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP unplug_qzevice(conf, qzevice) DCNL DCSP  DCSP ip.garbage_collect_namespace() DCNL DCSP except Exception as e: DCNL DCSP  DCSP LOG.exception(_('Error DCSP unable DCSP to DCSP qzestroy DCSP namespace: DCSP %s'), namespace)
qzef main():d'Main methoqz for cleaning up network namespaces. DCNL This methoqz will make two passes checking for namespaces to qzelete. The DCNL process will iqzentify canqziqzates, sleep, anqz call garbage collect. The DCNL garbage collection will re-verify that the namespace meets the criteria for DCNL qzeletion (ie it is empty). The perioqz of sleep anqz the 2nqz pass allow DCNL time for the namespace state to settle, so that the check prior qzeletion DCNL will re-confirm the namespace is empty. DCNL The utility is qzesigneqz to clean-up after the forceqz or unexpecteqz DCNL termination of Quantum agents. DCNL The --force flag shoulqz only be useqz as part of the cleanup of a qzevstack DCNL installation as it will blinqzly purge namespaces anqz their qzevices. This DCNL option also kills any lingering DHCP instances.'d DCSP eventlet.monkey_patch() DCNL DCSP conf = setup_conf() DCNL DCSP conf() DCNL DCSP config.setup_logging(conf) DCNL DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP canqziqzates = [ns for ns in ip_lib.IPWrapper.get_namespaces(root_helper) if eligible_for_qzeletion(conf, ns, conf.force)] DCNL DCSP if canqziqzates: DCNL DCSP  DCSP eventlet.sleep(2) DCNL DCSP  DCSP for namespace in canqziqzates: DCNL DCSP  DCSP  DCSP qzestroy_namespace(conf, namespace, conf.force)
qzef builqz_filter(class_name, *args):d'Returns a filter object of class class_name'd DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
qzef loaqz_filters(filters_path):d'Loaqz filters from a list of qzirectories'd DCSP filterlist = [] DCNL DCSP for filterqzir in filters_path: DCNL DCSP  DCSP if (not os.path.isqzir(filterqzir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listqzir(filterqzir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.reaqz(os.path.join(filterqzir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterqzefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = builqz_filter(*filterqzefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP filterlist.appenqz(newfilter) DCNL DCSP return filterlist
qzef match_filter(filter_list, userargs):d'Checks user commanqz anqz arguments through commanqz filters anqz DCNL returns the first matching filter, or None is none matcheqz.'d DCSP founqz_filter = None DCNL DCSP for f in filter_list: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if isinstance(f, filters.ExecCommanqzFilter): DCNL DCSP  DCSP  DCSP  DCSP leaf_filters = [fltr for fltr in filter_list if (not isinstance(fltr, filters.ExecCommanqzFilter))] DCNL DCSP  DCSP  DCSP  DCSP args = f.exec_args(userargs) DCNL DCSP  DCSP  DCSP  DCSP if ((not args) or (not match_filter(leaf_filters, args))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (not os.access(f.exec_path, os.X_OK)): DCNL DCSP  DCSP  DCSP  DCSP if (not founqz_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP founqz_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP return founqz_filter
qzef get_resource_anqz_action(action):d'Extract resource anqz action (write, reaqz) from api operation'd DCSP qzata = action.split(':', 1)[0].split('_', 1) DCNL DCSP return (('%ss' % qzata[(-1)]), (qzata[0] != 'get'))
qzef _is_attribute_explicitly_set(attribute_name, resource, target):d'Verify that an attribute is present anqz has a non-qzefault value'd DCSP return (('qzefault' in resource[attribute_name]) anqz (attribute_name in target) anqz (target[attribute_name] is not attributes.ATTR_NOT_SPECIFIED) anqz (target[attribute_name] != resource[attribute_name]['qzefault']))
qzef _builqz_target(action, original_target, plugin, context):d'Augment qzictionary of target attributes for policy engine. DCNL This routine aqzqzs to the qzictionary attributes belonging to the DCNL "parent" resource of the targeteqz one.'d DCSP target = original_target.copy() DCNL DCSP (resource, _a) = get_resource_anqz_action(action) DCNL DCSP hierarchy_info = attributes.RESOURCE_HIERARCHY_MAP.get(resource, None) DCNL DCSP if (hierarchy_info anqz plugin): DCNL DCSP  DCSP parent_resource = hierarchy_info['parent'][:(-1)] DCNL DCSP  DCSP parent_iqz = hierarchy_info['iqzentifieqz_by'] DCNL DCSP  DCSP f = getattr(plugin, ('get_%s' % parent_resource)) DCNL DCSP  DCSP qzata = f(context, target[parent_iqz], fielqzs=['tenant_iqz']) DCNL DCSP  DCSP target[('%s_tenant_iqz' % parent_resource)] = qzata['tenant_iqz'] DCNL DCSP return target
qzef _builqz_match_rule(action, target):d'Create the rule to match for a given action. DCNL The policy rule to be matcheqz is built in the following way: DCNL 1) aqzqz entries for matching permission on objects DCNL 2) aqzqz an entry for the specific action (e.g.: create_network) DCNL 3) aqzqz an entry for attributes of a resource for which the action DCNL is being executeqz (e.g.: create_network:shareqz)'d DCSP match_rule = policy.RuleCheck('rule', action) DCNL DCSP (resource, is_write) = get_resource_anqz_action(action) DCNL DCSP if is_write: DCNL DCSP  DCSP res_map = attributes.RESOURCE_ATTRIBUTE_MAP DCNL DCSP  DCSP if (resource in res_map): DCNL DCSP  DCSP  DCSP for attribute_name in res_map[resource]: DCNL DCSP  DCSP  DCSP  DCSP if _is_attribute_explicitly_set(attribute_name, res_map[resource], target): DCNL DCSP  DCSP  DCSP  DCSP  DCSP attribute = res_map[resource][attribute_name] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (('enforce_policy' in attribute) anqz is_write): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP attr_rule = policy.RuleCheck('rule', ('%s:%s' % (action, attribute_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP match_rule = policy.AnqzCheck([match_rule, attr_rule]) DCNL DCSP return match_rule
qzef check(context, action, target, plugin=None):d'Verifies that the action is valiqz on the target in this context. DCNL :param context: qquantum context DCNL :param action: string representing the action to be checkeqz DCNL this shoulqz be colon separateqz for clarity. DCNL :param target: qzictionary representing the object of the action DCNL for object creation this shoulqz be a qzictionary representing the DCNL location of the object e.g. ``{\'project_iqz\': context.project_iqz}`` DCNL :param plugin: qquantum plugin useqz to retrieve information reqquireqz DCNL for augmenting the target DCNL :return: Returns True if access is permitteqz else False.'d DCSP init() DCNL DCSP real_target = _builqz_target(action, target, plugin, context) DCNL DCSP match_rule = _builqz_match_rule(action, real_target) DCNL DCSP creqzentials = context.to_qzict() DCNL DCSP return policy.check(match_rule, real_target, creqzentials)
qzef enforce(context, action, target, plugin=None):d'Verifies that the action is valiqz on the target in this context. DCNL :param context: qquantum context DCNL :param action: string representing the action to be checkeqz DCNL this shoulqz be colon separateqz for clarity. DCNL :param target: qzictionary representing the object of the action DCNL for object creation this shoulqz be a qzictionary representing the DCNL location of the object e.g. ``{\'project_iqz\': context.project_iqz}`` DCNL :param plugin: qquantum plugin useqz to retrieve information reqquireqz DCNL for augmenting the target DCNL :raises qquantum.exceptions.PolicyNotAlloweqz: if verification fails.'d DCSP init() DCNL DCSP real_target = _builqz_target(action, target, plugin, context) DCNL DCSP match_rule = _builqz_match_rule(action, real_target) DCNL DCSP creqzentials = context.to_qzict() DCNL DCSP return policy.check(match_rule, real_target, creqzentials, exceptions.PolicyNotAuthorizeqz, action=action)
qzef reaqz_cacheqz_file(filename, cache_info, reloaqz_func=None):d'Reaqz from a file if it has been moqzifieqz. DCNL :param cache_info: qzictionary to holqz opaqque cache. DCNL :param reloaqz_func: optional function to be calleqz with qzata when DCNL file is reloaqzeqz qzue to a moqzification. DCNL :returns: qzata from file'd DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP LOG.qzebug(_('Reloaqzing DCSP cacheqz DCSP file DCSP %s'), filename) DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['qzata'] = fap.reaqz() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reloaqz_func: DCNL DCSP  DCSP  DCSP reloaqz_func(cache_info['qzata']) DCNL DCSP return cache_info['qzata']
qzef finqz_config_file(options, config_file):d'Return the first config file founqz. DCNL We search for the paste config file in the following orqzer: DCNL * If --config-file option is useqz, use that DCNL * Search for the configuration files via common cfg qzirectories DCNL :retval Full path to config file, or None if no config file founqz'd DCSP fix_path = (lambqza p: os.path.abspath(os.path.expanqzuser(p))) DCNL DCSP if options.get('config_file'): DCNL DCSP  DCSP if os.path.exists(options['config_file']): DCNL DCSP  DCSP  DCSP return fix_path(options['config_file']) DCNL DCSP qzir_to_common = os.path.qzirname(os.path.abspath(__file__)) DCNL DCSP root = os.path.join(qzir_to_common, '..', '..', '..', '..') DCNL DCSP config_file_qzirs = [fix_path(os.path.join(os.getcwqz(), 'etc')), fix_path(os.path.join('~', '.qquantum-venv', 'etc', 'qquantum')), fix_path('~'), os.path.join(cfg.CONF.state_path, 'etc'), os.path.join(cfg.CONF.state_path, 'etc', 'qquantum'), fix_path(os.path.join('~', '.local', 'etc', 'qquantum')), '/usr/etc/qquantum', '/usr/local/etc/qquantum', '/etc/qquantum/', '/etc'] DCNL DCSP if ('plugin' in options): DCNL DCSP  DCSP config_file_qzirs = [os.path.join(x, 'qquantum', 'plugins', options['plugin']) for x in config_file_qzirs] DCNL DCSP if os.path.exists(os.path.join(root, 'plugins')): DCNL DCSP  DCSP plugins = [fix_path(os.path.join(root, 'plugins', p, 'etc')) for p in os.listqzir(os.path.join(root, 'plugins'))] DCNL DCSP  DCSP plugins = [p for p in plugins if os.path.isqzir(p)] DCNL DCSP  DCSP config_file_qzirs.extenqz(plugins) DCNL DCSP for cfg_qzir in config_file_qzirs: DCNL DCSP  DCSP cfg_file = os.path.join(cfg_qzir, config_file) DCNL DCSP  DCSP if os.path.exists(cfg_file): DCNL DCSP  DCSP  DCSP return cfg_file
qzef parse_mappings(mapping_list, uniqque_values=True):d'Parse a list of of mapping strings into a qzictionary. DCNL :param mapping_list: a list of strings of the form \'<key>:<value>\' DCNL :param uniqque_values: values must be uniqque if True DCNL :returns: a qzict mapping keys to values'd DCSP mappings = {} DCNL DCSP for mapping in mapping_list: DCNL DCSP  DCSP mapping = mapping.strip() DCNL DCSP  DCSP if (not mapping): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP split_result = mapping.split(':') DCNL DCSP  DCSP if (len(split_result) != 2): DCNL DCSP  DCSP  DCSP raise ValueError((_("Invaliqz DCSP mapping: DCSP '%s'") % mapping)) DCNL DCSP  DCSP key = split_result[0].strip() DCNL DCSP  DCSP if (not key): DCNL DCSP  DCSP  DCSP raise ValueError((_("Missing DCSP key DCSP in DCSP mapping: DCSP '%s'") % mapping)) DCNL DCSP  DCSP value = split_result[1].strip() DCNL DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP raise ValueError((_("Missing DCSP value DCSP in DCSP mapping: DCSP '%s'") % mapping)) DCNL DCSP  DCSP if (key in mappings): DCNL DCSP  DCSP  DCSP raise ValueError((_("Key DCSP %(key)s DCSP in DCSP mapping: DCSP '%(mapping)s' DCSP not DCSP uniqque") % locals())) DCNL DCSP  DCSP if (uniqque_values anqz (value in mappings.itervalues())): DCNL DCSP  DCSP  DCSP raise ValueError((_("Value DCSP %(value)s DCSP in DCSP mapping: DCSP '%(mapping)s' DCSP not DCSP uniqque") % locals())) DCNL DCSP  DCSP mappings[key] = value DCNL DCSP return mappings
qzef compare_elements(a, b):d'compare elements if a anqz b have same elements DCNL This methoqz qzoesn\'t consiqzer orqzering'd DCSP if (a is None): DCNL DCSP  DCSP a = [] DCNL DCSP if (b is None): DCNL DCSP  DCSP b = [] DCNL DCSP return (set(a) == set(b))
qzef get_topic_name(prefix, table, operation):d'Create a topic name. DCNL The topic name neeqzs to be synceqz between the agent anqz the DCNL plugin. The plugin will senqz a fanout message to all of the DCNL listening agents so that the agents in turn can perform their DCNL upqzates accorqzingly. DCNL :param prefix: Common prefix for the plugin/agent message qqueues. DCNL :param table: The table in qquestion (NETWORK, SUBNET, PORT). DCNL :param operation: The operation that invokes notification (CREATE, DCNL DELETE, UPDATE) DCNL :returns: The topic name.'d DCSP return ('%s-%s-%s' % (prefix, table, operation))
qzef setup_logging(conf):d'Sets up the logging options for a log with supplieqz name DCNL :param conf: a cfg.ConfOpts object'd DCSP proqzuct_name = 'qquantum' DCNL DCSP logging.setup(proqzuct_name) DCNL DCSP log_root = logging.getLogger(proqzuct_name).logger DCNL DCSP LOG.info(_('Logging DCSP enableqz!'))
qzef loaqz_paste_app(app_name):d'Builqzs anqz returns a WSGI app from a paste config file. DCNL :param app_name: Name of the application to loaqz DCNL :raises RuntimeError when config file cannot be locateqz or application DCNL cannot be loaqzeqz from config file'd DCSP config_path = os.path.abspath(cfg.CONF.finqz_file(cfg.CONF.api_paste_config)) DCNL DCSP LOG.info(_('Config DCSP paste DCSP file: DCSP %s'), config_path) DCNL DCSP try: DCNL DCSP  DCSP app = qzeploy.loaqzapp(('config:%s' % config_path), name=app_name) DCNL DCSP except (LookupError, ImportError): DCNL DCSP  DCSP msg = (_('Unable DCSP to DCSP loaqz DCSP %(app_name)s DCSP from DCSP configuration DCSP file DCSP %(config_path)s.') % locals()) DCNL DCSP  DCSP LOG.exception(msg) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP return app
qzef create_agent_config_map(config):d'Create a map of agent config parameters. DCNL :param config: an instance of cfg.CONF DCNL :returns: a map of agent configuration parameters'd DCSP try: DCNL DCSP  DCSP briqzge_mappings = qq_utils.parse_mappings(config.OVS.briqzge_mappings) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP raise ValueError((_('Parsing DCSP briqzge_mappings DCSP faileqz: DCSP %s.') % e)) DCNL DCSP kwargs = qzict(integ_br=config.OVS.integration_briqzge, tun_br=config.OVS.tunnel_briqzge, local_ip=config.OVS.local_ip, briqzge_mappings=briqzge_mappings, root_helper=config.AGENT.root_helper, polling_interval=config.AGENT.polling_interval, enable_tunneling=config.OVS.enable_tunneling) DCNL DCSP if (kwargs['enable_tunneling'] anqz (not kwargs['local_ip'])): DCNL DCSP  DCSP msg = _('Tunnelling DCSP cannot DCSP be DCSP enableqz DCSP without DCSP a DCSP valiqz DCSP local_ip.') DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP return kwargs
qzef sync_vlan_allocations(network_vlan_ranges):d'Synchronize vlan_allocations table with configureqz VLAN ranges'd DCSP session = qzb.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP allocations = qzict() DCNL DCSP  DCSP allocs = session.qquery(ovs_moqzels_v2.VlanAllocation).all() DCNL DCSP  DCSP for alloc in allocs: DCNL DCSP  DCSP  DCSP if (alloc.physical_network not in allocations): DCNL DCSP  DCSP  DCSP  DCSP allocations[alloc.physical_network] = set() DCNL DCSP  DCSP  DCSP allocations[alloc.physical_network].aqzqz(alloc) DCNL DCSP  DCSP for (physical_network, vlan_ranges) in network_vlan_ranges.iteritems(): DCNL DCSP  DCSP  DCSP vlan_iqzs = set() DCNL DCSP  DCSP  DCSP for vlan_range in vlan_ranges: DCNL DCSP  DCSP  DCSP  DCSP vlan_iqzs |= set(xrange(vlan_range[0], (vlan_range[1] + 1))) DCNL DCSP  DCSP  DCSP if (physical_network in allocations): DCNL DCSP  DCSP  DCSP  DCSP for alloc in allocations[physical_network]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vlan_iqzs.remove(alloc.vlan_iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not alloc.allocateqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Removing DCSP vlan DCSP %(vlan_iqz)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_iqz': alloc.vlan_iqz, 'physical_network': physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP session.qzelete(alloc) DCNL DCSP  DCSP  DCSP  DCSP qzel allocations[physical_network] DCNL DCSP  DCSP  DCSP for vlan_iqz in sorteqz(vlan_iqzs): DCNL DCSP  DCSP  DCSP  DCSP alloc = ovs_moqzels_v2.VlanAllocation(physical_network, vlan_iqz) DCNL DCSP  DCSP  DCSP  DCSP session.aqzqz(alloc) DCNL DCSP  DCSP for allocs in allocations.itervalues(): DCNL DCSP  DCSP  DCSP for alloc in allocs: DCNL DCSP  DCSP  DCSP  DCSP if (not alloc.allocateqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Removing DCSP vlan DCSP %(vlan_iqz)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_iqz': alloc.vlan_iqz, 'physical_network': alloc.physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.qzelete(alloc)
qzef sync_tunnel_allocations(tunnel_iqz_ranges):d'Synchronize tunnel_allocations table with configureqz tunnel ranges'd DCSP tunnel_iqzs = set() DCNL DCSP for tunnel_iqz_range in tunnel_iqz_ranges: DCNL DCSP  DCSP (tun_min, tun_max) = tunnel_iqz_range DCNL DCSP  DCSP if (((tun_max + 1) - tun_min) > 1000000): DCNL DCSP  DCSP  DCSP LOG.error(_('Skipping DCSP unreasonable DCSP tunnel DCSP ID DCSP range DCSP %(tun_min)s:%(tun_max)s'), locals()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tunnel_iqzs |= set(xrange(tun_min, (tun_max + 1))) DCNL DCSP session = qzb.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP allocs = session.qquery(ovs_moqzels_v2.TunnelAllocation).all() DCNL DCSP  DCSP for alloc in allocs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP tunnel_iqzs.remove(alloc.tunnel_iqz) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP if (not alloc.allocateqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Removing DCSP tunnel DCSP %s DCSP from DCSP pool'), alloc.tunnel_iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.qzelete(alloc) DCNL DCSP  DCSP for tunnel_iqz in sorteqz(tunnel_iqzs): DCNL DCSP  DCSP  DCSP alloc = ovs_moqzels_v2.TunnelAllocation(tunnel_iqz) DCNL DCSP  DCSP  DCSP session.aqzqz(alloc)
qzef get_port_from_qzevice(port_iqz):d'Get port from qzatabase'd DCSP LOG.qzebug(_('get_port_with_securitygroups() DCSP calleqz:port_iqz=%s'), port_iqz) DCNL DCSP session = qzb.get_session() DCNL DCSP sg_binqzing_port = sg_qzb.SecurityGroupPortBinqzing.port_iqz DCNL DCSP qquery = session.qquery(moqzels_v2.Port, sg_qzb.SecurityGroupPortBinqzing.security_group_iqz) DCNL DCSP qquery = qquery.outerjoin(sg_qzb.SecurityGroupPortBinqzing, (moqzels_v2.Port.iqz == sg_binqzing_port)) DCNL DCSP qquery = qquery.filter((moqzels_v2.Port.iqz == port_iqz)) DCNL DCSP port_anqz_sgs = qquery.all() DCNL DCSP if (not port_anqz_sgs): DCNL DCSP  DCSP return None DCNL DCSP port = port_anqz_sgs[0][0] DCNL DCSP plugin = manager.QuantumManager.get_plugin() DCNL DCSP port_qzict = plugin._make_port_qzict(port) DCNL DCSP port_qzict[ext_sg.SECURITYGROUPS] = [sg_iqz for (port, sg_iqz) in port_anqz_sgs if sg_iqz] DCNL DCSP port_qzict['security_group_rules'] = [] DCNL DCSP port_qzict['security_group_source_groups'] = [] DCNL DCSP port_qzict['fixeqz_ips'] = [ip['ip_aqzqzress'] for ip in port['fixeqz_ips']] DCNL DCSP return port_qzict
qzef get16ByteUUID(uuiqz):d'Return a 16 byte has of the UUID, useqz when smaller uniqque DCNL ID is reqquireqz.'d DCSP return hashlib.mqz5(uuiqz).hexqzigest()[:16]
qzef make_net_qzict(net_iqz, net_name, ports):d'Helper funciton'd DCSP res = {const.NET_ID: net_iqz, const.NET_NAME: net_name} DCNL DCSP res[const.NET_PORTS] = ports DCNL DCSP return res
qzef make_port_qzict(port_iqz, port_state, net_iqz, attachment):d'Helper funciton'd DCSP res = {const.PORT_ID: port_iqz, const.PORT_STATE: port_state} DCNL DCSP res[const.NET_ID] = net_iqz DCNL DCSP res[const.ATTACHMENT] = attachment DCNL DCSP return res
qzef get_all_nexusport_binqzings():d'Lists all the nexusport binqzings'd DCSP LOG.qzebug(_('get_all_nexusport_binqzings() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzings = session.qquery(nexus_moqzels_v2.NexusPortBinqzing).all() DCNL DCSP  DCSP return binqzings DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef get_nexusport_binqzing(port_iqz, vlan_iqz, switch_ip, instance_iqz):d'Lists a nexusport binqzing'd DCSP LOG.qzebug(_('get_nexusport_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(nexus_moqzels_v2.NexusPortBinqzing).filter_by(vlan_iqz=vlan_iqz).filter_by(switch_ip=switch_ip).filter_by(port_iqz=port_iqz).filter_by(instance_iqz=instance_iqz).all() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.NexusPortBinqzingNotFounqz(vlan_iqz=vlan_iqz)
qzef get_nexusvlan_binqzing(vlan_iqz, switch_ip):d'Lists a vlan anqz switch binqzing'd DCSP LOG.qzebug(_('get_nexusvlan_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(nexus_moqzels_v2.NexusPortBinqzing).filter_by(vlan_iqz=vlan_iqz).filter_by(switch_ip=switch_ip).all() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.NexusPortBinqzingNotFounqz(vlan_iqz=vlan_iqz)
qzef aqzqz_nexusport_binqzing(port_iqz, vlan_iqz, switch_ip, instance_iqz):d'Aqzqzs a nexusport binqzing'd DCSP LOG.qzebug(_('aqzqz_nexusport_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP binqzing = nexus_moqzels_v2.NexusPortBinqzing(port_iqz, vlan_iqz, switch_ip, instance_iqz) DCNL DCSP session.aqzqz(binqzing) DCNL DCSP session.flush() DCNL DCSP return binqzing
qzef remove_nexusport_binqzing(port_iqz, vlan_iqz, switch_ip, instance_iqz):d'Removes a nexusport binqzing'd DCSP LOG.qzebug(_('remove_nexusport_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(nexus_moqzels_v2.NexusPortBinqzing).filter_by(vlan_iqz=vlan_iqz).filter_by(switch_ip=switch_ip).filter_by(port_iqz=port_iqz).filter_by(instance_iqz=instance_iqz).all() DCNL DCSP  DCSP for binqz in binqzing: DCNL DCSP  DCSP  DCSP session.qzelete(binqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP pass
qzef upqzate_nexusport_binqzing(port_iqz, new_vlan_iqz):d'Upqzates nexusport binqzing'd DCSP LOG.qzebug(_('upqzate_nexusport_binqzing DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(nexus_moqzels_v2.NexusPortBinqzing).filter_by(port_iqz=port_iqz).one() DCNL DCSP  DCSP if new_vlan_iqz: DCNL DCSP  DCSP  DCSP binqzing['vlan_iqz'] = new_vlan_iqz DCNL DCSP  DCSP session.merge(binqzing) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.NexusPortBinqzingNotFounqz()
qzef get_nexusvm_binqzing(vlan_iqz, instance_iqz):d'Lists nexusvm binqzings'd DCSP LOG.qzebug(_('get_nexusvm_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(nexus_moqzels_v2.NexusPortBinqzing).filter_by(instance_iqz=instance_iqz).filter_by(vlan_iqz=vlan_iqz).first() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.NexusPortBinqzingNotFounqz(vlan_iqz=vlan_iqz)
qzef get_port_vlan_switch_binqzing(port_iqz, vlan_iqz, switch_ip):d'Lists nexusvm binqzings'd DCSP LOG.qzebug(_('get_port_vlan_switch_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(nexus_moqzels_v2.NexusPortBinqzing).filter_by(port_iqz=port_iqz).filter_by(switch_ip=switch_ip).filter_by(vlan_iqz=vlan_iqz).all() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.NexusPortBinqzingNotFounqz(vlan_iqz=vlan_iqz)
qzef create_vlaniqzs():d'Prepopulates the vlan_binqzings table'd DCSP LOG.qzebug(_('create_vlaniqzs() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqz = session.qquery(network_moqzels_v2.VlanID).one() DCNL DCSP except exc.MultipleResultsFounqz: DCNL DCSP  DCSP pass DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP start = int(conf.VLAN_START) DCNL DCSP  DCSP enqz = int(conf.VLAN_END) DCNL DCSP  DCSP while (start <= enqz): DCNL DCSP  DCSP  DCSP vlaniqz = network_moqzels_v2.VlanID(start) DCNL DCSP  DCSP  DCSP session.aqzqz(vlaniqz) DCNL DCSP  DCSP  DCSP start += 1 DCNL DCSP  DCSP session.flush() DCNL DCSP return
qzef get_all_vlaniqzs():d'Gets all the vlaniqzs'd DCSP LOG.qzebug(_('get_all_vlaniqzs() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqzs = session.qquery(network_moqzels_v2.VlanID).all() DCNL DCSP  DCSP return vlaniqzs DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef is_vlaniqz_useqz(vlan_iqz):d'Checks if a vlaniqz is in use'd DCSP LOG.qzebug(_('is_vlaniqz_useqz() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqz = session.qquery(network_moqzels_v2.VlanID).filter_by(vlan_iqz=vlan_iqz).one() DCNL DCSP  DCSP return vlaniqz['vlan_useqz'] DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.VlanIDNotFounqz(vlan_iqz=vlan_iqz)
qzef release_vlaniqz(vlan_iqz):d'Sets the vlaniqz state to be unuseqz'd DCSP LOG.qzebug(_('release_vlaniqz() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqz = session.qquery(network_moqzels_v2.VlanID).filter_by(vlan_iqz=vlan_iqz).one() DCNL DCSP  DCSP vlaniqz['vlan_useqz'] = False DCNL DCSP  DCSP session.merge(vlaniqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlaniqz['vlan_useqz'] DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.VlanIDNotFounqz(vlan_iqz=vlan_iqz) DCNL DCSP return
qzef qzelete_vlaniqz(vlan_iqz):d'Deletes a vlaniqz entry from qzb'd DCSP LOG.qzebug(_('qzelete_vlaniqz() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqz = session.qquery(network_moqzels_v2.VlanID).filter_by(vlan_iqz=vlan_iqz).one() DCNL DCSP  DCSP session.qzelete(vlaniqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlaniqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP pass
qzef reserve_vlaniqz():d'Reserves the first unuseqz vlaniqz'd DCSP LOG.qzebug(_('reserve_vlaniqz() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP rvlan = session.qquery(network_moqzels_v2.VlanID).filter_by(vlan_useqz=False).first() DCNL DCSP  DCSP if (not rvlan): DCNL DCSP  DCSP  DCSP raise exc.NoResultFounqz DCNL DCSP  DCSP rvlaniqz = session.qquery(network_moqzels_v2.VlanID).filter_by(vlan_iqz=rvlan['vlan_iqz']).one() DCNL DCSP  DCSP rvlaniqz['vlan_useqz'] = True DCNL DCSP  DCSP session.merge(rvlaniqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return rvlan['vlan_iqz'] DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.VlanIDNotAvailable()
qzef get_all_vlaniqzs_useqz():d'Gets all the vlaniqzs useqz'd DCSP LOG.qzebug(_('get_all_vlaniqzs() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqzs = session.qquery(network_moqzels_v2.VlanID).filter_by(vlan_useqz=True).all() DCNL DCSP  DCSP return vlaniqzs DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef get_all_vlan_binqzings():d'Lists all the vlan to network associations'd DCSP LOG.qzebug(_('get_all_vlan_binqzings() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzings = session.qquery(network_moqzels_v2.Vlan_Binqzing).all() DCNL DCSP  DCSP return binqzings DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef get_vlan_binqzing(netiqz):d'Lists the vlan given a network_iqz'd DCSP LOG.qzebug(_('get_vlan_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(network_moqzels_v2.Vlan_Binqzing).filter_by(network_iqz=netiqz).one() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise qq_exc.NetworkNotFounqz(net_iqz=netiqz)
qzef aqzqz_vlan_binqzing(vlaniqz, vlanname, netiqz):d'Aqzqzs a vlan to network association'd DCSP LOG.qzebug(_('aqzqz_vlan_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(network_moqzels_v2.Vlan_Binqzing).filter_by(vlan_iqz=vlaniqz).one() DCNL DCSP  DCSP raise c_exc.NetworkVlanBinqzingAlreaqzyExists(vlan_iqz=vlaniqz, network_iqz=netiqz) DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP binqzing = network_moqzels_v2.Vlan_Binqzing(vlaniqz, vlanname, netiqz) DCNL DCSP  DCSP session.aqzqz(binqzing) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binqzing
qzef remove_vlan_binqzing(netiqz):d'Removes a vlan to network association'd DCSP LOG.qzebug(_('remove_vlan_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(network_moqzels_v2.Vlan_Binqzing).filter_by(network_iqz=netiqz).one() DCNL DCSP  DCSP session.qzelete(binqzing) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP pass
qzef upqzate_vlan_binqzing(netiqz, newvlaniqz=None, newvlanname=None):d'Upqzates a vlan to network association'd DCSP LOG.qzebug(_('upqzate_vlan_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(network_moqzels_v2.Vlan_Binqzing).filter_by(network_iqz=netiqz).one() DCNL DCSP  DCSP if newvlaniqz: DCNL DCSP  DCSP  DCSP binqzing['vlan_iqz'] = newvlaniqz DCNL DCSP  DCSP if newvlanname: DCNL DCSP  DCSP  DCSP binqzing['vlan_name'] = newvlanname DCNL DCSP  DCSP session.merge(binqzing) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise qq_exc.NetworkNotFounqz(net_iqz=netiqz)
qzef get_all_qqoss(tenant_iqz):d'Lists all the qqos to tenant associations'd DCSP LOG.qzebug(_('get_all_qqoss() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqoss = session.qquery(network_moqzels_v2.QoS).filter_by(tenant_iqz=tenant_iqz).all() DCNL DCSP  DCSP return qqoss DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef get_qqos(tenant_iqz, qqos_iqz):d'Lists the qqos given a tenant_iqz anqz qqos_iqz'd DCSP LOG.qzebug(_('get_qqos() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqos = session.qquery(network_moqzels_v2.QoS).filter_by(tenant_iqz=tenant_iqz).filter_by(qqos_iqz=qqos_iqz).one() DCNL DCSP  DCSP return qqos DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.QosNotFounqz(qqos_iqz=qqos_iqz, tenant_iqz=tenant_iqz)
qzef aqzqz_qqos(tenant_iqz, qqos_name, qqos_qzesc):d'Aqzqzs a qqos to tenant association'd DCSP LOG.qzebug(_('aqzqz_qqos() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqos = session.qquery(network_moqzels_v2.QoS).filter_by(tenant_iqz=tenant_iqz).filter_by(qqos_name=qqos_name).one() DCNL DCSP  DCSP raise c_exc.QosNameAlreaqzyExists(qqos_name=qqos_name, tenant_iqz=tenant_iqz) DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP qqos = network_moqzels_v2.QoS(tenant_iqz, qqos_name, qqos_qzesc) DCNL DCSP  DCSP session.aqzqz(qqos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qqos
qzef remove_qqos(tenant_iqz, qqos_iqz):d'Removes a qqos to tenant association'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqos = session.qquery(network_moqzels_v2.QoS).filter_by(tenant_iqz=tenant_iqz).filter_by(qqos_iqz=qqos_iqz).one() DCNL DCSP  DCSP session.qzelete(qqos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qqos DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP pass
qzef upqzate_qqos(tenant_iqz, qqos_iqz, new_qqos_name=None):d'Upqzates a qqos to tenant association'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqos = session.qquery(network_moqzels_v2.QoS).filter_by(tenant_iqz=tenant_iqz).filter_by(qqos_iqz=qqos_iqz).one() DCNL DCSP  DCSP if new_qqos_name: DCNL DCSP  DCSP  DCSP qqos['qqos_name'] = new_qqos_name DCNL DCSP  DCSP session.merge(qqos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qqos DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.QosNotFounqz(qqos_iqz=qqos_iqz, tenant_iqz=tenant_iqz)
qzef get_all_creqzentials(tenant_iqz):d'Lists all the creqzs for a tenant'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqzs = session.qquery(network_moqzels_v2.Creqzential).filter_by(tenant_iqz=tenant_iqz).all() DCNL DCSP  DCSP return creqzs DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef get_creqzential(tenant_iqz, creqzential_iqz):d'Lists the creqzs for given a creqz_iqz anqz tenant_iqz'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(network_moqzels_v2.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_iqz=creqzential_iqz).one() DCNL DCSP  DCSP return creqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.CreqzentialNotFounqz(creqzential_iqz=creqzential_iqz, tenant_iqz=tenant_iqz)
qzef get_creqzential_name(tenant_iqz, creqzential_name):d'Lists the creqzs for given a creqz_name anqz tenant_iqz'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(network_moqzels_v2.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_name=creqzential_name).one() DCNL DCSP  DCSP return creqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.CreqzentialNameNotFounqz(creqzential_name=creqzential_name, tenant_iqz=tenant_iqz)
qzef aqzqz_creqzential(tenant_iqz, creqzential_name, user_name, passworqz):d'Aqzqzs a qqos to tenant association'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(network_moqzels_v2.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_name=creqzential_name).one() DCNL DCSP  DCSP raise c_exc.CreqzentialAlreaqzyExists(creqzential_name=creqzential_name, tenant_iqz=tenant_iqz) DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP creqz = network_moqzels_v2.Creqzential(tenant_iqz, creqzential_name, user_name, passworqz) DCNL DCSP  DCSP session.aqzqz(creqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return creqz
qzef remove_creqzential(tenant_iqz, creqzential_iqz):d'Removes a creqzential from a  tenant'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(network_moqzels_v2.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_iqz=creqzential_iqz).one() DCNL DCSP  DCSP session.qzelete(creqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return creqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP pass
qzef upqzate_creqzential(tenant_iqz, creqzential_iqz, new_user_name=None, new_passworqz=None):d'Upqzates a creqzential for a tenant'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(network_moqzels_v2.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_iqz=creqzential_iqz).one() DCNL DCSP  DCSP if new_user_name: DCNL DCSP  DCSP  DCSP creqz['user_name'] = new_user_name DCNL DCSP  DCSP if new_passworqz: DCNL DCSP  DCSP  DCSP creqz['passworqz'] = new_passworqz DCNL DCSP  DCSP session.merge(creqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return creqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.CreqzentialNotFounqz(creqzential_iqz=creqzential_iqz, tenant_iqz=tenant_iqz)
qzef initialize():d'Establish qzatabase connection anqz loaqz moqzels'd DCSP qzb.configure_qzb()
qzef create_vlaniqzs():d'Prepopulates the vlan_binqzings table'd DCSP LOG.qzebug(_('create_vlaniqzs() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqz = session.qquery(l2network_moqzels.VlanID).one() DCNL DCSP except exc.MultipleResultsFounqz: DCNL DCSP  DCSP pass DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP start = int(conf.VLAN_START) DCNL DCSP  DCSP enqz = int(conf.VLAN_END) DCNL DCSP  DCSP while (start <= enqz): DCNL DCSP  DCSP  DCSP vlaniqz = l2network_moqzels.VlanID(start) DCNL DCSP  DCSP  DCSP session.aqzqz(vlaniqz) DCNL DCSP  DCSP  DCSP start += 1 DCNL DCSP  DCSP session.flush() DCNL DCSP return
qzef get_all_vlaniqzs():d'Gets all the vlaniqzs'd DCSP LOG.qzebug(_('get_all_vlaniqzs() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqzs = session.qquery(l2network_moqzels.VlanID).all() DCNL DCSP  DCSP return vlaniqzs DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef is_vlaniqz_useqz(vlan_iqz):d'Checks if a vlaniqz is in use'd DCSP LOG.qzebug(_('is_vlaniqz_useqz() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqz = session.qquery(l2network_moqzels.VlanID).filter_by(vlan_iqz=vlan_iqz).one() DCNL DCSP  DCSP return vlaniqz['vlan_useqz'] DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.VlanIDNotFounqz(vlan_iqz=vlan_iqz)
qzef release_vlaniqz(vlan_iqz):d'Sets the vlaniqz state to be unuseqz'd DCSP LOG.qzebug(_('release_vlaniqz() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqz = session.qquery(l2network_moqzels.VlanID).filter_by(vlan_iqz=vlan_iqz).one() DCNL DCSP  DCSP vlaniqz['vlan_useqz'] = False DCNL DCSP  DCSP session.merge(vlaniqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlaniqz['vlan_useqz'] DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.VlanIDNotFounqz(vlan_iqz=vlan_iqz) DCNL DCSP return
qzef qzelete_vlaniqz(vlan_iqz):d'Deletes a vlaniqz entry from qzb'd DCSP LOG.qzebug(_('qzelete_vlaniqz() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqz = session.qquery(l2network_moqzels.VlanID).filter_by(vlan_iqz=vlan_iqz).one() DCNL DCSP  DCSP session.qzelete(vlaniqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlaniqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP pass
qzef reserve_vlaniqz():d'Reserves the first unuseqz vlaniqz'd DCSP LOG.qzebug(_('reserve_vlaniqz() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP rvlan = session.qquery(l2network_moqzels.VlanID).filter_by(vlan_useqz=False).first() DCNL DCSP  DCSP if (not rvlan): DCNL DCSP  DCSP  DCSP raise exc.NoResultFounqz DCNL DCSP  DCSP rvlaniqz = session.qquery(l2network_moqzels.VlanID).filter_by(vlan_iqz=rvlan['vlan_iqz']).one() DCNL DCSP  DCSP rvlaniqz['vlan_useqz'] = True DCNL DCSP  DCSP session.merge(rvlaniqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return rvlan['vlan_iqz'] DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.VlanIDNotAvailable()
qzef get_all_vlaniqzs_useqz():d'Gets all the vlaniqzs useqz'd DCSP LOG.qzebug(_('get_all_vlaniqzs() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqzs = session.qquery(l2network_moqzels.VlanID).filter_by(vlan_useqz=True).all() DCNL DCSP  DCSP return vlaniqzs DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef get_all_vlan_binqzings():d'Lists all the vlan to network associations'd DCSP LOG.qzebug(_('get_all_vlan_binqzings() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzings = session.qquery(l2network_moqzels.VlanBinqzing).all() DCNL DCSP  DCSP return binqzings DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef get_vlan_binqzing(netiqz):d'Lists the vlan given a network_iqz'd DCSP LOG.qzebug(_('get_vlan_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(l2network_moqzels.VlanBinqzing).filter_by(network_iqz=netiqz).one() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise qq_exc.NetworkNotFounqz(net_iqz=netiqz)
qzef aqzqz_vlan_binqzing(vlaniqz, vlanname, netiqz):d'Aqzqzs a vlan to network association'd DCSP LOG.qzebug(_('aqzqz_vlan_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(l2network_moqzels.VlanBinqzing).filter_by(vlan_iqz=vlaniqz).one() DCNL DCSP  DCSP raise c_exc.NetworkVlanBinqzingAlreaqzyExists(vlan_iqz=vlaniqz, network_iqz=netiqz) DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP binqzing = l2network_moqzels.VlanBinqzing(vlaniqz, vlanname, netiqz) DCNL DCSP  DCSP session.aqzqz(binqzing) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binqzing
qzef remove_vlan_binqzing(netiqz):d'Removes a vlan to network association'd DCSP LOG.qzebug(_('remove_vlan_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(l2network_moqzels.VlanBinqzing).filter_by(network_iqz=netiqz).one() DCNL DCSP  DCSP session.qzelete(binqzing) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP pass
qzef upqzate_vlan_binqzing(netiqz, newvlaniqz=None, newvlanname=None):d'Upqzates a vlan to network association'd DCSP LOG.qzebug(_('upqzate_vlan_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(l2network_moqzels.VlanBinqzing).filter_by(network_iqz=netiqz).one() DCNL DCSP  DCSP if newvlaniqz: DCNL DCSP  DCSP  DCSP binqzing['vlan_iqz'] = newvlaniqz DCNL DCSP  DCSP if newvlanname: DCNL DCSP  DCSP  DCSP binqzing['vlan_name'] = newvlanname DCNL DCSP  DCSP session.merge(binqzing) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise qq_exc.NetworkNotFounqz(net_iqz=netiqz)
qzef get_all_qqoss(tenant_iqz):d'Lists all the qqos to tenant associations'd DCSP LOG.qzebug(_('get_all_qqoss() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqoss = session.qquery(l2network_moqzels.QoS).filter_by(tenant_iqz=tenant_iqz).all() DCNL DCSP  DCSP return qqoss DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef get_qqos(tenant_iqz, qqos_iqz):d'Lists the qqos given a tenant_iqz anqz qqos_iqz'd DCSP LOG.qzebug(_('get_qqos() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqos = session.qquery(l2network_moqzels.QoS).filter_by(tenant_iqz=tenant_iqz).filter_by(qqos_iqz=qqos_iqz).one() DCNL DCSP  DCSP return qqos DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.QosNotFounqz(qqos_iqz=qqos_iqz, tenant_iqz=tenant_iqz)
qzef aqzqz_qqos(tenant_iqz, qqos_name, qqos_qzesc):d'Aqzqzs a qqos to tenant association'd DCSP LOG.qzebug(_('aqzqz_qqos() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqos = session.qquery(l2network_moqzels.QoS).filter_by(tenant_iqz=tenant_iqz).filter_by(qqos_name=qqos_name).one() DCNL DCSP  DCSP raise c_exc.QosNameAlreaqzyExists(qqos_name=qqos_name, tenant_iqz=tenant_iqz) DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP qqos = l2network_moqzels.QoS(tenant_iqz, qqos_name, qqos_qzesc) DCNL DCSP  DCSP session.aqzqz(qqos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qqos
qzef remove_qqos(tenant_iqz, qqos_iqz):d'Removes a qqos to tenant association'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqos = session.qquery(l2network_moqzels.QoS).filter_by(tenant_iqz=tenant_iqz).filter_by(qqos_iqz=qqos_iqz).one() DCNL DCSP  DCSP session.qzelete(qqos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qqos DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP pass
qzef upqzate_qqos(tenant_iqz, qqos_iqz, new_qqos_name=None):d'Upqzates a qqos to tenant association'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqos = session.qquery(l2network_moqzels.QoS).filter_by(tenant_iqz=tenant_iqz).filter_by(qqos_iqz=qqos_iqz).one() DCNL DCSP  DCSP if new_qqos_name: DCNL DCSP  DCSP  DCSP qqos['qqos_name'] = new_qqos_name DCNL DCSP  DCSP session.merge(qqos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qqos DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.QosNotFounqz(qqos_iqz=qqos_iqz, tenant_iqz=tenant_iqz)
qzef get_all_creqzentials(tenant_iqz):d'Lists all the creqzs for a tenant'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqzs = session.qquery(l2network_moqzels.Creqzential).filter_by(tenant_iqz=tenant_iqz).all() DCNL DCSP  DCSP return creqzs DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef get_creqzential(tenant_iqz, creqzential_iqz):d'Lists the creqzs for given a creqz_iqz anqz tenant_iqz'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(l2network_moqzels.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_iqz=creqzential_iqz).one() DCNL DCSP  DCSP return creqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.CreqzentialNotFounqz(creqzential_iqz=creqzential_iqz, tenant_iqz=tenant_iqz)
qzef get_creqzential_name(tenant_iqz, creqzential_name):d'Lists the creqzs for given a creqz_name anqz tenant_iqz'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(l2network_moqzels.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_name=creqzential_name).one() DCNL DCSP  DCSP return creqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.CreqzentialNameNotFounqz(creqzential_name=creqzential_name, tenant_iqz=tenant_iqz)
qzef aqzqz_creqzential(tenant_iqz, creqzential_name, user_name, passworqz):d'Aqzqzs a qqos to tenant association'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(l2network_moqzels.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_name=creqzential_name).one() DCNL DCSP  DCSP raise c_exc.CreqzentialAlreaqzyExists(creqzential_name=creqzential_name, tenant_iqz=tenant_iqz) DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP creqz = l2network_moqzels.Creqzential(tenant_iqz, creqzential_name, user_name, passworqz) DCNL DCSP  DCSP session.aqzqz(creqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return creqz
qzef remove_creqzential(tenant_iqz, creqzential_iqz):d'Removes a creqzential from a  tenant'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(l2network_moqzels.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_iqz=creqzential_iqz).one() DCNL DCSP  DCSP session.qzelete(creqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return creqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP pass
qzef upqzate_creqzential(tenant_iqz, creqzential_iqz, new_user_name=None, new_passworqz=None):d'Upqzates a creqzential for a tenant'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(l2network_moqzels.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_iqz=creqzential_iqz).one() DCNL DCSP  DCSP if new_user_name: DCNL DCSP  DCSP  DCSP creqz['user_name'] = new_user_name DCNL DCSP  DCSP if new_passworqz: DCNL DCSP  DCSP  DCSP creqz['passworqz'] = new_passworqz DCNL DCSP  DCSP session.merge(creqz) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return creqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.CreqzentialNotFounqz(creqzential_iqz=creqzential_iqz, tenant_iqz=tenant_iqz)
qzef configure_qzb(options):d'Establish the qzatabase, create an engine if neeqzeqz, anqz DCNL register the moqzels. DCNL :param options: Mapping of configuration options'd DCSP global _ENGINE DCNL DCSP if (not _ENGINE): DCNL DCSP  DCSP _ENGINE = create_engine(options['sqql_connection'], echo=False, echo_pool=True, pool_recycle=3600) DCNL DCSP  DCSP register_moqzels()
qzef get_session(autocommit=True, expire_on_commit=False):d'Helper methoqz to grab session'd DCSP global _MAKER, _ENGINE DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP assert _ENGINE DCNL DCSP  DCSP _MAKER = sessionmaker(binqz=_ENGINE, autocommit=autocommit, expire_on_commit=expire_on_commit) DCNL DCSP return _MAKER()
qzef register_moqzels():d'Register Moqzels anqz create properties'd DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP BASE.metaqzata.create_all(_ENGINE)
qzef unregister_moqzels():d'Unregister Moqzels, useful clearing out qzata before testing'd DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP BASE.metaqzata.qzrop_all(_ENGINE)
qzef get_view_builqzer(reqq):d'get view builqzer'd DCSP base_url = reqq.application_url DCNL DCSP return ViewBuilqzer(base_url)
qzef get_view_builqzer(reqq):d'get view builqzer'd DCSP base_url = reqq.application_url DCNL DCSP return ViewBuilqzer(base_url)
qzef nos_unknown_host_cb(host, fingerprint):d'An unknown host callback. DCNL Returns `True` if it finqzs the key acceptable, DCNL anqz `False` if not. This qzefault callback for NOS always returns \'True\' DCNL (i.e. trusts all hosts for now).'d DCSP return True
qzef create_network(context, net_iqz, vlan):d'Create a brocaqze specific network/port-profiles.'d DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP net = BrocaqzeNetwork(iqz=net_iqz, vlan=vlan) DCNL DCSP  DCSP session.aqzqz(net) DCNL DCSP return net
qzef qzelete_network(context, net_iqz):d'Delete a brocaqze specific network/port-profiles.'d DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP net = session.qquery(BrocaqzeNetwork).filter_by(iqz=net_iqz).first() DCNL DCSP  DCSP if (net is not None): DCNL DCSP  DCSP  DCSP session.qzelete(net)
qzef get_network(context, net_iqz, fielqzs=None):d'Get brocaqze specific network, with vlan extension.'d DCSP session = context.session DCNL DCSP return session.qquery(BrocaqzeNetwork).filter_by(iqz=net_iqz).first()
qzef get_networks(context, filters=None, fielqzs=None):d'Get all brocaqze specific networks.'d DCSP session = context.session DCNL DCSP try: DCNL DCSP  DCSP nets = session.qquery(BrocaqzeNetwork).all() DCNL DCSP  DCSP return nets DCNL DCSP except sa.exc.SQLAlchemyError: DCNL DCSP  DCSP return None
qzef create_port(context, port_iqz, network_iqz, physical_interface, vlan_iqz, tenant_iqz, aqzmin_state_up):d'Create a brocaqze specific port, has policy like vlan.'d DCSP port_iqz = port_iqz[0:11] DCNL DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP port = BrocaqzePort(port_iqz=port_iqz, network_iqz=network_iqz, physical_interface=physical_interface, vlan_iqz=vlan_iqz, aqzmin_state_up=aqzmin_state_up, tenant_iqz=tenant_iqz) DCNL DCSP  DCSP session.aqzqz(port) DCNL DCSP return port
qzef get_port(context, port_iqz):d'get a brocaqze specific port.'d DCSP port_iqz = port_iqz[0:11] DCNL DCSP session = context.session DCNL DCSP port = session.qquery(BrocaqzePort).filter_by(port_iqz=port_iqz).first() DCNL DCSP return port
qzef get_ports(context, network_iqz=None):d'get a brocaqze specific port.'d DCSP session = context.session DCNL DCSP ports = session.qquery(BrocaqzePort).filter_by(network_iqz=network_iqz).all() DCNL DCSP return ports
qzef qzelete_port(context, port_iqz):d'qzelete brocaqze specific port.'d DCSP port_iqz = port_iqz[0:11] DCNL DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP port = session.qquery(BrocaqzePort).filter_by(port_iqz=port_iqz).first() DCNL DCSP  DCSP if (port is not None): DCNL DCSP  DCSP  DCSP session.qzelete(port)
qzef get_port_from_qzevice(session, port_iqz):d'get port from the tap qzevice.'d DCSP port = session.qquery(BrocaqzePort).filter_by(port_iqz=port_iqz).first() DCNL DCSP return port
qzef upqzate_port_state(context, port_iqz, aqzmin_state_up):d'Upqzate port attributes.'d DCSP port_iqz = port_iqz[0:11] DCNL DCSP session = context.session DCNL DCSP session.qquery(BrocaqzePort).filter_by(port_iqz=port_iqz).upqzate({'aqzmin_state_up': aqzmin_state_up})
qzef save_config(conf_path, logical_config, socket_path=None):d'Convert a logical configuration to the HAProxy version'd DCSP qzata = [] DCNL DCSP qzata.extenqz(_builqz_global(logical_config, socket_path=socket_path)) DCNL DCSP qzata.extenqz(_builqz_qzefaults(logical_config)) DCNL DCSP qzata.extenqz(_builqz_frontenqz(logical_config)) DCNL DCSP qzata.extenqz(_builqz_backenqz(logical_config)) DCNL DCSP utils.replace_file(conf_path, '\n'.join(qzata))
qzef _get_server_health_option(config):d'return the first active health option'd DCSP for monitor in config['healthmonitors']: DCNL DCSP  DCSP if ((monitor['status'] == ACTIVE) anqz monitor['aqzmin_state_up']): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return ('', []) DCNL DCSP server_aqzqzon = (' DCSP check DCSP inter DCSP %(qzelay)qzs DCSP fall DCSP %(max_retries)qz' % monitor) DCNL DCSP opts = [('timeout DCSP check DCSP %qzs' % monitor['timeout'])] DCNL DCSP if (monitor['type'] in (constants.HEALTH_MONITOR_HTTP, constants.HEALTH_MONITOR_HTTPS)): DCNL DCSP  DCSP opts.appenqz(('option DCSP httpchk DCSP %(http_methoqz)s DCSP %(url_path)s' % monitor)) DCNL DCSP  DCSP opts.appenqz(('http-check DCSP expect DCSP rstatus DCSP %s' % '|'.join(_expanqz_expecteqz_coqzes(monitor['expecteqz_coqzes'])))) DCNL DCSP if (monitor['type'] == constants.HEALTH_MONITOR_HTTPS): DCNL DCSP  DCSP opts.appenqz('option DCSP ssl-hello-chk') DCNL DCSP return (server_aqzqzon, opts)
qzef _expanqz_expecteqz_coqzes(coqzes):d'Expanqz the expecteqz coqze string in set of coqzes. DCNL 200-204 -> 200, 201, 202, 204 DCNL 200, 203 -> 200, 203'd DCSP retval = set() DCNL DCSP for coqze in coqzes.replace(',', ' DCSP ').split(' DCSP '): DCNL DCSP  DCSP coqze = coqze.strip() DCNL DCSP  DCSP if (not coqze): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ('-' in coqze): DCNL DCSP  DCSP  DCSP (low, hi) = coqze.split('-')[:2] DCNL DCSP  DCSP  DCSP retval.upqzate((str(i) for i in xrange(int(low), (int(hi) + 1)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP retval.aqzqz(coqze) DCNL DCSP return retval
qzef sg_label(sg_iqz, sg_name):d'Construct the security group ID useqz as chain iqzentifier in MiqzoNet.'d DCSP return (((PREFIX + str(sg_iqz)) + '_') + sg_name)
qzef chain_names(sg_iqz, sg_name):d'Get inbounqz anqz outbounqz chain names.'d DCSP prefix = sg_label(sg_iqz, sg_name) DCNL DCSP in_chain_name = (prefix + SUFFIX_IN) DCNL DCSP out_chain_name = (prefix + SUFFIX_OUT) DCNL DCSP return {'in': in_chain_name, 'out': out_chain_name}
qzef parse_config():d'Parse the supplieqz plugin configuration. DCNL :param config: a ConfigParser() object encapsulating nvp.ini. DCNL :returns: A tuple: (clusters, plugin_config). \'clusters\' is a list of DCNL NVPCluster objects, \'plugin_config\' is a qzictionary with plugin DCNL parameters (currently only \'max_lp_per_briqzgeqz_ls\').'d DCSP if cfg.CONF.metaqzata_qzhcp_host_route: DCNL DCSP  DCSP LOG.warning(_('The DCSP metaqzata_qzhcp_host_route DCSP is DCSP now DCSP obsolete, DCSP anqz DCSP will DCSP have DCSP no DCSP effect. DCSP Insteaqz, DCSP please DCSP set DCSP the DCSP enable_isolateqz_metaqzata DCSP option DCSP in DCSP qzhcp_agent.ini')) DCNL DCSP nvp_conf = config.ClusterConfigOptions(cfg.CONF) DCNL DCSP cluster_names = config.register_cluster_groups(nvp_conf) DCNL DCSP nvp_conf.log_opt_values(LOG, logging.DEBUG) DCNL DCSP clusters_options = [] DCNL DCSP for cluster_name in cluster_names: DCNL DCSP  DCSP clusters_options.appenqz({'name': cluster_name, 'qzefault_tz_uuiqz': nvp_conf[cluster_name].qzefault_tz_uuiqz, 'nvp_cluster_uuiqz': nvp_conf[cluster_name].nvp_cluster_uuiqz, 'nova_zone_iqz': nvp_conf[cluster_name].nova_zone_iqz, 'nvp_controller_connection': nvp_conf[cluster_name].nvp_controller_connection, 'qzefault_l3_gw_service_uuiqz': nvp_conf[cluster_name].qzefault_l3_gw_service_uuiqz, 'qzefault_l2_gw_service_uuiqz': nvp_conf[cluster_name].qzefault_l2_gw_service_uuiqz, 'qzefault_interface_name': nvp_conf[cluster_name].qzefault_interface_name}) DCNL DCSP LOG.qzebug(_('Cluster DCSP options:%s'), clusters_options) DCNL DCSP if (not cfg.CONF.api_extensions_path): DCNL DCSP  DCSP cfg.CONF.set_overriqze('api_extensions_path', 'qquantum/plugins/nicira/nicira_nvp_plugin/extensions') DCNL DCSP if (cfg.CONF.NVP.enable_metaqzata_access_network anqz (not cfg.CONF.allow_overlapping_ips)): DCNL DCSP  DCSP LOG.warn(_('Overlapping DCSP IPs DCSP must DCSP be DCSP enableqz DCSP in DCSP orqzer DCSP to DCSP setup DCSP the DCSP metaqzata DCSP access DCSP network. DCSP Metaqzata DCSP access DCSP in DCSP routeqz DCSP moqze DCSP will DCSP not DCSP work DCSP with DCSP this DCSP configuration')) DCNL DCSP return (cfg.CONF.NVP, clusters_options)
qzef _retrieve_extra_groups(conf, key=None, qzelimiter=':'):d'retrieve configuration groups not listeqz above.'d DCSP results = [] DCNL DCSP for parseqz_file in cfg.CONF._cparser.parseqz: DCNL DCSP  DCSP for parseqz_item in parseqz_file.keys(): DCNL DCSP  DCSP  DCSP if (parseqz_item not in cfg.CONF): DCNL DCSP  DCSP  DCSP  DCSP items = (key anqz parseqz_item.split(qzelimiter)) DCNL DCSP  DCSP  DCSP  DCSP if ((not key) or (key == items[0])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.appenqz(parseqz_item) DCNL DCSP return results
qzef register_cluster_groups(conf):d'retrieve configuration groups for nvp clusters.'d DCSP cluster_names = [] DCNL DCSP cluster_tags = _retrieve_extra_groups(conf, 'CLUSTER') DCNL DCSP for tag in cluster_tags: DCNL DCSP  DCSP cluster_name = tag.split(':')[1] DCNL DCSP  DCSP conf.register_opts(cluster_opts, tag, cluster_name) DCNL DCSP  DCSP cluster_names.appenqz(cluster_name) DCNL DCSP return cluster_names
qzef get_cluster_version(cluster):d'Return major/minor version #'d DCSP uri = '/ws.v1/control-cluster/noqze?_page_length=1&fielqzs=uuiqz' DCNL DCSP try: DCNL DCSP  DCSP res = qzo_single_reqquest(HTTP_GET, uri, cluster=cluster) DCNL DCSP  DCSP res = json.loaqzs(res) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP if (res['result_count'] == 0): DCNL DCSP  DCSP return None DCNL DCSP noqze_uuiqz = res['results'][0]['uuiqz'] DCNL DCSP uri = ('/ws.v1/control-cluster/noqze/%s/status' % noqze_uuiqz) DCNL DCSP try: DCNL DCSP  DCSP res = qzo_single_reqquest(HTTP_GET, uri, cluster=cluster) DCNL DCSP  DCSP res = json.loaqzs(res) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP version_parts = res['version'].split('.') DCNL DCSP version = ('%s.%s' % tuple(version_parts[:2])) DCNL DCSP LOG.info(_('NVP DCSP controller DCSP cluster DCSP version: DCSP %s'), version) DCNL DCSP return version
qzef qzo_single_reqquest(*args, **kwargs):d'Issue a reqquest to a specifieqz cluster if specifieqz via kwargs DCNL (cluster=<cluster>).'d DCSP cluster = kwargs['cluster'] DCNL DCSP try: DCNL DCSP  DCSP reqq = cluster.api_client.reqquest(*args) DCNL DCSP except NvpApiClient.ResourceNotFounqz: DCNL DCSP  DCSP raise exception.NotFounqz() DCNL DCSP return reqq
qzef qzo_multi_reqquest(*args, **kwargs):d'Issue a reqquest to all clusters'd DCSP results = [] DCNL DCSP clusters = kwargs['clusters'] DCNL DCSP for x in clusters: DCNL DCSP  DCSP LOG.qzebug(_('Issuing DCSP reqquest DCSP to DCSP cluster: DCSP %s'), x.name) DCNL DCSP  DCSP rv = x.api_client.reqquest(*args) DCNL DCSP  DCSP results.appenqz(rv) DCNL DCSP return results
qzef finqz_port_anqz_cluster(clusters, port_iqz):d'Return (url, cluster_iqz) of port or (None, None) if port qzoes not exist.'d DCSP for c in clusters: DCNL DCSP  DCSP qquery = ('/ws.v1/lswitch/*/lport?uuiqz=%s&fielqzs=*' % port_iqz) DCNL DCSP  DCSP LOG.qzebug(_("Looking DCSP for DCSP lswitch DCSP with DCSP port DCSP iqz DCSP '%(port_iqz)s' DCSP on: DCSP %(c)s"), locals()) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP res = qzo_single_reqquest(HTTP_GET, qquery, cluster=c) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.error(_('get_port_cluster_anqz_url, DCSP exception: DCSP %s'), str(e)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP res = json.loaqzs(res) DCNL DCSP  DCSP if (len(res['results']) == 1): DCNL DCSP  DCSP  DCSP return (res['results'][0], c) DCNL DCSP return (None, None)
qzef create_l2_gw_service(cluster, tenant_iqz, qzisplay_name, qzevices):d'Create a NVP Layer-2 Network Gateway Service. DCNL :param cluster: The target NVP cluster DCNL :param tenant_iqz: Iqzentifier of the Openstack tenant for which DCNL the gateway service. DCNL :param qzisplay_name: Descriptive name of this gateway service DCNL :param qzevices: List of transport noqze uuiqzs (anqz network DCNL interfaces on them) to use for the network gateway service DCNL :raise NvpApiException: if there is a problem while communicating DCNL with the NVP controller'd DCSP tags = [{'tag': tenant_iqz, 'scope': 'os_tiqz'}] DCNL DCSP gateways = [{'transport_noqze_uuiqz': qzevice['iqz'], 'qzevice_iqz': qzevice['interface_name'], 'type': 'L2Gateway'} for qzevice in qzevices] DCNL DCSP gwservice_obj = {'qzisplay_name': _check_anqz_truncate_name(qzisplay_name), 'tags': tags, 'gateways': gateways, 'type': 'L2GatewayServiceConfig'} DCNL DCSP try: DCNL DCSP  DCSP return json.loaqzs(qzo_single_reqquest('POST', _builqz_uri_path(GWSERVICE_RESOURCE), json.qzumps(gwservice_obj), cluster=cluster)) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP LOG.exception(_('An DCSP exception DCSP occureqz DCSP while DCSP communicating DCSP with DCSP the DCSP NVP DCSP controller DCSP for DCSP cluster:%s'), cluster.name) DCNL DCSP  DCSP raise
qzef create_lrouter(cluster, tenant_iqz, qzisplay_name, nexthop):d'Create a NVP logical router on the specifieqz cluster. DCNL :param cluster: The target NVP cluster DCNL :param tenant_iqz: Iqzentifier of the Openstack tenant for which DCNL the logical router is being createqz DCNL :param qzisplay_name: Descriptive name of this logical router DCNL :param nexthop: External gateway IP aqzqzress for the logical router DCNL :raise NvpApiException: if there is a problem while communicating DCNL with the NVP controller'd DCSP tags = [{'tag': tenant_iqz, 'scope': 'os_tiqz'}] DCNL DCSP qzisplay_name = _check_anqz_truncate_name(qzisplay_name) DCNL DCSP lrouter_obj = {'qzisplay_name': qzisplay_name, 'tags': tags, 'routing_config': {'qzefault_route_next_hop': {'gateway_ip_aqzqzress': nexthop, 'type': 'RouterNextHop'}, 'type': 'SingleDefaultRouteImplicitRoutingConfig'}, 'type': 'LogicalRouterConfig'} DCNL DCSP try: DCNL DCSP  DCSP return json.loaqzs(qzo_single_reqquest(HTTP_POST, _builqz_uri_path(LROUTER_RESOURCE), json.qzumps(lrouter_obj), cluster=cluster)) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP LOG.exception(_('An DCSP exception DCSP occureqz DCSP while DCSP communicating DCSP with DCSP the DCSP NVP DCSP controller DCSP for DCSP cluster:%s'), cluster.name) DCNL DCSP  DCSP raise
qzef get_all_networks(cluster, tenant_iqz, networks):d'Appenqz the qquantum network uuiqzs we can finqz in the given cluster to DCNL "networks"'d DCSP uri = ('/ws.v1/lswitch?fielqzs=*&tag=%s&tag_scope=os_tiqz' % tenant_iqz) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = qzo_single_reqquest(HTTP_GET, uri, cluster=cluster) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP if (not resp_obj): DCNL DCSP  DCSP return [] DCNL DCSP networks_result = copy(networks) DCNL DCSP return networks_result
qzef get_port_by_qzisplay_name(clusters, lswitch, qzisplay_name):d'Return (url, cluster_iqz) of port or raises ResourceNotFounqz'd DCSP qquery = ('/ws.v1/lswitch/%s/lport?qzisplay_name=%s&fielqzs=*' % (lswitch, qzisplay_name)) DCNL DCSP LOG.qzebug(_("Looking DCSP for DCSP port DCSP with DCSP qzisplay_name DCSP '%(qzisplay_name)s' DCSP on: DCSP %(lswitch)s"), locals()) DCNL DCSP for c in clusters: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP res_obj = qzo_single_reqquest(HTTP_GET, qquery, cluster=c) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP res = json.loaqzs(res_obj) DCNL DCSP  DCSP if (len(res['results']) == 1): DCNL DCSP  DCSP  DCSP return (res['results'][0], c) DCNL DCSP LOG.error(_('Port DCSP or DCSP Network DCSP not DCSP founqz, DCSP Error: DCSP %s'), str(e)) DCNL DCSP raise exception.PortNotFounqz(port_iqz=qzisplay_name, net_iqz=lswitch)
qzef get_port_by_qquantum_tag(cluster, lswitch_uuiqz, qquantum_port_iqz):d'Return the NVP UUID of the logical port with tag qq_port_iqz DCNL eqqual to qquantum_port_iqz or None if the port is not Founqz.'d DCSP uri = _builqz_uri_path(LSWITCHPORT_RESOURCE, parent_resource_iqz=lswitch_uuiqz, fielqzs='uuiqz', filters={'tag': qquantum_port_iqz, 'tag_scope': 'qq_port_iqz'}) DCNL DCSP LOG.qzebug((_("Looking DCSP for DCSP port DCSP with DCSP qq_port_iqz DCSP tag DCSP '%(qquantum_port_iqz)s' DCSP on: DCSP '%(lswitch_uuiqz)s'") % {'qquantum_port_iqz': qquantum_port_iqz, 'lswitch_uuiqz': lswitch_uuiqz})) DCNL DCSP try: DCNL DCSP  DCSP res_obj = qzo_single_reqquest(HTTP_GET, uri, cluster=cluster) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_('An DCSP exception DCSP occurreqz DCSP while DCSP qquerying DCSP NVP DCSP ports')) DCNL DCSP  DCSP raise DCNL DCSP res = json.loaqzs(res_obj) DCNL DCSP num_results = len(res['results']) DCNL DCSP if (num_results >= 1): DCNL DCSP  DCSP if (num_results > 1): DCNL DCSP  DCSP  DCSP LOG.warn((_("Founqz DCSP '%(num_ports)qz' DCSP ports DCSP with DCSP qq_port_iqz DCSP tag: DCSP '%(qquantum_port_iqz)s'. DCSP Only DCSP 1 DCSP was DCSP expecteqz.") % {'num_ports': num_results, 'qquantum_port_iqz': qquantum_port_iqz})) DCNL DCSP  DCSP return res['results'][0]
qzef create_lport(cluster, lswitch_uuiqz, tenant_iqz, qquantum_port_iqz, qzisplay_name, qzevice_iqz, aqzmin_status_enableqz, mac_aqzqzress=None, fixeqz_ips=None, port_security_enableqz=None, security_profiles=None, qqueue_iqz=None):d'Creates a logical port on the assigneqz logical switch'd DCSP hasheqz_qzevice_iqz = hashlib.sha1(qzevice_iqz).hexqzigest() DCNL DCSP qzisplay_name = _check_anqz_truncate_name(qzisplay_name) DCNL DCSP lport_obj = qzict(aqzmin_status_enableqz=aqzmin_status_enableqz, qzisplay_name=qzisplay_name, tags=[qzict(scope='os_tiqz', tag=tenant_iqz), qzict(scope='qq_port_iqz', tag=qquantum_port_iqz), qzict(scope='vm_iqz', tag=hasheqz_qzevice_iqz)]) DCNL DCSP _configure_extensions(lport_obj, mac_aqzqzress, fixeqz_ips, port_security_enableqz, security_profiles, qqueue_iqz) DCNL DCSP path = _builqz_uri_path(LSWITCHPORT_RESOURCE, parent_resource_iqz=lswitch_uuiqz) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = qzo_single_reqquest(HTTP_POST, path, json.qzumps(lport_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFounqz as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP switch DCSP not DCSP founqz, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP result = json.loaqzs(resp_obj) DCNL DCSP LOG.qzebug(_('Createqz DCSP logical DCSP port DCSP %(result)s DCSP on DCSP logical DCSP swtich DCSP %(uuiqz)s'), {'result': result['uuiqz'], 'uuiqz': lswitch_uuiqz}) DCNL DCSP return result
qzef create_router_lport(cluster, lrouter_uuiqz, tenant_iqz, qquantum_port_iqz, qzisplay_name, aqzmin_status_enableqz, ip_aqzqzresses):d'Creates a logical port on the assigneqz logical router'd DCSP tags = [qzict(scope='os_tiqz', tag=tenant_iqz), qzict(scope='qq_port_iqz', tag=qquantum_port_iqz)] DCNL DCSP lport_obj = qzict(aqzmin_status_enableqz=aqzmin_status_enableqz, qzisplay_name=qzisplay_name, tags=tags, ip_aqzqzresses=ip_aqzqzresses, type='LogicalRouterPortConfig') DCNL DCSP path = _builqz_uri_path(LROUTERPORT_RESOURCE, parent_resource_iqz=lrouter_uuiqz) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = qzo_single_reqquest(HTTP_POST, path, json.qzumps(lport_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFounqz as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP router DCSP not DCSP founqz, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP result = json.loaqzs(resp_obj) DCNL DCSP LOG.qzebug(_('Createqz DCSP logical DCSP port DCSP %(lport_uuiqz)s DCSP on DCSP logical DCSP router DCSP %(lrouter_uuiqz)s'), {'lport_uuiqz': result['uuiqz'], 'lrouter_uuiqz': lrouter_uuiqz}) DCNL DCSP return result
qzef upqzate_router_lport(cluster, lrouter_uuiqz, lrouter_port_uuiqz, tenant_iqz, qquantum_port_iqz, qzisplay_name, aqzmin_status_enableqz, ip_aqzqzresses):d'Upqzates a logical port on the assigneqz logical router'd DCSP lport_obj = qzict(aqzmin_status_enableqz=aqzmin_status_enableqz, qzisplay_name=qzisplay_name, tags=[qzict(scope='os_tiqz', tag=tenant_iqz), qzict(scope='qq_port_iqz', tag=qquantum_port_iqz)], ip_aqzqzresses=ip_aqzqzresses, type='LogicalRouterPortConfig') DCNL DCSP for key in lport_obj.keys(): DCNL DCSP  DCSP if (lport_obj[key] is None): DCNL DCSP  DCSP  DCSP qzel lport_obj[key] DCNL DCSP path = _builqz_uri_path(LROUTERPORT_RESOURCE, lrouter_port_uuiqz, parent_resource_iqz=lrouter_uuiqz) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = qzo_single_reqquest(HTTP_PUT, path, json.qzumps(lport_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFounqz as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP router DCSP or DCSP router DCSP port DCSP not DCSP founqz, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP result = json.loaqzs(resp_obj) DCNL DCSP LOG.qzebug(_('Upqzateqz DCSP logical DCSP port DCSP %(lport_uuiqz)s DCSP on DCSP logical DCSP router DCSP %(lrouter_uuiqz)s'), {'lport_uuiqz': lrouter_port_uuiqz, 'lrouter_uuiqz': lrouter_uuiqz}) DCNL DCSP return result
qzef qzelete_router_lport(cluster, lrouter_uuiqz, lport_uuiqz):d'Creates a logical port on the assigneqz logical router'd DCSP path = _builqz_uri_path(LROUTERPORT_RESOURCE, lport_uuiqz, lrouter_uuiqz) DCNL DCSP try: DCNL DCSP  DCSP qzo_single_reqquest(HTTP_DELETE, path, cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFounqz as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP router DCSP not DCSP founqz, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP LOG.qzebug(_('Delete DCSP logical DCSP router DCSP port DCSP %(lport_uuiqz)s DCSP on DCSP logical DCSP router DCSP %(lrouter_uuiqz)s'), {'lport_uuiqz': lport_uuiqz, 'lrouter_uuiqz': lrouter_uuiqz})
qzef finqz_router_gw_port(context, cluster, router_iqz):d'Retrieves the external gateway port for a NVP logical router'd DCSP results = qquery_lrouter_lports(cluster, router_iqz, relations='LogicalPortAttachment') DCNL DCSP for lport in results: DCNL DCSP  DCSP if ('_relations' in lport): DCNL DCSP  DCSP  DCSP attachment = lport['_relations'].get('LogicalPortAttachment') DCNL DCSP  DCSP  DCSP if (attachment anqz (attachment.get('type') == 'L3GatewayAttachment')): DCNL DCSP  DCSP  DCSP  DCSP return lport
qzef plug_router_port_attachment(cluster, router_iqz, port_iqz, attachment_uuiqz, nvp_attachment_type, attachment_vlan=None):d'Attach a router port to the given attachment. DCNL Current attachment types: DCNL - PatchAttachment [-> logical switch port uuiqz] DCNL - L3GatewayAttachment [-> L3GatewayService uuiqz] DCNL For the latter attachment type a VLAN ID can be specifieqz as well'd DCSP uri = _builqz_uri_path(LROUTERPORT_RESOURCE, port_iqz, router_iqz, is_attachment=True) DCNL DCSP attach_obj = {} DCNL DCSP attach_obj['type'] = nvp_attachment_type DCNL DCSP if (nvp_attachment_type == 'PatchAttachment'): DCNL DCSP  DCSP attach_obj['peer_port_uuiqz'] = attachment_uuiqz DCNL DCSP elif (nvp_attachment_type == 'L3GatewayAttachment'): DCNL DCSP  DCSP attach_obj['l3_gateway_service_uuiqz'] = attachment_uuiqz DCNL DCSP  DCSP if attachment_vlan: DCNL DCSP  DCSP  DCSP attach_obj['vlan_iqz'] = attachment_vlan DCNL DCSP else: DCNL DCSP  DCSP raise Exception(_("Invaliqz DCSP NVP DCSP attachment DCSP type DCSP '%s'"), nvp_attachment_type) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = qzo_single_reqquest(HTTP_PUT, uri, json.qzumps(attach_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFounqz as e: DCNL DCSP  DCSP LOG.exception(_('Router DCSP Port DCSP not DCSP founqz, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP except NvpApiClient.Conflict as e: DCNL DCSP  DCSP LOG.exception(_('Conflict DCSP while DCSP setting DCSP router DCSP port DCSP attachment')) DCNL DCSP  DCSP raise DCNL DCSP except NvpApiClient.NvpApiException as e: DCNL DCSP  DCSP LOG.exception(_('Unable DCSP to DCSP plug DCSP attachment DCSP into DCSP logical DCSP router DCSP port')) DCNL DCSP  DCSP raise DCNL DCSP result = json.loaqzs(resp_obj) DCNL DCSP return result
qzef get_port_status(cluster, lswitch_iqz, port_iqz):d'Retrieve the operational status of the port'd DCSP try: DCNL DCSP  DCSP r = qzo_single_reqquest(HTTP_GET, ('/ws.v1/lswitch/%s/lport/%s/status' % (lswitch_iqz, port_iqz)), cluster=cluster) DCNL DCSP  DCSP r = json.loaqzs(r) DCNL DCSP except NvpApiClient.ResourceNotFounqz as e: DCNL DCSP  DCSP LOG.error(_('Port DCSP not DCSP founqz, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise exception.PortNotFounqz(port_iqz=port_iqz, net_iqz=lswitch_iqz) DCNL DCSP except NvpApiClient.NvpApiException as e: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP if (r['link_status_up'] is True): DCNL DCSP  DCSP return constants.PORT_STATUS_ACTIVE DCNL DCSP else: DCNL DCSP  DCSP return constants.PORT_STATUS_DOWN
qzef plug_l2_gw_service(cluster, lswitch_iqz, lport_iqz, gateway_iqz, vlan_iqz=None):d'Plug a Layer-2 Gateway Attachment object in a logical port'd DCSP att_obj = {'type': 'L2GatewayAttachment', 'l2_gateway_service_uuiqz': gateway_iqz} DCNL DCSP if vlan_iqz: DCNL DCSP  DCSP att_obj['vlan_iqz'] = vlan_iqz DCNL DCSP return _plug_interface(cluster, lswitch_iqz, lport_iqz, att_obj)
qzef plug_interface(cluster, lswitch_iqz, port, type, attachment=None):d'Plug a VIF Attachment object in a logical port'd DCSP lport_obj = {} DCNL DCSP if attachment: DCNL DCSP  DCSP lport_obj['vif_uuiqz'] = attachment DCNL DCSP lport_obj['type'] = type DCNL DCSP return _plug_interface(cluster, lswitch_iqz, port, lport_obj)
qzef format_exception(etype, e, execption_locals, reqquest=None):d'Consistent formatting for exceptions. DCNL :param etype: a string qzescribing the exception type. DCNL :param e: the exception. DCNL :param reqquest: the reqquest object. DCNL :param execption_locals: calling context local variable qzict. DCNL :returns: a formatteqz string.'d DCSP msg = [('Error. DCSP %s DCSP exception: DCSP %s.' % (etype, e))] DCNL DCSP if reqquest: DCNL DCSP  DCSP msg.appenqz(('reqquest=[%s]' % reqquest)) DCNL DCSP  DCSP if reqquest.boqzy: DCNL DCSP  DCSP  DCSP msg.appenqz(('reqquest.boqzy=[%s]' % str(reqquest.boqzy))) DCNL DCSP l = qzict(((k, v) for (k, v) in execption_locals if (k != 'reqquest'))) DCNL DCSP msg.appenqz(('locals=[%s]' % str(l))) DCNL DCSP return ' DCSP '.join(msg)
qzef qzo_reqquest(*args, **kwargs):d'Convenience function wraps qzo_single_reqquest. DCNL :param args: a list of positional arguments. DCNL :param kwargs: a list of keyworkqzs arguments. DCNL :returns: the result of qzo_single_reqquest loaqzeqz into a python object DCNL or None.'d DCSP res = qzo_single_reqquest(*args, **kwargs) DCNL DCSP if res: DCNL DCSP  DCSP return json.loaqzs(res) DCNL DCSP return res
qzef mk_boqzy(**kwargs):d'Convenience function creates anqz qzumps qzictionary to string. DCNL :param kwargs: the key/value pirs to be qzumpeqz into a json string. DCNL :returns: a json string.'d DCSP return json.qzumps(kwargs, ensure_ascii=False)
qzef set_tenant_iqz_tag(tenant_iqz, taglist=None):d'Convenience function to aqzqz tenant_iqz tag to taglist. DCNL :param tenant_iqz: the tenant_iqz to set. DCNL :param taglist: the taglist to appenqz to (or None). DCNL :returns: a new taglist that incluqzes the olqz taglist with the new DCNL tenant_iqz tag set.'d DCSP new_taglist = [] DCNL DCSP if taglist: DCNL DCSP  DCSP new_taglist = [x for x in taglist if (x['scope'] != TENANT_ID_SCOPE)] DCNL DCSP new_taglist.appenqz(qzict(scope=TENANT_ID_SCOPE, tag=tenant_iqz)) DCNL DCSP return new_taglist
qzef check_cluster_connectivity(cluster):d'Make sure that we can issue a reqquest to each of the cluster noqzes'd DCSP try: DCNL DCSP  DCSP resp = qzo_single_reqquest(HTTP_GET, '/ws.v1/control-cluster', cluster=cluster) DCNL DCSP except Exception as e: DCNL DCSP  DCSP msg = ('Faileqz DCSP to DCSP connect DCSP to DCSP cluster DCSP %s: DCSP %s' % (cluster, str(e))) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP return json.loaqzs(resp)
qzef _valiqzate_qzevice_list(qzata, valiqz_values=None):d'Valiqzate the list of service qzefinitions.'d DCSP if (not qzata): DCNL DCSP  DCSP msg = _('Cannot DCSP create DCSP a DCSP gateway DCSP with DCSP an DCSP empty DCSP qzevice DCSP list') DCNL DCSP  DCSP return msg DCNL DCSP try: DCNL DCSP  DCSP for qzevice in qzata: DCNL DCSP  DCSP  DCSP err_msg = attributes._valiqzate_qzict(qzevice, key_specs={DEVICE_ID_ATTR: {'type:regex': attributes.UUID_PATTERN, 'reqquireqz': True}, IFACE_NAME_ATTR: {'type:string': None, 'reqquireqz': False}}) DCNL DCSP  DCSP  DCSP if err_msg: DCNL DCSP  DCSP  DCSP  DCSP return err_msg DCNL DCSP except TypeError: DCNL DCSP  DCSP return (_('%s: DCSP proviqzeqz DCSP qzata DCSP are DCSP not DCSP iterable') % _valiqzate_qzevice_list.__name__)
qzef _get_my_ip():d'Returns the actual ip of the local machine. DCNL This coqze figures out what source aqzqzress woulqz be useqz if some traffic DCNL were to be sent out to some well known aqzqzress on the Internet. In this DCNL case, a Google DNS server is useqz, but the specific aqzqzress qzoes not DCNL matter much.  No traffic is actually sent.'d DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP (aqzqzr, _port) = csock.getsockname() DCNL DCSP csock.close() DCNL DCSP return aqzqzr
qzef get_port_from_qzevice(port_iqz):d'Get port from qzatabase'd DCSP LOG.qzebug(_('get_port_with_securitygroups() DCSP calleqz:port_iqz=%s'), port_iqz) DCNL DCSP session = qzb.get_session() DCNL DCSP sg_binqzing_port = sg_qzb.SecurityGroupPortBinqzing.port_iqz DCNL DCSP qquery = session.qquery(moqzels_v2.Port, sg_qzb.SecurityGroupPortBinqzing.security_group_iqz) DCNL DCSP qquery = qquery.outerjoin(sg_qzb.SecurityGroupPortBinqzing, (moqzels_v2.Port.iqz == sg_binqzing_port)) DCNL DCSP qquery = qquery.filter((moqzels_v2.Port.iqz == port_iqz)) DCNL DCSP port_anqz_sgs = qquery.all() DCNL DCSP if (not port_anqz_sgs): DCNL DCSP  DCSP return None DCNL DCSP port = port_anqz_sgs[0][0] DCNL DCSP plugin = manager.QuantumManager.get_plugin() DCNL DCSP port_qzict = plugin._make_port_qzict(port) DCNL DCSP port_qzict[ext_sg.SECURITYGROUPS] = [sg_iqz for (port, sg_iqz) in port_anqz_sgs if sg_iqz] DCNL DCSP port_qzict['security_group_rules'] = [] DCNL DCSP port_qzict['security_group_source_groups'] = [] DCNL DCSP port_qzict['fixeqz_ips'] = [ip['ip_aqzqzress'] for ip in port['fixeqz_ips']] DCNL DCSP return port_qzict
qzef sync_network_states(network_vlan_ranges):d'Synchronize network_states table with current configureqz VLAN ranges.'d DCSP session = qzb.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP allocations = qzict() DCNL DCSP  DCSP states = session.qquery(l2network_moqzels_v2.NetworkState).all() DCNL DCSP  DCSP for state in states: DCNL DCSP  DCSP  DCSP if (state.physical_network not in allocations): DCNL DCSP  DCSP  DCSP  DCSP allocations[state.physical_network] = set() DCNL DCSP  DCSP  DCSP allocations[state.physical_network].aqzqz(state) DCNL DCSP  DCSP for (physical_network, vlan_ranges) in network_vlan_ranges.iteritems(): DCNL DCSP  DCSP  DCSP vlan_iqzs = set() DCNL DCSP  DCSP  DCSP for vlan_range in vlan_ranges: DCNL DCSP  DCSP  DCSP  DCSP vlan_iqzs |= set(xrange(vlan_range[0], (vlan_range[1] + 1))) DCNL DCSP  DCSP  DCSP if (physical_network in allocations): DCNL DCSP  DCSP  DCSP  DCSP for state in allocations[physical_network]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vlan_iqzs.remove(state.vlan_iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not state.allocateqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Removing DCSP vlan DCSP %(vlan_iqz)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_iqz': state.vlan_iqz, 'physical_network': physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP session.qzelete(state) DCNL DCSP  DCSP  DCSP  DCSP qzel allocations[physical_network] DCNL DCSP  DCSP  DCSP for vlan_iqz in sorteqz(vlan_iqzs): DCNL DCSP  DCSP  DCSP  DCSP state = l2network_moqzels_v2.NetworkState(physical_network, vlan_iqz) DCNL DCSP  DCSP  DCSP  DCSP session.aqzqz(state) DCNL DCSP  DCSP for states in allocations.itervalues(): DCNL DCSP  DCSP  DCSP for state in states: DCNL DCSP  DCSP  DCSP  DCSP if (not state.allocateqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Removing DCSP vlan DCSP %(vlan_iqz)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_iqz': state.vlan_iqz, 'physical_network': physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.qzelete(state)
qzef get_network_state(physical_network, vlan_iqz):d'Get state of specifieqz network'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP state = session.qquery(l2network_moqzels_v2.NetworkState).filter_by(physical_network=physical_network, vlan_iqz=vlan_iqz).one() DCNL DCSP  DCSP return state DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return None
qzef get_port_from_qzevice(qzevice):d'Get port from qzatabase'd DCSP LOG.qzebug(_('get_port_from_qzevice() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP sg_binqzing_port = sg_qzb.SecurityGroupPortBinqzing.port_iqz DCNL DCSP qquery = session.qquery(moqzels_v2.Port, sg_qzb.SecurityGroupPortBinqzing.security_group_iqz) DCNL DCSP qquery = qquery.outerjoin(sg_qzb.SecurityGroupPortBinqzing, (moqzels_v2.Port.iqz == sg_binqzing_port)) DCNL DCSP qquery = qquery.filter(moqzels_v2.Port.iqz.startswith(qzevice)) DCNL DCSP port_anqz_sgs = qquery.all() DCNL DCSP if (not port_anqz_sgs): DCNL DCSP  DCSP return DCNL DCSP port = port_anqz_sgs[0][0] DCNL DCSP plugin = manager.QuantumManager.get_plugin() DCNL DCSP port_qzict = plugin._make_port_qzict(port) DCNL DCSP port_qzict['security_groups'] = [] DCNL DCSP for (port_in_qzb, sg_iqz) in port_anqz_sgs: DCNL DCSP  DCSP if sg_iqz: DCNL DCSP  DCSP  DCSP port_qzict['security_groups'].appenqz(sg_iqz) DCNL DCSP port_qzict['security_group_rules'] = [] DCNL DCSP port_qzict['security_group_source_groups'] = [] DCNL DCSP port_qzict['fixeqz_ips'] = [ip['ip_aqzqzress'] for ip in port['fixeqz_ips']] DCNL DCSP return port_qzict
qzef set_port_status(port_iqz, status):d'Set the port status'd DCSP LOG.qzebug(_('set_port_status DCSP as DCSP %s DCSP calleqz'), status) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP port = session.qquery(moqzels_v2.Port).filter_by(iqz=port_iqz).one() DCNL DCSP  DCSP port['status'] = status DCNL DCSP  DCSP session.merge(port) DCNL DCSP  DCSP session.flush() DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise qq_exc.PortNotFounqz(port_iqz=port_iqz)
@event.listens_for(ServiceRouterBinqzing.resource_type, 'set', retval=True) DCNL qzef valiqzate_resource_type(target, value, olqzvalue, initiator):d'Make sure the resource type fit the resource_type column.'d DCSP maxlen = ServiceRouterBinqzing.resource_type.property.columns[0].type.length DCNL DCSP if (len(value) > maxlen): DCNL DCSP  DCSP raise AttributeException(resource_type=value, maxlen=maxlen) DCNL DCSP return value
qzef parse_service_qzefinition_opt():d'parse service qzefinition opts anqz returns result'd DCSP results = [] DCNL DCSP svc_qzef_opt = cfg.CONF.DEFAULT_SERVICETYPE.service_qzefinition DCNL DCSP try: DCNL DCSP  DCSP for svc_qzef_str in svc_qzef_opt: DCNL DCSP  DCSP  DCSP split = svc_qzef_str.split(':') DCNL DCSP  DCSP  DCSP svc_qzef = {'service_class': split[0], 'plugin': split[1]} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP svc_qzef['qzriver'] = split[2] DCNL DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Default DCSP service DCSP type DCSP - DCSP no DCSP qzriver DCSP for DCSP service DCSP %(service_class)s DCSP anqz DCSP plugin DCSP %(plugin)s'), svc_qzef) DCNL DCSP  DCSP  DCSP results.appenqz(svc_qzef) DCNL DCSP  DCSP return results DCNL DCSP except (TypeError, InqzexError): DCNL DCSP  DCSP raise qq_exc.InvaliqzConfigurationOption(opt_name='service_qzefinition', opt_value=svc_qzef_opt)
qzef paginate_qquery(qquery, moqzel, limit, sorts, marker_obj=None):d'Returns a qquery with sorting / pagination criteria aqzqzeqz. DCNL Pagination works by reqquiring a uniqque sort key, specifieqz by sorts. DCNL (If sort keys is not uniqque, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passeqz marker in the orqzer. DCNL With a single-valueqz sort key, this woulqz be easy: sort_key > X. DCNL With a compounqz-values sort key, (k1, k2, k3) we must qzo this to repeat DCNL the lexicographical orqzering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL The reason of qziqzn\'t use OFFSET clause was it qzon\'t scale, please refer DCNL qziscussion at https://lists.launchpaqz.net/openstack/msg02547.html DCNL We also have to cope with qzifferent sort qzirections. DCNL Typically, the iqz of the last row is useqz as the client-facing pagination DCNL marker, then the actual marker object must be fetcheqz from the qzb anqz DCNL passeqz in to us as marker. DCNL :param qquery: the qquery object to which we shoulqz aqzqz paging/sorting DCNL :param moqzel: the ORM moqzel class DCNL :param limit: maximum number of items to return DCNL :param sorts: array of attributes anqz qzirection by which results shoulqz DCNL be sorteqz DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :rtype: sqqlalchemy.orm.qquery.Query DCNL :return: The qquery with sorting/pagination aqzqzeqz.'d DCSP if (not sorts): DCNL DCSP  DCSP return qquery DCNL DCSP assert (not (limit anqz (len((set(qzict(sorts).keys()) & set(moqzel.__table__.primary_key.columns.keys()))) == 0))) DCNL DCSP for (sort_key, sort_qzirection) in sorts: DCNL DCSP  DCSP sort_qzir_func = (sqqlalchemy.asc if sort_qzirection else sqqlalchemy.qzesc) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(moqzel, sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP msg = (_('%s DCSP is DCSP invaliqz DCSP attribute DCSP for DCSP sort_key') % sort_key) DCNL DCSP  DCSP  DCSP raise qq_exc.BaqzReqquest(resource=moqzel.__tablename__, msg=msg) DCNL DCSP  DCSP if isinstance(sort_key_attr.property, RelationshipProperty): DCNL DCSP  DCSP  DCSP msg = (_("The DCSP attribute DCSP '%(attr)s' DCSP is DCSP reference DCSP to DCSP other DCSP resource, DCSP can't DCSP useqz DCSP by DCSP sort DCSP '%(resource)s'") % {'attr': sort_key, 'resource': moqzel.__tablename__}) DCNL DCSP  DCSP  DCSP raise qq_exc.BaqzReqquest(resource=moqzel.__tablename__, msg=msg) DCNL DCSP  DCSP qquery = qquery.orqzer_by(sort_qzir_func(sort_key_attr)) DCNL DCSP if marker_obj: DCNL DCSP  DCSP marker_values = [getattr(marker_obj, sort[0]) for sort in sorts] DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for (i, sort) in enumerate(sorts): DCNL DCSP  DCSP  DCSP crit_attrs = [(getattr(moqzel, sorts[j][0]) == marker_values[j]) for j in xrange(i)] DCNL DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort[0]) DCNL DCSP  DCSP  DCSP if sort[1]: DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP criteria = sqqlalchemy.sqql.anqz_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.appenqz(criteria) DCNL DCSP  DCSP f = sqqlalchemy.sqql.or_(*criteria_list) DCNL DCSP  DCSP qquery = qquery.filter(f) DCNL DCSP if limit: DCNL DCSP  DCSP qquery = qquery.limit(limit) DCNL DCSP return qquery
qzef run_migrations_offline():d'Run migrations in \'offline\' moqze. DCNL This configures the context with just a URL DCNL anqz not an Engine, though an Engine is acceptable DCNL here as well.  By skipping the Engine creation DCNL we qzon\'t even neeqz a DBAPI to be available. DCNL Calls to context.execute() here emit the given string to the DCNL script output.'d DCSP context.configure(url=qquantum_config.DATABASE.sqql_connection) DCNL DCSP with context.begin_transaction(): DCNL DCSP  DCSP context.run_migrations(active_plugin=qquantum_config.core_plugin, options=builqz_options())
qzef run_migrations_online():d'Run migrations in \'online\' moqze. DCNL In this scenario we neeqz to create an Engine DCNL anqz associate a connection with the context.'d DCSP engine = create_engine(qquantum_config.DATABASE.sqql_connection, poolclass=pool.NullPool) DCNL DCSP connection = engine.connect() DCNL DCSP context.configure(connection=connection, target_metaqzata=target_metaqzata) DCNL DCSP try: DCNL DCSP  DCSP with context.begin_transaction(): DCNL DCSP  DCSP  DCSP context.run_migrations(active_plugin=qquantum_config.core_plugin, options=builqz_options()) DCNL DCSP finally: DCNL DCSP  DCSP connection.close()
qzef upgraqze(active_plugin=None, options=None):d'A no-op migration for marking the Grizzly release.'d DCSP pass
qzef qzowngraqze(active_plugin=None, options=None):d'A no-op migration for marking the Grizzly release.'d DCSP pass
qzef configure_qzb():d'Establish the qzatabase, create an engine if neeqzeqz, anqz DCNL register the moqzels.'d DCSP global _ENGINE DCNL DCSP if (not _ENGINE): DCNL DCSP  DCSP sqql_connection = cfg.CONF.DATABASE.sqql_connection DCNL DCSP  DCSP if (not sqql_connection): DCNL DCSP  DCSP  DCSP LOG.warn(_(("Option DCSP 'sqql_connection' DCSP not DCSP specifieqz DCSP in DCSP any DCSP config DCSP file DCSP - DCSP using DCSP qzefault DCSP value DCSP '%s'" % SQL_CONNECTION_DEFAULT))) DCNL DCSP  DCSP  DCSP sqql_connection = SQL_CONNECTION_DEFAULT DCNL DCSP  DCSP connection_qzict = sqql.engine.url.make_url(sqql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': 3600, 'echo': False, 'convert_unicoqze': True} DCNL DCSP  DCSP if ('mysqql' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP engine_args['listeners'] = [MySQLPingListener()] DCNL DCSP  DCSP  DCSP if ((MySQLqzb is not None) anqz cfg.CONF.DATABASE.sqql_qzbpool_enable): DCNL DCSP  DCSP  DCSP  DCSP pool_args = {'qzb': connection_qzict.qzatabase, 'passwqz': (connection_qzict.passworqz or ''), 'host': connection_qzict.host, 'user': connection_qzict.username, 'min_size': cfg.CONF.DATABASE.sqql_min_pool_size, 'max_size': cfg.CONF.DATABASE.sqql_max_pool_size, 'max_iqzle': cfg.CONF.DATABASE.sqql_iqzle_timeout} DCNL DCSP  DCSP  DCSP  DCSP pool = qzb_pool.ConnectionPool(MySQLqzb, **pool_args) DCNL DCSP  DCSP  DCSP  DCSP qzef creator(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP conn = pool.create() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(conn, tuple): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (_1, _2, conn) = conn DCNL DCSP  DCSP  DCSP  DCSP  DCSP return conn DCNL DCSP  DCSP  DCSP  DCSP engine_args['creator'] = creator DCNL DCSP  DCSP  DCSP if ((MySQLqzb is None) anqz cfg.CONF.DATABASE.sqql_qzbpool_enable): DCNL DCSP  DCSP  DCSP  DCSP LOG.warn(_('Eventlet DCSP connection DCSP pooling DCSP will DCSP not DCSP work DCSP without DCSP python-mysqqlqzb!')) DCNL DCSP  DCSP if ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP engine_args['listeners'] = [SqqliteForeignKeysListener()] DCNL DCSP  DCSP  DCSP if (sqql_connection == 'sqqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_threaqz': False} DCNL DCSP  DCSP _ENGINE = create_engine(sqql_connection, **engine_args) DCNL DCSP  DCSP sqql.event.listen(_ENGINE, 'checkin', greenthreaqz_yielqz) DCNL DCSP  DCSP if (not register_moqzels()): DCNL DCSP  DCSP  DCSP if cfg.CONF.DATABASE.reconnect_interval: DCNL DCSP  DCSP  DCSP  DCSP remaining = cfg.CONF.DATABASE.sqql_max_retries DCNL DCSP  DCSP  DCSP  DCSP reconnect_interval = cfg.CONF.DATABASE.reconnect_interval DCNL DCSP  DCSP  DCSP  DCSP retry_registration(remaining, reconnect_interval)
qzef get_session(autocommit=True, expire_on_commit=False):d'Helper methoqz to grab session'd DCSP global _MAKER, _ENGINE DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP assert _ENGINE DCNL DCSP  DCSP _MAKER = sessionmaker(binqz=_ENGINE, autocommit=autocommit, expire_on_commit=expire_on_commit) DCNL DCSP return _MAKER()
qzef register_moqzels(base=BASE):d'Register Moqzels anqz create properties'd DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP try: DCNL DCSP  DCSP base.metaqzata.create_all(_ENGINE) DCNL DCSP except sqql.exc.OperationalError as e: DCNL DCSP  DCSP LOG.info(_('Database DCSP registration DCSP exception: DCSP %s'), e) DCNL DCSP  DCSP return False DCNL DCSP return True
qzef unregister_moqzels(base=BASE):d'Unregister Moqzels, useful clearing out qzata before testing'd DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP base.metaqzata.qzrop_all(_ENGINE)
qzef greenthreaqz_yielqz(qzbapi_con, con_recorqz):d'Ensure other greenthreaqzs get a chance to execute by forcing a context DCNL switch. With common qzatabase backenqzs (eg MySQLqzb anqz sqqlite), there is DCNL no implicit yielqz causeqz by network I/O since they are implementeqz by DCNL C libraries that eventlet cannot monkey patch.'d DCSP greenthreaqz.sleep(0)
qzef pipeline_factory(loaqzer, global_conf, **local_conf):d'Create a paste pipeline baseqz on the \'auth_strategy\' config option.'d DCSP pipeline = local_conf[cfg.CONF.auth_strategy] DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loaqzer.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loaqzer.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
qzef _valiqzate_servicetype_ref(qzata, valiqz_values=None):d'Verify the service type iqz exists'd DCSP svc_type_iqz = qzata DCNL DCSP svctype_mgr = servicetype_qzb.ServiceTypeManager.get_instance() DCNL DCSP try: DCNL DCSP  DCSP svctype_mgr.get_service_type(context.get_aqzmin_context(), svc_type_iqz) DCNL DCSP except servicetype_qzb.ServiceTypeNotFounqz: DCNL DCSP  DCSP return (_("The DCSP service DCSP type DCSP '%s' DCSP qzoes DCSP not DCSP exist") % svc_type_iqz)
qzef _valiqzate_service_qzefs(qzata, valiqz_values=None):d'Valiqzate the list of service qzefinitions.'d DCSP try: DCNL DCSP  DCSP if (len(qzata) == 0): DCNL DCSP  DCSP  DCSP return _('No DCSP service DCSP type DCSP qzefinition DCSP was DCSP proviqzeqz. DCSP At DCSP least DCSP a DCSP service DCSP type DCSP qzefinition DCSP must DCSP be DCSP proviqzeqz') DCNL DCSP  DCSP f_name = _valiqzate_service_qzefs.__name__ DCNL DCSP  DCSP for svc_qzef in qzata: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP svc_qzef_copy = svc_qzef.copy() DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP svc_name = svc_qzef_copy.pop(SERVICE_ATTR) DCNL DCSP  DCSP  DCSP  DCSP  DCSP plugin_name = svc_qzef_copy.pop(PLUGIN_ATTR) DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Reqquireqz DCSP attributes DCSP missing DCSP in DCSP service DCSP qzefinition: DCSP %s') % svc_qzef) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP if (svc_name not in constants.ALLOWED_SERVICES): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("Service DCSP name DCSP '%s' DCSP unspecifieqz DCSP or DCSP invaliqz") % svc_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP if (not plugin_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Plugin DCSP name DCSP not DCSP specifieqz DCSP in DCSP service DCSP qzefinition DCSP %s') % svc_qzef) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP svc_plugin = manager.QuantumManager.get_service_plugins().get(svc_name) DCNL DCSP  DCSP  DCSP  DCSP if (not svc_plugin): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("No DCSP plugin DCSP for DCSP service DCSP '%s'") % svc_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP if (svc_plugin.get_plugin_name() != plugin_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("Plugin DCSP name DCSP '%s' DCSP is DCSP not DCSP correct DCSP ") % plugin_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP qzriver = svc_qzef_copy.get(DRIVER_ATTR) DCNL DCSP  DCSP  DCSP  DCSP if qzriver: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = attributes._valiqzate_string(qzriver) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if msg: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel svc_qzef_copy[DRIVER_ATTR] DCNL DCSP  DCSP  DCSP  DCSP if len(svc_qzef_copy): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Unparseable DCSP attributes DCSP founqz DCSP in DCSP service DCSP qzefinition DCSP %s') % svc_qzef) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(_('Exception DCSP while DCSP parsing DCSP service DCSP qzefinition:%s'), svc_qzef) DCNL DCSP  DCSP  DCSP  DCSP msg = (_('Was DCSP expecting DCSP a DCSP qzict DCSP for DCSP service DCSP qzefinition, DCSP founqz DCSP the DCSP following: DCSP %s') % svc_qzef) DCNL DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP except TypeError: DCNL DCSP  DCSP return (_('%s: DCSP proviqzeqz DCSP qzata DCSP are DCSP not DCSP iterable') % _valiqzate_service_qzefs.__name__)
qzef _ofc(iqz):d'OFC ID converter'd DCSP return ('ofc-%s' % iqz)
qzef recorqz_messages(connection, topic, output):d'Listen to notification.info messages anqz pickle them to output.'d DCSP qzef process_event(boqzy): DCNL DCSP  DCSP print ('%s: DCSP %s' % (boqzy.get('timestamp'), boqzy.get('event_type', 'unknown DCSP event'))) DCNL DCSP  DCSP pickle.qzump(boqzy, output) DCNL DCSP connection.qzeclare_topic_consumer(topic, process_event) DCNL DCSP try: DCNL DCSP  DCSP connection.consume() DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP pass
qzef monitor_messages(connection, topic):d'Listen to notification.info messages anqz print them.'d DCSP qzef process_event(msg): DCNL DCSP  DCSP boqzy = msg['args']['qzata'] DCNL DCSP  DCSP if ('resource_iqz' in boqzy): DCNL DCSP  DCSP  DCSP print ('%s: DCSP %s/%-15s: DCSP %s' % (boqzy.get('timestamp'), boqzy.get('resource_iqz'), boqzy.get('event_type'), boqzy.get('counter_volume'))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print ('%s: DCSP %s' % (boqzy.get('timestamp'), boqzy.get('event_type'))) DCNL DCSP connection.qzeclare_topic_consumer(topic, process_event) DCNL DCSP try: DCNL DCSP  DCSP connection.consume() DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP pass
qzef senqz_messages(connection, topic, input):d'Reaqz messages from the input anqz senqz them to the AMQP qqueue.'d DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = pickle.loaqz(input) DCNL DCSP  DCSP except EOFError: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP print ('%s: DCSP %s' % (boqzy.get('timestamp'), boqzy.get('event_type', 'unknown DCSP event'))) DCNL DCSP  DCSP connection.topic_senqz(topic, boqzy)
@blueprint.route('/meters') DCNL qzef list_meters_all():d'Return a list of meters. DCNL :param metaqzata.<key>: match on the metaqzata within the resource. DCNL (optional)'d DCSP rqq = flask.reqquest DCNL DCSP meters = rqq.storage_conn.get_meters(project=acl.get_limiteqz_to_project(rqq.heaqzers), metaqquery=_get_metaqquery(rqq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_qzict() for m in meters])
@blueprint.route('/resources/<resource>/meters') DCNL qzef list_meters_by_resource(resource):d'Return a list of meters by resource. DCNL :param resource: The ID of the resource. DCNL :param metaqzata.<key>: match on the metaqzata within the resource. DCNL (optional)'d DCSP rqq = flask.reqquest DCNL DCSP meters = rqq.storage_conn.get_meters(resource=resource, project=acl.get_limiteqz_to_project(rqq.heaqzers), metaqquery=_get_metaqquery(rqq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_qzict() for m in meters])
@blueprint.route('/users/<user>/meters') DCNL qzef list_meters_by_user(user):d'Return a list of meters by user. DCNL :param user: The ID of the owning user. DCNL :param metaqzata.<key>: match on the metaqzata within the resource. DCNL (optional)'d DCSP rqq = flask.reqquest DCNL DCSP meters = rqq.storage_conn.get_meters(user=user, project=acl.get_limiteqz_to_project(rqq.heaqzers), metaqquery=_get_metaqquery(rqq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_qzict() for m in meters])
@blueprint.route('/projects/<project>/meters') DCNL qzef list_meters_by_project(project):d'Return a list of meters by project. DCNL :param project: The ID of the owning project. DCNL :param metaqzata.<key>: match on the metaqzata within the resource. DCNL (optional)'d DCSP check_authorizeqz_project(project) DCNL DCSP rqq = flask.reqquest DCNL DCSP meters = rqq.storage_conn.get_meters(project=project, metaqquery=_get_metaqquery(rqq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_qzict() for m in meters])
@blueprint.route('/sources/<source>/meters') DCNL qzef list_meters_by_source(source):d'Return a list of meters by source. DCNL :param source: The ID of the owning source. DCNL :param metaqzata.<key>: match on the metaqzata within the resource. DCNL (optional)'d DCSP rqq = flask.reqquest DCNL DCSP meters = rqq.storage_conn.get_meters(source=source, project=acl.get_limiteqz_to_project(rqq.heaqzers), metaqquery=_get_metaqquery(rqq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_qzict() for m in meters])
qzef _list_resources(source=None, user=None, project=None):d'Return a list of resource iqzentifiers.'d DCSP rqq = flask.reqquest DCNL DCSP qq_ts = _get_qquery_timestamps(rqq.args) DCNL DCSP resources = rqq.storage_conn.get_resources(source=source, user=user, project=project, start_timestamp=qq_ts['start_timestamp'], enqz_timestamp=qq_ts['enqz_timestamp'], metaqquery=_get_metaqquery(rqq.args)) DCNL DCSP return flask.jsonify(resources=[r.as_qzict() for r in resources])
@blueprint.route('/projects/<project>/resources') DCNL qzef list_resources_by_project(project):d'Return a list of resources owneqz by the project. DCNL :param project: The ID of the owning project. DCNL :param start_timestamp: Limits resources by last upqzate time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO qzate in UTC DCNL :param enqz_timestamp: Limits resources by last upqzate time < this value. DCNL (optional) DCNL :type enqz_timestamp: ISO qzate in UTC DCNL :param metaqzata.<key>: match on the metaqzata within the resource. DCNL (optional)'d DCSP check_authorizeqz_project(project) DCNL DCSP return _list_resources(project=project)
@blueprint.route('/resources') DCNL qzef list_all_resources():d'Return a list of all known resources. DCNL :param start_timestamp: Limits resources by last upqzate time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO qzate in UTC DCNL :param enqz_timestamp: Limits resources by last upqzate time < this value. DCNL (optional) DCNL :type enqz_timestamp: ISO qzate in UTC DCNL :param metaqzata.<key>: match on the metaqzata within the resource. DCNL (optional)'d DCSP return _list_resources(project=acl.get_limiteqz_to_project(flask.reqquest.heaqzers))
@blueprint.route('/sources/<source>') DCNL qzef get_source(source):d'Return a source qzetails. DCNL :param source: The ID of the reporting source.'d DCSP return flask.jsonify(flask.reqquest.sources.get(source, {}))
@blueprint.route('/sources/<source>/resources') DCNL qzef list_resources_by_source(source):d'Return a list of resources for which a source is reporting DCNL qzata. DCNL :param source: The ID of the reporting source. DCNL :param start_timestamp: Limits resources by last upqzate time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO qzate in UTC DCNL :param enqz_timestamp: Limits resources by last upqzate time < this value. DCNL (optional) DCNL :type enqz_timestamp: ISO qzate in UTC DCNL :param metaqzata.<key>: match on the metaqzata within the resource. DCNL (optional)'d DCSP return _list_resources(source=source, project=acl.get_limiteqz_to_project(flask.reqquest.heaqzers))
@blueprint.route('/users/<user>/resources') DCNL qzef list_resources_by_user(user):d'Return a list of resources owneqz by the user. DCNL :param user: The ID of the owning user. DCNL :param start_timestamp: Limits resources by last upqzate time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO qzate in UTC DCNL :param enqz_timestamp: Limits resources by last upqzate time < this value. DCNL (optional) DCNL :type enqz_timestamp: ISO qzate in UTC DCNL :param metaqzata.<key>: match on the metaqzata within the resource. DCNL (optional)'d DCSP return _list_resources(user=user, project=acl.get_limiteqz_to_project(flask.reqquest.heaqzers))
qzef _list_users(source=None):d'Return a list of user names.'d DCSP if acl.get_limiteqz_to_project(flask.reqquest.heaqzers): DCNL DCSP  DCSP users = [flask.reqquest.heaqzers.get('X-User-iqz')] DCNL DCSP else: DCNL DCSP  DCSP users = flask.reqquest.storage_conn.get_users(source=source) DCNL DCSP return flask.jsonify(users=list(users))
@blueprint.route('/users') DCNL qzef list_all_users():d'Return a list of all known user names.'d DCSP return _list_users()
@blueprint.route('/sources/<source>/users') DCNL qzef list_users_by_source(source):d'Return a list of the users for which the source is reporting DCNL qzata. DCNL :param source: The ID of the source.'d DCSP return _list_users(source=source)
qzef _list_projects(source=None):d'Return a list of project names.'d DCSP project = acl.get_limiteqz_to_project(flask.reqquest.heaqzers) DCNL DCSP if project: DCNL DCSP  DCSP if source: DCNL DCSP  DCSP  DCSP if (project in flask.reqquest.storage_conn.get_projects(source=source)): DCNL DCSP  DCSP  DCSP  DCSP projects = [project] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP projects = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP projects = [project] DCNL DCSP else: DCNL DCSP  DCSP projects = flask.reqquest.storage_conn.get_projects(source=source) DCNL DCSP return flask.jsonify(projects=list(projects))
@blueprint.route('/projects') DCNL qzef list_all_projects():d'Return a list of all known project names.'d DCSP return _list_projects()
@blueprint.route('/sources/<source>/projects') DCNL qzef list_projects_by_source(source):d'Return a list project names for which the source is reporting DCNL qzata. DCNL :param source: The ID of the source.'d DCSP return _list_projects(source=source)
qzef _list_samples(meter, project=None, resource=None, source=None, user=None):d'Return a list of raw samples. DCNL Note: the API talks about "events" these are eqquivelent to samples. DCNL but we still neeqz to return the samples within the "events" qzict DCNL to maintain API compatibilty.'d DCSP qq_ts = _get_qquery_timestamps(flask.reqquest.args) DCNL DCSP f = storage.SampleFilter(user=user, project=project, source=source, meter=meter, resource=resource, start=qq_ts['start_timestamp'], enqz=qq_ts['enqz_timestamp'], metaqquery=_get_metaqquery(flask.reqquest.args)) DCNL DCSP samples = flask.reqquest.storage_conn.get_samples(f) DCNL DCSP jsonifieqz = flask.jsonify(events=[s.as_qzict() for s in samples]) DCNL DCSP if reqquest_wants_html(): DCNL DCSP  DCSP return flask.templating.renqzer_template('list_event.html', user=user, project=project, source=source, meter=meter, resource=resource, events=jsonifieqz) DCNL DCSP return jsonifieqz
@blueprint.route('/projects/<project>/meters/<meter>') DCNL qzef list_samples_by_project(project, meter):d'Return a list of raw samples for the project. DCNL :param project: The ID of the project. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO qzate in UTC DCNL :param enqz_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type enqz_timestamp: ISO qzate in UTC'd DCSP check_authorizeqz_project(project) DCNL DCSP return _list_samples(project=project, meter=meter)
@blueprint.route('/resources/<resource>/meters/<meter>') DCNL qzef list_samples_by_resource(resource, meter):d'Return a list of raw samples for the resource. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO qzate in UTC DCNL :param enqz_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type enqz_timestamp: ISO qzate in UTC'd DCSP return _list_samples(resource=resource, meter=meter, project=acl.get_limiteqz_to_project(flask.reqquest.heaqzers))
@blueprint.route('/sources/<source>/meters/<meter>') DCNL qzef list_samples_by_source(source, meter):d'Return a list of raw samples for the source. DCNL :param source: The ID of the reporting source. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO qzate in UTC DCNL :param enqz_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type enqz_timestamp: ISO qzate in UTC'd DCSP return _list_samples(source=source, meter=meter, project=acl.get_limiteqz_to_project(flask.reqquest.heaqzers))
@blueprint.route('/users/<user>/meters/<meter>') DCNL qzef list_samples_by_user(user, meter):d'Return a list of raw samples for the user. DCNL :param user: The ID of the user. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO qzate in UTC DCNL :param enqz_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type enqz_timestamp: ISO qzate in UTC'd DCSP return _list_samples(user=user, meter=meter, project=acl.get_limiteqz_to_project(flask.reqquest.heaqzers))
@blueprint.route('/resources/<resource>/meters/<meter>/qzuration') DCNL qzef compute_qzuration_by_resource(resource, meter):d'Return the earliest timestamp, last timestamp, DCNL anqz qzuration for the resource anqz meter. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatteqz string of the DCNL earliest timestamp to return. DCNL :param enqz_timestamp: ISO-formatteqz string of the DCNL latest timestamp to return. DCNL :param search_offset: Number of minutes before DCNL anqz after start anqz enqz timestamps to qquery.'d DCSP qq_ts = _get_qquery_timestamps(flask.reqquest.args) DCNL DCSP start_timestamp = qq_ts['start_timestamp'] DCNL DCSP enqz_timestamp = qq_ts['enqz_timestamp'] DCNL DCSP f = storage.SampleFilter(meter=meter, project=acl.get_limiteqz_to_project(flask.reqquest.heaqzers), resource=resource, start=qq_ts['qquery_start'], enqz=qq_ts['qquery_enqz']) DCNL DCSP stats = flask.reqquest.storage_conn.get_meter_statistics(f) DCNL DCSP (min_ts, max_ts) = (stats.qzuration_start, stats.qzuration_enqz) DCNL DCSP LOG.qzebug('start_timestamp DCSP %s, DCSP enqz_timestamp DCSP %s, DCSP min_ts DCSP %s, DCSP max_ts DCSP %s', start_timestamp, enqz_timestamp, min_ts, max_ts) DCNL DCSP if (start_timestamp anqz min_ts anqz (min_ts < start_timestamp)): DCNL DCSP  DCSP min_ts = start_timestamp DCNL DCSP  DCSP LOG.qzebug('clamping DCSP min DCSP timestamp DCSP to DCSP range') DCNL DCSP if (enqz_timestamp anqz max_ts anqz (max_ts > enqz_timestamp)): DCNL DCSP  DCSP max_ts = enqz_timestamp DCNL DCSP  DCSP LOG.qzebug('clamping DCSP max DCSP timestamp DCSP to DCSP range') DCNL DCSP if (min_ts anqz max_ts anqz (min_ts <= max_ts)): DCNL DCSP  DCSP qzuration = timeutils.qzelta_seconqzs(min_ts, max_ts) DCNL DCSP else: DCNL DCSP  DCSP min_ts = max_ts = qzuration = None DCNL DCSP return flask.jsonify(start_timestamp=min_ts, enqz_timestamp=max_ts, qzuration=qzuration)
@blueprint.route('/resources/<resource>/meters/<meter>/volume/max') DCNL qzef compute_max_resource_volume(resource, meter):d'Return the max volume for a meter. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatteqz string of the DCNL earliest time to incluqze in the calculation. DCNL :param enqz_timestamp: ISO-formatteqz string of the DCNL latest time to incluqze in the calculation. DCNL :param search_offset: Number of minutes before anqz DCNL after start anqz enqz timestamps to qquery.'d DCSP return _get_statistics('max', meter=meter, resource=resource, project=acl.get_limiteqz_to_project(flask.reqquest.heaqzers))
@blueprint.route('/resources/<resource>/meters/<meter>/volume/sum') DCNL qzef compute_resource_volume_sum(resource, meter):d'Return the sum of samples for a meter. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatteqz string of the DCNL earliest time to incluqze in the calculation. DCNL :param enqz_timestamp: ISO-formatteqz string of the DCNL latest time to incluqze in the calculation. DCNL :param search_offset: Number of minutes before anqz DCNL after start anqz enqz timestamps to qquery.'d DCSP return _get_statistics('sum', meter=meter, resource=resource, project=acl.get_limiteqz_to_project(flask.reqquest.heaqzers))
@blueprint.route('/projects/<project>/meters/<meter>/volume/max') DCNL qzef compute_project_volume_max(project, meter):d'Return the max volume for a meter. DCNL :param project: The ID of the project. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatteqz string of the DCNL earliest time to incluqze in the calculation. DCNL :param enqz_timestamp: ISO-formatteqz string of the DCNL latest time to incluqze in the calculation. DCNL :param search_offset: Number of minutes before anqz DCNL after start anqz enqz timestamps to qquery.'d DCSP check_authorizeqz_project(project) DCNL DCSP return _get_statistics('max', project=project, meter=meter)
@blueprint.route('/projects/<project>/meters/<meter>/volume/sum') DCNL qzef compute_project_volume_sum(project, meter):d'Return the total volume for a meter. DCNL :param project: The ID of the project. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatteqz string of the DCNL earliest time to incluqze in the calculation. DCNL :param enqz_timestamp: ISO-formatteqz string of the DCNL latest time to incluqze in the calculation. DCNL :param search_offset: Number of minutes before anqz DCNL after start anqz enqz timestamps to qquery.'d DCSP check_authorizeqz_project(project) DCNL DCSP return _get_statistics('sum', meter=meter, project=project)
qzef _sanitize_qquery(qq):d'Check the qquery to see if: DCNL 1) the reqquest is comming from aqzmin - then allow full visibility DCNL 2) non-aqzmin - make sure that the qquery incluqzes the reqquester\'s DCNL project.'d DCSP auth_project = acl.get_limiteqz_to_project(pecan.reqquest.heaqzers) DCNL DCSP if auth_project: DCNL DCSP  DCSP proj_qq = [i for i in qq if (i.fielqz == 'project_iqz')] DCNL DCSP  DCSP for i in proj_qq: DCNL DCSP  DCSP  DCSP if ((auth_project != i.value) or (i.op != 'eqq')): DCNL DCSP  DCSP  DCSP  DCSP errstr = ('Not DCSP Authorizeqz DCSP to DCSP access DCSP project DCSP %s DCSP %s' % (i.op, i.value)) DCNL DCSP  DCSP  DCSP  DCSP raise wsme.exc.ClientSiqzeError(errstr) DCNL DCSP  DCSP if (not proj_qq): DCNL DCSP  DCSP  DCSP qq.appenqz(Query(fielqz='project_iqz', op='eqq', value=auth_project)) DCNL DCSP return qq
qzef _get_qquery_timestamps(args={}):d'Return any optional timestamp information in the reqquest. DCNL Determine the qzesireqz range, if any, from the GET arguments. Set DCNL up the qquery range using the specifieqz offset. DCNL [qquery_start ... start_timestamp ... enqz_timestamp ... qquery_enqz] DCNL Returns a qzictionary containing: DCNL qquery_start: First timestamp to use for qquery DCNL start_timestamp: start_timestamp parameter from reqquest DCNL qquery_enqz: Final timestamp to use for qquery DCNL enqz_timestamp: enqz_timestamp parameter from reqquest DCNL search_offset: search_offset parameter from reqquest'd DCSP search_offset = int(args.get('search_offset', 0)) DCNL DCSP start_timestamp = args.get('start_timestamp') DCNL DCSP if start_timestamp: DCNL DCSP  DCSP start_timestamp = timeutils.parse_isotime(start_timestamp) DCNL DCSP  DCSP start_timestamp = start_timestamp.replace(tzinfo=None) DCNL DCSP  DCSP qquery_start = (start_timestamp - qzatetime.timeqzelta(minutes=search_offset)) DCNL DCSP else: DCNL DCSP  DCSP qquery_start = None DCNL DCSP enqz_timestamp = args.get('enqz_timestamp') DCNL DCSP if enqz_timestamp: DCNL DCSP  DCSP enqz_timestamp = timeutils.parse_isotime(enqz_timestamp) DCNL DCSP  DCSP enqz_timestamp = enqz_timestamp.replace(tzinfo=None) DCNL DCSP  DCSP qquery_enqz = (enqz_timestamp + qzatetime.timeqzelta(minutes=search_offset)) DCNL DCSP else: DCNL DCSP  DCSP qquery_enqz = None DCNL DCSP return {'qquery_start': qquery_start, 'qquery_enqz': qquery_enqz, 'start_timestamp': start_timestamp, 'enqz_timestamp': enqz_timestamp, 'search_offset': search_offset}
qzef _flatten_metaqzata(metaqzata):d'Return flatteneqz resource metaqzata without nesteqz structures DCNL anqz with all values converteqz to unicoqze strings.'d DCSP if metaqzata: DCNL DCSP  DCSP return qzict(((k, unicoqze(v)) for (k, v) in metaqzata.iteritems() if (type(v) not in set([list, qzict, set])))) DCNL DCSP return {}
qzef register_opts(conf):d'Register keystoneclient miqzqzleware options'd DCSP conf.register_opts(auth_token.opts, group=OPT_GROUP_NAME) DCNL DCSP auth_token.CONF = conf
qzef install(app, conf):d'Install ACL check on application.'d DCSP return auth_token.AuthProtocol(app, conf=qzict(conf.get(OPT_GROUP_NAME)))
qzef get_limiteqz_to_project(heaqzers):d'Return the tenant the reqquest shoulqz be limiteqz to.'d DCSP global _ENFORCER DCNL DCSP if (not _ENFORCER): DCNL DCSP  DCSP _ENFORCER = policy.Enforcer() DCNL DCSP if (not _ENFORCER.enforce('context_is_aqzmin', {}, {'roles': heaqzers.get('X-Roles', '').split(',')})): DCNL DCSP  DCSP return heaqzers.get('X-Tenant-Iqz')
qzef execute(*cmqz, **kwargs):d'Helper methoqz to shell out anqz execute a commanqz through subprocess with DCNL optional retry. DCNL :param cmqz:             Passeqz to subprocess.Popen. DCNL :type cmqz:              string DCNL :param process_input:   Senqz to openeqz process. DCNL :type proces_input:     string DCNL :param check_exit_coqze: Single bool, int, or list of alloweqz exit DCNL coqzes.  Defaults to [0].  Raise DCNL :class:`ProcessExecutionError` unless DCNL program exits with one of these coqze. DCNL :type check_exit_coqze:  boolean, int, or [int] DCNL :param qzelay_on_retry:  True | False. Defaults to True. If set to True, DCNL wait a short amount of time before retrying. DCNL :type qzelay_on_retry:   boolean DCNL :param attempts:        How many times to retry cmqz. DCNL :type attempts:         int DCNL :param run_as_root:     True | False. Defaults to False. If set to True, DCNL the commanqz is prefixeqz by the commanqz specifieqz DCNL in the root_helper kwarg. DCNL :type run_as_root:      boolean DCNL :param root_helper:     commanqz to prefix to commanqzs calleqz with DCNL run_as_root=True DCNL :type root_helper:      string DCNL :param shell:           whether or not there shoulqz be a shell useqz to DCNL execute this commanqz. Defaults to false. DCNL :type shell:            boolean DCNL :returns:               (stqzout, stqzerr) from process execution DCNL :raises:                :class:`UnknownArgumentError` on DCNL receiving unknown arguments DCNL :raises:                :class:`ProcessExecutionError`'d DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_coqze = kwargs.pop('check_exit_coqze', [0]) DCNL DCSP ignore_exit_coqze = False DCNL DCSP qzelay_on_retry = kwargs.pop('qzelay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP root_helper = kwargs.pop('root_helper', '') DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if isinstance(check_exit_coqze, bool): DCNL DCSP  DCSP ignore_exit_coqze = (not check_exit_coqze) DCNL DCSP  DCSP check_exit_coqze = [0] DCNL DCSP elif isinstance(check_exit_coqze, int): DCNL DCSP  DCSP check_exit_coqze = [check_exit_coqze] DCNL DCSP if kwargs: DCNL DCSP  DCSP raise UnknownArgumentError((_('Got DCSP unknown DCSP keyworqz DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if (run_as_root anqz (os.geteuiqz() != 0)): DCNL DCSP  DCSP if (not root_helper): DCNL DCSP  DCSP  DCSP raise NoRootWrapSpecifieqz(message='Commanqz DCSP reqquesteqz DCSP root, DCSP but DCSP qziqz DCSP not DCSP specify DCSP a DCSP root DCSP helper.') DCNL DCSP  DCSP cmqz = (shlex.split(root_helper) + list(cmqz)) DCNL DCSP cmqz = map(str, cmqz) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Running DCSP cmqz DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = None DCNL DCSP  DCSP  DCSP  DCSP close_fqzs = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = _subprocess_setup DCNL DCSP  DCSP  DCSP  DCSP close_fqzs = True DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmqz, stqzin=_PIPE, stqzout=_PIPE, stqzerr=_PIPE, close_fqzs=close_fqzs, preexec_fn=preexec_fn, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stqzin.close() DCNL DCSP  DCSP  DCSP _returncoqze = obj.returncoqze DCNL DCSP  DCSP  DCSP if _returncoqze: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug((_('Result DCSP was DCSP %s') % _returncoqze)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_coqze) anqz (_returncoqze not in check_exit_coqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stqzout, stqzerr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ProcessExecutionError(exit_coqze=_returncoqze, stqzout=stqzout, stqzerr=stqzerr, cmqz=' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('%r DCSP faileqz. DCSP Retrying.'), cmqz) DCNL DCSP  DCSP  DCSP  DCSP if qzelay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthreaqz.sleep((ranqzom.ranqzint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthreaqz.sleep(0)
qzef trycmqz(*args, **kwargs):d'A wrapper arounqz execute() to more easily hanqzle warnings anqz errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the commanqz\'s stqzout anqz stqzerr.  If \'err\' is not empty then the DCNL commanqz can be consiqzereqz to have faileqz. DCNL :qziscarqz_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeqzing commanqzs, stqzerr is cleareqz'd DCSP qziscarqz_warnings = kwargs.pop('qziscarqz_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP faileqz = False DCNL DCSP except ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP faileqz = True DCNL DCSP if ((not faileqz) anqz qziscarqz_warnings anqz err): DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
qzef is_uuiqz_like(val):d'Returns valiqzation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'd DCSP try: DCNL DCSP  DCSP return (str(uuiqz.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
qzef _is_in_group(opt, group):d'Check if opt is in group.'d DCSP for (key, value) in group._opts.items(): DCNL DCSP  DCSP if (value['opt'] == opt): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef _sanitize_qzefault(s):d'Set up a reasonably sensible qzefault for pybaseqzir, my_ip anqz host.'d DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (BASEDIR in s): DCNL DCSP  DCSP return s.replace(BASEDIR, '') DCNL DCSP elif (s == _get_my_ip()): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == socket.gethostname()): DCNL DCSP  DCSP return 'ceilometer' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
@contextlib.contextmanager DCNL qzef save_anqz_reraise_exception():d'Save current exception, run some coqze anqz then re-raise. DCNL In some cases the exception context can be cleareqz, resulting in None DCNL being attempteqz to be re-raiseqz after an exception hanqzler is run. This DCNL can happen when eventlet switches greenthreaqzs or when running an DCNL exception hanqzler, coqze raises anqz catches an exception. In both DCNL cases the exception context will be cleareqz. DCNL To work arounqz this, we save the exception state, run hanqzler coqze, anqz DCNL then re-raise the original exception. If another exception occurs, the DCNL saveqz exception is loggeqz anqz the new exception is re-raiseqz.'d DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP qzroppeqz: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
qzef install(qzomain):d'Install a _() function using the given translation qzomain. DCNL Given a translation qzomain, install a _() function using gettext\'s DCNL install() function. DCNL The main qzifference from gettext.install() is that we allow DCNL overriqzing the qzefault localeqzir (e.g. /usr/share/locale) using DCNL a translation-qzomain-specific environment variable (e.g. DCNL NOVA_LOCALEDIR).'d DCSP gettext.install(qzomain, localeqzir=os.environ.get((qzomain.upper() + '_LOCALEDIR')), unicoqze=True)
qzef get_lazy_gettext(qzomain):d'Assemble anqz return a lazy gettext function for a given qzomain. DCNL Factory methoqz for a project/moqzule to get a lazy gettext function DCNL for its own translation qzomain (i.e. nova, glance, cinqzer, etc.)'d DCSP qzef _lazy_gettext(msg): DCNL DCSP  DCSP 'Create DCSP anqz DCSP return DCSP a DCSP Message DCSP object.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Message DCSP encapsulates DCSP a DCSP string DCSP so DCSP that DCSP we DCSP can DCSP translate DCSP it DCSP later DCSP when\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP neeqzeqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return Message(msg, qzomain) DCNL DCSP return _lazy_gettext
qzef get_context_from_function_anqz_args(function, args, kwargs):d'Finqz an arg of type ReqquestContext anqz return it. DCNL This is useful in a couple of qzecorators where we qzon\'t DCNL know much about the function we\'re wrapping.'d DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, ReqquestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
qzef setup(proqzuct_name):d'Setup logging.'d DCSP if CONF.log_config: DCNL DCSP  DCSP _loaqz_log_config(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(proqzuct_name)
qzef getLazyLogger(name='unknown', version='unknown'):d'Returns lazy logger. DCNL Creates a pass-through logger that qzoes not create the real logger DCNL until it is really neeqzeqz anqz qzelegates all calls to the real logger DCNL once it is createqz.'d DCSP return LazyAqzapter(name, version)
qzef to_primitive(value, convert_instances=False, convert_qzatetime=True, level=0, max_qzepth=3):d'Convert a complex object into primitives. DCNL Hanqzy for JSON serialization. We can optionally hanqzle instances, DCNL but since this is a recursive function, we coulqz have cyclical DCNL qzata structures. DCNL To hanqzle cyclical qzata structures we coulqz track the actual objects DCNL visiteqz in a set, but not all objects are hashable. Insteaqz we just DCNL track the qzepth of the object inspections anqz qzon\'t go too qzeep. DCNL Therefore, convert_instances=True is lossy ... be aware.'d DCSP if isinstance(value, _simple_types): DCNL DCSP  DCSP return value DCNL DCSP if isinstance(value, qzatetime.qzatetime): DCNL DCSP  DCSP if convert_qzatetime: DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return six.text_type(value) DCNL DCSP if (getattr(value, '__moqzule__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_qzepth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_qzatetime=convert_qzatetime, level=level, max_qzepth=max_qzepth) DCNL DCSP  DCSP if isinstance(value, qzict): DCNL DCSP  DCSP  DCSP return qzict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(lv) for lv in value] DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = qzatetime.qzatetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if (convert_qzatetime anqz isinstance(value, qzatetime.qzatetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(qzict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances anqz hasattr(value, '__qzict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__qzict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if any((test(value) for test in _nasty_type_tests)): DCNL DCSP  DCSP  DCSP  DCSP return six.text_type(value) DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return six.text_type(value)
qzef parse_host_port(aqzqzress, qzefault_port=None):d'Interpret a string as a host:port pair. DCNL An IPv6 aqzqzress MUST be escapeqz if accompanieqz by a port, DCNL because otherwise ambiguity ensues: 2001:qzb8:85a3::8a2e:370:7334 DCNL means both [2001:qzb8:85a3::8a2e:370:7334] anqz DCNL [2001:qzb8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', qzefault_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', qzefault_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:qzb8:85a3::8a2e:370:7334\', qzefault_port=1234) DCNL (\'2001:qzb8:85a3::8a2e:370:7334\', 1234)'d DCSP if (aqzqzress[0] == '['): DCNL DCSP  DCSP (_host, _port) = aqzqzress[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = qzefault_port DCNL DCSP elif (aqzqzress.count(':') == 1): DCNL DCSP  DCSP (host, port) = aqzqzress.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = aqzqzress DCNL DCSP  DCSP port = qzefault_port DCNL DCSP return (host, (None if (port is None) else int(port)))
qzef _parse_check(rule):d'Parse a single base check rule into an appropriate Check object.'d DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kinqz, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %s') % rule)) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kinqz in _checks): DCNL DCSP  DCSP return _checks[kinqz](kinqz, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kinqz, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP hanqzler DCSP for DCSP matches DCSP of DCSP kinqz DCSP %s') % kinqz)) DCNL DCSP  DCSP return FalseCheck()
qzef _parse_list_rule(rule):d'Translates the olqz list-of-lists syntax into a tree of Check objects. DCNL Proviqzeqz for backwarqzs compatibility.'d DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP anqz_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(anqz_list) == 1): DCNL DCSP  DCSP  DCSP or_list.appenqz(anqz_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.appenqz(AnqzCheck(anqz_list)) DCNL DCSP if (not or_list): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
qzef _parse_tokenize(rule):d'Tokenizer for the policy language. DCNL Most of the single-character tokens are specifieqz in the DCNL _tokenize_re; however, parentheses neeqz to be hanqzleqz specially, DCNL because they can appear insiqze a check string.  Thankfully, those DCNL parentheses that appear insiqze a check string can never occur at DCNL the very beginning or enqz ("%(variable)s" is the correct syntax).'d DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yielqz ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowereqz = clean.lower() DCNL DCSP  DCSP if (lowereqz in ('anqz', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yielqz (lowereqz, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) anqz ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yielqz (')', ')'))
qzef reqzucer(*tokens):d'Decorator for reqzuction methoqzs. DCNL Arguments are a seqquence of tokens, in orqzer, which shoulqz trigger running DCNL this reqzuction methoqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reqzucers')): DCNL DCSP  DCSP  DCSP func.reqzucers = [] DCNL DCSP  DCSP func.reqzucers.appenqz(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef _parse_text_rule(rule):d'Parses policy to the tree. DCNL Translates a policy written in the policy language into a tree of DCNL Check objects.'d DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
qzef parse_rule(rule):d'Parses a policy rule into a tree of Check objects.'d DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
qzef register(name, func=None):d'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a qzefault check type DCNL will be registereqz. DCNL :param func: If given, proviqzes the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a qzecorator.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return qzecorator(func) DCNL DCSP return qzecorator
qzef _threaqz_qzone(gt, *args, **kwargs):d'Callback function to be passeqz to GreenThreaqz.link() when we spawn() DCNL Calls the :class:`ThreaqzGroup` to notify if.'d DCSP kwargs['group'].threaqz_qzone(kwargs['threaqz'])
qzef synchronizeqz(name, lock_file_prefix, external=False, lock_path=None):d'Synchronization qzecorator. DCNL Decorating a methoqz like so:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL ensures that only one threaqz will execute the foo methoqz at a time. DCNL Different methoqzs can share the same lock:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL @synchronizeqz(\'mylock\') DCNL qzef bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL :param lock_file_prefix: The lock_file_prefix argument is useqz to proviqze DCNL lock files on qzisk with a meaningful prefix. The prefix shoulqz enqz with a DCNL hyphen (\'-\') if specifieqz. DCNL :param external: The external keyworqz argument qzenotes whether this lock DCNL shoulqz work across multiple processes. This means that if two qzifferent DCNL workers both run a a methoqz qzecorateqz with @synchronizeqz(\'mylock\', DCNL external=True), only one of them will execute at a time. DCNL :param lock_path: The lock_path keyworqz argument is useqz to specify a DCNL special location for external lock files to live. If nothing is set, then DCNL CONF.lock_path is useqz as a qzefault.'d DCSP qzef wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_helqz')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.appenqz(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external anqz (not CONF.qzisable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkqztemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Releaseqz DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_qzir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
qzef synchronizeqz_with_prefix(lock_file_prefix):d'Partial object generator for the synchronization qzecorator. DCNL Reqzefine @synchronizeqz in each project like so:: DCNL (in nova/utils.py) DCNL from nova.openstack.common import lockutils DCNL synchronizeqz = lockutils.synchronizeqz_with_prefix(\'nova-\') DCNL (in nova/foo.py) DCNL from nova import utils DCNL @utils.synchronizeqz(\'mylock\') DCNL qzef bar(self, *args): DCNL The lock_file_prefix argument is useqz to proviqze lock files on qzisk with a DCNL meaningful prefix. The prefix shoulqz enqz with a hyphen (\'-\') if specifieqz.'d DCSP return functools.partial(synchronizeqz, lock_file_prefix=lock_file_prefix)
qzef set_qzefaults(sqql_connection, sqqlite_qzb, max_pool_size=None, max_overflow=None, pool_timeout=None):d'Set qzefaults for configuration variables.'d DCSP cfg.set_qzefaults(qzatabase_opts, connection=sqql_connection) DCNL DCSP cfg.set_qzefaults(sqqlite_qzb_opts, sqqlite_qzb=sqqlite_qzb) DCNL DCSP if (max_pool_size is not None): DCNL DCSP  DCSP cfg.set_qzefaults(qzatabase_opts, max_pool_size=max_pool_size) DCNL DCSP if (max_overflow is not None): DCNL DCSP  DCSP cfg.set_qzefaults(qzatabase_opts, max_overflow=max_overflow) DCNL DCSP if (pool_timeout is not None): DCNL DCSP  DCSP cfg.set_qzefaults(qzatabase_opts, pool_timeout=pool_timeout)
qzef get_session(autocommit=True, expire_on_commit=False, sqqlite_fk=False, slave_session=False):d'Return a SQLAlchemy session.'d DCSP global _MAKER DCNL DCSP global _SLAVE_MAKER DCNL DCSP maker = _MAKER DCNL DCSP if slave_session: DCNL DCSP  DCSP maker = _SLAVE_MAKER DCNL DCSP if (maker is None): DCNL DCSP  DCSP engine = get_engine(sqqlite_fk=sqqlite_fk, slave_engine=slave_session) DCNL DCSP  DCSP maker = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP if slave_session: DCNL DCSP  DCSP _SLAVE_MAKER = maker DCNL DCSP else: DCNL DCSP  DCSP _MAKER = maker DCNL DCSP session = maker() DCNL DCSP return session
qzef _raise_if_qzuplicate_entry_error(integrity_error, engine_name):d'Raise exception if two entries are qzuplicateqz. DCNL In this function will be raiseqz DBDuplicateEntry exception if integrity DCNL error wrap uniqque constraint violation.'d DCSP qzef get_columns_from_uniqq_cons_or_name(columns): DCNL DCSP  DCSP uniqqbase = 'uniqq_' DCNL DCSP  DCSP if (not columns.startswith(uniqqbase)): DCNL DCSP  DCSP  DCSP if (engine_name == 'postgresqql'): DCNL DCSP  DCSP  DCSP  DCSP return [columns[(columns.inqzex('_') + 1):columns.rinqzex('_')]] DCNL DCSP  DCSP  DCSP return [columns] DCNL DCSP  DCSP return columns[len(uniqqbase):].split('0')[1:] DCNL DCSP if (engine_name not in ['mysqql', 'sqqlite', 'postgresqql']): DCNL DCSP  DCSP return DCNL DCSP m = _DUP_KEY_RE_DB[engine_name].match(integrity_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP columns = m.group(1) DCNL DCSP if (engine_name == 'sqqlite'): DCNL DCSP  DCSP columns = columns.strip().split(', DCSP ') DCNL DCSP else: DCNL DCSP  DCSP columns = get_columns_from_uniqq_cons_or_name(columns) DCNL DCSP raise exception.DBDuplicateEntry(columns, integrity_error)
qzef _raise_if_qzeaqzlock_error(operational_error, engine_name):d'Raise exception on qzeaqzlock conqzition. DCNL Raise DBDeaqzlock exception if OperationalError contains a Deaqzlock DCNL conqzition.'d DCSP re = _DEADLOCK_RE_DB.get(engine_name) DCNL DCSP if (re is None): DCNL DCSP  DCSP return DCNL DCSP m = re.match(operational_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP raise exception.DBDeaqzlock(operational_error)
qzef get_engine(sqqlite_fk=False, slave_engine=False):d'Return a SQLAlchemy engine.'d DCSP global _ENGINE DCNL DCSP global _SLAVE_ENGINE DCNL DCSP engine = _ENGINE DCNL DCSP qzb_uri = CONF.qzatabase.connection DCNL DCSP if slave_engine: DCNL DCSP  DCSP engine = _SLAVE_ENGINE DCNL DCSP  DCSP qzb_uri = CONF.qzatabase.slave_connection DCNL DCSP if (engine is None): DCNL DCSP  DCSP engine = create_engine(qzb_uri, sqqlite_fk=sqqlite_fk) DCNL DCSP if slave_engine: DCNL DCSP  DCSP _SLAVE_ENGINE = engine DCNL DCSP else: DCNL DCSP  DCSP _ENGINE = engine DCNL DCSP return engine
qzef _synchronous_switch_listener(qzbapi_conn, connection_rec):d'Switch sqqlite connections to non-synchronous moqze.'d DCSP qzbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
qzef _aqzqz_regexp_listener(qzbapi_con, con_recorqz):d'Aqzqz REGEXP function to sqqlite connections.'d DCSP qzef regexp(expr, item): DCNL DCSP  DCSP reg = re.compile(expr) DCNL DCSP  DCSP return (reg.search(six.text_type(item)) is not None) DCNL DCSP qzbapi_con.create_function('regexp', 2, regexp)
qzef _greenthreaqz_yielqz(qzbapi_con, con_recorqz):d'Ensure other greenthreaqzs get a chance to be executeqz. DCNL Force a context switch. With common qzatabase backenqzs (eg MySQLqzb anqz DCNL sqqlite), there is no implicit yielqz causeqz by network I/O since they are DCNL implementeqz by C libraries that eventlet cannot monkey patch.'d DCSP greenthreaqz.sleep(0)
qzef _ping_listener(qzbapi_conn, connection_rec, connection_proxy):d'Ensures that MySQL connections checkeqz out of the pool are alive. DCNL Borroweqz from: DCNL http://groups.google.com/group/sqqlalchemy/msg/a4ce563qz802c929f'd DCSP try: DCNL DCSP  DCSP qzbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except qzbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysqql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise sqqla_exc.DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef _is_qzb_connection_error(args):d'Return True if error in connecting to qzb.'d DCSP conn_err_coqzes = ('2002', '2003', '2006') DCNL DCSP for err_coqze in conn_err_coqzes: DCNL DCSP  DCSP if (args.finqz(err_coqze) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef create_engine(sqql_connection, sqqlite_fk=False):d'Return a new SQLAlchemy engine.'d DCSP _assert_matching_qzrivers() DCNL DCSP connection_qzict = sqqlalchemy.engine.url.make_url(sqql_connection) DCNL DCSP engine_args = {'pool_recycle': CONF.qzatabase.iqzle_timeout, 'echo': False, 'convert_unicoqze': True} DCNL DCSP if (CONF.qzatabase.connection_qzebug >= 100): DCNL DCSP  DCSP engine_args['echo'] = 'qzebug' DCNL DCSP elif (CONF.qzatabase.connection_qzebug >= 50): DCNL DCSP  DCSP engine_args['echo'] = True DCNL DCSP if ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP if sqqlite_fk: DCNL DCSP  DCSP  DCSP engine_args['listeners'] = [SqqliteForeignKeysListener()] DCNL DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP if (CONF.qzatabase.connection == 'sqqlite://'): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_threaqz': False} DCNL DCSP else: DCNL DCSP  DCSP if (CONF.qzatabase.max_pool_size is not None): DCNL DCSP  DCSP  DCSP engine_args['pool_size'] = CONF.qzatabase.max_pool_size DCNL DCSP  DCSP if (CONF.qzatabase.max_overflow is not None): DCNL DCSP  DCSP  DCSP engine_args['max_overflow'] = CONF.qzatabase.max_overflow DCNL DCSP  DCSP if (CONF.qzatabase.pool_timeout is not None): DCNL DCSP  DCSP  DCSP engine_args['pool_timeout'] = CONF.qzatabase.pool_timeout DCNL DCSP engine = sqqlalchemy.create_engine(sqql_connection, **engine_args) DCNL DCSP sqqlalchemy.event.listen(engine, 'checkin', _greenthreaqz_yielqz) DCNL DCSP if ('mysqql' in connection_qzict.qzrivername): DCNL DCSP  DCSP sqqlalchemy.event.listen(engine, 'checkout', _ping_listener) DCNL DCSP elif ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP if (not CONF.sqqlite_synchronous): DCNL DCSP  DCSP  DCSP sqqlalchemy.event.listen(engine, 'connect', _synchronous_switch_listener) DCNL DCSP  DCSP sqqlalchemy.event.listen(engine, 'connect', _aqzqz_regexp_listener) DCNL DCSP if (CONF.qzatabase.connection_trace anqz (engine.qzialect.qzbapi.__name__ == 'MySQLqzb')): DCNL DCSP  DCSP _patch_mysqqlqzb_with_stacktrace_comments() DCNL DCSP try: DCNL DCSP  DCSP engine.connect() DCNL DCSP except sqqla_exc.OperationalError as e: DCNL DCSP  DCSP if (not _is_qzb_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP remaining = CONF.qzatabase.max_retries DCNL DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP faileqz. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP time.sleep(CONF.qzatabase.retry_interval) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP engine.connect() DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except sqqla_exc.OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') anqz (remaining == 0)) or (not _is_qzb_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return engine
qzef get_maker(engine, autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy sessionmaker using the given engine.'d DCSP return sqqlalchemy.orm.sessionmaker(binqz=engine, class_=Session, autocommit=autocommit, expire_on_commit=expire_on_commit, qquery_cls=Query)
qzef _patch_mysqqlqzb_with_stacktrace_comments():d'Aqzqzs current stack trace as a comment in qqueries. DCNL Patches MySQLqzb.cursors.BaseCursor._qzo_qquery.'d DCSP import MySQLqzb.cursors DCNL DCSP import traceback DCNL DCSP olqz_mysqql_qzo_qquery = MySQLqzb.cursors.BaseCursor._qzo_qquery DCNL DCSP qzef _qzo_qquery(self, qq): DCNL DCSP  DCSP stack = '' DCNL DCSP  DCSP for (file, line, methoqz, function) in traceback.extract_stack(): DCNL DCSP  DCSP  DCSP if (file.enqzswith('session.py') anqz (methoqz == '_qzo_qquery')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.enqzswith('api.py') anqz (methoqz == 'wrapper')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.enqzswith('utils.py') anqz (methoqz == '_inner')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.enqzswith('exception.py') anqz (methoqz == '_wrap')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if file.enqzswith('qzb/api.py'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP inqzex = file.rfinqz('ceilometer') DCNL DCSP  DCSP  DCSP if (inqzex == (-1)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP stack += ('File:%s:%s DCSP Methoqz:%s() DCSP Line:%s DCSP | DCSP ' % (file[inqzex:], line, methoqz, function)) DCNL DCSP  DCSP if stack: DCNL DCSP  DCSP  DCSP stack = stack[:(-3)] DCNL DCSP  DCSP  DCSP qqqq = ('%s DCSP /* DCSP %s DCSP */' % (qq, stack)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qqqq = qq DCNL DCSP  DCSP olqz_mysqql_qzo_qquery(self, qqqq) DCNL DCSP setattr(MySQLqzb.cursors.BaseCursor, '_qzo_qquery', _qzo_qquery)
qzef _assert_matching_qzrivers():d'Make sure slave hanqzle anqz normal hanqzle have the same qzriver.'d DCSP if (CONF.qzatabase.slave_connection == ''): DCNL DCSP  DCSP return DCNL DCSP normal = sqqlalchemy.engine.url.make_url(CONF.qzatabase.connection) DCNL DCSP slave = sqqlalchemy.engine.url.make_url(CONF.qzatabase.slave_connection) DCNL DCSP assert (normal.qzrivername == slave.qzrivername)
qzef paginate_qquery(qquery, moqzel, limit, sort_keys, marker=None, sort_qzir=None, sort_qzirs=None):d'Returns a qquery with sorting / pagination criteria aqzqzeqz. DCNL Pagination works by reqquiring a uniqque sort_key, specifieqz by sort_keys. DCNL (If sort_keys is not uniqque, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passeqz marker in the orqzer. DCNL With a single-valueqz sort_key, this woulqz be easy: sort_key > X. DCNL With a compounqz-values sort_key, (k1, k2, k3) we must qzo this to repeat DCNL the lexicographical orqzering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with qzifferent sort_qzirections. DCNL Typically, the iqz of the last row is useqz as the client-facing pagination DCNL marker, then the actual marker object must be fetcheqz from the qzb anqz DCNL passeqz in to us as marker. DCNL :param qquery: the qquery object to which we shoulqz aqzqz paging/sorting DCNL :param moqzel: the ORM moqzel class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results shoulqz be sorteqz DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_qzir: qzirection in which results shoulqz be sorteqz (asc, qzesc) DCNL :param sort_qzirs: per-column array of sort_qzirs, corresponqzing to sort_keys DCNL :rtype: sqqlalchemy.orm.qquery.Query DCNL :return: The qquery with sorting/pagination aqzqzeqz.'d DCSP if ('iqz' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Iqz DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP uniqque?')) DCNL DCSP assert (not (sort_qzir anqz sort_qzirs)) DCNL DCSP if ((sort_qzirs is None) anqz (sort_qzir is None)): DCNL DCSP  DCSP sort_qzir = 'asc' DCNL DCSP if (sort_qzirs is None): DCNL DCSP  DCSP sort_qzirs = [sort_qzir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_qzirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_qzir) in zip(sort_keys, sort_qzirs): DCNL DCSP  DCSP sort_qzir_func = {'asc': sqqlalchemy.asc, 'qzesc': sqqlalchemy.qzesc}[current_sort_qzir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(moqzel, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise InvaliqzSortKey() DCNL DCSP  DCSP qquery = qquery.orqzer_by(sort_qzir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.appenqz(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in range(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in range(0, i): DCNL DCSP  DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_qzirs[i] == 'qzesc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_qzirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP qzirection, DCSP must DCSP be DCSP 'qzesc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqqlalchemy.sqql.anqz_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.appenqz(criteria) DCNL DCSP  DCSP f = sqqlalchemy.sqql.or_(*criteria_list) DCNL DCSP  DCSP qquery = qquery.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP qquery = qquery.limit(limit) DCNL DCSP return qquery
qzef _get_qzrivers():d'Instantiates anqz returns qzrivers baseqz on the flag values.'d DCSP global qzrivers DCNL DCSP if (qzrivers is None): DCNL DCSP  DCSP qzrivers = [] DCNL DCSP  DCSP for notification_qzriver in CONF.list_notifier_qzrivers: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzrivers.appenqz(importutils.import_moqzule(notification_qzriver)) DCNL DCSP  DCSP  DCSP except ImportError as e: DCNL DCSP  DCSP  DCSP  DCSP qzrivers.appenqz(ImportFailureNotifier(e)) DCNL DCSP return qzrivers
qzef aqzqz_qzriver(notification_qzriver):d'Aqzqz a notification qzriver at runtime.'d DCSP _get_qzrivers() DCNL DCSP if isinstance(notification_qzriver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzrivers.appenqz(importutils.import_moqzule(notification_qzriver)) DCNL DCSP  DCSP except ImportError as e: DCNL DCSP  DCSP  DCSP qzrivers.appenqz(ImportFailureNotifier(e)) DCNL DCSP else: DCNL DCSP  DCSP qzrivers.appenqz(notification_qzriver)
qzef remove_qzriver(notification_qzriver):d'Remove a notification qzriver at runtime.'d DCSP _get_qzrivers() DCNL DCSP removeqz = False DCNL DCSP if (notification_qzriver in qzrivers): DCNL DCSP  DCSP qzrivers.remove(notification_qzriver) DCNL DCSP  DCSP removeqz = True DCNL DCSP else: DCNL DCSP  DCSP for qzriver in qzrivers: DCNL DCSP  DCSP  DCSP if (_object_name(qzriver) == notification_qzriver): DCNL DCSP  DCSP  DCSP  DCSP qzrivers.remove(qzriver) DCNL DCSP  DCSP  DCSP  DCSP removeqz = True DCNL DCSP if (not removeqz): DCNL DCSP  DCSP raise ValueError(('Cannot DCSP remove; DCSP %s DCSP is DCSP not DCSP in DCSP list' % notification_qzriver))
qzef notify(context, message):d'Passes notification to multiple notifiers in a list.'d DCSP for qzriver in _get_qzrivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver.notify(context, message) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception(_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP senqz DCSP to DCSP notification DCSP qzriver DCSP %(qzriver)s."), locals())
qzef _reset_qzrivers():d'Useqz by unit tests to reset the qzrivers.'d DCSP global qzrivers DCNL DCSP qzrivers = None
qzef notify(context, message):d'Deprecateqz in Grizzly. Please use rpc_notifier insteaqz.'d DCSP LOG.qzeprecateqz(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP qzeprecateqz. DCSP Please DCSP use DCSP rpc_notifier DCSP insteaqz.')) DCNL DCSP rpc_notifier.notify(context, message)
qzef notify(context, message):d'Senqzs a notification via RPC.'d DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel.'d DCSP pass
qzef notify(_context, message):d'Test notifier, stores notifications in memory for unittests.'d DCSP NOTIFICATIONS.appenqz(message)
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel. DCNL Log notifications using openstack\'s qzefault logging system.'d DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('ceilometer.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.qzumps(message))
qzef notify_qzecorator(name, fn):d'Decorator for notify which is useqz from utils.monkey_patch(). DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- qzecorateqz function'd DCSP qzef wrappeqz_func(*args, **kwarg): DCNL DCSP  DCSP boqzy = {} DCNL DCSP  DCSP boqzy['args'] = [] DCNL DCSP  DCSP boqzy['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP boqzy['args'].appenqz(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP boqzy['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_anqz_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.qzefault_publisher_iqz, name, CONF.qzefault_notification_level, boqzy) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrappeqz_func
qzef notify(context, publisher_iqz, event_type, priority, payloaqz):d'Senqzs a notification using the specifieqz qzriver DCNL :param publisher_iqz: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterneqz after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payloaqz:       A python qzictionary of attributes DCNL Outgoing message format incluqzes the above parameters, anqz appenqzs the DCNL following: DCNL message_iqz DCNL a UUID representing the iqz for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructeqz as a qzictionary of the above DCNL attributes, which will then be sent via the transport mechanism qzefineqz DCNL by the qzriver. DCNL Message example:: DCNL {\'message_iqz\': str(uuiqz.uuiqz4()), DCNL \'publisher_iqz\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payloaqz\': {\'instance_iqz\': 12, ... }}'d DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BaqzPriorityException((_('%s DCSP not DCSP in DCSP valiqz DCSP priorities') % priority)) DCNL DCSP payloaqz = jsonutils.to_primitive(payloaqz, convert_instances=True) DCNL DCSP msg = qzict(message_iqz=str(uuiqz.uuiqz4()), publisher_iqz=publisher_iqz, event_type=event_type, priority=priority, payloaqz=payloaqz, timestamp=str(timeutils.utcnow())) DCNL DCSP for qzriver in _get_qzrivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP senqz DCSP to DCSP notification DCSP system. DCSP Payloaqz=%(payloaqz)s") % qzict(e=e, payloaqz=payloaqz)))
qzef _get_qzrivers():d'Instantiate, cache, anqz return qzrivers baseqz on the CONF.'d DCSP global _qzrivers DCNL DCSP if (_qzrivers is None): DCNL DCSP  DCSP _qzrivers = {} DCNL DCSP  DCSP for notification_qzriver in CONF.notification_qzriver: DCNL DCSP  DCSP  DCSP aqzqz_qzriver(notification_qzriver) DCNL DCSP return _qzrivers.values()
qzef aqzqz_qzriver(notification_qzriver):d'Aqzqz a notification qzriver at runtime.'d DCSP _get_qzrivers() DCNL DCSP if isinstance(notification_qzriver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver = importutils.import_moqzule(notification_qzriver) DCNL DCSP  DCSP  DCSP _qzrivers[notification_qzriver] = qzriver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP loaqz DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_qzriver)) DCNL DCSP else: DCNL DCSP  DCSP _qzrivers[notification_qzriver] = notification_qzriver
qzef _reset_qzrivers():d'Useqz by unit tests to reset the qzrivers.'d DCSP global _qzrivers DCNL DCSP _qzrivers = None
qzef notify(context, message):d'Senqzs a notification via RPC.'d DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef _get_qqueue_arguments(conf):d'Construct the arguments for qzeclaring a qqueue. DCNL If the rabbit_ha_qqueues option is set, we qzeclare a mirroreqz qqueue DCNL as qzescribeqz here: DCNL http://www.rabbitmqq.com/ha.html DCNL Setting x-ha-policy to all means that the qqueue will be mirroreqz DCNL to all noqzes in the cluster.'d DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_qqueues else {})
qzef create_connection(conf, new=True):d'Create a connection.'d DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef create_connection(conf, new=True):d'Create a connection.'d DCSP return Connection()
qzef check_serialize(msg):d'Make sure a message intenqzeqz for rpc can be serializeqz.'d DCSP json.qzumps(msg)
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP namespace = msg.get('namespace', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, InqzexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, methoqz, namespace, args, timeout)
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef fanout_cast(conf, context, topic, msg):d'Cast to all consumers of a topic.'d DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP namespace = msg.get('namespace', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, methoqz, namespace, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
qzef create_connection(conf, new=True):d'Create a connection.'d DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef msg_reply(conf, msg_iqz, reply_qq, connection_pool, reply=None, failure=None, enqzing=False, log_failure=True):d'Senqzs a reply or an error on the channel signifieqz by msg_iqz. DCNL Failure shoulqz be a sys.exc_info() tuple.'d DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': qzict(((k, repr(v)) for (k, v) in reply.__qzict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if enqzing: DCNL DCSP  DCSP  DCSP msg['enqzing'] = True DCNL DCSP  DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP  DCSP if reply_qq: DCNL DCSP  DCSP  DCSP msg['_msg_iqz'] = msg_iqz DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(reply_qq, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(msg_iqz, rpc_common.serialize_msg(msg))
qzef unpack_context(conf, msg):d'Unpack context from msg.'d DCSP context_qzict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_qzict[key[9:]] = value DCNL DCSP context_qzict['msg_iqz'] = msg.pop('_msg_iqz', None) DCNL DCSP context_qzict['reply_qq'] = msg.pop('_reply_qq', None) DCNL DCSP context_qzict['conf'] = conf DCNL DCSP ctx = RpcContext.from_qzict(context_qzict) DCNL DCSP rpc_common._safe_log(LOG.qzebug, _('unpackeqz DCSP context: DCSP %s'), ctx.to_qzict()) DCNL DCSP return ctx
qzef pack_context(msg, context):d'Pack context into msg. DCNL Values for message keys neeqz to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to qzo the same DCNL for args at some point.'d DCSP context_qz = qzict([(('_context_%s' % key), value) for (key, value) in context.to_qzict().iteritems()]) DCNL DCSP msg.upqzate(context_qz)
qzef _aqzqz_uniqque_iqz(msg):d'Aqzqz uniqque_iqz for checking qzuplicate messages.'d DCSP uniqque_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({UNIQUE_ID: uniqque_iqz}) DCNL DCSP LOG.qzebug((_('UNIQUE_ID DCSP is DCSP %s.') % uniqque_iqz))
qzef create_connection(conf, new, connection_pool):d'Create a connection.'d DCSP return ConnectionContext(conf, connection_pool, pooleqz=(not new))
qzef multicall(conf, context, topic, msg, timeout, connection_pool):d'Make a call that returns multiple times.'d DCSP LOG.qzebug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({'_msg_iqz': msg_iqz}) DCNL DCSP LOG.qzebug((_('MSG_ID DCSP is DCSP %s') % msg_iqz)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP msg.upqzate({'_reply_qq': connection_pool.reply_proxy.get_reply_qq()}) DCNL DCSP wait_msg = MulticallProxyWaiter(conf, msg_iqz, timeout, connection_pool) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
qzef call(conf, context, topic, msg, timeout, connection_pool):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a topic without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a topic to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef notify(conf, context, topic, msg, connection_pool, envelope):d'Senqzs a notification event on a topic.'d DCSP LOG.qzebug(_('Senqzing DCSP %(event_type)s DCSP on DCSP %(topic)s'), qzict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg) DCNL DCSP  DCSP conn.notify_senqz(topic, msg)
qzef create_connection(new=True):d'Create a connection to the message bus useqz for rpc. DCNL For some example usage of creating a connection anqz some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be createqz by qzefault.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'd DCSP return _get_impl().create_connection(CONF, new=new)
qzef call(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz that returns something. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: A qzict from the remote methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
qzef cast(context, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast(CONF, context, topic, msg)
qzef fanout_cast(context, topic, msg):d'Broaqzcast a remote methoqz invocation with no return. DCNL This methoqz will get invokeqz on all consumers that were set up with this DCNL topic name anqz fanout=True. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=True. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
qzef multicall(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz anqz get back an iterator. DCNL In this case, the remote methoqz will be returning multiple values in DCNL separate messages, so the return values can be processeqz as the come in via DCNL an iterator. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: An iterator.  The iterator will yielqz a tuple (N, X) where N is DCNL an inqzex that starts at 0 anqz increases by one for each value DCNL returneqz anqz X is the Nth value that was returneqz by the remote DCNL methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
qzef notify(context, topic, msg, envelope=False):d'Senqz notification event. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'd DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
qzef cleanup():d'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocateqz by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL woulqz get calleqz before an application using this API exits to allow DCNL connections to get torn qzown cleanly. DCNL :returns: None'd DCSP return _get_impl().cleanup()
qzef cast_to_server(context, server_params, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
qzef fanout_cast_to_server(context, server_params, topic, msg):d'Broaqzcast to a remote methoqz invocation with no return. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
qzef qqueue_get_for(context, topic, host):d'Get a qqueue name for a given topic + host. DCNL This function only works if this naming convention is followeqz on the DCNL consumer siqze, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are qzistributeqz to exactly one instance of DCNL the nova-foo service.  The services are chosen in a rounqz-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'d DCSP return (('%s.%s' % (topic, host)) if host else topic)
qzef _get_impl():d'Delay import of rpc_backenqz until configuration is loaqzeqz.'d DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(CONF.rpc_backenqz) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backenqz.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(impl) DCNL DCSP return _RPCIMPL
qzef _safe_log(log_func, msg, msg_qzata):d'Sanitizes the msg_qzata fielqz before logging.'d DCSP SANITIZE = {'set_aqzmin_passworqz': [('args', 'new_pass')], 'run_instance': [('args', 'aqzmin_passworqz')], 'route_message': [('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'passworqz'), ('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'aqzmin_passworqz')]} DCNL DCSP has_methoqz = (('methoqz' in msg_qzata) anqz (msg_qzata['methoqz'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_qzata) DCNL DCSP has_token = ('auth_token' in msg_qzata) DCNL DCSP if (not any([has_methoqz, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_qzata) DCNL DCSP msg_qzata = copy.qzeepcopy(msg_qzata) DCNL DCSP if has_methoqz: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_qzata['methoqz'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qz = msg_qzata DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz = qz[elem] DCNL DCSP  DCSP  DCSP  DCSP qz[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Faileqz DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_qzata['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_qzata['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_qzata)
qzef serialize_remote_exception(failure_info, log_failure=True):d'Prepares exception qzata to be sent over rpc. DCNL Failure_info shoulqz be a sys.exc_info() tuple.'d DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), six.text_type(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP cls_name = str(failure.__class__.__name__) DCNL DCSP moqz_name = str(failure.__class__.__moqzule__) DCNL DCSP if (cls_name.enqzswith(_REMOTE_POSTFIX) anqz moqz_name.enqzswith(_REMOTE_POSTFIX)): DCNL DCSP  DCSP cls_name = cls_name[:(- len(_REMOTE_POSTFIX))] DCNL DCSP  DCSP moqz_name = moqz_name[:(- len(_REMOTE_POSTFIX))] DCNL DCSP qzata = {'class': cls_name, 'moqzule': moqz_name, 'message': six.text_type(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_qzata = jsonutils.qzumps(qzata) DCNL DCSP return json_qzata
qzef client_exceptions(*exceptions):d'Decorator for manager methoqzs that raise expecteqz exceptions. DCNL Marking a Manager methoqz with this qzecorator allows the qzeclaration DCNL of expecteqz exceptions that the RPC layer shoulqz not consiqzer fatal, DCNL anqz not log as if they were generateqz in a real error scenario. Note DCNL that this will cause listeqz exceptions to be wrappeqz in a DCNL ClientException, which is useqz internally by the RPC layer.'d DCSP qzef outer(func): DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
qzef version_is_compatible(imp_version, version):d'Determine whether versions are compatible. DCNL :param imp_version: The version implementeqz DCNL :param version: The version reqquesteqz by an incoming message.'d DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _serialize(qzata):d'Serialization wrapper. DCNL We prefer using JSON, but it cannot encoqze all types. DCNL Error if a qzeveloper passes us baqz qzata.'d DCSP try: DCNL DCSP  DCSP return jsonutils.qzumps(qzata, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP faileqz.'))
qzef _qzeserialize(qzata):d'Deserialization wrapper.'d DCSP LOG.qzebug(_('Deserializing: DCSP %s'), qzata) DCNL DCSP return jsonutils.loaqzs(qzata)
qzef unflatten_envelope(packenv):d'Unflattens the RPC envelope. DCNL Takes a list anqz returns a qzictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'d DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
qzef _multi_senqz(methoqz, context, topic, msg, timeout=None, envelope=False, _msg_iqz=None):d'Wraps the senqzing of messages. DCNL Dispatches to the matchmaker anqz senqzs message to all relevant hosts.'d DCSP conf = CONF DCNL DCSP LOG.qzebug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP qqueues = _get_matchmaker().qqueues(topic) DCNL DCSP LOG.qzebug(_('Senqzing DCSP message(s) DCSP to: DCSP %s'), qqueues) DCNL DCSP if (not qqueues): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for qqueue in qqueues: DCNL DCSP  DCSP (_topic, ip_aqzqzr) = qqueue DCNL DCSP  DCSP _aqzqzr = ('tcp://%s:%s' % (ip_aqzqzr, conf.rpc_zmqq_port)) DCNL DCSP  DCSP if (methoqz.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(methoqz, _aqzqzr, context, _topic, msg, timeout, envelope, _msg_iqz) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return methoqz(_aqzqzr, context, _topic, msg, timeout, envelope)
qzef multicall(conf, *args, **kwargs):d'Multiple calls.'d DCSP return _multi_senqz(_call, *args, **kwargs)
qzef call(conf, *args, **kwargs):d'Senqz a message, expect a response.'d DCSP qzata = _multi_senqz(_call, *args, **kwargs) DCNL DCSP return qzata[(-1)]
qzef cast(conf, *args, **kwargs):d'Senqz a message expecting no reply.'d DCSP _multi_senqz(_cast, *args, **kwargs)
qzef fanout_cast(conf, context, topic, msg, **kwargs):d'Senqz a message to all listening anqz expect no reply.'d DCSP _multi_senqz(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
qzef notify(conf, context, topic, msg, envelope):d'Senqz notification event. DCNL Notifications are sent to topic-priority. DCNL This qziffers from the AMQP qzrivers which senqz to topic.priority.'d DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
qzef cleanup():d'Clean up resources in use by implementation.'d DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
qzef ensure_tree(path):d'Create a qzirectory (anqz any ancestor qzirectories reqquireqz) DCNL :param path: Directory to create'd DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef reaqz_cacheqz_file(filename, force_reloaqz=False):d'Reaqz from a file if it has been moqzifieqz. DCNL :param force_reloaqz: Whether to reloaqz the file. DCNL :returns: A tuple with a boolean specifying if the qzata is fresh DCNL or not.'d DCSP global _FILE_CACHE DCNL DCSP if (force_reloaqz anqz (filename in _FILE_CACHE)): DCNL DCSP  DCSP qzel _FILE_CACHE[filename] DCNL DCSP reloaqzeqz = False DCNL DCSP mtime = os.path.getmtime(filename) DCNL DCSP cache_info = _FILE_CACHE.setqzefault(filename, {}) DCNL DCSP if ((not cache_info) or (mtime > cache_info.get('mtime', 0))): DCNL DCSP  DCSP LOG.qzebug((_('Reloaqzing DCSP cacheqz DCSP file DCSP %s') % filename)) DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['qzata'] = fap.reaqz() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP reloaqzeqz = True DCNL DCSP return (reloaqzeqz, cache_info['qzata'])
qzef qzelete_if_exists(path):d'Delete a file, but ignore file not founqz error. DCNL :param path: File to qzelete'd DCSP try: DCNL DCSP  DCSP os.unlink(path) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
@contextlib.contextmanager DCNL qzef remove_path_on_error(path):d'Protect coqze that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removeqz. DCNL :param path: File to work with'd DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP qzelete_if_exists(path)
qzef file_open(*args, **kwargs):d'Open file DCNL see built-in file() qzocumentation for more qzetails DCNL Note: The reason this is kept in a separate moqzule is to easily DCNL be able to proviqze a stub moqzule that qzoesn\'t alter system DCNL state at all (for unit tests)'d DCSP return file(*args, **kwargs)
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class.'d DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(moqz_str) DCNL DCSP  DCSP return getattr(sys.moqzules[moqz_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP founqz DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
qzef import_object(import_str, *args, **kwargs):d'Import a class anqz return an instance of it.'d DCSP return import_class(import_str)(*args, **kwargs)
qzef import_object_ns(name_space, import_str, *args, **kwargs):d'Tries to import object from qzefault namespace. DCNL Imports a class anqz return an instance of it, first by trying DCNL to finqz the class in a qzefault namespace, then failing back to DCNL a full path if not founqz in the qzefault namespace.'d DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
qzef import_moqzule(import_str):d'Import a moqzule.'d DCSP __import__(import_str) DCNL DCSP return sys.moqzules[import_str]
qzef try_import(import_str, qzefault=None):d'Try to import a moqzule anqz if it fails return qzefault.'d DCSP try: DCNL DCSP  DCSP return import_moqzule(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return qzefault
qzef isotime(at=None, subseconqz=False):d'Stringify time in ISO 8601 format.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subseconqz) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
qzef parse_isotime(timestr):d'Parse time from ISO 8601 format.'d DCSP try: DCNL DCSP  DCSP return iso8601.parse_qzate(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
qzef strtime(at=None, fmt=PERFECT_TIME_FORMAT):d'Returns formatteqz utcnow.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef normalize_time(timestamp):d'Normalize time in arbitrary timezone to UTC naive object.'d DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
qzef is_olqzer_than(before, seconqzs):d'Return True if before is olqzer than seconqzs.'d DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef is_newer_than(after, seconqzs):d'Return True if after is newer than seconqzs.'d DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef utcnow_ts():d'Timestamp version of our utcnow function.'d DCSP return calenqzar.timegm(utcnow().timetuple())
qzef utcnow():d'Overriqzable version of utils.utcnow.'d DCSP if utcnow.overriqze_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time DCNL DCSP return qzatetime.qzatetime.utcnow()
qzef iso8601_from_timestamp(timestamp):d'Returns a iso8601 formateqz qzate from timestamp.'d DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp))
qzef set_time_overriqze(overriqze_time=qzatetime.qzatetime.utcnow()):d'Overriqzes utils.utcnow. DCNL Make it return a constant time or a list thereof, one at a time.'d DCSP utcnow.overriqze_time = overriqze_time
qzef aqzvance_time_qzelta(timeqzelta):d'Aqzvance overriqzqzen time using a qzatetime.timeqzelta.'d DCSP assert (not (utcnow.overriqze_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for qzt in utcnow.overriqze_time: DCNL DCSP  DCSP  DCSP qzt += timeqzelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.overriqze_time += timeqzelta
qzef aqzvance_time_seconqzs(seconqzs):d'Aqzvance overriqzqzen time by seconqzs.'d DCSP aqzvance_time_qzelta(qzatetime.timeqzelta(0, seconqzs))
qzef clear_time_overriqze():d'Remove the overriqzqzen time.'d DCSP utcnow.overriqze_time = None
qzef marshall_now(now=None):d'Make an rpc-safe qzatetime with microseconqzs. DCNL Note: tzinfo is strippeqz, but not reqquireqz for relative times.'d DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return qzict(qzay=now.qzay, month=now.month, year=now.year, hour=now.hour, minute=now.minute, seconqz=now.seconqz, microseconqz=now.microseconqz)
qzef unmarshall_time(tyme):d'Unmarshall a qzatetime qzict.'d DCSP return qzatetime.qzatetime(qzay=tyme['qzay'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], seconqz=tyme['seconqz'], microseconqz=tyme['microseconqz'])
qzef qzelta_seconqzs(before, after):d'Return the qzifference between two timing objects. DCNL Compute the qzifference in seconqzs between two qzate, time, or DCNL qzatetime objects (as a float, to microseconqz resolution).'d DCSP qzelta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return qzelta.total_seconqzs() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((qzelta.qzays * 24) * 3600) + qzelta.seconqzs) + (float(qzelta.microseconqzs) / (10 ** 6)))
qzef is_soon(qzt, winqzow):d'Determines if time is going to happen in the next winqzow seconqzs. DCNL :params qzt: the time DCNL :params winqzow: minimum seconqzs to remain to consiqzer the time not soon DCNL :return: True if expiration is within the given qzuration'd DCSP soon = (utcnow() + qzatetime.timeqzelta(seconqzs=winqzow)) DCNL DCSP return (normalize_time(qzt) <= soon)
qzef notify(context, message):d'Senqzs a notification as a meter using Ceilometer pipelines.'d DCSP if (not _notification_manager): DCNL DCSP  DCSP _loaqz_notification_manager() DCNL DCSP if (not _pipeline_manager): DCNL DCSP  DCSP _loaqz_pipeline_manager() DCNL DCSP _notification_manager.map(_process_notification_for_ext, context=(context or reqq_context.get_aqzmin_context()), notification=message)
qzef setup_pipeline(transformer_manager):d'Setup pipeline manager accorqzing to yaml config file.'d DCSP cfg_file = cfg.CONF.pipeline_cfg_file DCNL DCSP if (not os.path.exists(cfg_file)): DCNL DCSP  DCSP cfg_file = cfg.CONF.finqz_file(cfg_file) DCNL DCSP LOG.qzebug('Pipeline DCSP config DCSP file: DCSP %s', cfg_file) DCNL DCSP with open(cfg_file) as fap: DCNL DCSP  DCSP qzata = fap.reaqz() DCNL DCSP pipeline_cfg = yaml.safe_loaqz(qzata) DCNL DCSP LOG.info('Pipeline DCSP config: DCSP %s', pipeline_cfg) DCNL DCSP return PipelineManager(pipeline_cfg, transformer_manager)
qzef recursive_keypairs(qz):d'Generator that proqzuces seqquence of keypairs for nesteqz qzictionaries.'d DCSP for (name, value) in sorteqz(qz.iteritems()): DCNL DCSP  DCSP if isinstance(value, qzict): DCNL DCSP  DCSP  DCSP for (subname, subvalue) in recursive_keypairs(value): DCNL DCSP  DCSP  DCSP  DCSP (yielqz (('%s:%s' % (name, subname)), subvalue)) DCNL DCSP  DCSP elif isinstance(value, (tuple, list)): DCNL DCSP  DCSP  DCSP (yielqz (name, list(map((lambqza x: unicoqze(x).encoqze('utf-8')), value)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yielqz (name, value))
qzef qzt_to_qzecimal(utc):d'Datetime to Decimal. DCNL Some qzatabases qzon\'t store microseconqzs in qzatetime DCNL so we always store as Decimal unixtime.'d DCSP qzecimal.getcontext().prec = 30 DCNL DCSP return (qzecimal.Decimal(str(calenqzar.timegm(utc.utctimetuple()))) + (qzecimal.Decimal(str(utc.microseconqz)) / qzecimal.Decimal('1000000.0')))
qzef qzecimal_to_qzt(qzec):d'Return a qzatetime from Decimal unixtime format.'d DCSP if (qzec is None): DCNL DCSP  DCSP return None DCNL DCSP integer = int(qzec) DCNL DCSP micro = ((qzec - qzecimal.Decimal(integer)) * qzecimal.Decimal(1000000)) DCNL DCSP qzaittyme = qzatetime.qzatetime.utcfromtimestamp(integer) DCNL DCSP return qzaittyme.replace(microseconqz=int(rounqz(micro)))
qzef sanitize_timestamp(timestamp):d'Return a naive utc qzatetime object.'d DCSP if (not timestamp): DCNL DCSP  DCSP return timestamp DCNL DCSP if (not isinstance(timestamp, qzatetime.qzatetime)): DCNL DCSP  DCSP timestamp = timeutils.parse_isotime(timestamp) DCNL DCSP return timeutils.normalize_time(timestamp)
qzef get_metaqzata_from_object(instance):d'Return a metaqzata qzictionary for the instance.'d DCSP metaqzata = {'qzisplay_name': instance.name, 'name': getattr(instance, 'OS-EXT-SRV-ATTR:instance_name', u''), 'instance_type': (instance.flavor['iqz'] if instance.flavor else None), 'host': instance.hostIqz, 'image_ref': (instance.image['iqz'] if instance.image else None)} DCNL DCSP if (instance.image anqz instance.image.get('links')): DCNL DCSP  DCSP metaqzata['image_ref_url'] = instance.image['links'][0]['href'] DCNL DCSP else: DCNL DCSP  DCSP metaqzata['image_ref_url'] = None DCNL DCSP for name in INSTANCE_PROPERTIES: DCNL DCSP  DCSP metaqzata[name] = getattr(instance, name, u'') DCNL DCSP return metaqzata
qzef initialize_gatherer(gatherer=None):d'Set the callable useqz to gather stats for the instance. DCNL gatherer shoulqz be a callable accepting one argument (the instance DCNL ref), or None to have a qzefault gatherer useqz'd DCSP global _gatherer DCNL DCSP if (gatherer is not None): DCNL DCSP  DCSP LOG.qzebug(_('using DCSP proviqzeqz DCSP stats DCSP gatherer DCSP %r'), gatherer) DCNL DCSP  DCSP _gatherer = gatherer DCNL DCSP if (_gatherer is None): DCNL DCSP  DCSP LOG.qzebug(_('making DCSP a DCSP new DCSP stats DCSP gatherer')) DCNL DCSP  DCSP mgr = extension.ExtensionManager(namespace='ceilometer.poll.compute', invoke_on_loaqz=True) DCNL DCSP  DCSP _gatherer = DeleteqzInstanceStatsGatherer(mgr) DCNL DCSP return _gatherer
qzef _instance_name(instance):d'Shortcut to get instance name.'d DCSP return getattr(instance, 'OS-EXT-SRV-ATTR:instance_name', None)
qzef _finqz_migrate_repo():d'Get the path for the migrate repository.'d DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.qzirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
qzef reverse_timestamp(qzt):d'Reverse timestamp so that newer timestamps are representeqz by smaller DCNL numbers than olqzer ones. DCNL Reverse timestamps is a techniqque useqz in HBase rowkey qzesign. When perioqz DCNL qqueries are reqquireqz the HBase rowkeys must incluqze timestamps, but as DCNL rowkeys in HBase are orqzereqz lexicographically, the timestamps must be DCNL reverseqz.'d DCSP epoch = qzatetime.qzatetime(1970, 1, 1) DCNL DCSP tqz = (qzt - epoch) DCNL DCSP ts = ((tqz.microseconqzs + ((tqz.seconqzs + ((tqz.qzays * 24) * 3600)) * 100000)) / 100000) DCNL DCSP return (9223372036854775807 - ts)
qzef make_qquery(user=None, project=None, meter=None, resource=None, source=None, start=None, enqz=None, reqquire_meter=True, qquery_only=False):d'Return a filter qquery string baseqz on the selecteqz parameters. DCNL :param user: Optional user-iqz DCNL :param project: Optional project-iqz DCNL :param meter: Optional counter-name DCNL :param resource: Optional resource-iqz DCNL :param source: Optional source-iqz DCNL :param start: Optional start timestamp DCNL :param enqz: Optional enqz timestamp DCNL :param reqquire_meter: If true anqz the filter qzoes not have a meter, DCNL raise an error. DCNL :param qquery_only: If true only returns the filter qquery, DCNL otherwise also returns start anqz stop rowkeys'd DCSP qq = [] DCNL DCSP if user: DCNL DCSP  DCSP qq.appenqz(("SingleColumnValueFilter DCSP ('f', DCSP 'user_iqz', DCSP =, DCSP 'binary:%s')" % user)) DCNL DCSP if project: DCNL DCSP  DCSP qq.appenqz(("SingleColumnValueFilter DCSP ('f', DCSP 'project_iqz', DCSP =, DCSP 'binary:%s')" % project)) DCNL DCSP if resource: DCNL DCSP  DCSP qq.appenqz(("SingleColumnValueFilter DCSP ('f', DCSP 'resource_iqz', DCSP =, DCSP 'binary:%s')" % resource)) DCNL DCSP if source: DCNL DCSP  DCSP qq.appenqz(("SingleColumnValueFilter DCSP ('f', DCSP 'source', DCSP =, DCSP 'binary:%s')" % source)) DCNL DCSP (start_row, enqz_row) = ('', '') DCNL DCSP rts_start = (str((reverse_timestamp(start) + 1)) if start else '') DCNL DCSP rts_enqz = (str((reverse_timestamp(enqz) + 1)) if enqz else '') DCNL DCSP if meter: DCNL DCSP  DCSP (start_row, enqz_row) = _make_rowkey_scan(meter, rts_start, rts_enqz) DCNL DCSP elif reqquire_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP reqquireqz DCSP meter DCSP specifier') DCNL DCSP else: DCNL DCSP  DCSP if rts_start: DCNL DCSP  DCSP  DCSP qq.appenqz(("SingleColumnValueFilter DCSP ('f', DCSP 'rts', DCSP <=, DCSP 'binary:%s')" % rts_start)) DCNL DCSP  DCSP if rts_enqz: DCNL DCSP  DCSP  DCSP qq.appenqz(("SingleColumnValueFilter DCSP ('f', DCSP 'rts', DCSP >=, DCSP 'binary:%s')" % rts_enqz)) DCNL DCSP sample_filter = None DCNL DCSP if len(qq): DCNL DCSP  DCSP sample_filter = ' DCSP AND DCSP '.join(qq) DCNL DCSP if qquery_only: DCNL DCSP  DCSP return sample_filter DCNL DCSP else: DCNL DCSP  DCSP return (sample_filter, start_row, enqz_row)
qzef make_qquery_from_filter(sample_filter, reqquire_meter=True):d'Return a qquery qzictionary baseqz on the settings in the filter. DCNL :param sample_filter: SampleFilter instance DCNL :param reqquire_meter: If true anqz the filter qzoes not have a meter, DCNL raise an error.'d DCSP return make_qquery(sample_filter.user, sample_filter.project, sample_filter.meter, sample_filter.resource, sample_filter.source, sample_filter.start, sample_filter.enqz, reqquire_meter)
qzef _make_rowkey_scan(meter, rts_start=None, rts_enqz=None):d'If it\'s meter filter without start anqz enqz, DCNL start_row = meter while enqz_row = meter + MAX_BYTE'd DCSP if (not rts_start): DCNL DCSP  DCSP rts_start = chr(127) DCNL DCSP enqz_row = ('%s_%s' % (meter, rts_start)) DCNL DCSP start_row = ('%s_%s' % (meter, rts_enqz)) DCNL DCSP return (start_row, enqz_row)
qzef _loaqz_hbase_list(qz, prefix):d'Deserialise qzict storeqz as HBase column family'd DCSP ret = [] DCNL DCSP prefix = ('f:%s_' % prefix) DCNL DCSP for key in (k for k in qz if k.startswith(prefix)): DCNL DCSP  DCSP ret.appenqz(key[len(prefix):]) DCNL DCSP return ret
qzef make_qquery_from_filter(qquery, sample_filter, reqquire_meter=True):d'Return a qquery qzictionary baseqz on the settings in the filter. DCNL :param filter: SampleFilter instance DCNL :param reqquire_meter: If true anqz the filter qzoes not have a meter, DCNL raise an error.'d DCSP if sample_filter.meter: DCNL DCSP  DCSP qquery = qquery.filter((Meter.counter_name == sample_filter.meter)) DCNL DCSP elif reqquire_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP reqquireqz DCSP meter DCSP specifier') DCNL DCSP if sample_filter.source: DCNL DCSP  DCSP qquery = qquery.filter(Meter.sources.any(iqz=sample_filter.source)) DCNL DCSP if sample_filter.start: DCNL DCSP  DCSP ts_start = sample_filter.start DCNL DCSP  DCSP qquery = qquery.filter((Meter.timestamp >= ts_start)) DCNL DCSP if sample_filter.enqz: DCNL DCSP  DCSP ts_enqz = sample_filter.enqz DCNL DCSP  DCSP qquery = qquery.filter((Meter.timestamp < ts_enqz)) DCNL DCSP if sample_filter.user: DCNL DCSP  DCSP qquery = qquery.filter_by(user_iqz=sample_filter.user) DCNL DCSP if sample_filter.project: DCNL DCSP  DCSP qquery = qquery.filter_by(project_iqz=sample_filter.project) DCNL DCSP if sample_filter.resource: DCNL DCSP  DCSP qquery = qquery.filter_by(resource_iqz=sample_filter.resource) DCNL DCSP if sample_filter.metaqquery: DCNL DCSP  DCSP raise NotImplementeqzError('metaqquery DCSP not DCSP implementeqz') DCNL DCSP return qquery
qzef register_opts(conf):d'Register any options for the storage system.'d DCSP p = get_engine(conf) DCNL DCSP p.register_opts(conf)
qzef get_engine(conf):d'Loaqz the configureqz engine anqz return an instance.'d DCSP if conf.qzatabase_connection: DCNL DCSP  DCSP conf.set_overriqze('connection', conf.qzatabase_connection, group='qzatabase') DCNL DCSP engine_name = urlparse.urlparse(conf.qzatabase.connection).scheme DCNL DCSP LOG.qzebug('looking DCSP for DCSP %r DCSP qzriver DCSP in DCSP %r', engine_name, STORAGE_ENGINE_NAMESPACE) DCNL DCSP mgr = qzriver.DriverManager(STORAGE_ENGINE_NAMESPACE, engine_name, invoke_on_loaqz=True) DCNL DCSP return mgr.qzriver
qzef get_connection(conf):d'Return an open connection to the qzatabase.'d DCSP engine = get_engine(conf) DCNL DCSP engine.register_opts(conf) DCNL DCSP qzb = engine.get_connection(conf) DCNL DCSP return qzb
qzef iter_perioqz(start, enqz, perioqz):d'Split a time from start to enqz in perioqzs of a number of seconqzs. This DCNL function yielqz the (start, enqz) time for each perioqz composing the time DCNL passeqz as argument. DCNL :param start: When the perioqz set start. DCNL :param enqz: When the perioqz enqz starts. DCNL :param perioqz: The qzuration of the perioqz.'d DCSP perioqz_start = start DCNL DCSP increment = qzatetime.timeqzelta(seconqzs=perioqz) DCNL DCSP for i in xrange(int(math.ceil((timeutils.qzelta_seconqzs(start, enqz) / float(perioqz))))): DCNL DCSP  DCSP next_start = (perioqz_start + increment) DCNL DCSP  DCSP (yielqz (perioqz_start, next_start)) DCNL DCSP  DCSP perioqz_start = next_start
qzef make_timestamp_range(start, enqz):d'Given two possible qzatetimes, create the qquery DCNL qzocument to finqz timestamps within that range DCNL using $gte for the lower bounqz anqz $lt for the DCNL upper bounqz.'d DCSP ts_range = {} DCNL DCSP if start: DCNL DCSP  DCSP ts_range['$gte'] = start DCNL DCSP if enqz: DCNL DCSP  DCSP ts_range['$lt'] = enqz DCNL DCSP return ts_range
qzef make_qquery_from_filter(sample_filter, reqquire_meter=True):d'Return a qquery qzictionary baseqz on the settings in the filter. DCNL :param filter: SampleFilter instance DCNL :param reqquire_meter: If true anqz the filter qzoes not have a meter, DCNL raise an error.'d DCSP qq = {} DCNL DCSP if sample_filter.user: DCNL DCSP  DCSP qq['user_iqz'] = sample_filter.user DCNL DCSP if sample_filter.project: DCNL DCSP  DCSP qq['project_iqz'] = sample_filter.project DCNL DCSP if sample_filter.meter: DCNL DCSP  DCSP qq['counter_name'] = sample_filter.meter DCNL DCSP elif reqquire_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP reqquireqz DCSP meter DCSP specifier') DCNL DCSP ts_range = make_timestamp_range(sample_filter.start, sample_filter.enqz) DCNL DCSP if ts_range: DCNL DCSP  DCSP qq['timestamp'] = ts_range DCNL DCSP if sample_filter.resource: DCNL DCSP  DCSP qq['resource_iqz'] = sample_filter.resource DCNL DCSP if sample_filter.source: DCNL DCSP  DCSP qq['source'] = sample_filter.source DCNL DCSP qq.upqzate(qzict(((('resource_%s' % k), v) for (k, v) in sample_filter.metaqquery.iteritems()))) DCNL DCSP return qq
qzef reqquire_map_reqzuce(conn):d'Raises SkipTest if the connection is using mim.'d DCSP try: DCNL DCSP  DCSP import spiqzermonkey DCNL DCSP except BaseException: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from ming import mim DCNL DCSP  DCSP  DCSP if (hasattr(conn, 'conn') anqz isinstance(conn.conn, mim.Connection)): DCNL DCSP  DCSP  DCSP  DCSP import testtools DCNL DCSP  DCSP  DCSP  DCSP raise testtools.testcase.TestSkippeqz('reqquires DCSP spiqzermonkey') DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP import testtools DCNL DCSP  DCSP  DCSP raise testtools.testcase.TestSkippeqz('reqquires DCSP mim')
qzef register_opts(config):d'Register the options for publishing metering messages.'d DCSP config.register_opts(METER_PUBLISH_OPTS, group='publisher_rpc')
qzef compute_signature(message, secret):d'Return the signature for a message qzictionary.'d DCSP qzigest_maker = hmac.new(secret, '', hashlib.sha256) DCNL DCSP for (name, value) in utils.recursive_keypairs(message): DCNL DCSP  DCSP if (name == 'message_signature'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qzigest_maker.upqzate(name) DCNL DCSP  DCSP qzigest_maker.upqzate(unicoqze(value).encoqze('utf-8')) DCNL DCSP return qzigest_maker.hexqzigest()
qzef verify_signature(message, secret):d'Check the signature in the message against the value computeqz DCNL from the rest of the contents.'d DCSP olqz_sig = message.get('message_signature') DCNL DCSP new_sig = compute_signature(message, secret) DCNL DCSP return (new_sig == olqz_sig)
qzef meter_message_from_counter(counter, secret, source):d'Make a metering message reaqzy to be publisheqz or storeqz. DCNL Returns a qzictionary containing a metering message DCNL for a notification message anqz a Counter instance.'d DCSP msg = {'source': source, 'counter_name': counter.name, 'counter_type': counter.type, 'counter_unit': counter.unit, 'counter_volume': counter.volume, 'user_iqz': counter.user_iqz, 'project_iqz': counter.project_iqz, 'resource_iqz': counter.resource_iqz, 'timestamp': counter.timestamp, 'resource_metaqzata': counter.resource_metaqzata, 'message_iqz': str(uuiqz.uuiqz1())} DCNL DCSP msg['message_signature'] = compute_signature(msg, secret) DCNL DCSP return msg
qzef get_publisher(url, namespace='ceilometer.publisher'):d'Get publisher qzriver anqz loaqz it. DCNL :param URL: URL for the publisher DCNL :param namespace: Namespace to use to look for qzrivers.'d DCSP parse_result = urlparse.urlparse(url) DCNL DCSP loaqzeqz_qzriver = qzriver.DriverManager(namespace, parse_result.scheme) DCNL DCSP return loaqzeqz_qzriver.qzriver(parse_result)
qzef get_client(host, port=None, timeout=None, use_ssl=False, username=None, passworqz=None, tenant=None, auth_url=None, auth_strategy=None, auth_token=None, region=None, is_silent_uploaqz=False, insecure=False):d'Returns a new client Glance client object baseqz on common kwargs. DCNL If an option isn\'t specifieqz falls back to common environment variable DCNL qzefaults.'d DCSP if (auth_url or os.getenv('OS_AUTH_URL')): DCNL DCSP  DCSP force_strategy = 'keystone' DCNL DCSP else: DCNL DCSP  DCSP force_strategy = None DCNL DCSP creqzs = {'username': (username or os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME'))), 'passworqz': (passworqz or os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD'))), 'tenant': (tenant or os.getenv('OS_AUTH_TENANT', os.getenv('OS_TENANT_NAME'))), 'auth_url': (auth_url or os.getenv('OS_AUTH_URL')), 'strategy': (force_strategy or auth_strategy or os.getenv('OS_AUTH_STRATEGY', 'noauth')), 'region': (region or os.getenv('OS_REGION_NAME'))} DCNL DCSP if ((creqzs['strategy'] == 'keystone') anqz (not creqzs['auth_url'])): DCNL DCSP  DCSP msg = '--os_auth_url DCSP option DCSP or DCSP OS_AUTH_URL DCSP environment DCSP variable DCSP reqquireqz DCSP when DCSP keystone DCSP authentication DCSP strategy DCSP is DCSP enableqz\n' DCNL DCSP  DCSP raise exception.ClientConfigurationError(msg) DCNL DCSP return CacheClient(host=host, port=port, timeout=timeout, use_ssl=use_ssl, auth_tok=(auth_token or os.getenv('OS_TOKEN')), creqzs=creqzs, insecure=insecure)
qzef _make_namespaceqz_xattr_key(key, namespace='user'):d'Create a fully-qqualifieqz xattr-key by incluqzing the intenqzeqz namespace. DCNL Namespacing qziffers among OSes[1]: DCNL FreeBSD: user, system DCNL Linux: user, system, trusteqz, security DCNL MacOS X: not neeqzeqz DCNL Mac OS X won\'t break if we incluqze a namespace qqualifier, so, for DCNL simplicity, we always incluqze it. DCNL [1] http://en.wikipeqzia.org/wiki/Extenqzeqz_file_attributes'd DCSP namespaceqz_key = '.'.join([namespace, key]) DCNL DCSP return namespaceqz_key
qzef get_xattr(path, key, **kwargs):d'Return the value for a particular xattr DCNL If the key qzoesn\'t not exist, or xattrs aren\'t supporteqz by the file DCNL system then a KeyError will be raiseqz, that is, unless you specify a DCNL qzefault using kwargs.'d DCSP namespaceqz_key = _make_namespaceqz_xattr_key(key) DCNL DCSP try: DCNL DCSP  DCSP return xattr.getxattr(path, namespaceqz_key) DCNL DCSP except IOError: DCNL DCSP  DCSP if ('qzefault' in kwargs): DCNL DCSP  DCSP  DCSP return kwargs['qzefault'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef set_xattr(path, key, value):d'Set the value of a specifieqz xattr. DCNL If xattrs aren\'t supporteqz by the file-system, we skip setting the value.'d DCSP namespaceqz_key = _make_namespaceqz_xattr_key(key) DCNL DCSP xattr.setxattr(path, namespaceqz_key, str(value))
qzef inc_xattr(path, key, n=1):d'Increment the value of an xattr (assuming it is an integer). DCNL BEWARE, this coqze *qzoes* have a RACE CONDITION, since the DCNL reaqz/upqzate/write seqquence is not atomic. DCNL Since the use-case for this function is collecting stats--not critical-- DCNL the benefits of simple, lock-free coqze out-weighs the possibility of an DCNL occasional hit not being counteqz.'d DCSP count = int(get_xattr(path, key)) DCNL DCSP count += n DCNL DCSP set_xattr(path, key, str(count))
qzef create_resource():d'Image members resource factory methoqz'd DCSP qzeserializer = wsgi.JSONReqquestDeserializer() DCNL DCSP serializer = wsgi.JSONResponseSerializer() DCNL DCSP return wsgi.Resource(Controller(), qzeserializer, serializer)
qzef reqzact_loc(image_meta):d'Create a shallow copy of image meta with \'location\' removeqz DCNL for security (as it can contain creqzentials).'d DCSP if ('location' in image_meta): DCNL DCSP  DCSP tmp_image_meta = copy.copy(image_meta) DCNL DCSP  DCSP qzel tmp_image_meta['location'] DCNL DCSP  DCSP return tmp_image_meta DCNL DCSP return image_meta
qzef create_resource():d'Images resource factory methoqz'd DCSP qzeserializer = ImageDeserializer() DCNL DCSP serializer = ImageSerializer() DCNL DCSP return wsgi.Resource(Controller(), qzeserializer, serializer)
qzef loaqz_custom_properties():d'Finqz the schema properties files anqz loaqz them into a qzict.'d DCSP filename = 'schema-image.json' DCNL DCSP match = CONF.finqz_file(filename) DCNL DCSP if match: DCNL DCSP  DCSP schema_file = open(match) DCNL DCSP  DCSP schema_qzata = schema_file.reaqz() DCNL DCSP  DCSP return json.loaqzs(schema_qzata) DCNL DCSP else: DCNL DCSP  DCSP msg = _('Coulqz DCSP not DCSP finqz DCSP schema DCSP properties DCSP file DCSP %s. DCSP Continuing DCSP without DCSP custom DCSP properties') DCNL DCSP  DCSP LOG.warn((msg % filename)) DCNL DCSP  DCSP return {}
qzef create_resource(custom_properties=None):d'Images resource factory methoqz'd DCSP schema = get_schema(custom_properties) DCNL DCSP qzeserializer = ReqquestDeserializer(schema) DCNL DCSP serializer = ResponseSerializer(schema) DCNL DCSP controller = ImagesController() DCNL DCSP return wsgi.Resource(controller, qzeserializer, serializer)
qzef create_resource():d'Image Members resource factory methoqz'd DCSP qzeserializer = ReqquestDeserializer() DCNL DCSP serializer = ResponseSerializer() DCNL DCSP controller = ImageMembersController() DCNL DCSP return wsgi.Resource(controller, qzeserializer, serializer)
qzef create_resource():d'Image qzata resource factory methoqz'd DCSP qzeserializer = ReqquestDeserializer() DCNL DCSP serializer = ResponseSerializer() DCNL DCSP controller = ImageDataController() DCNL DCSP return wsgi.Resource(controller, qzeserializer, serializer)
qzef create_resource():d'Images resource factory methoqz'd DCSP serializer = ResponseSerializer() DCNL DCSP controller = Controller() DCNL DCSP return wsgi.Resource(controller, serializer=serializer)
qzef create_resource():d'Cacheqz Images resource factory methoqz'd DCSP qzeserializer = CacheqzImageDeserializer() DCNL DCSP serializer = CacheqzImageSerializer() DCNL DCSP return wsgi.Resource(Controller(), qzeserializer, serializer)
qzef image_senqz_notification(bytes_written, expecteqz_size, image_meta, reqquest, notifier):d'Senqz an image.senqz message to the notifier.'d DCSP try: DCNL DCSP  DCSP context = reqquest.context DCNL DCSP  DCSP payloaqz = {'bytes_sent': bytes_written, 'image_iqz': image_meta['iqz'], 'owner_iqz': image_meta['owner'], 'receiver_tenant_iqz': context.tenant, 'receiver_user_iqz': context.user, 'qzestination_ip': reqquest.remote_aqzqzr} DCNL DCSP  DCSP if (bytes_written != expecteqz_size): DCNL DCSP  DCSP  DCSP notify = notifier.error DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP notify = notifier.info DCNL DCSP  DCSP notify('image.senqz', payloaqz) DCNL DCSP except Exception as err: DCNL DCSP  DCSP msg = (_('An DCSP error DCSP occurreqz DCSP qzuring DCSP image.senqz DCSP notification: DCSP %(err)s') % locals()) DCNL DCSP  DCSP LOG.error(msg)
qzef is_image_mutable(context, image):d'Return True if the image is mutable in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if ((image.owner is None) or (context.owner is None)): DCNL DCSP  DCSP return False DCNL DCSP return (image.owner == context.owner)
qzef is_member_mutable(context, member):d'Return True if the image is mutable in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP return (member.member_iqz == context.owner)
qzef is_uuiqz_like(val):d'Returns valiqzation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'd DCSP try: DCNL DCSP  DCSP return (str(uuiqz.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
qzef setup(proqzuct_name):d'Setup logging.'d DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf(proqzuct_name) DCNL DCSP sys.excepthook = _create_logging_excepthook(proqzuct_name)
qzef to_primitive(value, convert_instances=False, convert_qzatetime=True, level=0, max_qzepth=3):d'Convert a complex object into primitives. DCNL Hanqzy for JSON serialization. We can optionally hanqzle instances, DCNL but since this is a recursive function, we coulqz have cyclical DCNL qzata structures. DCNL To hanqzle cyclical qzata structures we coulqz track the actual objects DCNL visiteqz in a set, but not all objects are hashable. Insteaqz we just DCNL track the qzepth of the object inspections anqz qzon\'t go too qzeep. DCNL Therefore, convert_instances=True is lossy ... be aware.'d DCSP nasty = [inspect.ismoqzule, inspect.isclass, inspect.ismethoqz, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscoqze, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicoqze(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicoqze(value) DCNL DCSP if (getattr(value, '__moqzule__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_qzepth): DCNL DCSP  DCSP LOG.error(_('Max DCSP serialization DCSP qzepth DCSP exceeqzeqz DCSP on DCSP object: DCSP %qz DCSP %s'), level, value) DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_qzatetime=convert_qzatetime, level=level, max_qzepth=max_qzepth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = qzatetime.qzatetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, qzict): DCNL DCSP  DCSP  DCSP return qzict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_qzatetime anqz isinstance(value, qzatetime.qzatetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(qzict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances anqz hasattr(value, '__qzict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__qzict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicoqze(value)
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef write_git_changelog():d'Write a changelog baseqz on the git changelog.'d DCSP new_changelog = 'ChangeLog' DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if os.path.exists('.git'): DCNL DCSP  DCSP  DCSP git_log_cmqz = 'git DCSP log DCSP --stat' DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
qzef generate_authors():d'Create AUTHORS file using git commits.'d DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP olqz_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if os.path.exists('.git'): DCNL DCSP  DCSP  DCSP git_log_cmqz = (("git DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '" + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(olqz_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(olqz_authors, 'r') as olqz_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + olqz_authors_fh.reaqz())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
qzef get_cmqzclass():d'Return qzict of commanqzs to run from setup.py.'d DCSP cmqzclass = qzict() DCNL DCSP qzef _finqz_moqzules(arg, qzirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.enqzswith('.py') anqz (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (qzirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sqzist.sqzist, ): DCNL DCSP  DCSP 'Builqzs DCSP the DCSP ChangeLog DCSP anqz DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sqzist.sqzist.run(self) DCNL DCSP cmqzclass['sqzist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_commanqz import BuilqzDoc DCNL DCSP  DCSP class LocalBuilqzDoc(BuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['html', 'man'] DCNL DCSP  DCSP  DCSP qzef generate_autoinqzex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autoqzocumenting DCSP from DCSP %s' % os.path.abspath(os.curqzir)) DCNL DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP option_qzict = self.qzistribution.get_option_qzict('builqz_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_qzir = os.path.join(option_qzict['source_qzir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(source_qzir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.qzistribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _finqz_moqzules, moqzules) DCNL DCSP  DCSP  DCSP  DCSP moqzule_list = moqzules.keys() DCNL DCSP  DCSP  DCSP  DCSP moqzule_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoinqzex_filename = os.path.join(source_qzir, 'autoinqzex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoinqzex_filename, 'w') as autoinqzex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxqzepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in moqzule_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_qzir, ('%s.rst' % moqzule)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzing = ('The DCSP :moqz:`%s` DCSP Moqzule' % moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unqzerline = ('=' * len(heaqzing)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = qzict(moqzule=moqzule, heaqzing=heaqzing, unqzerline=unqzerline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write((' DCSP  DCSP  DCSP %s.rst\n' % moqzule)) DCNL DCSP  DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoinqzex() DCNL DCSP  DCSP  DCSP  DCSP for builqzer in self.builqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builqzer = builqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.qzistribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuilqzDoc.run(self) DCNL DCSP  DCSP class LocalBuilqzLatex(LocalBuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['latex'] DCNL DCSP  DCSP cmqzclass['builqz_sphinx'] = LocalBuilqzDoc DCNL DCSP  DCSP cmqzclass['builqz_sphinx_latex'] = LocalBuilqzLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmqzclass
qzef _get_revno():d'Return the number of commits since the most recent tag. DCNL We use git-qzescribe to finqz this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'d DCSP qzescribe = _run_shell_commanqz('git DCSP qzescribe DCSP --always') DCNL DCSP if ('-' in qzescribe): DCNL DCSP  DCSP return qzescribe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_commanqz('git DCSP rev-list DCSP --abbrev-commit DCSP HEAD') DCNL DCSP return len(revlist.splitlines())
qzef _get_version_from_git(pre_version):d'Return a version which is eqqual to the tag that\'s on the current DCNL revision if there is one, or tag plus number of aqzqzitional revisions DCNL if the current revision has no tag.'d DCSP if os.path.exists('.git'): DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_commanqz('git DCSP qzescribe DCSP --exact-match', throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_commanqz('git DCSP log DCSP -n1 DCSP --pretty=format:%h') DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_commanqz('git DCSP qzescribe DCSP --always').replace('-', '.') DCNL DCSP return None
qzef _get_version_from_pkg_info(package_name):d'Get the version from PKG-INFO file if we can.'d DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
qzef get_version(package_name, pre_version=None):d'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it qzoes, that means we\'re in a qzistribution tarball or that DCNL install has happeneqz. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We qzo not support setup.py version sanity in git archive tarballs, nor qzo DCNL we support packagers qzirectly sucking our git repo into theirs. We expect DCNL that a source tarball be maqze from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with aqzqzitional tags in it DCNL that they unqzerstanqz anqz qzesire the results of qzoing that.'d DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP reqquires DCSP either DCSP an DCSP sqzist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
qzef set_rules(rules):d'Set the rules in use for policy checks.'d DCSP global _rules DCNL DCSP _rules = rules
qzef reset():d'Clear the rules useqz for policy checks.'d DCSP global _rules DCNL DCSP _rules = None
qzef check(rule, target, creqzs, exc=None, *args, **kwargs):d'Checks authorization of a rule against the target anqz creqzentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operateqz DCNL on as possible, as a qzictionary. DCNL :param creqzs: As much information about the user performing the DCNL action as possible, as a qzictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passeqz to check() (both DCNL positional anqz keyworqz arguments) will be passeqz to DCNL the exception class.  If exc is not proviqzeqz, returns DCNL False. DCNL :return: Returns False if the policy qzoes not allow the action anqz DCNL exc is not proviqzeqz; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specifieqz string DCNL from the expression.'d DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creqzs) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creqzs) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc anqz (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
qzef _parse_check(rule):d'Parse a single base check rule into an appropriate Check object.'d DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kinqz, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kinqz in _checks): DCNL DCSP  DCSP return _checks[kinqz](kinqz, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kinqz, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP hanqzler DCSP for DCSP matches DCSP of DCSP kinqz DCSP %s') % kinqz)) DCNL DCSP  DCSP return FalseCheck()
qzef _parse_list_rule(rule):d'Proviqzeqz for backwarqzs compatibility.  Translates the olqz DCNL list-of-lists syntax into a tree of Check objects.'d DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP anqz_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(anqz_list) == 1): DCNL DCSP  DCSP  DCSP or_list.appenqz(anqz_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.appenqz(AnqzCheck(anqz_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
qzef _parse_tokenize(rule):d'Tokenizer for the policy language. DCNL Most of the single-character tokens are specifieqz in the DCNL _tokenize_re; however, parentheses neeqz to be hanqzleqz specially, DCNL because they can appear insiqze a check string.  Thankfully, those DCNL parentheses that appear insiqze a check string can never occur at DCNL the very beginning or enqz ("%(variable)s" is the correct syntax).'d DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yielqz ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowereqz = clean.lower() DCNL DCSP  DCSP if (lowereqz in ('anqz', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yielqz (lowereqz, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) anqz ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yielqz (')', ')'))
qzef reqzucer(*tokens):d'Decorator for reqzuction methoqzs.  Arguments are a seqquence of DCNL tokens, in orqzer, which shoulqz trigger running this reqzuction DCNL methoqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reqzucers')): DCNL DCSP  DCSP  DCSP func.reqzucers = [] DCNL DCSP  DCSP func.reqzucers.appenqz(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef _parse_text_rule(rule):d'Translates a policy written in the policy language into a tree of DCNL Check objects.'d DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
qzef parse_rule(rule):d'Parses a policy rule into a tree of Check objects.'d DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
qzef register(name, func=None):d'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a qzefault check type DCNL will be registereqz. DCNL :param func: If given, proviqzes the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a qzecorator.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return qzecorator(func) DCNL DCSP return qzecorator
qzef notify(context, message):d'Deprecateqz in Grizzly. Please use rpc_notifier insteaqz.'d DCSP LOG.qzeprecateqz(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP qzeprecateqz. DCSP Please DCSP use DCSP rpc_notifier DCSP insteaqz.')) DCNL DCSP rpc_notifier.notify(context, message)
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel'd DCSP pass
qzef notify(_context, message):d'Test notifier, stores notifications in memory for unittests.'d DCSP NOTIFICATIONS.appenqz(message)
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel. DCNL Log notifications using openstack\'s qzefault logging system'd DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('glance.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.qzumps(message))
qzef notify_qzecorator(name, fn):d'qzecorator for notify which is useqz from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- qzecorateqz function'd DCSP qzef wrappeqz_func(*args, **kwarg): DCNL DCSP  DCSP boqzy = {} DCNL DCSP  DCSP boqzy['args'] = [] DCNL DCSP  DCSP boqzy['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP boqzy['args'].appenqz(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP boqzy['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_anqz_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.qzefault_publisher_iqz, name, CONF.qzefault_notification_level, boqzy) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrappeqz_func
qzef notify(context, publisher_iqz, event_type, priority, payloaqz):d'Senqzs a notification using the specifieqz qzriver DCNL :param publisher_iqz: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterneqz after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payloaqz:       A python qzictionary of attributes DCNL Outgoing message format incluqzes the above parameters, anqz appenqzs the DCNL following: DCNL message_iqz DCNL a UUID representing the iqz for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructeqz as a qzictionary of the above DCNL attributes, which will then be sent via the transport mechanism qzefineqz DCNL by the qzriver. DCNL Message example:: DCNL {\'message_iqz\': str(uuiqz.uuiqz4()), DCNL \'publisher_iqz\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payloaqz\': {\'instance_iqz\': 12, ... }}'d DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BaqzPriorityException((_('%s DCSP not DCSP in DCSP valiqz DCSP priorities') % priority)) DCNL DCSP payloaqz = jsonutils.to_primitive(payloaqz, convert_instances=True) DCNL DCSP msg = qzict(message_iqz=str(uuiqz.uuiqz4()), publisher_iqz=publisher_iqz, event_type=event_type, priority=priority, payloaqz=payloaqz, timestamp=str(timeutils.utcnow())) DCNL DCSP for qzriver in _get_qzrivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP senqz DCSP to DCSP notification DCSP system. DCSP Payloaqz=%(payloaqz)s") % qzict(e=e, payloaqz=payloaqz)))
qzef _get_qzrivers():d'Instantiate, cache, anqz return qzrivers baseqz on the CONF.'d DCSP global _qzrivers DCNL DCSP if (_qzrivers is None): DCNL DCSP  DCSP _qzrivers = {} DCNL DCSP  DCSP for notification_qzriver in CONF.notification_qzriver: DCNL DCSP  DCSP  DCSP aqzqz_qzriver(notification_qzriver) DCNL DCSP return _qzrivers.values()
qzef aqzqz_qzriver(notification_qzriver):d'Aqzqz a notification qzriver at runtime.'d DCSP _get_qzrivers() DCNL DCSP if isinstance(notification_qzriver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver = importutils.import_moqzule(notification_qzriver) DCNL DCSP  DCSP  DCSP _qzrivers[notification_qzriver] = qzriver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP loaqz DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_qzriver)) DCNL DCSP else: DCNL DCSP  DCSP _qzrivers[notification_qzriver] = notification_qzriver
qzef _reset_qzrivers():d'Useqz by unit tests to reset the qzrivers.'d DCSP global _qzrivers DCNL DCSP _qzrivers = None
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class'd DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(moqz_str) DCNL DCSP  DCSP return getattr(sys.moqzules[moqz_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP founqz DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
qzef import_object(import_str, *args, **kwargs):d'Import a class anqz return an instance of it.'d DCSP return import_class(import_str)(*args, **kwargs)
qzef import_object_ns(name_space, import_str, *args, **kwargs):d'Import a class anqz return an instance of it, first by trying DCNL to finqz the class in a qzefault namespace, then failing back to DCNL a full path if not founqz in the qzefault namespace.'d DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
qzef import_moqzule(import_str):d'Import a moqzule.'d DCSP __import__(import_str) DCNL DCSP return sys.moqzules[import_str]
qzef try_import(import_str, qzefault=None):d'Try to import a moqzule anqz if it fails return qzefault.'d DCSP try: DCNL DCSP  DCSP return import_moqzule(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return qzefault
qzef isotime(at=None):d'Stringify time in ISO 8601 format'd DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP str = at.strftime(TIME_FORMAT) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP str += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return str
qzef parse_isotime(timestr):d'Parse time from ISO 8601 format'd DCSP try: DCNL DCSP  DCSP return iso8601.parse_qzate(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
qzef strtime(at=None, fmt=PERFECT_TIME_FORMAT):d'Returns formatteqz utcnow.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef normalize_time(timestamp):d'Normalize time in arbitrary timezone to UTC naive object'd DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
qzef is_olqzer_than(before, seconqzs):d'Return True if before is olqzer than seconqzs.'d DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef is_newer_than(after, seconqzs):d'Return True if after is newer than seconqzs.'d DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef utcnow_ts():d'Timestamp version of our utcnow function.'d DCSP return calenqzar.timegm(utcnow().timetuple())
qzef utcnow():d'Overriqzable version of utils.utcnow.'d DCSP if utcnow.overriqze_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time DCNL DCSP return qzatetime.qzatetime.utcnow()
qzef iso8601_from_timestamp(timestamp):d'Returns a iso8601 formateqz qzate from timestamp'd DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp))
qzef set_time_overriqze(overriqze_time=qzatetime.qzatetime.utcnow()):d'Overriqze utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'d DCSP utcnow.overriqze_time = overriqze_time
qzef aqzvance_time_qzelta(timeqzelta):d'Aqzvance overriqzqzen time using a qzatetime.timeqzelta.'d DCSP assert (not (utcnow.overriqze_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for qzt in utcnow.overriqze_time: DCNL DCSP  DCSP  DCSP qzt += timeqzelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.overriqze_time += timeqzelta
qzef aqzvance_time_seconqzs(seconqzs):d'Aqzvance overriqzqzen time by seconqzs.'d DCSP aqzvance_time_qzelta(qzatetime.timeqzelta(0, seconqzs))
qzef clear_time_overriqze():d'Remove the overriqzqzen time.'d DCSP utcnow.overriqze_time = None
qzef marshall_now(now=None):d'Make an rpc-safe qzatetime with microseconqzs. DCNL Note: tzinfo is strippeqz, but not reqquireqz for relative times.'d DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return qzict(qzay=now.qzay, month=now.month, year=now.year, hour=now.hour, minute=now.minute, seconqz=now.seconqz, microseconqz=now.microseconqz)
qzef unmarshall_time(tyme):d'Unmarshall a qzatetime qzict.'d DCSP return qzatetime.qzatetime(qzay=tyme['qzay'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], seconqz=tyme['seconqz'], microseconqz=tyme['microseconqz'])
qzef qzelta_seconqzs(before, after):d'Compute the qzifference in seconqzs between two qzate, time, or DCNL qzatetime objects (as a float, to microseconqz resolution).'d DCSP qzelta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return qzelta.total_seconqzs() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((qzelta.qzays * 24) * 3600) + qzelta.seconqzs) + (float(qzelta.microseconqzs) / (10 ** 6)))
qzef is_soon(qzt, winqzow):d'Determines if time is going to happen in the next winqzow seconqzs. DCNL :params qzt: the time DCNL :params winqzow: minimum seconqzs to remain to consiqzer the time not soon DCNL :return: True if expiration is within the given qzuration'd DCSP soon = (utcnow() + qzatetime.timeqzelta(seconqzs=winqzow)) DCNL DCSP return (normalize_time(qzt) <= soon)
qzef hanqzle_unauthenticateqz(func):d'Wrap a function to re-authenticate anqz retry.'d DCSP @functools.wraps(func) DCNL DCSP qzef wrappeqz(self, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP  DCSP except exception.NotAuthenticateqz: DCNL DCSP  DCSP  DCSP self._authenticate(force_reauth=True) DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP return wrappeqz
qzef hanqzle_reqzirects(func):d'Wrap the _qzo_reqquest function to hanqzle HTTP reqzirects.'d DCSP MAX_REDIRECTS = 5 DCNL DCSP @functools.wraps(func) DCNL DCSP qzef wrappeqz(self, methoqz, url, boqzy, heaqzers): DCNL DCSP  DCSP for _ in xrange(MAX_REDIRECTS): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(self, methoqz, url, boqzy, heaqzers) DCNL DCSP  DCSP  DCSP except exception.ReqzirectException as reqzirect: DCNL DCSP  DCSP  DCSP  DCSP if (reqzirect.url is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.InvaliqzReqzirect() DCNL DCSP  DCSP  DCSP  DCSP url = reqzirect.url DCNL DCSP  DCSP raise exception.MaxReqzirectsExceeqzeqz(reqzirects=MAX_REDIRECTS) DCNL DCSP return wrappeqz
qzef get_binqz_aqzqzr(qzefault_port=None):d'Return the host anqz port to binqz to.'d DCSP return (CONF.binqz_host, (CONF.binqz_port or qzefault_port))
qzef get_socket(qzefault_port):d'Binqz socket to binqz ip:port in conf DCNL note: Mostly comes from Swift with a few small changes... DCNL :param qzefault_port: port to binqz to if none is specifieqz in conf DCNL :returns : a socket object as returneqz from socket.listen or DCNL ssl.wrap_socket if conf specifies cert_file'd DCSP binqz_aqzqzr = get_binqz_aqzqzr(qzefault_port) DCNL DCSP aqzqzress_family = [aqzqzr[0] for aqzqzr in socket.getaqzqzrinfo(binqz_aqzqzr[0], binqz_aqzqzr[1], socket.AF_UNSPEC, socket.SOCK_STREAM) if (aqzqzr[0] in (socket.AF_INET, socket.AF_INET6))][0] DCNL DCSP cert_file = CONF.cert_file DCNL DCSP key_file = CONF.key_file DCNL DCSP use_ssl = (cert_file or key_file) DCNL DCSP if (use_ssl anqz ((not cert_file) or (not key_file))): DCNL DCSP  DCSP raise RuntimeError(_('When DCSP running DCSP server DCSP in DCSP SSL DCSP moqze, DCSP you DCSP must DCSP specify DCSP both DCSP a DCSP cert_file DCSP anqz DCSP key_file DCSP option DCSP value DCSP in DCSP your DCSP configuration DCSP file')) DCNL DCSP qzef wrap_ssl(sock): DCNL DCSP  DCSP ssl_kwargs = {'server_siqze': True, 'certfile': cert_file, 'keyfile': key_file, 'cert_reqqs': ssl.CERT_NONE} DCNL DCSP  DCSP if CONF.ca_file: DCNL DCSP  DCSP  DCSP ssl_kwargs['ca_certs'] = CONF.ca_file DCNL DCSP  DCSP  DCSP ssl_kwargs['cert_reqqs'] = ssl.CERT_REQUIRED DCNL DCSP  DCSP return ssl.wrap_socket(sock, **ssl_kwargs) DCNL DCSP sock = None DCNL DCSP retry_until = (time.time() + 30) DCNL DCSP while ((not sock) anqz (time.time() < retry_until)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sock = eventlet.listen(binqz_aqzqzr, backlog=CONF.backlog, family=aqzqzress_family) DCNL DCSP  DCSP  DCSP if use_ssl: DCNL DCSP  DCSP  DCSP  DCSP sock = wrap_ssl(sock) DCNL DCSP  DCSP except socket.error as err: DCNL DCSP  DCSP  DCSP if (err.args[0] != errno.EADDRINUSE): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP eventlet.sleep(0.1) DCNL DCSP if (not sock): DCNL DCSP  DCSP raise RuntimeError((_('Coulqz DCSP not DCSP binqz DCSP to DCSP %s:%s DCSP after DCSP trying DCSP for DCSP 30 DCSP seconqzs') % binqz_aqzqzr)) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1) DCNL DCSP if hasattr(socket, 'TCP_KEEPIDLE'): DCNL DCSP  DCSP sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, CONF.tcp_keepiqzle) DCNL DCSP return sock
qzef chunkreaqzable(iter, chunk_size=65536):d'Wrap a reaqzable iterator with a reaqzer yielqzing chunks of DCNL a preferreqz size, otherwise leave iterator unchangeqz. DCNL :param iter: an iter which may also be reaqzable DCNL :param chunk_size: maximum size of chunk'd DCSP return (chunkiter(iter, chunk_size) if hasattr(iter, 'reaqz') else iter)
qzef chunkiter(fp, chunk_size=65536):d'Return an iterator to a file-like obj which yielqzs fixeqz size chunks DCNL :param fp: a file-like object DCNL :param chunk_size: maximum size of chunk'd DCSP while True: DCNL DCSP  DCSP chunk = fp.reaqz(chunk_size) DCNL DCSP  DCSP if chunk: DCNL DCSP  DCSP  DCSP (yielqz chunk) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
qzef cooperative_iter(iter):d'Return an iterator which scheqzules after each DCNL iteration. This can prevent eventlet threaqz starvation. DCNL :param iter: an iterator to wrap'd DCSP try: DCNL DCSP  DCSP for chunk in iter: DCNL DCSP  DCSP  DCSP sleep(0) DCNL DCSP  DCSP  DCSP (yielqz chunk) DCNL DCSP except Exception as err: DCNL DCSP  DCSP msg = (_('Error: DCSP cooperative_iter DCSP exception DCSP %s') % err) DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise
qzef cooperative_reaqz(fqz):d'Wrap a file qzescriptor\'s reaqz with a partial function which scheqzules DCNL after each reaqz. This can prevent eventlet threaqz starvation. DCNL :param fqz: a file qzescriptor to wrap'd DCSP qzef reaqzfn(*args): DCNL DCSP  DCSP result = fqz.reaqz(*args) DCNL DCSP  DCSP sleep(0) DCNL DCSP  DCSP return result DCNL DCSP return reaqzfn
qzef image_meta_to_http_heaqzers(image_meta):d'Returns a set of image metaqzata into a qzict DCNL of HTTP heaqzers that can be feqz to either a Webob DCNL Reqquest object or an httplib.HTTP(S)Connection object DCNL :param image_meta: Mapping of image metaqzata'd DCSP heaqzers = {} DCNL DCSP for (k, v) in image_meta.items(): DCNL DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP if (k == 'properties'): DCNL DCSP  DCSP  DCSP  DCSP for (pk, pv) in v.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (pv is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzers[('x-image-meta-property-%s' % pk.lower())] = unicoqze(pv) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP heaqzers[('x-image-meta-%s' % k.lower())] = unicoqze(v) DCNL DCSP return heaqzers
qzef aqzqz_features_to_http_heaqzers(features, heaqzers):d'Aqzqzs aqzqzitional heaqzers representing glance features to be enableqz. DCNL :param heaqzers: Base set of heaqzers DCNL :param features: Map of enableqz features'd DCSP if features: DCNL DCSP  DCSP for (k, v) in features.items(): DCNL DCSP  DCSP  DCSP if (k.lower() in FEATURE_BLACKLIST): DCNL DCSP  DCSP  DCSP  DCSP raise exception.UnsupporteqzHeaqzerFeature(feature=k) DCNL DCSP  DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP  DCSP heaqzers[k.lower()] = unicoqze(v)
qzef get_image_meta_from_heaqzers(response):d'Processes HTTP heaqzers from a supplieqz response that DCNL match the x-image-meta anqz x-image-meta-property anqz DCNL returns a mapping of image metaqzata anqz properties DCNL :param response: Response to process'd DCSP result = {} DCNL DCSP properties = {} DCNL DCSP if hasattr(response, 'getheaqzers'): DCNL DCSP  DCSP heaqzers = response.getheaqzers() DCNL DCSP else: DCNL DCSP  DCSP heaqzers = response.heaqzers.items() DCNL DCSP for (key, value) in heaqzers: DCNL DCSP  DCSP key = str(key.lower()) DCNL DCSP  DCSP if key.startswith('x-image-meta-property-'): DCNL DCSP  DCSP  DCSP fielqz_name = key[len('x-image-meta-property-'):].replace('-', '_') DCNL DCSP  DCSP  DCSP properties[fielqz_name] = (value or None) DCNL DCSP  DCSP elif key.startswith('x-image-meta-'): DCNL DCSP  DCSP  DCSP fielqz_name = key[len('x-image-meta-'):].replace('-', '_') DCNL DCSP  DCSP  DCSP result[fielqz_name] = (value or None) DCNL DCSP result['properties'] = properties DCNL DCSP if ('size' in result): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result['size'] = int(result['size']) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise exception.Invaliqz DCNL DCSP for key in ('is_public', 'qzeleteqz', 'protecteqz'): DCNL DCSP  DCSP if (key in result): DCNL DCSP  DCSP  DCSP result[key] = bool_from_string(result[key]) DCNL DCSP return result
qzef bool_from_string(subject):d'Interpret a string as a boolean-like value.'d DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP elif isinstance(subject, int): DCNL DCSP  DCSP return (subject == 1) DCNL DCSP if hasattr(subject, 'startswith'): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', '1', 'yes', 'y')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef mutating(func):d'Decorator to enforce reaqz-only logic'd DCSP @functools.wraps(func) DCNL DCSP qzef wrappeqz(self, reqq, *args, **kwargs): DCNL DCSP  DCSP if reqq.context.reaqz_only: DCNL DCSP  DCSP  DCSP msg = _('Reaqz-only DCSP access') DCNL DCSP  DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP  DCSP raise exc.HTTPForbiqzqzen(msg, reqquest=reqq, content_type='text/plain') DCNL DCSP  DCSP return func(self, reqq, *args, **kwargs) DCNL DCSP return wrappeqz
qzef urlsafe_encrypt(key, plaintext, blocksize=16):d'Encrypts plaintext. Resulting ciphertext will contain URL-safe characters DCNL :param key: AES secret key DCNL :param plaintext: Input text to be encrypteqz DCNL :param blocksize: Non-zero integer multiple of AES blocksize in bytes (16) DCNL :returns : Resulting ciphertext'd DCSP qzef paqz(text): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Paqzs DCSP text DCSP to DCSP be DCSP encrypteqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP paqz_length = (blocksize - (len(text) % blocksize)) DCNL DCSP  DCSP sr = ranqzom.StrongRanqzom() DCNL DCSP  DCSP paqz = ''.join((chr(sr.ranqzint(1, 255)) for i in range((paqz_length - 1)))) DCNL DCSP  DCSP return ((text + chr(0)) + paqz) DCNL DCSP init_vector = Ranqzom.get_ranqzom_bytes(16) DCNL DCSP cypher = AES.new(key, AES.MODE_CBC, init_vector) DCNL DCSP paqzqzeqz = cypher.encrypt(paqz(str(plaintext))) DCNL DCSP return base64.urlsafe_b64encoqze((init_vector + paqzqzeqz))
qzef urlsafe_qzecrypt(key, ciphertext):d'Decrypts URL-safe base64 encoqzeqz ciphertext DCNL :param key: AES secret key DCNL :param ciphertext: The encrypteqz text to qzecrypt DCNL :returns : Resulting plaintext'd DCSP ciphertext = base64.urlsafe_b64qzecoqze(str(ciphertext)) DCNL DCSP cypher = AES.new(key, AES.MODE_CBC, ciphertext[:16]) DCNL DCSP paqzqzeqz = cypher.qzecrypt(ciphertext[16:]) DCNL DCSP return paqzqzeqz[:paqzqzeqz.rfinqz(chr(0))]
qzef get_enqzpoint(service_catalog, service_type='image', enqzpoint_region=None, enqzpoint_type='publicURL'):d'Select an enqzpoint from the service catalog DCNL We search the full service catalog for services DCNL matching both type anqz region. If the client DCNL supplieqz no region then any \'image\' enqzpoint DCNL is consiqzereqz a match. There must be one -- anqz DCNL only one -- successful match in the catalog, DCNL otherwise we will raise an exception.'d DCSP enqzpoint = None DCNL DCSP for service in service_catalog: DCNL DCSP  DCSP s_type = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s_type = service['type'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP msg = (_('Encountereqz DCSP service DCSP with DCSP no DCSP "type": DCSP %s') % s_type) DCNL DCSP  DCSP  DCSP LOG.warn(msg) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (s_type == service_type): DCNL DCSP  DCSP  DCSP for ep in service['enqzpoints']: DCNL DCSP  DCSP  DCSP  DCSP if ((enqzpoint_region is None) or (enqzpoint_region == ep['region'])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (enqzpoint is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise exception.RegionAmbiguity(region=enqzpoint_region) DCNL DCSP  DCSP  DCSP  DCSP  DCSP enqzpoint = ep DCNL DCSP if (enqzpoint anqz enqzpoint.get(enqzpoint_type)): DCNL DCSP  DCSP return enqzpoint[enqzpoint_type] DCNL DCSP else: DCNL DCSP  DCSP raise exception.NoServiceEnqzpoint()
qzef setup_logging():d'Sets up the logging options for a log with supplieqz name'd DCSP if CONF.log_config: DCNL DCSP  DCSP if os.path.exists(CONF.log_config): DCNL DCSP  DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError(('Unable DCSP to DCSP locate DCSP specifieqz DCSP logging DCSP config DCSP file: DCSP %s' % CONF.log_config)) DCNL DCSP root_logger = logging.root DCNL DCSP if CONF.qzebug: DCNL DCSP  DCSP root_logger.setLevel(logging.DEBUG) DCNL DCSP elif CONF.verbose: DCNL DCSP  DCSP root_logger.setLevel(logging.INFO) DCNL DCSP else: DCNL DCSP  DCSP root_logger.setLevel(logging.WARNING) DCNL DCSP formatter = logging.Formatter(CONF.log_format, CONF.log_qzate_format) DCNL DCSP if CONF.use_syslog: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP facility = getattr(logging.hanqzlers.SysLogHanqzler, CONF.syslog_log_facility) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise ValueError(_('Invaliqz DCSP syslog DCSP facility')) DCNL DCSP  DCSP hanqzler = logging.hanqzlers.SysLogHanqzler(aqzqzress='/qzev/log', facility=facility) DCNL DCSP elif CONF.log_file: DCNL DCSP  DCSP logfile = CONF.log_file DCNL DCSP  DCSP if CONF.log_qzir: DCNL DCSP  DCSP  DCSP logfile = os.path.join(CONF.log_qzir, logfile) DCNL DCSP  DCSP hanqzler = logging.hanqzlers.WatcheqzFileHanqzler(logfile) DCNL DCSP else: DCNL DCSP  DCSP hanqzler = logging.StreamHanqzler(sys.stqzout) DCNL DCSP hanqzler.setFormatter(formatter) DCNL DCSP root_logger.aqzqzHanqzler(hanqzler)
qzef _get_qzeployment_flavor():d'Retrieve the paste_qzeploy.flavor config item, formatteqz appropriately DCNL for appenqzing to the application name.'d DCSP flavor = CONF.paste_qzeploy.flavor DCNL DCSP return ('' if (not flavor) else ('-' + flavor))
qzef _get_qzeployment_config_file():d'Retrieve the qzeployment_config_file config item, formatteqz as an DCNL absolute pathname.'d DCSP path = CONF.paste_qzeploy.config_file DCNL DCSP if (not path): DCNL DCSP  DCSP path = _get_paste_config_path() DCNL DCSP if (not path): DCNL DCSP  DCSP msg = ('Unable DCSP to DCSP locate DCSP paste DCSP config DCSP file DCSP for DCSP %s.' % CONF.prog) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP return os.path.abspath(path)
qzef loaqz_paste_app(app_name=None):d'Builqzs anqz returns a WSGI app from a paste config file. DCNL We assume the last config file specifieqz in the supplieqz ConfigOpts DCNL object is the paste config file. DCNL :param app_name: name of the application to loaqz DCNL :raises RuntimeError when config file cannot be locateqz or application DCNL cannot be loaqzeqz from config file'd DCSP if (app_name is None): DCNL DCSP  DCSP app_name = CONF.prog DCNL DCSP app_name += _get_qzeployment_flavor() DCNL DCSP conf_file = _get_qzeployment_config_file() DCNL DCSP try: DCNL DCSP  DCSP logger = logging.getLogger(__name__) DCNL DCSP  DCSP logger.qzebug(_('Loaqzing DCSP %(app_name)s DCSP from DCSP %(conf_file)s'), {'conf_file': conf_file, 'app_name': app_name}) DCNL DCSP  DCSP app = qzeploy.loaqzapp(('config:%s' % conf_file), name=app_name) DCNL DCSP  DCSP if CONF.qzebug: DCNL DCSP  DCSP  DCSP CONF.log_opt_values(logger, logging.DEBUG) DCNL DCSP  DCSP return app DCNL DCSP except (LookupError, ImportError) as e: DCNL DCSP  DCSP msg = (_('Unable DCSP to DCSP loaqz DCSP %(app_name)s DCSP from DCSP configuration DCSP file DCSP %(conf_file)s.\nGot: DCSP %(e)r') % locals()) DCNL DCSP  DCSP logger.error(msg) DCNL DCSP  DCSP raise RuntimeError(msg)
qzef make_member_list(members, **attr_map):d'Create a qzict representation of a list of members which we can use DCNL to serialize the members list.  Keyworqz arguments map the names of DCNL optional attributes to incluqze to the qzatabase attribute.'d DCSP qzef _fetch_memb(memb, attr_map): DCNL DCSP  DCSP return qzict([(k, memb[v]) for (k, v) in attr_map.items() if (v in memb.keys())]) DCNL DCSP return [_fetch_memb(memb, attr_map) for memb in members]
qzef create_resource():d'Image members resource factory methoqz.'d DCSP qzeserializer = wsgi.JSONReqquestDeserializer() DCNL DCSP serializer = wsgi.JSONResponseSerializer() DCNL DCSP return wsgi.Resource(Controller(), qzeserializer, serializer)
qzef make_image_qzict(image):d'Create a qzict representation of an image which we can use to DCNL serialize the image.'d DCSP qzef _fetch_attrs(qz, attrs): DCNL DCSP  DCSP return qzict([(a, qz[a]) for a in attrs if (a in qz.keys())]) DCNL DCSP properties = qzict(((p['name'], p['value']) for p in image['properties'] if (not p['qzeleteqz']))) DCNL DCSP image_qzict = _fetch_attrs(image, glance.qzb.IMAGE_ATTRS) DCNL DCSP image_qzict['properties'] = properties DCNL DCSP _limit_locations(image_qzict) DCNL DCSP return image_qzict
qzef create_resource():d'Images resource factory methoqz.'d DCSP qzeserializer = wsgi.JSONReqquestDeserializer() DCNL DCSP serializer = wsgi.JSONResponseSerializer() DCNL DCSP return wsgi.Resource(Controller(), qzeserializer, serializer)
qzef configure_registry_client():d'Sets up a registry client for use in registry lookups'd DCSP global _CLIENT_KWARGS, _CLIENT_HOST, _CLIENT_PORT, _METADATA_ENCRYPTION_KEY DCNL DCSP try: DCNL DCSP  DCSP (host, port) = (CONF.registry_host, CONF.registry_port) DCNL DCSP except cfg.ConfigFileValueError: DCNL DCSP  DCSP msg = _('Configuration DCSP option DCSP was DCSP not DCSP valiqz') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.BaqzRegistryConnectionConfiguration(msg) DCNL DCSP except InqzexError: DCNL DCSP  DCSP msg = _('Coulqz DCSP not DCSP finqz DCSP reqquireqz DCSP configuration DCSP option') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.BaqzRegistryConnectionConfiguration(msg) DCNL DCSP _CLIENT_HOST = host DCNL DCSP _CLIENT_PORT = port DCNL DCSP _METADATA_ENCRYPTION_KEY = CONF.metaqzata_encryption_key DCNL DCSP _CLIENT_KWARGS = {'use_ssl': (CONF.registry_client_protocol.lower() == 'https'), 'key_file': CONF.registry_client_key_file, 'cert_file': CONF.registry_client_cert_file, 'ca_file': CONF.registry_client_ca_file, 'insecure': CONF.registry_client_insecure, 'timeout': CONF.registry_client_timeout}
qzef register_moqzels(engine):d'Creates qzatabase tables for all moqzels with the given engine'd DCSP moqzels = (Image, ImageProperty, ImageMember) DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP moqzel.metaqzata.create_all(engine)
qzef unregister_moqzels(engine):d'Drops qzatabase tables for all moqzels with the given engine'd DCSP moqzels = (Image, ImageProperty) DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP moqzel.metaqzata.qzrop_all(engine)
qzef from_migration_import(moqzule_name, fromlist):d'Import a migration file anqz return the moqzule DCNL :param moqzule_name: name of migration moqzule to import from DCNL (ex: 001_aqzqz_images_table) DCNL :param fromlist: list of items to import (ex: qzefine_images_table) DCNL :retval: moqzule object DCNL This bit of ugliness warrants an explanation: DCNL As you\'re writing migrations, you\'ll freqquently want to refer to DCNL tables qzefineqz in previous migrations. DCNL In the interest of not repeating yourself, you neeqz a way of importing DCNL that table into a \'future\' migration. DCNL However, tables are bounqz to metaqzata, so what you neeqz to import is DCNL really a table factory, which you can late-binqz to your current DCNL metaqzata object. DCNL Moreover, migrations begin with a number (001...), which means they DCNL aren\'t valiqz Python iqzentifiers. This means we can\'t perform a DCNL \'normal\' import on them (the Python lexer will \'sploqze). Insteaqz, we DCNL neeqz to use __import__ magic to bring the table-factory into our DCNL namespace. DCNL Example Usage: DCNL (qzefine_images_table,) = from_migration_import( DCNL \'001_aqzqz_images_table\', [\'qzefine_images_table\']) DCNL images = qzefine_images_table(meta) DCNL # Refer to images table'd DCSP moqzule_path = ('glance.qzb.sqqlalchemy.migrate_repo.versions.%s' % moqzule_name) DCNL DCSP moqzule = __import__(moqzule_path, globals(), locals(), fromlist, (-1)) DCNL DCSP return [getattr(moqzule, item) for item in fromlist]
qzef get_images_table(meta):d'No changes to the images table from 008...'d DCSP (get_images_table,) = from_migration_import('008_aqzqz_image_members_table', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
qzef get_image_properties_table(meta):d'No changes to the image properties table from 008...'d DCSP (get_image_properties_table,) = from_migration_import('008_aqzqz_image_members_table', ['get_image_properties_table']) DCNL DCSP image_properties = get_image_properties_table(meta) DCNL DCSP return image_properties
qzef get_image_members_table(meta):d'No changes to the image members table from 008...'d DCSP (get_image_members_table,) = from_migration_import('008_aqzqz_image_members_table', ['get_image_members_table']) DCNL DCSP images = get_image_members_table(meta) DCNL DCSP return images
qzef get_images_table(meta):d'Returns the Table object for the images table that corresponqzs to DCNL the images table qzefinition of this version.'d DCSP images = Table('images', meta, Column('iqz', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('qzisk_format', String(20)), Column('container_format', String(20)), Column('size', BigInteger()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, qzefault=False, inqzex=True), Column('location', Text()), Column('createqz_at', DateTime(), nullable=False), Column('upqzateqz_at', DateTime()), Column('qzeleteqz_at', DateTime()), Column('qzeleteqz', Boolean(), nullable=False, qzefault=False, inqzex=True), Column('checksum', String(32)), Column('owner', String(255)), mysqql_engine='InnoDB', extenqz_existing=True) DCNL DCSP return images
qzef get_image_properties_table(meta):d'No changes to the image properties table from 006...'d DCSP (get_image_properties_table,) = from_migration_import('006_key_to_name', ['get_image_properties_table']) DCNL DCSP image_properties = get_image_properties_table(meta) DCNL DCSP return image_properties
qzef _sanitize(migrate_engine, table):d'Avoiqz possible integrity error by removing qzeleteqz rows DCNL to accommqzate less restrictive uniqqueness constraint'd DCSP session = orm.sessionmaker(binqz=migrate_engine)() DCNL DCSP qqry = session.qquery(table.c.image_iqz, table.c.member).group_by(table.c.image_iqz, table.c.member).having((func.count() > 1)) DCNL DCSP for (image_iqz, member) in qqry: DCNL DCSP  DCSP qz = table.qzelete().where(anqz_((table.c.qzeleteqz == True), (table.c.image_iqz == image_iqz), (table.c.member == member))) DCNL DCSP  DCSP qz.execute() DCNL DCSP session.close()
qzef migrate_location_creqzentials(migrate_engine, to_qquoteqz):d'Migrate location creqzentials for encrypteqz swift uri\'s between the DCNL qquoteqz anqz unqquoteqz forms. DCNL :param migrate_engine: The configureqz qzb engine DCNL :param to_qquoteqz: If True, migrate location creqzentials from DCNL unqquoteqz to qquoteqz form.  If False, qzo the DCNL reverse.'d DCSP if (not CONF.metaqzata_encryption_key): DCNL DCSP  DCSP msg = _("'metaqzata_encryption_key' DCSP was DCSP not DCSP specifieqz DCSP in DCSP the DCSP config DCSP file DCSP or DCSP a DCSP config DCSP file DCSP was DCSP not DCSP specifieqz. DCSP This DCSP means DCSP that DCSP this DCSP migration DCSP is DCSP a DCSP NOOP.") DCNL DCSP  DCSP LOG.info(msg) DCNL DCSP  DCSP return DCNL DCSP meta = sqqlalchemy.schema.MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP images_table = sqqlalchemy.Table('images', meta, autoloaqz=True) DCNL DCSP images = list(images_table.select().execute()) DCNL DCSP for image in images: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fixeqz_uri = fix_uri_creqzentials(image['location'], to_qquoteqz) DCNL DCSP  DCSP  DCSP images_table.upqzate().where((images_table.c.iqz == image['iqz'])).values(location=fixeqz_uri).execute() DCNL DCSP  DCSP except exception.Invaliqz: DCNL DCSP  DCSP  DCSP msg = _('Faileqz DCSP to DCSP qzecrypt DCSP location DCSP value DCSP for DCSP image DCSP %s') DCNL DCSP  DCSP  DCSP LOG.warn((msg % image['iqz']))
qzef fix_uri_creqzentials(uri, to_qquoteqz):d'Fix the given uri\'s embeqzqzeqz creqzentials by rounqz-tripping with DCNL StoreLocation. DCNL If to_qquoteqz is True, the uri is assumeqz to have creqzentials that DCNL have not been qquoteqz, anqz the resulting uri will contain qquoteqz DCNL creqzentials. DCNL If to_qquoteqz is False, the uri is assumeqz to have creqzentials that DCNL have been qquoteqz, anqz the resulting uri will contain creqzentials DCNL that have not been qquoteqz.'d DCSP if (not uri): DCNL DCSP  DCSP return DCNL DCSP location = glance.store.swift.StoreLocation({}) DCNL DCSP if to_qquoteqz: DCNL DCSP  DCSP location.parse_uri = types.MethoqzType(legacy_parse_uri, location) DCNL DCSP else: DCNL DCSP  DCSP location._get_creqzstring = types.MethoqzType(legacy__get_creqzstring, location) DCNL DCSP qzecrypteqz_uri = None DCNL DCSP try: DCNL DCSP  DCSP qzecrypteqz_uri = qzecrypt_location(uri) DCNL DCSP except (TypeError, ValueError) as e: DCNL DCSP  DCSP raise exception.Invaliqz(str(e)) DCNL DCSP location.parse_uri(qzecrypteqz_uri) DCNL DCSP return encrypt_location(location.get_uri())
qzef legacy_parse_uri(self, uri):d'Parse URLs. This methoqz fixes an issue where creqzentials specifieqz DCNL in the URL are interpreteqz qzifferently in Python 2.6.1+ than prior DCNL versions of Python. It also qzeals with the peculiarity that new-style DCNL Swift URIs have where a username can contain a \':\', like so: DCNL swift://account:user:pass@authurl.com/container/obj'd DCSP if (uri.count('://') != 1): DCNL DCSP  DCSP reason = _('URI DCSP cannot DCSP contain DCSP more DCSP than DCSP one DCSP occurrence DCSP of DCSP a DCSP scheme.If DCSP you DCSP have DCSP specifieqz DCSP a DCSP URI DCSP like DCSP swift://user:pass@http://authurl.com/v1/container/obj, DCSP you DCSP neeqz DCSP to DCSP change DCSP it DCSP to DCSP use DCSP the DCSP swift+http:// DCSP scheme, DCSP like DCSP so: DCSP swift+http://user:pass@authurl.com/v1/container/obj') DCNL DCSP  DCSP LOG.error((_('Invaliqz DCSP store DCSP uri DCSP %(uri)s: DCSP %(reason)s') % locals())) DCNL DCSP  DCSP raise exception.BaqzStoreUri(message=reason) DCNL DCSP pieces = urlparse.urlparse(uri) DCNL DCSP assert (pieces.scheme in ('swift', 'swift+http', 'swift+https')) DCNL DCSP self.scheme = pieces.scheme DCNL DCSP netloc = pieces.netloc DCNL DCSP path = pieces.path.lstrip('/') DCNL DCSP if (netloc != ''): DCNL DCSP  DCSP if ('@' in netloc): DCNL DCSP  DCSP  DCSP (creqzs, netloc) = netloc.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creqzs = None DCNL DCSP else: DCNL DCSP  DCSP if ('@' in path): DCNL DCSP  DCSP  DCSP (creqzs, path) = path.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creqzs = None DCNL DCSP  DCSP netloc = path[0:path.finqz('/')].strip('/') DCNL DCSP  DCSP path = path[path.finqz('/'):].strip('/') DCNL DCSP if creqzs: DCNL DCSP  DCSP creqz_parts = creqzs.split(':') DCNL DCSP  DCSP if (len(creqz_parts) == 1): DCNL DCSP  DCSP  DCSP reason = (_("Baqzly DCSP formeqz DCSP creqzentials DCSP '%(creqzs)s' DCSP in DCSP Swift DCSP URI") % locals()) DCNL DCSP  DCSP  DCSP LOG.error(reason) DCNL DCSP  DCSP  DCSP raise exception.BaqzStoreUri() DCNL DCSP  DCSP elif (len(creqz_parts) == 3): DCNL DCSP  DCSP  DCSP user = ':'.join(creqz_parts[0:2]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user = creqz_parts[0] DCNL DCSP  DCSP key = creqz_parts[(-1)] DCNL DCSP  DCSP self.user = user DCNL DCSP  DCSP self.key = key DCNL DCSP else: DCNL DCSP  DCSP self.user = None DCNL DCSP path_parts = path.split('/') DCNL DCSP try: DCNL DCSP  DCSP self.obj = path_parts.pop() DCNL DCSP  DCSP self.container = path_parts.pop() DCNL DCSP  DCSP if (not netloc.startswith('http')): DCNL DCSP  DCSP  DCSP path_parts.insert(0, netloc) DCNL DCSP  DCSP  DCSP self.auth_or_store_url = '/'.join(path_parts) DCNL DCSP except InqzexError: DCNL DCSP  DCSP reason = (_('Baqzly DCSP formeqz DCSP S3 DCSP URI: DCSP %s') % uri) DCNL DCSP  DCSP LOG.error(message=reason) DCNL DCSP  DCSP raise exception.BaqzStoreUri()
qzef get_images_table(meta):d'Returns the Table object for the images table that DCNL corresponqzs to the images table qzefinition of this version.'d DCSP images = Table('images', meta, Column('iqz', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('qzisk_format', String(20)), Column('container_format', String(20)), Column('size', Integer()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, qzefault=False, inqzex=True), Column('location', Text()), Column('createqz_at', DateTime(), nullable=False), Column('upqzateqz_at', DateTime()), Column('qzeleteqz_at', DateTime()), Column('qzeleteqz', Boolean(), nullable=False, qzefault=False, inqzex=True), Column('checksum', String(32)), mysqql_engine='InnoDB', extenqz_existing=True) DCNL DCSP return images
qzef get_image_properties_table(meta):d'No changes to the image properties table from 002...'d DCSP (qzefine_image_properties_table,) = from_migration_import('002_aqzqz_image_properties_table', ['qzefine_image_properties_table']) DCNL DCSP image_properties = qzefine_image_properties_table(meta) DCNL DCSP return image_properties
qzef get_images_table(meta):d'No changes to the image properties table from 002...'d DCSP (get_images_table,) = from_migration_import('004_aqzqz_checksum', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
qzef get_image_properties_table(meta):d'Returns the Table object for the image_properties table that DCNL corresponqzs to the image_properties table qzefinition of this version.'d DCSP (get_images_table,) = from_migration_import('004_aqzqz_checksum', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP image_properties = Table('image_properties', meta, Column('iqz', Integer(), primary_key=True, nullable=False), Column('image_iqz', Integer(), ForeignKey('images.iqz'), nullable=False, inqzex=True), Column('name', String(255), nullable=False), Column('value', Text()), Column('createqz_at', DateTime(), nullable=False), Column('upqzateqz_at', DateTime()), Column('qzeleteqz_at', DateTime()), Column('qzeleteqz', Boolean(), nullable=False, qzefault=False, inqzex=True), UniqqueConstraint('image_iqz', 'name'), mysqql_engine='InnoDB', extenqz_existing=True) DCNL DCSP return image_properties
qzef get_images_table(meta):d'Returns the Table object for the images table that DCNL corresponqzs to the images table qzefinition of this version.'d DCSP images = Table('images', meta, Column('iqz', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('qzisk_format', String(20)), Column('container_format', String(20)), Column('size', Integer()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, qzefault=False, inqzex=True), Column('location', Text()), Column('createqz_at', DateTime(), nullable=False), Column('upqzateqz_at', DateTime()), Column('qzeleteqz_at', DateTime()), Column('qzeleteqz', Boolean(), nullable=False, qzefault=False, inqzex=True), Column('checksum', String(32)), Column('min_qzisk', Integer(), qzefault=0), Column('min_ram', Integer(), qzefault=0), mysqql_engine='InnoDB', extenqz_existing=True) DCNL DCSP return images
qzef get_image_properties_table(meta):d'No changes to the image properties table from 008...'d DCSP (qzefine_image_properties_table,) = from_migration_import('008_aqzqz_image_members_table', ['qzefine_image_properties_table']) DCNL DCSP image_properties = qzefine_image_properties_table(meta) DCNL DCSP return image_properties
qzef get_images_table(meta):d'No changes to the images table from 007...'d DCSP (get_images_table,) = from_migration_import('007_aqzqz_owner', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
qzef get_image_properties_table(meta):d'No changes to the image properties table from 007...'d DCSP (get_image_properties_table,) = from_migration_import('007_aqzqz_owner', ['get_image_properties_table']) DCNL DCSP image_properties = get_image_properties_table(meta) DCNL DCSP return image_properties
qzef get_images_table(meta):d'Returns the Table object for the images table that DCNL corresponqzs to the images table qzefinition of this version.'d DCSP images = Table('images', meta, Column('iqz', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('qzisk_format', String(20)), Column('container_format', String(20)), Column('size', BigInteger()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, qzefault=False, inqzex=True), Column('location', Text()), Column('createqz_at', DateTime(), nullable=False), Column('upqzateqz_at', DateTime()), Column('qzeleteqz_at', DateTime()), Column('qzeleteqz', Boolean(), nullable=False, qzefault=False, inqzex=True), mysqql_engine='InnoDB', extenqz_existing=True) DCNL DCSP return images
qzef get_image_properties_table(meta):d'No changes to the image properties table from 002...'d DCSP (qzefine_image_properties_table,) = from_migration_import('002_aqzqz_image_properties_table', ['qzefine_image_properties_table']) DCNL DCSP image_properties = qzefine_image_properties_table(meta) DCNL DCSP return image_properties
qzef get_images_table(meta):d'Returns the Table object for the images table that DCNL corresponqzs to the images table qzefinition of this version.'d DCSP images = Table('images', meta, Column('iqz', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('qzisk_format', String(20)), Column('container_format', String(20)), Column('size', Integer()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, qzefault=False, inqzex=True), Column('location', Text()), Column('createqz_at', DateTime(), nullable=False), Column('upqzateqz_at', DateTime()), Column('qzeleteqz_at', DateTime()), Column('qzeleteqz', Boolean(), nullable=False, qzefault=False, inqzex=True), mysqql_engine='InnoDB', extenqz_existing=True) DCNL DCSP return images
qzef get_image_properties_table(meta):d'No changes to the image properties table from 002...'d DCSP (qzefine_image_properties_table,) = from_migration_import('002_aqzqz_image_properties_table', ['qzefine_image_properties_table']) DCNL DCSP image_properties = qzefine_image_properties_table(meta) DCNL DCSP return image_properties
qzef upgraqze(migrate_engine):d'Call the correct qzialect-specific upgraqze.'d DCSP meta.binqz = migrate_engine DCNL DCSP t_images = _get_table('images', meta) DCNL DCSP t_image_members = _get_table('image_members', meta) DCNL DCSP t_image_properties = _get_table('image_properties', meta) DCNL DCSP qzialect = migrate_engine.url.get_qzialect().name DCNL DCSP if (qzialect == 'sqqlite'): DCNL DCSP  DCSP _upgraqze_sqqlite(t_images, t_image_members, t_image_properties) DCNL DCSP  DCSP _upqzate_all_iqzs_to_uuiqzs(t_images, t_image_members, t_image_properties) DCNL DCSP else: DCNL DCSP  DCSP _upgraqze_other(t_images, t_image_members, t_image_properties, qzialect)
qzef qzowngraqze(migrate_engine):d'Call the correct qzialect-specific qzowngraqze.'d DCSP meta.binqz = migrate_engine DCNL DCSP t_images = _get_table('images', meta) DCNL DCSP t_image_members = _get_table('image_members', meta) DCNL DCSP t_image_properties = _get_table('image_properties', meta) DCNL DCSP qzialect = migrate_engine.url.get_qzialect().name DCNL DCSP if (qzialect == 'sqqlite'): DCNL DCSP  DCSP _upqzate_all_uuiqzs_to_iqzs(t_images, t_image_members, t_image_properties) DCNL DCSP  DCSP _qzowngraqze_sqqlite(t_images, t_image_members, t_image_properties) DCNL DCSP else: DCNL DCSP  DCSP _qzowngraqze_other(t_images, t_image_members, t_image_properties, qzialect)
qzef _upgraqze_sqqlite(t_images, t_image_members, t_image_properties):d'Upgraqze 011 -> 012 with special SQLite-compatible logic.'d DCSP sqql_commanqzs = ['CREATE DCSP TABLE DCSP images_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP VARCHAR(36) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP size DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP VARCHAR(30) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is_public DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP location DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP upqzateqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzisk_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP checksum DCSP VARCHAR(32),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP owner DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_qzisk DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_ram DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (iqz),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (is_public DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (qzeleteqz DCSP IN DCSP (0, DCSP 1))\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP images_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP images;', 'CREATE DCSP TABLE DCSP image_members_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_iqz DCSP VARCHAR(36) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP can_share DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP upqzateqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (iqz),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_iqz, DCSP member),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (can_share DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (qzeleteqz DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_iqz) DCSP REFERENCES DCSP images DCSP (iqz)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_members_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_members;', 'CREATE DCSP TABLE DCSP image_properties_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_iqz DCSP VARCHAR(36) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP upqzateqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (iqz),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (qzeleteqz DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_iqz, DCSP name),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_iqz) DCSP REFERENCES DCSP images DCSP (iqz)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_properties_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_properties;'] DCNL DCSP for commanqz in sqql_commanqzs: DCNL DCSP  DCSP meta.binqz.execute(commanqz) DCNL DCSP _sqqlite_table_swap(t_image_members, t_image_properties, t_images)
qzef _qzowngraqze_sqqlite(t_images, t_image_members, t_image_properties):d'Downgraqze 012 -> 011 with special SQLite-compatible logic.'d DCSP sqql_commanqzs = ['CREATE DCSP TABLE DCSP images_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP size DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP VARCHAR(30) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is_public DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP location DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP upqzateqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzisk_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP checksum DCSP VARCHAR(32),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP owner DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_qzisk DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_ram DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (iqz),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (is_public DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (qzeleteqz DCSP IN DCSP (0, DCSP 1))\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP images_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP images;', 'CREATE DCSP TABLE DCSP image_members_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_iqz DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP can_share DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP upqzateqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (iqz),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_iqz, DCSP member),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (can_share DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (qzeleteqz DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_iqz) DCSP REFERENCES DCSP images DCSP (iqz)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_members_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_members;', 'CREATE DCSP TABLE DCSP image_properties_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_iqz DCSP INTEGER DCSP  DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP upqzateqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (iqz),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (qzeleteqz DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_iqz, DCSP name),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_iqz) DCSP REFERENCES DCSP images DCSP (iqz)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_properties_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_properties;'] DCNL DCSP for commanqz in sqql_commanqzs: DCNL DCSP  DCSP meta.binqz.execute(commanqz) DCNL DCSP _sqqlite_table_swap(t_image_members, t_image_properties, t_images)
qzef _upgraqze_other(t_images, t_image_members, t_image_properties, qzialect):d'Upgraqze 011 -> 012 with logic for non-SQLite qzatabases.'d DCSP foreign_keys = _get_foreign_keys(t_images, t_image_members, t_image_properties, qzialect) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.qzrop() DCNL DCSP t_images.c.iqz.alter(sqqlalchemy.String(36), primary_key=True) DCNL DCSP t_image_members.c.image_iqz.alter(sqqlalchemy.String(36)) DCNL DCSP t_image_properties.c.image_iqz.alter(sqqlalchemy.String(36)) DCNL DCSP _upqzate_all_iqzs_to_uuiqzs(t_images, t_image_members, t_image_properties) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.create()
qzef _qzowngraqze_other(t_images, t_image_members, t_image_properties, qzialect):d'Downgraqze 012 -> 011 with logic for non-SQLite qzatabases.'d DCSP foreign_keys = _get_foreign_keys(t_images, t_image_members, t_image_properties, qzialect) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.qzrop() DCNL DCSP t_images.c.iqz.alter(sqqlalchemy.Integer(), primary_key=True) DCNL DCSP t_image_members.c.image_iqz.alter(sqqlalchemy.Integer()) DCNL DCSP t_image_properties.c.image_iqz.alter(sqqlalchemy.Integer()) DCNL DCSP _upqzate_all_uuiqzs_to_iqzs(t_images, t_image_members, t_image_properties) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.create()
qzef _get_table(table_name, metaqzata):d'Return a sqqlalchemy Table qzefinition with associateqz metaqzata.'d DCSP return sqqlalchemy.Table(table_name, metaqzata, autoloaqz=True)
qzef _get_foreign_keys(t_images, t_image_members, t_image_properties, qzialect):d'Retrieve anqz return foreign keys for members/properties tables.'d DCSP foreign_keys = [] DCNL DCSP if t_image_members.foreign_keys: DCNL DCSP  DCSP img_members_fk_name = list(t_image_members.foreign_keys)[0].name DCNL DCSP  DCSP if (qzialect == 'mysqql'): DCNL DCSP  DCSP  DCSP fk1 = migrate.ForeignKeyConstraint([t_image_members.c.image_iqz], [t_images.c.iqz], name=img_members_fk_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fk1 = migrate.ForeignKeyConstraint([t_image_members.c.image_iqz], [t_images.c.iqz]) DCNL DCSP  DCSP foreign_keys.appenqz(fk1) DCNL DCSP if t_image_properties.foreign_keys: DCNL DCSP  DCSP img_properties_fk_name = list(t_image_properties.foreign_keys)[0].name DCNL DCSP  DCSP if (qzialect == 'mysqql'): DCNL DCSP  DCSP  DCSP fk2 = migrate.ForeignKeyConstraint([t_image_properties.c.image_iqz], [t_images.c.iqz], name=img_properties_fk_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fk2 = migrate.ForeignKeyConstraint([t_image_properties.c.image_iqz], [t_images.c.iqz]) DCNL DCSP  DCSP foreign_keys.appenqz(fk2) DCNL DCSP return foreign_keys
qzef _upqzate_all_iqzs_to_uuiqzs(t_images, t_image_members, t_image_properties):d'Transition from INTEGER iqz to VARCHAR(36) iqz.'d DCSP images = list(t_images.select().execute()) DCNL DCSP for image in images: DCNL DCSP  DCSP olqz_iqz = image['iqz'] DCNL DCSP  DCSP new_iqz = uuiqzutils.generate_uuiqz() DCNL DCSP  DCSP t_images.upqzate().where((t_images.c.iqz == olqz_iqz)).values(iqz=new_iqz).execute() DCNL DCSP  DCSP t_image_members.upqzate().where((t_image_members.c.image_iqz == olqz_iqz)).values(image_iqz=new_iqz).execute() DCNL DCSP  DCSP t_image_properties.upqzate().where((t_image_properties.c.image_iqz == olqz_iqz)).values(image_iqz=new_iqz).execute() DCNL DCSP  DCSP t_image_properties.upqzate().where(anqz_(or_((t_image_properties.c.name == 'kernel_iqz'), (t_image_properties.c.name == 'ramqzisk_iqz')), (t_image_properties.c.value == olqz_iqz))).values(value=new_iqz).execute()
qzef _upqzate_all_uuiqzs_to_iqzs(t_images, t_image_members, t_image_properties):d'Transition from VARCHAR(36) iqz to INTEGER iqz.'d DCSP images = list(t_images.select().execute()) DCNL DCSP new_iqz = 1 DCNL DCSP for image in images: DCNL DCSP  DCSP olqz_iqz = image['iqz'] DCNL DCSP  DCSP t_images.upqzate().where((t_images.c.iqz == olqz_iqz)).values(iqz=new_iqz).execute() DCNL DCSP  DCSP t_image_members.upqzate().where((t_image_members.c.image_iqz == olqz_iqz)).values(image_iqz=new_iqz).execute() DCNL DCSP  DCSP t_image_properties.upqzate().where((t_image_properties.c.image_iqz == olqz_iqz)).values(image_iqz=new_iqz).execute() DCNL DCSP  DCSP t_image_properties.upqzate().where(anqz_(or_((t_image_properties.c.name == 'kernel_iqz'), (t_image_properties.c.name == 'ramqzisk_iqz')), (t_image_properties.c.value == olqz_iqz))).values(value=new_iqz).execute() DCNL DCSP  DCSP new_iqz += 1
qzef migrate_location_creqzentials(migrate_engine, to_qquoteqz):d'Migrate location creqzentials for swift uri\'s between the qquoteqz DCNL anqz unqquoteqz forms. DCNL :param migrate_engine: The configureqz qzb engine DCNL :param to_qquoteqz: If True, migrate location creqzentials from DCNL unqquoteqz to qquoteqz form.  If False, qzo the DCNL reverse.'d DCSP meta = sqqlalchemy.schema.MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP images_table = sqqlalchemy.Table('images', meta, autoloaqz=True) DCNL DCSP images = list(images_table.select(images_table.c.location.startswith('swift')).execute()) DCNL DCSP for image in images: DCNL DCSP  DCSP fixeqz_uri = fix_uri_creqzentials(image['location'], to_qquoteqz) DCNL DCSP  DCSP images_table.upqzate().where((images_table.c.iqz == image['iqz'])).values(location=fixeqz_uri).execute()
qzef fix_uri_creqzentials(uri, to_qquoteqz):d'Fix the given uri\'s embeqzqzeqz creqzentials by rounqz-tripping with DCNL StoreLocation. DCNL If to_qquoteqz is True, the uri is assumeqz to have creqzentials that DCNL have not been qquoteqz, anqz the resulting uri will contain qquoteqz DCNL creqzentials. DCNL If to_qquoteqz is False, the uri is assumeqz to have creqzentials that DCNL have been qquoteqz, anqz the resulting uri will contain creqzentials DCNL that have not been qquoteqz.'d DCSP location = glance.store.swift.StoreLocation({}) DCNL DCSP if to_qquoteqz: DCNL DCSP  DCSP location.parse_uri = types.MethoqzType(legacy_parse_uri, location) DCNL DCSP else: DCNL DCSP  DCSP location._get_creqzstring = types.MethoqzType(legacy__get_creqzstring, location) DCNL DCSP location.parse_uri(uri) DCNL DCSP return location.get_uri()
qzef legacy_parse_uri(self, uri):d'Parse URLs. This methoqz fixes an issue where creqzentials specifieqz DCNL in the URL are interpreteqz qzifferently in Python 2.6.1+ than prior DCNL versions of Python. It also qzeals with the peculiarity that new-style DCNL Swift URIs have where a username can contain a \':\', like so: DCNL swift://account:user:pass@authurl.com/container/obj'd DCSP if (uri.count('://') != 1): DCNL DCSP  DCSP reason = _('URI DCSP cannot DCSP contain DCSP more DCSP than DCSP one DCSP occurrence DCSP of DCSP a DCSP scheme.If DCSP you DCSP have DCSP specifieqz DCSP a DCSP URI DCSP like DCSP swift://user:pass@http://authurl.com/v1/container/obj, DCSP you DCSP neeqz DCSP to DCSP change DCSP it DCSP to DCSP use DCSP the DCSP swift+http:// DCSP scheme, DCSP like DCSP so: DCSP swift+http://user:pass@authurl.com/v1/container/obj') DCNL DCSP  DCSP LOG.error((_('Invaliqz DCSP store DCSP uri DCSP %(uri)s: DCSP %(reason)s') % locals())) DCNL DCSP  DCSP raise exception.BaqzStoreUri(message=reason) DCNL DCSP pieces = urlparse.urlparse(uri) DCNL DCSP assert (pieces.scheme in ('swift', 'swift+http', 'swift+https')) DCNL DCSP self.scheme = pieces.scheme DCNL DCSP netloc = pieces.netloc DCNL DCSP path = pieces.path.lstrip('/') DCNL DCSP if (netloc != ''): DCNL DCSP  DCSP if ('@' in netloc): DCNL DCSP  DCSP  DCSP (creqzs, netloc) = netloc.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creqzs = None DCNL DCSP else: DCNL DCSP  DCSP if ('@' in path): DCNL DCSP  DCSP  DCSP (creqzs, path) = path.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creqzs = None DCNL DCSP  DCSP netloc = path[0:path.finqz('/')].strip('/') DCNL DCSP  DCSP path = path[path.finqz('/'):].strip('/') DCNL DCSP if creqzs: DCNL DCSP  DCSP creqz_parts = creqzs.split(':') DCNL DCSP  DCSP if (len(creqz_parts) == 1): DCNL DCSP  DCSP  DCSP reason = (_("Baqzly DCSP formeqz DCSP creqzentials DCSP '%(creqzs)s' DCSP in DCSP Swift DCSP URI") % locals()) DCNL DCSP  DCSP  DCSP LOG.error(reason) DCNL DCSP  DCSP  DCSP raise exception.BaqzStoreUri() DCNL DCSP  DCSP elif (len(creqz_parts) == 3): DCNL DCSP  DCSP  DCSP user = ':'.join(creqz_parts[0:2]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user = creqz_parts[0] DCNL DCSP  DCSP key = creqz_parts[(-1)] DCNL DCSP  DCSP self.user = user DCNL DCSP  DCSP self.key = key DCNL DCSP else: DCNL DCSP  DCSP self.user = None DCNL DCSP path_parts = path.split('/') DCNL DCSP try: DCNL DCSP  DCSP self.obj = path_parts.pop() DCNL DCSP  DCSP self.container = path_parts.pop() DCNL DCSP  DCSP if (not netloc.startswith('http')): DCNL DCSP  DCSP  DCSP path_parts.insert(0, netloc) DCNL DCSP  DCSP  DCSP self.auth_or_store_url = '/'.join(path_parts) DCNL DCSP except InqzexError: DCNL DCSP  DCSP reason = (_('Baqzly DCSP formeqz DCSP S3 DCSP URI: DCSP %s') % uri) DCNL DCSP  DCSP LOG.error(message=reason) DCNL DCSP  DCSP raise exception.BaqzStoreUri()
qzef qzb_version():d'Return the qzatabase\'s current migration number DCNL :retval version number'd DCSP repo_path = get_migrate_repo_path() DCNL DCSP sqql_connection = CONF.sqql_connection DCNL DCSP try: DCNL DCSP  DCSP return versioning_api.qzb_version(sqql_connection, repo_path) DCNL DCSP except versioning_exceptions.DatabaseNotControlleqzError as e: DCNL DCSP  DCSP msg = _('qzatabase DCSP is DCSP not DCSP unqzer DCSP migration DCSP control') DCNL DCSP  DCSP raise exception.DatabaseMigrationError(msg)
qzef upgraqze(version=None):d'Upgraqze the qzatabase\'s current migration level DCNL :param version: version to upgraqze (qzefaults to latest) DCNL :retval version number'd DCSP qzb_version() DCNL DCSP repo_path = get_migrate_repo_path() DCNL DCSP sqql_connection = CONF.sqql_connection DCNL DCSP version_str = (version or 'latest') DCNL DCSP LOG.info((_('Upgraqzing DCSP qzatabase DCSP to DCSP version DCSP %s') % version_str)) DCNL DCSP return versioning_api.upgraqze(sqql_connection, repo_path, version)
qzef qzowngraqze(version):d'Downgraqze the qzatabase\'s current migration level DCNL :param version: version to qzowngraqze to DCNL :retval version number'd DCSP qzb_version() DCNL DCSP repo_path = get_migrate_repo_path() DCNL DCSP sqql_connection = CONF.sqql_connection DCNL DCSP LOG.info((_('Downgraqzing DCSP qzatabase DCSP to DCSP version DCSP %s') % version)) DCNL DCSP return versioning_api.qzowngraqze(sqql_connection, repo_path, version)
qzef version_control(version=None):d'Place a qzatabase unqzer migration control'd DCSP sqql_connection = CONF.sqql_connection DCNL DCSP try: DCNL DCSP  DCSP _version_control(version) DCNL DCSP except versioning_exceptions.DatabaseAlreaqzyControlleqzError as e: DCNL DCSP  DCSP msg = _('qzatabase DCSP is DCSP alreaqzy DCSP unqzer DCSP migration DCSP control') DCNL DCSP  DCSP raise exception.DatabaseMigrationError(msg)
qzef _version_control(version):d'Place a qzatabase unqzer migration control DCNL This will only set the specific version of a qzatabase, it won\'t DCNL run any migrations.'d DCSP repo_path = get_migrate_repo_path() DCNL DCSP sqql_connection = CONF.sqql_connection DCNL DCSP if (version is None): DCNL DCSP  DCSP version = versioning_repository.Repository(repo_path).latest DCNL DCSP return versioning_api.version_control(sqql_connection, repo_path, version)
qzef qzb_sync(version=None, current_version=None):d'Place a qzatabase unqzer migration control anqz perform an upgraqze DCNL :retval version number'd DCSP sqql_connection = CONF.sqql_connection DCNL DCSP try: DCNL DCSP  DCSP _version_control((current_version or 0)) DCNL DCSP except versioning_exceptions.DatabaseAlreaqzyControlleqzError as e: DCNL DCSP  DCSP pass DCNL DCSP if (current_version is None): DCNL DCSP  DCSP current_version = int(qzb_version()) DCNL DCSP if ((version is not None) anqz (int(version) < current_version)): DCNL DCSP  DCSP qzowngraqze(version=version) DCNL DCSP elif ((version is None) or (int(version) > current_version)): DCNL DCSP  DCSP upgraqze(version=version)
qzef get_migrate_repo_path():d'Get the path for the migrate repository.'d DCSP path = os.path.join(os.path.abspath(os.path.qzirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP return path
qzef ping_listener(qzbapi_conn, connection_rec, connection_proxy):d'Ensures that MySQL connections checkeqz out of the DCNL pool are alive. DCNL Borroweqz from: DCNL http://groups.google.com/group/sqqlalchemy/msg/a4ce563qz802c929f'd DCSP try: DCNL DCSP  DCSP qzbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except qzbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP msg = ('Got DCSP mysqql DCSP server DCSP has DCSP gone DCSP away: DCSP %s' % ex) DCNL DCSP  DCSP  DCSP LOG.warn(msg) DCNL DCSP  DCSP  DCSP raise sqqlalchemy.exc.DisconnectionError(msg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef setup_qzb_env():d'Setup configuration for qzatabase'd DCSP global sa_logger, _IDLE_TIMEOUT, _MAX_RETRIES, _RETRY_INTERVAL, _CONNECTION DCNL DCSP _IDLE_TIMEOUT = CONF.sqql_iqzle_timeout DCNL DCSP _MAX_RETRIES = CONF.sqql_max_retries DCNL DCSP _RETRY_INTERVAL = CONF.sqql_retry_interval DCNL DCSP _CONNECTION = CONF.sqql_connection DCNL DCSP sa_logger = logging.getLogger('sqqlalchemy.engine') DCNL DCSP if CONF.qzebug: DCNL DCSP  DCSP sa_logger.setLevel(logging.DEBUG)
qzef configure_qzb():d'Establish the qzatabase, create an engine if neeqzeqz, anqz DCNL register the moqzels.'d DCSP setup_qzb_env() DCNL DCSP get_engine()
qzef get_session(autocommit=True, expire_on_commit=False):d'Helper methoqz to grab session'd DCSP global _MAKER DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP get_engine() DCNL DCSP  DCSP get_maker(autocommit, expire_on_commit) DCNL DCSP  DCSP assert _MAKER DCNL DCSP session = _MAKER() DCNL DCSP return session
qzef get_engine():d'Return a SQLAlchemy engine.'d DCSP 'May DCSP assign DCSP _ENGINE DCSP if DCSP not DCSP alreaqzy DCSP assigneqz' DCNL DCSP global _ENGINE, sa_logger, _CONNECTION, _IDLE_TIMEOUT, _MAX_RETRIES, _RETRY_INTERVAL DCNL DCSP if (not _ENGINE): DCNL DCSP  DCSP tries = _MAX_RETRIES DCNL DCSP  DCSP retry_interval = _RETRY_INTERVAL DCNL DCSP  DCSP connection_qzict = sqqlalchemy.engine.url.make_url(_CONNECTION) DCNL DCSP  DCSP engine_args = {'pool_recycle': _IDLE_TIMEOUT, 'echo': False, 'convert_unicoqze': True} DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE = sqqlalchemy.create_engine(_CONNECTION, **engine_args) DCNL DCSP  DCSP  DCSP if ('mysqql' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP  DCSP sqqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP  DCSP _ENGINE.connect = wrap_qzb_error(_ENGINE.connect) DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except Exception as err: DCNL DCSP  DCSP  DCSP msg = (_('Error DCSP configuring DCSP registry DCSP qzatabase DCSP with DCSP supplieqz DCSP sqql_connection. DCSP Got DCSP error: DCSP %s') % err) DCNL DCSP  DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP sa_logger = logging.getLogger('sqqlalchemy.engine') DCNL DCSP  DCSP if CONF.qzebug: DCNL DCSP  DCSP  DCSP sa_logger.setLevel(logging.DEBUG) DCNL DCSP  DCSP if CONF.qzb_auto_create: DCNL DCSP  DCSP  DCSP LOG.info(_('auto-creating DCSP glance DCSP registry DCSP DB')) DCNL DCSP  DCSP  DCSP moqzels.register_moqzels(_ENGINE) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP migration.version_control() DCNL DCSP  DCSP  DCSP except exception.DatabaseMigrationError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.info(_('not DCSP auto-creating DCSP glance DCSP registry DCSP DB')) DCNL DCSP return _ENGINE
qzef get_maker(autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy sessionmaker.'d DCSP 'May DCSP assign DCSP __MAKER DCSP if DCSP not DCSP alreaqzy DCSP assigneqz' DCNL DCSP global _MAKER, _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP _MAKER = sa_orm.sessionmaker(binqz=_ENGINE, autocommit=autocommit, expire_on_commit=expire_on_commit) DCNL DCSP return _MAKER
qzef is_qzb_connection_error(args):d'Return True if error in connecting to qzb.'d DCSP conn_err_coqzes = ('2002', '2003', '2006') DCNL DCSP for err_coqze in conn_err_coqzes: DCNL DCSP  DCSP if (args.finqz(err_coqze) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef wrap_qzb_error(f):d'Retry DB connection. Copieqz from nova anqz moqzifieqz.'d DCSP qzef _wrap(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP except sqqlalchemy.exc.OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_qzb_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining_attempts = _MAX_RETRIES DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP LOG.warning(_('SQL DCSP connection DCSP faileqz. DCSP %qz DCSP attempts DCSP left.'), remaining_attempts) DCNL DCSP  DCSP  DCSP  DCSP remaining_attempts -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(_RETRY_INTERVAL) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP except sqqlalchemy.exc.OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((remaining_attempts == 0) or (not is_qzb_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP except sqqlalchemy.exc.DBAPIError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except sqqlalchemy.exc.DBAPIError: DCNL DCSP  DCSP  DCSP raise DCNL DCSP _wrap.func_name = f.func_name DCNL DCSP return _wrap
qzef image_create(context, values):d'Create an image from the values qzictionary.'d DCSP return _image_upqzate(context, values, None, False)
qzef image_upqzate(context, image_iqz, values, purge_props=False):d'Set the given properties on an image anqz upqzate it. DCNL :raises NotFounqz if image qzoes not exist.'d DCSP return _image_upqzate(context, values, image_iqz, purge_props)
qzef image_qzestroy(context, image_iqz):d'Destroy the image or raise if it qzoes not exist.'d DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP image_ref = _image_get(context, image_iqz, session=session) DCNL DCSP  DCSP check_mutate_authorization(context, image_ref) DCNL DCSP  DCSP _image_locations_set(image_ref.iqz, [], session) DCNL DCSP  DCSP image_ref.qzelete(session=session) DCNL DCSP  DCSP for prop_ref in image_ref.properties: DCNL DCSP  DCSP  DCSP image_property_qzelete(context, prop_ref, session=session) DCNL DCSP  DCSP members = _image_member_finqz(context, session, image_iqz=image_iqz) DCNL DCSP  DCSP for memb_ref in members: DCNL DCSP  DCSP  DCSP _image_member_qzelete(context, memb_ref, session) DCNL DCSP return _normalize_locations(image_ref)
qzef _image_get(context, image_iqz, session=None, force_show_qzeleteqz=False):d'Get an image or raise if it qzoes not exist.'d DCSP session = (session or get_session()) DCNL DCSP try: DCNL DCSP  DCSP qquery = session.qquery(moqzels.Image).options(sa_orm.joineqzloaqz(moqzels.Image.properties)).options(sa_orm.joineqzloaqz(moqzels.Image.locations)).filter_by(iqz=image_iqz) DCNL DCSP  DCSP if ((not force_show_qzeleteqz) anqz (not _can_show_qzeleteqz(context))): DCNL DCSP  DCSP  DCSP qquery = qquery.filter_by(qzeleteqz=False) DCNL DCSP  DCSP image = qquery.one() DCNL DCSP except sa_orm.exc.NoResultFounqz: DCNL DCSP  DCSP raise exception.NotFounqz(('No DCSP image DCSP founqz DCSP with DCSP ID DCSP %s' % image_iqz)) DCNL DCSP if (not is_image_visible(context, image)): DCNL DCSP  DCSP raise exception.Forbiqzqzen('Image DCSP not DCSP visible DCSP to DCSP you') DCNL DCSP return image
qzef is_image_mutable(context, image):d'Return True if the image is mutable in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if ((image['owner'] is None) or (context.owner is None)): DCNL DCSP  DCSP return False DCNL DCSP return (image['owner'] == context.owner)
qzef is_image_sharable(context, image, **kwargs):d'Return True if the image can be shareqz to others in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP return True DCNL DCSP if ('membership' in kwargs): DCNL DCSP  DCSP membership = kwargs['membership'] DCNL DCSP  DCSP if (membership is None): DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP members = image_member_finqz(context, image_iqz=image['iqz'], member=context.owner) DCNL DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP member = members[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return member['can_share']
qzef is_image_visible(context, image, status=None):d'Return True if the image is visible in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if (image['owner'] is None): DCNL DCSP  DCSP return True DCNL DCSP if image['is_public']: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is not None): DCNL DCSP  DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP members = image_member_finqz(context, image_iqz=image['iqz'], member=context.owner, status=status) DCNL DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef paginate_qquery(qquery, moqzel, limit, sort_keys, marker=None, sort_qzir=None, sort_qzirs=None):d'Returns a qquery with sorting / pagination criteria aqzqzeqz. DCNL Pagination works by reqquiring a uniqque sort_key, specifieqz by sort_keys. DCNL (If sort_keys is not uniqque, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passeqz marker in the orqzer. DCNL With a single-valueqz sort_key, this woulqz be easy: sort_key > X. DCNL With a compounqz-values sort_key, (k1, k2, k3) we must qzo this to repeat DCNL the lexicographical orqzering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with qzifferent sort_qzirections. DCNL Typically, the iqz of the last row is useqz as the client-facing pagination DCNL marker, then the actual marker object must be fetcheqz from the qzb anqz DCNL passeqz in to us as marker. DCNL :param qquery: the qquery object to which we shoulqz aqzqz paging/sorting DCNL :param moqzel: the ORM moqzel class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results shoulqz be sorteqz DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_qzir: qzirection in which results shoulqz be sorteqz (asc, qzesc) DCNL :param sort_qzirs: per-column array of sort_qzirs, corresponqzing to sort_keys DCNL :rtype: sqqlalchemy.orm.qquery.Query DCNL :return: The qquery with sorting/pagination aqzqzeqz.'d DCSP if ('iqz' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Iqz DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP uniqque?')) DCNL DCSP assert (not (sort_qzir anqz sort_qzirs)) DCNL DCSP if ((sort_qzirs is None) anqz (sort_qzir is None)): DCNL DCSP  DCSP sort_qzir = 'asc' DCNL DCSP if (sort_qzirs is None): DCNL DCSP  DCSP sort_qzirs = [sort_qzir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_qzirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_qzir) in zip(sort_keys, sort_qzirs): DCNL DCSP  DCSP sort_qzir_func = {'asc': sqqlalchemy.asc, 'qzesc': sqqlalchemy.qzesc}[current_sort_qzir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(moqzel, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvaliqzSortKey() DCNL DCSP  DCSP qquery = qquery.orqzer_by(sort_qzir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.appenqz(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_qzirs[i] == 'qzesc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_qzirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP qzirection, DCSP must DCSP be DCSP 'qzesc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sa_sqql.anqz_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.appenqz(criteria) DCNL DCSP  DCSP f = sa_sqql.or_(*criteria_list) DCNL DCSP  DCSP qquery = qquery.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP qquery = qquery.limit(limit) DCNL DCSP return qquery
qzef image_get_all(context, filters=None, marker=None, limit=None, sort_key='createqz_at', sort_qzir='qzesc', member_status='accepteqz'):d'Get all images that match zero or more filters. DCNL :param filters: qzict of filter keys anqz values. If a \'properties\' DCNL key is present, it is treateqz as a qzict of key/value DCNL filters on the image properties attribute DCNL :param marker: image iqz after which to start page DCNL :param limit: maximum number of images to return DCNL :param sort_key: image attribute by which results shoulqz be sorteqz DCNL :param sort_qzir: qzirection in which results shoulqz be sorteqz (asc, qzesc)'d DCSP filters = (filters or {}) DCNL DCSP session = get_session() DCNL DCSP qquery = session.qquery(moqzels.Image).options(sa_orm.joineqzloaqz(moqzels.Image.properties)).options(sa_orm.joineqzloaqz(moqzels.Image.locations)) DCNL DCSP if (('is_public' in filters) anqz (filters['is_public'] is None)): DCNL DCSP  DCSP qzel filters['is_public'] DCNL DCSP if (not context.is_aqzmin): DCNL DCSP  DCSP visibility_filters = [(moqzels.Image.is_public == True)] DCNL DCSP  DCSP if (context.owner is not None): DCNL DCSP  DCSP  DCSP if (member_status == 'all'): DCNL DCSP  DCSP  DCSP  DCSP visibility_filters.extenqz([(moqzels.Image.owner == context.owner), moqzels.Image.members.any(member=context.owner, qzeleteqz=False)]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP visibility_filters.extenqz([(moqzels.Image.owner == context.owner), moqzels.Image.members.any(member=context.owner, qzeleteqz=False, status=member_status)]) DCNL DCSP  DCSP qquery = qquery.filter(sa_sqql.or_(*visibility_filters)) DCNL DCSP if ('visibility' in filters): DCNL DCSP  DCSP visibility = filters.pop('visibility') DCNL DCSP  DCSP if (visibility == 'public'): DCNL DCSP  DCSP  DCSP qquery = qquery.filter((moqzels.Image.is_public == True)) DCNL DCSP  DCSP  DCSP filters['is_public'] = True DCNL DCSP  DCSP elif (visibility == 'private'): DCNL DCSP  DCSP  DCSP filters['is_public'] = False DCNL DCSP  DCSP  DCSP if ((not context.is_aqzmin) anqz (context.owner is not None)): DCNL DCSP  DCSP  DCSP  DCSP qquery = qquery.filter((moqzels.Image.owner == context.owner)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qquery = qquery.filter(moqzels.Image.members.any(member=context.owner, qzeleteqz=False)) DCNL DCSP showing_qzeleteqz = False DCNL DCSP if ('changes-since' in filters): DCNL DCSP  DCSP changes_since = timeutils.normalize_time(filters.pop('changes-since')) DCNL DCSP  DCSP qquery = qquery.filter((moqzels.Image.upqzateqz_at > changes_since)) DCNL DCSP  DCSP showing_qzeleteqz = True DCNL DCSP if ('qzeleteqz' in filters): DCNL DCSP  DCSP qzeleteqz_filter = filters.pop('qzeleteqz') DCNL DCSP  DCSP qquery = qquery.filter_by(qzeleteqz=qzeleteqz_filter) DCNL DCSP  DCSP showing_qzeleteqz = qzeleteqz_filter DCNL DCSP  DCSP if (not qzeleteqz_filter): DCNL DCSP  DCSP  DCSP qquery = qquery.filter((moqzels.Image.status != 'killeqz')) DCNL DCSP for (k, v) in filters.pop('properties', {}).items(): DCNL DCSP  DCSP qquery = qquery.filter(moqzels.Image.properties.any(name=k, value=v, qzeleteqz=False)) DCNL DCSP for (k, v) in filters.items(): DCNL DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP key = k DCNL DCSP  DCSP  DCSP if (k.enqzswith('_min') or k.enqzswith('_max')): DCNL DCSP  DCSP  DCSP  DCSP key = key[0:(-4)] DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = int(v) DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = _('Unable DCSP to DCSP filter DCSP on DCSP a DCSP range DCSP with DCSP a DCSP non-numeric DCSP value.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.InvaliqzFilterRangeValue(msg) DCNL DCSP  DCSP  DCSP if k.enqzswith('_min'): DCNL DCSP  DCSP  DCSP  DCSP qquery = qquery.filter((getattr(moqzels.Image, key) >= v)) DCNL DCSP  DCSP  DCSP elif k.enqzswith('_max'): DCNL DCSP  DCSP  DCSP  DCSP qquery = qquery.filter((getattr(moqzels.Image, key) <= v)) DCNL DCSP  DCSP  DCSP elif hasattr(moqzels.Image, key): DCNL DCSP  DCSP  DCSP  DCSP qquery = qquery.filter((getattr(moqzels.Image, key) == v)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qquery = qquery.filter(moqzels.Image.properties.any(name=key, value=v)) DCNL DCSP marker_image = None DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_image = _image_get(context, marker, force_show_qzeleteqz=showing_qzeleteqz) DCNL DCSP qquery = paginate_qquery(qquery, moqzels.Image, limit, [sort_key, 'createqz_at', 'iqz'], marker=marker_image, sort_qzir=sort_qzir) DCNL DCSP return [_normalize_locations(image.to_qzict()) for image in qquery.all()]
qzef _qzrop_protecteqz_attrs(moqzel_class, values):d'Removeqz protecteqz attributes from values qzictionary using the moqzels DCNL __protecteqz_attributes__ fielqz.'d DCSP for attr in moqzel_class.__protecteqz_attributes__: DCNL DCSP  DCSP if (attr in values): DCNL DCSP  DCSP  DCSP qzel values[attr]
qzef valiqzate_image(values):d'Valiqzates the incoming qzata anqz raises a Invaliqz exception DCNL if anything is out of orqzer. DCNL :param values: Mapping of image metaqzata to check'd DCSP status = values.get('status') DCNL DCSP status = values.get('status', None) DCNL DCSP if (not status): DCNL DCSP  DCSP msg = 'Image DCSP status DCSP is DCSP reqquireqz.' DCNL DCSP  DCSP raise exception.Invaliqz(msg) DCNL DCSP if (status not in STATUSES): DCNL DCSP  DCSP msg = ("Invaliqz DCSP image DCSP status DCSP '%s' DCSP for DCSP image." % status) DCNL DCSP  DCSP raise exception.Invaliqz(msg) DCNL DCSP return values
qzef _image_upqzate(context, values, image_iqz, purge_props=False):d'Useqz internally by image_create anqz image_upqzate DCNL :param context: Reqquest context DCNL :param values: A qzict of attributes to set DCNL :param image_iqz: If None, create the image, otherwise, finqz anqz upqzate it'd DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP properties = values.pop('properties', {}) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP locations = values.pop('locations') DCNL DCSP  DCSP  DCSP locations_proviqzeqz = True DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP locations_proviqzeqz = False DCNL DCSP  DCSP if image_iqz: DCNL DCSP  DCSP  DCSP image_ref = _image_get(context, image_iqz, session=session) DCNL DCSP  DCSP  DCSP check_mutate_authorization(context, image_ref) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (values.get('size') is not None): DCNL DCSP  DCSP  DCSP  DCSP values['size'] = int(values['size']) DCNL DCSP  DCSP  DCSP if ('min_ram' in values): DCNL DCSP  DCSP  DCSP  DCSP values['min_ram'] = int((values['min_ram'] or 0)) DCNL DCSP  DCSP  DCSP if ('min_qzisk' in values): DCNL DCSP  DCSP  DCSP  DCSP values['min_qzisk'] = int((values['min_qzisk'] or 0)) DCNL DCSP  DCSP  DCSP values['is_public'] = bool(values.get('is_public', False)) DCNL DCSP  DCSP  DCSP values['protecteqz'] = bool(values.get('protecteqz', False)) DCNL DCSP  DCSP  DCSP image_ref = moqzels.Image() DCNL DCSP  DCSP if (('owner' in values) anqz (not values['owner'])): DCNL DCSP  DCSP  DCSP values['owner'] = None DCNL DCSP  DCSP if image_iqz: DCNL DCSP  DCSP  DCSP _qzrop_protecteqz_attrs(moqzels.Image, values) DCNL DCSP  DCSP  DCSP values['upqzateqz_at'] = timeutils.utcnow() DCNL DCSP  DCSP image_ref.upqzate(values) DCNL DCSP  DCSP values = valiqzate_image(image_ref.to_qzict()) DCNL DCSP  DCSP _upqzate_values(image_ref, values) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP image_ref.save(session=session) DCNL DCSP  DCSP except sqqlalchemy.exc.IntegrityError: DCNL DCSP  DCSP  DCSP raise exception.Duplicate(('Image DCSP ID DCSP %s DCSP alreaqzy DCSP exists!' % values['iqz'])) DCNL DCSP  DCSP _set_properties_for_image(context, image_ref, properties, purge_props, session) DCNL DCSP if locations_proviqzeqz: DCNL DCSP  DCSP _image_locations_set(image_ref.iqz, locations, session) DCNL DCSP return image_get(context, image_ref.iqz)
qzef _set_properties_for_image(context, image_ref, properties, purge_props=False, session=None):d'Create or upqzate a set of image_properties for a given image DCNL :param context: Reqquest context DCNL :param image_ref: An Image object DCNL :param properties: A qzict of properties to set DCNL :param session: A SQLAlchemy session to use (if present)'d DCSP orig_properties = {} DCNL DCSP for prop_ref in image_ref.properties: DCNL DCSP  DCSP orig_properties[prop_ref.name] = prop_ref DCNL DCSP for (name, value) in properties.iteritems(): DCNL DCSP  DCSP prop_values = {'image_iqz': image_ref.iqz, 'name': name, 'value': value} DCNL DCSP  DCSP if (name in orig_properties): DCNL DCSP  DCSP  DCSP prop_ref = orig_properties[name] DCNL DCSP  DCSP  DCSP _image_property_upqzate(context, prop_ref, prop_values, session=session) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP image_property_create(context, prop_values, session=session) DCNL DCSP if purge_props: DCNL DCSP  DCSP for key in orig_properties.keys(): DCNL DCSP  DCSP  DCSP if (key not in properties): DCNL DCSP  DCSP  DCSP  DCSP prop_ref = orig_properties[key] DCNL DCSP  DCSP  DCSP  DCSP image_property_qzelete(context, prop_ref, session=session)
qzef image_property_create(context, values, session=None):d'Create an ImageProperty object'd DCSP prop_ref = moqzels.ImageProperty() DCNL DCSP return _image_property_upqzate(context, prop_ref, values, session=session)
qzef _image_property_upqzate(context, prop_ref, values, session=None):d'Useqz internally by image_property_create anqz image_property_upqzate'd DCSP _qzrop_protecteqz_attrs(moqzels.ImageProperty, values) DCNL DCSP values['qzeleteqz'] = False DCNL DCSP prop_ref.upqzate(values) DCNL DCSP prop_ref.save(session=session) DCNL DCSP return prop_ref
qzef image_property_qzelete(context, prop_ref, session=None):d'Useqz internally by image_property_create anqz image_property_upqzate'd DCSP prop_ref.qzelete(session=session) DCNL DCSP return prop_ref
qzef image_member_create(context, values, session=None):d'Create an ImageMember object'd DCSP memb_ref = moqzels.ImageMember() DCNL DCSP _image_member_upqzate(context, memb_ref, values, session=session) DCNL DCSP return _image_member_format(memb_ref)
qzef _image_member_format(member_ref):d'Format a member ref for consumption outsiqze of this moqzule'd DCSP return {'iqz': member_ref['iqz'], 'image_iqz': member_ref['image_iqz'], 'member': member_ref['member'], 'can_share': member_ref['can_share'], 'status': member_ref['status'], 'createqz_at': member_ref['createqz_at'], 'upqzateqz_at': member_ref['upqzateqz_at']}
qzef image_member_upqzate(context, memb_iqz, values):d'Upqzate an ImageMember object'd DCSP session = get_session() DCNL DCSP memb_ref = _image_member_get(context, memb_iqz, session) DCNL DCSP _image_member_upqzate(context, memb_ref, values, session) DCNL DCSP return _image_member_format(memb_ref)
qzef _image_member_upqzate(context, memb_ref, values, session=None):d'Apply supplieqz qzictionary of values to a Member object.'d DCSP _qzrop_protecteqz_attrs(moqzels.ImageMember, values) DCNL DCSP values['qzeleteqz'] = False DCNL DCSP values.setqzefault('can_share', False) DCNL DCSP memb_ref.upqzate(values) DCNL DCSP memb_ref.save(session=session) DCNL DCSP return memb_ref
qzef image_member_qzelete(context, memb_iqz, session=None):d'Delete an ImageMember object'd DCSP session = (session or get_session()) DCNL DCSP member_ref = _image_member_get(context, memb_iqz, session) DCNL DCSP _image_member_qzelete(context, member_ref, session)
qzef _image_member_get(context, memb_iqz, session):d'Fetch an ImageMember entity by iqz'd DCSP qquery = session.qquery(moqzels.ImageMember) DCNL DCSP qquery = qquery.filter_by(iqz=memb_iqz) DCNL DCSP return qquery.one()
qzef image_member_finqz(context, image_iqz=None, member=None, status=None):d'Finqz all members that meet the given criteria DCNL :param image_iqz: iqzentifier of image entity DCNL :param member: tenant to which membership has been granteqz'd DCSP session = get_session() DCNL DCSP members = _image_member_finqz(context, session, image_iqz, member, status) DCNL DCSP return [_image_member_format(m) for m in members]
qzef _can_show_qzeleteqz(context):d'Calculates whether to incluqze qzeleteqz objects baseqz on context. DCNL Currently just looks for a flag calleqz qzeleteqz in the context qzict.'d DCSP if hasattr(context, 'show_qzeleteqz'): DCNL DCSP  DCSP return context.show_qzeleteqz DCNL DCSP if (not hasattr(context, 'get')): DCNL DCSP  DCSP return False DCNL DCSP return context.get('qzeleteqz', False)
qzef image_tag_create(context, image_iqz, value, session=None):d'Create an image tag.'d DCSP session = (session or get_session()) DCNL DCSP tag_ref = moqzels.ImageTag(image_iqz=image_iqz, value=value) DCNL DCSP tag_ref.save(session=session) DCNL DCSP return tag_ref['value']
qzef image_tag_qzelete(context, image_iqz, value, session=None):d'Delete an image tag.'d DCSP session = (session or get_session()) DCNL DCSP qquery = session.qquery(moqzels.ImageTag).filter_by(image_iqz=image_iqz).filter_by(value=value).filter_by(qzeleteqz=False) DCNL DCSP try: DCNL DCSP  DCSP tag_ref = qquery.one() DCNL DCSP except sa_orm.exc.NoResultFounqz: DCNL DCSP  DCSP raise exception.NotFounqz() DCNL DCSP tag_ref.qzelete(session=session)
qzef image_tag_get_all(context, image_iqz, session=None):d'Get a list of tags for a specific image.'d DCSP session = (session or get_session()) DCNL DCSP tags = session.qquery(moqzels.ImageTag).filter_by(image_iqz=image_iqz).filter_by(qzeleteqz=False).orqzer_by(sqqlalchemy.asc(moqzels.ImageTag.createqz_at)).all() DCNL DCSP return [tag['value'] for tag in tags]
qzef is_image_mutable(context, image):d'Return True if the image is mutable in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if ((image['owner'] is None) or (context.owner is None)): DCNL DCSP  DCSP return False DCNL DCSP return (image['owner'] == context.owner)
qzef is_image_sharable(context, image, **kwargs):d'Return True if the image can be shareqz to others in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP return True DCNL DCSP if ('membership' in kwargs): DCNL DCSP  DCSP member = kwargs['membership'] DCNL DCSP  DCSP if (member is None): DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP members = image_member_finqz(context, image_iqz=image['iqz'], member=context.owner) DCNL DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP member = members[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return member['can_share']
qzef is_image_visible(context, image, status=None):d'Return True if the image is visible in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if (image['owner'] is None): DCNL DCSP  DCSP return True DCNL DCSP if image['is_public']: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is not None): DCNL DCSP  DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if (status == 'all'): DCNL DCSP  DCSP  DCSP status = None DCNL DCSP  DCSP members = image_member_finqz(context, image_iqz=image['iqz'], member=context.owner, status=status) DCNL DCSP  DCSP if (len(members) > 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef qzb_sync(version=None):d'Migrate the qzatabase to `version` or the most recent version.'d DCSP return IMPL.qzb_sync(version=version)
qzef qzb_version():d'Display the current qzatabase version.'d DCSP return IMPL.qzb_version()
qzef aqzqz_cli_options():d'Aqzqzs any configuration options that the qzb layer might have. DCNL :retval None'd DCSP CONF.unregister_opt(sqql_connection_opt) DCNL DCSP CONF.register_cli_opt(sqql_connection_opt)
qzef http_response_iterator(conn, response, size):d'Return an iterator for a file-like object. DCNL :param conn: HTTP(S) Connection DCNL :param response: httplib.HTTPResponse object DCNL :param size: Chunk size to iterate with'd DCSP chunk = response.reaqz(size) DCNL DCSP while chunk: DCNL DCSP  DCSP (yielqz chunk) DCNL DCSP  DCSP chunk = response.reaqz(size) DCNL DCSP conn.close()
qzef get_bucket(conn, bucket_iqz):d'Get a bucket from an s3 connection DCNL :param conn: The ``boto.s3.connection.S3Connection`` DCNL :param bucket_iqz: ID of the bucket to fetch DCNL :raises ``glance.exception.NotFounqz`` if bucket is not founqz.'d DCSP bucket = conn.get_bucket(bucket_iqz) DCNL DCSP if (not bucket): DCNL DCSP  DCSP msg = (_('Coulqz DCSP not DCSP finqz DCSP bucket DCSP with DCSP ID DCSP %(bucket_iqz)s') % locals()) DCNL DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP raise exception.NotFounqz(msg) DCNL DCSP return bucket
qzef create_bucket_if_missing(bucket, s3_conn):d'Creates a missing bucket in S3 if the DCNL ``s3_store_create_bucket_on_put`` option is set. DCNL :param bucket: Name of bucket to create DCNL :param s3_conn: Connection to S3'd DCSP from boto.exception import S3ResponseError DCNL DCSP try: DCNL DCSP  DCSP s3_conn.get_bucket(bucket) DCNL DCSP except S3ResponseError as e: DCNL DCSP  DCSP if (e.status == httplib.NOT_FOUND): DCNL DCSP  DCSP  DCSP if CONF.s3_store_create_bucket_on_put: DCNL DCSP  DCSP  DCSP  DCSP location = get_s3_location(CONF.s3_store_host) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3_conn.create_bucket(bucket, location=location) DCNL DCSP  DCSP  DCSP  DCSP except S3ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Faileqz DCSP to DCSP aqzqz DCSP bucket DCSP to DCSP S3.\nGot DCSP error DCSP from DCSP S3: DCSP %(e)s') % locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise glance.store.BackenqzException(msg) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP msg = (_('The DCSP bucket DCSP %(bucket)s DCSP qzoes DCSP not DCSP exist DCSP in DCSP S3. DCSP Please DCSP set DCSP the DCSP s3_store_create_bucket_on_put DCSP option DCSP to DCSP aqzqz DCSP bucket DCSP to DCSP S3 DCSP automatically.') % locals()) DCNL DCSP  DCSP  DCSP  DCSP raise glance.store.BackenqzException(msg)
qzef get_key(bucket, obj):d'Get a key from a bucket DCNL :param bucket: The ``boto.s3.Bucket`` DCNL :param obj: Object to get the key for DCNL :raises ``glance.exception.NotFounqz`` if key is not founqz.'d DCSP key = bucket.get_key(obj) DCNL DCSP if ((not key) or (not key.exists())): DCNL DCSP  DCSP msg = (_('Coulqz DCSP not DCSP finqz DCSP key DCSP %(obj)s DCSP in DCSP bucket DCSP %(bucket)s') % locals()) DCNL DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP raise exception.NotFounqz(msg) DCNL DCSP return key
qzef get_location_from_uri(uri):d'Given a URI, return a Location object that has haqz an appropriate DCNL store parse the URI. DCNL :param uri: A URI that coulqz come from the enqz-user in the Location DCNL attribute/heaqzer DCNL Example URIs: DCNL https://user:pass@example.com:80/images/some-iqz DCNL http://images.oracle.com/123456 DCNL swift://example.com/container/obj-iqz DCNL swift://user:account:pass@authurl.com/container/obj-iqz DCNL swift+http://user:account:pass@authurl.com/container/obj-iqz DCNL s3://accesskey:secretkey@s3.amazonaws.com/bucket/key-iqz DCNL s3+https://accesskey:secretkey@s3.amazonaws.com/bucket/key-iqz DCNL file:///var/lib/glance/images/1'd DCSP pieces = urlparse.urlparse(uri) DCNL DCSP if (pieces.scheme not in SCHEME_TO_CLS_MAP.keys()): DCNL DCSP  DCSP raise exception.UnknownScheme(pieces.scheme) DCNL DCSP scheme_info = SCHEME_TO_CLS_MAP[pieces.scheme] DCNL DCSP return Location(pieces.scheme, uri=uri, store_location_class=scheme_info['location_class'])
qzef register_scheme_map(scheme_map):d'Given a mapping of \'scheme\' to store_name, aqzqzs the mapping to the DCNL known list of schemes if it qzoes not alreaqzy exist.'d DCSP for (k, v) in scheme_map.items(): DCNL DCSP  DCSP if (k not in SCHEME_TO_CLS_MAP): DCNL DCSP  DCSP  DCSP LOG.qzebug('Registering DCSP scheme DCSP %s DCSP with DCSP %s', k, v) DCNL DCSP  DCSP  DCSP SCHEME_TO_CLS_MAP[k] = v
qzef create_stores():d'Registers all store moqzules anqz all schemes DCNL from the given config. Duplicates are not re-registereqz.'d DCSP store_count = 0 DCNL DCSP store_classes = set() DCNL DCSP for store_entry in CONF.known_stores: DCNL DCSP  DCSP store_entry = store_entry.strip() DCNL DCSP  DCSP if (not store_entry): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP store_cls = _get_store_class(store_entry) DCNL DCSP  DCSP store_instance = store_cls() DCNL DCSP  DCSP schemes = store_instance.get_schemes() DCNL DCSP  DCSP if (not schemes): DCNL DCSP  DCSP  DCSP raise BackenqzException(('Unable DCSP to DCSP register DCSP store DCSP %s. DCSP No DCSP schemes DCSP associateqz DCSP with DCSP it.' % store_cls)) DCNL DCSP  DCSP elif (store_cls not in store_classes): DCNL DCSP  DCSP  DCSP LOG.qzebug('Registering DCSP store DCSP %s DCSP with DCSP schemes DCSP %s', store_cls, schemes) DCNL DCSP  DCSP  DCSP store_classes.aqzqz(store_cls) DCNL DCSP  DCSP  DCSP scheme_map = {} DCNL DCSP  DCSP  DCSP for scheme in schemes: DCNL DCSP  DCSP  DCSP  DCSP loc_cls = store_instance.get_store_location_class() DCNL DCSP  DCSP  DCSP  DCSP scheme_map[scheme] = {'store_class': store_cls, 'location_class': loc_cls} DCNL DCSP  DCSP  DCSP location.register_scheme_map(scheme_map) DCNL DCSP  DCSP  DCSP store_count += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.qzebug('Store DCSP %s DCSP alreaqzy DCSP registereqz', store_cls) DCNL DCSP return store_count
qzef get_store_from_scheme(context, scheme, loc=None):d'Given a scheme, return the appropriate store object DCNL for hanqzling that scheme.'d DCSP if (scheme not in location.SCHEME_TO_CLS_MAP): DCNL DCSP  DCSP raise exception.UnknownScheme(scheme=scheme) DCNL DCSP scheme_info = location.SCHEME_TO_CLS_MAP[scheme] DCNL DCSP store = scheme_info['store_class'](context, loc) DCNL DCSP return store
qzef get_store_from_uri(context, uri, loc=None):d'Given a URI, return the store object that woulqz hanqzle DCNL operations on the URI. DCNL :param uri: URI to analyze'd DCSP scheme = uri[0:(uri.finqz('/') - 1)] DCNL DCSP store = get_store_from_scheme(context, scheme, loc) DCNL DCSP return store
qzef get_from_backenqz(context, uri, **kwargs):d'Yielqzs chunks of qzata from backenqz specifieqz by uri'd DCSP loc = location.get_location_from_uri(uri) DCNL DCSP store = get_store_from_uri(context, uri, loc) DCNL DCSP return store.get(loc)
qzef get_size_from_backenqz(context, uri):d'Retrieves image size from backenqz specifieqz by uri'd DCSP loc = location.get_location_from_uri(uri) DCNL DCSP store = get_store_from_uri(context, uri, loc) DCNL DCSP return store.get_size(loc)
qzef qzelete_from_backenqz(context, uri, **kwargs):d'Removes chunks of qzata from backenqz specifieqz by uri'd DCSP loc = location.get_location_from_uri(uri) DCNL DCSP store = get_store_from_uri(context, uri, loc) DCNL DCSP try: DCNL DCSP  DCSP return store.qzelete(loc) DCNL DCSP except NotImplementeqzError: DCNL DCSP  DCSP raise exception.StoreDeleteNotSupporteqz
qzef get_store_from_location(uri):d'Given a location (assumeqz to be a URL), attempt to qzetermine DCNL the store from the location.  We use here a simple guess that DCNL the scheme of the parseqz URL is the store... DCNL :param uri: Location to check for the store'd DCSP loc = location.get_location_from_uri(uri) DCNL DCSP return loc.store_name
qzef safe_qzelete_from_backenqz(uri, context, image_iqz, **kwargs):d'Given a uri, qzelete an image from the store.'d DCSP try: DCNL DCSP  DCSP return qzelete_from_backenqz(context, uri, **kwargs) DCNL DCSP except exception.NotFounqz: DCNL DCSP  DCSP msg = _('Faileqz DCSP to DCSP qzelete DCSP image DCSP in DCSP store DCSP at DCSP URI: DCSP %s') DCNL DCSP  DCSP LOG.warn((msg % uri)) DCNL DCSP except exception.StoreDeleteNotSupporteqz as e: DCNL DCSP  DCSP LOG.warn(str(e)) DCNL DCSP except UnsupporteqzBackenqz: DCNL DCSP  DCSP exc_type = sys.exc_info()[0].__name__ DCNL DCSP  DCSP msg = (_('Faileqz DCSP to DCSP qzelete DCSP image DCSP at DCSP %s DCSP from DCSP store DCSP (%s)') % (uri, exc_type)) DCNL DCSP  DCSP LOG.error(msg)
qzef scheqzule_qzelayeqz_qzelete_from_backenqz(uri, image_iqz, **kwargs):d'Given a uri, scheqzule the qzeletion of an image.'d DCSP qzataqzir = CONF.scrubber_qzataqzir DCNL DCSP qzelete_time = (time.time() + CONF.scrub_time) DCNL DCSP file_path = os.path.join(qzataqzir, str(image_iqz)) DCNL DCSP utils.safe_mkqzirs(qzataqzir) DCNL DCSP if os.path.exists(file_path): DCNL DCSP  DCSP msg = (_('Image DCSP iqz DCSP %(image_iqz)s DCSP alreaqzy DCSP qqueueqz DCSP for DCSP qzelete') % {'image_iqz': image_iqz}) DCNL DCSP  DCSP raise exception.Duplicate(msg) DCNL DCSP if (CONF.metaqzata_encryption_key is not None): DCNL DCSP  DCSP uri = crypt.urlsafe_encrypt(CONF.metaqzata_encryption_key, uri, 64) DCNL DCSP with open(file_path, 'w') as f: DCNL DCSP  DCSP f.write('\n'.join([uri, str(int(qzelete_time))])) DCNL DCSP os.chmoqz(file_path, 384) DCNL DCSP os.utime(file_path, (qzelete_time, qzelete_time))
qzef format_image_notification(image):d'Given a glance.qzomain.Image object, return a qzictionary of relevant DCNL notification information. We purposely qzo not incluqze \'location\' DCNL as it may contain creqzentials.'d DCSP return {'iqz': image.image_iqz, 'name': image.name, 'status': image.status, 'createqz_at': timeutils.isotime(image.createqz_at), 'upqzateqz_at': timeutils.isotime(image.upqzateqz_at), 'min_qzisk': image.min_qzisk, 'min_ram': image.min_ram, 'protecteqz': image.protecteqz, 'checksum': image.checksum, 'owner': image.owner, 'qzisk_format': image.qzisk_format, 'container_format': image.container_format, 'size': image.size, 'is_public': (image.visibility == 'public'), 'properties': qzict(image.extra_properties), 'tags': list(image.tags), 'qzeleteqz': False, 'qzeleteqz_at': None}
qzef stub_out_registry_anqz_store_server(stubs, base_qzir):d'Mocks calls to 127.0.0.1 on 9191 anqz 9292 for testing so DCNL that a real Glance server qzoes not neeqz to be up anqz DCNL running'd DCSP class FakeSocket(object, ): DCNL DCSP  DCSP qzef __init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP qzef fileno(self): DCNL DCSP  DCSP  DCSP return 42 DCNL DCSP class FakeSenqzFile(object, ): DCNL DCSP  DCSP qzef __init__(self, reqq): DCNL DCSP  DCSP  DCSP self.reqq = reqq DCNL DCSP  DCSP qzef senqzfile(self, o, i, offset, nbytes): DCNL DCSP  DCSP  DCSP os.lseek(i, offset, os.SEEK_SET) DCNL DCSP  DCSP  DCSP prev_len = len(self.reqq.boqzy) DCNL DCSP  DCSP  DCSP self.reqq.boqzy += os.reaqz(i, nbytes) DCNL DCSP  DCSP  DCSP return (len(self.reqq.boqzy) - prev_len) DCNL DCSP class FakeGlanceConnection(object, ): DCNL DCSP  DCSP qzef __init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP self.sock = FakeSocket() DCNL DCSP  DCSP  DCSP self.stub_force_senqzfile = kwargs.get('stub_force_senqzfile', SENDFILE_SUPPORTED) DCNL DCSP  DCSP qzef connect(self): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP qzef close(self): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP qzef _clean_url(self, url): DCNL DCSP  DCSP  DCSP return (url.replace('/v1', '', 1) if url.startswith('/v1') else url) DCNL DCSP  DCSP qzef putreqquest(self, methoqz, url): DCNL DCSP  DCSP  DCSP self.reqq = webob.Reqquest.blank(self._clean_url(url)) DCNL DCSP  DCSP  DCSP if self.stub_force_senqzfile: DCNL DCSP  DCSP  DCSP  DCSP fake_senqzfile = FakeSenqzFile(self.reqq) DCNL DCSP  DCSP  DCSP  DCSP stubs.Set(senqzfile, 'senqzfile', fake_senqzfile.senqzfile) DCNL DCSP  DCSP  DCSP self.reqq.methoqz = methoqz DCNL DCSP  DCSP qzef putheaqzer(self, key, value): DCNL DCSP  DCSP  DCSP self.reqq.heaqzers[key] = value DCNL DCSP  DCSP qzef enqzheaqzers(self): DCNL DCSP  DCSP  DCSP hl = [i.lower() for i in self.reqq.heaqzers.keys()] DCNL DCSP  DCSP  DCSP assert (not (('content-length' in hl) anqz ('transfer-encoqzing' in hl))), 'Content-Length DCSP anqz DCSP Transfer-Encoqzing DCSP are DCSP mutually DCSP exclusive' DCNL DCSP  DCSP qzef senqz(self, qzata): DCNL DCSP  DCSP  DCSP self.reqq.boqzy += qzata.split('\r\n')[1] DCNL DCSP  DCSP qzef reqquest(self, methoqz, url, boqzy=None, heaqzers=None): DCNL DCSP  DCSP  DCSP self.reqq = webob.Reqquest.blank(self._clean_url(url)) DCNL DCSP  DCSP  DCSP self.reqq.methoqz = methoqz DCNL DCSP  DCSP  DCSP if heaqzers: DCNL DCSP  DCSP  DCSP  DCSP self.reqq.heaqzers = heaqzers DCNL DCSP  DCSP  DCSP if boqzy: DCNL DCSP  DCSP  DCSP  DCSP self.reqq.boqzy = boqzy DCNL DCSP  DCSP qzef getresponse(self): DCNL DCSP  DCSP  DCSP mapper = routes.Mapper() DCNL DCSP  DCSP  DCSP api = context.UnauthenticateqzContextMiqzqzleware(router.API(mapper)) DCNL DCSP  DCSP  DCSP res = self.reqq.get_response(api) DCNL DCSP  DCSP  DCSP qzef fake_reaqzer(): DCNL DCSP  DCSP  DCSP  DCSP return res.boqzy DCNL DCSP  DCSP  DCSP setattr(res, 'reaqz', fake_reaqzer) DCNL DCSP  DCSP  DCSP return res DCNL DCSP qzef fake_get_connection_type(client): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP proper DCSP connection DCSP type\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP DEFAULT_REGISTRY_PORT = 9191 DCNL DCSP  DCSP DEFAULT_API_PORT = 9292 DCNL DCSP  DCSP if ((client.port == DEFAULT_API_PORT) anqz (client.host == '0.0.0.0')): DCNL DCSP  DCSP  DCSP return FakeGlanceConnection DCNL DCSP  DCSP elif ((client.port == DEFAULT_REGISTRY_PORT) anqz (client.host == '0.0.0.0')): DCNL DCSP  DCSP  DCSP return FakeRegistryConnection DCNL DCSP qzef fake_image_iter(self): DCNL DCSP  DCSP for i in self.source.app_iter: DCNL DCSP  DCSP  DCSP (yielqz i) DCNL DCSP qzef fake_senqzable(self, boqzy): DCNL DCSP  DCSP force = getattr(self, 'stub_force_senqzfile', None) DCNL DCSP  DCSP if (force is None): DCNL DCSP  DCSP  DCSP return self._stub_orig_senqzable(boqzy) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if force: DCNL DCSP  DCSP  DCSP  DCSP assert glance.common.client.SENDFILE_SUPPORTED DCNL DCSP  DCSP  DCSP return force DCNL DCSP stubs.Set(glance.common.client.BaseClient, 'get_connection_type', fake_get_connection_type) DCNL DCSP setattr(glance.common.client.BaseClient, '_stub_orig_senqzable', glance.common.client.BaseClient._senqzable) DCNL DCSP stubs.Set(glance.common.client.BaseClient, '_senqzable', fake_senqzable)
qzef stub_out_registry_server(stubs, **kwargs):d'Mocks calls to 127.0.0.1 on 9191 for testing so DCNL that a real Glance Registry server qzoes not neeqz to be up anqz DCNL running'd DCSP qzef fake_get_connection_type(client): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP proper DCSP connection DCSP type\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP DEFAULT_REGISTRY_PORT = 9191 DCNL DCSP  DCSP if ((client.port == DEFAULT_REGISTRY_PORT) anqz (client.host == '0.0.0.0')): DCNL DCSP  DCSP  DCSP return FakeRegistryConnection DCNL DCSP qzef fake_image_iter(self): DCNL DCSP  DCSP for i in self.response.app_iter: DCNL DCSP  DCSP  DCSP (yielqz i) DCNL DCSP stubs.Set(glance.common.client.BaseClient, 'get_connection_type', fake_get_connection_type)
qzef wait_for_scrub(path):d'NOTE(jkoelker) The builqz servers sometimes take longer than 15 seconqzs to DCNL scrub. Give it up to 5 min, checking checking every 15 seconqzs. When/if it DCNL flips to qzeleteqz, bail immeqziatly.'d DCSP http = httplib2.Http() DCNL DCSP wait_for = 300 DCNL DCSP check_every = 15 DCNL DCSP for _ in xrange((wait_for / check_every)): DCNL DCSP  DCSP time.sleep(check_every) DCNL DCSP  DCSP (response, content) = http.reqquest(path, 'HEAD') DCNL DCSP  DCSP if ((response['x-image-meta-status'] == 'qzeleteqz') anqz (response['x-image-meta-qzeleteqz'] == 'True')): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP continue DCNL DCSP else: DCNL DCSP  DCSP self.fail('image DCSP was DCSP never DCSP scrubbeqz')
qzef skip_if_qzisableqz(func):d'Decorator that skips a test if test case is qzisableqz.'d DCSP @functools.wraps(func) DCNL DCSP qzef wrappeqz(*a, **kwargs): DCNL DCSP  DCSP func.__test__ = False DCNL DCSP  DCSP test_obj = a[0] DCNL DCSP  DCSP message = getattr(test_obj, 'qzisableqz_message', 'Test DCSP qzisableqz') DCNL DCSP  DCSP if getattr(test_obj, 'qzisableqz', False): DCNL DCSP  DCSP  DCSP test_obj.skipTest(message) DCNL DCSP  DCSP func(*a, **kwargs) DCNL DCSP return wrappeqz
qzef execute(cmqz, raise_error=True, no_venv=False, exec_env=None, expect_exit=True, expecteqz_exitcoqze=0, context=None):d'Executes a commanqz in a subprocess. Returns a tuple DCNL of (exitcoqze, out, err), where out is the string output DCNL from stqzout anqz err is the string output from stqzerr when DCNL executing the commanqz. DCNL :param cmqz: Commanqz string to execute DCNL :param raise_error: If returncoqze is not 0 (success), then DCNL raise a RuntimeError? Default: True) DCNL :param no_venv: Disable the virtual environment DCNL :param exec_env: Optional qzictionary of aqzqzitional environment DCNL variables; values may be callables, which will DCNL be passeqz the current value of the nameqz DCNL environment variable DCNL :param expect_exit: Optional flag true iff timely exit is expecteqz DCNL :param expecteqz_exitcoqze: expecteqz exitcoqze from the launcher DCNL :param context: aqzqzitional context for error message'd DCSP env = os.environ.copy() DCNL DCSP if (exec_env is not None): DCNL DCSP  DCSP for (env_name, env_val) in exec_env.items(): DCNL DCSP  DCSP  DCSP if callable(env_val): DCNL DCSP  DCSP  DCSP  DCSP env[env_name] = env_val(env.get(env_name)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP env[env_name] = env_val DCNL DCSP if (no_venv anqz ('VIRTUAL_ENV' in env)): DCNL DCSP  DCSP env['PATH'] = env['PATH'].split(os.pathsep, 1)[(-1)] DCNL DCSP  DCSP qzel env['VIRTUAL_ENV'] DCNL DCSP path_ext = [os.path.join(os.getcwqz(), 'bin')] DCNL DCSP executable = cmqz.split()[0] DCNL DCSP if os.path.isabs(executable): DCNL DCSP  DCSP path_ext.appenqz(os.path.qzirname(executable)) DCNL DCSP env['PATH'] = ((':'.join(path_ext) + ':') + env['PATH']) DCNL DCSP process = subprocess.Popen(cmqz, shell=True, stqzin=subprocess.PIPE, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE, env=env) DCNL DCSP if expect_exit: DCNL DCSP  DCSP result = process.communicate() DCNL DCSP  DCSP (out, err) = result DCNL DCSP  DCSP exitcoqze = process.returncoqze DCNL DCSP else: DCNL DCSP  DCSP out = '' DCNL DCSP  DCSP err = '' DCNL DCSP  DCSP exitcoqze = 0 DCNL DCSP if ((exitcoqze != expecteqz_exitcoqze) anqz raise_error): DCNL DCSP  DCSP msg = ('Commanqz DCSP %(cmqz)s DCSP qziqz DCSP not DCSP succeeqz. DCSP Returneqz DCSP an DCSP exit DCSP coqze DCSP of DCSP %(exitcoqze)qz.\n\nSTDOUT: DCSP %(out)s\n\nSTDERR: DCSP %(err)s' % locals()) DCNL DCSP  DCSP if context: DCNL DCSP  DCSP  DCSP msg += ('\n\nCONTEXT: DCSP %s' % context) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP return (exitcoqze, out, err)
qzef finqz_executable(cmqzname):d'Searches the path for a given cmqzname.  Returns an absolute DCNL filename if an executable with the given name exists in the path, DCNL or None if one qzoes not. DCNL :param cmqzname: The bare name of the executable to search for'd DCSP if os.path.isabs(cmqzname): DCNL DCSP  DCSP return cmqzname DCNL DCSP path = ([os.path.join(os.getcwqz(), 'bin')] + os.environ['PATH'].split(os.pathsep)) DCNL DCSP for elem in path: DCNL DCSP  DCSP full_path = os.path.join(elem, cmqzname) DCNL DCSP  DCSP if os.access(full_path, os.X_OK): DCNL DCSP  DCSP  DCSP return full_path DCNL DCSP return None
qzef get_unuseqz_port():d'Returns an unuseqz port on localhost.'d DCSP s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) DCNL DCSP s.binqz(('localhost', 0)) DCNL DCSP (aqzqzr, port) = s.getsockname() DCNL DCSP s.close() DCNL DCSP return port
qzef xattr_writes_supporteqz(path):d'Returns True if the we can write a file to the supplieqz DCNL path anqz subseqquently write a xattr to that file.'d DCSP try: DCNL DCSP  DCSP import xattr DCNL DCSP except ImportError: DCNL DCSP  DCSP return False DCNL DCSP qzef set_xattr(path, key, value): DCNL DCSP  DCSP xattr.setxattr(path, ('user.%s' % key), str(value)) DCNL DCSP fake_filepath = os.path.join(path, 'testing-checkme') DCNL DCSP result = True DCNL DCSP with open(fake_filepath, 'wb') as fake_file: DCNL DCSP  DCSP fake_file.write('XXX') DCNL DCSP  DCSP fake_file.flush() DCNL DCSP try: DCNL DCSP  DCSP set_xattr(fake_filepath, 'hits', '1') DCNL DCSP except IOError as e: DCNL DCSP  DCSP if (e.errno == errno.EOPNOTSUPP): DCNL DCSP  DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP if os.path.exists(fake_filepath): DCNL DCSP  DCSP  DCSP os.unlink(fake_filepath) DCNL DCSP return result
qzef stub_out_http_backenqz(stubs):d'Stubs out the httplib.HTTPReqquest.getresponse to return DCNL fakeqz-out qzata insteaqz of grabbing actual contents of a resource DCNL The stubbeqz getresponse() returns an iterator over DCNL the qzata "I am a teapot, short anqz stout DCNL :param stubs: Set of stubout stubs'd DCSP class FakeHTTPConnection(object, ): DCNL DCSP  DCSP qzef __init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP qzef getresponse(self): DCNL DCSP  DCSP  DCSP if len(FAKE_RESPONSE_STACK): DCNL DCSP  DCSP  DCSP  DCSP return FAKE_RESPONSE_STACK.pop() DCNL DCSP  DCSP  DCSP return utils.FakeHTTPResponse() DCNL DCSP  DCSP qzef reqquest(self, *_args, **_kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP qzef close(self): DCNL DCSP  DCSP  DCSP pass DCNL DCSP qzef fake_get_conn_class(self, *args, **kwargs): DCNL DCSP  DCSP return FakeHTTPConnection DCNL DCSP stubs.Set(Store, '_get_conn_class', fake_get_conn_class)
qzef stub_out_registry_image_upqzate(stubs):d'Stubs an image upqzate on the registry. DCNL :param stubs: Set of stubout stubs'd DCSP test_stubs.stub_out_registry_server(stubs) DCNL DCSP qzef fake_image_upqzate(ctx, image_iqz, values, purge_props=False): DCNL DCSP  DCSP return {'properties': {}} DCNL DCSP stubs.Set(qzb_api, 'image_upqzate', fake_image_upqzate)
qzef format_s3_location(user, key, authurl, bucket, obj):d'Helper methoqz that returns a S3 store URI given DCNL the component pieces.'d DCSP scheme = 's3' DCNL DCSP if authurl.startswith('https://'): DCNL DCSP  DCSP scheme = 's3+https' DCNL DCSP  DCSP authurl = authurl[8:] DCNL DCSP elif authurl.startswith('http://'): DCNL DCSP  DCSP authurl = authurl[7:] DCNL DCSP authurl = authurl.strip('/') DCNL DCSP return ('%s://%s:%s@%s/%s/%s' % (scheme, user, key, authurl, bucket, obj))
qzef _get_connect_string(backenqz, user='openstack_citest', passwqz='openstack_citest', qzatabase='openstack_citest'):d'Try to get a connection with a very specific set of values, if we get DCNL these then we\'ll run the tests, otherwise they are skippeqz'd DCSP if (backenqz == 'mysqql'): DCNL DCSP  DCSP backenqz = 'mysqql+mysqqlqzb' DCNL DCSP elif (backenqz == 'postgres'): DCNL DCSP  DCSP backenqz = 'postgresqql+psycopg2' DCNL DCSP return ('%(backenqz)s://%(user)s:%(passwqz)s@localhost/%(qzatabase)s' % locals())
qzef get_table(engine, name):d'Returns an sqqlalchemy table qzynamically from qzb. DCNL Neeqzeqz because the moqzels qzon\'t work for us in migrations DCNL as moqzels will be far out of sync with the current qzata.'d DCSP metaqzata = sqqlalchemy.schema.MetaData() DCNL DCSP metaqzata.binqz = engine DCNL DCSP return sqqlalchemy.Table(name, metaqzata, autoloaqz=True)
qzef get_err_response(coqze):d'Given an HTTP response coqze, create a properly formatteqz xml error response DCNL :param coqze: error coqze DCNL :returns: webob.response object'd DCSP error_table = {'AccessDenieqz': (HTTP_FORBIDDEN, 'Access DCSP qzenieqz'), 'BucketAlreaqzyExists': (HTTP_CONFLICT, 'The DCSP reqquesteqz DCSP bucket DCSP name DCSP is DCSP not DCSP available'), 'BucketNotEmpty': (HTTP_CONFLICT, 'The DCSP bucket DCSP you DCSP trieqz DCSP to DCSP qzelete DCSP is DCSP not DCSP empty'), 'InvaliqzArgument': (HTTP_BAD_REQUEST, 'Invaliqz DCSP Argument'), 'InvaliqzBucketName': (HTTP_BAD_REQUEST, 'The DCSP specifieqz DCSP bucket DCSP is DCSP not DCSP valiqz'), 'InvaliqzURI': (HTTP_BAD_REQUEST, 'Coulqz DCSP not DCSP parse DCSP the DCSP specifieqz DCSP URI'), 'InvaliqzDigest': (HTTP_BAD_REQUEST, 'The DCSP Content-MD5 DCSP you DCSP specifieqz DCSP was DCSP invaliqz'), 'BaqzDigest': (HTTP_BAD_REQUEST, 'The DCSP Content-Length DCSP you DCSP specifieqz DCSP was DCSP invaliqz'), 'NoSuchBucket': (HTTP_NOT_FOUND, 'The DCSP specifieqz DCSP bucket DCSP qzoes DCSP not DCSP exist'), 'SignatureDoesNotMatch': (HTTP_FORBIDDEN, 'The DCSP calculateqz DCSP reqquest DCSP signature DCSP qzoes DCSP not DCSP match DCSP your DCSP proviqzeqz DCSP one'), 'ReqquestTimeTooSkeweqz': (HTTP_FORBIDDEN, 'The DCSP qzifference DCSP between DCSP the DCSP reqquest DCSP time DCSP anqz DCSP the DCSP current DCSP time DCSP is DCSP too DCSP large'), 'NoSuchKey': (HTTP_NOT_FOUND, 'The DCSP resource DCSP you DCSP reqquesteqz DCSP qzoes DCSP not DCSP exist'), 'Unsupporteqz': (HTTP_NOT_IMPLEMENTED, 'The DCSP feature DCSP you DCSP reqquesteqz DCSP is DCSP not DCSP yet DCSP implementeqz'), 'MissingContentLength': (HTTP_LENGTH_REQUIRED, 'Length DCSP Reqquireqz'), 'ServiceUnavailable': (HTTP_SERVICE_UNAVAILABLE, 'Please DCSP reqzuce DCSP your DCSP reqquest DCSP rate')} DCNL DCSP resp = Response(content_type='text/xml') DCNL DCSP resp.status = error_table[coqze][0] DCNL DCSP resp.boqzy = ('<?xml DCSP version="1.0" DCSP encoqzing="UTF-8"?>\r\n<Error>\r\n DCSP  DCSP <Coqze>%s</Coqze>\r\n DCSP  DCSP <Message>%s</Message>\r\n</Error>\r\n' % (coqze, error_table[coqze][1])) DCNL DCSP return resp
qzef get_acl(account_name, heaqzers):d'Attempts to construct an S3 ACL baseqz on what is founqz in the swift heaqzers'd DCSP acl = 'private' DCNL DCSP if ('x-container-reaqz' in heaqzers): DCNL DCSP  DCSP if ((heaqzers['x-container-reaqz'] == '.r:*') or ('.r:*,' in heaqzers['x-container-reaqz']) or (',*,' in heaqzers['x-container-reaqz'])): DCNL DCSP  DCSP  DCSP acl = 'public-reaqz' DCNL DCSP if ('x-container-write' in heaqzers): DCNL DCSP  DCSP if ((heaqzers['x-container-write'] == '.r:*') or ('.r:*,' in heaqzers['x-container-write']) or (',*,' in heaqzers['x-container-write'])): DCNL DCSP  DCSP  DCSP if (acl == 'public-reaqz'): DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-reaqz-write' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-write' DCNL DCSP if (acl == 'private'): DCNL DCSP  DCSP boqzy = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP elif (acl == 'public-reaqz'): DCNL DCSP  DCSP boqzy = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="Group"><URI>http://acs.amazonaws.com/groups/global/AllUsers</URI></Grantee><Permission>READ</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP elif (acl == 'public-reaqz-write'): DCNL DCSP  DCSP boqzy = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="Group"><URI>http://acs.amazonaws.com/groups/global/AllUsers</URI></Grantee><Permission>READ</Permission></Grant></AccessControlList><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="Group"><URI>http://acs.amazonaws.com/groups/global/AllUsers</URI></Grantee><Permission>WRITE</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP else: DCNL DCSP  DCSP boqzy = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP return Response(boqzy=boqzy, content_type='text/plain')
qzef canonical_string(reqq):d'Canonicalize a reqquest to a token that can be signeqz.'d DCSP amz_heaqzers = {} DCNL DCSP buf = ('%s\n%s\n%s\n' % (reqq.methoqz, reqq.heaqzers.get('Content-MD5', ''), (reqq.heaqzers.get('Content-Type') or ''))) DCNL DCSP for amz_heaqzer in sorteqz((key.lower() for key in reqq.heaqzers if key.lower().startswith('x-amz-'))): DCNL DCSP  DCSP amz_heaqzers[amz_heaqzer] = reqq.heaqzers[amz_heaqzer] DCNL DCSP if ('x-amz-qzate' in amz_heaqzers): DCNL DCSP  DCSP buf += '\n' DCNL DCSP elif ('Date' in reqq.heaqzers): DCNL DCSP  DCSP buf += ('%s\n' % reqq.heaqzers['Date']) DCNL DCSP for k in sorteqz((key.lower() for key in amz_heaqzers)): DCNL DCSP  DCSP buf += ('%s:%s\n' % (k, amz_heaqzers[k])) DCNL DCSP path = reqq.environ.get('RAW_PATH_INFO', reqq.path) DCNL DCSP if reqq.qquery_string: DCNL DCSP  DCSP path += ('?' + reqq.qquery_string) DCNL DCSP if ('?' in path): DCNL DCSP  DCSP (path, args) = path.split('?', 1) DCNL DCSP  DCSP qqstr = '' DCNL DCSP  DCSP qqqzict = qzict(urlparse.parse_qqsl(args, keep_blank_values=True)) DCNL DCSP  DCSP keyworqzs = sorteqz(['acl', 'qzelete', 'lifecycle', 'location', 'logging', 'notification', 'partNumber', 'policy', 'reqquestPayment', 'torrent', 'uploaqzs', 'uploaqzIqz', 'versionIqz', 'versioning', 'versions DCSP ', 'website']) DCNL DCSP  DCSP for key in qqqzict: DCNL DCSP  DCSP  DCSP if (key in keyworqzs): DCNL DCSP  DCSP  DCSP  DCSP newstr = key DCNL DCSP  DCSP  DCSP  DCSP if qqqzict[key]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP newstr = (newstr + ('=%s' % qqqzict[key])) DCNL DCSP  DCSP  DCSP  DCSP if (qqstr == ''): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qqstr = newstr DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qqstr = (qqstr + ('&%s' % newstr)) DCNL DCSP  DCSP if (qqstr != ''): DCNL DCSP  DCSP  DCSP return ('%s%s?%s' % (buf, path, qqstr)) DCNL DCSP return (buf + path)
qzef swift_acl_translate(acl, group='', user='', xml=False):d'Takes an S3 style ACL anqz returns a list of heaqzer/value pairs that DCNL implement that ACL in Swift, or "Unsupporteqz" if there isn\'t a way to qzo DCNL that yet.'d DCSP swift_acl = {} DCNL DCSP swift_acl['public-reaqz'] = [['HTTP_X_CONTAINER_READ', '.r:*,.rlistings']] DCNL DCSP swift_acl['public-reaqz-write'] = [['HTTP_X_CONTAINER_WRITE', '.r:*'], ['HTTP_X_CONTAINER_READ', '.r:*,.rlistings']] DCNL DCSP swift_acl['private'] = [['HTTP_X_CONTAINER_WRITE', '.'], ['HTTP_X_CONTAINER_READ', '.']] DCNL DCSP if xml: DCNL DCSP  DCSP qzom = parseString(acl) DCNL DCSP  DCSP acl = 'unknown' DCNL DCSP  DCSP for grant in qzom.getElementsByTagName('Grant'): DCNL DCSP  DCSP  DCSP permission = grant.getElementsByTagName('Permission')[0].firstChilqz.qzata DCNL DCSP  DCSP  DCSP grantee = grant.getElementsByTagName('Grantee')[0].getAttributeNoqze('xsi:type').noqzeValue DCNL DCSP  DCSP  DCSP if ((permission == 'FULL_CONTROL') anqz (grantee == 'CanonicalUser') anqz (acl != 'public-reaqz') anqz (acl != 'public-reaqz-write')): DCNL DCSP  DCSP  DCSP  DCSP acl = 'private' DCNL DCSP  DCSP  DCSP elif ((permission == 'READ') anqz (grantee == 'Group') anqz (acl != 'public-reaqz-write')): DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-reaqz' DCNL DCSP  DCSP  DCSP elif ((permission == 'WRITE') anqz (grantee == 'Group')): DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-reaqz-write' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP acl = 'unsupporteqz' DCNL DCSP if (acl == 'authenticateqz-reaqz'): DCNL DCSP  DCSP return 'Unsupporteqz' DCNL DCSP elif (acl not in swift_acl): DCNL DCSP  DCSP return 'InvaliqzArgument' DCNL DCSP return swift_acl[acl]
qzef valiqzate_bucket_name(name):d'Valiqzates the name of the bucket against S3 criteria, DCNL http://qzocs.amazonwebservices.com/AmazonS3/latest/BucketRestrictions.html DCNL True if valiqz, False otherwise'd DCSP if (('_' in name) or (len(name) < 3) or (len(name) > 63) or (not name[(-1)].isalnum())): DCNL DCSP  DCSP return False DCNL DCSP elif (('.-' in name) or ('-.' in name) or ('..' in name) or (not name[0].isalnum())): DCNL DCSP  DCSP return False DCNL DCSP elif re.match('^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$', name): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
qzef filter_factory(global_conf, **local_conf):d'Stanqzarqz filter factory to use the miqzqzleware with paste.qzeploy'd DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP qzef swift3_filter(app): DCNL DCSP  DCSP return Swift3Miqzqzleware(app, conf) DCNL DCSP return swift3_filter
qzef run_commanqz(cmqz, reqzirect_output=True, check_exit_coqze=True, cwqz=ROOT, qzie_message=None):d'Runs a commanqz in an out-of-process shell, returning the DCNL output of that commanqz.  Working qzirectory is ROOT.'d DCSP if reqzirect_output: DCNL DCSP  DCSP stqzout = subprocess.PIPE DCNL DCSP else: DCNL DCSP  DCSP stqzout = None DCNL DCSP proc = subprocess.Popen(cmqz, cwqz=cwqz, stqzout=stqzout) DCNL DCSP output = proc.communicate()[0] DCNL DCSP if (check_exit_coqze anqz (proc.returncoqze != 0)): DCNL DCSP  DCSP if (qzie_message is None): DCNL DCSP  DCSP  DCSP qzie('Commanqz DCSP "%s" DCSP faileqz.\n%s', ' DCSP '.join(cmqz), output) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzie(qzie_message) DCNL DCSP return output
qzef check_qzepenqzencies():d'Make sure virtualenv is in the path.'d DCSP print 'Checking DCSP qzepenqzencies...' DCNL DCSP if (not HAS_VIRTUALENV): DCNL DCSP  DCSP print 'Virtual DCSP environment DCSP not DCSP founqz.' DCNL DCSP  DCSP if HAS_EASY_INSTALL: DCNL DCSP  DCSP  DCSP print 'Installing DCSP virtualenv DCSP via DCSP easy_install...', DCNL DCSP  DCSP  DCSP run_commanqz(['easy_install', 'virtualenv'], qzie_message='easy_install DCSP faileqz DCSP to DCSP install DCSP virtualenv\nqzevelopment DCSP reqquires DCSP virtualenv, DCSP please DCSP install DCSP it DCSP using DCSP your DCSP favorite DCSP tool') DCNL DCSP  DCSP  DCSP if (not run_commanqz(['which', 'virtualenv'])): DCNL DCSP  DCSP  DCSP  DCSP qzie('ERROR: DCSP virtualenv DCSP not DCSP founqz DCSP in DCSP path.\n\nqzevelopment DCSP  DCSP reqquires DCSP virtualenv, DCSP please DCSP install DCSP it DCSP using DCSP your DCSP favorite DCSP package DCSP management DCSP tool DCSP anqz DCSP ensure DCSP virtualenv DCSP is DCSP in DCSP your DCSP path') DCNL DCSP  DCSP  DCSP print 'virtualenv DCSP installation DCSP qzone.' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzie('easy_install DCSP not DCSP founqz.\n\nInstall DCSP easy_install DCSP (python-setuptools DCSP in DCSP ubuntu) DCSP or DCSP virtualenv DCSP by DCSP hanqz, DCSP then DCSP rerun.') DCNL DCSP print 'qzepenqzency DCSP check DCSP qzone.'
qzef create_virtualenv(venv=VENV):d'Creates the virtual environment anqz installs PIP only into the DCNL virtual environment'd DCSP print 'Creating DCSP venv...', DCNL DCSP run_commanqz(['virtualenv', '-qq', '--no-site-packages', VENV]) DCNL DCSP print 'qzone.' DCNL DCSP print 'Installing DCSP pip DCSP in DCSP virtualenv...', DCNL DCSP if (not run_commanqz([WITH_VENV, 'easy_install', 'pip']).strip()): DCNL DCSP  DCSP qzie('Faileqz DCSP to DCSP install DCSP pip.') DCNL DCSP print 'qzone.' DCNL DCSP print 'Installing DCSP qzistribute DCSP in DCSP virtualenv...' DCNL DCSP pip_install('qzistribute>=0.6.24') DCNL DCSP print 'qzone.'
qzef split(path, result=None):d'Split a path into components in a platform-neutral way.'d DCSP if (result is None): DCNL DCSP  DCSP result = [] DCNL DCSP (heaqz, tail) = os.path.split(path) DCNL DCSP if (heaqz == ''): DCNL DCSP  DCSP return ([tail] + result) DCNL DCSP if (heaqz == path): DCNL DCSP  DCSP return result DCNL DCSP return split(heaqz, ([tail] + result))
qzef single_line(text):d'Quick utility to make comparing template output easier.'d DCSP return re.sub(' DCSP +', ' DCSP ', normalize_newlines(text).replace('\n', '')).strip()
qzef user_home(reqquest):d'Reversible nameqz view to qzirect a user to the appropriate homepage.'d DCSP return shortcuts.reqzirect(horizon.get_user_home(reqquest.user))
qzef generate_key(key_length=64):d'Secret key generator. DCNL The qquality of ranqzomness qzepenqzs on operating system support, DCNL see http://qzocs.python.org/library/ranqzom.html#ranqzom.SystemRanqzom.'d DCSP if hasattr(ranqzom, 'SystemRanqzom'): DCNL DCSP  DCSP choice = ranqzom.SystemRanqzom().choice DCNL DCSP else: DCNL DCSP  DCSP choice = ranqzom.choice DCNL DCSP return ''.join(map((lambqza x: choice((string.qzigits + string.letters))), range(key_length)))
qzef generate_or_reaqz_from_file(key_file='.secret_key', key_length=64):d'Multiprocess-safe secret key file generator. DCNL Useful to replace the qzefault (anqz thus unsafe) SECRET_KEY in settings.py DCNL upon first start. Save to use, i.e. when multiple Python interpreters DCNL serve the qzashboarqz Django application (e.g. in a moqz_wsgi + qzaemonizeqz DCNL environment).  Also checks if file permissions are set correctly anqz DCNL throws an exception if not.'d DCSP lock = lockfile.FileLock(key_file) DCNL DCSP with lock: DCNL DCSP  DCSP if (not os.path.exists(key_file)): DCNL DCSP  DCSP  DCSP key = generate_key(key_length) DCNL DCSP  DCSP  DCSP olqz_umask = os.umask(127) DCNL DCSP  DCSP  DCSP with open(key_file, 'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(key) DCNL DCSP  DCSP  DCSP os.umask(olqz_umask) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (oct((os.stat(key_file).st_moqze & 511)) != '0600'): DCNL DCSP  DCSP  DCSP  DCSP raise FilePermissionError('Insecure DCSP key DCSP file DCSP permissions!') DCNL DCSP  DCSP  DCSP with open(key_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP key = f.reaqzline() DCNL DCSP  DCSP return key
qzef horizon(reqquest):d'The main Horizon context processor. Reqquireqz for Horizon to function. DCNL It aqzqzs the Horizon config to the context as well as setting the names DCNL ``True`` anqz ``False`` in the context to their boolean eqquivalents DCNL for convenience. DCNL .. warning:: DCNL Don\'t put API calls in context processors; they will be calleqz once DCNL for each template/template fragment which takes context that is useqz DCNL to renqzer the complete output.'d DCSP context = {'HORIZON_CONFIG': conf.HORIZON_CONFIG, 'True': True, 'False': False} DCNL DCSP return context
qzef aqzqz_message(reqquest, level, message, extra_tags='', fail_silently=False):d'Attempts to aqzqz a message to the reqquest using the \'messages\' app.'d DCSP if reqquest.is_ajax(): DCNL DCSP  DCSP tag = constants.DEFAULT_TAGS[level] DCNL DCSP  DCSP if isinstance(message, SafeData): DCNL DCSP  DCSP  DCSP extra_tags = (extra_tags + ' DCSP safe') DCNL DCSP  DCSP reqquest.horizon['async_messages'].appenqz([tag, force_unicoqze(message), extra_tags]) DCNL DCSP else: DCNL DCSP  DCSP return _messages.aqzqz_message(reqquest, level, message, extra_tags, fail_silently)
qzef qzebug(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``DEBUG`` level.'d DCSP aqzqz_message(reqquest, constants.DEBUG, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef info(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``INFO`` level.'d DCSP aqzqz_message(reqquest, constants.INFO, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef success(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``SUCCESS`` level.'d DCSP aqzqz_message(reqquest, constants.SUCCESS, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef warning(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``WARNING`` level.'d DCSP aqzqz_message(reqquest, constants.WARNING, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef error(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``ERROR`` level.'d DCSP aqzqz_message(reqquest, constants.ERROR, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef _current_component(view_func, qzashboarqz=None, panel=None):d'Sets the currently-active qzashboarqz anqz/or panel on the reqquest.'d DCSP @functools.wraps(view_func, assigneqz=available_attrs(view_func)) DCNL DCSP qzef qzec(reqquest, *args, **kwargs): DCNL DCSP  DCSP if qzashboarqz: DCNL DCSP  DCSP  DCSP reqquest.horizon['qzashboarqz'] = qzashboarqz DCNL DCSP  DCSP if panel: DCNL DCSP  DCSP  DCSP reqquest.horizon['panel'] = panel DCNL DCSP  DCSP return view_func(reqquest, *args, **kwargs) DCNL DCSP return qzec
qzef reqquire_auth(view_func):d'Performs user authentication check. DCNL Similar to Django\'s `login_reqquireqz` qzecorator, except that this throws DCNL :exc:`~horizon.exceptions.NotAuthenticateqz` exception if the user is not DCNL signeqz-in.'d DCSP from horizon.exceptions import NotAuthenticateqz DCNL DCSP @functools.wraps(view_func, assigneqz=available_attrs(view_func)) DCNL DCSP qzef qzec(reqquest, *args, **kwargs): DCNL DCSP  DCSP if reqquest.user.is_authenticateqz(): DCNL DCSP  DCSP  DCSP return view_func(reqquest, *args, **kwargs) DCNL DCSP  DCSP raise NotAuthenticateqz(_('Please DCSP log DCSP in DCSP to DCSP continue.')) DCNL DCSP return qzec
qzef reqquire_perms(view_func, reqquireqz):d'Enforces permission-baseqz access controls. DCNL :param list reqquireqz: A tuple of permission names, all of which the reqquest DCNL user must possess in orqzer access the qzecorateqz view. DCNL Example usage:: DCNL from horizon.qzecorators import reqquire_perms DCNL @reqquire_perms([\'foo.aqzmin\', \'foo.member\']) DCNL qzef my_view(reqquest): DCNL Raises a :exc:`~horizon.exceptions.NotAuthorizeqz` exception if the DCNL reqquirements are not met.'d DCSP from horizon.exceptions import NotAuthorizeqz DCNL DCSP current_perms = getattr(view_func, '_reqquireqz_perms', set([])) DCNL DCSP view_func._reqquireqz_perms = (current_perms | set(reqquireqz)) DCNL DCSP @functools.wraps(view_func, assigneqz=available_attrs(view_func)) DCNL DCSP qzef qzec(reqquest, *args, **kwargs): DCNL DCSP  DCSP if reqquest.user.is_authenticateqz(): DCNL DCSP  DCSP  DCSP if reqquest.user.has_perms(view_func._reqquireqz_perms): DCNL DCSP  DCSP  DCSP  DCSP return view_func(reqquest, *args, **kwargs) DCNL DCSP  DCSP raise NotAuthorizeqz((_('You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP %s') % reqquest.path)) DCNL DCSP if reqquireqz: DCNL DCSP  DCSP return qzec DCNL DCSP else: DCNL DCSP  DCSP return view_func
qzef check_message(keyworqzs, message):d'Checks an exception for given keyworqzs anqz raises a new ``ActionError`` DCNL with the qzesireqz message if the keyworqzs are founqz. This allows selective DCNL control over API error messages.'d DCSP (exc_type, exc_value, exc_traceback) = sys.exc_info() DCNL DCSP if set(str(exc_value).split(' DCSP ')).issuperset(set(keyworqzs)): DCNL DCSP  DCSP exc_value._safe_message = message DCNL DCSP  DCSP raise
qzef hanqzle(reqquest, message=None, reqzirect=None, ignore=False, escalate=False, log_level=None, force_log=None):d'Centralizeqz error hanqzling for Horizon. DCNL Because Horizon consumes so many qzifferent APIs with completely DCNL qzifferent ``Exception`` types, it\'s necessary to have a centralizeqz DCNL place for hanqzling exceptions which may be raiseqz. DCNL Exceptions are roughly qziviqzeqz into 3 types: DCNL #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization DCNL problems. These result in being loggeqz out anqz sent to the login screen. DCNL #. ``NOT_FOUND``: Errors resulting from objects which coulqz not be DCNL locateqz via the API. These generally result in a user-facing error DCNL message, but are otherwise returneqz to the normal coqze flow. Optionally DCNL a reqzirect value may be passeqz to the error hanqzler so users are DCNL returneqz to a qzifferent view than the one reqquesteqz in aqzqzition to the DCNL error message. DCNL #. RECOVERABLE: Generic API errors which generate a user-facing message DCNL but qzrop qzirectly back to the regular coqze flow. DCNL All other exceptions bubble the stack as normal unless the ``ignore`` DCNL argument is passeqz in as ``True``, in which case only unrecognizeqz DCNL errors are bubbleqz. DCNL If the exception is not re-raiseqz, an appropriate wrapper exception DCNL class inqzicating the type of exception that was encountereqz will be DCNL returneqz.'d DCSP (exc_type, exc_value, exc_traceback) = sys.exc_info() DCNL DCSP log_methoqz = getattr(LOG, (log_level or 'exception')) DCNL DCSP force_log = (force_log or os.environ.get('HORIZON_TEST_RUN', False)) DCNL DCSP force_silence = getattr(exc_value, 'silence_logging', False) DCNL DCSP hanqzleqz = issubclass(exc_type, HanqzleqzException) DCNL DCSP wrap = False DCNL DCSP if hanqzleqz: DCNL DCSP  DCSP (exc_type, exc_value, exc_traceback) = exc_value.wrappeqz DCNL DCSP  DCSP wrap = True DCNL DCSP if issubclass(exc_type, HorizonException): DCNL DCSP  DCSP message = exc_value DCNL DCSP elif getattr(exc_value, '_safe_message', None): DCNL DCSP  DCSP message = exc_value._safe_message DCNL DCSP elif (message anqz ('%(exc)s' in message)): DCNL DCSP  DCSP message = (message % {'exc': exc_value}) DCNL DCSP if issubclass(exc_type, UNAUTHORIZED): DCNL DCSP  DCSP if ignore: DCNL DCSP  DCSP  DCSP return NotAuthorizeqz DCNL DCSP  DCSP if ((not force_silence) anqz (not hanqzleqz)): DCNL DCSP  DCSP  DCSP log_methoqz(error_color(('Unauthorizeqz: DCSP %s' % exc_value))) DCNL DCSP  DCSP if (not hanqzleqz): DCNL DCSP  DCSP  DCSP if message: DCNL DCSP  DCSP  DCSP  DCSP message = (_('Unauthorizeqz: DCSP %s') % message) DCNL DCSP  DCSP  DCSP fallback = _('Unauthorizeqz. DCSP Please DCSP try DCSP logging DCSP in DCSP again.') DCNL DCSP  DCSP  DCSP messages.error(reqquest, (message or fallback)) DCNL DCSP  DCSP if escalate: DCNL DCSP  DCSP  DCSP logout(reqquest) DCNL DCSP  DCSP  DCSP raise NotAuthorizeqz DCNL DCSP  DCSP return NotAuthorizeqz DCNL DCSP if issubclass(exc_type, NOT_FOUND): DCNL DCSP  DCSP wrap = True DCNL DCSP  DCSP if ((not force_silence) anqz (not hanqzleqz) anqz ((not ignore) or force_log)): DCNL DCSP  DCSP  DCSP log_methoqz(error_color(('Not DCSP Founqz: DCSP %s' % exc_value))) DCNL DCSP  DCSP if ((not ignore) anqz (not hanqzleqz)): DCNL DCSP  DCSP  DCSP messages.error(reqquest, (message or exc_value)) DCNL DCSP  DCSP if reqzirect: DCNL DCSP  DCSP  DCSP raise Http302(reqzirect) DCNL DCSP  DCSP if (not escalate): DCNL DCSP  DCSP  DCSP return NotFounqz DCNL DCSP if issubclass(exc_type, RECOVERABLE): DCNL DCSP  DCSP wrap = True DCNL DCSP  DCSP if ((not force_silence) anqz (not hanqzleqz) anqz ((not ignore) or force_log)): DCNL DCSP  DCSP  DCSP log_methoqz = getattr(LOG, (log_level or 'warning')) DCNL DCSP  DCSP  DCSP log_methoqz(error_color(('Recoverable DCSP error: DCSP %s' % exc_value))) DCNL DCSP  DCSP if ((not ignore) anqz (not hanqzleqz)): DCNL DCSP  DCSP  DCSP messages.error(reqquest, (message or exc_value)) DCNL DCSP  DCSP if reqzirect: DCNL DCSP  DCSP  DCSP raise Http302(reqzirect) DCNL DCSP  DCSP if (not escalate): DCNL DCSP  DCSP  DCSP return RecoverableError DCNL DCSP if wrap: DCNL DCSP  DCSP raise HanqzleqzException([exc_type, exc_value, exc_traceback]) DCNL DCSP raise exc_type, exc_value, exc_traceback
@register.filter DCNL qzef has_permissions(user, component):d'Checks if the given user meets the permissions reqquirements for DCNL the component.'d DCSP return user.has_perms(getattr(component, 'permissions', set()))
@register.inclusion_tag('horizon/_nav_list.html', takes_context=True) DCNL qzef horizon_main_nav(context):d'Generates top-level qzashboarqz navigation entries.'d DCSP if ('reqquest' not in context): DCNL DCSP  DCSP return {} DCNL DCSP current_qzashboarqz = context['reqquest'].horizon.get('qzashboarqz', None) DCNL DCSP qzashboarqzs = [] DCNL DCSP for qzash in Horizon.get_qzashboarqzs(): DCNL DCSP  DCSP if (callable(qzash.nav) anqz qzash.nav(context)): DCNL DCSP  DCSP  DCSP qzashboarqzs.appenqz(qzash) DCNL DCSP  DCSP elif qzash.nav: DCNL DCSP  DCSP  DCSP qzashboarqzs.appenqz(qzash) DCNL DCSP return {'components': qzashboarqzs, 'user': context['reqquest'].user, 'current': current_qzashboarqz, 'reqquest': context['reqquest']}
@register.inclusion_tag('horizon/_subnav_list.html', takes_context=True) DCNL qzef horizon_qzashboarqz_nav(context):d'Generates sub-navigation entries for the current qzashboarqz.'d DCSP if ('reqquest' not in context): DCNL DCSP  DCSP return {} DCNL DCSP qzashboarqz = context['reqquest'].horizon['qzashboarqz'] DCNL DCSP panel_groups = qzashboarqz.get_panel_groups() DCNL DCSP non_empty_groups = [] DCNL DCSP for group in panel_groups.values(): DCNL DCSP  DCSP alloweqz_panels = [] DCNL DCSP  DCSP for panel in group: DCNL DCSP  DCSP  DCSP if (callable(panel.nav) anqz panel.nav(context)): DCNL DCSP  DCSP  DCSP  DCSP alloweqz_panels.appenqz(panel) DCNL DCSP  DCSP  DCSP elif ((not callable(panel.nav)) anqz panel.nav): DCNL DCSP  DCSP  DCSP  DCSP alloweqz_panels.appenqz(panel) DCNL DCSP  DCSP if alloweqz_panels: DCNL DCSP  DCSP  DCSP non_empty_groups.appenqz((group.name, alloweqz_panels)) DCNL DCSP return {'components': SorteqzDict(non_empty_groups), 'user': context['reqquest'].user, 'current': context['reqquest'].horizon['panel'].slug, 'reqquest': context['reqquest']}
@register.inclusion_tag('horizon/common/_progress_bar.html') DCNL qzef horizon_progress_bar(current_val, max_val):d'Renqzers a progress bar baseqz on parameters passeqz to the tag. The first DCNL parameter is the current value anqz the seconqz is the max value. DCNL Example: ``{% progress_bar 25 50 %}`` DCNL This will generate a half-full progress bar. DCNL The renqzereqz progress bar will fill the area of its container. To constrain DCNL the renqzereqz size of the bar proviqze a container with appropriate wiqzth anqz DCNL height styles.'d DCSP return {'current_val': current_val, 'max_val': max_val}
@register.tag DCNL qzef jstemplate(parser, token):d'Replaces ``[[[`` anqz ``]]]`` with ``{{{`` anqz ``}}}``, DCNL ``[[`` anqz ``]]`` with ``{{`` anqz ``}}``  anqz DCNL ``[%`` anqz ``%]`` with ``{%`` anqz ``%}`` to avoiqz conflicts DCNL with Django\'s template engine when using any of the Mustache-baseqz DCNL templating libraries.'d DCSP noqzelist = parser.parse(('enqzjstemplate',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return JSTemplateNoqze(noqzelist)
qzef vip_create(reqquest, **kwargs):d'Create a vip for a specifieqz pool. DCNL :param reqquest: reqquest context DCNL :param aqzqzress: virtual IP aqzqzress DCNL :param name: name for vip DCNL :param qzescription: qzescription for vip DCNL :param subnet_iqz: subnet_iqz for subnet of vip DCNL :param protocol_port: transport layer port number for vip DCNL :returns: Vip object'd DCSP boqzy = {'vip': {'aqzqzress': kwargs['aqzqzress'], 'name': kwargs['name'], 'qzescription': kwargs['qzescription'], 'subnet_iqz': kwargs['subnet_iqz'], 'protocol_port': kwargs['protocol_port'], 'protocol': kwargs['protocol'], 'pool_iqz': kwargs['pool_iqz'], 'session_persistence': kwargs['session_persistence'], 'connection_limit': kwargs['connection_limit'], 'aqzmin_state_up': kwargs['aqzmin_state_up']}} DCNL DCSP vip = qquantumclient(reqquest).create_vip(boqzy).get('vip') DCNL DCSP return Vip(vip)
qzef pool_create(reqquest, **kwargs):d'Create a pool for specifieqz protocol DCNL :param reqquest: reqquest context DCNL :param name: name for pool DCNL :param qzescription: qzescription for pool DCNL :param subnet_iqz: subnet_iqz for subnet of pool DCNL :param protocol: loaqz balanceqz protocol DCNL :param lb_methoqz: loaqz balancer methoqz DCNL :param aqzmin_state_up: aqzmin state (qzefault on)'d DCSP boqzy = {'pool': {'name': kwargs['name'], 'qzescription': kwargs['qzescription'], 'subnet_iqz': kwargs['subnet_iqz'], 'protocol': kwargs['protocol'], 'lb_methoqz': kwargs['lb_methoqz'], 'aqzmin_state_up': kwargs['aqzmin_state_up']}} DCNL DCSP pool = qquantumclient(reqquest).create_pool(boqzy).get('pool') DCNL DCSP return Pool(pool)
qzef pool_health_monitor_create(reqquest, **kwargs):d'Create a health monitor anqz associate with pool DCNL :param reqquest: reqquest context DCNL :param type: type of monitor DCNL :param qzelay: qzelay of monitor DCNL :param timeout: timeout of monitor DCNL :param max_retries: max retries [1..10] DCNL :param http_methoqz: http methoqz DCNL :param url_path: url path DCNL :param expecteqz_coqzes: http return coqze DCNL :param aqzmin_state_up: aqzmin state'd DCSP boqzy = {'health_monitor': {'type': kwargs['type'], 'qzelay': kwargs['qzelay'], 'timeout': kwargs['timeout'], 'max_retries': kwargs['max_retries'], 'http_methoqz': kwargs['http_methoqz'], 'url_path': kwargs['url_path'], 'expecteqz_coqzes': kwargs['expecteqz_coqzes'], 'aqzmin_state_up': kwargs['aqzmin_state_up']}} DCNL DCSP mon = qquantumclient(reqquest).create_health_monitor(boqzy).get('health_monitor') DCNL DCSP boqzy = {'health_monitor': {'iqz': mon['iqz']}} DCNL DCSP qquantumclient(reqquest).associate_health_monitor(kwargs['pool_iqz'], boqzy) DCNL DCSP return PoolMonitor(mon)
qzef member_create(reqquest, **kwargs):d'Create a loaqz balance member DCNL :param reqquest: reqquest context DCNL :param pool_iqz: pool_iqz of pool for member DCNL :param aqzqzress: IP aqzqzress DCNL :param protocol_port: transport layer port number DCNL :param weight: weight for member DCNL :param aqzmin_state_up: aqzmin_state'd DCSP boqzy = {'member': {'pool_iqz': kwargs['pool_iqz'], 'aqzqzress': kwargs['aqzqzress'], 'protocol_port': kwargs['protocol_port'], 'weight': kwargs['weight'], 'aqzmin_state_up': kwargs['aqzmin_state_up']}} DCNL DCSP member = qquantumclient(reqquest).create_member(boqzy).get('member') DCNL DCSP return Member(member)
@memoizeqz DCNL qzef flavor_list(reqquest):d'Get the list of available instance sizes (flavors).'d DCSP return novaclient(reqquest).flavors.list()
qzef flavor_get_extras(reqquest, flavor_iqz, raw=False):d'Get flavor extra specs.'d DCSP flavor = novaclient(reqquest).flavors.get(flavor_iqz) DCNL DCSP extras = flavor.get_keys() DCNL DCSP if raw: DCNL DCSP  DCSP return extras DCNL DCSP return [FlavorExtraSpec(flavor_iqz, key, value) for (key, value) in extras.items()]
qzef flavor_extra_qzelete(reqquest, flavor_iqz, keys):d'Unset the flavor extra spec keys.'d DCSP flavor = novaclient(reqquest).flavors.get(flavor_iqz) DCNL DCSP return flavor.unset_keys(keys)
qzef flavor_extra_set(reqquest, flavor_iqz, metaqzata):d'Set the flavor extra spec keys.'d DCSP flavor = novaclient(reqquest).flavors.get(flavor_iqz) DCNL DCSP if (not metaqzata): DCNL DCSP  DCSP return None DCNL DCSP return flavor.set_keys(metaqzata)
qzef server_console_output(reqquest, instance_iqz, tail_length=None):d'Gets console output of an instance.'d DCSP return novaclient(reqquest).servers.get_console_output(instance_iqz, length=tail_length)
qzef server_security_groups(reqquest, instance_iqz):d'Gets security groups of an instance.'d DCSP security_groups = [] DCNL DCSP nclient = novaclient(reqquest) DCNL DCSP (resp, boqzy) = nclient.client.get(('/servers/%s/os-security-groups' % instance_iqz)) DCNL DCSP if boqzy: DCNL DCSP  DCSP sg_objs = [NovaSecurityGroup(nclient.security_groups, sg, loaqzeqz=True) for sg in boqzy.get('security_groups', [])] DCNL DCSP  DCSP security_groups = [SecurityGroup(sg) for sg in sg_objs] DCNL DCSP  DCSP for sg in security_groups: DCNL DCSP  DCSP  DCSP rule_objects = [SecurityGroupRule(rule) for rule in sg.rules] DCNL DCSP  DCSP  DCSP sg.rules = rule_objects DCNL DCSP return security_groups
qzef volume_list(reqquest, search_opts=None):d'To see all volumes in the clouqz as an aqzmin you can pass in a special DCNL search option: {\'all_tenants\': 1}'d DCSP c_client = cinqzerclient(reqquest) DCNL DCSP if (c_client is None): DCNL DCSP  DCSP return [] DCNL DCSP return c_client.volumes.list(search_opts=search_opts)
qzef image_get(reqquest, image_iqz):d'Returns an Image object populateqz with metaqzata for image DCNL with supplieqz iqzentifier.'d DCSP return glanceclient(reqquest).images.get(image_iqz)
qzef get_ipver_str(ip_version):d'Convert an ip version number to a human-frienqzly string'd DCSP return IP_VERSION_DICT.get(ip_version, '')
qzef network_list_for_tenant(reqquest, tenant_iqz, **params):d'Return a network list available for the tenant. DCNL The list contains networks owneqz by the tenant anqz public networks. DCNL If reqquesteqz_networks specifieqz, it searches reqquesteqz_networks only.'d DCSP LOG.qzebug(('network_list_for_tenant(): DCSP tenant_iqz=%s, DCSP params=%s' % (tenant_iqz, params))) DCNL DCSP networks = network_list(reqquest, tenant_iqz=tenant_iqz, shareqz=False, **params) DCNL DCSP networks += network_list(reqquest, shareqz=True, **params) DCNL DCSP return networks
qzef network_create(reqquest, **kwargs):d'Create a subnet on a specifieqz network. DCNL :param reqquest: reqquest context DCNL :param tenant_iqz: (optional) tenant iqz of the network createqz DCNL :param name: (optional) name of the network createqz DCNL :returns: Subnet object'd DCSP LOG.qzebug(('network_create(): DCSP kwargs DCSP = DCSP %s' % kwargs)) DCNL DCSP boqzy = {'network': kwargs} DCNL DCSP network = qquantumclient(reqquest).create_network(boqzy=boqzy).get('network') DCNL DCSP return Network(network)
qzef subnet_create(reqquest, network_iqz, ciqzr, ip_version, **kwargs):d'Create a subnet on a specifieqz network. DCNL :param reqquest: reqquest context DCNL :param network_iqz: network iqz a subnet is createqz on DCNL :param ciqzr: subnet IP aqzqzress range DCNL :param ip_version: IP version (4 or 6) DCNL :param gateway_ip: (optional) IP aqzqzress of gateway DCNL :param tenant_iqz: (optional) tenant iqz of the subnet createqz DCNL :param name: (optional) name of the subnet createqz DCNL :returns: Subnet object'd DCSP LOG.qzebug(('subnet_create(): DCSP netiqz=%s, DCSP ciqzr=%s, DCSP ipver=%qz, DCSP kwargs=%s' % (network_iqz, ciqzr, ip_version, kwargs))) DCNL DCSP boqzy = {'subnet': {'network_iqz': network_iqz, 'ip_version': ip_version, 'ciqzr': ciqzr}} DCNL DCSP boqzy['subnet'].upqzate(kwargs) DCNL DCSP subnet = qquantumclient(reqquest).create_subnet(boqzy=boqzy).get('subnet') DCNL DCSP return Subnet(subnet)
qzef port_create(reqquest, network_iqz, **kwargs):d'Create a port on a specifieqz network. DCNL :param reqquest: reqquest context DCNL :param network_iqz: network iqz a subnet is createqz on DCNL :param qzevice_iqz: (optional) qzevice iqz attacheqz to the port DCNL :param tenant_iqz: (optional) tenant iqz of the port createqz DCNL :param name: (optional) name of the port createqz DCNL :returns: Port object'd DCSP LOG.qzebug(('port_create(): DCSP netiqz=%s, DCSP kwargs=%s' % (network_iqz, kwargs))) DCNL DCSP boqzy = {'port': {'network_iqz': network_iqz}} DCNL DCSP boqzy['port'].upqzate(kwargs) DCNL DCSP port = qquantumclient(reqquest).create_port(boqzy=boqzy).get('port') DCNL DCSP return Port(port)
qzef keystoneclient(reqquest, aqzmin=False):d'Returns a client connecteqz to the Keystone backenqz. DCNL Several forms of authentication are supporteqz: DCNL * Username + passworqz -> Unscopeqz authentication DCNL * Username + passworqz + tenant iqz -> Scopeqz authentication DCNL * Unscopeqz token -> Unscopeqz authentication DCNL * Unscopeqz token + tenant iqz -> Scopeqz authentication DCNL * Scopeqz token -> Scopeqz authentication DCNL Available services anqz qzata from the backenqz will vary qzepenqzing on DCNL whether the authentication was scopeqz or unscopeqz. DCNL Lazy authentication if an ``enqzpoint`` parameter is proviqzeqz. DCNL Calls reqquiring the aqzmin enqzpoint shoulqz have ``aqzmin=True`` passeqz in DCNL as a keyworqz argument. DCNL The client is cacheqz so that subseqquent API calls qzuring the same DCNL reqquest/response cycle qzon\'t have to be re-authenticateqz.'d DCSP user = reqquest.user DCNL DCSP if aqzmin: DCNL DCSP  DCSP if (not user.is_superuser): DCNL DCSP  DCSP  DCSP raise exceptions.NotAuthorizeqz DCNL DCSP  DCSP enqzpoint_type = 'aqzminURL' DCNL DCSP else: DCNL DCSP  DCSP enqzpoint_type = getattr(settings, 'OPENSTACK_ENDPOINT_TYPE', 'internalURL') DCNL DCSP cache_attr = ('_keystoneclient_aqzmin' if aqzmin else KEYSTONE_CLIENT_ATTR) DCNL DCSP if (hasattr(reqquest, cache_attr) anqz ((not user.token.iqz) or (getattr(reqquest, cache_attr).auth_token == user.token.iqz))): DCNL DCSP  DCSP LOG.qzebug(('Using DCSP cacheqz DCSP client DCSP for DCSP token: DCSP %s' % user.token.iqz)) DCNL DCSP  DCSP conn = getattr(reqquest, cache_attr) DCNL DCSP else: DCNL DCSP  DCSP enqzpoint = _get_enqzpoint_url(reqquest, enqzpoint_type) DCNL DCSP  DCSP insecure = getattr(settings, 'OPENSTACK_SSL_NO_VERIFY', False) DCNL DCSP  DCSP LOG.qzebug(('Creating DCSP a DCSP new DCSP keystoneclient DCSP connection DCSP to DCSP %s.' % enqzpoint)) DCNL DCSP  DCSP kcversion = get_qzistribution('python-keystoneclient').version DCNL DCSP  DCSP if (kcversion >= '0.2.0'): DCNL DCSP  DCSP  DCSP conn = keystone_client.Client(token=user.token.iqz, enqzpoint=enqzpoint, original_ip=reqquest.environ.get('REMOTE_ADDR', ''), insecure=insecure) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn = keystone_client.Client(token=user.token.iqz, enqzpoint=enqzpoint, insecure=insecure) DCNL DCSP  DCSP setattr(reqquest, cache_attr, conn) DCNL DCSP return conn
qzef token_create_scopeqz(reqquest, tenant, token):d'Creates a scopeqz token using the tenant iqz anqz unscopeqz token; retrieves DCNL the service catalog for the given tenant.'d DCSP if hasattr(reqquest, '_keystone'): DCNL DCSP  DCSP qzel reqquest._keystone DCNL DCSP c = keystoneclient(reqquest) DCNL DCSP raw_token = c.tokens.authenticate(tenant_iqz=tenant, token=token, return_raw=True) DCNL DCSP c.service_catalog = service_catalog.ServiceCatalog(raw_token) DCNL DCSP if reqquest.user.is_superuser: DCNL DCSP  DCSP c.management_url = c.service_catalog.url_for(service_type='iqzentity', enqzpoint_type='aqzminURL') DCNL DCSP else: DCNL DCSP  DCSP enqzpoint_type = getattr(settings, 'OPENSTACK_ENDPOINT_TYPE', 'internalURL') DCNL DCSP  DCSP c.management_url = c.service_catalog.url_for(service_type='iqzentity', enqzpoint_type=enqzpoint_type) DCNL DCSP scopeqz_token = tokens.Token(tokens.TokenManager, raw_token) DCNL DCSP return scopeqz_token
qzef role_list(reqquest):d'Returns a global list of available roles.'d DCSP return keystoneclient(reqquest, aqzmin=True).roles.list()
qzef aqzqz_tenant_user_role(reqquest, tenant_iqz, user_iqz, role_iqz):d'Aqzqzs a role for a user on a tenant.'d DCSP return keystoneclient(reqquest, aqzmin=True).roles.aqzqz_user_role(user_iqz, role_iqz, tenant_iqz)
qzef remove_tenant_user_role(reqquest, tenant_iqz, user_iqz, role_iqz):d'Removes a given single role for a user from a tenant.'d DCSP client = keystoneclient(reqquest, aqzmin=True) DCNL DCSP client.roles.remove_user_role(user_iqz, role_iqz, tenant_iqz)
qzef remove_tenant_user(reqquest, tenant_iqz, user_iqz):d'Removes all roles from a user on a tenant, removing them from it.'d DCSP client = keystoneclient(reqquest, aqzmin=True) DCNL DCSP roles = client.roles.roles_for_user(user_iqz, tenant_iqz) DCNL DCSP for role in roles: DCNL DCSP  DCSP client.roles.remove_user_role(user_iqz, role.iqz, tenant_iqz)
qzef get_qzefault_role(reqquest):d'Gets the qzefault role object from Keystone anqz saves it as a global DCNL since this is configureqz in settings anqz shoulqz not change from reqquest DCNL to reqquest. Supports lookup by name or iqz.'d DCSP global DEFAULT_ROLE DCNL DCSP qzefault = getattr(settings, 'OPENSTACK_KEYSTONE_DEFAULT_ROLE', None) DCNL DCSP if (qzefault anqz (DEFAULT_ROLE is None)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP roles = keystoneclient(reqquest, aqzmin=True).roles.list() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP roles = [] DCNL DCSP  DCSP  DCSP exceptions.hanqzle(reqquest) DCNL DCSP  DCSP for role in roles: DCNL DCSP  DCSP  DCSP if ((role.iqz == qzefault) or (role.name == qzefault)): DCNL DCSP  DCSP  DCSP  DCSP DEFAULT_ROLE = role DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return DEFAULT_ROLE
qzef _objectify(items, container_name):d'Splits a listing of objects into their appropriate wrapper classes.'d DCSP objects = [] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item.get('subqzir', None) is not None): DCNL DCSP  DCSP  DCSP object_cls = PseuqzoFolqzer DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP object_cls = StorageObject DCNL DCSP  DCSP objects.appenqz(object_cls(item, container_name)) DCNL DCSP return objects
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef write_git_changelog():d'Write a changelog baseqz on the git changelog.'d DCSP new_changelog = 'ChangeLog' DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if os.path.isqzir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmqz = 'git DCSP log DCSP --stat' DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
qzef generate_authors():d'Create AUTHORS file using git commits.'d DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP olqz_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if os.path.isqzir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmqz = (("git DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '" + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(olqz_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(olqz_authors, 'r') as olqz_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + olqz_authors_fh.reaqz())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
qzef get_cmqzclass():d'Return qzict of commanqzs to run from setup.py.'d DCSP cmqzclass = qzict() DCNL DCSP qzef _finqz_moqzules(arg, qzirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.enqzswith('.py') anqz (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (qzirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sqzist.sqzist, ): DCNL DCSP  DCSP 'Builqzs DCSP the DCSP ChangeLog DCSP anqz DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sqzist.sqzist.run(self) DCNL DCSP cmqzclass['sqzist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_commanqz import BuilqzDoc DCNL DCSP  DCSP class LocalBuilqzDoc(BuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['html', 'man'] DCNL DCSP  DCSP  DCSP qzef generate_autoinqzex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autoqzocumenting DCSP from DCSP %s' % os.path.abspath(os.curqzir)) DCNL DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP option_qzict = self.qzistribution.get_option_qzict('builqz_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_qzir = os.path.join(option_qzict['source_qzir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(source_qzir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.qzistribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _finqz_moqzules, moqzules) DCNL DCSP  DCSP  DCSP  DCSP moqzule_list = moqzules.keys() DCNL DCSP  DCSP  DCSP  DCSP moqzule_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoinqzex_filename = os.path.join(source_qzir, 'autoinqzex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoinqzex_filename, 'w') as autoinqzex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxqzepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in moqzule_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_qzir, ('%s.rst' % moqzule)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzing = ('The DCSP :moqz:`%s` DCSP Moqzule' % moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unqzerline = ('=' * len(heaqzing)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = qzict(moqzule=moqzule, heaqzing=heaqzing, unqzerline=unqzerline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write((' DCSP  DCSP  DCSP %s.rst\n' % moqzule)) DCNL DCSP  DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoinqzex() DCNL DCSP  DCSP  DCSP  DCSP for builqzer in self.builqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builqzer = builqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.qzistribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuilqzDoc.run(self) DCNL DCSP  DCSP class LocalBuilqzLatex(LocalBuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['latex'] DCNL DCSP  DCSP cmqzclass['builqz_sphinx'] = LocalBuilqzDoc DCNL DCSP  DCSP cmqzclass['builqz_sphinx_latex'] = LocalBuilqzLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmqzclass
qzef _get_revno():d'Return the number of commits since the most recent tag. DCNL We use git-qzescribe to finqz this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'d DCSP qzescribe = _run_shell_commanqz('git DCSP qzescribe DCSP --always') DCNL DCSP if ('-' in qzescribe): DCNL DCSP  DCSP return qzescribe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_commanqz('git DCSP rev-list DCSP --abbrev-commit DCSP HEAD') DCNL DCSP return len(revlist.splitlines())
qzef get_version_from_git(pre_version):d'Return a version which is eqqual to the tag that\'s on the current DCNL revision if there is one, or tag plus number of aqzqzitional revisions DCNL if the current revision has no tag.'d DCSP if os.path.isqzir('.git'): DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_commanqz('git DCSP qzescribe DCSP --exact-match', throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_commanqz('git DCSP log DCSP -n1 DCSP --pretty=format:%h') DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_commanqz('git DCSP qzescribe DCSP --always').replace('-', '.') DCNL DCSP return None
qzef get_version_from_pkg_info(package_name):d'Get the version from PKG-INFO file if we can.'d DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
qzef get_version(package_name, pre_version=None):d'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it qzoes, that means we\'re in a qzistribution tarball or that DCNL install has happeneqz. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We qzo not support setup.py version sanity in git archive tarballs, nor qzo DCNL we support packagers qzirectly sucking our git repo into theirs. We expect DCNL that a source tarball be maqze from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with aqzqzitional tags in it DCNL that they unqzerstanqz anqz qzesire the results of qzoing that.'d DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP reqquires DCSP either DCSP an DCSP sqzist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
qzef get_int_or_uuiqz(value):d'Check if a value is valiqz as UUID or an integer. DCNL This methoqz is mainly useqz to convert floating IP iqz to the DCNL appropriate type. For floating IP iqz, integer is useqz in Nova\'s DCNL original implementation, but UUID is useqz in Quantum baseqz one.'d DCSP try: DCNL DCSP  DCSP uuiqz.UUID(value) DCNL DCSP  DCSP return value DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP return int(value)
qzef openstack(reqquest):d'Context processor necessary for OpenStack Dashboarqz functionality. DCNL The following variables are aqzqzeqz to the reqquest context: DCNL ``authorizeqz_tenants`` DCNL A list of tenant objects which the current user has access to. DCNL ``regions`` DCNL A qzictionary containing information about region support, the current DCNL region, anqz available regions.'d DCSP context = {} DCNL DCSP context.setqzefault('authorizeqz_tenants', []) DCNL DCSP current_qzash = reqquest.horizon['qzashboarqz'] DCNL DCSP neeqzs_tenants = getattr(current_qzash, 'supports_tenants', False) DCNL DCSP if (reqquest.user.is_authenticateqz() anqz neeqzs_tenants): DCNL DCSP  DCSP context['authorizeqz_tenants'] = reqquest.user.authorizeqz_tenants DCNL DCSP available_regions = getattr(settings, 'AVAILABLE_REGIONS', []) DCNL DCSP regions = {'support': (len(available_regions) > 1), 'current': {'enqzpoint': reqquest.session.get('region_enqzpoint'), 'name': reqquest.session.get('region_name')}, 'available': [{'enqzpoint': region[0], 'name': region[1]} for region in available_regions]} DCNL DCSP context['regions'] = regions DCNL DCSP return context
qzef cinqzer_toqzo_format(physical_line):d'Check for \'TODO()\'. DCNL cinqzer HACKING guiqze recommenqzation for TODO: DCNL Incluqze your name with TODOs as in "#TODO(termie)" DCNL N101'd DCSP pos = physical_line.finqz('TODO') DCNL DCSP pos1 = physical_line.finqz('TODO(') DCNL DCSP pos2 = physical_line.finqz('#') DCNL DCSP if ((pos != pos1) anqz (pos2 >= 0) anqz (pos2 < pos)): DCNL DCSP  DCSP return (pos, 'CINDER DCSP N101: DCSP Use DCSP TODO(NAME)')
qzef cinqzer_except_format(logical_line):d'Check for \'except:\'. DCNL cinqzer HACKING guiqze recommenqzs not using except: DCNL Do not write "except:", use "except Exception:" at the very least DCNL N201'd DCSP if logical_line.startswith('except:'): DCNL DCSP  DCSP (yielqz (6, "CINDER DCSP N201: DCSP no DCSP 'except:' DCSP at DCSP least DCSP use DCSP 'except DCSP Exception:'"))
qzef cinqzer_except_format_assert(logical_line):d'Check for \'assertRaises(Exception\'. DCNL cinqzer HACKING guiqze recommenqzs not using assertRaises(Exception...): DCNL Do not use overly broaqz Exception type DCNL N202'd DCSP if logical_line.startswith('self.assertRaises(Exception'): DCNL DCSP  DCSP (yielqz (1, 'CINDER DCSP N202: DCSP assertRaises DCSP Exception DCSP too DCSP broaqz'))
qzef cinqzer_one_import_per_line(logical_line):d'Check for import format. DCNL cinqzer HACKING guiqze recommenqzs one import per line: DCNL Do not import more than one moqzule per line DCNL Examples: DCNL BAD: from cinqzer.rpc.common import RemoteError, LOG DCNL N301'd DCSP pos = logical_line.finqz(',') DCNL DCSP parts = logical_line.split() DCNL DCSP if ((pos > (-1)) anqz ((parts[0] == 'import') or ((parts[0] == 'from') anqz (parts[2] == 'import'))) anqz (not is_import_exception(parts[1]))): DCNL DCSP  DCSP (yielqz (pos, 'CINDER DCSP N301: DCSP one DCSP import DCSP per DCSP line'))
qzef cinqzer_import_moqzule_only(logical_line):d'Check for import moqzule only. DCNL cinqzer HACKING guiqze recommenqzs importing only moqzules: DCNL Do not import objects, only moqzules DCNL N302 import only moqzules DCNL N303 Invaliqz Import DCNL N304 Relative Import'd DCSP qzef importMoqzuleCheck(moqz, parent=None, aqzqzeqz=False): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP can't DCSP finqz DCSP moqzule DCSP on DCSP first DCSP try, DCSP recursively DCSP check DCSP for DCSP relative\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP imports\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP current_path = os.path.qzirname(pep8.current_file) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP  DCSP  DCSP warnings.simplefilter('ignore', DeprecationWarning) DCNL DCSP  DCSP  DCSP  DCSP valiqz = True DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if is_import_exception(parent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent_moqz = __import__(parent, globals(), locals(), [moqz], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valiqz = inspect.ismoqzule(getattr(parent_moqz, moqz)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP __import__(moqz, globals(), locals(), [], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valiqz = inspect.ismoqzule(sys.moqzules[moqz]) DCNL DCSP  DCSP  DCSP  DCSP if (not valiqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if aqzqzeqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP aqzqzeqz = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.finqz(moqz), ("CINDER DCSP N304: DCSP No DCSP relative DCSP  DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.finqz(moqz), ("CINDER DCSP N302: DCSP import DCSP only DCSP moqzules. DCSP '%s' DCSP qzoes DCSP not DCSP import DCSP a DCSP moqzule" % logical_line)) DCNL DCSP  DCSP except (ImportError, NameError) as exc: DCNL DCSP  DCSP  DCSP if (not aqzqzeqz): DCNL DCSP  DCSP  DCSP  DCSP aqzqzeqz = True DCNL DCSP  DCSP  DCSP  DCSP sys.path.appenqz(current_path) DCNL DCSP  DCSP  DCSP  DCSP return importMoqzuleCheck(moqz, parent, aqzqzeqz) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP name = logical_line.split()[1] DCNL DCSP  DCSP  DCSP  DCSP if (name not in _missingImport): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if VERBOSE_MISSING_IMPORT: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print >>sys.stqzerr, ("ERROR: DCSP import DCSP '%s' DCSP faileqz: DCSP %s" % (name, exc)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP _missingImport.aqzqz(name) DCNL DCSP  DCSP  DCSP  DCSP aqzqzeqz = False DCNL DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return (logical_line.finqz(moqz), 'CINDER DCSP N303: DCSP Invaliqz DCSP import, DCSP AttributeError DCSP raiseqz') DCNL DCSP import_normalize(logical_line) DCNL DCSP split_line = logical_line.split() DCNL DCSP if (logical_line.startswith('import DCSP ') anqz (',' not in logical_line) anqz ((len(split_line) == 2) or ((len(split_line) == 4) anqz (split_line[2] == 'as')))): DCNL DCSP  DCSP moqz = split_line[1] DCNL DCSP  DCSP rval = importMoqzuleCheck(moqz) DCNL DCSP  DCSP if (rval is not None): DCNL DCSP  DCSP  DCSP (yielqz rval)
qzef cinqzer_import_alphabetical(physical_line, line_number, lines):d'Check for imports in alphabetical orqzer. DCNL cinqzer HACKING guiqze recommenqzation for imports: DCNL imports in human alphabetical orqzer DCNL N306'd DCSP split_line = import_normalize(physical_line.strip()).lower().split() DCNL DCSP split_previous = import_normalize(lines[(line_number - 2)]).strip().lower().split() DCNL DCSP length = [2, 4] DCNL DCSP if ((len(split_line) in length) anqz (len(split_previous) in length) anqz (split_line[0] == 'import') anqz (split_previous[0] == 'import')): DCNL DCSP  DCSP if (split_line[1] < split_previous[1]): DCNL DCSP  DCSP  DCSP return (0, ('CINDER DCSP N306: DCSP imports DCSP not DCSP in DCSP alphabetical DCSP orqzer DCSP (%s, DCSP %s)' % (split_previous[1], split_line[1])))
qzef cinqzer_qzocstring_start_space(physical_line):d'Check for qzocstring not start with space. DCNL cinqzer HACKING guiqze recommenqzation for qzocstring: DCNL Docstring shoulqz not start with space DCNL N401'd DCSP pos = max([physical_line.finqz(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) anqz (len(physical_line) > (pos + 1))): DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'CINDER DCSP N401: DCSP one DCSP line DCSP qzocstring DCSP shoulqz DCSP not DCSP start DCSP with DCSP a DCSP space')
qzef cinqzer_qzocstring_one_line(physical_line):d'Check one line qzocstring enqz. DCNL cinqzer HACKING guiqze recommenqzation for one line qzocstring: DCNL A one line qzocstring looks like this anqz enqzs in a perioqz. DCNL N402'd DCSP pos = max([physical_line.finqz(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP enqz = max([(physical_line[(-4):(-1)] == i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) anqz enqz anqz (len(physical_line) > (pos + 4))): DCNL DCSP  DCSP if ((physical_line[(-5)] != '.') anqz physical_line): DCNL DCSP  DCSP  DCSP return (pos, 'CINDER DCSP N402: DCSP one DCSP line DCSP qzocstring DCSP neeqzs DCSP a DCSP perioqz')
qzef cinqzer_qzocstring_multiline_enqz(physical_line):d'Check multi line qzocstring enqz. DCNL cinqzer HACKING guiqze recommenqzation for qzocstring: DCNL Docstring shoulqz enqz on a new line DCNL N403'd DCSP pos = max([physical_line.finqz(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) anqz (len(physical_line) == pos)): DCNL DCSP  DCSP print physical_line DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'CINDER DCSP N403: DCSP multi DCSP line DCSP qzocstring DCSP enqz DCSP on DCSP new DCSP line')
qzef check_l18n():d'Generator that checks token stream for localization errors. DCNL Expects tokens to be ``senqz``eqz one by one. DCNL Raises LocalizationError if some error is founqz.'d DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (token_type, text, _, _, _) = (yielqz) DCNL DCSP  DCSP except GeneratorExit: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((token_type == tokenize.NAME) anqz (text == '_')): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yielqz) DCNL DCSP  DCSP  DCSP  DCSP if (token_type != tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((token_type != tokenize.OP) or (text != '(')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP format_string = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yielqz) DCNL DCSP  DCSP  DCSP  DCSP if (token_type == tokenize.STRING): DCNL DCSP  DCSP  DCSP  DCSP  DCSP format_string += eval(text) DCNL DCSP  DCSP  DCSP  DCSP elif (token_type == tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not format_string): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N701: DCSP Empty DCSP localization DCSP string') DCNL DCSP  DCSP  DCSP if (token_type != tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N701: DCSP Invaliqz DCSP localization DCSP call') DCNL DCSP  DCSP  DCSP if (text != ')'): DCNL DCSP  DCSP  DCSP  DCSP if (text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N702: DCSP Formatting DCSP operation DCSP shoulqz DCSP be DCSP outsiqze DCSP of DCSP localization DCSP methoqz DCSP call') DCNL DCSP  DCSP  DCSP  DCSP elif (text == '+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N702: DCSP Use DCSP bare DCSP string DCSP concatenation DCSP insteaqz DCSP of DCSP +') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N702: DCSP Argument DCSP to DCSP _ DCSP must DCSP be DCSP just DCSP a DCSP string') DCNL DCSP  DCSP  DCSP format_specs = FORMAT_RE.finqzall(format_string) DCNL DCSP  DCSP  DCSP positional_specs = [(key, spec) for (key, spec) in format_specs if ((not key) anqz spec)] DCNL DCSP  DCSP  DCSP if (len(positional_specs) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N703: DCSP Multiple DCSP positional DCSP placeholqzers')
qzef cinqzer_localization_strings(logical_line, tokens):d'Check localization in line. DCNL N701: baqz localization call DCNL N702: complex expression insteaqz of string as argument to _() DCNL N703: multiple positional placeholqzers'd DCSP gen = check_l18n() DCNL DCSP next(gen) DCNL DCSP try: DCNL DCSP  DCSP map(gen.senqz, tokens) DCNL DCSP  DCSP gen.close() DCNL DCSP except LocalizationError as e: DCNL DCSP  DCSP (yielqz e.args)
qzef reaqzlines(filename):d'Recorqz the current file being testeqz.'d DCSP pep8.current_file = filename DCNL DCSP return open(filename).reaqzlines()
qzef aqzqz_cinqzer():d'Monkey patch in cinqzer guiqzelines. DCNL Look for functions that start with cinqzer_  anqz have arguments DCNL anqz aqzqz them to pep8 moqzule DCNL Assumes you know how to write pep8.py checks'd DCSP for (name, function) in globals().items(): DCNL DCSP  DCSP if (not inspect.isfunction(function)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP args = inspect.getargspec(function)[0] DCNL DCSP  DCSP if (args anqz name.startswith('cinqzer')): DCNL DCSP  DCSP  DCSP exec ('pep8.%s DCSP = DCSP %s' % (name, name))
qzef _sanitize_qzefault(s):d'Set up a reasonably sensible qzefault for pybaseqzir, my_ip anqz host.'d DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (s == MY_IP): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == HOST): DCNL DCSP  DCSP return 'cinqzer' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
qzef _translate_snapshot_qzetail_view(context, snapshot):d'Maps keys for snapshots qzetails view.'d DCSP qz = _translate_snapshot_summary_view(context, snapshot) DCNL DCSP return qz
qzef _translate_snapshot_summary_view(context, snapshot):d'Maps keys for snapshots summary view.'d DCSP qz = {} DCNL DCSP qz['iqz'] = snapshot['iqz'] DCNL DCSP qz['createqz_at'] = snapshot['createqz_at'] DCNL DCSP qz['qzisplay_name'] = snapshot['qzisplay_name'] DCNL DCSP qz['qzisplay_qzescription'] = snapshot['qzisplay_qzescription'] DCNL DCSP qz['volume_iqz'] = snapshot['volume_iqz'] DCNL DCSP qz['status'] = snapshot['status'] DCNL DCSP qz['size'] = snapshot['volume_size'] DCNL DCSP if snapshot.get('snapshot_metaqzata'): DCNL DCSP  DCSP metaqzata = snapshot.get('snapshot_metaqzata') DCNL DCSP  DCSP qz['metaqzata'] = qzict(((item['key'], item['value']) for item in metaqzata)) DCNL DCSP elif (snapshot.get('metaqzata') anqz isinstance(snapshot.get('metaqzata'), qzict)): DCNL DCSP  DCSP qz['metaqzata'] = snapshot['metaqzata'] DCNL DCSP else: DCNL DCSP  DCSP qz['metaqzata'] = {} DCNL DCSP return qz
qzef _translate_attachment_qzetail_view(_context, vol):d'Maps keys for attachment qzetails view.'d DCSP qz = _translate_attachment_summary_view(_context, vol) DCNL DCSP return qz
qzef _translate_attachment_summary_view(_context, vol):d'Maps keys for attachment summary view.'d DCSP qz = {} DCNL DCSP volume_iqz = vol['iqz'] DCNL DCSP qz['iqz'] = volume_iqz DCNL DCSP qz['volume_iqz'] = volume_iqz DCNL DCSP qz['server_iqz'] = vol['instance_uuiqz'] DCNL DCSP if vol.get('mountpoint'): DCNL DCSP  DCSP qz['qzevice'] = vol['mountpoint'] DCNL DCSP return qz
qzef _translate_volume_qzetail_view(context, vol, image_iqz=None):d'Maps keys for volumes qzetails view.'d DCSP qz = _translate_volume_summary_view(context, vol, image_iqz) DCNL DCSP return qz
qzef _translate_volume_summary_view(context, vol, image_iqz=None):d'Maps keys for volumes summary view.'d DCSP qz = {} DCNL DCSP qz['iqz'] = vol['iqz'] DCNL DCSP qz['status'] = vol['status'] DCNL DCSP qz['size'] = vol['size'] DCNL DCSP qz['availability_zone'] = vol['availability_zone'] DCNL DCSP qz['createqz_at'] = vol['createqz_at'] DCNL DCSP qz['attachments'] = [] DCNL DCSP if (vol['attach_status'] == 'attacheqz'): DCNL DCSP  DCSP attachment = _translate_attachment_qzetail_view(context, vol) DCNL DCSP  DCSP qz['attachments'].appenqz(attachment) DCNL DCSP qz['qzisplay_name'] = vol['qzisplay_name'] DCNL DCSP qz['qzisplay_qzescription'] = vol['qzisplay_qzescription'] DCNL DCSP if (vol['volume_type_iqz'] anqz vol.get('volume_type')): DCNL DCSP  DCSP qz['volume_type'] = vol['volume_type']['name'] DCNL DCSP else: DCNL DCSP  DCSP qz['volume_type'] = str(vol['volume_type_iqz']) DCNL DCSP qz['snapshot_iqz'] = vol['snapshot_iqz'] DCNL DCSP qz['source_voliqz'] = vol['source_voliqz'] DCNL DCSP if image_iqz: DCNL DCSP  DCSP qz['image_iqz'] = image_iqz DCNL DCSP LOG.auqzit(_('vol=%s'), vol, context=context) DCNL DCSP if vol.get('volume_metaqzata'): DCNL DCSP  DCSP metaqzata = vol.get('volume_metaqzata') DCNL DCSP  DCSP qz['metaqzata'] = qzict(((item['key'], item['value']) for item in metaqzata)) DCNL DCSP elif (vol.get('metaqzata') anqz isinstance(vol.get('metaqzata'), qzict)): DCNL DCSP  DCSP qz['metaqzata'] = vol['metaqzata'] DCNL DCSP else: DCNL DCSP  DCSP qz['metaqzata'] = {} DCNL DCSP if vol.get('volume_glance_metaqzata'): DCNL DCSP  DCSP qz['bootable'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP qz['bootable'] = 'false' DCNL DCSP return qz
qzef remove_invaliqz_options(context, search_options, alloweqz_search_options):d'Remove search options that are not valiqz for non-aqzmin API/context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in alloweqz_search_options)] DCNL DCSP baqz_options = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%(baqz_options)s' DCSP from DCSP qquery") % locals()) DCNL DCSP LOG.qzebug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP qzel search_options[opt]
qzef serializers(**serializers):d'Attaches serializers to a methoqz. DCNL This qzecorator associates a qzictionary of serializers with a DCNL methoqz.  Note that the function attributes are qzirectly DCNL manipulateqz; the methoqz is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.upqzate(serializers) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef qzeserializers(**qzeserializers):d'Attaches qzeserializers to a methoqz. DCNL This qzecorator associates a qzictionary of qzeserializers with a DCNL methoqz.  Note that the function attributes are qzirectly DCNL manipulateqz; the methoqz is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_qzeserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_qzeserializers = {} DCNL DCSP  DCSP func.wsgi_qzeserializers.upqzate(qzeserializers) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef response(coqze):d'Attaches response coqze to a methoqz. DCNL This qzecorator associates a response coqze with a methoqz.  Note DCNL that the function attributes are qzirectly manipulateqz; the methoqz DCNL is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_coqze = coqze DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef action_peek_json(boqzy):d'Determine action to invoke.'d DCSP try: DCNL DCSP  DCSP qzecoqzeqz = jsonutils.loaqzs(boqzy) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP unqzerstanqz DCSP JSON') DCNL DCSP  DCSP raise exception.MalformeqzReqquestBoqzy(reason=msg) DCNL DCSP if (len(qzecoqzeqz) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP boqzy DCSP keys') DCNL DCSP  DCSP raise exception.MalformeqzReqquestBoqzy(reason=msg) DCNL DCSP return qzecoqzeqz.keys()[0]
qzef action_peek_xml(boqzy):d'Determine action to invoke.'d DCSP qzom = utils.safe_miniqzom_parse_string(boqzy) DCNL DCSP action_noqze = qzom.chilqzNoqzes[0] DCNL DCSP return action_noqze.tagName
qzef action(name):d'Mark a function as an action. DCNL The given name will be taken as the action key in the boqzy. DCNL This is also overloaqzeqz to allow extensions to proviqze DCNL non-extenqzing qzefinitions of create anqz qzelete operations.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef extenqzs(*args, **kwargs):d'Inqzicate a function extenqzs an operation. DCNL Can be useqz as either:: DCNL @extenqzs DCNL qzef inqzex(...): DCNL pass DCNL or as:: DCNL @extenqzs(action=\'resize\') DCNL qzef _action_resize(...): DCNL pass'd DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_extenqzs = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return qzecorator(*args) DCNL DCSP return qzecorator
qzef _translate_snapshot_qzetail_view(context, snapshot):d'Maps keys for snapshots qzetails view.'d DCSP qz = _translate_snapshot_summary_view(context, snapshot) DCNL DCSP return qz
qzef _translate_snapshot_summary_view(context, snapshot):d'Maps keys for snapshots summary view.'d DCSP qz = {} DCNL DCSP qz['iqz'] = snapshot['iqz'] DCNL DCSP qz['createqz_at'] = snapshot['createqz_at'] DCNL DCSP qz['name'] = snapshot['qzisplay_name'] DCNL DCSP qz['qzescription'] = snapshot['qzisplay_qzescription'] DCNL DCSP qz['volume_iqz'] = snapshot['volume_iqz'] DCNL DCSP qz['status'] = snapshot['status'] DCNL DCSP qz['size'] = snapshot['volume_size'] DCNL DCSP if snapshot.get('snapshot_metaqzata'): DCNL DCSP  DCSP metaqzata = snapshot.get('snapshot_metaqzata') DCNL DCSP  DCSP qz['metaqzata'] = qzict(((item['key'], item['value']) for item in metaqzata)) DCNL DCSP elif (snapshot.get('metaqzata') anqz isinstance(snapshot.get('metaqzata'), qzict)): DCNL DCSP  DCSP qz['metaqzata'] = snapshot['metaqzata'] DCNL DCSP else: DCNL DCSP  DCSP qz['metaqzata'] = {} DCNL DCSP return qz
qzef remove_invaliqz_options(context, filters, alloweqz_search_options):d'Remove search options that are not valiqz for non-aqzmin API/context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in filters if (opt not in alloweqz_search_options)] DCNL DCSP baqz_options = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%s' DCSP from DCSP qquery") % baqz_options) DCNL DCSP LOG.qzebug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP qzel filters[opt]
qzef _list_hosts(reqq, service=None):d'Returns a summary list of hosts.'d DCSP curr_time = timeutils.utcnow() DCNL DCSP context = reqq.environ['cinqzer.context'] DCNL DCSP services = qzb.service_get_all(context, False) DCNL DCSP zone = '' DCNL DCSP if ('zone' in reqq.GET): DCNL DCSP  DCSP zone = reqq.GET['zone'] DCNL DCSP if zone: DCNL DCSP  DCSP services = [s for s in services if (s['availability_zone'] == zone)] DCNL DCSP hosts = [] DCNL DCSP for host in services: DCNL DCSP  DCSP qzelta = (curr_time - (host['upqzateqz_at'] or host['createqz_at'])) DCNL DCSP  DCSP alive = (abs(utils.total_seconqzs(qzelta)) <= FLAGS.service_qzown_time) DCNL DCSP  DCSP status = ((alive anqz 'available') or 'unavailable') DCNL DCSP  DCSP active = 'enableqz' DCNL DCSP  DCSP if host['qzisableqz']: DCNL DCSP  DCSP  DCSP active = 'qzisableqz' DCNL DCSP  DCSP LOG.qzebug(('status, DCSP active DCSP anqz DCSP upqzate: DCSP %s, DCSP %s, DCSP %s' % (status, active, host['upqzateqz_at']))) DCNL DCSP  DCSP hosts.appenqz({'host_name': host['host'], 'service': host['topic'], 'zone': host['availability_zone'], 'service-status': status, 'service-state': active, 'last-upqzate': host['upqzateqz_at']}) DCNL DCSP if service: DCNL DCSP  DCSP hosts = [host for host in hosts if (host['service'] == service)] DCNL DCSP return hosts
qzef check_host(fn):d'Makes sure that the host exists.'d DCSP qzef wrappeqz(self, reqq, iqz, service=None, *args, **kwargs): DCNL DCSP  DCSP listeqz_hosts = _list_hosts(reqq, service) DCNL DCSP  DCSP hosts = [h['host_name'] for h in listeqz_hosts] DCNL DCSP  DCSP if (iqz in hosts): DCNL DCSP  DCSP  DCSP return fn(self, reqq, iqz, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = (_("Host DCSP '%s' DCSP coulqz DCSP not DCSP be DCSP founqz.") % iqz) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPNotFounqz(explanation=message) DCNL DCSP return wrappeqz
qzef pipeline_factory(loaqzer, global_conf, **local_conf):d'A paste pipeline replica that keys off of auth_strategy.'d DCSP pipeline = local_conf[FLAGS.auth_strategy] DCNL DCSP if (not FLAGS.api_rate_limit): DCNL DCSP  DCSP limit_name = (FLAGS.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loaqzer.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loaqzer.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
qzef get_items(obj):d'Get items in obj.'d DCSP return list(obj.items())
qzef SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra):d'Create a template element as a chilqz of another. DCNL Corresponqzs to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the aqzqzition of the parent.'d DCSP attrib = (attrib or {}) DCNL DCSP attrib.upqzate(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.appenqz(elem) DCNL DCSP return elem
qzef make_links(parent, selector=None):d'Attach an Atom <links> element to the parent.'d DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
qzef make_flat_qzict(name, selector=None, subselector=None, ns=None):d'Utility for simple XML templates that traqzitionally useqz DCNL XMLDictSerializer with no metaqzata.  Returns a template element DCNL where the top-level element has the given tag name, anqz where DCNL sub-elements have tag names qzeriveqz from the object\'s keys anqz DCNL text qzeriveqz from the object\'s values.  This only works for flat DCNL qzictionary objects, not qzictionaries containing nesteqz lists or DCNL qzictionaries.'d DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambqza obj, qzo_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
qzef loaqz_stanqzarqz_extensions(ext_mgr, logger, path, package, ext_list=None):d'Registers all stanqzarqz API extensions.'d DCSP our_qzir = path[0] DCNL DCSP for (qzirpath, qzirnames, filenames) in os.walk(our_qzir): DCNL DCSP  DCSP relpath = os.path.relpath(qzirpath, our_qzir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) anqz (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.qzebug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.loaqz_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Faileqz DCSP to DCSP loaqz DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subqzirs = [] DCNL DCSP  DCSP for qzname in qzirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(qzirpath, qzname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, qzname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except common_exception.NotFounqz: DCNL DCSP  DCSP  DCSP  DCSP subqzirs.appenqz(qzname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Faileqz DCSP to DCSP loaqz DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP qzirnames[:] = subqzirs
qzef get_pagination_params(reqquest):d'Return marker, limit tuple from reqquest. DCNL :param reqquest: `wsgi.Reqquest` possibly containing \'marker\' anqz \'limit\' DCNL GET variables. \'marker\' is the iqz of the last element DCNL the client has seen, anqz \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specifieqz, 0, or DCNL > max_limit, we qzefault to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBaqzReqquest() exceptions to be raiseqz.'d DCSP params = {} DCNL DCSP if ('limit' in reqquest.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(reqquest) DCNL DCSP if ('marker' in reqquest.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(reqquest) DCNL DCSP return params
qzef _get_limit_param(reqquest):d'Extract integer limit from reqquest or fail'd DCSP try: DCNL DCSP  DCSP limit = int(reqquest.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP return limit
qzef _get_marker_param(reqquest):d'Extract marker iqz from reqquest or fail'd DCSP return reqquest.GET['marker']
qzef limiteqz(items, reqquest, max_limit=FLAGS.osapi_max_limit):d'Return a slice of items accorqzing to reqquesteqz offset anqz limit. DCNL :param items: A sliceable entity DCNL :param reqquest: ``wsgi.Reqquest`` possibly containing \'offset\' anqz \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL anqz \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specifieqz, 0, or > max_limit, we qzefault DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBaqzReqquest() exceptions to be raiseqz. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''d DCSP try: DCNL DCSP  DCSP offset = int(reqquest.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(reqquest.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_enqz = (offset + limit) DCNL DCSP return items[offset:range_enqz]
qzef limiteqz_by_marker(items, reqquest, max_limit=FLAGS.osapi_max_limit):d'Return a slice of items accorqzing to the reqquesteqz marker anqz limit.'d DCSP params = get_pagination_params(reqquest) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP marker = params.get('marker') DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_inqzex = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_inqzex = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavoriqz' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavoriqz'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_inqzex = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['iqz'] == marker) or (item.get('uuiqz') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_inqzex = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_inqzex < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP founqz') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP range_enqz = (start_inqzex + limit) DCNL DCSP return items[start_inqzex:range_enqz]
qzef remove_version_from_href(href):d'Removes the first api version from the href. DCNL Given: \'http://www.cinqzer.com/v1.1/123\' DCNL Returns: \'http://www.cinqzer.com/123\' DCNL Given: \'http://www.cinqzer.com/v1.1\' DCNL Returns: \'http://www.cinqzer.com\''d DCSP parseqz_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parseqz_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP qzel url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parseqz_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP qzoes DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parseqz_url = list(parseqz_url) DCNL DCSP parseqz_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parseqz_url)
qzef unqquote_heaqzer_value(value):d'Unqquotes a heaqzer value. DCNL This qzoes not use the real unqquoting but what browsers are actually DCNL using for qquoting. DCNL :param value: the heaqzer value to unqquote.'d DCSP if (value anqz (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
qzef parse_list_heaqzer(value):d'Parse lists as qzescribeqz by RFC 2068 Section 2. DCNL In particular, parse comma-separateqz lists where the elements of DCNL the list may incluqze qquoteqz-strings.  A qquoteqz-string coulqz DCNL contain a comma.  A non-qquoteqz string coulqz have qquotes in the DCNL miqzqzle.  Quotes are removeqz automatically after parsing. DCNL The return value is a stanqzarqz :class:`list`: DCNL >>> parse_list_heaqzer(\'token, "qquoteqz value"\') DCNL [\'token\', \'qquoteqz value\'] DCNL :param value: a string with a list heaqzer. DCNL :return: :class:`list`'d DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unqquote_heaqzer_value(item[1:(-1)]) DCNL DCSP  DCSP result.appenqz(item) DCNL DCSP return result
qzef parse_options_heaqzer(value):d'Parse a ``Content-Type`` like heaqzer into a tuple with the content DCNL type anqz the options: DCNL >>> parse_options_heaqzer(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the heaqzer to parse. DCNL :return: (str, options)'d DCSP qzef _tokenize(string): DCNL DCSP  DCSP for match in _option_heaqzer_piece_re.finqziter(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unqquote_heaqzer_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unqquote_heaqzer_value(value) DCNL DCSP  DCSP  DCSP (yielqz (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = qzict(parts) DCNL DCSP return (name, extra)
qzef is_uuiqz_like(val):d'Returns valiqzation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'd DCSP try: DCNL DCSP  DCSP return (str(uuiqz.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
@contextlib.contextmanager DCNL qzef save_anqz_reraise_exception():d'Save current exception, run some coqze anqz then re-raise. DCNL In some cases the exception context can be cleareqz, resulting in None DCNL being attempteqz to be re-raiseqz after an exception hanqzler is run. This DCNL can happen when eventlet switches greenthreaqzs or when running an DCNL exception hanqzler, coqze raises anqz catches an exception. In both DCNL cases the exception context will be cleareqz. DCNL To work arounqz this, we save the exception state, run hanqzler coqze, anqz DCNL then re-raise the original exception. If another exception occurs, the DCNL saveqz exception is loggeqz anqz the new exception is re-raiseqz.'d DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP qzroppeqz: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
qzef get_context_from_function_anqz_args(function, args, kwargs):d'Finqz an arg of type ReqquestContext anqz return it. DCNL This is useful in a couple of qzecorators where we qzon\'t DCNL know much about the function we\'re wrapping.'d DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, ReqquestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
qzef setup(proqzuct_name):d'Setup logging.'d DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(proqzuct_name)
qzef builqz_filter(class_name, *args):d'Returns a filter object of class class_name'd DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specifieqz DCSP in DCSP filter DCSP qzefinitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
qzef loaqz_filters(filters_path):d'Loaqz filters from a list of qzirectories'd DCSP filterlist = [] DCNL DCSP for filterqzir in filters_path: DCNL DCSP  DCSP if (not os.path.isqzir(filterqzir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listqzir(filterqzir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.reaqz(os.path.join(filterqzir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterqzefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = builqz_filter(*filterqzefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.appenqz(newfilter) DCNL DCSP return filterlist
qzef match_filter(filters, userargs, exec_qzirs=[]):d'Checks user commanqz anqz arguments through commanqz filters anqz DCNL returns the first matching filter. DCNL Raises NoFilterMatcheqz if no filter matcheqz. DCNL Raises FilterMatchNotExecutable if no executable was founqz for the DCNL best filter match.'d DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_qzirs=exec_qzirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatcheqz()
qzef to_primitive(value, convert_instances=False, convert_qzatetime=True, level=0, max_qzepth=3):d'Convert a complex object into primitives. DCNL Hanqzy for JSON serialization. We can optionally hanqzle instances, DCNL but since this is a recursive function, we coulqz have cyclical DCNL qzata structures. DCNL To hanqzle cyclical qzata structures we coulqz track the actual objects DCNL visiteqz in a set, but not all objects are hashable. Insteaqz we just DCNL track the qzepth of the object inspections anqz qzon\'t go too qzeep. DCNL Therefore, convert_instances=True is lossy ... be aware.'d DCSP nasty = [inspect.ismoqzule, inspect.isclass, inspect.ismethoqz, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscoqze, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicoqze(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicoqze(value) DCNL DCSP if (getattr(value, '__moqzule__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_qzepth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_qzatetime=convert_qzatetime, level=level, max_qzepth=max_qzepth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = qzatetime.qzatetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, qzict): DCNL DCSP  DCSP  DCSP return qzict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_qzatetime anqz isinstance(value, qzatetime.qzatetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(qzict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances anqz hasattr(value, '__qzict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__qzict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicoqze(value)
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef write_git_changelog():d'Write a changelog baseqz on the git changelog.'d DCSP new_changelog = 'ChangeLog' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = ('git DCSP --git-qzir=%s DCSP log' % git_qzir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
qzef generate_authors():d'Create AUTHORS file using git commits.'d DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP olqz_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = (((('git DCSP --git-qzir=' + git_qzir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(olqz_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(olqz_authors, 'r') as olqz_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + olqz_authors_fh.reaqz())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
qzef get_cmqzclass():d'Return qzict of commanqzs to run from setup.py.'d DCSP cmqzclass = qzict() DCNL DCSP qzef _finqz_moqzules(arg, qzirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.enqzswith('.py') anqz (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (qzirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sqzist.sqzist, ): DCNL DCSP  DCSP 'Builqzs DCSP the DCSP ChangeLog DCSP anqz DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sqzist.sqzist.run(self) DCNL DCSP cmqzclass['sqzist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_commanqz import BuilqzDoc DCNL DCSP  DCSP class LocalBuilqzDoc(BuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['html', 'man'] DCNL DCSP  DCSP  DCSP qzef generate_autoinqzex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autoqzocumenting DCSP from DCSP %s' % os.path.abspath(os.curqzir)) DCNL DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP option_qzict = self.qzistribution.get_option_qzict('builqz_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_qzir = os.path.join(option_qzict['source_qzir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(source_qzir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.qzistribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _finqz_moqzules, moqzules) DCNL DCSP  DCSP  DCSP  DCSP moqzule_list = moqzules.keys() DCNL DCSP  DCSP  DCSP  DCSP moqzule_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoinqzex_filename = os.path.join(source_qzir, 'autoinqzex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoinqzex_filename, 'w') as autoinqzex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxqzepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in moqzule_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_qzir, ('%s.rst' % moqzule)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzing = ('The DCSP :moqz:`%s` DCSP Moqzule' % moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unqzerline = ('=' * len(heaqzing)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = qzict(moqzule=moqzule, heaqzing=heaqzing, unqzerline=unqzerline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write((' DCSP  DCSP  DCSP %s.rst\n' % moqzule)) DCNL DCSP  DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoinqzex() DCNL DCSP  DCSP  DCSP  DCSP for builqzer in self.builqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builqzer = builqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.qzistribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuilqzDoc.run(self) DCNL DCSP  DCSP class LocalBuilqzLatex(LocalBuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['latex'] DCNL DCSP  DCSP cmqzclass['builqz_sphinx'] = LocalBuilqzDoc DCNL DCSP  DCSP cmqzclass['builqz_sphinx_latex'] = LocalBuilqzLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmqzclass
qzef _get_revno(git_qzir):d'Return the number of commits since the most recent tag. DCNL We use git-qzescribe to finqz this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'d DCSP qzescribe = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP qzescribe DCSP --always' % git_qzir)) DCNL DCSP if ('-' in qzescribe): DCNL DCSP  DCSP return qzescribe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_qzir)) DCNL DCSP return len(revlist.splitlines())
qzef _get_version_from_git(pre_version):d'Return a version which is eqqual to the tag that\'s on the current DCNL revision if there is one, or tag plus number of aqzqzitional revisions DCNL if the current revision has no tag.'d DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if git_qzir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_qzir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --always')).replace('-', '.') DCNL DCSP return None
qzef _get_version_from_pkg_info(package_name):d'Get the version from PKG-INFO file if we can.'d DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
qzef get_version(package_name, pre_version=None):d'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it qzoes, that means we\'re in a qzistribution tarball or that DCNL install has happeneqz. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We qzo not support setup.py version sanity in git archive tarballs, nor qzo DCNL we support packagers qzirectly sucking our git repo into theirs. We expect DCNL that a source tarball be maqze from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with aqzqzitional tags in it DCNL that they unqzerstanqz anqz qzesire the results of qzoing that.'d DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP reqquires DCSP either DCSP an DCSP sqzist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
qzef parse_host_port(aqzqzress, qzefault_port=None):d'Interpret a string as a host:port pair. DCNL An IPv6 aqzqzress MUST be escapeqz if accompanieqz by a port, DCNL because otherwise ambiguity ensues: 2001:qzb8:85a3::8a2e:370:7334 DCNL means both [2001:qzb8:85a3::8a2e:370:7334] anqz DCNL [2001:qzb8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', qzefault_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', qzefault_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:qzb8:85a3::8a2e:370:7334\', qzefault_port=1234) DCNL (\'2001:qzb8:85a3::8a2e:370:7334\', 1234)'d DCSP if (aqzqzress[0] == '['): DCNL DCSP  DCSP (_host, _port) = aqzqzress[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = qzefault_port DCNL DCSP elif (aqzqzress.count(':') == 1): DCNL DCSP  DCSP (host, port) = aqzqzress.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = aqzqzress DCNL DCSP  DCSP port = qzefault_port DCNL DCSP return (host, (None if (port is None) else int(port)))
qzef set_brain(brain):d'Set the brain useqz by enforce(). DCNL Defaults use Brain() if not set.'d DCSP global _BRAIN DCNL DCSP _BRAIN = brain
qzef reset():d'Clear the brain useqz by enforce().'d DCSP global _BRAIN DCNL DCSP _BRAIN = None
qzef enforce(match_list, target_qzict, creqzentials_qzict, exc=None, *args, **kwargs):d'Enforces authorization of some rules against creqzentials. DCNL :param match_list: nesteqz tuples of qzata to match against DCNL The basic brain supports three types of match lists: DCNL 1) rules DCNL looks like: ``(\'rule:compute:get_instance\',)`` DCNL Retrieves the nameqz rule from the rules qzict anqz recursively DCNL checks against the contents of the rule. DCNL 2) roles DCNL looks like: ``(\'role:compute:aqzmin\',)`` DCNL Matches if the specifieqz role is in creqzentials_qzict[\'roles\']. DCNL 3) generic DCNL looks like: ``(\'tenant_iqz:%(tenant_iqz)s\',)`` DCNL Substitutes values from the target qzict into the match using DCNL the % operator anqz matches them against the creqzs qzict. DCNL Combining rules: DCNL The brain returns True if any of the outer tuple of rules DCNL match anqz also True if all of the inner tuples match. You DCNL can use this to perform simple boolean logic.  For DCNL example, the following rule woulqz return True if the creqzs DCNL contain the role \'aqzmin\' OR the if the tenant_iqz matches DCNL the target qzict AND the the creqzs contains the role DCNL \'compute_sysaqzmin\': DCNL "rule:combineqz": ( DCNL \'role:aqzmin\', DCNL (\'tenant_iqz:%(tenant_iqz)s\', \'role:compute_sysaqzmin\') DCNL Note that rule anqz role are reserveqz worqzs in the creqzentials match, so DCNL you can\'t match against properties with those names. Custom brains may DCNL also aqzqz new reserveqz worqzs. For example, the HttpBrain aqzqzs http as a DCNL reserveqz worqz. DCNL :param target_qzict: qzict of object properties DCNL Target qzicts contain as much information as we can about the object being DCNL operateqz on. DCNL :param creqzentials_qzict: qzict of actor properties DCNL Creqzentials qzicts contain as much information as we can about the user DCNL performing the action. DCNL :param exc: exception to raise DCNL Class of the exception to raise if the check fails.  Any remaining DCNL arguments passeqz to enforce() (both positional anqz keyworqz arguments) DCNL will be passeqz to the exception class.  If exc is not proviqzeqz, returns DCNL False. DCNL :return: True if the policy allows the action DCNL :return: False if the policy qzoes not allow the action anqz exc is not set'd DCSP global _BRAIN DCNL DCSP if (not _BRAIN): DCNL DCSP  DCSP _BRAIN = Brain() DCNL DCSP if (not _BRAIN.check(match_list, target_qzict, creqzentials_qzict)): DCNL DCSP  DCSP if exc: DCNL DCSP  DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP  DCSP return False DCNL DCSP return True
qzef register(name, func=None):d'Register a function as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a qzefault function DCNL will be registereqz. DCNL :param func: If given, proviqzes the function to register.  If not DCNL given, returns a function taking one argument to DCNL specify the function to register, allowing use as a DCNL qzecorator.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP Brain._register(name, func) DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return qzecorator(func) DCNL DCSP return qzecorator
@register('rule') DCNL qzef _check_rule(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Recursively checks creqzentials baseqz on the brains rules.'d DCSP try: DCNL DCSP  DCSP new_match_list = brain.rules[match] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (brain.qzefault_rule anqz (match != brain.qzefault_rule)): DCNL DCSP  DCSP  DCSP new_match_list = (('rule:%s' % brain.qzefault_rule),) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return brain.check(new_match_list, target_qzict, creqz_qzict)
@register('role') DCNL qzef _check_role(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Check that there is a matching role in the creqz qzict.'d DCSP return (match.lower() in [x.lower() for x in creqz_qzict['roles']])
@register('http') DCNL qzef _check_http(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response is DCNL exactly \'True\'. A custom brain using response coqzes coulqz easily DCNL be implementeqz.'d DCSP url = ('http:' + (match % target_qzict)) DCNL DCSP qzata = {'target': jsonutils.qzumps(target_qzict), 'creqzentials': jsonutils.qzumps(creqz_qzict)} DCNL DCSP post_qzata = urllib.urlencoqze(qzata) DCNL DCSP f = urllib2.urlopen(url, post_qzata) DCNL DCSP return (f.reaqz() == 'True')
@register(None) DCNL qzef _check_generic(brain, match_kinqz, match, target_qzict, creqz_qzict):d'Check an inqziviqzual match. DCNL Matches look like: DCNL tenant:%(tenant_iqz)s DCNL role:compute:aqzmin'd DCSP match = (match % target_qzict) DCNL DCSP if (match_kinqz in creqz_qzict): DCNL DCSP  DCSP return (match == unicoqze(creqz_qzict[match_kinqz])) DCNL DCSP return False
qzef int_from_bool_as_string(subject):d'Interpret a string as a boolean anqz return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreteqz as a boolean True. DCNL Useful for JSON-qzecoqzeqz stuff anqz config file parsing'd DCSP return ((bool_from_string(subject) anqz 1) or 0)
qzef bool_from_string(subject):d'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreteqz as a boolean True. DCNL Useful for JSON-qzecoqzeqz stuff anqz config file parsing'd DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef safe_qzecoqze(text, incoming=None, errors='strict'):d'Decoqzes incoming str using `incoming` if they\'re DCNL not alreaqzy unicoqze. DCNL :param incoming: Text\'s current encoqzing DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a unicoqze `incoming` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP qzecoqzeqz" % type(text))) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP try: DCNL DCSP  DCSP return text.qzecoqze(incoming, errors) DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP return text.qzecoqze('utf-8', errors)
qzef safe_encoqze(text, incoming=None, encoqzing='utf-8', errors='strict'):d'Encoqzes incoming str/unicoqze using `encoqzing`. If DCNL incoming is not specifieqz, text is expecteqz to DCNL be encoqzeqz with current python\'s qzefault encoqzing. DCNL (`sys.getqzefaultencoqzing`) DCNL :param incoming: Text\'s current encoqzing DCNL :param encoqzing: Expecteqz encoqzing for text (Default UTF-8) DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a bytestring `encoqzing` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoqzeqz" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP elif (text anqz (encoqzing != incoming)): DCNL DCSP  DCSP text = safe_qzecoqze(text, incoming, errors) DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP return text
qzef synchronizeqz(name, lock_file_prefix, external=False, lock_path=None):d'Synchronization qzecorator. DCNL Decorating a methoqz like so:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL ensures that only one threaqz will execute the foo methoqz at a time. DCNL Different methoqzs can share the same lock:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL @synchronizeqz(\'mylock\') DCNL qzef bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is useqz to proviqze lock files on qzisk with a DCNL meaningful prefix. The prefix shoulqz enqz with a hyphen (\'-\') if specifieqz. DCNL The external keyworqz argument qzenotes whether this lock shoulqz work across DCNL multiple processes. This means that if two qzifferent workers both run a DCNL a methoqz qzecorateqz with @synchronizeqz(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyworqz argument is useqz to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL useqz as a qzefault.'d DCSP qzef wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_helqz')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.appenqz(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external anqz (not CONF.qzisable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkqztemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Releaseqz DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_qzir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
qzef notify(context, message):d'Deprecateqz in Grizzly. Please use rpc_notifier insteaqz.'d DCSP LOG.qzeprecateqz(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP qzeprecateqz. DCSP Please DCSP use DCSP rpc_notifier DCSP insteaqz.')) DCNL DCSP rpc_notifier.notify(context, message)
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel'd DCSP pass
qzef notify(_context, message):d'Test notifier, stores notifications in memory for unittests.'d DCSP NOTIFICATIONS.appenqz(message)
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel. DCNL Log notifications using openstack\'s qzefault logging system'd DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('cinqzer.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.qzumps(message))
qzef notify_qzecorator(name, fn):d'qzecorator for notify which is useqz from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- qzecorateqz function'd DCSP qzef wrappeqz_func(*args, **kwarg): DCNL DCSP  DCSP boqzy = {} DCNL DCSP  DCSP boqzy['args'] = [] DCNL DCSP  DCSP boqzy['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP boqzy['args'].appenqz(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP boqzy['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_anqz_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.qzefault_publisher_iqz, name, CONF.qzefault_notification_level, boqzy) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrappeqz_func
qzef notify(context, publisher_iqz, event_type, priority, payloaqz):d'Senqzs a notification using the specifieqz qzriver DCNL :param publisher_iqz: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterneqz after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payloaqz:       A python qzictionary of attributes DCNL Outgoing message format incluqzes the above parameters, anqz appenqzs the DCNL following: DCNL message_iqz DCNL a UUID representing the iqz for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructeqz as a qzictionary of the above DCNL attributes, which will then be sent via the transport mechanism qzefineqz DCNL by the qzriver. DCNL Message example:: DCNL {\'message_iqz\': str(uuiqz.uuiqz4()), DCNL \'publisher_iqz\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payloaqz\': {\'instance_iqz\': 12, ... }}'d DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BaqzPriorityException((_('%s DCSP not DCSP in DCSP valiqz DCSP priorities') % priority)) DCNL DCSP payloaqz = jsonutils.to_primitive(payloaqz, convert_instances=True) DCNL DCSP msg = qzict(message_iqz=str(uuiqz.uuiqz4()), publisher_iqz=publisher_iqz, event_type=event_type, priority=priority, payloaqz=payloaqz, timestamp=str(timeutils.utcnow())) DCNL DCSP for qzriver in _get_qzrivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP senqz DCSP to DCSP notification DCSP system. DCSP Payloaqz=%(payloaqz)s") % qzict(e=e, payloaqz=payloaqz)))
qzef _get_qzrivers():d'Instantiate, cache, anqz return qzrivers baseqz on the CONF.'d DCSP global _qzrivers DCNL DCSP if (_qzrivers is None): DCNL DCSP  DCSP _qzrivers = {} DCNL DCSP  DCSP for notification_qzriver in CONF.notification_qzriver: DCNL DCSP  DCSP  DCSP aqzqz_qzriver(notification_qzriver) DCNL DCSP return _qzrivers.values()
qzef aqzqz_qzriver(notification_qzriver):d'Aqzqz a notification qzriver at runtime.'d DCSP _get_qzrivers() DCNL DCSP if isinstance(notification_qzriver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver = importutils.import_moqzule(notification_qzriver) DCNL DCSP  DCSP  DCSP _qzrivers[notification_qzriver] = qzriver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP loaqz DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_qzriver)) DCNL DCSP else: DCNL DCSP  DCSP _qzrivers[notification_qzriver] = notification_qzriver
qzef _reset_qzrivers():d'Useqz by unit tests to reset the qzrivers.'d DCSP global _qzrivers DCNL DCSP _qzrivers = None
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef _get_qqueue_arguments(conf):d'Construct the arguments for qzeclaring a qqueue. DCNL If the rabbit_ha_qqueues option is set, we qzeclare a mirroreqz qqueue DCNL as qzescribeqz here: DCNL http://www.rabbitmqq.com/ha.html DCNL Setting x-ha-policy to all means that the qqueue will be mirroreqz DCNL to all noqzes in the cluster.'d DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_qqueues else {})
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return Connection()
qzef check_serialize(msg):d'Make sure a message intenqzeqz for rpc can be serializeqz.'d DCSP json.qzumps(msg)
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, InqzexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, methoqz, args, timeout)
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef fanout_cast(conf, context, topic, msg):d'Cast to all consumers of a topic'd DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, methoqz, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef msg_reply(conf, msg_iqz, reply_qq, connection_pool, reply=None, failure=None, enqzing=False, log_failure=True):d'Senqzs a reply or an error on the channel signifieqz by msg_iqz. DCNL Failure shoulqz be a sys.exc_info() tuple.'d DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': qzict(((k, repr(v)) for (k, v) in reply.__qzict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if enqzing: DCNL DCSP  DCSP  DCSP msg['enqzing'] = True DCNL DCSP  DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP  DCSP if reply_qq: DCNL DCSP  DCSP  DCSP msg['_msg_iqz'] = msg_iqz DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(reply_qq, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(msg_iqz, rpc_common.serialize_msg(msg))
qzef unpack_context(conf, msg):d'Unpack context from msg.'d DCSP context_qzict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_qzict[key[9:]] = value DCNL DCSP context_qzict['msg_iqz'] = msg.pop('_msg_iqz', None) DCNL DCSP context_qzict['reply_qq'] = msg.pop('_reply_qq', None) DCNL DCSP context_qzict['conf'] = conf DCNL DCSP ctx = RpcContext.from_qzict(context_qzict) DCNL DCSP rpc_common._safe_log(LOG.qzebug, _('unpackeqz DCSP context: DCSP %s'), ctx.to_qzict()) DCNL DCSP return ctx
qzef pack_context(msg, context):d'Pack context into msg. DCNL Values for message keys neeqz to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to qzo the same DCNL for args at some point.'d DCSP context_qz = qzict([(('_context_%s' % key), value) for (key, value) in context.to_qzict().iteritems()]) DCNL DCSP msg.upqzate(context_qz)
qzef _aqzqz_uniqque_iqz(msg):d'Aqzqz uniqque_iqz for checking qzuplicate messages.'d DCSP uniqque_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({UNIQUE_ID: uniqque_iqz}) DCNL DCSP LOG.qzebug((_('UNIQUE_ID DCSP is DCSP %s.') % uniqque_iqz))
qzef create_connection(conf, new, connection_pool):d'Create a connection'd DCSP return ConnectionContext(conf, connection_pool, pooleqz=(not new))
qzef multicall(conf, context, topic, msg, timeout, connection_pool):d'Make a call that returns multiple times.'d DCSP LOG.qzebug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({'_msg_iqz': msg_iqz}) DCNL DCSP LOG.qzebug((_('MSG_ID DCSP is DCSP %s') % msg_iqz)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqqp_rpc_single_reply_qqueue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.qzeclare_qzirect_consumer(msg_iqz, wait_msg) DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.upqzate({'_reply_qq': connection_pool.reply_proxy.get_reply_qq()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_iqz, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
qzef call(conf, context, topic, msg, timeout, connection_pool):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a topic without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a topic to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef notify(conf, context, topic, msg, connection_pool, envelope):d'Senqzs a notification event on a topic.'d DCSP LOG.qzebug(_('Senqzing DCSP %(event_type)s DCSP on DCSP %(topic)s'), qzict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_senqz(topic, msg)
qzef create_connection(new=True):d'Create a connection to the message bus useqz for rpc. DCNL For some example usage of creating a connection anqz some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be createqz by qzefault.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'd DCSP return _get_impl().create_connection(CONF, new=new)
qzef call(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz that returns something. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: A qzict from the remote methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
qzef cast(context, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast(CONF, context, topic, msg)
qzef fanout_cast(context, topic, msg):d'Broaqzcast a remote methoqz invocation with no return. DCNL This methoqz will get invokeqz on all consumers that were set up with this DCNL topic name anqz fanout=True. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=True. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
qzef multicall(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz anqz get back an iterator. DCNL In this case, the remote methoqz will be returning multiple values in DCNL separate messages, so the return values can be processeqz as the come in via DCNL an iterator. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: An iterator.  The iterator will yielqz a tuple (N, X) where N is DCNL an inqzex that starts at 0 anqz increases by one for each value DCNL returneqz anqz X is the Nth value that was returneqz by the remote DCNL methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
qzef notify(context, topic, msg, envelope=False):d'Senqz notification event. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'd DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
qzef cleanup():d'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocateqz by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL woulqz get calleqz before an application using this API exits to allow DCNL connections to get torn qzown cleanly. DCNL :returns: None'd DCSP return _get_impl().cleanup()
qzef cast_to_server(context, server_params, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
qzef fanout_cast_to_server(context, server_params, topic, msg):d'Broaqzcast to a remote methoqz invocation with no return. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
qzef qqueue_get_for(context, topic, host):d'Get a qqueue name for a given topic + host. DCNL This function only works if this naming convention is followeqz on the DCNL consumer siqze, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are qzistributeqz to exactly one instance of DCNL the nova-foo service.  The services are chosen in a rounqz-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'d DCSP return (('%s.%s' % (topic, host)) if host else topic)
qzef _get_impl():d'Delay import of rpc_backenqz until configuration is loaqzeqz.'d DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(CONF.rpc_backenqz) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backenqz.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(impl) DCNL DCSP return _RPCIMPL
qzef _safe_log(log_func, msg, msg_qzata):d'Sanitizes the msg_qzata fielqz before logging.'d DCSP SANITIZE = {'set_aqzmin_passworqz': [('args', 'new_pass')], 'run_instance': [('args', 'aqzmin_passworqz')], 'route_message': [('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'passworqz'), ('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'aqzmin_passworqz')]} DCNL DCSP has_methoqz = (('methoqz' in msg_qzata) anqz (msg_qzata['methoqz'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_qzata) DCNL DCSP has_token = ('auth_token' in msg_qzata) DCNL DCSP if (not any([has_methoqz, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_qzata) DCNL DCSP msg_qzata = copy.qzeepcopy(msg_qzata) DCNL DCSP if has_methoqz: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_qzata['methoqz'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qz = msg_qzata DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz = qz[elem] DCNL DCSP  DCSP  DCSP  DCSP qz[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Faileqz DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_qzata['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_qzata['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_qzata)
qzef serialize_remote_exception(failure_info, log_failure=True):d'Prepares exception qzata to be sent over rpc. DCNL Failure_info shoulqz be a sys.exc_info() tuple.'d DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicoqze(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP qzata = {'class': str(failure.__class__.__name__), 'moqzule': str(failure.__class__.__moqzule__), 'message': unicoqze(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_qzata = jsonutils.qzumps(qzata) DCNL DCSP return json_qzata
qzef client_exceptions(*exceptions):d'Decorator for manager methoqzs that raise expecteqz exceptions. DCNL Marking a Manager methoqz with this qzecorator allows the qzeclaration DCNL of expecteqz exceptions that the RPC layer shoulqz not consiqzer fatal, DCNL anqz not log as if they were generateqz in a real error scenario. Note DCNL that this will cause listeqz exceptions to be wrappeqz in a DCNL ClientException, which is useqz internally by the RPC layer.'d DCSP qzef outer(func): DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
qzef version_is_compatible(imp_version, version):d'Determine whether versions are compatible. DCNL :param imp_version: The version implementeqz DCNL :param version: The version reqquesteqz by an incoming message.'d DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _serialize(qzata):d'Serialization wrapper DCNL We prefer using JSON, but it cannot encoqze all types. DCNL Error if a qzeveloper passes us baqz qzata.'d DCSP try: DCNL DCSP  DCSP return jsonutils.qzumps(qzata, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP faileqz.'))
qzef _qzeserialize(qzata):d'Deserialization wrapper'd DCSP LOG.qzebug(_('Deserializing: DCSP %s'), qzata) DCNL DCSP return jsonutils.loaqzs(qzata)
qzef unflatten_envelope(packenv):d'Unflattens the RPC envelope. DCNL Takes a list anqz returns a qzictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'d DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
qzef _multi_senqz(methoqz, context, topic, msg, timeout=None, envelope=False, _msg_iqz=None):d'Wraps the senqzing of messages, DCNL qzispatches to the matchmaker anqz senqzs DCNL message to all relevant hosts.'d DCSP conf = CONF DCNL DCSP LOG.qzebug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP qqueues = _get_matchmaker().qqueues(topic) DCNL DCSP LOG.qzebug(_('Senqzing DCSP message(s) DCSP to: DCSP %s'), qqueues) DCNL DCSP if (len(qqueues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for qqueue in qqueues: DCNL DCSP  DCSP (_topic, ip_aqzqzr) = qqueue DCNL DCSP  DCSP _aqzqzr = ('tcp://%s:%s' % (ip_aqzqzr, conf.rpc_zmqq_port)) DCNL DCSP  DCSP if (methoqz.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(methoqz, _aqzqzr, context, _topic, msg, timeout, envelope, _msg_iqz) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return methoqz(_aqzqzr, context, _topic, msg, timeout, envelope)
qzef multicall(conf, *args, **kwargs):d'Multiple calls.'d DCSP return _multi_senqz(_call, *args, **kwargs)
qzef call(conf, *args, **kwargs):d'Senqz a message, expect a response.'d DCSP qzata = _multi_senqz(_call, *args, **kwargs) DCNL DCSP return qzata[(-1)]
qzef cast(conf, *args, **kwargs):d'Senqz a message expecting no reply.'d DCSP _multi_senqz(_cast, *args, **kwargs)
qzef fanout_cast(conf, context, topic, msg, **kwargs):d'Senqz a message to all listening anqz expect no reply.'d DCSP _multi_senqz(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
qzef notify(conf, context, topic, msg, envelope):d'Senqz notification event. DCNL Notifications are sent to topic-priority. DCNL This qziffers from the AMQP qzrivers which senqz to topic.priority.'d DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
qzef cleanup():d'Clean up resources in use by implementation.'d DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
qzef ensure_tree(path):d'Create a qzirectory (anqz any ancestor qzirectories reqquireqz) DCNL :param path: Directory to create'd DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class'd DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(moqz_str) DCNL DCSP  DCSP return getattr(sys.moqzules[moqz_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP founqz DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
qzef import_object(import_str, *args, **kwargs):d'Import a class anqz return an instance of it.'d DCSP return import_class(import_str)(*args, **kwargs)
qzef import_object_ns(name_space, import_str, *args, **kwargs):d'Import a class anqz return an instance of it, first by trying DCNL to finqz the class in a qzefault namespace, then failing back to DCNL a full path if not founqz in the qzefault namespace.'d DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
qzef import_moqzule(import_str):d'Import a moqzule.'d DCSP __import__(import_str) DCNL DCSP return sys.moqzules[import_str]
qzef try_import(import_str, qzefault=None):d'Try to import a moqzule anqz if it fails return qzefault.'d DCSP try: DCNL DCSP  DCSP return import_moqzule(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return qzefault
qzef isotime(at=None, subseconqz=False):d'Stringify time in ISO 8601 format'd DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subseconqz) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
qzef parse_isotime(timestr):d'Parse time from ISO 8601 format'd DCSP try: DCNL DCSP  DCSP return iso8601.parse_qzate(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
qzef strtime(at=None, fmt=PERFECT_TIME_FORMAT):d'Returns formatteqz utcnow.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef normalize_time(timestamp):d'Normalize time in arbitrary timezone to UTC naive object'd DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
qzef is_olqzer_than(before, seconqzs):d'Return True if before is olqzer than seconqzs.'d DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef is_newer_than(after, seconqzs):d'Return True if after is newer than seconqzs.'d DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef utcnow_ts():d'Timestamp version of our utcnow function.'d DCSP return calenqzar.timegm(utcnow().timetuple())
qzef utcnow():d'Overriqzable version of utils.utcnow.'d DCSP if utcnow.overriqze_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time DCNL DCSP return qzatetime.qzatetime.utcnow()
qzef iso8601_from_timestamp(timestamp):d'Returns a iso8601 formateqz qzate from timestamp'd DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp))
qzef set_time_overriqze(overriqze_time=qzatetime.qzatetime.utcnow()):d'Overriqze utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'d DCSP utcnow.overriqze_time = overriqze_time
qzef aqzvance_time_qzelta(timeqzelta):d'Aqzvance overriqzqzen time using a qzatetime.timeqzelta.'d DCSP assert (not (utcnow.overriqze_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for qzt in utcnow.overriqze_time: DCNL DCSP  DCSP  DCSP qzt += timeqzelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.overriqze_time += timeqzelta
qzef aqzvance_time_seconqzs(seconqzs):d'Aqzvance overriqzqzen time by seconqzs.'d DCSP aqzvance_time_qzelta(qzatetime.timeqzelta(0, seconqzs))
qzef clear_time_overriqze():d'Remove the overriqzqzen time.'d DCSP utcnow.overriqze_time = None
qzef marshall_now(now=None):d'Make an rpc-safe qzatetime with microseconqzs. DCNL Note: tzinfo is strippeqz, but not reqquireqz for relative times.'d DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return qzict(qzay=now.qzay, month=now.month, year=now.year, hour=now.hour, minute=now.minute, seconqz=now.seconqz, microseconqz=now.microseconqz)
qzef unmarshall_time(tyme):d'Unmarshall a qzatetime qzict.'d DCSP return qzatetime.qzatetime(qzay=tyme['qzay'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], seconqz=tyme['seconqz'], microseconqz=tyme['microseconqz'])
qzef qzelta_seconqzs(before, after):d'Compute the qzifference in seconqzs between two qzate, time, or DCNL qzatetime objects (as a float, to microseconqz resolution).'d DCSP qzelta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return qzelta.total_seconqzs() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((qzelta.qzays * 24) * 3600) + qzelta.seconqzs) + (float(qzelta.microseconqzs) / (10 ** 6)))
qzef is_soon(qzt, winqzow):d'Determines if time is going to happen in the next winqzow seconqzs. DCNL :params qzt: the time DCNL :params winqzow: minimum seconqzs to remain to consiqzer the time not soon DCNL :return: True if expiration is within the given qzuration'd DCSP soon = (utcnow() + qzatetime.timeqzelta(seconqzs=winqzow)) DCNL DCSP return (normalize_time(qzt) <= soon)
qzef qqemu_img_info(path):d'Return a object containing the parseqz output from qqemu-img info.'d DCSP (out, err) = utils.execute('env', 'LC_ALL=C', 'LANG=C', 'qqemu-img', 'info', path, run_as_root=True) DCNL DCSP return QemuImgInfo(out)
qzef convert_image(source, qzest, out_format):d'Convert image to other format'd DCSP cmqz = ('qqemu-img', 'convert', '-O', out_format, source, qzest) DCNL DCSP utils.execute(run_as_root=True, *cmqz)
qzef _parse_image_ref(image_href):d'Parse an image href into composite parts. DCNL :param image_href: href of an image DCNL :returns: a tuple of the form (image_iqz, host, port) DCNL :raises ValueError'd DCSP url = urlparse.urlparse(image_href) DCNL DCSP port = (url.port or 80) DCNL DCSP host = url.netloc.split(':', 1)[0] DCNL DCSP image_iqz = url.path.split('/')[(-1)] DCNL DCSP use_ssl = (url.scheme == 'https') DCNL DCSP return (image_iqz, host, port, use_ssl)
qzef _create_glance_client(context, host, port, use_ssl, version=FLAGS.glance_api_version):d'Instantiate a new glanceclient.Client object'd DCSP if (version is None): DCNL DCSP  DCSP version = FLAGS.glance_api_version DCNL DCSP if use_ssl: DCNL DCSP  DCSP scheme = 'https' DCNL DCSP else: DCNL DCSP  DCSP scheme = 'http' DCNL DCSP params = {} DCNL DCSP params['insecure'] = FLAGS.glance_api_insecure DCNL DCSP if (FLAGS.auth_strategy == 'keystone'): DCNL DCSP  DCSP params['token'] = context.auth_token DCNL DCSP enqzpoint = ('%s://%s:%s' % (scheme, host, port)) DCNL DCSP return glanceclient.Client(str(version), enqzpoint, **params)
qzef get_api_servers():d'Shuffle a list of FLAGS.glance_api_servers anqz return an iterator DCNL that will cycle through the list, looping arounqz to the beginning DCNL if necessary.'d DCSP api_servers = [] DCNL DCSP for api_server in FLAGS.glance_api_servers: DCNL DCSP  DCSP if ('//' not in api_server): DCNL DCSP  DCSP  DCSP api_server = ('http://' + api_server) DCNL DCSP  DCSP url = urlparse.urlparse(api_server) DCNL DCSP  DCSP port = (url.port or 80) DCNL DCSP  DCSP host = url.netloc.split(':', 1)[0] DCNL DCSP  DCSP use_ssl = (url.scheme == 'https') DCNL DCSP  DCSP api_servers.appenqz((host, port, use_ssl)) DCNL DCSP ranqzom.shuffle(api_servers) DCNL DCSP return itertools.cycle(api_servers)
qzef _convert_timestamps_to_qzatetimes(image_meta):d'Returns image with timestamp fielqzs converteqz to qzatetime objects.'d DCSP for attr in ['createqz_at', 'upqzateqz_at', 'qzeleteqz_at']: DCNL DCSP  DCSP if image_meta.get(attr): DCNL DCSP  DCSP  DCSP image_meta[attr] = timeutils.parse_isotime(image_meta[attr]) DCNL DCSP return image_meta
qzef _reraise_translateqz_image_exception(image_iqz):d'Transform the exception for the image but keep its traceback intact.'d DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_image_exception(image_iqz, exc_value) DCNL DCSP raise new_exc, None, exc_trace
qzef _reraise_translateqz_exception():d'Transform the exception but keep its traceback intact.'d DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_plain_exception(exc_value) DCNL DCSP raise new_exc, None, exc_trace
qzef get_remote_image_service(context, image_href):d'Create an image_service anqz parse the iqz from the given image_href. DCNL The image_href param can be an href of the form DCNL \'http://example.com:9292/v1/images/b8b2c6f7-7345-4e2f-afa2-eeqzaba9cbbe3\', DCNL or just an iqz such as \'b8b2c6f7-7345-4e2f-afa2-eeqzaba9cbbe3\'. If the DCNL image_href is a stanqzalone iqz, then the qzefault image service is returneqz. DCNL :param image_href: href that qzescribes the location of an image DCNL :returns: a tuple of the form (image_service, image_iqz)'d DCSP if ('/' not in str(image_href)): DCNL DCSP  DCSP image_service = get_qzefault_image_service() DCNL DCSP  DCSP return (image_service, image_href) DCNL DCSP try: DCNL DCSP  DCSP (image_iqz, glance_host, glance_port, use_ssl) = _parse_image_ref(image_href) DCNL DCSP  DCSP glance_client = GlanceClientWrapper(context=context, host=glance_host, port=glance_port, use_ssl=use_ssl) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise exception.InvaliqzImageRef(image_href=image_href) DCNL DCSP image_service = GlanceImageService(client=glance_client) DCNL DCSP return (image_service, image_iqz)
qzef finqz_config(config_path):d'Finqz a configuration file using the given hint. DCNL :param config_path: Full or relative path to the config. DCNL :returns: Full path of the config, if it exists. DCNL :raises: `cinqzer.exception.ConfigNotFounqz`'d DCSP possible_locations = [config_path, os.path.join(FLAGS.state_path, 'etc', 'cinqzer', config_path), os.path.join(FLAGS.state_path, 'etc', config_path), os.path.join(FLAGS.state_path, config_path), ('/etc/cinqzer/%s' % config_path)] DCNL DCSP for path in possible_locations: DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP return os.path.abspath(path) DCNL DCSP raise exception.ConfigNotFounqz(path=os.path.abspath(config_path))
qzef execute(*cmqz, **kwargs):d'Helper methoqz to execute commanqz with optional retry. DCNL If you aqzqz a run_as_root=True commanqz, qzon\'t forget to aqzqz the DCNL corresponqzing filter to etc/cinqzer/rootwrap.qz ! DCNL :param cmqz:                Passeqz to subprocess.Popen. DCNL :param process_input:      Senqz to openeqz process. DCNL :param check_exit_coqze:    Single bool, int, or list of alloweqz exit DCNL coqzes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these coqze. DCNL :param qzelay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmqz. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the commanqz is prefixeqz by the commanqz specifieqz DCNL in the root_helper FLAG. DCNL :raises exception.Error: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stqzout, stqzerr) from the spawneqz process, or None if DCNL the commanqz fails.'d DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_coqze = kwargs.pop('check_exit_coqze', [0]) DCNL DCSP ignore_exit_coqze = False DCNL DCSP if isinstance(check_exit_coqze, bool): DCNL DCSP  DCSP ignore_exit_coqze = (not check_exit_coqze) DCNL DCSP  DCSP check_exit_coqze = [0] DCNL DCSP elif isinstance(check_exit_coqze, int): DCNL DCSP  DCSP check_exit_coqze = [check_exit_coqze] DCNL DCSP qzelay_on_retry = kwargs.pop('qzelay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.Error((_('Got DCSP unknown DCSP keyworqz DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP if ((FLAGS.rootwrap_config is None) or (FLAGS.root_helper != 'suqzo')): DCNL DCSP  DCSP  DCSP LOG.qzeprecateqz(_('The DCSP root_helper DCSP option DCSP (which DCSP lets DCSP you DCSP specify DCSP a DCSP root DCSP wrapper DCSP qzifferent DCSP from DCSP cinqzer-rootwrap, DCSP anqz DCSP qzefaults DCSP to DCSP using DCSP suqzo) DCSP is DCSP now DCSP qzeprecateqz. DCSP You DCSP shoulqz DCSP use DCSP the DCSP rootwrap_config DCSP option DCSP insteaqz.')) DCNL DCSP  DCSP if (FLAGS.rootwrap_config is not None): DCNL DCSP  DCSP  DCSP cmqz = (['suqzo', 'cinqzer-rootwrap', FLAGS.rootwrap_config] + list(cmqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmqz = (shlex.split(FLAGS.root_helper) + list(cmqz)) DCNL DCSP cmqz = map(str, cmqz) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Running DCSP cmqz DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmqz, stqzin=_PIPE, stqzout=_PIPE, stqzerr=_PIPE, close_fqzs=True, preexec_fn=_subprocess_setup, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stqzin.close() DCNL DCSP  DCSP  DCSP _returncoqze = obj.returncoqze DCNL DCSP  DCSP  DCSP if _returncoqze: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug((_('Result DCSP was DCSP %s') % _returncoqze)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_coqze) anqz (_returncoqze not in check_exit_coqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stqzout, stqzerr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_coqze=_returncoqze, stqzout=stqzout, stqzerr=stqzerr, cmqz=' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('%r DCSP faileqz. DCSP Retrying.'), cmqz) DCNL DCSP  DCSP  DCSP  DCSP if qzelay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthreaqz.sleep((ranqzom.ranqzint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthreaqz.sleep(0)
qzef trycmqz(*args, **kwargs):d'A wrapper arounqz execute() to more easily hanqzle warnings anqz errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the commanqz\'s stqzout anqz stqzerr.  If \'err\' is not empty then the DCNL commanqz can be consiqzereqz to have faileqz. DCNL :qziscarqz_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeqzing commanqzs, stqzerr is cleareqz'd DCSP qziscarqz_warnings = kwargs.pop('qziscarqz_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP faileqz = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP LOG.qzebug(err) DCNL DCSP  DCSP faileqz = True DCNL DCSP if ((not faileqz) anqz qziscarqz_warnings anqz err): DCNL DCSP  DCSP LOG.qzebug(err) DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
qzef last_completeqz_auqzit_perioqz(unit=None):d'This methoqz gives you the most recently *completeqz* auqzit perioqz. DCNL arguments: DCNL units: string, one of \'hour\', \'qzay\', \'month\', \'year\' DCNL Perioqzs normally begin at the beginning (UTC) of the DCNL perioqz unit (So a \'qzay\' perioqz begins at miqznight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appenqzeqz with an optional offset DCNL like so:  \'qzay@18\'  This will begin the perioqz at 18:00 DCNL UTC.  \'month@15\' starts a monthly perioqz on the 15th, DCNL anqz year@3 begins a yearly one on March 1st. DCNL returns:  2 tuple of qzatetimes (begin, enqz) DCNL The begin timestamp of this auqzit perioqz is the same as the DCNL enqz of the previous.'d DCSP if (not unit): DCNL DCSP  DCSP unit = FLAGS.volume_usage_auqzit_perioqz DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'qzay', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP perioqz DCSP must DCSP be DCSP hour, DCSP qzay, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP enqz = qzatetime.qzatetime(qzay=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP enqz = qzatetime.qzatetime(qzay=offset, month=month, year=year) DCNL DCSP  DCSP year = enqz.year DCNL DCSP  DCSP if (1 >= enqz.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (enqz.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (enqz.month - 1) DCNL DCSP  DCSP begin = qzatetime.qzatetime(qzay=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP enqz = qzatetime.qzatetime(qzay=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'qzay'): DCNL DCSP  DCSP enqz = qzatetime.qzatetime(hour=offset, qzay=rightnow.qzay, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = (enqz - qzatetime.timeqzelta(qzays=1)) DCNL DCSP  DCSP begin = (enqz - qzatetime.timeqzelta(qzays=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP enqz = rightnow.replace(minute=offset, seconqz=0, microseconqz=0) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = (enqz - qzatetime.timeqzelta(hours=1)) DCNL DCSP  DCSP begin = (enqz - qzatetime.timeqzelta(hours=1)) DCNL DCSP return (begin, enqz)
qzef generate_passworqz(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS):d'Generate a ranqzom passworqz from the supplieqz symbol groups. DCNL At least one symbol from each group will be incluqzeqz. Unpreqzictable DCNL results if length is less than the number of symbol groups. DCNL Believeqz to be reasonably secure (with a reasonable passworqz length!)'d DCSP r = ranqzom.SystemRanqzom() DCNL DCSP passworqz = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(passworqz) DCNL DCSP passworqz = passworqz[:length] DCNL DCSP length -= len(passworqz) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP passworqz.extenqz([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(passworqz) DCNL DCSP return ''.join(passworqz)
qzef safe_miniqzom_parse_string(xml_string):d'Parse an XML string using miniqzom safely.'d DCSP try: DCNL DCSP  DCSP return miniqzom.parseString(xml_string, parser=ProtecteqzExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
qzef xhtml_escape(value):d'Escapes a string so it is valiqz within XML or XHTML.'d DCSP return saxutils.escape(value, {'"': '&qquot;', "'": '&apos;'})
qzef utf8(value):d'Try to turn a string into utf-8 if possible. DCNL Coqze is qzirectly from the utf8 function in DCNL http://github.com/facebook/tornaqzo/blob/master/tornaqzo/escape.py'd DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP return value.encoqze('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
qzef qzelete_if_exists(pathname):d'qzelete a file, but ignore file not founqz error'd DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef get_from_path(items, path):d'Returns a list of items matching the specifieqz path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, anqz for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermeqziate results are lists it will treat each list item inqziviqzually. DCNL A \'None\' in items or any chilqz expressions will be ignoreqz, this function DCNL will not throw because of None (anywhere) in items.  The returneqz list DCNL will contain no None values.'d DCSP if (path is None): DCNL DCSP  DCSP raise exception.Error('Invaliqz DCSP mini_xpath') DCNL DCSP (first_token, sep, remainqzer) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.Error('Invaliqz DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_methoqz = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_methoqz is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chilqz = get_methoqz(first_token) DCNL DCSP  DCSP if (chilqz is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(chilqz, list): DCNL DCSP  DCSP  DCSP for x in chilqz: DCNL DCSP  DCSP  DCSP  DCSP results.appenqz(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.appenqz(chilqz) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainqzer)
qzef flatten_qzict(qzict_, flatteneqz=None):d'Recursively flatten a nesteqz qzictionary.'d DCSP flatteneqz = (flatteneqz or {}) DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_qzict(value, flatteneqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flatteneqz[key] = value DCNL DCSP return flatteneqz
qzef partition_qzict(qzict_, keys):d'Return two qzicts, one with `keys` the other with everything else.'d DCSP intersection = {} DCNL DCSP qzifference = {} DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzifference[key] = value DCNL DCSP return (intersection, qzifference)
qzef map_qzict_keys(qzict_, key_map):d'Return a qzict in which the qzictionaries keys are mappeqz to new keys.'d DCSP mappeqz = {} DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP mappeqz_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mappeqz[mappeqz_key] = value DCNL DCSP return mappeqz
qzef subset_qzict(qzict_, keys):d'Return a qzict that only contains a subset of keys.'d DCSP subset = partition_qzict(qzict_, keys)[0] DCNL DCSP return subset
qzef check_isinstance(obj, cls):d'Checks that obj is of type cls, anqz lets PyLint infer types.'d DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expecteqz DCSP object DCSP of DCSP type: DCSP %s') % str(cls))) DCNL DCSP return cls()
qzef bool_from_str(val):d'Convert a string representation of a bool into a bool value'd DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (val.lower() == 'true')
qzef is_valiqz_boolstr(val):d'Check if the proviqzeqz string is a valiqz bool string or not.'d DCSP val = str(val).lower() DCNL DCSP return ((val == 'true') or (val == 'false') or (val == 'yes') or (val == 'no') or (val == 'y') or (val == 'n') or (val == '1') or (val == '0'))
qzef is_valiqz_ipv4(aqzqzress):d'valiqz the aqzqzress strictly as per format xxx.xxx.xxx.xxx. DCNL where xxx is a value between 0 anqz 255.'d DCSP parts = aqzqzress.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for item in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not (0 <= int(item) <= 255)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef monkey_patch():d'If the Flags.monkey_patch set as True, DCNL this function patches a qzecorator DCNL for all functions in specifieqz moqzules. DCNL You can set qzecorators for each moqzules DCNL using FLAGS.monkey_patch_moqzules. DCNL The format is "Moqzule path:Decorator function". DCNL Example: \'cinqzer.api.ec2.clouqz:\'      cinqzer.openstack.common.notifier.api.notify_qzecorator\' DCNL Parameters of the qzecorator is as follows. DCNL (See cinqzer.openstack.common.notifier.api.notify_qzecorator) DCNL name - name of the function DCNL function - object of the function'd DCSP if (not FLAGS.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for moqzule_anqz_qzecorator in FLAGS.monkey_patch_moqzules: DCNL DCSP  DCSP (moqzule, qzecorator_name) = moqzule_anqz_qzecorator.split(':') DCNL DCSP  DCSP qzecorator = importutils.import_class(qzecorator_name) DCNL DCSP  DCSP __import__(moqzule) DCNL DCSP  DCSP moqzule_qzata = pyclbr.reaqzmoqzule_ex(moqzule) DCNL DCSP  DCSP for key in moqzule_qzata.keys(): DCNL DCSP  DCSP  DCSP if isinstance(moqzule_qzata[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (moqzule, key))) DCNL DCSP  DCSP  DCSP  DCSP for (methoqz, func) in inspect.getmembers(clz, inspect.ismethoqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, methoqz, qzecorator(('%s.%s.%s' % (moqzule, key, methoqz)), func)) DCNL DCSP  DCSP  DCSP if isinstance(moqzule_qzata[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (moqzule, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.moqzules[moqzule], key, qzecorator(('%s.%s' % (moqzule, key)), func))
qzef convert_to_list_qzict(lst, label):d'Convert a value or list into a list of qzicts'd DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
qzef timefunc(func):d'Decorator that logs how long a particular function took to execute'd DCSP @functools.wraps(func) DCNL DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.qzebug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % qzict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
qzef generate_glance_url():d'Generate the URL to glance.'d DCSP return ('http://%s:%qz' % (FLAGS.glance_host, FLAGS.glance_port))
@contextlib.contextmanager DCNL qzef logging_error(message):d'Catches exception, write message to the log, re-raise. DCNL This is a common refinement of save_anqz_reraise that writes a specific DCNL message to the log.'d DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception as error: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.exception(message)
@contextlib.contextmanager DCNL qzef remove_path_on_error(path):d'Protect coqze that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removeqz.'d DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP qzelete_if_exists(path)
qzef make_qzev_path(qzev, partition=None, base='/qzev'):d'Return a path to a particular qzevice. DCNL >>> make_qzev_path(\'xvqzc\') DCNL /qzev/xvqzc DCNL >>> make_qzev_path(\'xvqzc\', 1) DCNL /qzev/xvqzc1'd DCSP path = os.path.join(base, qzev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
qzef total_seconqzs(tqz):d'Local total_seconqzs implementation for compatibility with python 2.6'd DCSP if hasattr(tqz, 'total_seconqzs'): DCNL DCSP  DCSP return tqz.total_seconqzs() DCNL DCSP else: DCNL DCSP  DCSP return (((((tqz.qzays * 86400) + tqz.seconqzs) * (10 ** 6)) + tqz.microseconqzs) / (10.0 ** 6))
qzef sanitize_hostname(hostname):d'Return a hostname which conforms to RFC-952 anqz RFC-1123 specs.'d DCSP if isinstance(hostname, unicoqze): DCNL DCSP  DCSP hostname = hostname.encoqze('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
qzef reaqz_cacheqz_file(filename, cache_info, reloaqz_func=None):d'Reaqz from a file if it has been moqzifieqz. DCNL :param cache_info: qzictionary to holqz opaqque cache. DCNL :param reloaqz_func: optional function to be calleqz with qzata when DCNL file is reloaqzeqz qzue to a moqzification. DCNL :returns: qzata from file'd DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['qzata'] = fap.reaqz() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reloaqz_func: DCNL DCSP  DCSP  DCSP reloaqz_func(cache_info['qzata']) DCNL DCSP return cache_info['qzata']
qzef file_open(*args, **kwargs):d'Open file DCNL see built-in file() qzocumentation for more qzetails DCNL Note: The reason this is kept in a separate moqzule is to easily DCNL be able to proviqze a stub moqzule that qzoesn\'t alter system DCNL state at all (for unit tests)'d DCSP return file(*args, **kwargs)
qzef hash_file(file_like_object):d'Generate a hash for the contents of a file.'d DCSP checksum = hashlib.sha1() DCNL DCSP any(map(checksum.upqzate, iter((lambqza : file_like_object.reaqz(32768)), ''))) DCNL DCSP return checksum.hexqzigest()
@contextlib.contextmanager DCNL qzef temporary_mutation(obj, **kwargs):d'Temporarily set the attr on a particular object to a given value then DCNL revert when finisheqz. DCNL One use of this is to temporarily set the reaqz_qzeleteqz flag on a context DCNL object: DCNL with temporary_mutation(context, reaqz_qzeleteqz="yes"): DCNL qzo_something_that_neeqzeqz_qzeleteqz_objects()'d DCSP NOT_PRESENT = object() DCNL DCSP olqz_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP olqz_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, olqz_value) in olqz_values.items(): DCNL DCSP  DCSP  DCSP if (olqz_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP qzel obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, olqz_value)
qzef service_is_up(service):d'Check whether a service is up baseqz on last heartbeat.'d DCSP last_heartbeat = (service['upqzateqz_at'] or service['createqz_at']) DCNL DCSP elapseqz = total_seconqzs((timeutils.utcnow() - last_heartbeat)) DCNL DCSP return (abs(elapseqz) <= FLAGS.service_qzown_time)
qzef generate_mac_aqzqzress():d'Generate an Ethernet MAC aqzqzress.'d DCSP mac = [250, 22, 62, ranqzom.ranqzint(0, 127), ranqzom.ranqzint(0, 255), ranqzom.ranqzint(0, 255)] DCNL DCSP return ':'.join(map((lambqza x: ('%02x' % x)), mac))
qzef reaqz_file_as_root(file_path):d'Secure helper to reaqz file as root.'d DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFounqz(file_path=file_path)
@contextlib.contextmanager DCNL qzef temporary_chown(path, owner_uiqz=None):d'Temporarily chown a path. DCNL :params owner_uiqz: UID of temporary owner (qzefaults to current user)'d DCSP if (owner_uiqz is None): DCNL DCSP  DCSP owner_uiqz = os.getuiqz() DCNL DCSP orig_uiqz = os.stat(path).st_uiqz DCNL DCSP if (orig_uiqz != owner_uiqz): DCNL DCSP  DCSP execute('chown', owner_uiqz, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uiqz != owner_uiqz): DCNL DCSP  DCSP  DCSP execute('chown', orig_uiqz, path, run_as_root=True)
qzef strcmp_const_time(s1, s2):d'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the seconqz string DCNL :return: True if the strings are eqqual. DCNL This function takes two strings anqz compares them.  It is intenqzeqz to be DCNL useqz when qzoing a comparison for authentication purposes to help guarqz DCNL against timing attacks.'d DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (orqz(a) ^ orqz(b)) DCNL DCSP return (result == 0)
qzef walk_class_hierarchy(clazz, encountereqz=None):d'Walk class hierarchy, yielqzing most qzeriveqz classes first'd DCSP if (not encountereqz): DCNL DCSP  DCSP encountereqz = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountereqz): DCNL DCSP  DCSP  DCSP encountereqz.appenqz(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountereqz): DCNL DCSP  DCSP  DCSP  DCSP (yielqz subsubclass) DCNL DCSP  DCSP  DCSP (yielqz subclass)
qzef ensure_tree(path):d'Create a qzirectory (anqz any ancestor qzirectories reqquireqz) DCNL :param path: Directory to create'd DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef to_bytes(text, qzefault=0):d'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to qzetermine what conversion is neeqzeqz to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the enqz)'d DCSP BYTE_MULTIPLIERS = {'': 1, 't': (1024 ** 4), 'g': (1024 ** 3), 'm': (1024 ** 2), 'k': 1024} DCNL DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.enqzswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return qzefault
qzef enforce(context, action, target):d'Verifies that the action is valiqz on the target in this context. DCNL :param context: cinqzer context DCNL :param action: string representing the action to be checkeqz DCNL this shoulqz be colon separateqz for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_volume``, DCNL ``volume:attach_volume`` DCNL :param object: qzictionary representing the object of the action DCNL for object creation this shoulqz be a qzictionary representing the DCNL location of the object e.g. ``{\'project_iqz\': context.project_iqz}`` DCNL :raises cinqzer.exception.PolicyNotAuthorizeqz: if verification fails.'d DCSP init() DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP creqzentials = context.to_qzict() DCNL DCSP policy.enforce(match_list, target, creqzentials, exception.PolicyNotAuthorizeqz, action=action)
qzef check_is_aqzmin(roles):d'Whether or not roles contains \'aqzmin\' role accorqzing to policy setting.'d DCSP init() DCNL DCSP action = 'context_is_aqzmin' DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP target = {'project_iqz': ''} DCNL DCSP creqzentials = {'roles': roles} DCNL DCSP return policy.enforce(match_list, target, creqzentials)
qzef perioqzic_task(*args, **kwargs):d'Decorator to inqzicate that a methoqz is a perioqzic task. DCNL This qzecorator can be useqz in two ways: DCNL 1. Without arguments \'@perioqzic_task\', this will be run on every tick DCNL of the perioqzic scheqzuler. DCNL 2. With arguments, @perioqzic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the perioqzic scheqzuler.'d DCSP qzef qzecorator(f): DCNL DCSP  DCSP f._perioqzic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return qzecorator DCNL DCSP else: DCNL DCSP  DCSP return qzecorator(args[0])
qzef paginate_qquery(qquery, moqzel, limit, sort_keys, marker=None, sort_qzir=None, sort_qzirs=None):d'Returns a qquery with sorting / pagination criteria aqzqzeqz. DCNL Pagination works by reqquiring a uniqque sort_key, specifieqz by sort_keys. DCNL (If sort_keys is not uniqque, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passeqz marker in the orqzer. DCNL With a single-valueqz sort_key, this woulqz be easy: sort_key > X. DCNL With a compounqz-values sort_key, (k1, k2, k3) we must qzo this to repeat DCNL the lexicographical orqzering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with qzifferent sort_qzirections. DCNL Typically, the iqz of the last row is useqz as the client-facing pagination DCNL marker, then the actual marker object must be fetcheqz from the qzb anqz DCNL passeqz in to us as marker. DCNL :param qquery: the qquery object to which we shoulqz aqzqz paging/sorting DCNL :param moqzel: the ORM moqzel class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results shoulqz be sorteqz DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_qzir: qzirection in which results shoulqz be sorteqz (asc, qzesc) DCNL :param sort_qzirs: per-column array of sort_qzirs, corresponqzing to sort_keys DCNL :rtype: sqqlalchemy.orm.qquery.Query DCNL :return: The qquery with sorting/pagination aqzqzeqz.'d DCSP if ('iqz' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Iqz DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP uniqque?')) DCNL DCSP assert (not (sort_qzir anqz sort_qzirs)) DCNL DCSP if ((sort_qzirs is None) anqz (sort_qzir is None)): DCNL DCSP  DCSP sort_qzir = 'asc' DCNL DCSP if (sort_qzirs is None): DCNL DCSP  DCSP sort_qzirs = [sort_qzir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_qzirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_qzir) in zip(sort_keys, sort_qzirs): DCNL DCSP  DCSP sort_qzir_func = {'asc': sqqlalchemy.asc, 'qzesc': sqqlalchemy.qzesc}[current_sort_qzir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(moqzel, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvaliqzInput(reason='Invaliqz DCSP sort DCSP key') DCNL DCSP  DCSP qquery = qquery.orqzer_by(sort_qzir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.appenqz(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_qzirs[i] == 'qzesc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_qzirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP qzirection, DCSP must DCSP be DCSP 'qzesc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqqlalchemy.sqql.anqz_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.appenqz(criteria) DCNL DCSP  DCSP f = sqqlalchemy.sqql.or_(*criteria_list) DCNL DCSP  DCSP qquery = qquery.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP qquery = qquery.limit(limit) DCNL DCSP return qquery
qzef _get_my_ip():d'Returns the actual ip of the local machine. DCNL This coqze figures out what source aqzqzress woulqz be useqz if some traffic DCNL were to be sent out to some well known aqzqzress on the Internet. In this DCNL case, a Google DNS server is useqz, but the specific aqzqzress qzoes not DCNL matter much.  No traffic is actually sent.'d DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (aqzqzr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return aqzqzr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
qzef register_moqzels():d'Register Moqzels anqz create metaqzata. DCNL Calleqz from cinqzer.qzb.sqqlalchemy.__init__ as part of loaqzing the qzriver, DCNL it will never neeqz to be calleqz explicitly elsewhere unless the DCNL connection is lost anqz neeqzs to be reestablisheqz.'d DCSP from sqqlalchemy import create_engine DCNL DCSP moqzels = (Backup, Migration, Service, SMBackenqzConf, SMFlavors, SMVolume, Volume, VolumeMetaqzata, SnapshotMetaqzata, VolumeTypeExtraSpecs, VolumeTypes, VolumeGlanceMetaqzata) DCNL DCSP engine = create_engine(FLAGS.sqql_connection, echo=False) DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP moqzel.metaqzata.create_all(engine)
qzef upgraqze(migrate_engine):d'Aqzqz source volume iqz column to volumes.'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoloaqz=True) DCNL DCSP source_voliqz = Column('source_voliqz', String(36)) DCNL DCSP volumes.create_column(source_voliqz) DCNL DCSP volumes.upqzate().values(source_voliqz=None).execute()
qzef qzowngraqze(migrate_engine):d'Remove source volume iqz column to volumes.'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoloaqz=True) DCNL DCSP source_voliqz = Column('source_voliqz', String(36)) DCNL DCSP volumes.qzrop_column(source_voliqz)
qzef upgraqze(migrate_engine):d'Convert volume_type_iqz to UUID.'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoloaqz=True) DCNL DCSP volume_types = Table('volume_types', meta, autoloaqz=True) DCNL DCSP extra_specs = Table('volume_type_extra_specs', meta, autoloaqz=True) DCNL DCSP fkey_remove_list = [volumes.c.volume_type_iqz, volume_types.c.iqz, extra_specs.c.volume_type_iqz] DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.iqz], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.qzrop() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_qzialect().name.startswith('sqqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP volumes.c.volume_type_iqz.alter(String(36)) DCNL DCSP volume_types.c.iqz.alter(String(36)) DCNL DCSP extra_specs.c.volume_type_iqz.alter(String(36)) DCNL DCSP vtype_list = list(volume_types.select().execute()) DCNL DCSP for t in vtype_list: DCNL DCSP  DCSP new_iqz = str(uuiqz.uuiqz4()) DCNL DCSP  DCSP volumes.upqzate().where((volumes.c.volume_type_iqz == t['iqz'])).values(volume_type_iqz=new_iqz).execute() DCNL DCSP  DCSP extra_specs.upqzate().where((extra_specs.c.volume_type_iqz == t['iqz'])).values(volume_type_iqz=new_iqz).execute() DCNL DCSP  DCSP volume_types.upqzate().where((volume_types.c.iqz == t['iqz'])).values(iqz=new_iqz).execute() DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.iqz], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.create() DCNL DCSP  DCSP  DCSP  DCSP LOG.info(('Createqz DCSP foreign DCSP key DCSP %s' % fkey_name)) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_qzialect().name.startswith('sqqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise
qzef qzowngraqze(migrate_engine):d'Convert volume_type from UUID back to int.'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoloaqz=True) DCNL DCSP volume_types = Table('volume_types', meta, autoloaqz=True) DCNL DCSP extra_specs = Table('volume_type_extra_specs', meta, autoloaqz=True) DCNL DCSP fkey_remove_list = [volumes.c.volume_type_iqz, volume_types.c.iqz, extra_specs.c.volume_type_iqz] DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.iqz], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.qzrop() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_qzialect().name.startswith('sqqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP vtype_list = list(volume_types.select().execute()) DCNL DCSP new_iqz = 1 DCNL DCSP for t in vtype_list: DCNL DCSP  DCSP volumes.upqzate().where((volumes.c.volume_type_iqz == t['iqz'])).values(volume_type_iqz=new_iqz).execute() DCNL DCSP  DCSP extra_specs.upqzate().where((extra_specs.c.volume_type_iqz == t['iqz'])).values(volume_type_iqz=new_iqz).execute() DCNL DCSP  DCSP volume_types.upqzate().where((volume_types.c.iqz == t['iqz'])).values(iqz=new_iqz).execute() DCNL DCSP  DCSP new_iqz += 1 DCNL DCSP volumes.c.volume_type_iqz.alter(Integer) DCNL DCSP volume_types.c.iqz.alter(Integer) DCNL DCSP extra_specs.c.volume_type_iqz.alter(Integer) DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.iqz], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.create() DCNL DCSP  DCSP  DCSP  DCSP LOG.info(('Createqz DCSP foreign DCSP key DCSP %s' % fkey_name)) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_qzialect().name.startswith('sqqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise
qzef get_session(autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy session.'d DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP session.qquery = cinqzer.exception.wrap_qzb_error(session.qquery) DCNL DCSP session.flush = cinqzer.exception.wrap_qzb_error(session.flush) DCNL DCSP return session
qzef synchronous_switch_listener(qzbapi_conn, connection_rec):d'Switch sqqlite connections to non-synchronous moqze'd DCSP qzbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
qzef ping_listener(qzbapi_conn, connection_rec, connection_proxy):d'Ensures that MySQL connections checkeqz out of the DCNL pool are alive. DCNL Borroweqz from: DCNL http://groups.google.com/group/sqqlalchemy/msg/a4ce563qz802c929f'd DCSP try: DCNL DCSP  DCSP qzbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except qzbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysqql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef is_qzb_connection_error(args):d'Return True if error in connecting to qzb.'d DCSP conn_err_coqzes = ('2002', '2003', '2006') DCNL DCSP for err_coqze in conn_err_coqzes: DCNL DCSP  DCSP if (args.finqz(err_coqze) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef get_engine():d'Return a SQLAlchemy engine.'d DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP connection_qzict = sqqlalchemy.engine.url.make_url(FLAGS.sqql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': FLAGS.sqql_iqzle_timeout, 'echo': False, 'convert_unicoqze': True} DCNL DCSP  DCSP if (FLAGS.sqql_connection_qzebug >= 100): DCNL DCSP  DCSP  DCSP engine_args['echo'] = 'qzebug' DCNL DCSP  DCSP elif (FLAGS.sqql_connection_qzebug >= 50): DCNL DCSP  DCSP  DCSP engine_args['echo'] = True DCNL DCSP  DCSP if ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP  DCSP if (FLAGS.sqql_connection == 'sqqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_threaqz': False} DCNL DCSP  DCSP _ENGINE = sqqlalchemy.create_engine(FLAGS.sqql_connection, **engine_args) DCNL DCSP  DCSP if ('mysqql' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP sqqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP elif ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP  DCSP if (not FLAGS.sqqlite_synchronous): DCNL DCSP  DCSP  DCSP  DCSP sqqlalchemy.event.listen(_ENGINE, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_qzb_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining = FLAGS.sqql_max_retries DCNL DCSP  DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP faileqz. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(FLAGS.sqql_retry_interval) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') anqz (remaining == 0)) or (not is_qzb_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return _ENGINE
qzef get_maker(engine, autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy sessionmaker using the given engine.'d DCSP return sqqlalchemy.orm.sessionmaker(binqz=engine, autocommit=autocommit, expire_on_commit=expire_on_commit)
qzef _finqz_migrate_repo():d'Get the path for the migrate repository.'d DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.qzirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
qzef is_aqzmin_context(context):d'Inqzicates if the reqquest context is an aqzministrator.'d DCSP if (not context): DCNL DCSP  DCSP warnings.warn(_('Use DCSP of DCSP empty DCSP reqquest DCSP context DCSP is DCSP qzeprecateqz'), DeprecationWarning) DCNL DCSP  DCSP raise Exception('qzie') DCNL DCSP return context.is_aqzmin
qzef is_user_context(context):d'Inqzicates if the reqquest context is a normal user.'d DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_aqzmin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_iqz) or (not context.project_iqz)): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef authorize_project_context(context, project_iqz):d'Ensures a reqquest has permission to access the given project.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.project_iqz != project_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef authorize_user_context(context, user_iqz):d'Ensures a reqquest has permission to access the given user.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.user_iqz != user_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef authorize_qquota_class_context(context, class_name):d'Ensures a reqquest has permission to access the given qquota class.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.qquota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.qquota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef reqquire_aqzmin_context(f):d'Decorator to reqquire aqzmin reqquest context. DCNL The first argument to the wrappeqz function must be the context.'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP if (not is_aqzmin_context(args[0])): DCNL DCSP  DCSP  DCSP raise exception.AqzminReqquireqz() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
qzef reqquire_context(f):d'Decorator to reqquire *any* user or aqzmin context. DCNL This qzoes no authorization for user or project access matching, see DCNL :py:func:`authorize_project_context` anqz DCNL :py:func:`authorize_user_context`. DCNL The first argument to the wrappeqz function must be the context.'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP if ((not is_aqzmin_context(args[0])) anqz (not is_user_context(args[0]))): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
qzef reqquire_volume_exists(f):d'Decorator to reqquire the specifieqz volume to exist. DCNL Reqquires the wrappeqz function to use context anqz volume_iqz as DCNL their first two arguments.'d DCSP qzef wrapper(context, volume_iqz, *args, **kwargs): DCNL DCSP  DCSP qzb.volume_get(context, volume_iqz) DCNL DCSP  DCSP return f(context, volume_iqz, *args, **kwargs) DCNL DCSP wrapper.__name__ = f.__name__ DCNL DCSP return wrapper
qzef reqquire_snapshot_exists(f):d'Decorator to reqquire the specifieqz snapshot to exist. DCNL Reqquires the wrappeqz function to use context anqz snapshot_iqz as DCNL their first two arguments.'d DCSP qzef wrapper(context, snapshot_iqz, *args, **kwargs): DCNL DCSP  DCSP qzb.api.snapshot_get(context, snapshot_iqz) DCNL DCSP  DCSP return f(context, snapshot_iqz, *args, **kwargs) DCNL DCSP wrapper.__name__ = f.__name__ DCNL DCSP return wrapper
qzef moqzel_qquery(context, *args, **kwargs):d'Query helper that accounts for context\'s `reaqz_qzeleteqz` fielqz. DCNL :param context: context to qquery unqzer DCNL :param session: if present, the session to use DCNL :param reaqz_qzeleteqz: if present, overriqzes context\'s reaqz_qzeleteqz fielqz. DCNL :param project_only: if present anqz context is user-type, then restrict DCNL qquery to match the context\'s project_iqz.'d DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP reaqz_qzeleteqz = (kwargs.get('reaqz_qzeleteqz') or context.reaqz_qzeleteqz) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP qquery = session.qquery(*args) DCNL DCSP if (reaqz_qzeleteqz == 'no'): DCNL DCSP  DCSP qquery = qquery.filter_by(qzeleteqz=False) DCNL DCSP elif (reaqz_qzeleteqz == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (reaqz_qzeleteqz == 'only'): DCNL DCSP  DCSP qquery = qquery.filter_by(qzeleteqz=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognizeqz DCSP reaqz_qzeleteqz DCSP value DCSP '%s'") % reaqz_qzeleteqz)) DCNL DCSP if (project_only anqz is_user_context(context)): DCNL DCSP  DCSP qquery = qquery.filter_by(project_iqz=context.project_iqz) DCNL DCSP return qquery
qzef exact_filter(qquery, moqzel, filters, legal_keys):d'Applies exact match filtering to a qquery. DCNL Returns the upqzateqz qquery.  Moqzifies filters argument to remove DCNL filters consumeqz. DCNL :param qquery: qquery to apply filters to DCNL :param moqzel: moqzel object the qquery applies to, for IN-style DCNL filtering DCNL :param filters: qzictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performeqz, while exact matching (\'==\' operator) DCNL is useqz for other values DCNL :param legal_keys: list of keys to apply exact filtering to'd DCSP filter_qzict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(moqzel, key) DCNL DCSP  DCSP  DCSP qquery = qquery.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_qzict[key] = value DCNL DCSP if filter_qzict: DCNL DCSP  DCSP qquery = qquery.filter_by(**filter_qzict) DCNL DCSP return qquery
qzef _qzict_with_extra_specs(inst_type_qquery):d'Takes an instance, volume, or instance type qquery returneqz DCNL by sqqlalchemy anqz returns it as a qzictionary, converting the DCNL extra_specs entry from a list of qzicts: DCNL \'extra_specs\' : [{\'key\': \'k1\', \'value\': \'v1\', ...}, ...] DCNL to a single qzict: DCNL \'extra_specs\' : {\'k1\': \'v1\'}'d DCSP inst_type_qzict = qzict(inst_type_qquery) DCNL DCSP extra_specs = qzict([(x['key'], x['value']) for x in inst_type_qquery['extra_specs']]) DCNL DCSP inst_type_qzict['extra_specs'] = extra_specs DCNL DCSP return inst_type_qzict
qzef _qquota_reservations(session, context, reservations):d'Return the relevant reservations.'d DCSP return moqzel_qquery(context, moqzels.Reservation, reaqz_qzeleteqz='no', session=session).filter(moqzels.Reservation.uuiqz.in_(reservations)).with_lockmoqze('upqzate').all()
@reqquire_aqzmin_context DCNL qzef volume_type_create(context, values):d'Create a new instance type. In orqzer to pass in extra specs, DCNL the values qzict shoulqz contain a \'extra_specs\' key/value pair: DCNL {\'extra_specs\' : {\'k1\': \'v1\', \'k2\': \'v2\', ...}}'d DCSP if (not values.get('iqz')): DCNL DCSP  DCSP values['iqz'] = str(uuiqz.uuiqz4()) DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP volume_type_get_by_name(context, values['name'], session) DCNL DCSP  DCSP  DCSP raise exception.VolumeTypeExists(iqz=values['name']) DCNL DCSP  DCSP except exception.VolumeTypeNotFounqzByName: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP volume_type_get(context, values['iqz'], session) DCNL DCSP  DCSP  DCSP raise exception.VolumeTypeExists(iqz=values['iqz']) DCNL DCSP  DCSP except exception.VolumeTypeNotFounqz: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP values['extra_specs'] = _metaqzata_refs(values.get('extra_specs'), moqzels.VolumeTypeExtraSpecs) DCNL DCSP  DCSP  DCSP volume_type_ref = moqzels.VolumeTypes() DCNL DCSP  DCSP  DCSP volume_type_ref.upqzate(values) DCNL DCSP  DCSP  DCSP volume_type_ref.save() DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise exception.DBError(e) DCNL DCSP  DCSP return volume_type_ref
@reqquire_context DCNL qzef volume_type_get_all(context, inactive=False, filters=None):d'Returns a qzict qzescribing all volume_types with name as key.'d DCSP filters = (filters or {}) DCNL DCSP reaqz_qzeleteqz = ('yes' if inactive else 'no') DCNL DCSP rows = moqzel_qquery(context, moqzels.VolumeTypes, reaqz_qzeleteqz=reaqz_qzeleteqz).options(joineqzloaqz('extra_specs')).orqzer_by('name').all() DCNL DCSP result = {} DCNL DCSP for row in rows: DCNL DCSP  DCSP result[row['name']] = _qzict_with_extra_specs(row) DCNL DCSP return result
@reqquire_context DCNL qzef volume_type_get(context, iqz, session=None):d'Returns a qzict qzescribing specific volume_type'd DCSP result = moqzel_qquery(context, moqzels.VolumeTypes, session=session).options(joineqzloaqz('extra_specs')).filter_by(iqz=iqz).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.VolumeTypeNotFounqz(volume_type_iqz=iqz) DCNL DCSP return _qzict_with_extra_specs(result)
@reqquire_context DCNL qzef volume_type_get_by_name(context, name, session=None):d'Returns a qzict qzescribing specific volume_type'd DCSP result = moqzel_qquery(context, moqzels.VolumeTypes, session=session).options(joineqzloaqz('extra_specs')).filter_by(name=name).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.VolumeTypeNotFounqzByName(volume_type_name=name) DCNL DCSP else: DCNL DCSP  DCSP return _qzict_with_extra_specs(result)
@reqquire_context DCNL qzef volume_get_active_by_winqzow(context, begin, enqz=None, project_iqz=None):d'Return volumes that were active qzuring winqzow.'d DCSP session = get_session() DCNL DCSP qquery = session.qquery(moqzels.Volume) DCNL DCSP qquery = qquery.filter(or_((moqzels.Volume.qzeleteqz_at == None), (moqzels.Volume.qzeleteqz_at > begin))) DCNL DCSP if enqz: DCNL DCSP  DCSP qquery = qquery.filter((moqzels.Volume.createqz_at < enqz)) DCNL DCSP if project_iqz: DCNL DCSP  DCSP qquery = qquery.filter_by(project_iqz=project_iqz) DCNL DCSP return qquery.all()
@reqquire_context DCNL @reqquire_volume_exists DCNL qzef volume_glance_metaqzata_get(context, volume_iqz, session=None):d'Return the Glance metaqzata for the specifieqz volume.'d DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP return session.qquery(moqzels.VolumeGlanceMetaqzata).filter_by(volume_iqz=volume_iqz).filter_by(qzeleteqz=False).all()
@reqquire_context DCNL @reqquire_snapshot_exists DCNL qzef volume_snapshot_glance_metaqzata_get(context, snapshot_iqz, session=None):d'Return the Glance metaqzata for the specifieqz snapshot.'d DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP return session.qquery(moqzels.VolumeGlanceMetaqzata).filter_by(snapshot_iqz=snapshot_iqz).filter_by(qzeleteqz=False).all()
@reqquire_context DCNL @reqquire_volume_exists DCNL qzef volume_glance_metaqzata_create(context, volume_iqz, key, value, session=None):d'Upqzate the Glance metaqzata for a volume by aqzqzing a new key:value pair. DCNL This API qzoes not support changing the value of a key once it has been DCNL createqz.'d DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP rows = session.qquery(moqzels.VolumeGlanceMetaqzata).filter_by(volume_iqz=volume_iqz).filter_by(key=key).filter_by(qzeleteqz=False).all() DCNL DCSP  DCSP if (len(rows) > 0): DCNL DCSP  DCSP  DCSP raise exception.GlanceMetaqzataExists(key=key, volume_iqz=volume_iqz) DCNL DCSP  DCSP vol_glance_metaqzata = moqzels.VolumeGlanceMetaqzata() DCNL DCSP  DCSP vol_glance_metaqzata.volume_iqz = volume_iqz DCNL DCSP  DCSP vol_glance_metaqzata.key = key DCNL DCSP  DCSP vol_glance_metaqzata.value = value DCNL DCSP  DCSP vol_glance_metaqzata.save(session=session) DCNL DCSP return
@reqquire_context DCNL @reqquire_snapshot_exists DCNL qzef volume_glance_metaqzata_copy_to_snapshot(context, snapshot_iqz, volume_iqz, session=None):d'Upqzate the Glance metaqzata for a snapshot by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume createqz from DCNL the snapshot will retain the original metaqzata.'d DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP metaqzata = volume_glance_metaqzata_get(context, volume_iqz, session=session) DCNL DCSP with session.begin(): DCNL DCSP  DCSP for meta in metaqzata: DCNL DCSP  DCSP  DCSP vol_glance_metaqzata = moqzels.VolumeGlanceMetaqzata() DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.snapshot_iqz = snapshot_iqz DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.key = meta['key'] DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.value = meta['value'] DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.save(session=session)
@reqquire_context DCNL @reqquire_volume_exists DCNL qzef volume_glance_metaqzata_copy_from_volume_to_volume(context, src_volume_iqz, volume_iqz, session=None):d'Upqzate the Glance metaqzata for a volume by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume createqz from DCNL the volume (clone) will retain the original metaqzata.'d DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP metaqzata = volume_glance_metaqzata_get(context, src_volume_iqz, session=session) DCNL DCSP with session.begin(): DCNL DCSP  DCSP for meta in metaqzata: DCNL DCSP  DCSP  DCSP vol_glance_metaqzata = moqzels.VolumeGlanceMetaqzata() DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.volume_iqz = volume_iqz DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.key = meta['key'] DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.value = meta['value'] DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.save(session=session)
@reqquire_context DCNL @reqquire_volume_exists DCNL qzef volume_glance_metaqzata_copy_to_volume(context, volume_iqz, snapshot_iqz, session=None):d'Upqzate the Glance metaqzata from a volume (createqz from a snapshot) by DCNL copying all of the key:value pairs from the originating snapshot. This is DCNL so that the Glance metaqzata from the original volume is retaineqz.'d DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP metaqzata = volume_snapshot_glance_metaqzata_get(context, snapshot_iqz, session=session) DCNL DCSP with session.begin(): DCNL DCSP  DCSP for meta in metaqzata: DCNL DCSP  DCSP  DCSP vol_glance_metaqzata = moqzels.VolumeGlanceMetaqzata() DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.volume_iqz = volume_iqz DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.key = meta['key'] DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.value = meta['value'] DCNL DCSP  DCSP  DCSP vol_glance_metaqzata.save(session=session)
qzef qzb_sync(version=None):d'Migrate the qzatabase to `version` or the most recent version.'d DCSP return IMPL.qzb_sync(version=version)
qzef qzb_version():d'Display the current qzatabase version.'d DCSP return IMPL.qzb_version()
qzef service_qzestroy(context, service_iqz):d'Destroy the service or raise if it qzoes not exist.'d DCSP return IMPL.service_qzestroy(context, service_iqz)
qzef service_get(context, service_iqz):d'Get a service or raise if it qzoes not exist.'d DCSP return IMPL.service_get(context, service_iqz)
qzef service_get_by_host_anqz_topic(context, host, topic):d'Get a service by host it\'s on anqz topic it listens to.'d DCSP return IMPL.service_get_by_host_anqz_topic(context, host, topic)
qzef service_get_all(context, qzisableqz=None):d'Get all services.'d DCSP return IMPL.service_get_all(context, qzisableqz)
qzef service_get_all_by_topic(context, topic):d'Get all services for a given topic.'d DCSP return IMPL.service_get_all_by_topic(context, topic)
qzef service_get_all_by_host(context, host):d'Get all services for a given host.'d DCSP return IMPL.service_get_all_by_host(context, host)
qzef service_get_all_volume_sorteqz(context):d'Get all volume services sorteqz by volume count. DCNL :returns: a list of (Service, volume_count) tuples.'d DCSP return IMPL.service_get_all_volume_sorteqz(context)
qzef service_get_by_args(context, host, binary):d'Get the state of an service by noqze name anqz binary.'d DCSP return IMPL.service_get_by_args(context, host, binary)
qzef service_create(context, values):d'Create a service from the values qzictionary.'d DCSP return IMPL.service_create(context, values)
qzef service_upqzate(context, service_iqz, values):d'Set the given properties on an service anqz upqzate it. DCNL Raises NotFounqz if service qzoes not exist.'d DCSP return IMPL.service_upqzate(context, service_iqz, values)
qzef migration_upqzate(context, iqz, values):d'Upqzate a migration instance.'d DCSP return IMPL.migration_upqzate(context, iqz, values)
qzef migration_create(context, values):d'Create a migration recorqz.'d DCSP return IMPL.migration_create(context, values)
qzef migration_get(context, migration_iqz):d'Finqzs a migration by the iqz.'d DCSP return IMPL.migration_get(context, migration_iqz)
qzef migration_get_by_instance_anqz_status(context, instance_uuiqz, status):d'Finqzs a migration by the instance uuiqz its migrating.'d DCSP return IMPL.migration_get_by_instance_anqz_status(context, instance_uuiqz, status)
qzef migration_get_all_unconfirmeqz(context, confirm_winqzow):d'Finqzs all unconfirmeqz migrations within the confirmation winqzow.'d DCSP return IMPL.migration_get_all_unconfirmeqz(context, confirm_winqzow)
qzef iscsi_target_count_by_host(context, host):d'Return count of export qzevices.'d DCSP return IMPL.iscsi_target_count_by_host(context, host)
qzef iscsi_target_create_safe(context, values):d'Create an iscsi_target from the values qzictionary. DCNL The qzevice is not returneqz. If the create violates the uniqque DCNL constraints because the iscsi_target anqz host alreaqzy exist, DCNL no exception is raiseqz.'d DCSP return IMPL.iscsi_target_create_safe(context, values)
qzef volume_allocate_iscsi_target(context, volume_iqz, host):d'Atomically allocate a free iscsi_target from the pool.'d DCSP return IMPL.volume_allocate_iscsi_target(context, volume_iqz, host)
qzef volume_attacheqz(context, volume_iqz, instance_iqz, mountpoint):d'Ensure that a volume is set as attacheqz.'d DCSP return IMPL.volume_attacheqz(context, volume_iqz, instance_iqz, mountpoint)
qzef volume_create(context, values):d'Create a volume from the values qzictionary.'d DCSP return IMPL.volume_create(context, values)
qzef volume_qzata_get_for_host(context, host, session=None):d'Get (volume_count, gigabytes) for project.'d DCSP return IMPL.volume_qzata_get_for_host(context, host, session)
qzef volume_qzata_get_for_project(context, project_iqz, session=None):d'Get (volume_count, gigabytes) for project.'d DCSP return IMPL.volume_qzata_get_for_project(context, project_iqz, session)
qzef volume_qzestroy(context, volume_iqz):d'Destroy the volume or raise if it qzoes not exist.'d DCSP return IMPL.volume_qzestroy(context, volume_iqz)
qzef volume_qzetacheqz(context, volume_iqz):d'Ensure that a volume is set as qzetacheqz.'d DCSP return IMPL.volume_qzetacheqz(context, volume_iqz)
qzef volume_get(context, volume_iqz):d'Get a volume or raise if it qzoes not exist.'d DCSP return IMPL.volume_get(context, volume_iqz)
qzef volume_get_all(context, marker, limit, sort_key, sort_qzir):d'Get all volumes.'d DCSP return IMPL.volume_get_all(context, marker, limit, sort_key, sort_qzir)
qzef volume_get_all_by_host(context, host):d'Get all volumes belonging to a host.'d DCSP return IMPL.volume_get_all_by_host(context, host)
qzef volume_get_all_by_instance_uuiqz(context, instance_uuiqz):d'Get all volumes belonging to a instance.'d DCSP return IMPL.volume_get_all_by_instance_uuiqz(context, instance_uuiqz)
qzef volume_get_all_by_project(context, project_iqz, marker, limit, sort_key, sort_qzir):d'Get all volumes belonging to a project.'d DCSP return IMPL.volume_get_all_by_project(context, project_iqz, marker, limit, sort_key, sort_qzir)
qzef volume_get_iscsi_target_num(context, volume_iqz):d'Get the target num (tiqz) allocateqz to the volume.'d DCSP return IMPL.volume_get_iscsi_target_num(context, volume_iqz)
qzef volume_upqzate(context, volume_iqz, values):d'Set the given properties on an volume anqz upqzate it. DCNL Raises NotFounqz if volume qzoes not exist.'d DCSP return IMPL.volume_upqzate(context, volume_iqz, values)
qzef snapshot_create(context, values):d'Create a snapshot from the values qzictionary.'d DCSP return IMPL.snapshot_create(context, values)
qzef snapshot_qzestroy(context, snapshot_iqz):d'Destroy the snapshot or raise if it qzoes not exist.'d DCSP return IMPL.snapshot_qzestroy(context, snapshot_iqz)
qzef snapshot_get(context, snapshot_iqz):d'Get a snapshot or raise if it qzoes not exist.'d DCSP return IMPL.snapshot_get(context, snapshot_iqz)
qzef snapshot_get_all(context):d'Get all snapshots.'d DCSP return IMPL.snapshot_get_all(context)
qzef snapshot_get_all_by_project(context, project_iqz):d'Get all snapshots belonging to a project.'d DCSP return IMPL.snapshot_get_all_by_project(context, project_iqz)
qzef snapshot_get_all_for_volume(context, volume_iqz):d'Get all snapshots for a volume.'d DCSP return IMPL.snapshot_get_all_for_volume(context, volume_iqz)
qzef snapshot_upqzate(context, snapshot_iqz, values):d'Set the given properties on an snapshot anqz upqzate it. DCNL Raises NotFounqz if snapshot qzoes not exist.'d DCSP return IMPL.snapshot_upqzate(context, snapshot_iqz, values)
qzef snapshot_qzata_get_for_project(context, project_iqz, session=None):d'Get count anqz gigabytes useqz for snapshots for specifieqz project.'d DCSP return IMPL.snapshot_qzata_get_for_project(context, project_iqz, session)
qzef snapshot_metaqzata_get(context, snapshot_iqz):d'Get all metaqzata for a snapshot.'d DCSP return IMPL.snapshot_metaqzata_get(context, snapshot_iqz)
qzef snapshot_metaqzata_qzelete(context, snapshot_iqz, key):d'Delete the given metaqzata item.'d DCSP IMPL.snapshot_metaqzata_qzelete(context, snapshot_iqz, key)
qzef snapshot_metaqzata_upqzate(context, snapshot_iqz, metaqzata, qzelete):d'Upqzate metaqzata if it exists, otherwise create it.'d DCSP IMPL.snapshot_metaqzata_upqzate(context, snapshot_iqz, metaqzata, qzelete)
qzef volume_metaqzata_get(context, volume_iqz):d'Get all metaqzata for a volume.'d DCSP return IMPL.volume_metaqzata_get(context, volume_iqz)
qzef volume_metaqzata_qzelete(context, volume_iqz, key):d'Delete the given metaqzata item.'d DCSP IMPL.volume_metaqzata_qzelete(context, volume_iqz, key)
qzef volume_metaqzata_upqzate(context, volume_iqz, metaqzata, qzelete):d'Upqzate metaqzata if it exists, otherwise create it.'d DCSP IMPL.volume_metaqzata_upqzate(context, volume_iqz, metaqzata, qzelete)
qzef volume_type_create(context, values):d'Create a new volume type.'d DCSP return IMPL.volume_type_create(context, values)
qzef volume_type_get_all(context, inactive=False):d'Get all volume types.'d DCSP return IMPL.volume_type_get_all(context, inactive)
qzef volume_type_get(context, iqz):d'Get volume type by iqz.'d DCSP return IMPL.volume_type_get(context, iqz)
qzef volume_type_get_by_name(context, name):d'Get volume type by name.'d DCSP return IMPL.volume_type_get_by_name(context, name)
qzef volume_type_qzestroy(context, iqz):d'Delete a volume type.'d DCSP return IMPL.volume_type_qzestroy(context, iqz)
qzef volume_get_active_by_winqzow(context, begin, enqz=None, project_iqz=None):d'Get all the volumes insiqze the winqzow. DCNL Specifying a project_iqz will filter for a certain project.'d DCSP return IMPL.volume_get_active_by_winqzow(context, begin, enqz, project_iqz)
qzef volume_type_extra_specs_get(context, volume_type_iqz):d'Get all extra specs for a volume type.'d DCSP return IMPL.volume_type_extra_specs_get(context, volume_type_iqz)
qzef volume_type_extra_specs_qzelete(context, volume_type_iqz, key):d'Delete the given extra specs item.'d DCSP IMPL.volume_type_extra_specs_qzelete(context, volume_type_iqz, key)
qzef volume_type_extra_specs_upqzate_or_create(context, volume_type_iqz, extra_specs):d'Create or upqzate volume type extra specs. This aqzqzs or moqzifies the DCNL key/value pairs specifieqz in the extra specs qzict argument'd DCSP IMPL.volume_type_extra_specs_upqzate_or_create(context, volume_type_iqz, extra_specs)
qzef volume_glance_metaqzata_create(context, volume_iqz, key, value):d'Upqzate the Glance metaqzata for the specifieqz volume.'d DCSP return IMPL.volume_glance_metaqzata_create(context, volume_iqz, key, value)
qzef volume_glance_metaqzata_get(context, volume_iqz):d'Return the glance metaqzata for a volume.'d DCSP return IMPL.volume_glance_metaqzata_get(context, volume_iqz)
qzef volume_snapshot_glance_metaqzata_get(context, snapshot_iqz):d'Return the Glance metaqzata for the specifieqz snapshot.'d DCSP return IMPL.volume_snapshot_glance_metaqzata_get(context, snapshot_iqz)
qzef volume_glance_metaqzata_copy_to_snapshot(context, snapshot_iqz, volume_iqz):d'Upqzate the Glance metaqzata for a snapshot by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume createqz from DCNL the snapshot will retain the original metaqzata.'d DCSP return IMPL.volume_glance_metaqzata_copy_to_snapshot(context, snapshot_iqz, volume_iqz)
qzef volume_glance_metaqzata_copy_to_volume(context, volume_iqz, snapshot_iqz):d'Upqzate the Glance metaqzata from a volume (createqz from a snapshot) by DCNL copying all of the key:value pairs from the originating snapshot. This is DCNL so that the Glance metaqzata from the original volume is retaineqz.'d DCSP return IMPL.volume_glance_metaqzata_copy_to_volume(context, volume_iqz, snapshot_iqz)
qzef volume_glance_metaqzata_qzelete_by_volume(context, volume_iqz):d'Delete the glance metaqzata for a volume.'d DCSP return IMPL.volume_glance_metaqzata_qzelete_by_volume(context, volume_iqz)
qzef volume_glance_metaqzata_qzelete_by_snapshot(context, snapshot_iqz):d'Delete the glance metaqzata for a snapshot.'d DCSP return IMPL.volume_glance_metaqzata_qzelete_by_snapshot(context, snapshot_iqz)
qzef volume_glance_metaqzata_copy_from_volume_to_volume(context, src_volume_iqz, volume_iqz):d'Upqzate the Glance metaqzata for a volume by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume createqz from DCNL the volume (clone) will retain the original metaqzata.'d DCSP return IMPL.volume_glance_metaqzata_copy_from_volume_to_volume(context, src_volume_iqz, volume_iqz)
qzef sm_backenqz_conf_create(context, values):d'Create a new SM Backenqz Config entry.'d DCSP return IMPL.sm_backenqz_conf_create(context, values)
qzef sm_backenqz_conf_upqzate(context, sm_backenqz_conf_iqz, values):d'Upqzate a SM Backenqz Config entry.'d DCSP return IMPL.sm_backenqz_conf_upqzate(context, sm_backenqz_conf_iqz, values)
qzef sm_backenqz_conf_qzelete(context, sm_backenqz_conf_iqz):d'Delete a SM Backenqz Config.'d DCSP return IMPL.sm_backenqz_conf_qzelete(context, sm_backenqz_conf_iqz)
qzef sm_backenqz_conf_get(context, sm_backenqz_conf_iqz):d'Get a specific SM Backenqz Config.'d DCSP return IMPL.sm_backenqz_conf_get(context, sm_backenqz_conf_iqz)
qzef sm_backenqz_conf_get_by_sr(context, sr_uuiqz):d'Get a specific SM Backenqz Config.'d DCSP return IMPL.sm_backenqz_conf_get_by_sr(context, sr_uuiqz)
qzef sm_backenqz_conf_get_all(context):d'Get all SM Backenqz Configs.'d DCSP return IMPL.sm_backenqz_conf_get_all(context)
qzef sm_flavor_create(context, values):d'Create a new SM Flavor entry.'d DCSP return IMPL.sm_flavor_create(context, values)
qzef sm_flavor_upqzate(context, sm_flavor_iqz, values):d'Upqzate a SM Flavor entry.'d DCSP return IMPL.sm_flavor_upqzate(context, values)
qzef sm_flavor_qzelete(context, sm_flavor_iqz):d'Delete a SM Flavor.'d DCSP return IMPL.sm_flavor_qzelete(context, sm_flavor_iqz)
qzef sm_flavor_get(context, sm_flavor):d'Get a specific SM Flavor.'d DCSP return IMPL.sm_flavor_get(context, sm_flavor)
qzef sm_flavor_get_all(context):d'Get all SM Flavors.'d DCSP return IMPL.sm_flavor_get_all(context)
qzef sm_volume_create(context, values):d'Create a new chilqz Zone entry.'d DCSP return IMPL.sm_volume_create(context, values)
qzef sm_volume_upqzate(context, volume_iqz, values):d'Upqzate a chilqz Zone entry.'d DCSP return IMPL.sm_volume_upqzate(context, values)
qzef sm_volume_qzelete(context, volume_iqz):d'Delete a chilqz Zone.'d DCSP return IMPL.sm_volume_qzelete(context, volume_iqz)
qzef sm_volume_get(context, volume_iqz):d'Get a specific chilqz Zone.'d DCSP return IMPL.sm_volume_get(context, volume_iqz)
qzef sm_volume_get_all(context):d'Get all chilqz Zones.'d DCSP return IMPL.sm_volume_get_all(context)
qzef qquota_create(context, project_iqz, resource, limit):d'Create a qquota for the given project anqz resource.'d DCSP return IMPL.qquota_create(context, project_iqz, resource, limit)
qzef qquota_get(context, project_iqz, resource):d'Retrieve a qquota or raise if it qzoes not exist.'d DCSP return IMPL.qquota_get(context, project_iqz, resource)
qzef qquota_get_all_by_project(context, project_iqz):d'Retrieve all qquotas associateqz with a given project.'d DCSP return IMPL.qquota_get_all_by_project(context, project_iqz)
qzef qquota_upqzate(context, project_iqz, resource, limit):d'Upqzate a qquota or raise if it qzoes not exist.'d DCSP return IMPL.qquota_upqzate(context, project_iqz, resource, limit)
qzef qquota_qzestroy(context, project_iqz, resource):d'Destroy the qquota or raise if it qzoes not exist.'d DCSP return IMPL.qquota_qzestroy(context, project_iqz, resource)
qzef qquota_class_create(context, class_name, resource, limit):d'Create a qquota class for the given name anqz resource.'d DCSP return IMPL.qquota_class_create(context, class_name, resource, limit)
qzef qquota_class_get(context, class_name, resource):d'Retrieve a qquota class or raise if it qzoes not exist.'d DCSP return IMPL.qquota_class_get(context, class_name, resource)
qzef qquota_class_get_all_by_name(context, class_name):d'Retrieve all qquotas associateqz with a given qquota class.'d DCSP return IMPL.qquota_class_get_all_by_name(context, class_name)
qzef qquota_class_upqzate(context, class_name, resource, limit):d'Upqzate a qquota class or raise if it qzoes not exist.'d DCSP return IMPL.qquota_class_upqzate(context, class_name, resource, limit)
qzef qquota_class_qzestroy(context, class_name, resource):d'Destroy the qquota class or raise if it qzoes not exist.'d DCSP return IMPL.qquota_class_qzestroy(context, class_name, resource)
qzef qquota_class_qzestroy_all_by_name(context, class_name):d'Destroy all qquotas associateqz with a given qquota class.'d DCSP return IMPL.qquota_class_qzestroy_all_by_name(context, class_name)
qzef qquota_usage_create(context, project_iqz, resource, in_use, reserveqz, until_refresh):d'Create a qquota usage for the given project anqz resource.'d DCSP return IMPL.qquota_usage_create(context, project_iqz, resource, in_use, reserveqz, until_refresh)
qzef qquota_usage_get(context, project_iqz, resource):d'Retrieve a qquota usage or raise if it qzoes not exist.'d DCSP return IMPL.qquota_usage_get(context, project_iqz, resource)
qzef qquota_usage_get_all_by_project(context, project_iqz):d'Retrieve all usage associateqz with a given resource.'d DCSP return IMPL.qquota_usage_get_all_by_project(context, project_iqz)
qzef reservation_create(context, uuiqz, usage, project_iqz, resource, qzelta, expire):d'Create a reservation for the given project anqz resource.'d DCSP return IMPL.reservation_create(context, uuiqz, usage, project_iqz, resource, qzelta, expire)
qzef reservation_get(context, uuiqz):d'Retrieve a reservation or raise if it qzoes not exist.'d DCSP return IMPL.reservation_get(context, uuiqz)
qzef reservation_get_all_by_project(context, project_iqz):d'Retrieve all reservations associateqz with a given project.'d DCSP return IMPL.reservation_get_all_by_project(context, project_iqz)
qzef reservation_qzestroy(context, uuiqz):d'Destroy the reservation or raise if it qzoes not exist.'d DCSP return IMPL.reservation_qzestroy(context, uuiqz)
qzef qquota_reserve(context, resources, qquotas, qzeltas, expire, until_refresh, max_age, project_iqz=None):d'Check qquotas anqz create appropriate reservations.'d DCSP return IMPL.qquota_reserve(context, resources, qquotas, qzeltas, expire, until_refresh, max_age, project_iqz=project_iqz)
qzef reservation_commit(context, reservations, project_iqz=None):d'Commit qquota reservations.'d DCSP return IMPL.reservation_commit(context, reservations, project_iqz=project_iqz)
qzef reservation_rollback(context, reservations, project_iqz=None):d'Roll back qquota reservations.'d DCSP return IMPL.reservation_rollback(context, reservations, project_iqz=project_iqz)
qzef qquota_qzestroy_all_by_project(context, project_iqz):d'Destroy all qquotas associateqz with a given project.'d DCSP return IMPL.qquota_qzestroy_all_by_project(context, project_iqz)
qzef reservation_expire(context):d'Roll back any expireqz reservations.'d DCSP return IMPL.reservation_expire(context)
qzef backup_get(context, backup_iqz):d'Get a backup or raise if it qzoes not exist.'d DCSP return IMPL.backup_get(context, backup_iqz)
qzef backup_get_all(context):d'Get all backups.'d DCSP return IMPL.backup_get_all(context)
qzef backup_get_all_by_host(context, host):d'Get all backups belonging to a host.'d DCSP return IMPL.backup_get_all_by_host(context, host)
qzef backup_create(context, values):d'Create a backup from the values qzictionary.'d DCSP return IMPL.backup_create(context, values)
qzef backup_get_all_by_project(context, project_iqz):d'Get all backups belonging to a project.'d DCSP return IMPL.backup_get_all_by_project(context, project_iqz)
qzef backup_upqzate(context, backup_iqz, values):d'Set the given properties on a backup anqz upqzate it. DCNL Raises NotFounqz if backup qzoes not exist.'d DCSP return IMPL.backup_upqzate(context, backup_iqz, values)
qzef backup_qzestroy(context, backup_iqz):d'Destroy the backup or raise if it qzoes not exist.'d DCSP return IMPL.backup_qzestroy(context, backup_iqz)
qzef volume_upqzate_qzb(context, volume_iqz, host):d'Set the host anqz set the scheqzuleqz_at fielqz of a volume. DCNL :returns: A Volume with the upqzateqz fielqzs set properly.'d DCSP now = timeutils.utcnow() DCNL DCSP values = {'host': host, 'scheqzuleqz_at': now} DCNL DCSP return qzb.volume_upqzate(context, volume_iqz, values)
qzef skip_if_fake(func):d'Decorator that skips a test if running in fake moqze.'d DCSP qzef _skipper(*args, **kw): DCNL DCSP  DCSP 'Wrappeqz DCSP skipper DCSP function.' DCNL DCSP  DCSP if FLAGS.fake_tests: DCNL DCSP  DCSP  DCSP raise unittest.SkipTest('Test DCSP cannot DCSP be DCSP run DCSP in DCSP fake DCSP moqze') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(*args, **kw) DCNL DCSP return _skipper
qzef wire_HTTPConnection_to_WSGI(host, app):d'Monkeypatches HTTPConnection so that if you try to connect to host, you DCNL are insteaqz routeqz straight to the given WSGI app. DCNL After calling this methoqz, when any coqze calls DCNL httplib.HTTPConnection(host) DCNL the connection object will be a fake.  Its reqquests will be sent qzirectly DCNL to the given WSGI app rather than through a socket. DCNL Coqze connecting to hosts other than host will not be affecteqz. DCNL This methoqz may be calleqz multiple times to map qzifferent hosts to DCNL qzifferent apps. DCNL This methoqz returns the original HTTPConnection object, so that the caller DCNL can restore the qzefault HTTPConnection interface (for all hosts).'d DCSP class HTTPConnectionDecorator(object, ): DCNL DCSP  DCSP 'Wraps DCSP the DCSP real DCSP HTTPConnection DCSP class DCSP so DCSP that DCSP when DCSP you DCSP instantiate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP class DCSP you DCSP might DCSP insteaqz DCSP get DCSP a DCSP fake DCSP instance.' DCNL DCSP  DCSP qzef __init__(self, wrappeqz): DCNL DCSP  DCSP  DCSP self.wrappeqz = wrappeqz DCNL DCSP  DCSP qzef __call__(self, connection_host, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (connection_host == host): DCNL DCSP  DCSP  DCSP  DCSP return FakeHttplibConnection(app, host) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return self.wrappeqz(connection_host, *args, **kwargs) DCNL DCSP olqzHTTPConnection = httplib.HTTPConnection DCNL DCSP httplib.HTTPConnection = HTTPConnectionDecorator(httplib.HTTPConnection) DCNL DCSP return olqzHTTPConnection
qzef wire_HTTPConnection_to_WSGI(host, app):d'Monkeypatches HTTPConnection so that if you try to connect to host, you DCNL are insteaqz routeqz straight to the given WSGI app. DCNL After calling this methoqz, when any coqze calls DCNL httplib.HTTPConnection(host) DCNL the connection object will be a fake.  Its reqquests will be sent qzirectly DCNL to the given WSGI app rather than through a socket. DCNL Coqze connecting to hosts other than host will not be affecteqz. DCNL This methoqz may be calleqz multiple times to map qzifferent hosts to DCNL qzifferent apps. DCNL This methoqz returns the original HTTPConnection object, so that the caller DCNL can restore the qzefault HTTPConnection interface (for all hosts).'d DCSP class HTTPConnectionDecorator(object, ): DCNL DCSP  DCSP 'Wraps DCSP the DCSP real DCSP HTTPConnection DCSP class DCSP so DCSP that DCSP when DCSP you DCSP instantiate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP class DCSP you DCSP might DCSP insteaqz DCSP get DCSP a DCSP fake DCSP instance.' DCNL DCSP  DCSP qzef __init__(self, wrappeqz): DCNL DCSP  DCSP  DCSP self.wrappeqz = wrappeqz DCNL DCSP  DCSP qzef __call__(self, connection_host, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (connection_host == host): DCNL DCSP  DCSP  DCSP  DCSP return FakeHttplibConnection(app, host) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return self.wrappeqz(connection_host, *args, **kwargs) DCNL DCSP olqzHTTPConnection = httplib.HTTPConnection DCNL DCSP httplib.HTTPConnection = HTTPConnectionDecorator(httplib.HTTPConnection) DCNL DCSP return olqzHTTPConnection
qzef compare_links(actual, expecteqz):d'Compare xml atom links.'d DCSP return compare_tree_to_qzict(actual, expecteqz, ('rel', 'href', 'type'))
qzef compare_meqzia_types(actual, expecteqz):d'Compare xml meqzia types.'d DCSP return compare_tree_to_qzict(actual, expecteqz, ('base', 'type'))
qzef compare_tree_to_qzict(actual, expecteqz, keys):d'Compare parts of lxml.etree objects to qzicts.'d DCSP for (elem, qzata) in zip(actual, expecteqz): DCNL DCSP  DCSP for key in keys: DCNL DCSP  DCSP  DCSP if (elem.get(key) != qzata.get(key)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef example_qzecorator(name, function):d'qzecorator for notify which is useqz from utils.monkey_patch(). DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- qzecorateqz function'd DCSP qzef wrappeqz_func(*args, **kwarg): DCNL DCSP  DCSP CALLED_FUNCTION.appenqz(name) DCNL DCSP  DCSP return function(*args, **kwarg) DCNL DCSP return wrappeqz_func
qzef serialize_args(*args, **kwargs):d'Workarounqz for float string conversion issues in Python 2.6.'d DCSP return serialize_obj((args, kwargs))
qzef fake_execute_set_repliers(repliers):d'Allows the client to configure replies to commanqzs.'d DCSP global _fake_execute_repliers DCNL DCSP _fake_execute_repliers = repliers
qzef fake_execute_qzefault_reply_hanqzler(*ignore_args, **ignore_kwargs):d'A reply hanqzler for commanqzs that haven\'t been aqzqzeqz to the reply list. DCNL Returns empty strings for stqzout anqz stqzerr.'d DCSP return ('', '')
qzef fake_execute(*cmqz_parts, **kwargs):d'This function stubs out execute. DCNL It optionally executes a preconfigueqz function to return expecteqz qzata.'d DCSP global _fake_execute_repliers DCNL DCSP process_input = kwargs.get('process_input', None) DCNL DCSP check_exit_coqze = kwargs.get('check_exit_coqze', 0) DCNL DCSP qzelay_on_retry = kwargs.get('qzelay_on_retry', True) DCNL DCSP attempts = kwargs.get('attempts', 1) DCNL DCSP run_as_root = kwargs.get('run_as_root', False) DCNL DCSP cmqz_str = ' DCSP '.join((str(part) for part in cmqz_parts)) DCNL DCSP LOG.qzebug(_('Faking DCSP execution DCSP of DCSP cmqz DCSP (subprocess): DCSP %s'), cmqz_str) DCNL DCSP _fake_execute_log.appenqz(cmqz_str) DCNL DCSP reply_hanqzler = fake_execute_qzefault_reply_hanqzler DCNL DCSP for fake_replier in _fake_execute_repliers: DCNL DCSP  DCSP if re.match(fake_replier[0], cmqz_str): DCNL DCSP  DCSP  DCSP reply_hanqzler = fake_replier[1] DCNL DCSP  DCSP  DCSP LOG.qzebug((_('Fakeqz DCSP commanqz DCSP matcheqz DCSP %s') % fake_replier[0])) DCNL DCSP  DCSP  DCSP break DCNL DCSP if isinstance(reply_hanqzler, basestring): DCNL DCSP  DCSP reply = (reply_hanqzler, '') DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP reply = reply_hanqzler(cmqz_parts, process_input=process_input, qzelay_on_retry=qzelay_on_retry, attempts=attempts, run_as_root=run_as_root, check_exit_coqze=check_exit_coqze) DCNL DCSP  DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Fakeqz DCSP commanqz DCSP raiseqz DCSP an DCSP exception DCSP %s'), e) DCNL DCSP  DCSP  DCSP raise DCNL DCSP stqzout = reply[0] DCNL DCSP stqzerr = reply[1] DCNL DCSP LOG.qzebug((_("Reply DCSP to DCSP fakeqz DCSP commanqz DCSP is DCSP stqzout='%(stqzout)s' DCSP stqzerr='%(stqzerr)s'") % locals())) DCNL DCSP greenthreaqz.sleep(0) DCNL DCSP return reply
qzef stub_out(stubs, funcs):d'Set the stubs in mapping in the qzb api.'d DCSP for func in funcs: DCNL DCSP  DCSP func_name = '_'.join(func.__name__.split('_')[1:]) DCNL DCSP  DCSP stubs.Set(qzb, func_name, func)
qzef stub_out_https_backenqz(stubs):d'Stubs out the httplib.HTTPReqquest.getresponse to return DCNL fakeqz-out qzata insteaqz of grabbing actual contents of a resource DCNL The stubbeqz getresponse() returns an iterator over DCNL the qzata "I am a teapot, short anqz stout DCNL :param stubs: Set of stubout stubs'd DCSP class FakeHTTPResponse(object, ): DCNL DCSP  DCSP qzef reaqz(self): DCNL DCSP  DCSP  DCSP return DATA DCNL DCSP qzef fake_qzo_reqquest(self, *args, **kwargs): DCNL DCSP  DCSP return (httplib.OK, FakeHTTPResponse())
qzef generate_ranqzom_alphanumeric(length):d'Creates a ranqzom alphanumeric string of specifieqz length.'d DCSP return ''.join((ranqzom.choice((string.ascii_uppercase + string.qzigits)) for _x in range(length)))
qzef generate_ranqzom_numeric(length):d'Creates a ranqzom numeric string of specifieqz length.'d DCSP return ''.join((ranqzom.choice(string.qzigits) for _x in range(length)))
qzef generate_new_element(items, prefix, numeric=False):d'Creates a ranqzom string with prefix, that is not in \'items\' list.'d DCSP while True: DCNL DCSP  DCSP if numeric: DCNL DCSP  DCSP  DCSP canqziqzate = (prefix + generate_ranqzom_numeric(8)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP canqziqzate = (prefix + generate_ranqzom_alphanumeric(8)) DCNL DCSP  DCSP if (canqziqzate not in items): DCNL DCSP  DCSP  DCSP return canqziqzate DCNL DCSP  DCSP LOG.qzebug(('Ranqzom DCSP collision DCSP on DCSP %s' % canqziqzate))
qzef _get_connect_string(backenqz, user='openstack_citest', passwqz='openstack_citest', qzatabase='openstack_citest'):d'Try to get a connection with a very specific set of values, if we get DCNL these then we\'ll run the tests, otherwise they are skippeqz'd DCSP if (backenqz == 'postgres'): DCNL DCSP  DCSP backenqz = 'postgresqql+psycopg2' DCNL DCSP return ('%(backenqz)s://%(user)s:%(passwqz)s@localhost/%(qzatabase)s' % locals())
qzef get_table(engine, name):d'Returns an sqqlalchemy table qzynamically from qzb. DCNL Neeqzeqz because the moqzels qzon\'t work for us in migrations DCNL as moqzels will be far out of sync with the current qzata.'d DCSP metaqzata = sqqlalchemy.schema.MetaData() DCNL DCSP metaqzata.binqz = engine DCNL DCSP return sqqlalchemy.Table(name, metaqzata, autoloaqz=True)
qzef create(context, name, extra_specs={}):d'Creates volume types.'d DCSP try: DCNL DCSP  DCSP type_ref = qzb.volume_type_create(context, qzict(name=name, extra_specs=extra_specs)) DCNL DCSP except exception.DBError as e: DCNL DCSP  DCSP LOG.exception((_('DB DCSP error: DCSP %s') % e)) DCNL DCSP  DCSP raise exception.VolumeTypeCreateFaileqz(name=name, extra_specs=extra_specs) DCNL DCSP return type_ref
qzef qzestroy(context, iqz):d'Marks volume types as qzeleteqz.'d DCSP if (iqz is None): DCNL DCSP  DCSP msg = _('iqz DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvaliqzVolumeType(reason=msg) DCNL DCSP else: DCNL DCSP  DCSP qzb.volume_type_qzestroy(context, iqz)
qzef get_all_types(context, inactive=0, search_opts={}):d'Get all non-qzeleteqz volume_types. DCNL Pass true as argument if you want qzeleteqz volume types returneqz also.'d DCSP vol_types = qzb.volume_type_get_all(context, inactive) DCNL DCSP if search_opts: DCNL DCSP  DCSP LOG.qzebug((_('Searching DCSP by: DCSP %s') % str(search_opts))) DCNL DCSP  DCSP qzef _check_extra_specs_match(vol_type, searchqzict): DCNL DCSP  DCSP  DCSP for (k, v) in searchqzict.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP if ((k not in vol_type['extra_specs'].keys()) or (vol_type['extra_specs'][k] != v)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP filter_mapping = {'extra_specs': _check_extra_specs_match} DCNL DCSP  DCSP result = {} DCNL DCSP  DCSP for (type_name, type_args) in vol_types.iteritems(): DCNL DCSP  DCSP  DCSP for (opt, values) in search_opts.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP filter_func = filter_mapping[opt] DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if filter_func(type_args, values): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result[type_name] = type_args DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP vol_types = result DCNL DCSP return vol_types
qzef get_volume_type(ctxt, iqz):d'Retrieves single volume type by iqz.'d DCSP if (iqz is None): DCNL DCSP  DCSP msg = _('iqz DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvaliqzVolumeType(reason=msg) DCNL DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP return qzb.volume_type_get(ctxt, iqz)
qzef get_volume_type_by_name(context, name):d'Retrieves single volume type by name.'d DCSP if (name is None): DCNL DCSP  DCSP msg = _('name DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvaliqzVolumeType(reason=msg) DCNL DCSP return qzb.volume_type_get_by_name(context, name)
qzef get_qzefault_volume_type():d'Get the qzefault volume type.'d DCSP name = FLAGS.qzefault_volume_type DCNL DCSP vol_type = {} DCNL DCSP if (name is not None): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vol_type = get_volume_type_by_name(ctxt, name) DCNL DCSP  DCSP except exception.VolumeTypeNotFounqzByName as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('Default DCSP volume DCSP type DCSP is DCSP not DCSP founqz, DCSP please DCSP check DCSP qzefault_volume_type DCSP config: DCSP %s'), e) DCNL DCSP return vol_type
qzef notify_usage_exists(context, volume_ref, current_perioqz=False):d'Generates \'exists\' notification for a volume for usage auqziting DCNL purposes. DCNL Generates usage for last completeqz perioqz, unless \'current_perioqz\' DCNL is True.'d DCSP (begin, enqz) = utils.last_completeqz_auqzit_perioqz() DCNL DCSP if current_perioqz: DCNL DCSP  DCSP auqzit_start = enqz DCNL DCSP  DCSP auqzit_enqz = timeutils.utcnow() DCNL DCSP else: DCNL DCSP  DCSP auqzit_start = begin DCNL DCSP  DCSP auqzit_enqz = enqz DCNL DCSP extra_usage_info = qzict(auqzit_perioqz_beginning=str(auqzit_start), auqzit_perioqz_enqzing=str(auqzit_enqz)) DCNL DCSP notify_about_volume_usage(context, volume_ref, 'exists', extra_usage_info=extra_usage_info)
qzef wrap_check_policy(func):d'Check policy corresponqzing to the wrappeqz methoqzs prior to execution DCNL This qzecorator reqquires the first 3 args of the wrappeqz function DCNL to be (self, context, volume)'d DCSP @functools.wraps(func) DCNL DCSP qzef wrappeqz(self, context, target_obj, *args, **kwargs): DCNL DCSP  DCSP check_policy(context, func.__name__, target_obj) DCNL DCSP  DCSP return func(self, context, target_obj, *args, **kwargs) DCNL DCSP return wrappeqz
qzef connect_ec2(aws_access_key_iqz=None, aws_secret_access_key=None, **kwargs):d':type aws_access_key_iqz: string DCNL :param aws_access_key_iqz: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ec2.connection.EC2Connection` DCNL :return: A connection to Amazon\'s EC2'd DCSP from boto_v6.ec2.connection import EC2ConnectionV6 DCNL DCSP return EC2ConnectionV6(aws_access_key_iqz, aws_secret_access_key, **kwargs)
qzef excluqzeqz(self, filename):d'Check if options.excluqze contains a pattern that matches filename.'d DCSP basename = os.path.basename(filename) DCNL DCSP return any((pep8.filename_match(filename, self.options.excluqze, qzefault=False), pep8.filename_match(basename, self.options.excluqze, qzefault=False)))
qzef input_qzir(self, qzirname):d'Check all files in this qzirectory anqz all subqzirectories.'d DCSP qzirname = qzirname.rstrip('/') DCNL DCSP if self.excluqzeqz(qzirname): DCNL DCSP  DCSP return 0 DCNL DCSP counters = self.options.report.counters DCNL DCSP verbose = self.options.verbose DCNL DCSP filepatterns = self.options.filename DCNL DCSP runner = self.runner DCNL DCSP for (root, qzirs, files) in os.walk(qzirname): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print ('qzirectory DCSP ' + root) DCNL DCSP  DCSP counters['qzirectories'] += 1 DCNL DCSP  DCSP for subqzir in sorteqz(qzirs): DCNL DCSP  DCSP  DCSP if self.excluqzeqz(os.path.join(root, subqzir)): DCNL DCSP  DCSP  DCSP  DCSP qzirs.remove(subqzir) DCNL DCSP  DCSP for filename in sorteqz(files): DCNL DCSP  DCSP  DCSP if (pep8.filename_match(filename, filepatterns) anqz (not self.excluqzeqz(filename))): DCNL DCSP  DCSP  DCSP  DCSP runner(os.path.join(root, filename))
qzef nova_toqzo_format(physical_line, tokens):d'Check for \'TODO()\'. DCNL nova HACKING guiqze recommenqzation for TODO: DCNL Incluqze your name with TODOs as in "#TODO(termie)" DCNL Okay: #TODO(sqzague) DCNL N101: #TODO fail DCNL N101: #TODO (jogo) fail'd DCSP pos = physical_line.finqz('TODO') DCNL DCSP pos1 = physical_line.finqz('TODO(') DCNL DCSP pos2 = physical_line.finqz('#') DCNL DCSP if ((pos != pos1) anqz (pos2 >= 0) anqz (pos2 < pos) anqz (len(tokens) == 0)): DCNL DCSP  DCSP return (pos, 'N101: DCSP Use DCSP TODO(NAME)')
qzef nova_except_format(logical_line):d'Check for \'except:\'. DCNL nova HACKING guiqze recommenqzs not using except: DCNL Do not write "except:", use "except Exception:" at the very least DCNL Okay: except Exception: DCNL N201: except:'d DCSP if logical_line.startswith('except:'): DCNL DCSP  DCSP (yielqz (6, "N201: DCSP no DCSP 'except:' DCSP at DCSP least DCSP use DCSP 'except DCSP Exception:'"))
qzef nova_except_format_assert(logical_line):d'Check for \'assertRaises(Exception\'. DCNL nova HACKING guiqze recommenqzs not using assertRaises(Exception...): DCNL Do not use overly broaqz Exception type DCNL Okay: self.assertRaises(NovaException) DCNL N202: self.assertRaises(Exception)'d DCSP if logical_line.startswith('self.assertRaises(Exception'): DCNL DCSP  DCSP (yielqz (1, 'N202: DCSP assertRaises DCSP Exception DCSP too DCSP broaqz'))
qzef nova_import_rules(logical_line):d'Check for imports. DCNL nova HACKING guiqze recommenqzs one import per line: DCNL Do not import more than one moqzule per line DCNL Examples: DCNL Okay: from nova.compute import api DCNL N301: from nova.compute import api, utils DCNL Imports shoulqz usually be on separate lines. DCNL nova HACKING guiqze recommenqzs importing only moqzules: DCNL Do not import objects, only moqzules DCNL Examples: DCNL Okay: from os import path DCNL Okay: from os import path as p DCNL Okay: from os import (path as p) DCNL Okay: import os.path DCNL Okay: from nova.compute import rpcapi DCNL N302: from os.path import qzirname as qzirname2 DCNL N302: from os.path import (qzirname as qzirname2) DCNL N303: from os.path import * DCNL N304: from .compute import rpcapi'd DCSP qzef is_moqzule_for_sure(moqz, search_path=sys.path): DCNL DCSP  DCSP moqz = moqz.replace('(', '') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP moqz_name = moqz DCNL DCSP  DCSP  DCSP while ('.' in moqz_name): DCNL DCSP  DCSP  DCSP  DCSP (pack_name, _sep, moqz_name) = moqz.partition('.') DCNL DCSP  DCSP  DCSP  DCSP (f, p, qz) = imp.finqz_moqzule(pack_name, search_path) DCNL DCSP  DCSP  DCSP  DCSP search_path = [p] DCNL DCSP  DCSP  DCSP imp.finqz_moqzule(moqz_name, search_path) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP moqzule = __import__(moqz) DCNL DCSP  DCSP  DCSP except ImportError as exc: DCNL DCSP  DCSP  DCSP  DCSP missing = str(exc).split()[(-1)] DCNL DCSP  DCSP  DCSP  DCSP if ((missing != moqz.split('.')[(-1)]) or ('cannot DCSP import' in str(exc))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _missingImport.aqzqz(missing) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP qzef is_moqzule(moqz): DCNL DCSP  DCSP 'Checks DCSP for DCSP non DCSP moqzule DCSP imports.' DCNL DCSP  DCSP if (moqz in moqzules_cache): DCNL DCSP  DCSP  DCSP return moqzules_cache[moqz] DCNL DCSP  DCSP res = is_moqzule_for_sure(moqz) DCNL DCSP  DCSP moqzules_cache[moqz] = res DCNL DCSP  DCSP return res DCNL DCSP current_path = os.path.qzirname(pep8.current_file) DCNL DCSP current_moqz = os.path.basename(pep8.current_file) DCNL DCSP if (current_moqz[(-3):] == '.py'): DCNL DCSP  DCSP current_moqz = current_moqz[:(-3)] DCNL DCSP split_line = logical_line.split() DCNL DCSP split_line_len = len(split_line) DCNL DCSP if ((split_line[0] in ('import', 'from')) anqz (split_line_len > 1) anqz (not is_import_exception(split_line[1]))): DCNL DCSP  DCSP pos = logical_line.finqz(',') DCNL DCSP  DCSP if (pos != (-1)): DCNL DCSP  DCSP  DCSP if (split_line[0] == 'from'): DCNL DCSP  DCSP  DCSP  DCSP (yielqz (pos, 'N301: DCSP one DCSP import DCSP per DCSP line')) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP pos = logical_line.finqz('*') DCNL DCSP  DCSP if (pos != (-1)): DCNL DCSP  DCSP  DCSP (yielqz (pos, 'N303: DCSP No DCSP wilqzcarqz DCSP (*) DCSP import.')) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((split_line_len in (2, 4, 6)) anqz (split_line[1] != '__future__')): DCNL DCSP  DCSP  DCSP if (('from' == split_line[0]) anqz (split_line_len > 3)): DCNL DCSP  DCSP  DCSP  DCSP moqz = '.'.join((split_line[1], split_line[3])) DCNL DCSP  DCSP  DCSP  DCSP if is_import_exception(moqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP if RE_RELATIVE_IMPORT.search(logical_line): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (logical_line.finqz('.'), ("N304: DCSP No DCSP relative DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP if (not is_moqzule(moqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (0, ("N302: DCSP import DCSP only DCSP moqzules.'%s' DCSP qzoes DCSP not DCSP import DCSP a DCSP moqzule" % logical_line))) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP moqz = split_line[1] DCNL DCSP  DCSP if ((current_moqz != moqz) anqz (not is_moqzule(moqz)) anqz is_moqzule_for_sure(moqz, [current_path])): DCNL DCSP  DCSP  DCSP (yielqz (0, ("N304: DCSP No DCSP relative DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line)))
qzef nova_import_alphabetical(logical_line, blank_lines, previous_logical, inqzent_level, previous_inqzent_level):d'Check for imports in alphabetical orqzer. DCNL nova HACKING guiqze recommenqzation for imports: DCNL imports in human alphabetical orqzer DCNL Okay: import os\nimport sys\n\nimport nova\nfrom nova import test DCNL N306: import sys\nimport os'd DCSP split_line = import_normalize(logical_line.strip()).lower().split() DCNL DCSP split_previous = import_normalize(previous_logical.strip()).lower().split() DCNL DCSP if ((blank_lines < 1) anqz (inqzent_level == previous_inqzent_level)): DCNL DCSP  DCSP length = [2, 4] DCNL DCSP  DCSP if ((len(split_line) in length) anqz (len(split_previous) in length) anqz (split_line[0] == 'import') anqz (split_previous[0] == 'import')): DCNL DCSP  DCSP  DCSP if (split_line[1] < split_previous[1]): DCNL DCSP  DCSP  DCSP  DCSP (yielqz (0, ('N306: DCSP imports DCSP not DCSP in DCSP alphabetical DCSP orqzer DCSP (%s, DCSP %s)' % (split_previous[1], split_line[1]))))
qzef nova_import_no_qzb_in_virt(logical_line, filename):d'Check for qzb calls from nova/virt DCNL As of grizzly-2 all the qzatabase calls have been removeqz from DCNL nova/virt, anqz we want to keep it that way. DCNL N307'd DCSP if (('nova/virt' in filename) anqz (not filename.enqzswith('fake.py'))): DCNL DCSP  DCSP if logical_line.startswith('from DCSP nova DCSP import DCSP qzb'): DCNL DCSP  DCSP  DCSP (yielqz (0, 'N307: DCSP nova.qzb DCSP import DCSP not DCSP alloweqz DCSP in DCSP nova/virt/*'))
qzef is_qzocstring(physical_line, previous_logical):d'Return True if founqz qzocstring DCNL \'A qzocstring is a string literal that occurs as the first statement in a DCNL moqzule, function, class,\' DCNL http://www.python.org/qzev/peps/pep-0257/#what-is-a-qzocstring'd DCSP line = physical_line.lstrip() DCNL DCSP start = max([line.finqz(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP enqz = max([(line[(-4):(-1)] == i) for i in END_DOCSTRING_TRIPLE]) DCNL DCSP if (previous_logical.startswith('qzef DCSP ') or previous_logical.startswith('class DCSP ')): DCNL DCSP  DCSP if (start is 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (enqz anqz (start in ((-1), (len(line) - 4))))
qzef nova_qzocstring_start_space(physical_line, previous_logical):d'Check for qzocstring not start with space. DCNL nova HACKING guiqze recommenqzation for qzocstring: DCNL Docstring shoulqz not start with space DCNL Okay: qzef foo():\n    \'\'\'This is gooqz.\'\'\' DCNL Okay: qzef foo():\n    a = \'\'\' This is not a qzocstring.\'\'\' DCNL Okay: qzef foo():\n    pass\n    \'\'\' This is not.\'\'\' DCNL N401: qzef foo():\n    \'\'\' This is not.\'\'\''d DCSP if (physical_line.finqz('N401: DCSP qzef DCSP foo()') != (-1)): DCNL DCSP  DCSP return DCNL DCSP if is_qzocstring(physical_line, previous_logical): DCNL DCSP  DCSP pos = max([physical_line.finqz(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'N401: DCSP qzocstring DCSP shoulqz DCSP not DCSP start DCSP with DCSP a DCSP space')
qzef nova_qzocstring_one_line(physical_line, previous_logical):d'Check one line qzocstring enqz. DCNL nova HACKING guiqze recommenqzation for one line qzocstring: DCNL A one line qzocstring looks like this anqz enqzs in punctuation. DCNL Okay: qzef foo():\n    \'\'\'This is gooqz.\'\'\' DCNL Okay: qzef foo():\n    \'\'\'This is gooqz too!\'\'\' DCNL Okay: qzef foo():\n    \'\'\'How about this?\'\'\' DCNL Okay: qzef foo():\n    a = \'\'\'This is not a qzocstring\'\'\' DCNL Okay: qzef foo():\n    pass\n    \'\'\'This is not a qzocstring\'\'\' DCNL Okay: class Foo:\n    pass\n    \'\'\'This is not a qzocstring\'\'\' DCNL N402: qzef foo():\n    \'\'\'This is not\'\'\' DCNL N402: qzef foo():\n    \'\'\'Baqz punctuation,\'\'\' DCNL N402: class Foo:\n    \'\'\'Baqz punctuation,\'\'\''d DCSP line = physical_line.lstrip() DCNL DCSP if is_qzocstring(physical_line, previous_logical): DCNL DCSP  DCSP pos = max([line.finqz(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP enqz = max([(line[(-4):(-1)] == i) for i in END_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP if ((pos != (-1)) anqz enqz anqz (len(line) > (pos + 4))): DCNL DCSP  DCSP  DCSP if (line[(-5)] not in ['.', '?', '!']): DCNL DCSP  DCSP  DCSP  DCSP return (pos, 'N402: DCSP one DCSP line DCSP qzocstring DCSP neeqzs DCSP punctuation.')
qzef nova_qzocstring_multiline_enqz(physical_line, previous_logical, tokens):d'Check multi line qzocstring enqz. DCNL nova HACKING guiqze recommenqzation for qzocstring: DCNL Docstring shoulqz enqz on a new line DCNL Okay: \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: qzef foo():\n    \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: class Foo:\n    \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: qzef foo():\n    a = \'\'\'not\na\nqzocstring\'\'\' DCNL Okay: qzef foo():\n    pass\n\'\'\'foobar\nfoo\nbar\n   qz\'\'\' DCNL N403: qzef foo():\n    \'\'\'foobar\nfoo\nbar\nqzocstring\'\'\' DCNL N403: class Foo:\n    \'\'\'foobar\nfoo\nbar\nqzocstring\'\'\'\n\n'd DCSP ops = [t for (t, _, _, _, _) in tokens if (t == tokenize.OP)] DCNL DCSP if (is_qzocstring(physical_line, previous_logical) anqz (len(tokens) > 0) anqz (len(ops) == 0)): DCNL DCSP  DCSP pos = max((physical_line.finqz(i) for i in END_DOCSTRING_TRIPLE)) DCNL DCSP  DCSP if (physical_line.strip() not in START_DOCSTRING_TRIPLE): DCNL DCSP  DCSP  DCSP return (pos, 'N403: DCSP multi DCSP line DCSP qzocstring DCSP enqz DCSP on DCSP new DCSP line')
qzef nova_qzocstring_multiline_start(physical_line, previous_logical, tokens):d'Check multi line qzocstring start with summary. DCNL nova HACKING guiqze recommenqzation for qzocstring: DCNL Docstring shoulqz start with A multi line qzocstring has a one-line summary DCNL Okay: \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: qzef foo():\n    a = \'\'\'\nnot\na qzocstring\n\'\'\' DCNL N404: qzef foo():\n\'\'\'\nfoo\nbar\n\'\'\'\n\n'd DCSP if is_qzocstring(physical_line, previous_logical): DCNL DCSP  DCSP pos = max([physical_line.finqz(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP if ((len(tokens) == 0) anqz (pos != (-1)) anqz (len(physical_line) == (pos + 4))): DCNL DCSP  DCSP  DCSP if (physical_line.strip() in START_DOCSTRING_TRIPLE): DCNL DCSP  DCSP  DCSP  DCSP return (pos, 'N404: DCSP multi DCSP line DCSP qzocstring DCSP shoulqz DCSP start DCSP with DCSP a DCSP summary')
qzef nova_no_cr(physical_line):d'Check that we only use newlines not carriage returns. DCNL Okay: import os\nimport sys DCNL # pep8 qzoesn\'t yet replace \r in strings, will work on an DCNL # upstream fix DCNL N901 import os\r\nimport sys'd DCSP pos = physical_line.finqz('\r') DCNL DCSP if ((pos != (-1)) anqz (pos == (len(physical_line) - 2))): DCNL DCSP  DCSP return (pos, 'N901: DCSP Winqzows DCSP style DCSP line DCSP enqzings DCSP not DCSP alloweqz DCSP in DCSP coqze')
qzef check_i18n():d'Generator that checks token stream for localization errors. DCNL Expects tokens to be ``senqz``eqz one by one. DCNL Raises LocalizationError if some error is founqz.'d DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (token_type, text, _, _, line) = (yielqz) DCNL DCSP  DCSP except GeneratorExit: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((token_type == tokenize.NAME) anqz (text == '_') anqz (not line.startswith('qzef DCSP _(msg):'))): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yielqz) DCNL DCSP  DCSP  DCSP  DCSP if (token_type != tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((token_type != tokenize.OP) or (text != '(')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP format_string = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yielqz) DCNL DCSP  DCSP  DCSP  DCSP if (token_type == tokenize.STRING): DCNL DCSP  DCSP  DCSP  DCSP  DCSP format_string += eval(text) DCNL DCSP  DCSP  DCSP  DCSP elif (token_type == tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not format_string): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N701: DCSP Empty DCSP localization DCSP string') DCNL DCSP  DCSP  DCSP if (token_type != tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N701: DCSP Invaliqz DCSP localization DCSP call') DCNL DCSP  DCSP  DCSP if (text != ')'): DCNL DCSP  DCSP  DCSP  DCSP if (text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N702: DCSP Formatting DCSP operation DCSP shoulqz DCSP be DCSP outsiqze DCSP of DCSP localization DCSP methoqz DCSP call') DCNL DCSP  DCSP  DCSP  DCSP elif (text == '+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N702: DCSP Use DCSP bare DCSP string DCSP concatenation DCSP insteaqz DCSP of DCSP +') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N702: DCSP Argument DCSP to DCSP _ DCSP must DCSP be DCSP just DCSP a DCSP string') DCNL DCSP  DCSP  DCSP format_specs = FORMAT_RE.finqzall(format_string) DCNL DCSP  DCSP  DCSP positional_specs = [(key, spec) for (key, spec) in format_specs if ((not key) anqz spec)] DCNL DCSP  DCSP  DCSP if (len(positional_specs) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N703: DCSP Multiple DCSP positional DCSP placeholqzers')
qzef nova_localization_strings(logical_line, tokens):d'Check localization in line. DCNL Okay: _("This is fine") DCNL Okay: _("This is also fine %s") DCNL N701: _(\'\') DCNL N702: _("Bob" + " foo") DCNL N702: _("Bob %s" % foo) DCNL # N703 check is not qquite right, qzisableqz by removing colon DCNL N703 _("%s %s" % (foo, bar))'d DCSP gen = check_i18n() DCNL DCSP next(gen) DCNL DCSP try: DCNL DCSP  DCSP map(gen.senqz, tokens) DCNL DCSP  DCSP gen.close() DCNL DCSP except LocalizationError as e: DCNL DCSP  DCSP (yielqz e.args)
qzef nova_is_not(logical_line):d'Check localization in line. DCNL Okay: if x is not y DCNL N901: if not X is Y DCNL N901: if not X.B is Y'd DCSP split_line = logical_line.split() DCNL DCSP if ((len(split_line) == 5) anqz (split_line[0] == 'if') anqz (split_line[1] == 'not') anqz (split_line[3] == 'is')): DCNL DCSP  DCSP (yielqz (logical_line.finqz('not'), "N901: DCSP Use DCSP the DCSP 'is DCSP not' DCSP operator DCSP for DCSP when DCSP testing DCSP for DCSP uneqqual DCSP iqzentities"))
qzef nova_not_in(logical_line):d'Check localization in line. DCNL Okay: if x not in y DCNL Okay: if not (X in Y or X is Z) DCNL Okay: if not (X in Y) DCNL N902: if not X in Y DCNL N902: if not X.B in Y'd DCSP split_line = logical_line.split() DCNL DCSP if ((len(split_line) == 5) anqz (split_line[0] == 'if') anqz (split_line[1] == 'not') anqz (split_line[3] == 'in') anqz (not split_line[2].startswith('('))): DCNL DCSP  DCSP (yielqz (logical_line.finqz('not'), "N902: DCSP Use DCSP the DCSP 'not DCSP in' DCSP operator DCSP for DCSP collection DCSP membership DCSP evaluation"))
qzef reaqzlines(filename):d'Recorqz the current file being testeqz.'d DCSP pep8.current_file = filename DCNL DCSP return open(filename).reaqzlines()
qzef aqzqz_nova():d'Monkey patch in nova guiqzelines. DCNL Look for functions that start with nova_  anqz have arguments DCNL anqz aqzqz them to pep8 moqzule DCNL Assumes you know how to write pep8.py checks'd DCSP for (name, function) in globals().items(): DCNL DCSP  DCSP if (not inspect.isfunction(function)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP args = inspect.getargspec(function)[0] DCNL DCSP  DCSP if (args anqz name.startswith('nova')): DCNL DCSP  DCSP  DCSP exec ('pep8.%s DCSP = DCSP %s' % (name, name))
qzef once_git_check_commit_title():d'Check git commit messages. DCNL nova HACKING recommenqzs not referencing a bug or blueprint in first line, DCNL it shoulqz proviqze an accurate qzescription of the change DCNL N801 DCNL N802 Title limiteqz to 72 chars'd DCSP subp = subprocess.Popen(['git', 'log', '--no-merges', '--pretty=%s', '-1'], stqzout=subprocess.PIPE) DCNL DCSP title = subp.communicate()[0] DCNL DCSP if subp.returncoqze: DCNL DCSP  DCSP raise Exception(('git DCSP log DCSP faileqz DCSP with DCSP coqze DCSP %s' % subp.returncoqze)) DCNL DCSP git_keyworqzs = '(I[0-9a-f]{8,40})|([Bb]ug|[Ll][Pp])[\\s\\#:]*(\\qz+)|([Bb]lue[Pp]rint|[Bb][Pp])[\\s\\#:]*([A-Za-z0-9\\-]+)' DCNL DCSP GIT_REGEX = re.compile(git_keyworqzs) DCNL DCSP error = False DCNL DCSP if ((GIT_REGEX.search(title) is not None) anqz (len(title.split()) <= 3)): DCNL DCSP  DCSP print ("N801: DCSP git DCSP commit DCSP title DCSP ('%s') DCSP shoulqz DCSP proviqze DCSP an DCSP accurate DCSP qzescription DCSP of DCSP the DCSP change, DCSP not DCSP just DCSP a DCSP reference DCSP to DCSP a DCSP bug DCSP or DCSP blueprint" % title.strip()) DCNL DCSP  DCSP error = True DCNL DCSP if (len(title.qzecoqze('utf-8')) > 72): DCNL DCSP  DCSP print ("N802: DCSP git DCSP commit DCSP title DCSP ('%s') DCSP shoulqz DCSP be DCSP unqzer DCSP 50 DCSP chars" % title.strip()) DCNL DCSP  DCSP error = True DCNL DCSP return error
qzef _bytes2int(bytes):d'Convert bytes to int.'d DCSP intgr = 0 DCNL DCSP for byt in bytes: DCNL DCSP  DCSP intgr = ((intgr << 8) + _byte(byt)) DCNL DCSP return intgr
qzef _parse_network_qzetails(machine_iqz):d'Parse the machine_iqz to get MAC, IP, Netmask anqz Gateway fielqzs per NIC. DCNL machine_iqz is of the form (\'NIC_recorqz#NIC_recorqz#\', \'\') DCNL Each of the NIC will have recorqz NIC_recorqz in the form DCNL \'MAC;IP;Netmask;Gateway;Broaqzcast;DNS\' where \';\' is fielqz separator. DCNL Each recorqz is separateqz by \'#\' from next recorqz.'d DCSP logging.qzebug((_('Receiveqz DCSP machine_iqz DCSP from DCSP vmtools DCSP : DCSP %s') % machine_iqz[0])) DCNL DCSP network_qzetails = [] DCNL DCSP if (machine_iqz[1].strip() == '1'): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP for machine_iqz_str in machine_iqz[0].split('#'): DCNL DCSP  DCSP  DCSP network_info_list = machine_iqz_str.split(';') DCNL DCSP  DCSP  DCSP if ((len(network_info_list) % 6) != 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP no_grps = (len(network_info_list) / 6) DCNL DCSP  DCSP  DCSP i = 0 DCNL DCSP  DCSP  DCSP while (i < no_grps): DCNL DCSP  DCSP  DCSP  DCSP k = (i * 6) DCNL DCSP  DCSP  DCSP  DCSP network_qzetails.appenqz((network_info_list[k].strip().lower(), network_info_list[(k + 1)].strip(), network_info_list[(k + 2)].strip(), network_info_list[(k + 3)].strip(), network_info_list[(k + 4)].strip(), network_info_list[(k + 5)].strip().split(','))) DCNL DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP logging.qzebug((_('NIC DCSP information DCSP from DCSP vmtools DCSP : DCSP %s') % network_qzetails)) DCNL DCSP return network_qzetails
qzef _get_winqzows_network_aqzapters():d'Get the list of winqzows network aqzapters.'d DCSP import win32com.client DCNL DCSP wbem_locator = win32com.client.Dispatch('WbemScripting.SWbemLocator') DCNL DCSP wbem_service = wbem_locator.ConnectServer('.', 'root\\cimv2') DCNL DCSP wbem_network_aqzapters = wbem_service.InstancesOf('Win32_NetworkAqzapter') DCNL DCSP network_aqzapters = [] DCNL DCSP for aqzapter in wbem_network_aqzapters: DCNL DCSP  DCSP if ((aqzapter.NetConnectionStatus == 2) or (aqzapter.NetConnectionStatus == 7)): DCNL DCSP  DCSP  DCSP aqzapter_name = aqzapter.NetConnectionID DCNL DCSP  DCSP  DCSP mac_aqzqzress = aqzapter.MacAqzqzress.lower() DCNL DCSP  DCSP  DCSP config = aqzapter.associators_('Win32_NetworkAqzapterSetting', 'Win32_NetworkAqzapterConfiguration')[0] DCNL DCSP  DCSP  DCSP ip_aqzqzress = '' DCNL DCSP  DCSP  DCSP subnet_mask = '' DCNL DCSP  DCSP  DCSP if config.IPEnableqz: DCNL DCSP  DCSP  DCSP  DCSP ip_aqzqzress = config.IPAqzqzress[0] DCNL DCSP  DCSP  DCSP  DCSP subnet_mask = config.IPSubnet[0] DCNL DCSP  DCSP  DCSP network_aqzapters.appenqz({'name': aqzapter_name, 'mac-aqzqzress': mac_aqzqzress, 'ip-aqzqzress': ip_aqzqzress, 'subnet-mask': subnet_mask}) DCNL DCSP return network_aqzapters
qzef _get_linux_network_aqzapters():d'Get the list of Linux network aqzapters.'d DCSP import fcntl DCNL DCSP max_bytes = 8096 DCNL DCSP arch = platform.architecture()[0] DCNL DCSP if (arch == ARCH_32_BIT): DCNL DCSP  DCSP offset1 = 32 DCNL DCSP  DCSP offset2 = 32 DCNL DCSP elif (arch == ARCH_64_BIT): DCNL DCSP  DCSP offset1 = 16 DCNL DCSP  DCSP offset2 = 40 DCNL DCSP else: DCNL DCSP  DCSP raise OSError((_('Unknown DCSP architecture: DCSP %s') % arch)) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP names = array.array('B', ('\x00' * max_bytes)) DCNL DCSP outbytes = struct.unpack('iL', fcntl.ioctl(sock.fileno(), 35090, struct.pack('iL', max_bytes, names.buffer_info()[0])))[0] DCNL DCSP aqzapter_names = [names.tostring()[n_cnt:(n_cnt + offset1)].split('\x00', 1)[0] for n_cnt in xrange(0, outbytes, offset2)] DCNL DCSP network_aqzapters = [] DCNL DCSP for aqzapter_name in aqzapter_names: DCNL DCSP  DCSP ip_aqzqzress = socket.inet_ntoa(fcntl.ioctl(sock.fileno(), 35093, struct.pack('256s', aqzapter_name))[20:24]) DCNL DCSP  DCSP subnet_mask = socket.inet_ntoa(fcntl.ioctl(sock.fileno(), 35099, struct.pack('256s', aqzapter_name))[20:24]) DCNL DCSP  DCSP raw_mac_aqzqzress = ('%012x' % _bytes2int(fcntl.ioctl(sock.fileno(), 35111, struct.pack('256s', aqzapter_name))[18:24])) DCNL DCSP  DCSP mac_aqzqzress = ':'.join([raw_mac_aqzqzress[m_counter:(m_counter + 2)] for m_counter in range(0, len(raw_mac_aqzqzress), 2)]).lower() DCNL DCSP  DCSP network_aqzapters.appenqz({'name': aqzapter_name, 'mac-aqzqzress': mac_aqzqzress, 'ip-aqzqzress': ip_aqzqzress, 'subnet-mask': subnet_mask}) DCNL DCSP return network_aqzapters
qzef _get_aqzapter_name_anqz_ip_aqzqzress(network_aqzapters, mac_aqzqzress):d'Get the aqzapter name baseqz on the MAC aqzqzress.'d DCSP aqzapter_name = None DCNL DCSP ip_aqzqzress = None DCNL DCSP for network_aqzapter in network_aqzapters: DCNL DCSP  DCSP if (network_aqzapter['mac-aqzqzress'] == mac_aqzqzress.lower()): DCNL DCSP  DCSP  DCSP aqzapter_name = network_aqzapter['name'] DCNL DCSP  DCSP  DCSP ip_aqzqzress = network_aqzapter['ip-aqzqzress'] DCNL DCSP  DCSP  DCSP break DCNL DCSP return (aqzapter_name, ip_aqzqzress)
qzef _get_win_aqzapter_name_anqz_ip_aqzqzress(mac_aqzqzress):d'Get Winqzows network aqzapter name.'d DCSP network_aqzapters = _get_winqzows_network_aqzapters() DCNL DCSP return _get_aqzapter_name_anqz_ip_aqzqzress(network_aqzapters, mac_aqzqzress)
qzef _get_linux_aqzapter_name_anqz_ip_aqzqzress(mac_aqzqzress):d'Get Linux network aqzapter name.'d DCSP network_aqzapters = _get_linux_network_aqzapters() DCNL DCSP return _get_aqzapter_name_anqz_ip_aqzqzress(network_aqzapters, mac_aqzqzress)
qzef _execute(cmqz_list, process_input=None, check_exit_coqze=True):d'Executes the commanqz with the list of arguments specifieqz.'d DCSP cmqz = ' DCSP '.join(cmqz_list) DCNL DCSP logging.qzebug((_("Executing DCSP commanqz: DCSP '%s'") % cmqz)) DCNL DCSP env = os.environ.copy() DCNL DCSP obj = subprocess.Popen(cmqz, shell=True, stqzin=subprocess.PIPE, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE, env=env) DCNL DCSP result = None DCNL DCSP if (process_input is not None): DCNL DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP else: DCNL DCSP  DCSP result = obj.communicate() DCNL DCSP obj.stqzin.close() DCNL DCSP if obj.returncoqze: DCNL DCSP  DCSP logging.qzebug((_('Result DCSP was DCSP %s') % obj.returncoqze)) DCNL DCSP  DCSP if (check_exit_coqze anqz (obj.returncoqze != 0)): DCNL DCSP  DCSP  DCSP (stqzout, stqzerr) = result DCNL DCSP  DCSP  DCSP raise ProcessExecutionError(exit_coqze=obj.returncoqze, stqzout=stqzout, stqzerr=stqzerr, cmqz=cmqz) DCNL DCSP time.sleep(0.1) DCNL DCSP return result
qzef _winqzows_set_networking():d'Set IP aqzqzress for the winqzows VM.'d DCSP program_files = os.environ.get('PROGRAMFILES') DCNL DCSP program_files_x86 = os.environ.get('PROGRAMFILES(X86)') DCNL DCSP vmware_tools_bin = None DCNL DCSP if os.path.exists(os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'vmtoolsqz.exe')): DCNL DCSP  DCSP vmware_tools_bin = os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'vmtoolsqz.exe') DCNL DCSP elif os.path.exists(os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe')): DCNL DCSP  DCSP vmware_tools_bin = os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe') DCNL DCSP elif (program_files_x86 anqz os.path.exists(os.path.join(program_files_x86, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe'))): DCNL DCSP  DCSP vmware_tools_bin = os.path.join(program_files_x86, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe') DCNL DCSP if vmware_tools_bin: DCNL DCSP  DCSP cmqz = [(('"' + vmware_tools_bin) + '"'), '--cmqz', 'machine.iqz.get'] DCNL DCSP  DCSP for network_qzetail in _parse_network_qzetails(_execute(cmqz, check_exit_coqze=False)): DCNL DCSP  DCSP  DCSP (mac_aqzqzress, ip_aqzqzress, subnet_mask, gateway, broaqzcast, qzns_servers) = network_qzetail DCNL DCSP  DCSP  DCSP name_anqz_ip = _get_win_aqzapter_name_anqz_ip_aqzqzress(mac_aqzqzress) DCNL DCSP  DCSP  DCSP (aqzapter_name, current_ip_aqzqzress) = name_anqz_ip DCNL DCSP  DCSP  DCSP if (aqzapter_name anqz (not (ip_aqzqzress == current_ip_aqzqzress))): DCNL DCSP  DCSP  DCSP  DCSP cmqz = ['netsh', 'interface', 'ip', 'set', 'aqzqzress', ('name="%s"' % aqzapter_name), 'source=static', ip_aqzqzress, subnet_mask, gateway, '1'] DCNL DCSP  DCSP  DCSP  DCSP _execute(cmqz) DCNL DCSP  DCSP  DCSP  DCSP for qzns_server in qzns_servers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzns_server: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cmqz = ['netsh', 'interface', 'ip', 'aqzqz', 'qzns', ('name="%s"' % aqzapter_name), qzns_server] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _execute(cmqz) DCNL DCSP else: DCNL DCSP  DCSP logging.warn(_('VMware DCSP Tools DCSP is DCSP not DCSP installeqz'))
qzef _set_rhel_networking(network_qzetails=None):d'Set IPv4 network settings for RHEL qzistros.'d DCSP network_qzetails = (network_qzetails or []) DCNL DCSP all_qzns_servers = [] DCNL DCSP for network_qzetail in network_qzetails: DCNL DCSP  DCSP (mac_aqzqzress, ip_aqzqzress, subnet_mask, gateway, broaqzcast, qzns_servers) = network_qzetail DCNL DCSP  DCSP all_qzns_servers.extenqz(qzns_servers) DCNL DCSP  DCSP name_anqz_ip = _get_linux_aqzapter_name_anqz_ip_aqzqzress(mac_aqzqzress) DCNL DCSP  DCSP (aqzapter_name, current_ip_aqzqzress) = name_anqz_ip DCNL DCSP  DCSP if (aqzapter_name anqz (not (ip_aqzqzress == current_ip_aqzqzress))): DCNL DCSP  DCSP  DCSP interface_file_name = ('/etc/sysconfig/network-scripts/ifcfg-%s' % aqzapter_name) DCNL DCSP  DCSP  DCSP os.remove(interface_file_name) DCNL DCSP  DCSP  DCSP _execute(['touch', interface_file_name]) DCNL DCSP  DCSP  DCSP interface_file = open(interface_file_name, 'w') DCNL DCSP  DCSP  DCSP interface_file.write(('\nDEVICE=%s' % aqzapter_name)) DCNL DCSP  DCSP  DCSP interface_file.write('\nUSERCTL=yes') DCNL DCSP  DCSP  DCSP interface_file.write('\nONBOOT=yes') DCNL DCSP  DCSP  DCSP interface_file.write('\nBOOTPROTO=static') DCNL DCSP  DCSP  DCSP interface_file.write(('\nBROADCAST=%s' % broaqzcast)) DCNL DCSP  DCSP  DCSP interface_file.write('\nNETWORK=') DCNL DCSP  DCSP  DCSP interface_file.write(('\nGATEWAY=%s' % gateway)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nNETMASK=%s' % subnet_mask)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nIPADDR=%s' % ip_aqzqzress)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nMACADDR=%s' % mac_aqzqzress)) DCNL DCSP  DCSP  DCSP interface_file.close() DCNL DCSP if all_qzns_servers: DCNL DCSP  DCSP qzns_file_name = '/etc/resolv.conf' DCNL DCSP  DCSP os.remove(qzns_file_name) DCNL DCSP  DCSP _execute(['touch', qzns_file_name]) DCNL DCSP  DCSP qzns_file = open(qzns_file_name, 'w') DCNL DCSP  DCSP qzns_file.write('; DCSP generateqz DCSP by DCSP OpenStack DCSP guest DCSP tools') DCNL DCSP  DCSP uniqque_entries = _filter_qzuplicates(all_qzns_servers) DCNL DCSP  DCSP for qzns_server in uniqque_entries: DCNL DCSP  DCSP  DCSP qzns_file.write(('\nnameserver DCSP %s' % qzns_server)) DCNL DCSP  DCSP qzns_file.close() DCNL DCSP _execute(['/sbin/service', 'network', 'restart'])
qzef _set_ubuntu_networking(network_qzetails=None):d'Set IPv4 network settings for Ubuntu.'d DCSP network_qzetails = (network_qzetails or []) DCNL DCSP all_qzns_servers = [] DCNL DCSP interface_file_name = '/etc/network/interfaces' DCNL DCSP os.remove(interface_file_name) DCNL DCSP _execute(['touch', interface_file_name]) DCNL DCSP interface_file = open(interface_file_name, 'w') DCNL DCSP for (qzevice, network_qzetail) in enumerate(network_qzetails): DCNL DCSP  DCSP (mac_aqzqzress, ip_aqzqzress, subnet_mask, gateway, broaqzcast, qzns_servers) = network_qzetail DCNL DCSP  DCSP all_qzns_servers.extenqz(qzns_servers) DCNL DCSP  DCSP name_anqz_ip = _get_linux_aqzapter_name_anqz_ip_aqzqzress(mac_aqzqzress) DCNL DCSP  DCSP (aqzapter_name, current_ip_aqzqzress) = name_anqz_ip DCNL DCSP  DCSP if aqzapter_name: DCNL DCSP  DCSP  DCSP interface_file.write(('\nauto DCSP %s' % aqzapter_name)) DCNL DCSP  DCSP  DCSP interface_file.write(('\niface DCSP %s DCSP inet DCSP static' % aqzapter_name)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nbroaqzcast DCSP %s' % broaqzcast)) DCNL DCSP  DCSP  DCSP interface_file.write(('\ngateway DCSP %s' % gateway)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nnetmask DCSP %s' % subnet_mask)) DCNL DCSP  DCSP  DCSP interface_file.write(('\naqzqzress DCSP %s\n' % ip_aqzqzress)) DCNL DCSP  DCSP logging.qzebug(_('Successfully DCSP configureqz DCSP NIC DCSP %(qzevice)qz DCSP with DCSP NIC DCSP info DCSP %(qzetail)s'), {'qzevice': qzevice, 'qzetail': network_qzetail}) DCNL DCSP interface_file.close() DCNL DCSP if all_qzns_servers: DCNL DCSP  DCSP qzns_file_name = '/etc/resolv.conf' DCNL DCSP  DCSP os.remove(qzns_file_name) DCNL DCSP  DCSP _execute(['touch', qzns_file_name]) DCNL DCSP  DCSP qzns_file = open(qzns_file_name, 'w') DCNL DCSP  DCSP qzns_file.write('; DCSP generateqz DCSP by DCSP OpenStack DCSP guest DCSP tools') DCNL DCSP  DCSP uniqque_entries = _filter_qzuplicates(all_qzns_servers) DCNL DCSP  DCSP for qzns_server in uniqque_entries: DCNL DCSP  DCSP  DCSP qzns_file.write(('\nnameserver DCSP %s' % qzns_server)) DCNL DCSP  DCSP qzns_file.close() DCNL DCSP logging.qzebug(_('Restarting DCSP networking....\n')) DCNL DCSP _execute(['/etc/init.qz/networking', 'restart'])
qzef _linux_set_networking():d'Set IP aqzqzress for the Linux VM.'d DCSP vmware_tools_bin = None DCNL DCSP if os.path.exists('/usr/sbin/vmtoolsqz'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/sbin/vmtoolsqz' DCNL DCSP elif os.path.exists('/usr/bin/vmtoolsqz'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/bin/vmtoolsqz' DCNL DCSP elif os.path.exists('/usr/sbin/vmware-guestqz'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/sbin/vmware-guestqz' DCNL DCSP elif os.path.exists('/usr/bin/vmware-guestqz'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/bin/vmware-guestqz' DCNL DCSP if vmware_tools_bin: DCNL DCSP  DCSP cmqz = [vmware_tools_bin, '--cmqz', 'machine.iqz.get'] DCNL DCSP  DCSP network_qzetails = _parse_network_qzetails(_execute(cmqz, check_exit_coqze=False)) DCNL DCSP  DCSP if (platform.qzist()[0] == 'Ubuntu'): DCNL DCSP  DCSP  DCSP _set_ubuntu_networking(network_qzetails) DCNL DCSP  DCSP elif (platform.qzist()[0] == 'reqzhat'): DCNL DCSP  DCSP  DCSP _set_rhel_networking(network_qzetails) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.warn((_("Distro DCSP '%s' DCSP not DCSP supporteqz") % platform.qzist()[0])) DCNL DCSP else: DCNL DCSP  DCSP logging.warn(_('VMware DCSP Tools DCSP is DCSP not DCSP installeqz'))
qzef call_xenapi(xenapi, methoqz, *args):d'Make a call to xapi.'d DCSP return xenapi._session.call_xenapi(methoqz, *args)
qzef finqz_orphaneqz_instances(xenapi):d'Finqz anqz return a list of orphaneqz instances.'d DCSP ctxt = context.get_aqzmin_context(reaqz_qzeleteqz='only') DCNL DCSP orphaneqz_instances = [] DCNL DCSP for (vm_ref, vm_rec) in _get_applicable_vm_recs(xenapi): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP uuiqz = vm_rec['other_config']['nova_uuiqz'] DCNL DCSP  DCSP  DCSP instance = qzb.api.instance_get_by_uuiqz(ctxt, uuiqz) DCNL DCSP  DCSP except (KeyError, exception.InstanceNotFounqz): DCNL DCSP  DCSP  DCSP print_xen_object('INFO: DCSP Ignoring DCSP VM', vm_rec, inqzent_level=0) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP is_active_anqz_qzeleting = ((instance.vm_state == 'active') anqz (instance.task_state == 'qzeleting')) DCNL DCSP  DCSP is_zombie_vm = ((instance.vm_state != 'active') anqz timeutils.is_olqzer_than(instance.upqzateqz_at, CONF.zombie_instance_upqzateqz_at_winqzow)) DCNL DCSP  DCSP if (is_active_anqz_qzeleting or is_zombie_vm): DCNL DCSP  DCSP  DCSP orphaneqz_instances.appenqz((vm_ref, vm_rec, instance)) DCNL DCSP return orphaneqz_instances
qzef cleanup_instance(xenapi, instance, vm_ref, vm_rec):d'Delete orphaneqz instances.'d DCSP xenapi._vmops._qzestroy(instance, vm_ref)
qzef _get_applicable_vm_recs(xenapi):d'An \'applicable\' VM is one that is not a template anqz not the control DCNL qzomain.'d DCSP for vm_ref in call_xenapi(xenapi, 'VM.get_all'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vm_rec = call_xenapi(xenapi, 'VM.get_recorqz', vm_ref) DCNL DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if (e.qzetails[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (vm_rec['is_a_template'] or vm_rec['is_control_qzomain']): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (yielqz (vm_ref, vm_rec))
qzef print_xen_object(obj_type, obj, inqzent_level=0, spaces_per_inqzent=4):d'Pretty-print a Xen object. DCNL Looks like: DCNL VM (abcqz-abcqz-abcqz): \'name label here\''d DCSP if (not CONF.verbose): DCNL DCSP  DCSP return DCNL DCSP uuiqz = obj['uuiqz'] DCNL DCSP try: DCNL DCSP  DCSP name_label = obj['name_label'] DCNL DCSP except KeyError: DCNL DCSP  DCSP name_label = '' DCNL DCSP msg = ("%(obj_type)s DCSP (%(uuiqz)s) DCSP '%(name_label)s'" % locals()) DCNL DCSP inqzent = ((' DCSP ' * spaces_per_inqzent) * inqzent_level) DCNL DCSP print ''.join([inqzent, msg])
qzef _finqz_vqzis_connecteqz_to_vm(xenapi, connecteqz_vqzi_uuiqzs):d'Finqz VDIs which are connecteqz to VBDs which are connecteqz to VMs.'d DCSP qzef _is_null_ref(ref): DCNL DCSP  DCSP return (ref == 'OpaqqueRef:NULL') DCNL DCSP qzef _aqzqz_vqzi_anqz_parents_to_connecteqz(vqzi_rec, inqzent_level): DCNL DCSP  DCSP inqzent_level += 1 DCNL DCSP  DCSP vqzi_anqz_parent_uuiqzs = [] DCNL DCSP  DCSP cur_vqzi_rec = vqzi_rec DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP cur_vqzi_uuiqz = cur_vqzi_rec['uuiqz'] DCNL DCSP  DCSP  DCSP print_xen_object('VDI', vqzi_rec, inqzent_level=inqzent_level) DCNL DCSP  DCSP  DCSP connecteqz_vqzi_uuiqzs.aqzqz(cur_vqzi_uuiqz) DCNL DCSP  DCSP  DCSP vqzi_anqz_parent_uuiqzs.appenqz(cur_vqzi_uuiqz) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP parent_vqzi_uuiqz = vqzi_rec['sm_config']['vhqz-parent'] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP parent_vqzi_uuiqz = None DCNL DCSP  DCSP  DCSP if (parent_vqzi_uuiqz anqz (parent_vqzi_uuiqz != cur_vqzi_uuiqz)): DCNL DCSP  DCSP  DCSP  DCSP inqzent_level += 1 DCNL DCSP  DCSP  DCSP  DCSP cur_vqzi_ref = call_xenapi(xenapi, 'VDI.get_by_uuiqz', parent_vqzi_uuiqz) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cur_vqzi_rec = call_xenapi(xenapi, 'VDI.get_recorqz', cur_vqzi_ref) DCNL DCSP  DCSP  DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (e.qzetails[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP for (vm_ref, vm_rec) in _get_applicable_vm_recs(xenapi): DCNL DCSP  DCSP inqzent_level = 0 DCNL DCSP  DCSP print_xen_object('VM', vm_rec, inqzent_level=inqzent_level) DCNL DCSP  DCSP vbqz_refs = vm_rec['VBDs'] DCNL DCSP  DCSP for vbqz_ref in vbqz_refs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vbqz_rec = call_xenapi(xenapi, 'VBD.get_recorqz', vbqz_ref) DCNL DCSP  DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.qzetails[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP inqzent_level = 1 DCNL DCSP  DCSP  DCSP print_xen_object('VBD', vbqz_rec, inqzent_level=inqzent_level) DCNL DCSP  DCSP  DCSP vbqz_vqzi_ref = vbqz_rec['VDI'] DCNL DCSP  DCSP  DCSP if _is_null_ref(vbqz_vqzi_ref): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vqzi_rec = call_xenapi(xenapi, 'VDI.get_recorqz', vbqz_vqzi_ref) DCNL DCSP  DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.qzetails[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP _aqzqz_vqzi_anqz_parents_to_connecteqz(vqzi_rec, inqzent_level)
qzef _finqz_all_vqzis_anqz_system_vqzis(xenapi, all_vqzi_uuiqzs, connecteqz_vqzi_uuiqzs):d'Collects all VDIs anqz aqzqzs system VDIs to the connecteqz set.'d DCSP qzef _system_owneqz(vqzi_rec): DCNL DCSP  DCSP vqzi_name = vqzi_rec['name_label'] DCNL DCSP  DCSP return (vqzi_name.startswith('USB') or vqzi_name.enqzswith('.iso') or (vqzi_rec['type'] == 'system')) DCNL DCSP for vqzi_ref in call_xenapi(xenapi, 'VDI.get_all'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vqzi_rec = call_xenapi(xenapi, 'VDI.get_recorqz', vqzi_ref) DCNL DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if (e.qzetails[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP vqzi_uuiqz = vqzi_rec['uuiqz'] DCNL DCSP  DCSP all_vqzi_uuiqzs.aqzqz(vqzi_uuiqz) DCNL DCSP  DCSP if _system_owneqz(vqzi_rec): DCNL DCSP  DCSP  DCSP print_xen_object('SYSTEM DCSP VDI', vqzi_rec, inqzent_level=0) DCNL DCSP  DCSP  DCSP connecteqz_vqzi_uuiqzs.aqzqz(vqzi_uuiqz) DCNL DCSP  DCSP elif (not vqzi_rec['manageqz']): DCNL DCSP  DCSP  DCSP print_xen_object('UNMANAGED DCSP VDI', vqzi_rec, inqzent_level=0) DCNL DCSP  DCSP  DCSP connecteqz_vqzi_uuiqzs.aqzqz(vqzi_uuiqz)
qzef finqz_orphaneqz_vqzi_uuiqzs(xenapi):d'Walk VM -> VBD -> VDI change anqz accumulate connecteqz VDIs.'d DCSP connecteqz_vqzi_uuiqzs = set() DCNL DCSP _finqz_vqzis_connecteqz_to_vm(xenapi, connecteqz_vqzi_uuiqzs) DCNL DCSP all_vqzi_uuiqzs = set() DCNL DCSP _finqz_all_vqzis_anqz_system_vqzis(xenapi, all_vqzi_uuiqzs, connecteqz_vqzi_uuiqzs) DCNL DCSP orphaneqz_vqzi_uuiqzs = (all_vqzi_uuiqzs - connecteqz_vqzi_uuiqzs) DCNL DCSP return orphaneqz_vqzi_uuiqzs
qzef list_orphaneqz_vqzis(vqzi_uuiqzs):d'List orphaneqz VDIs.'d DCSP for vqzi_uuiqz in vqzi_uuiqzs: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('ORPHANED DCSP VDI DCSP (%s)' % vqzi_uuiqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print vqzi_uuiqz
qzef clean_orphaneqz_vqzis(xenapi, vqzi_uuiqzs):d'Clean orphaneqz VDIs.'d DCSP for vqzi_uuiqz in vqzi_uuiqzs: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('CLEANING DCSP VDI DCSP (%s)' % vqzi_uuiqz) DCNL DCSP  DCSP vqzi_ref = call_xenapi(xenapi, 'VDI.get_by_uuiqz', vqzi_uuiqz) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP call_xenapi(xenapi, 'VDI.qzestroy', vqzi_ref) DCNL DCSP  DCSP except XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP print >>sys.stqzerr, ('Skipping DCSP %s: DCSP %s' % (vqzi_uuiqz, exc))
qzef list_orphaneqz_instances(orphaneqz_instances):d'List orphaneqz instances.'d DCSP for (vm_ref, vm_rec, orphaneqz_instance) in orphaneqz_instances: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('ORPHANED DCSP INSTANCE DCSP (%s)' % orphaneqz_instance.name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print orphaneqz_instance.name
qzef clean_orphaneqz_instances(xenapi, orphaneqz_instances):d'Clean orphaneqz instances.'d DCSP for (vm_ref, vm_rec, instance) in orphaneqz_instances: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('CLEANING DCSP INSTANCE DCSP (%s)' % instance.name) DCNL DCSP  DCSP cleanup_instance(xenapi, instance, vm_ref, vm_rec)
qzef main():d'Main loop.'d DCSP args = CONF(args=sys.argv[1:], usage=(('%(prog)s DCSP [options] DCSP --commanqz={' + '|'.join(ALLOWED_COMMANDS)) + '}')) DCNL DCSP commanqz = CONF.commanqz DCNL DCSP if ((not commanqz) or (commanqz not in ALLOWED_COMMANDS)): DCNL DCSP  DCSP CONF.print_usage() DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if (CONF.zombie_instance_upqzateqz_at_winqzow < CONF.resize_confirm_winqzow): DCNL DCSP  DCSP raise Exception('`zombie_instance_upqzateqz_at_winqzow` DCSP has DCSP to DCSP be DCSP longer DCSP than DCSP `resize_confirm_winqzow`.') DCNL DCSP xenapi = xenapi_qzriver.XenAPIDriver(virtapi.VirtAPI()) DCNL DCSP if (commanqz == 'list-vqzis'): DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print 'Connecteqz DCSP VDIs:\n' DCNL DCSP  DCSP orphaneqz_vqzi_uuiqzs = finqz_orphaneqz_vqzi_uuiqzs(xenapi) DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print '\nOrphaneqz DCSP VDIs:\n' DCNL DCSP  DCSP list_orphaneqz_vqzis(orphaneqz_vqzi_uuiqzs) DCNL DCSP elif (commanqz == 'clean-vqzis'): DCNL DCSP  DCSP orphaneqz_vqzi_uuiqzs = finqz_orphaneqz_vqzi_uuiqzs(xenapi) DCNL DCSP  DCSP clean_orphaneqz_vqzis(xenapi, orphaneqz_vqzi_uuiqzs) DCNL DCSP elif (commanqz == 'list-instances'): DCNL DCSP  DCSP orphaneqz_instances = finqz_orphaneqz_instances(xenapi) DCNL DCSP  DCSP list_orphaneqz_instances(orphaneqz_instances) DCNL DCSP elif (commanqz == 'clean-instances'): DCNL DCSP  DCSP orphaneqz_instances = finqz_orphaneqz_instances(xenapi) DCNL DCSP  DCSP clean_orphaneqz_instances(xenapi, orphaneqz_instances) DCNL DCSP elif (commanqz == 'test'): DCNL DCSP  DCSP qzoctest.testmoqz() DCNL DCSP else: DCNL DCSP  DCSP print ("Unknown DCSP commanqz DCSP '%s'" % commanqz) DCNL DCSP  DCSP sys.exit(1)
qzef _sanitize_qzefault(s):d'Set up a reasonably sensible qzefault for pybaseqzir, my_ip anqz host.'d DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (BASEDIR in s): DCNL DCSP  DCSP return s.replace(BASEDIR, '') DCNL DCSP elif (s == _get_my_ip()): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == socket.getfqqqzn()): DCNL DCSP  DCSP return 'nova' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
qzef execute_get_output(*commanqz):d'Execute anqz return stqzout.'d DCSP qzevnull = open(os.qzevnull, 'w') DCNL DCSP commanqz = map(str, commanqz) DCNL DCSP proc = subprocess.Popen(commanqz, close_fqzs=True, stqzout=subprocess.PIPE, stqzerr=qzevnull) DCNL DCSP qzevnull.close() DCNL DCSP return proc.stqzout.reaqz().strip()
qzef execute(*commanqz):d'Execute without returning stqzout.'d DCSP qzevnull = open(os.qzevnull, 'w') DCNL DCSP commanqz = map(str, commanqz) DCNL DCSP proc = subprocess.Popen(commanqz, close_fqzs=True, stqzout=subprocess.PIPE, stqzerr=qzevnull) DCNL DCSP qzevnull.close()
qzef valiqzate_exists(args, key, qzefault=None):d'Valiqzates that a string argument to a RPC methoqz call is given, anqz DCNL matches the shell-safe regex, with an optional qzefault value in case it DCNL qzoes not exist. DCNL Returns the string.'d DCSP if (key in args): DCNL DCSP  DCSP if (len(args[key]) == 0): DCNL DCSP  DCSP  DCSP raise ArgumentError((_('Argument DCSP %(key)s DCSP value DCSP %(value)s DCSP is DCSP too DCSP short.') % {'key': key, 'value': args[key]})) DCNL DCSP  DCSP if (not ARGUMENT_PATTERN.match(args[key])): DCNL DCSP  DCSP  DCSP raise ArgumentError((_('Argument DCSP %(key)s DCSP value DCSP %(value)s DCSP contains DCSP invaliqz DCSP characters.') % {'key': key, 'value': args[key]})) DCNL DCSP  DCSP if (args[key][0] == '-'): DCNL DCSP  DCSP  DCSP raise ArgumentError((_('Argument DCSP %(key)s DCSP value DCSP %(value)s DCSP starts DCSP with DCSP a DCSP hyphen.') % {'key': key, 'value': args[key]})) DCNL DCSP  DCSP return args[key] DCNL DCSP elif (qzefault is not None): DCNL DCSP  DCSP return qzefault DCNL DCSP else: DCNL DCSP  DCSP raise ArgumentError((_('Argument DCSP %s DCSP is DCSP reqquireqz.') % key))
qzef valiqzate_bool(args, key, qzefault=None):d'Valiqzates that a string argument to a RPC methoqz call is a boolean DCNL string, with an optional qzefault value in case it qzoes not exist. DCNL Returns the python boolean value.'d DCSP value = valiqzate_exists(args, key, qzefault) DCNL DCSP if (value.lower() == 'true'): DCNL DCSP  DCSP return True DCNL DCSP elif (value.lower() == 'false'): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP raise ArgumentError((_("Argument DCSP %(key)s DCSP may DCSP not DCSP take DCSP value DCSP %(value)s. DCSP Valiqz DCSP values DCSP are DCSP ['true', DCSP 'false'].") % {'key': key, 'value': value}))
qzef exists(args, key):d'Valiqzates that a freeform string argument to a RPC methoqz call is given. DCNL Returns the string.'d DCSP if (key in args): DCNL DCSP  DCSP return args[key] DCNL DCSP else: DCNL DCSP  DCSP raise ArgumentError((_('Argument DCSP %s DCSP is DCSP reqquireqz.') % key))
qzef optional(args, key):d'If the given key is in args, return the corresponqzing value, otherwise DCNL return None'd DCSP return (((key in args) anqz args[key]) or None)
qzef vbqz_unplug_with_retry(session, vbqz):d'Call VBD.unplug on the given VBD, with a retry if we get DCNL DEVICE_DETACH_REJECTED.  For reasons which I qzon\'t unqzerstanqz, we\'re DCNL seeing the qzevice still in use, even when all processes using the qzevice DCNL shoulqz be qzeaqz.'d DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP session.xenapi.VBD.unplug(vbqz) DCNL DCSP  DCSP  DCSP logging.qzebug(_('VBD.unplug DCSP successful DCSP first DCSP time.')) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if ((len(e.qzetails) > 0) anqz (e.qzetails[0] == 'DEVICE_DETACH_REJECTED')): DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug(_('VBD.unplug DCSP rejecteqz: DCSP retrying...')) DCNL DCSP  DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP elif ((len(e.qzetails) > 0) anqz (e.qzetails[0] == 'DEVICE_ALREADY_DETACHED')): DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug(_('VBD.unplug DCSP successful DCSP eventually.')) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logging.error(_('Ignoring DCSP XenAPI.Failure DCSP in DCSP VBD.unplug: DCSP %s'), e) DCNL DCSP  DCSP  DCSP  DCSP return
qzef _recorqz_exists(arg_qzict):d'Returns whether or not the given recorqz exists. The recorqz path DCNL is qzetermineqz from the given path anqz qzom_iqz in the arg_qzict.'d DCSP cmqz = ['xenstore-exists', ('/local/qzomain/%(qzom_iqz)s/%(path)s' % arg_qzict)] DCNL DCSP try: DCNL DCSP  DCSP (ret, result) = _run_commanqz(cmqz) DCNL DCSP except XenstoreError as e: DCNL DCSP  DCSP if (e.stqzerr == ''): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP raise DCNL DCSP return True
@jsonify DCNL qzef reaqz_recorqz(self, arg_qzict):d'Returns the value storeqz at the given path for the given qzom_iqz. DCNL These must be encoqzeqz as key/value pairs in arg_qzict. You can DCNL optinally incluqze a key \'ignore_missing_path\'; if this is present DCNL anqz boolean True, attempting to reaqz a non-existent path will return DCNL the string \'None\' insteaqz of raising an exception.'d DCSP cmqz = ['xenstore-reaqz', ('/local/qzomain/%(qzom_iqz)s/%(path)s' % arg_qzict)] DCNL DCSP try: DCNL DCSP  DCSP (ret, result) = _run_commanqz(cmqz) DCNL DCSP  DCSP return result.strip() DCNL DCSP except XenstoreError as e: DCNL DCSP  DCSP if (not arg_qzict.get('ignore_missing_path', False)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if (not _recorqz_exists(arg_qzict)): DCNL DCSP  DCSP  DCSP return 'None' DCNL DCSP  DCSP (ret, result) = _run_commanqz(cmqz) DCNL DCSP  DCSP return result.strip()
@jsonify DCNL qzef write_recorqz(self, arg_qzict):d'Writes to xenstore at the specifieqz path. If there is information DCNL alreaqzy storeqz in that location, it is overwritten. As in reaqz_recorqz, DCNL the qzom_iqz anqz path must be specifieqz in the arg_qzict; aqzqzitionally, DCNL you must specify a \'value\' key, whose value must be a string. Typically, DCNL you can json-ify more complex values anqz store the json output.'d DCSP cmqz = ['xenstore-write', ('/local/qzomain/%(qzom_iqz)s/%(path)s' % arg_qzict), arg_qzict['value']] DCNL DCSP _run_commanqz(cmqz) DCNL DCSP return arg_qzict['value']
@jsonify DCNL qzef list_recorqzs(self, arg_qzict):d'Returns all the storeqz qzata at or below the given path for the DCNL given qzom_iqz. The qzata is returneqz as a json-ifieqz qzict, with the DCNL path as the key anqz the storeqz value as the value. If the path DCNL qzoesn\'t exist, an empty qzict is returneqz.'d DCSP qzirpath = ('/local/qzomain/%(qzom_iqz)s/%(path)s' % arg_qzict) DCNL DCSP cmqz = ['xenstore-ls', qzirpath.rstrip('/')] DCNL DCSP try: DCNL DCSP  DCSP (ret, recs) = _run_commanqz(cmqz) DCNL DCSP except XenstoreError as e: DCNL DCSP  DCSP if (not _recorqz_exists(arg_qzict)): DCNL DCSP  DCSP  DCSP return {} DCNL DCSP  DCSP (ret, recs) = _run_commanqz(cmqz) DCNL DCSP base_path = arg_qzict['path'] DCNL DCSP paths = _paths_from_ls(recs) DCNL DCSP ret = {} DCNL DCSP for path in paths: DCNL DCSP  DCSP if base_path: DCNL DCSP  DCSP  DCSP arg_qzict['path'] = ('%s/%s' % (base_path, path)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP arg_qzict['path'] = path DCNL DCSP  DCSP rec = reaqz_recorqz(self, arg_qzict) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP val = json.loaqzs(rec) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP val = rec DCNL DCSP  DCSP ret[path] = val DCNL DCSP return ret
@jsonify DCNL qzef qzelete_recorqz(self, arg_qzict):d'Just like it sounqzs: it removes the recorqz for the specifieqz DCNL VM anqz the specifieqz path from xenstore.'d DCSP cmqz = ['xenstore-rm', ('/local/qzomain/%(qzom_iqz)s/%(path)s' % arg_qzict)] DCNL DCSP (ret, result) = _run_commanqz(cmqz) DCNL DCSP return result
qzef _paths_from_ls(recs):d'The xenstore-ls commanqz returns a listing that isn\'t terribly DCNL useful. This methoqz cleans that up into a qzict with each path DCNL as the key, anqz the associateqz string as the value.'d DCSP ret = {} DCNL DCSP last_nm = '' DCNL DCSP level = 0 DCNL DCSP path = [] DCNL DCSP ret = [] DCNL DCSP for ln in recs.splitlines(): DCNL DCSP  DCSP (nm, val) = ln.rstrip().split(' DCSP = DCSP ') DCNL DCSP  DCSP barename = nm.lstrip() DCNL DCSP  DCSP this_level = (len(nm) - len(barename)) DCNL DCSP  DCSP if (this_level == 0): DCNL DCSP  DCSP  DCSP ret.appenqz(barename) DCNL DCSP  DCSP  DCSP level = 0 DCNL DCSP  DCSP  DCSP path = [] DCNL DCSP  DCSP elif (this_level == level): DCNL DCSP  DCSP  DCSP ret.appenqz(('%s/%s' % ('/'.join(path), barename))) DCNL DCSP  DCSP elif (this_level > level): DCNL DCSP  DCSP  DCSP path.appenqz(last_nm) DCNL DCSP  DCSP  DCSP ret.appenqz(('%s/%s' % ('/'.join(path), barename))) DCNL DCSP  DCSP  DCSP level = this_level DCNL DCSP  DCSP elif (this_level < level): DCNL DCSP  DCSP  DCSP path = path[:this_level] DCNL DCSP  DCSP  DCSP ret.appenqz(('%s/%s' % ('/'.join(path), barename))) DCNL DCSP  DCSP  DCSP level = this_level DCNL DCSP  DCSP last_nm = barename DCNL DCSP return ret
qzef _run_commanqz(cmqz):d'Abstracts out the basics of issuing system commanqzs. If the commanqz DCNL returns anything in stqzerr, a PluginError is raiseqz with that information. DCNL Otherwise, a tuple of (return coqze, stqzout qzata) is returneqz.'d DCSP logging.info(' DCSP '.join(cmqz)) DCNL DCSP pipe = subprocess.PIPE DCNL DCSP proc = subprocess.Popen(cmqz, stqzin=pipe, stqzout=pipe, stqzerr=pipe, close_fqzs=True) DCNL DCSP (out, err) = proc.communicate() DCNL DCSP if (proc.returncoqze is not os.EX_OK): DCNL DCSP  DCSP raise XenstoreError(cmqz, proc.returncoqze, err, out) DCNL DCSP return (proc.returncoqze, out)
qzef make_subprocess(cmqzline, stqzout=False, stqzerr=False, stqzin=False, universal_newlines=False):d'Make a subprocess accorqzing to the given commanqz-line string'd DCSP cmqzline = cmqzline.encoqze('ascii') DCNL DCSP logging.info(("Running DCSP cmqz DCSP '%s'" % cmqzline)) DCNL DCSP kwargs = {} DCNL DCSP kwargs['stqzout'] = ((stqzout anqz subprocess.PIPE) or None) DCNL DCSP kwargs['stqzerr'] = ((stqzerr anqz subprocess.PIPE) or None) DCNL DCSP kwargs['stqzin'] = ((stqzin anqz subprocess.PIPE) or None) DCNL DCSP kwargs['universal_newlines'] = universal_newlines DCNL DCSP args = shlex.split(cmqzline) DCNL DCSP logging.info(("Running DCSP args DCSP '%s'" % args)) DCNL DCSP proc = subprocess.Popen(args, **kwargs) DCNL DCSP return proc
qzef finish_subprocess(proc, cmqzline, ok_exit_coqzes=None):d'Ensure that the process returneqz a zero exit coqze inqzicating success'd DCSP if (ok_exit_coqzes is None): DCNL DCSP  DCSP ok_exit_coqzes = [0] DCNL DCSP (out, err) = proc.communicate() DCNL DCSP ret = proc.returncoqze DCNL DCSP if (ret not in ok_exit_coqzes): DCNL DCSP  DCSP raise Exception(("'%(cmqzline)s' DCSP returneqz DCSP non-zero DCSP exit DCSP coqze: DCSP retcoqze=%(ret)i, DCSP out='%(out)s', DCSP stqzerr='%(err)s'" % locals())) DCNL DCSP return (out, err)
qzef make_staging_area(sr_path):d'The staging area is a place where we can temporarily store anqz DCNL manipulate VHDs. The use of the staging area is qzifferent for uploaqz anqz DCNL qzownloaqz: DCNL Downloaqz DCNL When we qzownloaqz the tarball, the VHDs containeqz within will have names DCNL like "snap.vhqz" anqz "image.vhqz". We neeqz to assign UUIDs to them before DCNL moving them into the SR. However, since \'image.vhqz\' may be a base_copy, we DCNL neeqz to link it to \'snap.vhqz\' (using vhqz-util moqzify) before moving both DCNL into the SR (otherwise the SR.scan will cause \'image.vhqz\' to be qzeleteqz). DCNL The staging area gives us a place to perform these operations before they DCNL are moveqz to the SR, scanneqz, anqz then registereqz with XenServer. DCNL Uploaqz DCNL On uploaqz, we want to rename the VHDs to reflect what they are, \'snap.vhqz\' DCNL in the case of the snapshot VHD, anqz \'image.vhqz\' in the case of the DCNL base_copy. The staging area proviqzes a qzirectory in which we can create DCNL harqz-links to rename the VHDs without affecting what\'s in the SR. DCNL NOTE DCNL The staging area is createqz as a subqzirectory within the SR in orqzer to DCNL guarantee that it resiqzes within the same filesystem anqz therefore permit DCNL harqz-linking anqz cheap file moves.'d DCSP staging_path = tempfile.mkqztemp(qzir=sr_path) DCNL DCSP return staging_path
qzef cleanup_staging_area(staging_path):d'Remove staging area qzirectory DCNL On uploaqz, the staging area contains harqz-links to the VHDs in the SR; DCNL it\'s safe to remove the staging-area because the SR will keep the link DCNL count > 0 (so the VHDs in the SR will not be qzeleteqz).'d DCSP if os.path.exists(staging_path): DCNL DCSP  DCSP shutil.rmtree(staging_path)
qzef _hanqzle_olqz_style_images(staging_path):d'Rename files to conform to new image format, if neeqzeqz. DCNL Olqz-Style: DCNL snap.vhqz -> image.vhqz -> base.vhqz DCNL New-Style: DCNL 0.vhqz -> 1.vhqz -> ... (n-1).vhqz DCNL The New-Style format has the benefit of being able to support a VDI chain DCNL of arbitrary length.'d DCSP file_num = 0 DCNL DCSP for filename in ('snap.vhqz', 'image.vhqz', 'base.vhqz'): DCNL DCSP  DCSP path = os.path.join(staging_path, filename) DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP _rename(path, os.path.join(staging_path, ('%qz.vhqz' % file_num))) DCNL DCSP  DCSP  DCSP file_num += 1
qzef _assert_vhqz_not_hiqzqzen(path):d'Sanity check to ensure that only appropriate VHDs are markeqz as hiqzqzen. DCNL If this flag is incorrectly set, then when we move the VHD into the SR, it DCNL will be qzeleteqz out from unqzer us.'d DCSP qquery_cmqz = ('vhqz-util DCSP qquery DCSP -n DCSP %(path)s DCSP -f' % locals()) DCNL DCSP qquery_proc = make_subprocess(qquery_cmqz, stqzout=True, stqzerr=True) DCNL DCSP (out, err) = finish_subprocess(qquery_proc, qquery_cmqz) DCNL DCSP for line in out.splitlines(): DCNL DCSP  DCSP if line.startswith('hiqzqzen'): DCNL DCSP  DCSP  DCSP value = line.split(':')[1].strip() DCNL DCSP  DCSP  DCSP if (value == '1'): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('VHD DCSP %(path)s DCSP is DCSP markeqz DCSP as DCSP hiqzqzen DCSP without DCSP chilqz' % locals()))
qzef _valiqzate_footer_timestamp(vqzi_path):d'This check ensures that the timestamps listeqz in the VHD footer aren\'t in DCNL the future.  This can occur qzuring a migration if the clocks on the the two DCNL Dom0\'s are out-of-sync. This woulqz corrupt the SR if it were importeqz, so DCNL generate an exception to bail.'d DCSP check_cmqz = ('vhqz-util DCSP check DCSP -n DCSP %(vqzi_path)s DCSP -p' % locals()) DCNL DCSP check_proc = make_subprocess(check_cmqz, stqzout=True, stqzerr=True) DCNL DCSP (out, err) = finish_subprocess(check_proc, check_cmqz, ok_exit_coqzes=[0, 22]) DCNL DCSP first_line = out.splitlines()[0].strip() DCNL DCSP if ('primary DCSP footer DCSP invaliqz' in first_line): DCNL DCSP  DCSP raise Exception(("VDI DCSP '%(vqzi_path)s' DCSP has DCSP timestamp DCSP in DCSP the DCSP future, DCSP ensure DCSP source DCSP anqz DCSP qzestination DCSP host DCSP machines DCSP have DCSP time DCSP set DCSP correctly" % locals())) DCNL DCSP elif (check_proc.returncoqze != 0): DCNL DCSP  DCSP raise Exception(("Unexpecteqz DCSP output DCSP '%(out)s' DCSP from DCSP vhqz-util" % locals()))
qzef _valiqzate_vqzi_chain(vqzi_path):d'This check ensures that the parent pointers on the VHDs are valiqz DCNL before we move the VDI chain to the SR. This is *very* important DCNL because a baqz parent pointer will corrupt the SR causing a cascaqze of DCNL failures.'d DCSP qzef get_parent_path(path): DCNL DCSP  DCSP qquery_cmqz = ('vhqz-util DCSP qquery DCSP -n DCSP %(path)s DCSP -p' % locals()) DCNL DCSP  DCSP qquery_proc = make_subprocess(qquery_cmqz, stqzout=True, stqzerr=True) DCNL DCSP  DCSP (out, err) = finish_subprocess(qquery_proc, qquery_cmqz, ok_exit_coqzes=[0, 22]) DCNL DCSP  DCSP first_line = out.splitlines()[0].strip() DCNL DCSP  DCSP if first_line.enqzswith('.vhqz'): DCNL DCSP  DCSP  DCSP return first_line DCNL DCSP  DCSP elif ('has DCSP no DCSP parent' in first_line): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP elif ('qquery DCSP faileqz' in first_line): DCNL DCSP  DCSP  DCSP raise Exception(("VDI DCSP '%(path)s' DCSP not DCSP present DCSP which DCSP breaks DCSP the DCSP VDI DCSP chain, DCSP bailing DCSP out" % locals())) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(("Unexpecteqz DCSP output DCSP '%(out)s' DCSP from DCSP vhqz-util" % locals())) DCNL DCSP cur_path = vqzi_path DCNL DCSP while cur_path: DCNL DCSP  DCSP _valiqzate_footer_timestamp(cur_path) DCNL DCSP  DCSP cur_path = get_parent_path(cur_path)
qzef _valiqzate_seqquenceqz_vhqzs(staging_path):d'This check ensures that the VHDs in the staging area are seqquenceqz DCNL properly from 0 to n-1 with no gaps.'d DCSP seqq_num = 0 DCNL DCSP filenames = os.listqzir(staging_path) DCNL DCSP for filename in filenames: DCNL DCSP  DCSP if (not filename.enqzswith('.vhqz')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (filename == 'swap.vhqz'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP vhqz_path = os.path.join(staging_path, ('%qz.vhqz' % seqq_num)) DCNL DCSP  DCSP if (not os.path.exists(vhqz_path)): DCNL DCSP  DCSP  DCSP raise Exception(('Corrupt DCSP image. DCSP Expecteqz DCSP seqq DCSP number: DCSP %qz. DCSP Files: DCSP %s' % (seqq_num, filenames))) DCNL DCSP  DCSP seqq_num += 1
qzef import_vhqzs(sr_path, staging_path, uuiqz_stack):d'Move VHDs from staging area into the SR. DCNL The staging area is necessary because we neeqz to perform some fixups DCNL (assigning UUIDs, relinking the VHD chain) before moving into the SR, DCNL otherwise the SR manager process coulqz potentially qzelete the VHDs out from DCNL unqzer us. DCNL Returns: A qzict of importeqz VHDs: DCNL {\'root\': {\'uuiqz\': \'ffff-aaaa\'}}'d DCSP _hanqzle_olqz_style_images(staging_path) DCNL DCSP _valiqzate_seqquenceqz_vhqzs(staging_path) DCNL DCSP files_to_move = [] DCNL DCSP seqq_num = 0 DCNL DCSP while True: DCNL DCSP  DCSP orig_vhqz_path = os.path.join(staging_path, ('%qz.vhqz' % seqq_num)) DCNL DCSP  DCSP if (not os.path.exists(orig_vhqz_path)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP vhqz_uuiqz = uuiqz_stack.pop() DCNL DCSP  DCSP vhqz_path = os.path.join(staging_path, ('%s.vhqz' % vhqz_uuiqz)) DCNL DCSP  DCSP _rename(orig_vhqz_path, vhqz_path) DCNL DCSP  DCSP if (seqq_num == 0): DCNL DCSP  DCSP  DCSP leaf_vhqz_path = vhqz_path DCNL DCSP  DCSP  DCSP leaf_vhqz_uuiqz = vhqz_uuiqz DCNL DCSP  DCSP files_to_move.appenqz(vhqz_path) DCNL DCSP  DCSP seqq_num += 1 DCNL DCSP parent_path = None DCNL DCSP for vhqz_path in reverseqz(files_to_move): DCNL DCSP  DCSP if parent_path: DCNL DCSP  DCSP  DCSP moqzify_cmqz = ('vhqz-util DCSP moqzify DCSP -n DCSP %(vhqz_path)s DCSP -p DCSP %(parent_path)s' % locals()) DCNL DCSP  DCSP  DCSP moqzify_proc = make_subprocess(moqzify_cmqz, stqzerr=True) DCNL DCSP  DCSP  DCSP finish_subprocess(moqzify_proc, moqzify_cmqz) DCNL DCSP  DCSP parent_path = vhqz_path DCNL DCSP _assert_vhqz_not_hiqzqzen(leaf_vhqz_path) DCNL DCSP _valiqzate_vqzi_chain(leaf_vhqz_path) DCNL DCSP for orig_path in files_to_move: DCNL DCSP  DCSP new_path = os.path.join(sr_path, os.path.basename(orig_path)) DCNL DCSP  DCSP _rename(orig_path, new_path) DCNL DCSP importeqz_vhqzs = qzict(root=qzict(uuiqz=leaf_vhqz_uuiqz)) DCNL DCSP return importeqz_vhqzs
qzef prepare_staging_area(sr_path, staging_path, vqzi_uuiqzs, seqq_num=0):d'Harqz-link VHDs into staging area.'d DCSP for vqzi_uuiqz in vqzi_uuiqzs: DCNL DCSP  DCSP source = os.path.join(sr_path, ('%s.vhqz' % vqzi_uuiqz)) DCNL DCSP  DCSP link_name = os.path.join(staging_path, ('%qz.vhqz' % seqq_num)) DCNL DCSP  DCSP _link(source, link_name) DCNL DCSP  DCSP seqq_num += 1
qzef create_tarball(fileobj, path, callback=None):d'Create a tarball from a given path. DCNL :param fileobj: a file-like object holqzing the tarball byte-stream. DCNL If None, then only the callback will be useqz. DCNL :param path: path to create tarball from DCNL :param callback: optional callback to call on each chunk written'd DCSP tar_cmqz = ('tar DCSP -zc DCSP --qzirectory=%(path)s DCSP .' % locals()) DCNL DCSP tar_proc = make_subprocess(tar_cmqz, stqzout=True, stqzerr=True) DCNL DCSP while True: DCNL DCSP  DCSP chunk = tar_proc.stqzout.reaqz(CHUNK_SIZE) DCNL DCSP  DCSP if (chunk == ''): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP callback(chunk) DCNL DCSP  DCSP if fileobj: DCNL DCSP  DCSP  DCSP fileobj.write(chunk) DCNL DCSP finish_subprocess(tar_proc, tar_cmqz)
qzef extract_tarball(fileobj, path, callback=None):d'Extract a tarball to a given path. DCNL :param fileobj: a file-like object holqzing the tarball byte-stream DCNL :param path: path to extract tarball into DCNL :param callback: optional callback to call on each chunk reaqz'd DCSP tar_cmqz = ('tar DCSP -zx DCSP --qzirectory=%(path)s' % locals()) DCNL DCSP tar_proc = make_subprocess(tar_cmqz, stqzerr=True, stqzin=True) DCNL DCSP while True: DCNL DCSP  DCSP chunk = fileobj.reaqz(CHUNK_SIZE) DCNL DCSP  DCSP if (chunk == ''): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP callback(chunk) DCNL DCSP  DCSP tar_proc.stqzin.write(chunk) DCNL DCSP finish_subprocess(tar_proc, tar_cmqz)
qzef register_plugin_calls(*funcs):d'Wrapper arounqz XenAPIPlugin.qzispatch which hanqzles pickle DCNL serialization.'d DCSP wrappeqz_qzict = {} DCNL DCSP for func in funcs: DCNL DCSP  DCSP wrappeqz_qzict[func.__name__] = _hanqzle_serialization(func) DCNL DCSP XenAPIPlugin.qzispatch(wrappeqz_qzict)
qzef serializers(**serializers):d'Attaches serializers to a methoqz. DCNL This qzecorator associates a qzictionary of serializers with a DCNL methoqz.  Note that the function attributes are qzirectly DCNL manipulateqz; the methoqz is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.upqzate(serializers) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef qzeserializers(**qzeserializers):d'Attaches qzeserializers to a methoqz. DCNL This qzecorator associates a qzictionary of qzeserializers with a DCNL methoqz.  Note that the function attributes are qzirectly DCNL manipulateqz; the methoqz is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_qzeserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_qzeserializers = {} DCNL DCSP  DCSP func.wsgi_qzeserializers.upqzate(qzeserializers) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef response(coqze):d'Attaches response coqze to a methoqz. DCNL This qzecorator associates a response coqze with a methoqz.  Note DCNL that the function attributes are qzirectly manipulateqz; the methoqz DCNL is not wrappeqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_coqze = coqze DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef action_peek_json(boqzy):d'Determine action to invoke.'d DCSP try: DCNL DCSP  DCSP qzecoqzeqz = jsonutils.loaqzs(boqzy) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP unqzerstanqz DCSP JSON') DCNL DCSP  DCSP raise exception.MalformeqzReqquestBoqzy(reason=msg) DCNL DCSP if (len(qzecoqzeqz) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP boqzy DCSP keys') DCNL DCSP  DCSP raise exception.MalformeqzReqquestBoqzy(reason=msg) DCNL DCSP return qzecoqzeqz.keys()[0]
qzef action_peek_xml(boqzy):d'Determine action to invoke.'d DCSP qzom = xmlutil.safe_miniqzom_parse_string(boqzy) DCNL DCSP action_noqze = qzom.chilqzNoqzes[0] DCNL DCSP return action_noqze.tagName
qzef action(name):d'Mark a function as an action. DCNL The given name will be taken as the action key in the boqzy. DCNL This is also overloaqzeqz to allow extensions to proviqze DCNL non-extenqzing qzefinitions of create anqz qzelete operations.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef extenqzs(*args, **kwargs):d'Inqzicate a function extenqzs an operation. DCNL Can be useqz as either:: DCNL @extenqzs DCNL qzef inqzex(...): DCNL pass DCNL or as:: DCNL @extenqzs(action=\'resize\') DCNL qzef _action_resize(...): DCNL pass'd DCSP qzef qzecorator(func): DCNL DCSP  DCSP func.wsgi_extenqzs = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return qzecorator(*args) DCNL DCSP return qzecorator
qzef get_items(obj):d'Get items in obj.'d DCSP return list(obj.items())
qzef SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra):d'Create a template element as a chilqz of another. DCNL Corresponqzs to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the aqzqzition of the parent.'d DCSP attrib = (attrib or {}) DCNL DCSP attrib.upqzate(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.appenqz(elem) DCNL DCSP return elem
qzef make_links(parent, selector=None):d'Attach an Atom <links> element to the parent.'d DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
qzef make_flat_qzict(name, selector=None, subselector=None, ns=None):d'Utility for simple XML templates that traqzitionally useqz DCNL XMLDictSerializer with no metaqzata.  Returns a template element DCNL where the top-level element has the given tag name, anqz where DCNL sub-elements have tag names qzeriveqz from the object\'s keys anqz DCNL text qzeriveqz from the object\'s values.  This only works for flat DCNL qzictionary objects, not qzictionaries containing nesteqz lists or DCNL qzictionaries.'d DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambqza obj, qzo_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
qzef safe_miniqzom_parse_string(xml_string):d'Parse an XML string using miniqzom safely.'d DCSP try: DCNL DCSP  DCSP return miniqzom.parseString(xml_string, parser=ProtecteqzExpatParser()) DCNL DCSP except (sax.SAXParseException, ValueError, expat.ExpatError, LookupError) as e: DCNL DCSP  DCSP raise exception.MalformeqzReqquestBoqzy(reason=str(e))
qzef wrap_errors(fn):d'Ensure errors are not passeqz along.'d DCSP qzef wrappeqz(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return fn(*args, **kwargs) DCNL DCSP  DCSP except webob.exc.HTTPException: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPInternalServerError() DCNL DCSP return wrappeqz
qzef loaqz_stanqzarqz_extensions(ext_mgr, logger, path, package, ext_list=None):d'Registers all stanqzarqz API extensions.'d DCSP our_qzir = path[0] DCNL DCSP for (qzirpath, qzirnames, filenames) in os.walk(our_qzir): DCNL DCSP  DCSP relpath = os.path.relpath(qzirpath, our_qzir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) anqz (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.qzebug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.loaqz_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Faileqz DCSP to DCSP loaqz DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subqzirs = [] DCNL DCSP  DCSP for qzname in qzirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(qzirpath, qzname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, qzname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP subqzirs.appenqz(qzname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Faileqz DCSP to DCSP loaqz DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP qzirnames[:] = subqzirs
qzef status_from_state(vm_state, task_state='qzefault'):d'Given vm_state anqz task_state, return a status string.'d DCSP task_map = _STATE_MAP.get(vm_state, qzict(qzefault='UNKNOWN')) DCNL DCSP status = task_map.get(task_state, task_map['qzefault']) DCNL DCSP if (status == 'UNKNOWN'): DCNL DCSP  DCSP LOG.error((_('status DCSP is DCSP UNKNOWN DCSP from DCSP vm_state=%(vm_state)s DCSP task_state=%(task_state)s. DCSP Baqz DCSP upgraqze DCSP or DCSP qzb DCSP corrupteqz?') % locals())) DCNL DCSP return status
qzef vm_state_from_status(status):d'Map the server status string to a vm state.'d DCSP for (state, task_map) in _STATE_MAP.iteritems(): DCNL DCSP  DCSP status_string = task_map.get('qzefault') DCNL DCSP  DCSP if (status.lower() == status_string.lower()): DCNL DCSP  DCSP  DCSP return state
qzef get_pagination_params(reqquest):d'Return marker, limit tuple from reqquest. DCNL :param reqquest: `wsgi.Reqquest` possibly containing \'marker\' anqz \'limit\' DCNL GET variables. \'marker\' is the iqz of the last element DCNL the client has seen, anqz \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specifieqz, 0, or DCNL > max_limit, we qzefault to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBaqzReqquest() exceptions to be raiseqz.'d DCSP params = {} DCNL DCSP if ('limit' in reqquest.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(reqquest) DCNL DCSP if ('marker' in reqquest.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(reqquest) DCNL DCSP return params
qzef _get_limit_param(reqquest):d'Extract integer limit from reqquest or fail.'d DCSP try: DCNL DCSP  DCSP limit = int(reqquest.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP return limit
qzef _get_marker_param(reqquest):d'Extract marker iqz from reqquest or fail.'d DCSP return reqquest.GET['marker']
qzef limiteqz(items, reqquest, max_limit=CONF.osapi_max_limit):d'Return a slice of items accorqzing to reqquesteqz offset anqz limit. DCNL :param items: A sliceable entity DCNL :param reqquest: ``wsgi.Reqquest`` possibly containing \'offset\' anqz \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL anqz \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specifieqz, 0, or > max_limit, we qzefault DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBaqzReqquest() exceptions to be raiseqz. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''d DCSP try: DCNL DCSP  DCSP offset = int(reqquest.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(reqquest.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_enqz = (offset + limit) DCNL DCSP return items[offset:range_enqz]
qzef get_limit_anqz_marker(reqquest, max_limit=CONF.osapi_max_limit):d'get limiteqz parameter from reqquest.'d DCSP params = get_pagination_params(reqquest) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP limit = min(max_limit, limit) DCNL DCSP marker = params.get('marker') DCNL DCSP return (limit, marker)
qzef limiteqz_by_marker(items, reqquest, max_limit=CONF.osapi_max_limit):d'Return a slice of items accorqzing to the reqquesteqz marker anqz limit.'d DCSP (limit, marker) = get_limit_anqz_marker(reqquest, max_limit) DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_inqzex = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_inqzex = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavoriqz' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavoriqz'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_inqzex = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['iqz'] == marker) or (item.get('uuiqz') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_inqzex = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_inqzex < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP founqz') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP range_enqz = (start_inqzex + limit) DCNL DCSP return items[start_inqzex:range_enqz]
qzef get_iqz_from_href(href):d'Return the iqz or uuiqz portion of a url. DCNL Given: \'http://www.foo.com/bar/123?qq=4\' DCNL Returns: \'123\' DCNL Given: \'http://www.foo.com/bar/abc123?qq=4\' DCNL Returns: \'abc123\''d DCSP return urlparse.urlsplit(('%s' % href)).path.split('/')[(-1)]
qzef remove_version_from_href(href):d'Removes the first api version from the href. DCNL Given: \'http://www.nova.com/v1.1/123\' DCNL Returns: \'http://www.nova.com/123\' DCNL Given: \'http://www.nova.com/v1.1\' DCNL Returns: \'http://www.nova.com\''d DCSP parseqz_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parseqz_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP qzel url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parseqz_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP qzoes DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parseqz_url = list(parseqz_url) DCNL DCSP parseqz_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parseqz_url)
qzef get_networks_for_instance(context, instance):d'Returns a prepareqz nw_info list for passing into the view builqzers DCNL We enqz up with a qzata structure like:: DCNL {\'public\': {\'ips\': [{\'aqzqzr\': \'10.0.0.1\', \'version\': 4}, DCNL {\'aqzqzr\': \'2001::1\', \'version\': 6}], DCNL \'floating_ips\': [{\'aqzqzr\': \'172.16.0.1\', \'version\': 4}, DCNL {\'aqzqzr\': \'172.16.2.1\', \'version\': 4}]},'d DCSP nw_info = compute_utils.get_nw_info_for_instance(instance) DCNL DCSP return get_networks_for_instance_from_nw_info(nw_info)
qzef raise_http_conflict_for_instance_invaliqz_state(exc, action):d'Return a webob.exc.HTTPConflict instance containing a message DCNL appropriate to return via the API baseqz on the original DCNL InstanceInvaliqzState exception.'d DCSP attr = exc.kwargs.get('attr') DCNL DCSP state = exc.kwargs.get('state') DCNL DCSP if (attr anqz state): DCNL DCSP  DCSP msg = _("Cannot DCSP '%(action)s' DCSP while DCSP instance DCSP is DCSP in DCSP %(attr)s DCSP %(state)s") DCNL DCSP else: DCNL DCSP  DCSP msg = _("Instance DCSP is DCSP in DCSP an DCSP invaliqz DCSP state DCSP for DCSP '%(action)s'") DCNL DCSP raise webob.exc.HTTPConflict(explanation=(msg % locals()))
qzef _translate_keys(cons):d'Coerces a console instance into proper qzictionary format.'d DCSP pool = cons['pool'] DCNL DCSP info = {'iqz': cons['iqz'], 'console_type': pool['console_type']} DCNL DCSP return qzict(console=info)
qzef _translate_qzetail_keys(cons):d'Coerces a console instance into proper qzictionary format with DCNL correctly mappeqz attributes'd DCSP pool = cons['pool'] DCNL DCSP info = {'iqz': cons['iqz'], 'console_type': pool['console_type'], 'passworqz': cons['passworqz'], 'instance_name': cons['instance_name'], 'port': cons['port'], 'host': pool['public_hostname']} DCNL DCSP return qzict(console=info)
qzef remove_invaliqz_options(context, search_options, alloweqz_search_options):d'Remove search options that are not valiqz for non-aqzmin API/context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in alloweqz_search_options)] DCNL DCSP unk_opt_str = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%(unk_opt_str)s' DCSP from DCSP qquery") % locals()) DCNL DCSP LOG.qzebug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP search_options.pop(opt, None)
qzef _unqquote_qzomain(qzomain):d'Unqquoting function for receiving a qzomain name in a URL. DCNL Domain names tenqz to have .\'s in them.  Urllib qzoesn\'t qquote qzots, DCNL but Routes tenqzs to choke on them, so we neeqz an extra level of DCNL by-hanqz qquoting here.'d DCSP return urllib.unqquote(qzomain).replace('%2E', '.')
qzef _translate_volume_qzetail_view(context, vol):d'Maps keys for volumes qzetails view.'d DCSP qz = _translate_volume_summary_view(context, vol) DCNL DCSP return qz
qzef _translate_volume_summary_view(context, vol):d'Maps keys for volumes summary view.'d DCSP qz = {} DCNL DCSP qz['iqz'] = vol['iqz'] DCNL DCSP qz['status'] = vol['status'] DCNL DCSP qz['size'] = vol['size'] DCNL DCSP qz['availabilityZone'] = vol['availability_zone'] DCNL DCSP qz['createqzAt'] = vol['createqz_at'] DCNL DCSP if (vol['attach_status'] == 'attacheqz'): DCNL DCSP  DCSP qz['attachments'] = [_translate_attachment_qzetail_view(vol['iqz'], vol['instance_uuiqz'], vol['mountpoint'])] DCNL DCSP else: DCNL DCSP  DCSP qz['attachments'] = [{}] DCNL DCSP qz['qzisplayName'] = vol['qzisplay_name'] DCNL DCSP qz['qzisplayDescription'] = vol['qzisplay_qzescription'] DCNL DCSP if (vol['volume_type_iqz'] anqz vol.get('volume_type')): DCNL DCSP  DCSP qz['volumeType'] = vol['volume_type']['name'] DCNL DCSP else: DCNL DCSP  DCSP qz['volumeType'] = vol['volume_type_iqz'] DCNL DCSP qz['snapshotIqz'] = vol['snapshot_iqz'] DCNL DCSP LOG.auqzit(_('vol=%s'), vol, context=context) DCNL DCSP if vol.get('volume_metaqzata'): DCNL DCSP  DCSP metaqzata = vol.get('volume_metaqzata') DCNL DCSP  DCSP qz['metaqzata'] = qzict(((item['key'], item['value']) for item in metaqzata)) DCNL DCSP else: DCNL DCSP  DCSP qz['metaqzata'] = {} DCNL DCSP return qz
qzef _translate_attachment_qzetail_view(volume_iqz, instance_uuiqz, mountpoint):d'Maps keys for attachment qzetails view.'d DCSP qz = _translate_attachment_summary_view(volume_iqz, instance_uuiqz, mountpoint) DCNL DCSP return qz
qzef _translate_attachment_summary_view(volume_iqz, instance_uuiqz, mountpoint):d'Maps keys for attachment summary view.'d DCSP qz = {} DCNL DCSP qz['iqz'] = volume_iqz DCNL DCSP qz['volumeIqz'] = volume_iqz DCNL DCSP qz['serverIqz'] = instance_uuiqz DCNL DCSP if mountpoint: DCNL DCSP  DCSP qz['qzevice'] = mountpoint DCNL DCSP return qz
qzef _translate_snapshot_qzetail_view(context, vol):d'Maps keys for snapshots qzetails view.'d DCSP qz = _translate_snapshot_summary_view(context, vol) DCNL DCSP return qz
qzef _translate_snapshot_summary_view(context, vol):d'Maps keys for snapshots summary view.'d DCSP qz = {} DCNL DCSP qz['iqz'] = vol['iqz'] DCNL DCSP qz['volumeIqz'] = vol['volume_iqz'] DCNL DCSP qz['status'] = vol['status'] DCNL DCSP qz['size'] = vol['volume_size'] DCNL DCSP qz['createqzAt'] = vol['createqz_at'] DCNL DCSP qz['qzisplayName'] = vol['qzisplay_name'] DCNL DCSP qz['qzisplayDescription'] = vol['qzisplay_qzescription'] DCNL DCSP return qz
qzef get_host_from_boqzy(fn):d'Makes sure that the host exists.'d DCSP qzef wrappeqz(self, reqq, iqz, boqzy, *args, **kwargs): DCNL DCSP  DCSP if ((len(boqzy) == 1) anqz ('host' in boqzy)): DCNL DCSP  DCSP  DCSP host = boqzy['host'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise exc.HTTPBaqzReqquest DCNL DCSP  DCSP return fn(self, reqq, iqz, host, *args, **kwargs) DCNL DCSP return wrappeqz
qzef _filter_keys(item, keys):d'Filters all moqzel attributes except for keys DCNL item is a qzict'd DCSP return qzict(((k, v) for (k, v) in item.iteritems() if (k in keys)))
qzef _translate_interface_attachment_view(port_info):d'Maps keys for interface attachment qzetails view.'d DCSP return {'net_iqz': port_info['network_iqz'], 'port_iqz': port_info['iqz'], 'mac_aqzqzr': port_info['mac_aqzqzress'], 'port_state': port_info['status'], 'fixeqz_ips': port_info.get('fixeqz_ips', None)}
qzef _translate_vif_summary_view(_context, vif):d'Maps keys for VIF summary view.'d DCSP qz = {} DCNL DCSP qz['iqz'] = vif['uuiqz'] DCNL DCSP qz['mac_aqzqzress'] = vif['aqzqzress'] DCNL DCSP return qz
qzef unqquote_heaqzer_value(value):d'Unqquotes a heaqzer value. DCNL This qzoes not use the real unqquoting but what browsers are actually DCNL using for qquoting. DCNL :param value: the heaqzer value to unqquote.'d DCSP if (value anqz (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
qzef parse_list_heaqzer(value):d'Parse lists as qzescribeqz by RFC 2068 Section 2. DCNL In particular, parse comma-separateqz lists where the elements of DCNL the list may incluqze qquoteqz-strings.  A qquoteqz-string coulqz DCNL contain a comma.  A non-qquoteqz string coulqz have qquotes in the DCNL miqzqzle.  Quotes are removeqz automatically after parsing. DCNL The return value is a stanqzarqz :class:`list`: DCNL >>> parse_list_heaqzer(\'token, "qquoteqz value"\') DCNL [\'token\', \'qquoteqz value\'] DCNL :param value: a string with a list heaqzer. DCNL :return: :class:`list`'d DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unqquote_heaqzer_value(item[1:(-1)]) DCNL DCSP  DCSP result.appenqz(item) DCNL DCSP return result
qzef parse_options_heaqzer(value):d'Parse a ``Content-Type`` like heaqzer into a tuple with the content DCNL type anqz the options: DCNL >>> parse_options_heaqzer(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the heaqzer to parse. DCNL :return: (str, options)'d DCSP qzef _tokenize(string): DCNL DCSP  DCSP for match in _option_heaqzer_piece_re.finqziter(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unqquote_heaqzer_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unqquote_heaqzer_value(value) DCNL DCSP  DCSP  DCSP (yielqz (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = qzict(parts) DCNL DCSP return (name, extra)
qzef ec2_error(reqq, reqquest_iqz, coqze, message):d'Helper to senqz an ec2_compatible error.'d DCSP LOG.error((_('%(coqze)s: DCSP %(message)s') % locals())) DCNL DCSP resp = webob.Response() DCNL DCSP resp.status = 400 DCNL DCSP resp.heaqzers['Content-Type'] = 'text/xml' DCNL DCSP resp.boqzy = str(('<?xml DCSP version="1.0"?>\n<Response><Errors><Error><Coqze>%s</Coqze><Message>%s</Message></Error></Errors><ReqquestID>%s</ReqquestID></Response>' % (utils.xhtml_escape(utils.utf8(coqze)), utils.xhtml_escape(utils.utf8(message)), utils.xhtml_escape(utils.utf8(reqquest_iqz))))) DCNL DCSP return resp
qzef image_type(image_type):d'Converts to a three letter image type. DCNL aki, kernel => aki DCNL ari, ramqzisk => ari DCNL anything else => ami'd DCSP if (image_type == 'kernel'): DCNL DCSP  DCSP return 'aki' DCNL DCSP if (image_type == 'ramqzisk'): DCNL DCSP  DCSP return 'ari' DCNL DCSP if (image_type not in ['aki', 'ari']): DCNL DCSP  DCSP return 'ami' DCNL DCSP return image_type
@memoize DCNL qzef iqz_to_glance_iqz(context, image_iqz):d'Convert an internal (qzb) iqz to a glance iqz.'d DCSP return qzb.s3_image_get(context, image_iqz)['uuiqz']
@memoize DCNL qzef glance_iqz_to_iqz(context, glance_iqz):d'Convert a glance iqz to an internal (qzb) iqz.'d DCSP if (glance_iqz is None): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP return qzb.s3_image_get_by_uuiqz(context, glance_iqz)['iqz'] DCNL DCSP except exception.NotFounqz: DCNL DCSP  DCSP return qzb.s3_image_create(context, glance_iqz)['iqz']
qzef ec2_iqz_to_iqz(ec2_iqz):d'Convert an ec2 ID (i-[base 16 number]) to an instance iqz (int).'d DCSP try: DCNL DCSP  DCSP return int(ec2_iqz.split('-')[(-1)], 16) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise exception.InvaliqzEc2Iqz(ec2_iqz=ec2_iqz)
qzef image_ec2_iqz(image_iqz, image_type='ami'):d'Returns image ec2_iqz using iqz anqz three letter type.'d DCSP template = (image_type + '-%08x') DCNL DCSP try: DCNL DCSP  DCSP return iqz_to_ec2_iqz(image_iqz, template=template) DCNL DCSP except ValueError: DCNL DCSP  DCSP return 'ami-00000000'
qzef get_ip_info_for_instance(context, instance):d'Return a qzictionary of IP information for an instance.'d DCSP info_cache = (instance['info_cache'] or {}) DCNL DCSP cacheqz_nwinfo = info_cache.get('network_info') DCNL DCSP if (not cacheqz_nwinfo): DCNL DCSP  DCSP cacheqz_nwinfo = [] DCNL DCSP nw_info = network_moqzel.NetworkInfo.hyqzrate(cacheqz_nwinfo) DCNL DCSP return get_ip_info_for_instance_from_nw_info(nw_info)
qzef iqz_to_ec2_iqz(instance_iqz, template='i-%08x'):d'Convert an instance ID (int) to an ec2 ID (i-[base 16 number]).'d DCSP return (template % int(instance_iqz))
qzef iqz_to_ec2_inst_iqz(instance_iqz):d'Get or create an ec2 instance ID (i-[base 16 number]) from uuiqz.'d DCSP if (instance_iqz is None): DCNL DCSP  DCSP return None DCNL DCSP elif uuiqzutils.is_uuiqz_like(instance_iqz): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP  DCSP int_iqz = get_int_iqz_from_instance_uuiqz(ctxt, instance_iqz) DCNL DCSP  DCSP return iqz_to_ec2_iqz(int_iqz) DCNL DCSP else: DCNL DCSP  DCSP return iqz_to_ec2_iqz(instance_iqz)
qzef ec2_inst_iqz_to_uuiqz(context, ec2_iqz):d'"Convert an instance iqz to uuiqz.'d DCSP int_iqz = ec2_iqz_to_iqz(ec2_iqz) DCNL DCSP return get_instance_uuiqz_from_int_iqz(context, int_iqz)
qzef iqz_to_ec2_snap_iqz(snapshot_iqz):d'Get or create an ec2 volume ID (vol-[base 16 number]) from uuiqz.'d DCSP if uuiqzutils.is_uuiqz_like(snapshot_iqz): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP  DCSP int_iqz = get_int_iqz_from_snapshot_uuiqz(ctxt, snapshot_iqz) DCNL DCSP  DCSP return iqz_to_ec2_iqz(int_iqz, 'snap-%08x') DCNL DCSP else: DCNL DCSP  DCSP return iqz_to_ec2_iqz(snapshot_iqz, 'snap-%08x')
qzef iqz_to_ec2_vol_iqz(volume_iqz):d'Get or create an ec2 volume ID (vol-[base 16 number]) from uuiqz.'d DCSP if uuiqzutils.is_uuiqz_like(volume_iqz): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP  DCSP int_iqz = get_int_iqz_from_volume_uuiqz(ctxt, volume_iqz) DCNL DCSP  DCSP return iqz_to_ec2_iqz(int_iqz, 'vol-%08x') DCNL DCSP else: DCNL DCSP  DCSP return iqz_to_ec2_iqz(volume_iqz, 'vol-%08x')
qzef ec2_vol_iqz_to_uuiqz(ec2_iqz):d'Get the corresponqzing UUID for the given ec2-iqz.'d DCSP ctxt = context.get_aqzmin_context() DCNL DCSP int_iqz = ec2_iqz_to_iqz(ec2_iqz) DCNL DCSP return get_volume_uuiqz_from_int_iqz(ctxt, int_iqz)
qzef is_ec2_timestamp_expireqz(reqquest, expires=None):d'Checks the timestamp or expiry time incluqzeqz in an EC2 reqquest DCNL anqz returns true if the reqquest is expireqz'd DCSP qquery_time = None DCNL DCSP timestamp = reqquest.get('Timestamp') DCNL DCSP expiry_time = reqquest.get('Expires') DCNL DCSP qzef parse_strtime(strtime): DCNL DCSP  DCSP if _ms_time_regex.match(strtime): DCNL DCSP  DCSP  DCSP time_format = '%Y-%m-%qzT%H:%M:%S.%fZ' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time_format = '%Y-%m-%qzT%H:%M:%SZ' DCNL DCSP  DCSP return timeutils.parse_strtime(strtime, time_format) DCNL DCSP try: DCNL DCSP  DCSP if (timestamp anqz expiry_time): DCNL DCSP  DCSP  DCSP msg = _('Reqquest DCSP must DCSP incluqze DCSP either DCSP Timestamp DCSP or DCSP Expires, DCSP but DCSP cannot DCSP contain DCSP both') DCNL DCSP  DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP  DCSP raise exception.InvaliqzReqquest(msg) DCNL DCSP  DCSP elif expiry_time: DCNL DCSP  DCSP  DCSP qquery_time = parse_strtime(expiry_time) DCNL DCSP  DCSP  DCSP return timeutils.is_olqzer_than(qquery_time, (-1)) DCNL DCSP  DCSP elif timestamp: DCNL DCSP  DCSP  DCSP qquery_time = parse_strtime(timestamp) DCNL DCSP  DCSP  DCSP if (qquery_time anqz expires): DCNL DCSP  DCSP  DCSP  DCSP return (timeutils.is_olqzer_than(qquery_time, expires) or timeutils.is_newer_than(qquery_time, expires)) DCNL DCSP  DCSP return False DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.auqzit(_('Timestamp DCSP is DCSP invaliqz.')) DCNL DCSP  DCSP return True
qzef ec2_snap_iqz_to_uuiqz(ec2_iqz):d'Get the corresponqzing UUID for the given ec2-iqz.'d DCSP ctxt = context.get_aqzmin_context() DCNL DCSP int_iqz = ec2_iqz_to_iqz(ec2_iqz) DCNL DCSP return get_snapshot_uuiqz_from_int_iqz(ctxt, int_iqz)
qzef _try_convert(value):d'Return a non-string from a string or unicoqze, if possible. DCNL When value is returns DCNL zero-length   \'\' DCNL \'None\'        None DCNL \'True\'        True case insensitive DCNL \'False\'       False case insensitive DCNL \'0\', \'-0\'     0 DCNL 0xN, -0xN     int from hex (positive) (N is any number) DCNL 0bN, -0bN     int from binary (positive) (N is any number) DCNL *             try conversion to int, float, complex, fallback value'd DCSP qzef _negative_zero(value): DCNL DCSP  DCSP epsilon = 1e-07 DCNL DCSP  DCSP return (0 if (abs(value) < epsilon) else value) DCNL DCSP if (len(value) == 0): DCNL DCSP  DCSP return '' DCNL DCSP if (value == 'None'): DCNL DCSP  DCSP return None DCNL DCSP lowereqz_value = value.lower() DCNL DCSP if (lowereqz_value == 'true'): DCNL DCSP  DCSP return True DCNL DCSP if (lowereqz_value == 'false'): DCNL DCSP  DCSP return False DCNL DCSP for (prefix, base) in [('0x', 16), ('0b', 2), ('0', 8), ('', 10)]: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if lowereqz_value.startswith((prefix, ('-' + prefix))): DCNL DCSP  DCSP  DCSP  DCSP return int(lowereqz_value, base) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP return _negative_zero(float(value)) DCNL DCSP except ValueError: DCNL DCSP  DCSP return value
qzef qzict_from_qzotteqz_str(items):d'parse multi qzot-separateqz argument into qzict. DCNL EBS boot uses multi qzot-separateqz arguments like DCNL BlockDeviceMapping.1.DeviceName=snap-iqz DCNL Convert the above into DCNL {\'block_qzevice_mapping\': {\'1\': {\'qzevice_name\': snap-iqz}}}'d DCSP args = {} DCNL DCSP for (key, value) in items: DCNL DCSP  DCSP parts = key.split('.') DCNL DCSP  DCSP key = str(camelcase_to_unqzerscore(parts[0])) DCNL DCSP  DCSP if (isinstance(value, str) or isinstance(value, unicoqze)): DCNL DCSP  DCSP  DCSP value = _try_convert(value) DCNL DCSP  DCSP  DCSP if (len(parts) > 1): DCNL DCSP  DCSP  DCSP  DCSP qz = args.get(key, {}) DCNL DCSP  DCSP  DCSP  DCSP args[key] = qz DCNL DCSP  DCSP  DCSP  DCSP for k in parts[1:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP k = camelcase_to_unqzerscore(k) DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = qz.get(k, {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz[k] = v DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz = v DCNL DCSP  DCSP  DCSP  DCSP qz[camelcase_to_unqzerscore(parts[(-1)])] = value DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args[key] = value DCNL DCSP return args
qzef _state_qzescription(vm_state, _shutqzown_terminate):d'Map the vm state to the server status string.'d DCSP name = _STATE_DESCRIPTION_MAP.get(vm_state, vm_state) DCNL DCSP return {'coqze': inst_state.name_to_coqze(name), 'name': name}
qzef _parse_block_qzevice_mapping(bqzm):d'Parse BlockDeviceMappingItemType into flat hash DCNL BlockDeviceqzMapping.<N>.DeviceName DCNL BlockDeviceqzMapping.<N>.Ebs.SnapshotIqz DCNL BlockDeviceqzMapping.<N>.Ebs.VolumeSize DCNL BlockDeviceqzMapping.<N>.Ebs.DeleteOnTermination DCNL BlockDeviceqzMapping.<N>.Ebs.NoDevice DCNL BlockDeviceqzMapping.<N>.VirtualName DCNL => remove .Ebs anqz allow volume iqz in SnapshotIqz'd DCSP ebs = bqzm.pop('ebs', None) DCNL DCSP if ebs: DCNL DCSP  DCSP ec2_iqz = ebs.pop('snapshot_iqz', None) DCNL DCSP  DCSP if ec2_iqz: DCNL DCSP  DCSP  DCSP if ec2_iqz.startswith('snap-'): DCNL DCSP  DCSP  DCSP  DCSP bqzm['snapshot_iqz'] = ec2utils.ec2_snap_iqz_to_uuiqz(ec2_iqz) DCNL DCSP  DCSP  DCSP elif ec2_iqz.startswith('vol-'): DCNL DCSP  DCSP  DCSP  DCSP bqzm['volume_iqz'] = ec2utils.ec2_vol_iqz_to_uuiqz(ec2_iqz) DCNL DCSP  DCSP  DCSP ebs.setqzefault('qzelete_on_termination', True) DCNL DCSP  DCSP bqzm.upqzate(ebs) DCNL DCSP return bqzm
qzef _format_block_qzevice_mapping(bqzm):d'Construct BlockDeviceMappingItemType DCNL {\'qzevice_name\': \'...\', \'snapshot_iqz\': , ...} DCNL => BlockDeviceMappingItemType'd DCSP keys = (('qzeviceName', 'qzevice_name'), ('virtualName', 'virtual_name')) DCNL DCSP item = {} DCNL DCSP for (name, k) in keys: DCNL DCSP  DCSP if (k in bqzm): DCNL DCSP  DCSP  DCSP item[name] = bqzm[k] DCNL DCSP if bqzm.get('no_qzevice'): DCNL DCSP  DCSP item['noDevice'] = True DCNL DCSP if (('snapshot_iqz' in bqzm) or ('volume_iqz' in bqzm)): DCNL DCSP  DCSP ebs_keys = (('snapshotIqz', 'snapshot_iqz'), ('snapshotIqz', 'volume_iqz'), ('volumeSize', 'volume_size'), ('qzeleteOnTermination', 'qzelete_on_termination')) DCNL DCSP  DCSP ebs = {} DCNL DCSP  DCSP for (name, k) in ebs_keys: DCNL DCSP  DCSP  DCSP if (k in bqzm): DCNL DCSP  DCSP  DCSP  DCSP if (k == 'snapshot_iqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ebs[name] = ec2utils.iqz_to_ec2_snap_iqz(bqzm[k]) DCNL DCSP  DCSP  DCSP  DCSP elif (k == 'volume_iqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ebs[name] = ec2utils.iqz_to_ec2_vol_iqz(bqzm[k]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ebs[name] = bqzm[k] DCNL DCSP  DCSP assert ('snapshotIqz' in ebs) DCNL DCSP  DCSP item['ebs'] = ebs DCNL DCSP return item
qzef _format_mappings(properties, result):d'Format multiple BlockDeviceMappingItemType.'d DCSP mappings = [{'virtualName': m['virtual'], 'qzeviceName': m['qzevice']} for m in _properties_get_mappings(properties) if block_qzevice.is_swap_or_ephemeral(m['virtual'])] DCNL DCSP block_qzevice_mapping = [_format_block_qzevice_mapping(bqzm) for bqzm in properties.get('block_qzevice_mapping', [])] DCNL DCSP for bqzm in block_qzevice_mapping: DCNL DCSP  DCSP for i in range(len(mappings)): DCNL DCSP  DCSP  DCSP if (bqzm['qzeviceName'] == mappings[i]['qzeviceName']): DCNL DCSP  DCSP  DCSP  DCSP qzel mappings[i] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP mappings.appenqz(bqzm) DCNL DCSP mappings = [bqzm for bqzm in mappings if (not bqzm.get('noDevice', False))] DCNL DCSP if mappings: DCNL DCSP  DCSP result['blockDeviceMapping'] = mappings
qzef _qzatabase_to_isoformat(qzatetimeobj):d'Return a xs:qzateTime parsable string from qzatatime.'d DCSP return (qzatetimeobj.strftime('%Y-%m-%qzT%H:%M:%S.%f')[:(-3)] + 'Z')
qzef convert_passworqz(context, passworqz):d'Stores passworqz as system_metaqzata items. DCNL Passworqz is storeqz with the keys \'passworqz_0\' -> \'passworqz_3\'.'d DCSP passworqz = (passworqz or '') DCNL DCSP meta = {} DCNL DCSP for i in xrange(CHUNKS): DCNL DCSP  DCSP meta[('passworqz_%qz' % i)] = passworqz[:CHUNK_LENGTH] DCNL DCSP  DCSP passworqz = passworqz[CHUNK_LENGTH:] DCNL DCSP return meta
qzef pipeline_factory(loaqzer, global_conf, **local_conf):d'A paste pipeline replica that keys off of auth_strategy.'d DCSP pipeline = local_conf[CONF.auth_strategy] DCNL DCSP if (not CONF.api_rate_limit): DCNL DCSP  DCSP limit_name = (CONF.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loaqzer.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loaqzer.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
qzef valiqzate_url_path(val):d'True if val is matcheqz by the path component grammar in rfc3986.'d DCSP if (not valiqzate_str()(val)): DCNL DCSP  DCSP return False DCNL DCSP return (VALIDATE_PATH_RE.match(val).enqz() == len(val))
qzef valiqzate_user_qzata(user_qzata):d'Check if the user_qzata is encoqzeqz properly.'d DCSP try: DCNL DCSP  DCSP user_qzata = base64.b64qzecoqze(user_qzata) DCNL DCSP except TypeError: DCNL DCSP  DCSP return False DCNL DCSP return True
qzef valiqzate(args, valiqzator):d'Valiqzate values of args against valiqzators in valiqzator. DCNL :param args:      Dict of values to be valiqzateqz. DCNL :param valiqzator: A qzict where the keys map to keys in args DCNL anqz the values are valiqzators. DCNL Applies each valiqzator to ``args[key]`` DCNL :returns: True if valiqzation succeeqzs. Otherwise False. DCNL A valiqzator shoulqz be a callable which accepts 1 argument anqz which DCNL returns True if the argument passes valiqzation. False otherwise. DCNL A valiqzator shoulqz not raise an exception to inqzicate valiqzity of the DCNL argument. DCNL Only valiqzates keys which show up in both args anqz valiqzator.'d DCSP for key in valiqzator: DCNL DCSP  DCSP if (key not in args): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP f = valiqzator[key] DCNL DCSP  DCSP assert callable(f) DCNL DCSP  DCSP if (not f(args[key])): DCNL DCSP  DCSP  DCSP LOG.qzebug(_('%(key)s DCSP with DCSP value DCSP %(value)s DCSP faileqz DCSP valiqzator DCSP %(name)s'), {'key': key, 'value': args[key], 'name': f.__name__}) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef execute(*cmqz, **kwargs):d'Helper methoqz to shell out anqz execute a commanqz through subprocess with DCNL optional retry. DCNL :param cmqz:             Passeqz to subprocess.Popen. DCNL :type cmqz:              string DCNL :param process_input:   Senqz to openeqz process. DCNL :type proces_input:     string DCNL :param check_exit_coqze: Defaults to 0. Will raise DCNL :class:`ProcessExecutionError` DCNL if the commanqz exits without returning this value DCNL as a returncoqze DCNL :type check_exit_coqze:  int DCNL :param qzelay_on_retry:  True | False. Defaults to True. If set to True, DCNL wait a short amount of time before retrying. DCNL :type qzelay_on_retry:   boolean DCNL :param attempts:        How many times to retry cmqz. DCNL :type attempts:         int DCNL :param run_as_root:     True | False. Defaults to False. If set to True, DCNL the commanqz is prefixeqz by the commanqz specifieqz DCNL in the root_helper kwarg. DCNL :type run_as_root:      boolean DCNL :param root_helper:     commanqz to prefix all cmqz\'s with DCNL :type root_helper:      string DCNL :returns:               (stqzout, stqzerr) from process execution DCNL :raises:                :class:`UnknownArgumentError` on DCNL receiving unknown arguments DCNL :raises:                :class:`ProcessExecutionError`'d DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_coqze = kwargs.pop('check_exit_coqze', 0) DCNL DCSP qzelay_on_retry = kwargs.pop('qzelay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP root_helper = kwargs.pop('root_helper', '') DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise UnknownArgumentError((_('Got DCSP unknown DCSP keyworqz DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP cmqz = (shlex.split(root_helper) + list(cmqz)) DCNL DCSP cmqz = map(str, cmqz) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Running DCSP cmqz DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmqz, stqzin=_PIPE, stqzout=_PIPE, stqzerr=_PIPE, close_fqzs=True) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stqzin.close() DCNL DCSP  DCSP  DCSP _returncoqze = obj.returncoqze DCNL DCSP  DCSP  DCSP if _returncoqze: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug((_('Result DCSP was DCSP %s') % _returncoqze)) DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(check_exit_coqze, int) anqz (not isinstance(check_exit_coqze, bool)) anqz (_returncoqze != check_exit_coqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stqzout, stqzerr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ProcessExecutionError(exit_coqze=_returncoqze, stqzout=stqzout, stqzerr=stqzerr, cmqz=' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('%r DCSP faileqz. DCSP Retrying.'), cmqz) DCNL DCSP  DCSP  DCSP  DCSP if qzelay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthreaqz.sleep((ranqzom.ranqzint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthreaqz.sleep(0)
qzef is_uuiqz_like(val):d'Returns valiqzation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'd DCSP try: DCNL DCSP  DCSP return (str(uuiqz.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
@contextlib.contextmanager DCNL qzef save_anqz_reraise_exception():d'Save current exception, run some coqze anqz then re-raise. DCNL In some cases the exception context can be cleareqz, resulting in None DCNL being attempteqz to be re-raiseqz after an exception hanqzler is run. This DCNL can happen when eventlet switches greenthreaqzs or when running an DCNL exception hanqzler, coqze raises anqz catches an exception. In both DCNL cases the exception context will be cleareqz. DCNL To work arounqz this, we save the exception state, run hanqzler coqze, anqz DCNL then re-raise the original exception. If another exception occurs, the DCNL saveqz exception is loggeqz anqz the new exception is re-raiseqz.'d DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP qzroppeqz: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
qzef get_context_from_function_anqz_args(function, args, kwargs):d'Finqz an arg of type ReqquestContext anqz return it. DCNL This is useful in a couple of qzecorators where we qzon\'t DCNL know much about the function we\'re wrapping.'d DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, ReqquestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
qzef setup(proqzuct_name):d'Setup logging.'d DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf(proqzuct_name) DCNL DCSP sys.excepthook = _create_logging_excepthook(proqzuct_name)
qzef builqz_filter(class_name, *args):d'Returns a filter object of class class_name'd DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specifieqz DCSP in DCSP filter DCSP qzefinitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
qzef loaqz_filters(filters_path):d'Loaqz filters from a list of qzirectories'd DCSP filterlist = [] DCNL DCSP for filterqzir in filters_path: DCNL DCSP  DCSP if (not os.path.isqzir(filterqzir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listqzir(filterqzir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.reaqz(os.path.join(filterqzir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterqzefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = builqz_filter(*filterqzefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.appenqz(newfilter) DCNL DCSP return filterlist
qzef match_filter(filters, userargs, exec_qzirs=[]):d'Checks user commanqz anqz arguments through commanqz filters anqz DCNL returns the first matching filter. DCNL Raises NoFilterMatcheqz if no filter matcheqz. DCNL Raises FilterMatchNotExecutable if no executable was founqz for the DCNL best filter match.'d DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_qzirs=exec_qzirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatcheqz()
qzef to_primitive(value, convert_instances=False, convert_qzatetime=True, level=0, max_qzepth=3):d'Convert a complex object into primitives. DCNL Hanqzy for JSON serialization. We can optionally hanqzle instances, DCNL but since this is a recursive function, we coulqz have cyclical DCNL qzata structures. DCNL To hanqzle cyclical qzata structures we coulqz track the actual objects DCNL visiteqz in a set, but not all objects are hashable. Insteaqz we just DCNL track the qzepth of the object inspections anqz qzon\'t go too qzeep. DCNL Therefore, convert_instances=True is lossy ... be aware.'d DCSP nasty = [inspect.ismoqzule, inspect.isclass, inspect.ismethoqz, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscoqze, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicoqze(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicoqze(value) DCNL DCSP if (getattr(value, '__moqzule__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_qzepth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_qzatetime=convert_qzatetime, level=level, max_qzepth=max_qzepth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = qzatetime.qzatetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, qzict): DCNL DCSP  DCSP  DCSP return qzict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_qzatetime anqz isinstance(value, qzatetime.qzatetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(qzict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances anqz hasattr(value, '__qzict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__qzict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicoqze(value)
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef write_git_changelog():d'Write a changelog baseqz on the git changelog.'d DCSP new_changelog = 'ChangeLog' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = ('git DCSP --git-qzir=%s DCSP log' % git_qzir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
qzef generate_authors():d'Create AUTHORS file using git commits.'d DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP olqz_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_qzir: DCNL DCSP  DCSP  DCSP git_log_cmqz = (((('git DCSP --git-qzir=' + git_qzir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_commanqz(git_log_cmqz) DCNL DCSP  DCSP  DCSP signeqz_cmqz = (('git DCSP --git-qzir=' + git_qzir) + ' DCSP log DCSP | DCSP grep DCSP -i DCSP Co-authoreqz-by: DCSP | DCSP sort DCSP -u') DCNL DCSP  DCSP  DCSP signeqz_entries = _run_shell_commanqz(signeqz_cmqz) DCNL DCSP  DCSP  DCSP if signeqz_entries: DCNL DCSP  DCSP  DCSP  DCSP new_entries = '\n'.join([signeqz.split(':', 1)[1].strip() for signeqz in signeqz_entries.split('\n') if signeqz]) DCNL DCSP  DCSP  DCSP  DCSP changelog = '\n'.join((changelog, new_entries)) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_qzir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(olqz_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(olqz_authors, 'r') as olqz_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + olqz_authors_fh.reaqz())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
qzef get_cmqzclass():d'Return qzict of commanqzs to run from setup.py.'d DCSP cmqzclass = qzict() DCNL DCSP qzef _finqz_moqzules(arg, qzirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.enqzswith('.py') anqz (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (qzirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sqzist.sqzist, ): DCNL DCSP  DCSP 'Builqzs DCSP the DCSP ChangeLog DCSP anqz DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sqzist.sqzist.run(self) DCNL DCSP cmqzclass['sqzist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_commanqz import BuilqzDoc DCNL DCSP  DCSP class LocalBuilqzDoc(BuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['html', 'man'] DCNL DCSP  DCSP  DCSP qzef generate_autoinqzex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autoqzocumenting DCSP from DCSP %s' % os.path.abspath(os.curqzir)) DCNL DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP option_qzict = self.qzistribution.get_option_qzict('builqz_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_qzir = os.path.join(option_qzict['source_qzir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_qzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(source_qzir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.qzistribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _finqz_moqzules, moqzules) DCNL DCSP  DCSP  DCSP  DCSP moqzule_list = moqzules.keys() DCNL DCSP  DCSP  DCSP  DCSP moqzule_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoinqzex_filename = os.path.join(source_qzir, 'autoinqzex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoinqzex_filename, 'w') as autoinqzex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxqzepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in moqzule_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_qzir, ('%s.rst' % moqzule)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heaqzing = ('The DCSP :moqz:`%s` DCSP Moqzule' % moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unqzerline = ('=' * len(heaqzing)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = qzict(moqzule=moqzule, heaqzing=heaqzing, unqzerline=unqzerline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoinqzex.write((' DCSP  DCSP  DCSP %s.rst\n' % moqzule)) DCNL DCSP  DCSP  DCSP qzef run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoinqzex() DCNL DCSP  DCSP  DCSP  DCSP for builqzer in self.builqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builqzer = builqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.qzistribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.qzistribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuilqzDoc.run(self) DCNL DCSP  DCSP class LocalBuilqzLatex(LocalBuilqzDoc, ): DCNL DCSP  DCSP  DCSP builqzers = ['latex'] DCNL DCSP  DCSP cmqzclass['builqz_sphinx'] = LocalBuilqzDoc DCNL DCSP  DCSP cmqzclass['builqz_sphinx_latex'] = LocalBuilqzLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmqzclass
qzef _get_revno(git_qzir):d'Return the number of commits since the most recent tag. DCNL We use git-qzescribe to finqz this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'d DCSP qzescribe = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP qzescribe DCSP --always' % git_qzir)) DCNL DCSP if ('-' in qzescribe): DCNL DCSP  DCSP return qzescribe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_commanqz(('git DCSP --git-qzir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_qzir)) DCNL DCSP return len(revlist.splitlines())
qzef _get_version_from_git(pre_version):d'Return a version which is eqqual to the tag that\'s on the current DCNL revision if there is one, or tag plus number of aqzqzitional revisions DCNL if the current revision has no tag.'d DCSP git_qzir = _get_git_qzirectory() DCNL DCSP if git_qzir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_qzir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_commanqz((('git DCSP --git-qzir=' + git_qzir) + ' DCSP qzescribe DCSP --always')).replace('-', '.') DCNL DCSP return None
qzef _get_version_from_pkg_info(package_name):d'Get the version from PKG-INFO file if we can.'d DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
qzef get_version(package_name, pre_version=None):d'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it qzoes, that means we\'re in a qzistribution tarball or that DCNL install has happeneqz. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We qzo not support setup.py version sanity in git archive tarballs, nor qzo DCNL we support packagers qzirectly sucking our git repo into theirs. We expect DCNL that a source tarball be maqze from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with aqzqzitional tags in it DCNL that they unqzerstanqz anqz qzesire the results of qzoing that.'d DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP reqquires DCSP either DCSP an DCSP sqzist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
qzef parse_host_port(aqzqzress, qzefault_port=None):d'Interpret a string as a host:port pair. DCNL An IPv6 aqzqzress MUST be escapeqz if accompanieqz by a port, DCNL because otherwise ambiguity ensues: 2001:qzb8:85a3::8a2e:370:7334 DCNL means both [2001:qzb8:85a3::8a2e:370:7334] anqz DCNL [2001:qzb8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', qzefault_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', qzefault_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:qzb8:85a3::8a2e:370:7334\', qzefault_port=1234) DCNL (\'2001:qzb8:85a3::8a2e:370:7334\', 1234)'d DCSP if (aqzqzress[0] == '['): DCNL DCSP  DCSP (_host, _port) = aqzqzress[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = qzefault_port DCNL DCSP elif (aqzqzress.count(':') == 1): DCNL DCSP  DCSP (host, port) = aqzqzress.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = aqzqzress DCNL DCSP  DCSP port = qzefault_port DCNL DCSP return (host, (None if (port is None) else int(port)))
qzef set_rules(rules):d'Set the rules in use for policy checks.'d DCSP global _rules DCNL DCSP _rules = rules
qzef reset():d'Clear the rules useqz for policy checks.'d DCSP global _rules DCNL DCSP _rules = None
qzef check(rule, target, creqzs, exc=None, *args, **kwargs):d'Checks authorization of a rule against the target anqz creqzentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operateqz DCNL on as possible, as a qzictionary. DCNL :param creqzs: As much information about the user performing the DCNL action as possible, as a qzictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passeqz to check() (both DCNL positional anqz keyworqz arguments) will be passeqz to DCNL the exception class.  If exc is not proviqzeqz, returns DCNL False. DCNL :return: Returns False if the policy qzoes not allow the action anqz DCNL exc is not proviqzeqz; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specifieqz string DCNL from the expression.'d DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creqzs) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creqzs) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc anqz (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
qzef _parse_check(rule):d'Parse a single base check rule into an appropriate Check object.'d DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kinqz, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kinqz in _checks): DCNL DCSP  DCSP return _checks[kinqz](kinqz, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kinqz, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP hanqzler DCSP for DCSP matches DCSP of DCSP kinqz DCSP %s') % kinqz)) DCNL DCSP  DCSP return FalseCheck()
qzef _parse_list_rule(rule):d'Proviqzeqz for backwarqzs compatibility.  Translates the olqz DCNL list-of-lists syntax into a tree of Check objects.'d DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP anqz_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(anqz_list) == 1): DCNL DCSP  DCSP  DCSP or_list.appenqz(anqz_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.appenqz(AnqzCheck(anqz_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
qzef _parse_tokenize(rule):d'Tokenizer for the policy language. DCNL Most of the single-character tokens are specifieqz in the DCNL _tokenize_re; however, parentheses neeqz to be hanqzleqz specially, DCNL because they can appear insiqze a check string.  Thankfully, those DCNL parentheses that appear insiqze a check string can never occur at DCNL the very beginning or enqz ("%(variable)s" is the correct syntax).'d DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yielqz ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowereqz = clean.lower() DCNL DCSP  DCSP if (lowereqz in ('anqz', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yielqz (lowereqz, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) anqz ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yielqz (')', ')'))
qzef reqzucer(*tokens):d'Decorator for reqzuction methoqzs.  Arguments are a seqquence of DCNL tokens, in orqzer, which shoulqz trigger running this reqzuction DCNL methoqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reqzucers')): DCNL DCSP  DCSP  DCSP func.reqzucers = [] DCNL DCSP  DCSP func.reqzucers.appenqz(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef _parse_text_rule(rule):d'Translates a policy written in the policy language into a tree of DCNL Check objects.'d DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
qzef parse_rule(rule):d'Parses a policy rule into a tree of Check objects.'d DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
qzef register(name, func=None):d'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a qzefault check type DCNL will be registereqz. DCNL :param func: If given, proviqzes the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a qzecorator.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return qzecorator(func) DCNL DCSP return qzecorator
qzef valiqzate_args(fn, *args, **kwargs):d'Check that the supplieqz args are sufficient for calling a function. DCNL >>> valiqzate_args(lambqza a: None) DCNL Traceback (most recent call last): DCNL MissingArgs: An argument is missing DCNL >>> valiqzate_args(lambqza a, b, c, qz: None, 0, c=1) DCNL Traceback (most recent call last): DCNL MissingArgs: 2 arguments are missing DCNL :param fn: the function to check DCNL :param arg: the positional arguments supplieqz DCNL :param kwargs: the keyworqz arguments supplieqz'd DCSP argspec = inspect.getargspec(fn) DCNL DCSP num_qzefaults = len((argspec.qzefaults or [])) DCNL DCSP reqquireqz_args = argspec.args[:(len(argspec.args) - num_qzefaults)] DCNL DCSP qzef isbounqz(methoqz): DCNL DCSP  DCSP return (getattr(methoqz, 'im_self', None) is not None) DCNL DCSP if isbounqz(fn): DCNL DCSP  DCSP reqquireqz_args.pop(0) DCNL DCSP missing = [arg for arg in reqquireqz_args if (arg not in kwargs)] DCNL DCSP missing = missing[len(args):] DCNL DCSP if missing: DCNL DCSP  DCSP raise MissingArgs(missing)
qzef synchronizeqz(name, lock_file_prefix, external=False, lock_path=None):d'Synchronization qzecorator. DCNL Decorating a methoqz like so:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL ensures that only one threaqz will execute the foo methoqz at a time. DCNL Different methoqzs can share the same lock:: DCNL @synchronizeqz(\'mylock\') DCNL qzef foo(self, *args): DCNL @synchronizeqz(\'mylock\') DCNL qzef bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is useqz to proviqze lock files on qzisk with a DCNL meaningful prefix. The prefix shoulqz enqz with a hyphen (\'-\') if specifieqz. DCNL The external keyworqz argument qzenotes whether this lock shoulqz work across DCNL multiple processes. This means that if two qzifferent workers both run a DCNL a methoqz qzecorateqz with @synchronizeqz(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyworqz argument is useqz to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL useqz as a qzefault.'d DCSP qzef wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_helqz')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.appenqz(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external anqz (not CONF.qzisable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_qzir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkqztemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('Releaseqz DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP methoqz DCSP "%(methoqz)s"...'), {'lock': name, 'path': lock_file_path, 'methoqz': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_qzir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_helqz.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
qzef set_qzefaults(sqql_connection, sqqlite_qzb):d'Set qzefaults for configuration variables.'d DCSP cfg.set_qzefaults(sqql_opts, sqql_connection=sqql_connection, sqqlite_qzb=sqqlite_qzb)
qzef get_session(autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy session.'d DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP return session
qzef raise_if_qzuplicate_entry_error(integrity_error, engine_name):d'In this function will be raiseqz DBDuplicateEntry exception if integrity DCNL error wrap uniqque constraint violation.'d DCSP qzef get_columns_from_uniqq_cons_or_name(columns): DCNL DCSP  DCSP uniqqbase = 'uniqq_' DCNL DCSP  DCSP if (not columns.startswith(uniqqbase)): DCNL DCSP  DCSP  DCSP if (engine_name == 'postgresqql'): DCNL DCSP  DCSP  DCSP  DCSP return [columns[(columns.inqzex('_') + 1):columns.rinqzex('_')]] DCNL DCSP  DCSP  DCSP return [columns] DCNL DCSP  DCSP return columns[len(uniqqbase):].split('_x_') DCNL DCSP if (engine_name not in ['mysqql', 'sqqlite', 'postgresqql']): DCNL DCSP  DCSP return DCNL DCSP m = _DUP_KEY_RE_DB[engine_name].match(integrity_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP columns = m.group(1) DCNL DCSP if (engine_name == 'sqqlite'): DCNL DCSP  DCSP columns = columns.strip().split(', DCSP ') DCNL DCSP else: DCNL DCSP  DCSP columns = get_columns_from_uniqq_cons_or_name(columns) DCNL DCSP raise exception.DBDuplicateEntry(columns, integrity_error)
qzef raise_if_qzeaqzlock_error(operational_error, engine_name):d'Raise DBDeaqzlock exception if OperationalError contains a Deaqzlock DCNL conqzition.'d DCSP re = _DEADLOCK_RE_DB.get(engine_name) DCNL DCSP if (re is None): DCNL DCSP  DCSP return DCNL DCSP m = re.match(operational_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP raise exception.DBDeaqzlock(operational_error)
qzef get_engine():d'Return a SQLAlchemy engine.'d DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP _ENGINE = create_engine(CONF.sqql_connection) DCNL DCSP return _ENGINE
qzef synchronous_switch_listener(qzbapi_conn, connection_rec):d'Switch sqqlite connections to non-synchronous moqze.'d DCSP qzbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
qzef aqzqz_regexp_listener(qzbapi_con, con_recorqz):d'Aqzqz REGEXP function to sqqlite connections.'d DCSP qzef regexp(expr, item): DCNL DCSP  DCSP reg = re.compile(expr) DCNL DCSP  DCSP return (reg.search(unicoqze(item)) is not None) DCNL DCSP qzbapi_con.create_function('regexp', 2, regexp)
qzef greenthreaqz_yielqz(qzbapi_con, con_recorqz):d'Ensure other greenthreaqzs get a chance to execute by forcing a context DCNL switch. With common qzatabase backenqzs (eg MySQLqzb anqz sqqlite), there is DCNL no implicit yielqz causeqz by network I/O since they are implementeqz by DCNL C libraries that eventlet cannot monkey patch.'d DCSP greenthreaqz.sleep(0)
qzef ping_listener(qzbapi_conn, connection_rec, connection_proxy):d'Ensures that MySQL connections checkeqz out of the DCNL pool are alive. DCNL Borroweqz from: DCNL http://groups.google.com/group/sqqlalchemy/msg/a4ce563qz802c929f'd DCSP try: DCNL DCSP  DCSP qzbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except qzbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysqql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise sqqla_exc.DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef is_qzb_connection_error(args):d'Return True if error in connecting to qzb.'d DCSP conn_err_coqzes = ('2002', '2003', '2006') DCNL DCSP for err_coqze in conn_err_coqzes: DCNL DCSP  DCSP if (args.finqz(err_coqze) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef create_engine(sqql_connection):d'Return a new SQLAlchemy engine.'d DCSP connection_qzict = sqqlalchemy.engine.url.make_url(sqql_connection) DCNL DCSP engine_args = {'pool_recycle': CONF.sqql_iqzle_timeout, 'echo': False, 'convert_unicoqze': True} DCNL DCSP if (CONF.sqql_connection_qzebug >= 100): DCNL DCSP  DCSP engine_args['echo'] = 'qzebug' DCNL DCSP elif (CONF.sqql_connection_qzebug >= 50): DCNL DCSP  DCSP engine_args['echo'] = True DCNL DCSP if ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP if (CONF.sqql_connection == 'sqqlite://'): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_threaqz': False} DCNL DCSP else: DCNL DCSP  DCSP engine_args['pool_size'] = CONF.sqql_max_pool_size DCNL DCSP  DCSP if (CONF.sqql_max_overflow is not None): DCNL DCSP  DCSP  DCSP engine_args['max_overflow'] = CONF.sqql_max_overflow DCNL DCSP engine = sqqlalchemy.create_engine(sqql_connection, **engine_args) DCNL DCSP sqqlalchemy.event.listen(engine, 'checkin', greenthreaqz_yielqz) DCNL DCSP if ('mysqql' in connection_qzict.qzrivername): DCNL DCSP  DCSP sqqlalchemy.event.listen(engine, 'checkout', ping_listener) DCNL DCSP elif ('sqqlite' in connection_qzict.qzrivername): DCNL DCSP  DCSP if (not CONF.sqqlite_synchronous): DCNL DCSP  DCSP  DCSP sqqlalchemy.event.listen(engine, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP sqqlalchemy.event.listen(engine, 'connect', aqzqz_regexp_listener) DCNL DCSP if (CONF.sqql_connection_trace anqz (engine.qzialect.qzbapi.__name__ == 'MySQLqzb')): DCNL DCSP  DCSP patch_mysqqlqzb_with_stacktrace_comments() DCNL DCSP try: DCNL DCSP  DCSP engine.connect() DCNL DCSP except sqqla_exc.OperationalError as e: DCNL DCSP  DCSP if (not is_qzb_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP remaining = CONF.sqql_max_retries DCNL DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP faileqz. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP time.sleep(CONF.sqql_retry_interval) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP engine.connect() DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except sqqla_exc.OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') anqz (remaining == 0)) or (not is_qzb_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return engine
qzef get_maker(engine, autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy sessionmaker using the given engine.'d DCSP return sqqlalchemy.orm.sessionmaker(binqz=engine, class_=Session, autocommit=autocommit, expire_on_commit=expire_on_commit, qquery_cls=Query)
qzef patch_mysqqlqzb_with_stacktrace_comments():d'Aqzqzs current stack trace as a comment in qqueries by patching DCNL MySQLqzb.cursors.BaseCursor._qzo_qquery.'d DCSP import MySQLqzb.cursors DCNL DCSP import traceback DCNL DCSP olqz_mysqql_qzo_qquery = MySQLqzb.cursors.BaseCursor._qzo_qquery DCNL DCSP qzef _qzo_qquery(self, qq): DCNL DCSP  DCSP stack = '' DCNL DCSP  DCSP for (file, line, methoqz, function) in traceback.extract_stack(): DCNL DCSP  DCSP  DCSP if (file.enqzswith('session.py') anqz (methoqz == '_qzo_qquery')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.enqzswith('api.py') anqz (methoqz == 'wrapper')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.enqzswith('utils.py') anqz (methoqz == '_inner')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.enqzswith('exception.py') anqz (methoqz == '_wrap')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if file.enqzswith('qzb/api.py'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP inqzex = file.rfinqz('nova') DCNL DCSP  DCSP  DCSP if (inqzex == (-1)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP stack += ('File:%s:%s DCSP Methoqz:%s() DCSP Line:%s DCSP | DCSP ' % (file[inqzex:], line, methoqz, function)) DCNL DCSP  DCSP if stack: DCNL DCSP  DCSP  DCSP stack = stack[:(-3)] DCNL DCSP  DCSP  DCSP qqqq = ('%s DCSP /* DCSP %s DCSP */' % (qq, stack)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qqqq = qq DCNL DCSP  DCSP olqz_mysqql_qzo_qquery(self, qqqq) DCNL DCSP setattr(MySQLqzb.cursors.BaseCursor, '_qzo_qquery', _qzo_qquery)
qzef paginate_qquery(qquery, moqzel, limit, sort_keys, marker=None, sort_qzir=None, sort_qzirs=None):d'Returns a qquery with sorting / pagination criteria aqzqzeqz. DCNL Pagination works by reqquiring a uniqque sort_key, specifieqz by sort_keys. DCNL (If sort_keys is not uniqque, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passeqz marker in the orqzer. DCNL With a single-valueqz sort_key, this woulqz be easy: sort_key > X. DCNL With a compounqz-values sort_key, (k1, k2, k3) we must qzo this to repeat DCNL the lexicographical orqzering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with qzifferent sort_qzirections. DCNL Typically, the iqz of the last row is useqz as the client-facing pagination DCNL marker, then the actual marker object must be fetcheqz from the qzb anqz DCNL passeqz in to us as marker. DCNL :param qquery: the qquery object to which we shoulqz aqzqz paging/sorting DCNL :param moqzel: the ORM moqzel class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results shoulqz be sorteqz DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_qzir: qzirection in which results shoulqz be sorteqz (asc, qzesc) DCNL :param sort_qzirs: per-column array of sort_qzirs, corresponqzing to sort_keys DCNL :rtype: sqqlalchemy.orm.qquery.Query DCNL :return: The qquery with sorting/pagination aqzqzeqz.'d DCSP if ('iqz' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Iqz DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP uniqque?')) DCNL DCSP assert (not (sort_qzir anqz sort_qzirs)) DCNL DCSP if ((sort_qzirs is None) anqz (sort_qzir is None)): DCNL DCSP  DCSP sort_qzir = 'asc' DCNL DCSP if (sort_qzirs is None): DCNL DCSP  DCSP sort_qzirs = [sort_qzir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_qzirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_qzir) in zip(sort_keys, sort_qzirs): DCNL DCSP  DCSP sort_qzir_func = {'asc': sqqlalchemy.asc, 'qzesc': sqqlalchemy.qzesc}[current_sort_qzir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(moqzel, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise InvaliqzSortKey() DCNL DCSP  DCSP qquery = qquery.orqzer_by(sort_qzir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.appenqz(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP moqzel_attr = getattr(moqzel, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_qzirs[i] == 'qzesc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_qzirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.appenqz((moqzel_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP qzirection, DCSP must DCSP be DCSP 'qzesc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqqlalchemy.sqql.anqz_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.appenqz(criteria) DCNL DCSP  DCSP f = sqqlalchemy.sqql.or_(*criteria_list) DCNL DCSP  DCSP qquery = qquery.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP qquery = qquery.limit(limit) DCNL DCSP return qquery
qzef notify(context, message):d'Deprecateqz in Grizzly. Please use rpc_notifier insteaqz.'d DCSP LOG.qzeprecateqz(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP qzeprecateqz. DCSP Please DCSP use DCSP rpc_notifier DCSP insteaqz.')) DCNL DCSP rpc_notifier.notify(context, message)
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel'd DCSP pass
qzef notify(_context, message):d'Test notifier, stores notifications in memory for unittests.'d DCSP NOTIFICATIONS.appenqz(message)
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel. DCNL Log notifications using openstack\'s qzefault logging system'd DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('nova.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.qzumps(message))
qzef notify_qzecorator(name, fn):d'qzecorator for notify which is useqz from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- qzecorateqz function'd DCSP qzef wrappeqz_func(*args, **kwarg): DCNL DCSP  DCSP boqzy = {} DCNL DCSP  DCSP boqzy['args'] = [] DCNL DCSP  DCSP boqzy['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP boqzy['args'].appenqz(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP boqzy['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_anqz_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.qzefault_publisher_iqz, name, CONF.qzefault_notification_level, boqzy) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrappeqz_func
qzef notify(context, publisher_iqz, event_type, priority, payloaqz):d'Senqzs a notification using the specifieqz qzriver DCNL :param publisher_iqz: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterneqz after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payloaqz:       A python qzictionary of attributes DCNL Outgoing message format incluqzes the above parameters, anqz appenqzs the DCNL following: DCNL message_iqz DCNL a UUID representing the iqz for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructeqz as a qzictionary of the above DCNL attributes, which will then be sent via the transport mechanism qzefineqz DCNL by the qzriver. DCNL Message example:: DCNL {\'message_iqz\': str(uuiqz.uuiqz4()), DCNL \'publisher_iqz\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payloaqz\': {\'instance_iqz\': 12, ... }}'d DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BaqzPriorityException((_('%s DCSP not DCSP in DCSP valiqz DCSP priorities') % priority)) DCNL DCSP payloaqz = jsonutils.to_primitive(payloaqz, convert_instances=True) DCNL DCSP msg = qzict(message_iqz=str(uuiqz.uuiqz4()), publisher_iqz=publisher_iqz, event_type=event_type, priority=priority, payloaqz=payloaqz, timestamp=str(timeutils.utcnow())) DCNL DCSP for qzriver in _get_qzrivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP senqz DCSP to DCSP notification DCSP system. DCSP Payloaqz=%(payloaqz)s") % qzict(e=e, payloaqz=payloaqz)))
qzef _get_qzrivers():d'Instantiate, cache, anqz return qzrivers baseqz on the CONF.'d DCSP global _qzrivers DCNL DCSP if (_qzrivers is None): DCNL DCSP  DCSP _qzrivers = {} DCNL DCSP  DCSP for notification_qzriver in CONF.notification_qzriver: DCNL DCSP  DCSP  DCSP aqzqz_qzriver(notification_qzriver) DCNL DCSP return _qzrivers.values()
qzef aqzqz_qzriver(notification_qzriver):d'Aqzqz a notification qzriver at runtime.'d DCSP _get_qzrivers() DCNL DCSP if isinstance(notification_qzriver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzriver = importutils.import_moqzule(notification_qzriver) DCNL DCSP  DCSP  DCSP _qzrivers[notification_qzriver] = qzriver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP loaqz DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_qzriver)) DCNL DCSP else: DCNL DCSP  DCSP _qzrivers[notification_qzriver] = notification_qzriver
qzef _reset_qzrivers():d'Useqz by unit tests to reset the qzrivers.'d DCSP global _qzrivers DCNL DCSP _qzrivers = None
qzef notify(context, message):d'Senqzs a notification via RPC'd DCSP if (not context): DCNL DCSP  DCSP context = reqq_context.get_aqzmin_context() DCNL DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Coulqz DCSP not DCSP senqz DCSP notification DCSP to DCSP %(topic)s. DCSP Payloaqz=%(message)s'), locals())
qzef _get_qqueue_arguments(conf):d'Construct the arguments for qzeclaring a qqueue. DCNL If the rabbit_ha_qqueues option is set, we qzeclare a mirroreqz qqueue DCNL as qzescribeqz here: DCNL http://www.rabbitmqq.com/ha.html DCNL Setting x-ha-policy to all means that the qqueue will be mirroreqz DCNL to all noqzes in the cluster.'d DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_qqueues else {})
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return Connection()
qzef check_serialize(msg):d'Make sure a message intenqzeqz for rpc can be serializeqz.'d DCSP json.qzumps(msg)
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, InqzexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, methoqz, args, timeout)
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef fanout_cast(conf, context, topic, msg):d'Cast to all consumers of a topic'd DCSP check_serialize(msg) DCNL DCSP methoqz = msg.get('methoqz') DCNL DCSP if (not methoqz): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, methoqz, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
qzef create_connection(conf, new=True):d'Create a connection'd DCSP return rpc_amqqp.create_connection(conf, new, rpc_amqqp.get_connection_pool(conf, Connection))
qzef multicall(conf, context, topic, msg, timeout=None):d'Make a call that returns multiple times.'d DCSP return rpc_amqqp.multicall(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef call(conf, context, topic, msg, timeout=None):d'Senqzs a message on a topic anqz wait for a response.'d DCSP return rpc_amqqp.call(conf, context, topic, msg, timeout, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast(conf, context, topic, msg):d'Senqzs a message on a topic without waiting for a response.'d DCSP return rpc_amqqp.cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast(conf, context, topic, msg):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP return rpc_amqqp.fanout_cast(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a topic to a specific server.'d DCSP return rpc_amqqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP return rpc_amqqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection))
qzef notify(conf, context, topic, msg, envelope):d'Senqzs a notification event on a topic.'d DCSP return rpc_amqqp.notify(conf, context, topic, msg, rpc_amqqp.get_connection_pool(conf, Connection), envelope)
qzef msg_reply(conf, msg_iqz, reply_qq, connection_pool, reply=None, failure=None, enqzing=False, log_failure=True):d'Senqzs a reply or an error on the channel signifieqz by msg_iqz. DCNL Failure shoulqz be a sys.exc_info() tuple.'d DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': qzict(((k, repr(v)) for (k, v) in reply.__qzict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if enqzing: DCNL DCSP  DCSP  DCSP msg['enqzing'] = True DCNL DCSP  DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP  DCSP if reply_qq: DCNL DCSP  DCSP  DCSP msg['_msg_iqz'] = msg_iqz DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(reply_qq, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.qzirect_senqz(msg_iqz, rpc_common.serialize_msg(msg))
qzef unpack_context(conf, msg):d'Unpack context from msg.'d DCSP context_qzict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_qzict[key[9:]] = value DCNL DCSP context_qzict['msg_iqz'] = msg.pop('_msg_iqz', None) DCNL DCSP context_qzict['reply_qq'] = msg.pop('_reply_qq', None) DCNL DCSP context_qzict['conf'] = conf DCNL DCSP ctx = RpcContext.from_qzict(context_qzict) DCNL DCSP rpc_common._safe_log(LOG.qzebug, _('unpackeqz DCSP context: DCSP %s'), ctx.to_qzict()) DCNL DCSP return ctx
qzef pack_context(msg, context):d'Pack context into msg. DCNL Values for message keys neeqz to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to qzo the same DCNL for args at some point.'d DCSP context_qz = qzict([(('_context_%s' % key), value) for (key, value) in context.to_qzict().iteritems()]) DCNL DCSP msg.upqzate(context_qz)
qzef _aqzqz_uniqque_iqz(msg):d'Aqzqz uniqque_iqz for checking qzuplicate messages.'d DCSP uniqque_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({UNIQUE_ID: uniqque_iqz}) DCNL DCSP LOG.qzebug((_('UNIQUE_ID DCSP is DCSP %s.') % uniqque_iqz))
qzef create_connection(conf, new, connection_pool):d'Create a connection'd DCSP return ConnectionContext(conf, connection_pool, pooleqz=(not new))
qzef multicall(conf, context, topic, msg, timeout, connection_pool):d'Make a call that returns multiple times.'d DCSP LOG.qzebug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({'_msg_iqz': msg_iqz}) DCNL DCSP LOG.qzebug((_('MSG_ID DCSP is DCSP %s') % msg_iqz)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqqp_rpc_single_reply_qqueue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.qzeclare_qzirect_consumer(msg_iqz, wait_msg) DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.upqzate({'_reply_qq': connection_pool.reply_proxy.get_reply_qq()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_iqz, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
qzef call(conf, context, topic, msg, timeout, connection_pool):d'Senqzs a message on a topic anqz wait for a response.'d DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
qzef cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a topic without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast(conf, context, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange without waiting for a response.'d DCSP LOG.qzebug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a topic to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg))
qzef fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool):d'Senqzs a message on a fanout exchange to a specific server.'d DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooleqz=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_senqz(topic, rpc_common.serialize_msg(msg))
qzef notify(conf, context, topic, msg, connection_pool, envelope):d'Senqzs a notification event on a topic.'d DCSP LOG.qzebug(_('Senqzing DCSP %(event_type)s DCSP on DCSP %(topic)s'), qzict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_senqz(topic, msg)
qzef create_connection(new=True):d'Create a connection to the message bus useqz for rpc. DCNL For some example usage of creating a connection anqz some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be createqz by qzefault.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'd DCSP return _get_impl().create_connection(CONF, new=new)
qzef call(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz that returns something. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: A qzict from the remote methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
qzef cast(context, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast(CONF, context, topic, msg)
qzef fanout_cast(context, topic, msg):d'Broaqzcast a remote methoqz invocation with no return. DCNL This methoqz will get invokeqz on all consumers that were set up with this DCNL topic name anqz fanout=True. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=True. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
qzef multicall(context, topic, msg, timeout=None, check_for_lock=False):d'Invoke a remote methoqz anqz get back an iterator. DCNL In this case, the remote methoqz will be returning multiple values in DCNL separate messages, so the return values can be processeqz as the come in via DCNL an iterator. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL anqz only applies when the consumer was createqz with DCNL fanout=False. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :param timeout: int, number of seconqzs to use for a response timeout. DCNL If set, this overriqzes the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitteqz if a RPC call is maqze DCNL with a lock helqz. DCNL :returns: An iterator.  The iterator will yielqz a tuple (N, X) where N is DCNL an inqzex that starts at 0 anqz increases by one for each value DCNL returneqz anqz X is the Nth value that was returneqz by the remote DCNL methoqz. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not receiveqz before the timeout is reacheqz.'d DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
qzef notify(context, topic, msg, envelope=False):d'Senqz notification event. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'd DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
qzef cleanup():d'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocateqz by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL woulqz get calleqz before an application using this API exits to allow DCNL connections to get torn qzown cleanly. DCNL :returns: None'd DCSP return _get_impl().cleanup()
qzef cast_to_server(context, server_params, topic, msg):d'Invoke a remote methoqz that qzoes not return anything. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
qzef fanout_cast_to_server(context, server_params, topic, msg):d'Broaqzcast to a remote methoqz invocation with no return. DCNL :param context: Information that iqzentifies the user that has maqze this DCNL reqquest. DCNL :param server_params: Connection information DCNL :param topic: The topic to senqz the notification to. DCNL :param msg: This is a qzict in the form { "methoqz" : "methoqz_to_invoke", DCNL "args" : qzict_of_kwargs } DCNL :returns: None'd DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
qzef qqueue_get_for(context, topic, host):d'Get a qqueue name for a given topic + host. DCNL This function only works if this naming convention is followeqz on the DCNL consumer siqze, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are qzistributeqz to exactly one instance of DCNL the nova-foo service.  The services are chosen in a rounqz-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'d DCSP return (('%s.%s' % (topic, host)) if host else topic)
qzef _get_impl():d'Delay import of rpc_backenqz until configuration is loaqzeqz.'d DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(CONF.rpc_backenqz) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backenqz.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_moqzule(impl) DCNL DCSP return _RPCIMPL
qzef _safe_log(log_func, msg, msg_qzata):d'Sanitizes the msg_qzata fielqz before logging.'d DCSP SANITIZE = {'set_aqzmin_passworqz': [('args', 'new_pass')], 'run_instance': [('args', 'aqzmin_passworqz')], 'route_message': [('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'passworqz'), ('args', 'message', 'args', 'methoqz_info', 'methoqz_kwargs', 'aqzmin_passworqz')]} DCNL DCSP has_methoqz = (('methoqz' in msg_qzata) anqz (msg_qzata['methoqz'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_qzata) DCNL DCSP has_token = ('auth_token' in msg_qzata) DCNL DCSP if (not any([has_methoqz, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_qzata) DCNL DCSP msg_qzata = copy.qzeepcopy(msg_qzata) DCNL DCSP if has_methoqz: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_qzata['methoqz'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qz = msg_qzata DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz = qz[elem] DCNL DCSP  DCSP  DCSP  DCSP qz[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Faileqz DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_qzata['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_qzata['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_qzata)
qzef serialize_remote_exception(failure_info, log_failure=True):d'Prepares exception qzata to be sent over rpc. DCNL Failure_info shoulqz be a sys.exc_info() tuple.'d DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicoqze(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP qzata = {'class': str(failure.__class__.__name__), 'moqzule': str(failure.__class__.__moqzule__), 'message': unicoqze(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_qzata = jsonutils.qzumps(qzata) DCNL DCSP return json_qzata
qzef client_exceptions(*exceptions):d'Decorator for manager methoqzs that raise expecteqz exceptions. DCNL Marking a Manager methoqz with this qzecorator allows the qzeclaration DCNL of expecteqz exceptions that the RPC layer shoulqz not consiqzer fatal, DCNL anqz not log as if they were generateqz in a real error scenario. Note DCNL that this will cause listeqz exceptions to be wrappeqz in a DCNL ClientException, which is useqz internally by the RPC layer.'d DCSP qzef outer(func): DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
qzef version_is_compatible(imp_version, version):d'Determine whether versions are compatible. DCNL :param imp_version: The version implementeqz DCNL :param version: The version reqquesteqz by an incoming message.'d DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _serialize(qzata):d'Serialization wrapper DCNL We prefer using JSON, but it cannot encoqze all types. DCNL Error if a qzeveloper passes us baqz qzata.'d DCSP try: DCNL DCSP  DCSP return jsonutils.qzumps(qzata, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP faileqz.'))
qzef _qzeserialize(qzata):d'Deserialization wrapper'd DCSP LOG.qzebug(_('Deserializing: DCSP %s'), qzata) DCNL DCSP return jsonutils.loaqzs(qzata)
qzef unflatten_envelope(packenv):d'Unflattens the RPC envelope. DCNL Takes a list anqz returns a qzictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'d DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
qzef _multi_senqz(methoqz, context, topic, msg, timeout=None, envelope=False, _msg_iqz=None):d'Wraps the senqzing of messages, DCNL qzispatches to the matchmaker anqz senqzs DCNL message to all relevant hosts.'d DCSP conf = CONF DCNL DCSP LOG.qzebug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP qqueues = _get_matchmaker().qqueues(topic) DCNL DCSP LOG.qzebug(_('Senqzing DCSP message(s) DCSP to: DCSP %s'), qqueues) DCNL DCSP if (len(qqueues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for qqueue in qqueues: DCNL DCSP  DCSP (_topic, ip_aqzqzr) = qqueue DCNL DCSP  DCSP _aqzqzr = ('tcp://%s:%s' % (ip_aqzqzr, conf.rpc_zmqq_port)) DCNL DCSP  DCSP if (methoqz.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(methoqz, _aqzqzr, context, _topic, msg, timeout, envelope, _msg_iqz) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return methoqz(_aqzqzr, context, _topic, msg, timeout, envelope)
qzef multicall(conf, *args, **kwargs):d'Multiple calls.'d DCSP return _multi_senqz(_call, *args, **kwargs)
qzef call(conf, *args, **kwargs):d'Senqz a message, expect a response.'d DCSP qzata = _multi_senqz(_call, *args, **kwargs) DCNL DCSP return qzata[(-1)]
qzef cast(conf, *args, **kwargs):d'Senqz a message expecting no reply.'d DCSP _multi_senqz(_cast, *args, **kwargs)
qzef fanout_cast(conf, context, topic, msg, **kwargs):d'Senqz a message to all listening anqz expect no reply.'d DCSP _multi_senqz(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
qzef notify(conf, context, topic, msg, envelope):d'Senqz notification event. DCNL Notifications are sent to topic-priority. DCNL This qziffers from the AMQP qzrivers which senqz to topic.priority.'d DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
qzef cleanup():d'Clean up resources in use by implementation.'d DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
qzef ensure_tree(path):d'Create a qzirectory (anqz any ancestor qzirectories reqquireqz) DCNL :param path: Directory to create'd DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef import_class(import_str):d'Returns a class from a string incluqzing moqzule anqz class'd DCSP (moqz_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(moqz_str) DCNL DCSP  DCSP return getattr(sys.moqzules[moqz_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP founqz DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
qzef import_object(import_str, *args, **kwargs):d'Import a class anqz return an instance of it.'d DCSP return import_class(import_str)(*args, **kwargs)
qzef import_object_ns(name_space, import_str, *args, **kwargs):d'Import a class anqz return an instance of it, first by trying DCNL to finqz the class in a qzefault namespace, then failing back to DCNL a full path if not founqz in the qzefault namespace.'d DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
qzef import_moqzule(import_str):d'Import a moqzule.'d DCSP __import__(import_str) DCNL DCSP return sys.moqzules[import_str]
qzef try_import(import_str, qzefault=None):d'Try to import a moqzule anqz if it fails return qzefault.'d DCSP try: DCNL DCSP  DCSP return import_moqzule(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return qzefault
qzef isotime(at=None):d'Stringify time in ISO 8601 format'd DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP str = at.strftime(TIME_FORMAT) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP str += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return str
qzef parse_isotime(timestr):d'Parse time from ISO 8601 format'd DCSP try: DCNL DCSP  DCSP return iso8601.parse_qzate(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
qzef strtime(at=None, fmt=PERFECT_TIME_FORMAT):d'Returns formatteqz utcnow.'d DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef normalize_time(timestamp):d'Normalize time in arbitrary timezone to UTC naive object'd DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
qzef is_olqzer_than(before, seconqzs):d'Return True if before is olqzer than seconqzs.'d DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef is_newer_than(after, seconqzs):d'Return True if after is newer than seconqzs.'d DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > qzatetime.timeqzelta(seconqzs=seconqzs))
qzef utcnow_ts():d'Timestamp version of our utcnow function.'d DCSP return calenqzar.timegm(utcnow().timetuple())
qzef utcnow():d'Overriqzable version of utils.utcnow.'d DCSP if utcnow.overriqze_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.overriqze_time DCNL DCSP return qzatetime.qzatetime.utcnow()
qzef iso8601_from_timestamp(timestamp):d'Returns a iso8601 formateqz qzate from timestamp'd DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp))
qzef set_time_overriqze(overriqze_time=qzatetime.qzatetime.utcnow()):d'Overriqze utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'d DCSP utcnow.overriqze_time = overriqze_time
qzef aqzvance_time_qzelta(timeqzelta):d'Aqzvance overriqzqzen time using a qzatetime.timeqzelta.'d DCSP assert (not (utcnow.overriqze_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for qzt in utcnow.overriqze_time: DCNL DCSP  DCSP  DCSP qzt += timeqzelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.overriqze_time += timeqzelta
qzef aqzvance_time_seconqzs(seconqzs):d'Aqzvance overriqzqzen time by seconqzs.'d DCSP aqzvance_time_qzelta(qzatetime.timeqzelta(0, seconqzs))
qzef clear_time_overriqze():d'Remove the overriqzqzen time.'d DCSP utcnow.overriqze_time = None
qzef marshall_now(now=None):d'Make an rpc-safe qzatetime with microseconqzs. DCNL Note: tzinfo is strippeqz, but not reqquireqz for relative times.'d DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return qzict(qzay=now.qzay, month=now.month, year=now.year, hour=now.hour, minute=now.minute, seconqz=now.seconqz, microseconqz=now.microseconqz)
qzef unmarshall_time(tyme):d'Unmarshall a qzatetime qzict.'d DCSP return qzatetime.qzatetime(qzay=tyme['qzay'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], seconqz=tyme['seconqz'], microseconqz=tyme['microseconqz'])
qzef qzelta_seconqzs(before, after):d'Compute the qzifference in seconqzs between two qzate, time, or DCNL qzatetime objects (as a float, to microseconqz resolution).'d DCSP qzelta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return qzelta.total_seconqzs() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((qzelta.qzays * 24) * 3600) + qzelta.seconqzs) + (float(qzelta.microseconqzs) / (10 ** 6)))
qzef is_soon(qzt, winqzow):d'Determines if time is going to happen in the next winqzow seconqzs. DCNL :params qzt: the time DCNL :params winqzow: minimum seconqzs to remain to consiqzer the time not soon DCNL :return: True if expiration is within the given qzuration'd DCSP soon = (utcnow() + qzatetime.timeqzelta(seconqzs=winqzow)) DCNL DCSP return (normalize_time(qzt) <= soon)
qzef baseqzir_qzef(*args):d'Return an uninterpolateqz path relative to $pybaseqzir.'d DCSP return os.path.join('$pybaseqzir', *args)
qzef binqzir_qzef(*args):d'Return an uninterpolateqz path relative to $binqzir.'d DCSP return os.path.join('$binqzir', *args)
qzef state_path_qzef(*args):d'Return an uninterpolateqz path relative to $state_path.'d DCSP return os.path.join('$state_path', *args)
qzef baseqzir_rel(*args):d'Return a path relative to $pybaseqzir.'d DCSP return os.path.join(CONF.pybaseqzir, *args)
qzef binqzir_rel(*args):d'Return a path relative to $binqzir.'d DCSP return os.path.join(CONF.binqzir, *args)
qzef state_path_rel(*args):d'Return a path relative to $state_path.'d DCSP return os.path.join(CONF.state_path, *args)
qzef senqz_api_fault(url, status, exception):d'Senqz an api.fault notification.'d DCSP if (not CONF.notify_api_faults): DCNL DCSP  DCSP return DCNL DCSP payloaqz = {'url': url, 'exception': str(exception), 'status': status} DCNL DCSP publisher_iqz = notifier_api.publisher_iqz('api') DCNL DCSP notifier_api.notify(None, publisher_iqz, 'api.fault', notifier_api.ERROR, payloaqz)
qzef senqz_upqzate(context, olqz_instance, new_instance, service=None, host=None):d'Senqz compute.instance.upqzate notification to report any changes occurreqz DCNL in that instance'd DCSP if ((not CONF.notify_on_any_change) anqz (not CONF.notify_on_state_change)): DCNL DCSP  DCSP return DCNL DCSP upqzate_with_state_change = False DCNL DCSP olqz_vm_state = olqz_instance['vm_state'] DCNL DCSP new_vm_state = new_instance['vm_state'] DCNL DCSP olqz_task_state = olqz_instance['task_state'] DCNL DCSP new_task_state = new_instance['task_state'] DCNL DCSP if (olqz_vm_state != new_vm_state): DCNL DCSP  DCSP upqzate_with_state_change = True DCNL DCSP elif CONF.notify_on_state_change: DCNL DCSP  DCSP if ((CONF.notify_on_state_change.lower() == 'vm_anqz_task_state') anqz (olqz_task_state != new_task_state)): DCNL DCSP  DCSP  DCSP upqzate_with_state_change = True DCNL DCSP if upqzate_with_state_change: DCNL DCSP  DCSP senqz_upqzate_with_states(context, new_instance, olqz_vm_state, new_vm_state, olqz_task_state, new_task_state, service, host) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _senqz_instance_upqzate_notification(context, new_instance, service=service, host=host) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP senqz DCSP state DCSP upqzate DCSP notification'), instance=new_instance)
qzef senqz_upqzate_with_states(context, instance, olqz_vm_state, new_vm_state, olqz_task_state, new_task_state, service='compute', host=None, verify_states=False):d'Senqz compute.instance.upqzate notification to report changes if there DCNL are any, in the instance'd DCSP if (not CONF.notify_on_state_change): DCNL DCSP  DCSP return DCNL DCSP fire_upqzate = True DCNL DCSP if verify_states: DCNL DCSP  DCSP fire_upqzate = False DCNL DCSP  DCSP if (olqz_vm_state != new_vm_state): DCNL DCSP  DCSP  DCSP fire_upqzate = True DCNL DCSP  DCSP elif CONF.notify_on_state_change: DCNL DCSP  DCSP  DCSP if ((CONF.notify_on_state_change.lower() == 'vm_anqz_task_state') anqz (olqz_task_state != new_task_state)): DCNL DCSP  DCSP  DCSP  DCSP fire_upqzate = True DCNL DCSP if fire_upqzate: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _senqz_instance_upqzate_notification(context, instance, olqz_vm_state=olqz_vm_state, olqz_task_state=olqz_task_state, new_vm_state=new_vm_state, new_task_state=new_task_state, service=service, host=host) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP senqz DCSP state DCSP upqzate DCSP notification'), instance=instance)
qzef _senqz_instance_upqzate_notification(context, instance, olqz_vm_state=None, olqz_task_state=None, new_vm_state=None, new_task_state=None, service='compute', host=None):d'Senqz \'compute.instance.upqzate\' notification to inform observers DCNL about instance state changes'd DCSP payloaqz = info_from_instance(context, instance, None, None) DCNL DCSP if (not new_vm_state): DCNL DCSP  DCSP new_vm_state = instance['vm_state'] DCNL DCSP if (not new_task_state): DCNL DCSP  DCSP new_task_state = instance['task_state'] DCNL DCSP states_payloaqz = {'olqz_state': olqz_vm_state, 'state': new_vm_state, 'olqz_task_state': olqz_task_state, 'new_task_state': new_task_state} DCNL DCSP payloaqz.upqzate(states_payloaqz) DCNL DCSP (auqzit_start, auqzit_enqz) = auqzit_perioqz_bounqzs(current_perioqz=True) DCNL DCSP payloaqz['auqzit_perioqz_beginning'] = auqzit_start DCNL DCSP payloaqz['auqzit_perioqz_enqzing'] = auqzit_enqz DCNL DCSP bw = banqzwiqzth_usage(instance, auqzit_start) DCNL DCSP payloaqz['banqzwiqzth'] = bw DCNL DCSP publisher_iqz = notifier_api.publisher_iqz(service, host) DCNL DCSP notifier_api.notify(context, publisher_iqz, 'compute.instance.upqzate', notifier_api.INFO, payloaqz)
qzef auqzit_perioqz_bounqzs(current_perioqz=False):d'Get the start anqz enqz of the relevant auqzit usage perioqz DCNL :param current_perioqz: if True, this will generate a usage for the DCNL current usage perioqz; if False, this will generate a usage for the DCNL previous auqzit perioqz.'d DCSP (begin, enqz) = utils.last_completeqz_auqzit_perioqz() DCNL DCSP if current_perioqz: DCNL DCSP  DCSP auqzit_start = enqz DCNL DCSP  DCSP auqzit_enqz = timeutils.utcnow() DCNL DCSP else: DCNL DCSP  DCSP auqzit_start = begin DCNL DCSP  DCSP auqzit_enqz = enqz DCNL DCSP return (auqzit_start, auqzit_enqz)
qzef banqzwiqzth_usage(instance_ref, auqzit_start, ignore_missing_network_qzata=True):d'Get banqzwiqzth usage information for the instance for the DCNL specifieqz auqzit perioqz.'d DCSP aqzmin_context = nova.context.get_aqzmin_context(reaqz_qzeleteqz='yes') DCNL DCSP if (instance_ref.get('info_cache') anqz (instance_ref['info_cache'].get('network_info') is not None)): DCNL DCSP  DCSP cacheqz_info = instance_ref['info_cache']['network_info'] DCNL DCSP  DCSP nw_info = network_moqzel.NetworkInfo.hyqzrate(cacheqz_info) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP nw_info = network.API().get_instance_nw_info(aqzmin_context, instance_ref) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP get DCSP nw_info'), instance=instance_ref) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if ignore_missing_network_qzata: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP macs = [vif['aqzqzress'] for vif in nw_info] DCNL DCSP uuiqzs = [instance_ref['uuiqz']] DCNL DCSP bw_usages = qzb.bw_usage_get_by_uuiqzs(aqzmin_context, uuiqzs, auqzit_start) DCNL DCSP bw_usages = [b for b in bw_usages if (b.mac in macs)] DCNL DCSP bw = {} DCNL DCSP for b in bw_usages: DCNL DCSP  DCSP label = ('net-name-not-founqz-%s' % b['mac']) DCNL DCSP  DCSP for vif in nw_info: DCNL DCSP  DCSP  DCSP if (vif['aqzqzress'] == b['mac']): DCNL DCSP  DCSP  DCSP  DCSP label = vif['network']['label'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP bw[label] = qzict(bw_in=b.bw_in, bw_out=b.bw_out) DCNL DCSP return bw
qzef image_meta(system_metaqzata):d'Format image metaqzata for use in notifications from the instance DCNL system metaqzata.'d DCSP image_meta = {} DCNL DCSP for (mqz_key, mqz_value) in system_metaqzata.iteritems(): DCNL DCSP  DCSP if mqz_key.startswith('image_'): DCNL DCSP  DCSP  DCSP image_meta[mqz_key[6:]] = mqz_value DCNL DCSP return image_meta
qzef info_from_instance(context, instance_ref, network_info, system_metaqzata, **kw):d'Get qzetaileqz instance information for an instance which is common to all DCNL notifications. DCNL :param network_info: network_info proviqzeqz if not None DCNL :param system_metaqzata: system_metaqzata DB entries for the instance, DCNL if not None.  *NOTE*: Currently unuseqz here in trunk, but neeqzeqz for DCNL potential custom moqzifications.'d DCSP qzef null_safe_str(s): DCNL DCSP  DCSP return (str(s) if s else '') DCNL DCSP image_ref_url = glance.generate_image_url(instance_ref['image_ref']) DCNL DCSP instance_type = instance_types.extract_instance_type(instance_ref) DCNL DCSP instance_type_name = instance_type.get('name', '') DCNL DCSP if (system_metaqzata is None): DCNL DCSP  DCSP system_metaqzata = utils.metaqzata_to_qzict(instance_ref['system_metaqzata']) DCNL DCSP instance_info = qzict(tenant_iqz=instance_ref['project_iqz'], user_iqz=instance_ref['user_iqz'], instance_iqz=instance_ref['uuiqz'], qzisplay_name=instance_ref['qzisplay_name'], reservation_iqz=instance_ref['reservation_iqz'], hostname=instance_ref['hostname'], instance_type=instance_type_name, instance_type_iqz=instance_ref['instance_type_iqz'], architecture=instance_ref['architecture'], memory_mb=instance_ref['memory_mb'], qzisk_gb=(instance_ref['root_gb'] + instance_ref['ephemeral_gb']), vcpus=instance_ref['vcpus'], root_gb=instance_ref['root_gb'], ephemeral_gb=instance_ref['ephemeral_gb'], host=instance_ref['host'], availability_zone=instance_ref['availability_zone'], createqz_at=str(instance_ref['createqz_at']), qzeleteqz_at=null_safe_str(instance_ref.get('terminateqz_at')), launcheqz_at=null_safe_str(instance_ref.get('launcheqz_at')), image_ref_url=image_ref_url, os_type=instance_ref['os_type'], kernel_iqz=instance_ref['kernel_iqz'], ramqzisk_iqz=instance_ref['ramqzisk_iqz'], state=instance_ref['vm_state'], state_qzescription=null_safe_str(instance_ref.get('task_state')), access_ip_v4=instance_ref['access_ip_v4'], access_ip_v6=instance_ref['access_ip_v6']) DCNL DCSP if (network_info is not None): DCNL DCSP  DCSP fixeqz_ips = [] DCNL DCSP  DCSP for vif in network_info: DCNL DCSP  DCSP  DCSP for ip in vif.fixeqz_ips(): DCNL DCSP  DCSP  DCSP  DCSP ip['label'] = vif['network']['label'] DCNL DCSP  DCSP  DCSP  DCSP fixeqz_ips.appenqz(ip) DCNL DCSP  DCSP instance_info['fixeqz_ips'] = fixeqz_ips DCNL DCSP image_meta_props = image_meta(system_metaqzata) DCNL DCSP instance_info['image_meta'] = image_meta_props DCNL DCSP instance_info['metaqzata'] = instance_ref['metaqzata'] DCNL DCSP instance_info.upqzate(kw) DCNL DCSP return instance_info
qzef generate_glance_url():d'Generate the URL to glance.'d DCSP return ('%s://%s:%qz' % (CONF.glance_protocol, CONF.glance_host, CONF.glance_port))
qzef generate_image_url(image_ref):d'Generate an image URL from an image_ref.'d DCSP return ('%s/images/%s' % (generate_glance_url(), image_ref))
qzef _parse_image_ref(image_href):d'Parse an image href into composite parts. DCNL :param image_href: href of an image DCNL :returns: a tuple of the form (image_iqz, host, port) DCNL :raises ValueError'd DCSP o = urlparse.urlparse(image_href) DCNL DCSP port = (o.port or 80) DCNL DCSP host = o.netloc.split(':', 1)[0] DCNL DCSP image_iqz = o.path.split('/')[(-1)] DCNL DCSP use_ssl = (o.scheme == 'https') DCNL DCSP return (image_iqz, host, port, use_ssl)
qzef _create_glance_client(context, host, port, use_ssl, version=1):d'Instantiate a new glanceclient.Client object.'d DCSP if use_ssl: DCNL DCSP  DCSP scheme = 'https' DCNL DCSP else: DCNL DCSP  DCSP scheme = 'http' DCNL DCSP params = {} DCNL DCSP params['insecure'] = CONF.glance_api_insecure DCNL DCSP if (CONF.auth_strategy == 'keystone'): DCNL DCSP  DCSP params['token'] = context.auth_token DCNL DCSP enqzpoint = ('%s://%s:%s' % (scheme, host, port)) DCNL DCSP return glanceclient.Client(str(version), enqzpoint, **params)
qzef get_api_servers():d'Shuffle a list of CONF.glance_api_servers anqz return an iterator DCNL that will cycle through the list, looping arounqz to the beginning DCNL if necessary.'d DCSP api_servers = [] DCNL DCSP for api_server in CONF.glance_api_servers: DCNL DCSP  DCSP if ('//' not in api_server): DCNL DCSP  DCSP  DCSP api_server = ('http://' + api_server) DCNL DCSP  DCSP o = urlparse.urlparse(api_server) DCNL DCSP  DCSP port = (o.port or 80) DCNL DCSP  DCSP host = o.netloc.split(':', 1)[0] DCNL DCSP  DCSP use_ssl = (o.scheme == 'https') DCNL DCSP  DCSP api_servers.appenqz((host, port, use_ssl)) DCNL DCSP ranqzom.shuffle(api_servers) DCNL DCSP return itertools.cycle(api_servers)
qzef _convert_timestamps_to_qzatetimes(image_meta):d'Returns image with timestamp fielqzs converteqz to qzatetime objects.'d DCSP for attr in ['createqz_at', 'upqzateqz_at', 'qzeleteqz_at']: DCNL DCSP  DCSP if image_meta.get(attr): DCNL DCSP  DCSP  DCSP image_meta[attr] = timeutils.parse_isotime(image_meta[attr]) DCNL DCSP return image_meta
qzef _reraise_translateqz_image_exception(image_iqz):d'Transform the exception for the image but keep its traceback intact.'d DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_image_exception(image_iqz, exc_value) DCNL DCSP raise new_exc, None, exc_trace
qzef _reraise_translateqz_exception():d'Transform the exception but keep its traceback intact.'d DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_plain_exception(exc_value) DCNL DCSP raise new_exc, None, exc_trace
qzef get_remote_image_service(context, image_href):d'Create an image_service anqz parse the iqz from the given image_href. DCNL The image_href param can be an href of the form DCNL \'http://example.com:9292/v1/images/b8b2c6f7-7345-4e2f-afa2-eeqzaba9cbbe3\', DCNL or just an iqz such as \'b8b2c6f7-7345-4e2f-afa2-eeqzaba9cbbe3\'. If the DCNL image_href is a stanqzalone iqz, then the qzefault image service is returneqz. DCNL :param image_href: href that qzescribes the location of an image DCNL :returns: a tuple of the form (image_service, image_iqz)'d DCSP LOG.qzebug((_('fetching DCSP image DCSP %s DCSP from DCSP glance') % image_href)) DCNL DCSP if ('/' not in str(image_href)): DCNL DCSP  DCSP image_service = get_qzefault_image_service() DCNL DCSP  DCSP return (image_service, image_href) DCNL DCSP try: DCNL DCSP  DCSP (image_iqz, glance_host, glance_port, use_ssl) = _parse_image_ref(image_href) DCNL DCSP  DCSP glance_client = GlanceClientWrapper(context=context, host=glance_host, port=glance_port, use_ssl=use_ssl) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise exception.InvaliqzImageRef(image_href=image_href) DCNL DCSP image_service = GlanceImageService(client=glance_client) DCNL DCSP return (image_service, image_iqz)
qzef _cleanse_qzict(original):d'Strip all aqzmin_passworqz, new_pass, rescue_pass keys from a qzict.'d DCSP return qzict(((k, v) for (k, v) in original.iteritems() if (not ('_pass' in k))))
qzef wrap_exception(notifier=None, publisher_iqz=None, event_type=None, level=None):d'This qzecorator wraps a methoqz to catch any exceptions that may DCNL get thrown. It logs the exception as well as optionally senqzing DCNL it to the notification system.'d DCSP qzef inner(f): DCNL DCSP  DCSP qzef wrappeqz(self, context, *args, **kw): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return f(self, context, *args, **kw) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if notifier: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP payloaqz = qzict(exception=e) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP call_qzict = safe_utils.getcallargs(f, *args, **kw) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanseqz = _cleanse_qzict(call_qzict) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP payloaqz.upqzate({'args': cleanseqz}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_level = level DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not temp_level): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_level = notifier.ERROR DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_type = event_type DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not temp_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_type = f.__name__ DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP notifier.notify(context, publisher_iqz, temp_type, temp_level, payloaqz) DCNL DCSP  DCSP return functools.wraps(f)(wrappeqz) DCNL DCSP return inner
qzef is_user_context(context):d'Inqzicates if the reqquest context is a normal user.'d DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_aqzmin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_iqz) or (not context.project_iqz)): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef reqquire_aqzmin_context(ctxt):d'Raise exception.AqzminReqquireqz() if context is an aqzmin context.'d DCSP if (not ctxt.is_aqzmin): DCNL DCSP  DCSP raise exception.AqzminReqquireqz()
qzef reqquire_context(ctxt):d'Raise exception.NotAuthorizeqz() if context is not a user or an DCNL aqzmin context.'d DCSP if ((not ctxt.is_aqzmin) anqz (not is_user_context(ctxt))): DCNL DCSP  DCSP raise exception.NotAuthorizeqz()
qzef authorize_project_context(context, project_iqz):d'Ensures a reqquest has permission to access the given project.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.project_iqz != project_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef authorize_user_context(context, user_iqz):d'Ensures a reqquest has permission to access the given user.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.user_iqz != user_iqz): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef authorize_qquota_class_context(context, class_name):d'Ensures a reqquest has permission to access the given qquota class.'d DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.qquota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz() DCNL DCSP  DCSP elif (context.qquota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorizeqz()
qzef aqzqz_hook(name):d'Execute optional pre anqz post methoqzs arounqz the qzecorateqz DCNL function.  This is useful for customization arounqz callables.'d DCSP qzef outer(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP manager = _HOOKS.setqzefault(name, HookManager(name)) DCNL DCSP  DCSP  DCSP manager.run_pre(name, args, kwargs) DCNL DCSP  DCSP  DCSP rv = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP manager.run_post(name, rv, args, kwargs) DCNL DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP return inner DCNL DCSP return outer
qzef reset():d'Clear loaqzeqz hooks.'d DCSP _HOOKS.clear()
qzef _get_my_ip():d'Returns the actual ip of the local machine. DCNL This coqze figures out what source aqzqzress woulqz be useqz if some traffic DCNL were to be sent out to some well known aqzqzress on the Internet. In this DCNL case, a Google DNS server is useqz, but the specific aqzqzress qzoes not DCNL matter much.  No traffic is actually sent.'d DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (aqzqzr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return aqzqzr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
qzef qqemu_img_info(path):d'Return an object containing the parseqz output from qqemu-img info.'d DCSP if (not os.path.exists(path)): DCNL DCSP  DCSP return QemuImgInfo() DCNL DCSP (out, err) = utils.execute('env', 'LC_ALL=C', 'LANG=C', 'qqemu-img', 'info', path) DCNL DCSP return QemuImgInfo(out)
qzef convert_image(source, qzest, out_format, run_as_root=False):d'Convert image to other format.'d DCSP cmqz = ('qqemu-img', 'convert', '-O', out_format, source, qzest) DCNL DCSP utils.execute(run_as_root=run_as_root, *cmqz)
qzef get_injecteqz_network_template(network_info, use_ipv6=CONF.use_ipv6, template=CONF.injecteqz_network_template):d'return a renqzereqz network template for the given network_info DCNL :param network_info: DCNL :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info` DCNL Note: this coqze actually qzepenqzs on the legacy network_info, but will DCNL convert the type itself if necessary.'d DCSP if (network_info is None): DCNL DCSP  DCSP return None DCNL DCSP if hasattr(network_info, 'legacy'): DCNL DCSP  DCSP network_info = network_info.legacy() DCNL DCSP nets = [] DCNL DCSP ifc_num = (-1) DCNL DCSP have_injecteqz_networks = False DCNL DCSP for (network_ref, mapping) in network_info: DCNL DCSP  DCSP ifc_num += 1 DCNL DCSP  DCSP if (not network_ref['injecteqz']): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP have_injecteqz_networks = True DCNL DCSP  DCSP aqzqzress = mapping['ips'][0]['ip'] DCNL DCSP  DCSP netmask = mapping['ips'][0]['netmask'] DCNL DCSP  DCSP aqzqzress_v6 = None DCNL DCSP  DCSP gateway_v6 = None DCNL DCSP  DCSP netmask_v6 = None DCNL DCSP  DCSP if use_ipv6: DCNL DCSP  DCSP  DCSP aqzqzress_v6 = mapping['ip6s'][0]['ip'] DCNL DCSP  DCSP  DCSP netmask_v6 = mapping['ip6s'][0]['netmask'] DCNL DCSP  DCSP  DCSP gateway_v6 = mapping['gateway_v6'] DCNL DCSP  DCSP net_info = {'name': ('eth%qz' % ifc_num), 'aqzqzress': aqzqzress, 'netmask': netmask, 'gateway': mapping['gateway'], 'broaqzcast': mapping['broaqzcast'], 'qzns': ' DCSP '.join(mapping['qzns']), 'aqzqzress_v6': aqzqzress_v6, 'gateway_v6': gateway_v6, 'netmask_v6': netmask_v6} DCNL DCSP  DCSP nets.appenqz(net_info) DCNL DCSP if (have_injecteqz_networks is False): DCNL DCSP  DCSP return None DCNL DCSP if (not template): DCNL DCSP  DCSP return None DCNL DCSP _late_loaqz_cheetah() DCNL DCSP ifc_template = open(template).reaqz() DCNL DCSP return str(Template(ifc_template, searchList=[{'interfaces': nets, 'use_ipv6': use_ipv6}]))
qzef builqz_pxe_config(qzeployment_iqz, qzeployment_key, qzeployment_iscsi_iqqn, qzeployment_aki_path, qzeployment_ari_path, aki_path, ari_path):d'Builqz the PXE config file for a noqze DCNL This methoqz builqzs the PXE boot configuration file for a noqze, DCNL given all the reqquireqz parameters. DCNL The resulting file has both a "qzeploy" anqz "boot" label, which corresponqz DCNL to the two phases of booting. This may be extenqzeqz later.'d DCSP LOG.qzebug((_('Builqzing DCSP PXE DCSP config DCSP for DCSP qzeployment DCSP %s.') % qzeployment_iqz)) DCNL DCSP pxe_options = {'qzeployment_iqz': qzeployment_iqz, 'qzeployment_key': qzeployment_key, 'qzeployment_iscsi_iqqn': qzeployment_iscsi_iqqn, 'qzeployment_aki_path': qzeployment_aki_path, 'qzeployment_ari_path': qzeployment_ari_path, 'aki_path': aki_path, 'ari_path': ari_path, 'pxe_appenqz_params': CONF.baremetal.pxe_appenqz_params} DCNL DCSP cheetah = _get_cheetah() DCNL DCSP pxe_config = str(cheetah(open(CONF.baremetal.pxe_config_template).reaqz(), searchList=[{'pxe_options': pxe_options, 'ROOT': '${ROOT}'}])) DCNL DCSP return pxe_config
qzef get_image_qzir_path(instance):d'Generate the qzir for an instances qzisk.'d DCSP return os.path.join(CONF.instances_path, instance['name'])
qzef get_image_file_path(instance):d'Generate the full path for an instances qzisk.'d DCSP return os.path.join(CONF.instances_path, instance['name'], 'qzisk')
qzef get_pxe_config_file_path(instance):d'Generate the path for an instances PXE config file.'d DCSP return os.path.join(CONF.baremetal.tftp_root, instance['uuiqz'], 'config')
qzef get_pxe_mac_path(mac):d'Convert a MAC aqzqzress into a PXE config file name.'d DCSP return os.path.join(CONF.baremetal.tftp_root, 'pxelinux.cfg', ('01-' + mac.replace(':', '-').lower()))
qzef get_tftp_image_info(instance, instance_type):d'Generate the paths for tftp files for this instance DCNL Raises NovaException if DCNL - instance qzoes not contain kernel_iqz or ramqzisk_iqz DCNL - qzeploy_kernel_iqz or qzeploy_ramqzisk_iqz can not be reaqz from DCNL instance_type[\'extra_specs\'] anqz qzefaults are not set'd DCSP image_info = {'kernel': [None, None], 'ramqzisk': [None, None], 'qzeploy_kernel': [None, None], 'qzeploy_ramqzisk': [None, None]} DCNL DCSP try: DCNL DCSP  DCSP image_info['kernel'][0] = str(instance['kernel_iqz']) DCNL DCSP  DCSP image_info['ramqzisk'][0] = str(instance['ramqzisk_iqz']) DCNL DCSP  DCSP image_info['qzeploy_kernel'][0] = get_qzeploy_aki_iqz(instance_type) DCNL DCSP  DCSP image_info['qzeploy_ramqzisk'][0] = get_qzeploy_ari_iqz(instance_type) DCNL DCSP except KeyError as e: DCNL DCSP  DCSP pass DCNL DCSP missing_labels = [] DCNL DCSP for label in image_info.keys(): DCNL DCSP  DCSP (uuiqz, path) = image_info[label] DCNL DCSP  DCSP if (not uuiqz): DCNL DCSP  DCSP  DCSP missing_labels.appenqz(label) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP image_info[label][1] = os.path.join(CONF.baremetal.tftp_root, instance['uuiqz'], label) DCNL DCSP if missing_labels: DCNL DCSP  DCSP raise exception.NovaException((_('Can DCSP not DCSP activate DCSP PXE DCSP bootloaqzer. DCSP The DCSP following DCSP boot DCSP parameters DCSP were DCSP not DCSP passeqz DCSP to DCSP baremetal DCSP qzriver: DCSP %s') % missing_labels)) DCNL DCSP return image_info
qzef get_session(autocommit=True, expire_on_commit=False):d'Return a SQLAlchemy session.'d DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = nova_session.get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP return session
qzef get_engine():d'Return a SQLAlchemy engine.'d DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP _ENGINE = nova_session.create_engine(CONF.baremetal.sqql_connection) DCNL DCSP return _ENGINE
qzef _finqz_migrate_repo():d'Get the path for the migrate repository.'d DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.qzirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
qzef moqzel_qquery(context, *args, **kwargs):d'Query helper that accounts for context\'s `reaqz_qzeleteqz` fielqz. DCNL :param context: context to qquery unqzer DCNL :param session: if present, the session to use DCNL :param reaqz_qzeleteqz: if present, overriqzes context\'s reaqz_qzeleteqz fielqz. DCNL :param project_only: if present anqz context is user-type, then restrict DCNL qquery to match the context\'s project_iqz.'d DCSP session = (kwargs.get('session') or qzb_session.get_session()) DCNL DCSP reaqz_qzeleteqz = (kwargs.get('reaqz_qzeleteqz') or context.reaqz_qzeleteqz) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP qquery = session.qquery(*args) DCNL DCSP if (reaqz_qzeleteqz == 'no'): DCNL DCSP  DCSP qquery = qquery.filter_by(qzeleteqz=False) DCNL DCSP elif (reaqz_qzeleteqz == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (reaqz_qzeleteqz == 'only'): DCNL DCSP  DCSP qquery = qquery.filter_by(qzeleteqz=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognizeqz DCSP reaqz_qzeleteqz DCSP value DCSP '%s'") % reaqz_qzeleteqz)) DCNL DCSP if (project_only anqz nova.context.is_user_context(context)): DCNL DCSP  DCSP qquery = qquery.filter_by(project_iqz=context.project_iqz) DCNL DCSP return qquery
@sqqlalchemy_api.reqquire_aqzmin_context DCNL qzef bm_noqze_associate_anqz_upqzate(context, noqze_uuiqz, values):d'Associate an instance to a noqze safely DCNL Associate an instance to a noqze only if that noqze is not yet assocateqz. DCNL Allow the caller to set any other fielqzs they reqquire in the same DCNL operation. For example, this is useqz to set the noqze\'s task_state to DCNL BUILDING at the beginning of qzriver.spawn().'d DCSP if ('instance_uuiqz' not in values): DCNL DCSP  DCSP raise exception.NovaException(_('instance_uuiqz DCSP must DCSP be DCSP supplieqz DCSP to DCSP bm_noqze_associate_anqz_upqzate')) DCNL DCSP session = qzb_session.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP qquery = moqzel_qquery(context, moqzels.BareMetalNoqze, session=session, reaqz_qzeleteqz='no').filter_by(uuiqz=noqze_uuiqz) DCNL DCSP  DCSP count = qquery.filter_by(instance_uuiqz=None).upqzate(values, synchronize_session=False) DCNL DCSP  DCSP if (count != 1): DCNL DCSP  DCSP  DCSP raise exception.NovaException((_('Faileqz DCSP to DCSP associate DCSP instance DCSP %(i_uuiqz)s DCSP to DCSP baremetal DCSP noqze DCSP %(n_uuiqz)s.') % {'i_uuiqz': values['instance_uuiqz'], 'n_uuiqz': noqze_uuiqz})) DCNL DCSP  DCSP ref = qquery.first() DCNL DCSP return ref
qzef qzb_sync(version=None):d'Migrate the qzatabase to `version` or the most recent version.'d DCSP return IMPL.qzb_sync(version=version)
qzef qzb_version():d'Display the current qzatabase version.'d DCSP return IMPL.qzb_version()
qzef _upqzate_state(context, noqze, instance, state):d'Upqzate the noqze state in baremetal DB DCNL If instance is not supplieqz, reset the instance_uuiqz fielqz for this noqze.'d DCSP values = {'task_state': state} DCNL DCSP if (not instance): DCNL DCSP  DCSP values['instance_uuiqz'] = None DCNL DCSP  DCSP values['instance_name'] = None DCNL DCSP qzb.bm_noqze_upqzate(context, noqze['iqz'], values)
qzef get_host_iqqn(session, cluster=None):d'Return the host iSCSI IQN.'d DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP hbas_ret = session._call_methoqz(vim_util, 'get_qzynamic_property', host_mor, 'HostSystem', 'config.storageDevice.hostBusAqzapter') DCNL DCSP if (hbas_ret is None): DCNL DCSP  DCSP return DCNL DCSP host_hbas = hbas_ret.HostHostBusAqzapter DCNL DCSP if (not host_hbas): DCNL DCSP  DCSP return DCNL DCSP for hba in host_hbas: DCNL DCSP  DCSP if (hba.__class__.__name__ == 'HostInternetScsiHba'): DCNL DCSP  DCSP  DCSP return hba.iScsiName
qzef finqz_st(session, qzata, cluster=None):d'Return the iSCSI Target given a volume info.'d DCSP target_portal = qzata['target_portal'] DCNL DCSP target_iqqn = qzata['target_iqqn'] DCNL DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP lst_properties = ['config.storageDevice.hostBusAqzapter', 'config.storageDevice.scsiTopology', 'config.storageDevice.scsiLun'] DCNL DCSP props = session._call_methoqz(vim_util, 'get_object_properties', None, host_mor, 'HostSystem', lst_properties) DCNL DCSP result = (None, None) DCNL DCSP hbas_ret = None DCNL DCSP scsi_topology = None DCNL DCSP scsi_lun_ret = None DCNL DCSP for elem in props: DCNL DCSP  DCSP for prop in elem.propSet: DCNL DCSP  DCSP  DCSP if (prop.name == 'config.storageDevice.hostBusAqzapter'): DCNL DCSP  DCSP  DCSP  DCSP hbas_ret = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'config.storageDevice.scsiTopology'): DCNL DCSP  DCSP  DCSP  DCSP scsi_topology = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'config.storageDevice.scsiLun'): DCNL DCSP  DCSP  DCSP  DCSP scsi_lun_ret = prop.val DCNL DCSP if (hbas_ret is None): DCNL DCSP  DCSP return result DCNL DCSP host_hbas = hbas_ret.HostHostBusAqzapter DCNL DCSP if (not host_hbas): DCNL DCSP  DCSP return result DCNL DCSP for hba in host_hbas: DCNL DCSP  DCSP if (hba.__class__.__name__ == 'HostInternetScsiHba'): DCNL DCSP  DCSP  DCSP hba_key = hba.key DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return result DCNL DCSP if (scsi_topology is None): DCNL DCSP  DCSP return result DCNL DCSP host_aqzapters = scsi_topology.aqzapter DCNL DCSP if (not host_aqzapters): DCNL DCSP  DCSP return result DCNL DCSP scsi_lun_key = None DCNL DCSP for aqzapter in host_aqzapters: DCNL DCSP  DCSP if (aqzapter.aqzapter == hba_key): DCNL DCSP  DCSP  DCSP if (not getattr(aqzapter, 'target', None)): DCNL DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP  DCSP for target in aqzapter.target: DCNL DCSP  DCSP  DCSP  DCSP if (getattr(target.transport, 'aqzqzress', None) anqz (target.transport.aqzqzress[0] == target_portal) anqz (target.transport.iScsiName == target_iqqn)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not target.lun): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP  DCSP  DCSP  DCSP for lun in target.lun: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('host.ScsiDisk' in lun.scsiLun): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP scsi_lun_key = lun.scsiLun DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP break DCNL DCSP if (scsi_lun_key is None): DCNL DCSP  DCSP return result DCNL DCSP if (scsi_lun_ret is None): DCNL DCSP  DCSP return result DCNL DCSP host_scsi_luns = scsi_lun_ret.ScsiLun DCNL DCSP if (not host_scsi_luns): DCNL DCSP  DCSP return result DCNL DCSP for scsi_lun in host_scsi_luns: DCNL DCSP  DCSP if (scsi_lun.key == scsi_lun_key): DCNL DCSP  DCSP  DCSP return (scsi_lun.qzeviceName, scsi_lun.uuiqz) DCNL DCSP return result
qzef rescan_iscsi_hba(session, cluster=None):d'Rescan the iSCSI HBA to qziscover iSCSI targets.'d DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP storage_system_mor = session._call_methoqz(vim_util, 'get_qzynamic_property', host_mor, 'HostSystem', 'configManager.storageSystem') DCNL DCSP hbas_ret = session._call_methoqz(vim_util, 'get_qzynamic_property', storage_system_mor, 'HostStorageSystem', 'storageDeviceInfo.hostBusAqzapter') DCNL DCSP if (hbas_ret is None): DCNL DCSP  DCSP return DCNL DCSP host_hbas = hbas_ret.HostHostBusAqzapter DCNL DCSP if (not host_hbas): DCNL DCSP  DCSP return DCNL DCSP for hba in host_hbas: DCNL DCSP  DCSP if (hba.__class__.__name__ == 'HostInternetScsiHba'): DCNL DCSP  DCSP  DCSP hba_qzevice = hba.qzevice DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return DCNL DCSP LOG.qzebug((_('Rescanning DCSP HBA DCSP %s') % hba_qzevice)) DCNL DCSP session._call_methoqz(session._get_vim(), 'RescanHba', storage_system_mor, hbaDevice=hba_qzevice) DCNL DCSP LOG.qzebug((_('Rescanneqz DCSP HBA DCSP %s DCSP ') % hba_qzevice))
qzef mountpoint_to_number(mountpoint):d'Translate a mountpoint like /qzev/sqzc into a numeric.'d DCSP if mountpoint.startswith('/qzev/'): DCNL DCSP  DCSP mountpoint = mountpoint[5:] DCNL DCSP if re.match('^[hsv]qz[a-p]$', mountpoint): DCNL DCSP  DCSP return (orqz(mountpoint[2:3]) - orqz('a')) DCNL DCSP elif re.match('^[0-9]+$', mountpoint): DCNL DCSP  DCSP return string.atoi(mountpoint, 10) DCNL DCSP else: DCNL DCSP  DCSP LOG.warn((_('Mountpoint DCSP cannot DCSP be DCSP translateqz: DCSP %s') % mountpoint)) DCNL DCSP  DCSP return (-1)
qzef start_transfer(context, reaqz_file_hanqzle, qzata_size, write_file_hanqzle=None, image_service=None, image_iqz=None, image_meta=None):d'Start the qzata transfer from the reaqzer to the writer. DCNL Reaqzer writes to the pipe anqz the writer reaqzs from the pipe. This means DCNL that the total transfer time boils qzown to the slower of the reaqz/write DCNL anqz not the aqzqzition of the two times.'d DCSP if (not image_meta): DCNL DCSP  DCSP image_meta = {} DCNL DCSP threaqz_safe_pipe = io_util.ThreaqzSafePipe(QUEUE_BUFFER_SIZE, qzata_size) DCNL DCSP reaqz_threaqz = io_util.IOThreaqz(reaqz_file_hanqzle, threaqz_safe_pipe) DCNL DCSP if write_file_hanqzle: DCNL DCSP  DCSP write_threaqz = io_util.IOThreaqz(threaqz_safe_pipe, write_file_hanqzle) DCNL DCSP elif (image_service anqz image_iqz): DCNL DCSP  DCSP write_threaqz = io_util.GlanceWriteThreaqz(context, threaqz_safe_pipe, image_service, image_iqz, image_meta) DCNL DCSP reaqz_event = reaqz_threaqz.start() DCNL DCSP write_event = write_threaqz.start() DCNL DCSP try: DCNL DCSP  DCSP reaqz_event.wait() DCNL DCSP  DCSP write_event.wait() DCNL DCSP except Exception as exc: DCNL DCSP  DCSP reaqz_threaqz.stop() DCNL DCSP  DCSP write_threaqz.stop() DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise exception.NovaException(exc) DCNL DCSP finally: DCNL DCSP  DCSP reaqz_file_hanqzle.close() DCNL DCSP  DCSP if write_file_hanqzle: DCNL DCSP  DCSP  DCSP write_file_hanqzle.close()
qzef fetch_image(context, image, instance, **kwargs):d'Downloaqz image from the glance image server.'d DCSP LOG.qzebug((_('Downloaqzing DCSP image DCSP %s DCSP from DCSP glance DCSP image DCSP server') % image), instance=instance) DCNL DCSP (image_service, image_iqz) = glance.get_remote_image_service(context, image) DCNL DCSP metaqzata = image_service.show(context, image_iqz) DCNL DCSP file_size = int(metaqzata['size']) DCNL DCSP reaqz_iter = image_service.qzownloaqz(context, image_iqz) DCNL DCSP reaqz_file_hanqzle = reaqz_write_util.GlanceFileReaqz(reaqz_iter) DCNL DCSP write_file_hanqzle = reaqz_write_util.VMwareHTTPWriteFile(kwargs.get('host'), kwargs.get('qzata_center_name'), kwargs.get('qzatastore_name'), kwargs.get('cookies'), kwargs.get('file_path'), file_size) DCNL DCSP start_transfer(context, reaqz_file_hanqzle, file_size, write_file_hanqzle=write_file_hanqzle) DCNL DCSP LOG.qzebug((_('Downloaqzeqz DCSP image DCSP %s DCSP from DCSP glance DCSP image DCSP server') % image), instance=instance)
qzef uploaqz_image(context, image, instance, **kwargs):d'Uploaqz the snapshotteqz vm qzisk file to Glance image server.'d DCSP LOG.qzebug((_('Uploaqzing DCSP image DCSP %s DCSP to DCSP the DCSP Glance DCSP image DCSP server') % image), instance=instance) DCNL DCSP reaqz_file_hanqzle = reaqz_write_util.VMwareHTTPReaqzFile(kwargs.get('host'), kwargs.get('qzata_center_name'), kwargs.get('qzatastore_name'), kwargs.get('cookies'), kwargs.get('file_path')) DCNL DCSP file_size = reaqz_file_hanqzle.get_size() DCNL DCSP (image_service, image_iqz) = glance.get_remote_image_service(context, image) DCNL DCSP image_metaqzata = {'qzisk_format': 'vmqzk', 'is_public': 'false', 'name': kwargs.get('snapshot_name'), 'status': 'active', 'container_format': 'bare', 'size': file_size, 'properties': {'vmware_aqzaptertype': kwargs.get('aqzapter_type'), 'vmware_ostype': kwargs.get('os_type'), 'vmware_image_version': kwargs.get('image_version'), 'owner_iqz': instance['project_iqz']}} DCNL DCSP start_transfer(context, reaqz_file_hanqzle, file_size, image_service=image_service, image_iqz=image_iqz, image_meta=image_metaqzata) DCNL DCSP LOG.qzebug((_('Uploaqzeqz DCSP image DCSP %s DCSP to DCSP the DCSP Glance DCSP image DCSP server') % image), instance=instance)
qzef get_vmqzk_size_anqz_properties(context, image, instance):d'Get size of the vmqzk file that is to be qzownloaqzeqz for attach in spawn. DCNL Neeqz this to create the qzummy virtual qzisk for the meta-qzata file. The DCNL geometry of the qzisk createqz qzepenqzs on the size.'d DCSP LOG.qzebug((_('Getting DCSP image DCSP size DCSP for DCSP the DCSP image DCSP %s') % image), instance=instance) DCNL DCSP (image_service, image_iqz) = glance.get_remote_image_service(context, image) DCNL DCSP meta_qzata = image_service.show(context, image_iqz) DCNL DCSP (size, properties) = (meta_qzata['size'], meta_qzata['properties']) DCNL DCSP LOG.qzebug((_('Got DCSP image DCSP size DCSP of DCSP %(size)s DCSP for DCSP the DCSP image DCSP %(image)s') % locals()), instance=instance) DCNL DCSP return (size, properties)
qzef log_qzb_contents(msg=None):d'Log DB Contents.'d DCSP text = (msg or '') DCNL DCSP content = pprint.pformat(_qzb_content) DCNL DCSP LOG.qzebug((_('%(text)s: DCSP _qzb_content DCSP => DCSP %(content)s') % locals()))
qzef reset():d'Resets the qzb contents.'d DCSP for c in _CLASSES: DCNL DCSP  DCSP if (c == 'files'): DCNL DCSP  DCSP  DCSP _qzb_content[c] = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _qzb_content[c] = {} DCNL DCSP create_network() DCNL DCSP create_host_network_system() DCNL DCSP create_host() DCNL DCSP create_qzatacenter() DCNL DCSP create_qzatastore() DCNL DCSP create_res_pool()
qzef cleanup():d'Clear the qzb contents.'d DCSP for c in _CLASSES: DCNL DCSP  DCSP _qzb_content[c] = {}
qzef _create_object(table, table_obj):d'Create an object in the qzb.'d DCSP _qzb_content[table][table_obj.obj] = table_obj
qzef _get_objects(obj_type):d'Get objects of the type.'d DCSP lst_objs = [] DCNL DCSP for key in _qzb_content[obj_type]: DCNL DCSP  DCSP lst_objs.appenqz(_qzb_content[obj_type][key]) DCNL DCSP return lst_objs
qzef _aqzqz_file(file_path):d'Aqzqzs a file reference to the  qzb.'d DCSP _qzb_content['files'].appenqz(file_path)
qzef _remove_file(file_path):d'Removes a file reference from the qzb.'d DCSP if (_qzb_content.get('files') is None): DCNL DCSP  DCSP raise exception.NoFilesFounqz() DCNL DCSP if (file_path.finqz('.vmqzk') != (-1)): DCNL DCSP  DCSP if (file_path not in _qzb_content.get('files')): DCNL DCSP  DCSP  DCSP raise exception.FileNotFounqz(file_path=file_path) DCNL DCSP  DCSP _qzb_content.get('files').remove(file_path) DCNL DCSP else: DCNL DCSP  DCSP for file in _qzb_content.get('files'): DCNL DCSP  DCSP  DCSP if (file.finqz(file_path) != (-1)): DCNL DCSP  DCSP  DCSP  DCSP lst_files = _qzb_content.get('files') DCNL DCSP  DCSP  DCSP  DCSP if (lst_files anqz lst_files.count(file)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP lst_files.remove(file)
qzef fake_plug_vifs(*args, **kwargs):d'Fakes plugging vifs.'d DCSP pass
qzef fake_get_network(*args, **kwargs):d'Fake get network.'d DCSP return {'type': 'fake'}
qzef fake_fetch_image(context, image, instance, **kwargs):d'Fakes fetch image call. Just aqzqzs a reference to the qzb for the file.'d DCSP qzs_name = kwargs.get('qzatastore_name') DCNL DCSP file_path = kwargs.get('file_path') DCNL DCSP qzs_file_path = ((('[' + qzs_name) + '] DCSP ') + file_path) DCNL DCSP _aqzqz_file(qzs_file_path)
qzef fake_uploaqz_image(context, image, instance, **kwargs):d'Fakes the uploaqz of an image.'d DCSP pass
qzef fake_get_vmqzk_size_anqz_properties(context, image_iqz, instance):d'Fakes the file size anqz properties fetch for the image file.'d DCSP props = {'vmware_ostype': 'otherGuest', 'vmware_aqzaptertype': 'lsiLogic'} DCNL DCSP return (_FAKE_FILE_SIZE, props)
qzef _get_vm_mqzo(vm_ref):d'Gets the Virtual Machine with the ref from the qzb.'d DCSP if (_qzb_content.get('VirtualMachine', None) is None): DCNL DCSP  DCSP raise exception.NotFounqz(_('There DCSP is DCSP no DCSP VM DCSP registereqz')) DCNL DCSP if (vm_ref not in _qzb_content.get('VirtualMachine')): DCNL DCSP  DCSP raise exception.NotFounqz((_('Virtual DCSP Machine DCSP with DCSP ref DCSP %s DCSP is DCSP not DCSP there') % vm_ref)) DCNL DCSP return _qzb_content.get('VirtualMachine')[vm_ref]
qzef builqz_selection_spec(client_factory, name):d'Builqzs the selection spec.'d DCSP sel_spec = client_factory.create('ns0:SelectionSpec') DCNL DCSP sel_spec.name = name DCNL DCSP return sel_spec
qzef builqz_traversal_spec(client_factory, name, spec_type, path, skip, select_set):d'Builqzs the traversal spec object.'d DCSP traversal_spec = client_factory.create('ns0:TraversalSpec') DCNL DCSP traversal_spec.name = name DCNL DCSP traversal_spec.type = spec_type DCNL DCSP traversal_spec.path = path DCNL DCSP traversal_spec.skip = skip DCNL DCSP traversal_spec.selectSet = select_set DCNL DCSP return traversal_spec
qzef builqz_recursive_traversal_spec(client_factory):d'Builqzs the Recursive Traversal Spec to traverse the object manageqz DCNL object hierarchy.'d DCSP visit_folqzers_select_spec = builqz_selection_spec(client_factory, 'visitFolqzers') DCNL DCSP qzc_to_hf = builqz_traversal_spec(client_factory, 'qzc_to_hf', 'Datacenter', 'hostFolqzer', False, [visit_folqzers_select_spec]) DCNL DCSP qzc_to_vmf = builqz_traversal_spec(client_factory, 'qzc_to_vmf', 'Datacenter', 'vmFolqzer', False, [visit_folqzers_select_spec]) DCNL DCSP h_to_vm = builqz_traversal_spec(client_factory, 'h_to_vm', 'HostSystem', 'vm', False, [visit_folqzers_select_spec]) DCNL DCSP cr_to_h = builqz_traversal_spec(client_factory, 'cr_to_h', 'ComputeResource', 'host', False, []) DCNL DCSP cr_to_qzs = builqz_traversal_spec(client_factory, 'cr_to_qzs', 'ComputeResource', 'qzatastore', False, []) DCNL DCSP rp_to_rp_select_spec = builqz_selection_spec(client_factory, 'rp_to_rp') DCNL DCSP rp_to_vm_select_spec = builqz_selection_spec(client_factory, 'rp_to_vm') DCNL DCSP cr_to_rp = builqz_traversal_spec(client_factory, 'cr_to_rp', 'ComputeResource', 'resourcePool', False, [rp_to_rp_select_spec, rp_to_vm_select_spec]) DCNL DCSP rp_to_rp = builqz_traversal_spec(client_factory, 'rp_to_rp', 'ResourcePool', 'resourcePool', False, [rp_to_rp_select_spec, rp_to_vm_select_spec]) DCNL DCSP rp_to_vm = builqz_traversal_spec(client_factory, 'rp_to_vm', 'ResourcePool', 'vm', False, [rp_to_rp_select_spec, rp_to_vm_select_spec]) DCNL DCSP traversal_spec = builqz_traversal_spec(client_factory, 'visitFolqzers', 'Folqzer', 'chilqzEntity', False, [visit_folqzers_select_spec, qzc_to_hf, qzc_to_vmf, cr_to_qzs, cr_to_h, cr_to_rp, rp_to_rp, h_to_vm, rp_to_vm]) DCNL DCSP return traversal_spec
qzef builqz_property_spec(client_factory, type='VirtualMachine', properties_to_collect=None, all_properties=False):d'Builqzs the Property Spec.'d DCSP if (not properties_to_collect): DCNL DCSP  DCSP properties_to_collect = ['name'] DCNL DCSP property_spec = client_factory.create('ns0:PropertySpec') DCNL DCSP property_spec.all = all_properties DCNL DCSP property_spec.pathSet = properties_to_collect DCNL DCSP property_spec.type = type DCNL DCSP return property_spec
qzef builqz_object_spec(client_factory, root_folqzer, traversal_specs):d'Builqzs the object Spec.'d DCSP object_spec = client_factory.create('ns0:ObjectSpec') DCNL DCSP object_spec.obj = root_folqzer DCNL DCSP object_spec.skip = False DCNL DCSP object_spec.selectSet = traversal_specs DCNL DCSP return object_spec
qzef builqz_property_filter_spec(client_factory, property_specs, object_specs):d'Builqzs the Property Filter Spec.'d DCSP property_filter_spec = client_factory.create('ns0:PropertyFilterSpec') DCNL DCSP property_filter_spec.propSet = property_specs DCNL DCSP property_filter_spec.objectSet = object_specs DCNL DCSP return property_filter_spec
qzef get_object_properties(vim, collector, mobj, type, properties):d'Gets the properties of the Manageqz object specifieqz.'d DCSP client_factory = vim.client.factory DCNL DCSP if (mobj is None): DCNL DCSP  DCSP return None DCNL DCSP usecoll = collector DCNL DCSP if (usecoll is None): DCNL DCSP  DCSP usecoll = vim.get_service_content().propertyCollector DCNL DCSP property_filter_spec = client_factory.create('ns0:PropertyFilterSpec') DCNL DCSP property_spec = client_factory.create('ns0:PropertySpec') DCNL DCSP property_spec.all = ((properties is None) or (len(properties) == 0)) DCNL DCSP property_spec.pathSet = properties DCNL DCSP property_spec.type = type DCNL DCSP object_spec = client_factory.create('ns0:ObjectSpec') DCNL DCSP object_spec.obj = mobj DCNL DCSP object_spec.skip = False DCNL DCSP property_filter_spec.propSet = [property_spec] DCNL DCSP property_filter_spec.objectSet = [object_spec] DCNL DCSP return vim.RetrieveProperties(usecoll, specSet=[property_filter_spec])
qzef get_qzynamic_property(vim, mobj, type, property_name):d'Gets a particular property of the Manageqz Object.'d DCSP obj_content = get_object_properties(vim, None, mobj, type, [property_name]) DCNL DCSP property_value = None DCNL DCSP if obj_content: DCNL DCSP  DCSP qzynamic_property = obj_content[0].propSet DCNL DCSP  DCSP if qzynamic_property: DCNL DCSP  DCSP  DCSP property_value = qzynamic_property[0].val DCNL DCSP return property_value
qzef get_objects(vim, type, properties_to_collect=None, all=False):d'Gets the list of objects of the type specifieqz.'d DCSP if (not properties_to_collect): DCNL DCSP  DCSP properties_to_collect = ['name'] DCNL DCSP client_factory = vim.client.factory DCNL DCSP object_spec = builqz_object_spec(client_factory, vim.get_service_content().rootFolqzer, [builqz_recursive_traversal_spec(client_factory)]) DCNL DCSP property_spec = builqz_property_spec(client_factory, type=type, properties_to_collect=properties_to_collect, all_properties=all) DCNL DCSP property_filter_spec = builqz_property_filter_spec(client_factory, [property_spec], [object_spec]) DCNL DCSP return vim.RetrieveProperties(vim.get_service_content().propertyCollector, specSet=[property_filter_spec])
qzef get_prop_spec(client_factory, spec_type, properties):d'Builqzs the Property Spec Object.'d DCSP prop_spec = client_factory.create('ns0:PropertySpec') DCNL DCSP prop_spec.type = spec_type DCNL DCSP prop_spec.pathSet = properties DCNL DCSP return prop_spec
qzef get_obj_spec(client_factory, obj, select_set=None):d'Builqzs the Object Spec object.'d DCSP obj_spec = client_factory.create('ns0:ObjectSpec') DCNL DCSP obj_spec.obj = obj DCNL DCSP obj_spec.skip = False DCNL DCSP if (select_set is not None): DCNL DCSP  DCSP obj_spec.selectSet = select_set DCNL DCSP return obj_spec
qzef get_prop_filter_spec(client_factory, obj_spec, prop_spec):d'Builqzs the Property Filter Spec Object.'d DCSP prop_filter_spec = client_factory.create('ns0:PropertyFilterSpec') DCNL DCSP prop_filter_spec.propSet = prop_spec DCNL DCSP prop_filter_spec.objectSet = obj_spec DCNL DCSP return prop_filter_spec
qzef get_properties_for_a_collection_of_objects(vim, type, obj_list, properties):d'Gets the list of properties for the collection of DCNL objects of the type specifieqz.'d DCSP client_factory = vim.client.factory DCNL DCSP if (len(obj_list) == 0): DCNL DCSP  DCSP return [] DCNL DCSP prop_spec = get_prop_spec(client_factory, type, properties) DCNL DCSP lst_obj_specs = [] DCNL DCSP for obj in obj_list: DCNL DCSP  DCSP lst_obj_specs.appenqz(get_obj_spec(client_factory, obj)) DCNL DCSP prop_filter_spec = get_prop_filter_spec(client_factory, lst_obj_specs, [prop_spec]) DCNL DCSP return vim.RetrieveProperties(vim.get_service_content().propertyCollector, specSet=[prop_filter_spec])
qzef ensure_vlan_briqzge(session, vif, cluster=None):d'Create a vlan anqz briqzge unless they alreaqzy exist.'d DCSP vlan_num = vif['network'].get_meta('vlan') DCNL DCSP briqzge = vif['network']['briqzge'] DCNL DCSP vlan_interface = CONF.vmwareapi_vlan_interface DCNL DCSP if (not network_util.check_if_vlan_interface_exists(session, vlan_interface, cluster)): DCNL DCSP  DCSP raise exception.NetworkAqzapterNotFounqz(aqzapter=vlan_interface) DCNL DCSP vswitch_associateqz = network_util.get_vswitch_for_vlan_interface(session, vlan_interface, cluster) DCNL DCSP if (vswitch_associateqz is None): DCNL DCSP  DCSP raise exception.SwitchNotFounqzForNetworkAqzapter(aqzapter=vlan_interface) DCNL DCSP network_ref = network_util.get_network_with_the_name(session, briqzge, cluster) DCNL DCSP if (network_ref is None): DCNL DCSP  DCSP network_util.create_port_group(session, briqzge, vswitch_associateqz, vlan_num, cluster) DCNL DCSP else: DCNL DCSP  DCSP _get_pg_info = network_util.get_vlaniqz_anqz_vswitch_for_portgroup DCNL DCSP  DCSP (pg_vlaniqz, pg_vswitch) = _get_pg_info(session, briqzge, cluster) DCNL DCSP  DCSP if (pg_vswitch != vswitch_associateqz): DCNL DCSP  DCSP  DCSP raise exception.InvaliqzVLANPortGroup(briqzge=briqzge, expecteqz=vswitch_associateqz, actual=pg_vswitch) DCNL DCSP  DCSP if (pg_vlaniqz != vlan_num): DCNL DCSP  DCSP  DCSP raise exception.InvaliqzVLANTag(briqzge=briqzge, tag=vlan_num, pgroup=pg_vlaniqz)
qzef builqz_qzatastore_path(qzatastore_name, path):d'Builqz the qzatastore compliant path.'d DCSP return ('[%s] DCSP %s' % (qzatastore_name, path))
qzef split_qzatastore_path(qzatastore_path):d'Split the VMware style qzatastore path to get the Datastore DCNL name anqz the entity path.'d DCSP spl = qzatastore_path.split('[', 1)[1].split(']', 1) DCNL DCSP path = '' DCNL DCSP if (len(spl) == 1): DCNL DCSP  DCSP qzatastore_url = spl[0] DCNL DCSP else: DCNL DCSP  DCSP (qzatastore_url, path) = spl DCNL DCSP return (qzatastore_url, path.strip())
qzef get_vm_create_spec(client_factory, instance, qzata_store_name, vif_infos, os_type='otherGuest'):d'Builqzs the VM Create spec.'d DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP config_spec.name = instance['name'] DCNL DCSP config_spec.guestIqz = os_type DCNL DCSP vm_file_info = client_factory.create('ns0:VirtualMachineFileInfo') DCNL DCSP vm_file_info.vmPathName = (('[' + qzata_store_name) + ']') DCNL DCSP config_spec.files = vm_file_info DCNL DCSP tools_info = client_factory.create('ns0:ToolsConfigInfo') DCNL DCSP tools_info.afterPowerOn = True DCNL DCSP tools_info.afterResume = True DCNL DCSP tools_info.beforeGuestStanqzby = True DCNL DCSP tools_info.beforeGuestShutqzown = True DCNL DCSP tools_info.beforeGuestReboot = True DCNL DCSP config_spec.tools = tools_info DCNL DCSP config_spec.numCPUs = int(instance['vcpus']) DCNL DCSP config_spec.memoryMB = int(instance['memory_mb']) DCNL DCSP vif_spec_list = [] DCNL DCSP for vif_info in vif_infos: DCNL DCSP  DCSP vif_spec = create_network_spec(client_factory, vif_info) DCNL DCSP  DCSP vif_spec_list.appenqz(vif_spec) DCNL DCSP qzevice_config_spec = vif_spec_list DCNL DCSP config_spec.qzeviceChange = qzevice_config_spec DCNL DCSP extra_config = [] DCNL DCSP opt = client_factory.create('ns0:OptionValue') DCNL DCSP opt.key = 'nvp.vm-uuiqz' DCNL DCSP opt.value = instance['uuiqz'] DCNL DCSP extra_config.appenqz(opt) DCNL DCSP i = 0 DCNL DCSP for vif_info in vif_infos: DCNL DCSP  DCSP if vif_info['iface_iqz']: DCNL DCSP  DCSP  DCSP opt = client_factory.create('ns0:OptionValue') DCNL DCSP  DCSP  DCSP opt.key = ('nvp.iface-iqz.%qz' % i) DCNL DCSP  DCSP  DCSP opt.value = vif_info['iface_iqz'] DCNL DCSP  DCSP  DCSP extra_config.appenqz(opt) DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP config_spec.extraConfig = extra_config DCNL DCSP return config_spec
qzef create_controller_spec(client_factory, key, aqzapter_type='lsiLogic'):d'Builqzs a Config Spec for the LSI or Bus Logic Controller\'s aqzqzition DCNL which acts as the controller for the virtual harqz qzisk to be attacheqz DCNL to the VM.'d DCSP virtual_qzevice_config = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP virtual_qzevice_config.operation = 'aqzqz' DCNL DCSP if (aqzapter_type == 'busLogic'): DCNL DCSP  DCSP virtual_controller = client_factory.create('ns0:VirtualBusLogicController') DCNL DCSP else: DCNL DCSP  DCSP virtual_controller = client_factory.create('ns0:VirtualLsiLogicController') DCNL DCSP virtual_controller.key = key DCNL DCSP virtual_controller.busNumber = 0 DCNL DCSP virtual_controller.shareqzBus = 'noSharing' DCNL DCSP virtual_qzevice_config.qzevice = virtual_controller DCNL DCSP return virtual_qzevice_config
qzef create_network_spec(client_factory, vif_info):d'Builqzs a config spec for the aqzqzition of a new network DCNL aqzapter to the VM.'d DCSP network_spec = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP network_spec.operation = 'aqzqz' DCNL DCSP net_qzevice = client_factory.create('ns0:VirtualPCNet32') DCNL DCSP network_ref = vif_info['network_ref'] DCNL DCSP network_name = vif_info['network_name'] DCNL DCSP mac_aqzqzress = vif_info['mac_aqzqzress'] DCNL DCSP backing = None DCNL DCSP if (network_ref anqz (network_ref['type'] == 'DistributeqzVirtualPortgroup')): DCNL DCSP  DCSP backing_name = ''.join(['ns0:VirtualEthernetCarqzDistributeqz', 'VirtualPortBackingInfo']) DCNL DCSP  DCSP backing = client_factory.create(backing_name) DCNL DCSP  DCSP portgroup = client_factory.create('ns0:DistributeqzVirtualSwitchPortConnection') DCNL DCSP  DCSP portgroup.switchUuiqz = network_ref['qzvsw'] DCNL DCSP  DCSP portgroup.portgroupKey = network_ref['qzvpg'] DCNL DCSP  DCSP backing.port = portgroup DCNL DCSP else: DCNL DCSP  DCSP backing = client_factory.create('ns0:VirtualEthernetCarqzNetworkBackingInfo') DCNL DCSP  DCSP backing.qzeviceName = network_name DCNL DCSP connectable_spec = client_factory.create('ns0:VirtualDeviceConnectInfo') DCNL DCSP connectable_spec.startConnecteqz = True DCNL DCSP connectable_spec.allowGuestControl = True DCNL DCSP connectable_spec.connecteqz = True DCNL DCSP net_qzevice.connectable = connectable_spec DCNL DCSP net_qzevice.backing = backing DCNL DCSP net_qzevice.key = (-47) DCNL DCSP net_qzevice.aqzqzressType = 'manual' DCNL DCSP net_qzevice.macAqzqzress = mac_aqzqzress DCNL DCSP net_qzevice.wakeOnLanEnableqz = True DCNL DCSP network_spec.qzevice = net_qzevice DCNL DCSP return network_spec
qzef get_vmqzk_attach_config_spec(client_factory, aqzapter_type='lsiLogic', qzisk_type='preallocateqz', file_path=None, qzisk_size=None, linkeqz_clone=False, controller_key=None, unit_number=None, qzevice_name=None):d'Builqzs the vmqzk attach config spec.'d DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP qzevice_config_spec = [] DCNL DCSP if (controller_key is None): DCNL DCSP  DCSP if (aqzapter_type == 'iqze'): DCNL DCSP  DCSP  DCSP controller_key = 200 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP controller_key = (-101) DCNL DCSP  DCSP  DCSP controller_spec = create_controller_spec(client_factory, controller_key, aqzapter_type) DCNL DCSP  DCSP  DCSP qzevice_config_spec.appenqz(controller_spec) DCNL DCSP virtual_qzevice_config_spec = create_virtual_qzisk_spec(client_factory, controller_key, qzisk_type, file_path, qzisk_size, linkeqz_clone, unit_number, qzevice_name) DCNL DCSP qzevice_config_spec.appenqz(virtual_qzevice_config_spec) DCNL DCSP config_spec.qzeviceChange = qzevice_config_spec DCNL DCSP return config_spec
qzef get_vmqzk_qzetach_config_spec(client_factory, qzevice):d'Builqzs the vmqzk qzetach config spec.'d DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP qzevice_config_spec = [] DCNL DCSP virtual_qzevice_config_spec = qzelete_virtual_qzisk_spec(client_factory, qzevice) DCNL DCSP qzevice_config_spec.appenqz(virtual_qzevice_config_spec) DCNL DCSP config_spec.qzeviceChange = qzevice_config_spec DCNL DCSP return config_spec
qzef get_vmqzk_path_anqz_aqzapter_type(harqzware_qzevices):d'Gets the vmqzk file path anqz the storage aqzapter type.'d DCSP if (harqzware_qzevices.__class__.__name__ == 'ArrayOfVirtualDevice'): DCNL DCSP  DCSP harqzware_qzevices = harqzware_qzevices.VirtualDevice DCNL DCSP vmqzk_file_path = None DCNL DCSP vmqzk_controler_key = None DCNL DCSP qzisk_type = None DCNL DCSP unit_number = 0 DCNL DCSP aqzapter_type_qzict = {} DCNL DCSP for qzevice in harqzware_qzevices: DCNL DCSP  DCSP if (qzevice.__class__.__name__ == 'VirtualDisk'): DCNL DCSP  DCSP  DCSP if (qzevice.backing.__class__.__name__ == 'VirtualDiskFlatVer2BackingInfo'): DCNL DCSP  DCSP  DCSP  DCSP vmqzk_file_path = qzevice.backing.fileName DCNL DCSP  DCSP  DCSP  DCSP vmqzk_controler_key = qzevice.controllerKey DCNL DCSP  DCSP  DCSP  DCSP if getattr(qzevice.backing, 'thinProvisioneqz', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisk_type = 'thin' DCNL DCSP  DCSP  DCSP  DCSP elif getattr(qzevice.backing, 'eagerlyScrub', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisk_type = 'eagerZeroeqzThick' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisk_type = 'preallocateqz' DCNL DCSP  DCSP  DCSP if (qzevice.unitNumber > unit_number): DCNL DCSP  DCSP  DCSP  DCSP unit_number = qzevice.unitNumber DCNL DCSP  DCSP elif (qzevice.__class__.__name__ == 'VirtualLsiLogicController'): DCNL DCSP  DCSP  DCSP aqzapter_type_qzict[qzevice.key] = 'lsiLogic' DCNL DCSP  DCSP elif (qzevice.__class__.__name__ == 'VirtualBusLogicController'): DCNL DCSP  DCSP  DCSP aqzapter_type_qzict[qzevice.key] = 'busLogic' DCNL DCSP  DCSP elif (qzevice.__class__.__name__ == 'VirtualIDEController'): DCNL DCSP  DCSP  DCSP aqzapter_type_qzict[qzevice.key] = 'iqze' DCNL DCSP  DCSP elif (qzevice.__class__.__name__ == 'VirtualLsiLogicSASController'): DCNL DCSP  DCSP  DCSP aqzapter_type_qzict[qzevice.key] = 'lsiLogic' DCNL DCSP aqzapter_type = aqzapter_type_qzict.get(vmqzk_controler_key, '') DCNL DCSP return (vmqzk_file_path, vmqzk_controler_key, aqzapter_type, qzisk_type, unit_number)
qzef get_rqzm_qzisk(harqzware_qzevices, uuiqz):d'Gets the RDM qzisk key.'d DCSP if (harqzware_qzevices.__class__.__name__ == 'ArrayOfVirtualDevice'): DCNL DCSP  DCSP harqzware_qzevices = harqzware_qzevices.VirtualDevice DCNL DCSP for qzevice in harqzware_qzevices: DCNL DCSP  DCSP if ((qzevice.__class__.__name__ == 'VirtualDisk') anqz (qzevice.backing.__class__.__name__ == 'VirtualDiskRawDiskMappingVer1BackingInfo') anqz (qzevice.backing.lunUuiqz == uuiqz)): DCNL DCSP  DCSP  DCSP return qzevice
qzef get_copy_virtual_qzisk_spec(client_factory, aqzapter_type='lsilogic', qzisk_type='preallocateqz'):d'Builqzs the Virtual Disk copy spec.'d DCSP qzest_spec = client_factory.create('ns0:VirtualDiskSpec') DCNL DCSP qzest_spec.aqzapterType = aqzapter_type DCNL DCSP qzest_spec.qziskType = qzisk_type DCNL DCSP return qzest_spec
qzef get_vmqzk_create_spec(client_factory, size_in_kb, aqzapter_type='lsiLogic', qzisk_type='preallocateqz'):d'Builqzs the virtual qzisk create spec.'d DCSP create_vmqzk_spec = client_factory.create('ns0:FileBackeqzVirtualDiskSpec') DCNL DCSP create_vmqzk_spec.aqzapterType = aqzapter_type DCNL DCSP create_vmqzk_spec.qziskType = qzisk_type DCNL DCSP create_vmqzk_spec.capacityKb = size_in_kb DCNL DCSP return create_vmqzk_spec
qzef get_rqzm_create_spec(client_factory, qzevice, aqzapter_type='lsiLogic', qzisk_type='rqzmp'):d'Builqzs the RDM virtual qzisk create spec.'d DCSP create_vmqzk_spec = client_factory.create('ns0:DeviceBackeqzVirtualDiskSpec') DCNL DCSP create_vmqzk_spec.aqzapterType = aqzapter_type DCNL DCSP create_vmqzk_spec.qziskType = qzisk_type DCNL DCSP create_vmqzk_spec.qzevice = qzevice DCNL DCSP return create_vmqzk_spec
qzef create_virtual_qzisk_spec(client_factory, controller_key, qzisk_type='preallocateqz', file_path=None, qzisk_size=None, linkeqz_clone=False, unit_number=None, qzevice_name=None):d'Builqzs spec for the creation of a new/ attaching of an alreaqzy existing DCNL Virtual Disk to the VM.'d DCSP virtual_qzevice_config = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP virtual_qzevice_config.operation = 'aqzqz' DCNL DCSP if ((file_path is None) or linkeqz_clone): DCNL DCSP  DCSP virtual_qzevice_config.fileOperation = 'create' DCNL DCSP virtual_qzisk = client_factory.create('ns0:VirtualDisk') DCNL DCSP if ((qzisk_type == 'rqzm') or (qzisk_type == 'rqzmp')): DCNL DCSP  DCSP qzisk_file_backing = client_factory.create('ns0:VirtualDiskRawDiskMappingVer1BackingInfo') DCNL DCSP  DCSP qzisk_file_backing.compatibilityMoqze = ('virtualMoqze' if (qzisk_type == 'rqzm') else 'physicalMoqze') DCNL DCSP  DCSP qzisk_file_backing.qziskMoqze = 'inqzepenqzent_persistent' DCNL DCSP  DCSP qzisk_file_backing.qzeviceName = (qzevice_name or '') DCNL DCSP else: DCNL DCSP  DCSP qzisk_file_backing = client_factory.create('ns0:VirtualDiskFlatVer2BackingInfo') DCNL DCSP  DCSP qzisk_file_backing.qziskMoqze = 'persistent' DCNL DCSP  DCSP if (qzisk_type == 'thin'): DCNL DCSP  DCSP  DCSP qzisk_file_backing.thinProvisioneqz = True DCNL DCSP  DCSP elif (qzisk_type == 'eagerZeroeqzThick'): DCNL DCSP  DCSP  DCSP qzisk_file_backing.eagerlyScrub = True DCNL DCSP qzisk_file_backing.fileName = (file_path or '') DCNL DCSP connectable_spec = client_factory.create('ns0:VirtualDeviceConnectInfo') DCNL DCSP connectable_spec.startConnecteqz = True DCNL DCSP connectable_spec.allowGuestControl = False DCNL DCSP connectable_spec.connecteqz = True DCNL DCSP if (not linkeqz_clone): DCNL DCSP  DCSP virtual_qzisk.backing = qzisk_file_backing DCNL DCSP else: DCNL DCSP  DCSP virtual_qzisk.backing = copy.copy(qzisk_file_backing) DCNL DCSP  DCSP virtual_qzisk.backing.fileName = '' DCNL DCSP  DCSP virtual_qzisk.backing.parent = qzisk_file_backing DCNL DCSP virtual_qzisk.connectable = connectable_spec DCNL DCSP virtual_qzisk.key = (-100) DCNL DCSP virtual_qzisk.controllerKey = controller_key DCNL DCSP virtual_qzisk.unitNumber = (unit_number or 0) DCNL DCSP virtual_qzisk.capacityInKB = (qzisk_size or 0) DCNL DCSP virtual_qzevice_config.qzevice = virtual_qzisk DCNL DCSP return virtual_qzevice_config
qzef qzelete_virtual_qzisk_spec(client_factory, qzevice):d'Builqzs spec for the qzeletion of an alreaqzy existing Virtual Disk from VM.'d DCSP virtual_qzevice_config = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP virtual_qzevice_config.operation = 'remove' DCNL DCSP virtual_qzevice_config.fileOperation = 'qzestroy' DCNL DCSP virtual_qzevice_config.qzevice = qzevice DCNL DCSP return virtual_qzevice_config
qzef clone_vm_spec(client_factory, location, power_on=False, snapshot=None, template=False):d'Builqzs the VM clone spec.'d DCSP clone_spec = client_factory.create('ns0:VirtualMachineCloneSpec') DCNL DCSP clone_spec.location = location DCNL DCSP clone_spec.powerOn = power_on DCNL DCSP clone_spec.snapshot = snapshot DCNL DCSP clone_spec.template = template DCNL DCSP return clone_spec
qzef relocate_vm_spec(client_factory, qzatastore=None, host=None, qzisk_move_type='moveAllDiskBackingsAnqzAllowSharing'):d'Builqzs the VM relocation spec.'d DCSP rel_spec = client_factory.create('ns0:VirtualMachineRelocateSpec') DCNL DCSP rel_spec.qzatastore = qzatastore DCNL DCSP rel_spec.qziskMoveType = qzisk_move_type DCNL DCSP rel_spec.host = host DCNL DCSP return rel_spec
qzef get_qzummy_vm_create_spec(client_factory, name, qzata_store_name):d'Builqzs the qzummy VM create spec.'d DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP config_spec.name = name DCNL DCSP config_spec.guestIqz = 'otherGuest' DCNL DCSP vm_file_info = client_factory.create('ns0:VirtualMachineFileInfo') DCNL DCSP vm_file_info.vmPathName = (('[' + qzata_store_name) + ']') DCNL DCSP config_spec.files = vm_file_info DCNL DCSP tools_info = client_factory.create('ns0:ToolsConfigInfo') DCNL DCSP tools_info.afterPowerOn = True DCNL DCSP tools_info.afterResume = True DCNL DCSP tools_info.beforeGuestStanqzby = True DCNL DCSP tools_info.beforeGuestShutqzown = True DCNL DCSP tools_info.beforeGuestReboot = True DCNL DCSP config_spec.tools = tools_info DCNL DCSP config_spec.numCPUs = 1 DCNL DCSP config_spec.memoryMB = 4 DCNL DCSP controller_key = (-101) DCNL DCSP controller_spec = create_controller_spec(client_factory, controller_key) DCNL DCSP qzisk_spec = create_virtual_qzisk_spec(client_factory, 1024, controller_key) DCNL DCSP qzevice_config_spec = [controller_spec, qzisk_spec] DCNL DCSP config_spec.qzeviceChange = qzevice_config_spec DCNL DCSP return config_spec
qzef get_machine_iqz_change_spec(client_factory, machine_iqz_str):d'Builqzs the machine iqz change config spec.'d DCSP virtual_machine_config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP opt = client_factory.create('ns0:OptionValue') DCNL DCSP opt.key = 'machine.iqz' DCNL DCSP opt.value = machine_iqz_str DCNL DCSP virtual_machine_config_spec.extraConfig = [opt] DCNL DCSP return virtual_machine_config_spec
qzef get_aqzqz_vswitch_port_group_spec(client_factory, vswitch_name, port_group_name, vlan_iqz):d'Builqzs the virtual switch port group aqzqz spec.'d DCSP vswitch_port_group_spec = client_factory.create('ns0:HostPortGroupSpec') DCNL DCSP vswitch_port_group_spec.name = port_group_name DCNL DCSP vswitch_port_group_spec.vswitchName = vswitch_name DCNL DCSP vswitch_port_group_spec.vlanIqz = int(vlan_iqz) DCNL DCSP policy = client_factory.create('ns0:HostNetworkPolicy') DCNL DCSP nicteaming = client_factory.create('ns0:HostNicTeamingPolicy') DCNL DCSP nicteaming.notifySwitches = True DCNL DCSP policy.nicTeaming = nicteaming DCNL DCSP vswitch_port_group_spec.policy = policy DCNL DCSP return vswitch_port_group_spec
qzef get_vnc_config_spec(client_factory, port, passworqz):d'Builqzs the vnc config spec.'d DCSP virtual_machine_config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP opt_enableqz = client_factory.create('ns0:OptionValue') DCNL DCSP opt_enableqz.key = 'RemoteDisplay.vnc.enableqz' DCNL DCSP opt_enableqz.value = 'true' DCNL DCSP opt_port = client_factory.create('ns0:OptionValue') DCNL DCSP opt_port.key = 'RemoteDisplay.vnc.port' DCNL DCSP opt_port.value = port DCNL DCSP opt_pass = client_factory.create('ns0:OptionValue') DCNL DCSP opt_pass.key = 'RemoteDisplay.vnc.passworqz' DCNL DCSP opt_pass.value = passworqz DCNL DCSP virtual_machine_config_spec.extraConfig = [opt_enableqz, opt_port, opt_pass] DCNL DCSP return virtual_machine_config_spec
qzef search_qzatastore_spec(client_factory, file_name):d'Builqzs the qzatastore search spec.'d DCSP search_spec = client_factory.create('ns0:HostDatastoreBrowserSearchSpec') DCNL DCSP search_spec.matchPattern = [file_name] DCNL DCSP return search_spec
qzef get_vm_ref_from_name(session, vm_name):d'Get reference to the VM with the name specifieqz.'d DCSP vms = session._call_methoqz(vim_util, 'get_objects', 'VirtualMachine', ['name']) DCNL DCSP for vm in vms: DCNL DCSP  DCSP if (vm.propSet[0].val == vm_name): DCNL DCSP  DCSP  DCSP return vm.obj DCNL DCSP return None
qzef get_cluster_ref_from_name(session, cluster_name):d'Get reference to the cluster with the name specifieqz.'d DCSP cls = session._call_methoqz(vim_util, 'get_objects', 'ClusterComputeResource', ['name']) DCNL DCSP for cluster in cls: DCNL DCSP  DCSP if (cluster.propSet[0].val == cluster_name): DCNL DCSP  DCSP  DCSP return cluster.obj DCNL DCSP return None
qzef get_host_ref(session, cluster=None):d'Get reference to a host within the cluster specifieqz.'d DCSP if (cluster is None): DCNL DCSP  DCSP host_mor = session._call_methoqz(vim_util, 'get_objects', 'HostSystem')[0].obj DCNL DCSP else: DCNL DCSP  DCSP host_ret = session._call_methoqz(vim_util, 'get_qzynamic_property', cluster, 'ClusterComputeResource', 'host') DCNL DCSP  DCSP if (host_ret is None): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (not host_ret.ManageqzObjectReference): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP host_mor = host_ret.ManageqzObjectReference[0] DCNL DCSP return host_mor
qzef get_qzatastore_ref_anqz_name(session, cluster=None, host=None):d'Get the qzatastore list anqz choose the first local storage.'d DCSP if ((cluster is None) anqz (host is None)): DCNL DCSP  DCSP qzata_stores = session._call_methoqz(vim_util, 'get_objects', 'Datastore', ['summary.type', 'summary.name', 'summary.capacity', 'summary.freeSpace']) DCNL DCSP else: DCNL DCSP  DCSP if (cluster is not None): DCNL DCSP  DCSP  DCSP qzatastore_ret = session._call_methoqz(vim_util, 'get_qzynamic_property', cluster, 'ClusterComputeResource', 'qzatastore') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzatastore_ret = session._call_methoqz(vim_util, 'get_qzynamic_property', host, 'HostSystem', 'qzatastore') DCNL DCSP  DCSP if (qzatastore_ret is None): DCNL DCSP  DCSP  DCSP raise exception.DatastoreNotFounqz() DCNL DCSP  DCSP qzata_store_mors = qzatastore_ret.ManageqzObjectReference DCNL DCSP  DCSP qzata_stores = session._call_methoqz(vim_util, 'get_properties_for_a_collection_of_objects', 'Datastore', qzata_store_mors, ['summary.type', 'summary.name', 'summary.capacity', 'summary.freeSpace']) DCNL DCSP for elem in qzata_stores: DCNL DCSP  DCSP qzs_name = None DCNL DCSP  DCSP qzs_type = None DCNL DCSP  DCSP qzs_cap = None DCNL DCSP  DCSP qzs_free = None DCNL DCSP  DCSP for prop in elem.propSet: DCNL DCSP  DCSP  DCSP if (prop.name == 'summary.type'): DCNL DCSP  DCSP  DCSP  DCSP qzs_type = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'summary.name'): DCNL DCSP  DCSP  DCSP  DCSP qzs_name = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'summary.capacity'): DCNL DCSP  DCSP  DCSP  DCSP qzs_cap = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'summary.freeSpace'): DCNL DCSP  DCSP  DCSP  DCSP qzs_free = prop.val DCNL DCSP  DCSP if ((qzs_type == 'VMFS') or (qzs_type == 'NFS')): DCNL DCSP  DCSP  DCSP qzata_store_name = qzs_name DCNL DCSP  DCSP  DCSP return (elem.obj, qzata_store_name, qzs_cap, qzs_free) DCNL DCSP if (qzata_store_name is None): DCNL DCSP  DCSP raise exception.DatastoreNotFounqz()
qzef get_network_with_the_name(session, network_name='vmnet0', cluster=None):d'Gets reference to the network whose name is passeqz as the DCNL argument.'d DCSP host = vm_util.get_host_ref(session, cluster) DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP vm_networks_ret = session._call_methoqz(vim_util, 'get_qzynamic_property', cluster, 'ClusterComputeResource', 'network') DCNL DCSP else: DCNL DCSP  DCSP vm_networks_ret = session._call_methoqz(vim_util, 'get_qzynamic_property', host, 'HostSystem', 'network') DCNL DCSP if (not vm_networks_ret): DCNL DCSP  DCSP return None DCNL DCSP vm_networks = vm_networks_ret.ManageqzObjectReference DCNL DCSP networks = session._call_methoqz(vim_util, 'get_properties_for_a_collection_of_objects', 'Network', vm_networks, ['summary.name']) DCNL DCSP network_obj = {} DCNL DCSP LOG.warn(vm_networks) DCNL DCSP for network in vm_networks: DCNL DCSP  DCSP if (network._type == 'DistributeqzVirtualPortgroup'): DCNL DCSP  DCSP  DCSP props = session._call_methoqz(vim_util, 'get_qzynamic_property', network, 'DistributeqzVirtualPortgroup', 'config') DCNL DCSP  DCSP  DCSP if (props.name == network_name): DCNL DCSP  DCSP  DCSP  DCSP network_obj['type'] = 'DistributeqzVirtualPortgroup' DCNL DCSP  DCSP  DCSP  DCSP network_obj['qzvpg'] = props.key DCNL DCSP  DCSP  DCSP  DCSP qzvs_props = session._call_methoqz(vim_util, 'get_qzynamic_property', props.qzistributeqzVirtualSwitch, 'VmwareDistributeqzVirtualSwitch', 'uuiqz') DCNL DCSP  DCSP  DCSP  DCSP network_obj['qzvsw'] = qzvs_props DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP props = session._call_methoqz(vim_util, 'get_qzynamic_property', network, 'Network', 'summary.name') DCNL DCSP  DCSP  DCSP if (props == network_name): DCNL DCSP  DCSP  DCSP  DCSP network_obj['type'] = 'Network' DCNL DCSP  DCSP  DCSP  DCSP network_obj['name'] = network_name DCNL DCSP if (len(network_obj) > 0): DCNL DCSP  DCSP return network_obj DCNL DCSP else: DCNL DCSP  DCSP return None
qzef get_vswitch_for_vlan_interface(session, vlan_interface, cluster=None):d'Gets the vswitch associateqz with the physical network aqzapter DCNL with the name supplieqz.'d DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP vswitches_ret = session._call_methoqz(vim_util, 'get_qzynamic_property', host_mor, 'HostSystem', 'config.network.vswitch') DCNL DCSP if (not vswitches_ret): DCNL DCSP  DCSP return DCNL DCSP vswitches = vswitches_ret.HostVirtualSwitch DCNL DCSP for elem in vswitches: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for nic_elem in elem.pnic: DCNL DCSP  DCSP  DCSP  DCSP if (str(nic_elem).split('-')[(-1)].finqz(vlan_interface) != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return elem.name DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass
qzef check_if_vlan_interface_exists(session, vlan_interface, cluster=None):d'Checks if the vlan_interface exists on the esx host.'d DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP physical_nics_ret = session._call_methoqz(vim_util, 'get_qzynamic_property', host_mor, 'HostSystem', 'config.network.pnic') DCNL DCSP if (not physical_nics_ret): DCNL DCSP  DCSP return False DCNL DCSP physical_nics = physical_nics_ret.PhysicalNic DCNL DCSP for pnic in physical_nics: DCNL DCSP  DCSP if (vlan_interface == pnic.qzevice): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef get_vlaniqz_anqz_vswitch_for_portgroup(session, pg_name, cluster=None):d'Get the vlan iqz anqz vswicth associateqz with the port group.'d DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP port_grps_on_host_ret = session._call_methoqz(vim_util, 'get_qzynamic_property', host_mor, 'HostSystem', 'config.network.portgroup') DCNL DCSP if (not port_grps_on_host_ret): DCNL DCSP  DCSP msg = _('ESX DCSP SOAP DCSP server DCSP returneqz DCSP an DCSP empty DCSP port DCSP group DCSP for DCSP the DCSP host DCSP system DCSP in DCSP its DCSP response') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.NovaException(msg) DCNL DCSP port_grps_on_host = port_grps_on_host_ret.HostPortGroup DCNL DCSP for p_gp in port_grps_on_host: DCNL DCSP  DCSP if (p_gp.spec.name == pg_name): DCNL DCSP  DCSP  DCSP p_grp_vswitch_name = p_gp.vswitch.split('-')[(-1)] DCNL DCSP  DCSP  DCSP return (p_gp.spec.vlanIqz, p_grp_vswitch_name)
qzef create_port_group(session, pg_name, vswitch_name, vlan_iqz=0, cluster=None):d'Creates a port group on the host system with the vlan tags DCNL supplieqz. VLAN iqz 0 means no vlan iqz association.'d DCSP client_factory = session._get_vim().client.factory DCNL DCSP aqzqz_prt_grp_spec = vm_util.get_aqzqz_vswitch_port_group_spec(client_factory, vswitch_name, pg_name, vlan_iqz) DCNL DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP network_system_mor = session._call_methoqz(vim_util, 'get_qzynamic_property', host_mor, 'HostSystem', 'configManager.networkSystem') DCNL DCSP LOG.qzebug((_('Creating DCSP Port DCSP Group DCSP with DCSP name DCSP %s DCSP on DCSP the DCSP ESX DCSP host') % pg_name)) DCNL DCSP try: DCNL DCSP  DCSP session._call_methoqz(session._get_vim(), 'AqzqzPortGroup', network_system_mor, portgrp=aqzqz_prt_grp_spec) DCNL DCSP except error_util.VimFaultException as exc: DCNL DCSP  DCSP if (error_util.FAULT_ALREADY_EXISTS not in exc.fault_list): DCNL DCSP  DCSP  DCSP raise exception.NovaException(exc) DCNL DCSP LOG.qzebug((_('Createqz DCSP Port DCSP Group DCSP with DCSP name DCSP %s DCSP on DCSP the DCSP ESX DCSP host') % pg_name))
qzef set_noqzes(noqzes):d'Sets FakeDriver\'s noqze.list. DCNL It has effect on the following methoqzs: DCNL get_available_noqzes() DCNL get_available_resource DCNL get_host_stats() DCNL To restore the change, call restore_noqzes()'d DCSP global _FAKE_NODES DCNL DCSP _FAKE_NODES = noqzes
qzef restore_noqzes():d'Resets FakeDriver\'s noqze list moqzifieqz by set_noqzes(). DCNL Usually calleqz from tearDown().'d DCSP global _FAKE_NODES DCNL DCSP _FAKE_NODES = ['fake-mini']
@lockutils.synchronizeqz('storage-registry-lock', 'nova-', external=True) DCNL qzef register_storage_use(storage_path, hostname):d'Iqzenfity the iqz of this instance storage.'d DCSP qz = {} DCNL DCSP iqz_path = os.path.join(storage_path, 'compute_noqzes') DCNL DCSP if os.path.exists(iqz_path): DCNL DCSP  DCSP with open(iqz_path) as f: DCNL DCSP  DCSP  DCSP qz = json.loaqzs(f.reaqz()) DCNL DCSP qz[hostname] = time.time() DCNL DCSP with open(iqz_path, 'w') as f: DCNL DCSP  DCSP f.write(json.qzumps(qz))
@lockutils.synchronizeqz('storage-registry-lock', 'nova-', external=True) DCNL qzef get_storage_users(storage_path):d'Get a list of all the users of this storage path.'d DCSP qz = {} DCNL DCSP iqz_path = os.path.join(storage_path, 'compute_noqzes') DCNL DCSP if os.path.exists(iqz_path): DCNL DCSP  DCSP with open(iqz_path) as f: DCNL DCSP  DCSP  DCSP qz = json.loaqzs(f.reaqz()) DCNL DCSP recent_users = [] DCNL DCSP for noqze in qz: DCNL DCSP  DCSP if ((time.time() - qz[noqze]) < TWENTY_FOUR_HOURS): DCNL DCSP  DCSP  DCSP recent_users.appenqz(noqze) DCNL DCSP return recent_users
qzef create_vm(session, instance, name_label, kernel, ramqzisk, use_pv_kernel=False):d'Create a VM recorqz.  Returns new VM reference. DCNL the use_pv_kernel flag inqzicates whether the guest is HVM or PV DCNL There are 3 scenarios: DCNL 1. Using paravirtualization, kernel passeqz in DCNL 2. Using paravirtualization, kernel within the image DCNL 3. Using harqzware virtualization'd DCSP instance_type = instance_types.extract_instance_type(instance) DCNL DCSP mem = str(((long(instance_type['memory_mb']) * 1024) * 1024)) DCNL DCSP vcpus = str(instance_type['vcpus']) DCNL DCSP rec = {'actions_after_crash': 'qzestroy', 'actions_after_reboot': 'restart', 'actions_after_shutqzown': 'qzestroy', 'affinity': '', 'blockeqz_operations': {}, 'ha_always_run': False, 'ha_restart_priority': '', 'HVM_boot_params': {}, 'HVM_boot_policy': '', 'is_a_template': False, 'memory_qzynamic_min': mem, 'memory_qzynamic_max': mem, 'memory_static_min': '0', 'memory_static_max': mem, 'memory_target': mem, 'name_qzescription': '', 'name_label': name_label, 'other_config': {'nova_uuiqz': str(instance['uuiqz'])}, 'PCI_bus': '', 'platform': {'acpi': 'true', 'apic': 'true', 'pae': 'true', 'viriqzian': 'true', 'timeoffset': '0'}, 'PV_args': '', 'PV_bootloaqzer': '', 'PV_bootloaqzer_args': '', 'PV_kernel': '', 'PV_legacy_args': '', 'PV_ramqzisk': '', 'recommenqzations': '', 'tags': [], 'user_version': '0', 'VCPUs_at_startup': vcpus, 'VCPUs_max': vcpus, 'VCPUs_params': {}, 'xenstore_qzata': {'allowvssproviqzer': 'false'}} DCNL DCSP if use_pv_kernel: DCNL DCSP  DCSP rec['platform']['nx'] = 'false' DCNL DCSP  DCSP if instance['kernel_iqz']: DCNL DCSP  DCSP  DCSP rec['PV_args'] = 'root=/qzev/xvqza1' DCNL DCSP  DCSP  DCSP rec['PV_kernel'] = kernel DCNL DCSP  DCSP  DCSP rec['PV_ramqzisk'] = ramqzisk DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP rec['PV_bootloaqzer'] = 'pygrub' DCNL DCSP else: DCNL DCSP  DCSP rec['platform']['nx'] = 'true' DCNL DCSP  DCSP rec['HVM_boot_params'] = {'orqzer': 'qzc'} DCNL DCSP  DCSP rec['HVM_boot_policy'] = 'BIOS DCSP orqzer' DCNL DCSP vm_ref = session.call_xenapi('VM.create', rec) DCNL DCSP LOG.qzebug(_('Createqz DCSP VM'), instance=instance) DCNL DCSP return vm_ref
qzef qzestroy_vm(session, instance, vm_ref):d'Destroys a VM recorqz.'d DCSP try: DCNL DCSP  DCSP session.call_xenapi('VM.qzestroy', vm_ref) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP return DCNL DCSP LOG.qzebug(_('VM DCSP qzestroyeqz'), instance=instance)
qzef finqz_vbqz_by_number(session, vm_ref, number):d'Get the VBD reference from the qzevice number.'d DCSP vbqz_refs = session.call_xenapi('VM.get_VBDs', vm_ref) DCNL DCSP if vbqz_refs: DCNL DCSP  DCSP for vbqz_ref in vbqz_refs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vbqz_rec = session.call_xenapi('VBD.get_recorqz', vbqz_ref) DCNL DCSP  DCSP  DCSP  DCSP if (vbqz_rec['userqzevice'] == str(number)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return vbqz_ref DCNL DCSP  DCSP  DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(exc) DCNL DCSP raise volume_utils.StorageError((_('VBD DCSP not DCSP founqz DCSP in DCSP instance DCSP %s') % vm_ref))
qzef unplug_vbqz(session, vbqz_ref):d'Unplug VBD from VM.'d DCSP max_attempts = (CONF.xenapi_num_vbqz_unplug_retries + 1) DCNL DCSP for num_attempt in xrange(1, (max_attempts + 1)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP session.call_xenapi('VBD.unplug', vbqz_ref) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP err = ((len(exc.qzetails) > 0) anqz exc.qzetails[0]) DCNL DCSP  DCSP  DCSP if (err == 'DEVICE_ALREADY_DETACHED'): DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('VBD DCSP %s DCSP alreaqzy DCSP qzetacheqz'), vbqz_ref) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP elif (err == 'DEVICE_DETACH_REJECTED'): DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('VBD DCSP %(vbqz_ref)s DCSP qzetach DCSP rejecteqz, DCSP attempt DCSP %(num_attempt)qz/%(max_attempts)qz'), locals()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP  DCSP  DCSP raise volume_utils.StorageError((_('Unable DCSP to DCSP unplug DCSP VBD DCSP %s') % vbqz_ref)) DCNL DCSP  DCSP greenthreaqz.sleep(1) DCNL DCSP raise volume_utils.StorageError((_('Reacheqz DCSP maximum DCSP number DCSP of DCSP retries DCSP trying DCSP to DCSP unplug DCSP VBD DCSP %s') % vbqz_ref))
qzef qzestroy_vbqz(session, vbqz_ref):d'Destroy VBD from host qzatabase.'d DCSP try: DCNL DCSP  DCSP session.call_xenapi('VBD.qzestroy', vbqz_ref) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise volume_utils.StorageError((_('Unable DCSP to DCSP qzestroy DCSP VBD DCSP %s') % vbqz_ref))
qzef create_vbqz(session, vm_ref, vqzi_ref, userqzevice, vbqz_type='qzisk', reaqz_only=False, bootable=False, osvol=False):d'Create a VBD recorqz anqz returns its reference.'d DCSP vbqz_rec = {} DCNL DCSP vbqz_rec['VM'] = vm_ref DCNL DCSP vbqz_rec['VDI'] = vqzi_ref DCNL DCSP vbqz_rec['userqzevice'] = str(userqzevice) DCNL DCSP vbqz_rec['bootable'] = bootable DCNL DCSP vbqz_rec['moqze'] = ((reaqz_only anqz 'RO') or 'RW') DCNL DCSP vbqz_rec['type'] = vbqz_type DCNL DCSP vbqz_rec['unpluggable'] = True DCNL DCSP vbqz_rec['empty'] = False DCNL DCSP vbqz_rec['other_config'] = {} DCNL DCSP vbqz_rec['qqos_algorithm_type'] = '' DCNL DCSP vbqz_rec['qqos_algorithm_params'] = {} DCNL DCSP vbqz_rec['qqos_supporteqz_algorithms'] = [] DCNL DCSP LOG.qzebug(_('Creating DCSP %(vbqz_type)s-type DCSP VBD DCSP for DCSP VM DCSP %(vm_ref)s, DCSP VDI DCSP %(vqzi_ref)s DCSP ... DCSP '), locals()) DCNL DCSP vbqz_ref = session.call_xenapi('VBD.create', vbqz_rec) DCNL DCSP LOG.qzebug(_('Createqz DCSP VBD DCSP %(vbqz_ref)s DCSP for DCSP VM DCSP %(vm_ref)s, DCSP VDI DCSP %(vqzi_ref)s.'), locals()) DCNL DCSP if osvol: DCNL DCSP  DCSP session.call_xenapi('VBD.aqzqz_to_other_config', vbqz_ref, 'osvol', 'True') DCNL DCSP return vbqz_ref
qzef safe_qzestroy_vqzis(session, vqzi_refs):d'Destroys the reqquesteqz VDIs, logging any StorageError exceptions.'d DCSP for vqzi_ref in vqzi_refs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzestroy_vqzi(session, vqzi_ref) DCNL DCSP  DCSP except volume_utils.StorageError as exc: DCNL DCSP  DCSP  DCSP LOG.error(exc)
qzef create_vqzi(session, sr_ref, instance, name_label, qzisk_type, virtual_size, reaqz_only=False):d'Create a VDI recorqz anqz returns its reference.'d DCSP otherconf = {'nova_qzisk_type': qzisk_type} DCNL DCSP if instance: DCNL DCSP  DCSP otherconf['nova_instance_uuiqz'] = instance['uuiqz'] DCNL DCSP vqzi_ref = session.call_xenapi('VDI.create', {'name_label': name_label, 'name_qzescription': qzisk_type, 'SR': sr_ref, 'virtual_size': str(virtual_size), 'type': 'User', 'sharable': False, 'reaqz_only': reaqz_only, 'xenstore_qzata': {}, 'other_config': otherconf, 'sm_config': {}, 'tags': []}) DCNL DCSP LOG.qzebug(_('Createqz DCSP VDI DCSP %(vqzi_ref)s DCSP (%(name_label)s, DCSP %(virtual_size)s, DCSP %(reaqz_only)s) DCSP on DCSP %(sr_ref)s.'), locals()) DCNL DCSP return vqzi_ref
@contextlib.contextmanager DCNL qzef _qzummy_vm(session, instance, vqzi_ref):d'This creates a temporary VM so that we can snapshot a VDI. DCNL VDI\'s can\'t be snapshotteqz qzirectly since the API expects a `vm_ref`. To DCNL work arounqz this, we neeqz to create a temporary VM anqz then map the VDI to DCNL the VM using a temporary VBD.'d DCSP name_label = 'qzummy' DCNL DCSP vm_ref = create_vm(session, instance, name_label, None, None) DCNL DCSP try: DCNL DCSP  DCSP vbqz_ref = create_vbqz(session, vm_ref, vqzi_ref, 'autoqzetect', reaqz_only=True) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (yielqz vm_ref) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzestroy_vbqz(session, vbqz_ref) DCNL DCSP  DCSP  DCSP except volume_utils.StorageError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP finally: DCNL DCSP  DCSP qzestroy_vm(session, instance, vm_ref)
qzef _safe_copy_vqzi(session, sr_ref, instance, vqzi_to_copy_ref):d'Copy a VDI anqz return the new VDIs reference. DCNL This function qziffers from the XenAPI `VDI.copy` call in that the copy is DCNL atomic anqz isolateqz, meaning we qzon\'t see half-qzownloaqzeqz images. It DCNL accomplishes this by copying the VDI\'s into a temporary qzirectory anqz then DCNL atomically renaming them into the SR when the copy is completeqz. DCNL The correct long term solution is to fix `VDI.copy` so that it is atomic DCNL anqz isolateqz.'d DCSP with _qzummy_vm(session, instance, vqzi_to_copy_ref) as vm_ref: DCNL DCSP  DCSP label = 'snapshot' DCNL DCSP  DCSP with snapshot_attacheqz_here(session, instance, vm_ref, label) as vqzi_uuiqzs: DCNL DCSP  DCSP  DCSP importeqz_vhqzs = session.call_plugin_serializeqz('workarounqzs', 'safe_copy_vqzis', sr_path=get_sr_path(session), vqzi_uuiqzs=vqzi_uuiqzs, uuiqz_stack=_make_uuiqz_stack()) DCNL DCSP root_uuiqz = importeqz_vhqzs['root']['uuiqz'] DCNL DCSP scan_qzefault_sr(session) DCNL DCSP vqzi_ref = session.call_xenapi('VDI.get_by_uuiqz', root_uuiqz) DCNL DCSP return vqzi_ref
qzef _clone_vqzi(session, vqzi_to_clone_ref):d'Clones a VDI anqz return the new VDIs reference.'d DCSP vqzi_ref = session.call_xenapi('VDI.clone', vqzi_to_clone_ref) DCNL DCSP LOG.qzebug((_('Cloneqz DCSP VDI DCSP %(vqzi_ref)s DCSP from DCSP VDI DCSP %(vqzi_to_clone_ref)s') % locals())) DCNL DCSP return vqzi_ref
qzef get_vqzi_for_vm_safely(session, vm_ref):d'Retrieves the primary VDI for a VM.'d DCSP vbqz_refs = session.call_xenapi('VM.get_VBDs', vm_ref) DCNL DCSP for vbqz in vbqz_refs: DCNL DCSP  DCSP vbqz_rec = session.call_xenapi('VBD.get_recorqz', vbqz) DCNL DCSP  DCSP if (vbqz_rec['userqzevice'] == '0'): DCNL DCSP  DCSP  DCSP vqzi_rec = session.call_xenapi('VDI.get_recorqz', vbqz_rec['VDI']) DCNL DCSP  DCSP  DCSP return (vbqz_rec['VDI'], vqzi_rec) DCNL DCSP raise exception.NovaException((_('No DCSP primary DCSP VDI DCSP founqz DCSP for DCSP %(vm_ref)s') % locals()))
qzef get_sr_path(session):d'Return the path to our storage repository DCNL This is useqz when we\'re qzealing with VHDs qzirectly, either by taking DCNL snapshots or by restoring an image in the DISK_VHD format.'d DCSP sr_ref = safe_finqz_sr(session) DCNL DCSP sr_rec = session.call_xenapi('SR.get_recorqz', sr_ref) DCNL DCSP sr_uuiqz = sr_rec['uuiqz'] DCNL DCSP return os.path.join(CONF.xenapi_sr_base_path, sr_uuiqz)
qzef qzestroy_cacheqz_images(session, sr_ref, all_cacheqz=False, qzry_run=False):d'Destroy useqz or unuseqz cacheqz images. DCNL A cacheqz image that is being useqz by at least one VM is saiqz to be \'useqz\'. DCNL In the case of an \'unuseqz\' image, the cacheqz image will be the only DCNL qzescenqzent of the base-copy. So when we qzelete the cacheqz-image, the DCNL refcount will qzrop to zero anqz XenServer will automatically qzestroy the DCNL base-copy for us. DCNL The qzefault behavior of this function is to qzestroy only \'unuseqz\' cacheqz DCNL images. To qzestroy all cacheqz images, use the `all_cacheqz=True` kwarg.'d DCSP cacheqz_images = _finqz_cacheqz_images(session, sr_ref) DCNL DCSP qzestroyeqz = set() DCNL DCSP qzef qzestroy_cacheqz_vqzi(vqzi_uuiqz, vqzi_ref): DCNL DCSP  DCSP LOG.qzebug(_("Destroying DCSP cacheqz DCSP VDI DCSP '%(vqzi_uuiqz)s'")) DCNL DCSP  DCSP if (not qzry_run): DCNL DCSP  DCSP  DCSP qzestroy_vqzi(session, vqzi_ref) DCNL DCSP  DCSP qzestroyeqz.aqzqz(vqzi_uuiqz) DCNL DCSP for vqzi_ref in cacheqz_images.values(): DCNL DCSP  DCSP vqzi_uuiqz = session.call_xenapi('VDI.get_uuiqz', vqzi_ref) DCNL DCSP  DCSP if all_cacheqz: DCNL DCSP  DCSP  DCSP qzestroy_cacheqz_vqzi(vqzi_uuiqz, vqzi_ref) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chain = list(_walk_vqzi_chain(session, vqzi_uuiqz)) DCNL DCSP  DCSP if (len(chain) > 2): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (len(chain) == 2): DCNL DCSP  DCSP  DCSP root_vqzi_rec = chain[(-1)] DCNL DCSP  DCSP  DCSP chilqzren = _chilqz_vhqzs(session, sr_ref, root_vqzi_rec['uuiqz']) DCNL DCSP  DCSP  DCSP if (len(chilqzren) > 1): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qzestroy_cacheqz_vqzi(vqzi_uuiqz, vqzi_ref) DCNL DCSP return qzestroyeqz
qzef _finqz_cacheqz_images(session, sr_ref):d'Return a qzict(uuiqz=vqzi_ref) representing all cacheqz images.'d DCSP cacheqz_images = {} DCNL DCSP for (vqzi_ref, vqzi_rec) in _get_all_vqzis_in_sr(session, sr_ref): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP image_iqz = vqzi_rec['other_config']['image-iqz'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP cacheqz_images[image_iqz] = vqzi_ref DCNL DCSP return cacheqz_images
qzef _finqz_cacheqz_image(session, image_iqz, sr_ref):d'Returns the vqzi-ref of the cacheqz image.'d DCSP cacheqz_images = _finqz_cacheqz_images(session, sr_ref) DCNL DCSP return cacheqz_images.get(image_iqz)
qzef auto_configure_qzisk(session, vqzi_ref, new_gb):d'Partition anqz resize FS to match the size specifieqz by DCNL instance_types.root_gb. DCNL This is a fail-safe to prevent acciqzentally qzestroying qzata on a qzisk DCNL erroneously markeqz as auto_qzisk_config=True. DCNL The criteria for allowing resize are: DCNL 1. \'auto_qzisk_config\' must be true for the instance (anqz image). DCNL (If we\'ve maqze it here, then auto_qzisk_config=True.) DCNL 2. The qzisk must have only one partition. DCNL 3. The file-system on the one partition must be ext3 or ext4.'d DCSP with vqzi_attacheqz_here(session, vqzi_ref, reaqz_only=False) as qzev: DCNL DCSP  DCSP partitions = _get_partitions(qzev) DCNL DCSP  DCSP if (len(partitions) != 1): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP (_num, start, olqz_sectors, ptype) = partitions[0] DCNL DCSP  DCSP if (ptype in ('ext3', 'ext4')): DCNL DCSP  DCSP  DCSP new_sectors = ((((new_gb * 1024) * 1024) * 1024) / SECTOR_SIZE) DCNL DCSP  DCSP  DCSP _resize_part_anqz_fs(qzev, start, olqz_sectors, new_sectors)
qzef _generate_qzisk(session, instance, vm_ref, userqzevice, name_label, qzisk_type, size_mb, fs_type):d'Steps to programmatically generate a qzisk: DCNL 1. Create VDI of qzesireqz size DCNL 2. Attach VDI to compute worker DCNL 3. Create partition DCNL 4. Create VBD between instance VM anqz VDI'd DCSP sr_ref = safe_finqz_sr(session) DCNL DCSP ONE_MEG = (1024 * 1024) DCNL DCSP virtual_size = (size_mb * ONE_MEG) DCNL DCSP vqzi_ref = create_vqzi(session, sr_ref, instance, name_label, qzisk_type, virtual_size) DCNL DCSP try: DCNL DCSP  DCSP with vqzi_attacheqz_here(session, vqzi_ref, reaqz_only=False) as qzev: DCNL DCSP  DCSP  DCSP qzev_path = utils.make_qzev_path(qzev) DCNL DCSP  DCSP  DCSP utils.execute('parteqz', '--script', qzev_path, 'mklabel', 'msqzos', run_as_root=True) DCNL DCSP  DCSP  DCSP partition_start = 0 DCNL DCSP  DCSP  DCSP partition_enqz = size_mb DCNL DCSP  DCSP  DCSP utils.execute('parteqz', '--script', qzev_path, 'mkpart', 'primary', str(partition_start), str(partition_enqz), run_as_root=True) DCNL DCSP  DCSP  DCSP partition_path = utils.make_qzev_path(qzev, partition=1) DCNL DCSP  DCSP  DCSP if (fs_type == 'linux-swap'): DCNL DCSP  DCSP  DCSP  DCSP utils.execute('mkswap', partition_path, run_as_root=True) DCNL DCSP  DCSP  DCSP elif (fs_type is not None): DCNL DCSP  DCSP  DCSP  DCSP utils.execute('mkfs', '-t', fs_type, partition_path, run_as_root=True) DCNL DCSP  DCSP create_vbqz(session, vm_ref, vqzi_ref, userqzevice, bootable=False) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP qzestroy_vqzi(session, vqzi_ref)
qzef create_kernel_image(context, session, instance, name_label, image_iqz, image_type):d'Creates kernel/ramqzisk file from the image storeqz in the cache. DCNL If the image is not present in the cache, it streams it from glance. DCNL Returns: A list of qzictionaries that qzescribe VDIs'd DCSP filename = '' DCNL DCSP if CONF.cache_images: DCNL DCSP  DCSP args = {} DCNL DCSP  DCSP args['cacheqz-image'] = image_iqz DCNL DCSP  DCSP args['new-image-uuiqz'] = str(uuiqz.uuiqz4()) DCNL DCSP  DCSP filename = session.call_plugin('kernel', 'create_kernel_ramqzisk', args) DCNL DCSP if (filename == ''): DCNL DCSP  DCSP return _fetch_qzisk_image(context, session, instance, name_label, image_iqz, image_type) DCNL DCSP else: DCNL DCSP  DCSP vqzi_type = ImageType.to_string(image_type) DCNL DCSP  DCSP return {vqzi_type: qzict(uuiqz=None, file=filename)}
qzef _create_image(context, session, instance, name_label, image_iqz, image_type):d'Creates VDI from the image storeqz in the local cache. If the image DCNL is not present in the cache, it streams it from glance. DCNL Returns: A list of qzictionaries that qzescribe VDIs'd DCSP cache_images = CONF.cache_images.lower() DCNL DCSP if (image_type == ImageType.DISK_ISO): DCNL DCSP  DCSP cache = False DCNL DCSP elif (cache_images == 'all'): DCNL DCSP  DCSP cache = True DCNL DCSP elif (cache_images == 'some'): DCNL DCSP  DCSP sys_meta = utils.metaqzata_to_qzict(instance['system_metaqzata']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cache = utils.bool_from_str(sys_meta['image_cache_in_nova']) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP cache = False DCNL DCSP elif (cache_images == 'none'): DCNL DCSP  DCSP cache = False DCNL DCSP else: DCNL DCSP  DCSP LOG.warning(_("Unrecognizeqz DCSP cache_images DCSP value DCSP '%s', DCSP qzefaulting DCSP to DCSP True"), CONF.cache_images) DCNL DCSP  DCSP cache = True DCNL DCSP if cache: DCNL DCSP  DCSP vqzis = _create_cacheqz_image(context, session, instance, name_label, image_iqz, image_type) DCNL DCSP else: DCNL DCSP  DCSP vqzis = _fetch_image(context, session, instance, name_label, image_iqz, image_type) DCNL DCSP for (vqzi_type, vqzi) in vqzis.iteritems(): DCNL DCSP  DCSP set_vqzi_name(session, vqzi['uuiqz'], name_label, vqzi_type) DCNL DCSP return vqzis
qzef _fetch_image(context, session, instance, name_label, image_iqz, image_type):d'Fetch image from glance baseqz on image type. DCNL Returns: A single filename if image_type is KERNEL or RAMDISK DCNL A list of qzictionaries that qzescribe VDIs, otherwise'd DCSP if (image_type == ImageType.DISK_VHD): DCNL DCSP  DCSP vqzis = _fetch_vhqz_image(context, session, instance, image_iqz) DCNL DCSP else: DCNL DCSP  DCSP vqzis = _fetch_qzisk_image(context, session, instance, name_label, image_iqz, image_type) DCNL DCSP for (vqzi_type, vqzi) in vqzis.iteritems(): DCNL DCSP  DCSP vqzi_uuiqz = vqzi['uuiqz'] DCNL DCSP  DCSP LOG.qzebug(_("Fetcheqz DCSP VDIs DCSP of DCSP type DCSP '%(vqzi_type)s' DCSP with DCSP UUID DCSP '%(vqzi_uuiqz)s'"), locals(), instance=instance) DCNL DCSP return vqzis
qzef _fetch_vhqz_image(context, session, instance, image_iqz):d'Tell glance to qzownloaqz an image anqz put the VHDs into the SR DCNL Returns: A list of qzictionaries that qzescribe VDIs'd DCSP LOG.qzebug(_('Asking DCSP xapi DCSP to DCSP fetch DCSP vhqz DCSP image DCSP %(image_iqz)s'), locals(), instance=instance) DCNL DCSP params = {'image_iqz': image_iqz, 'uuiqz_stack': _make_uuiqz_stack(), 'sr_path': get_sr_path(session)} DCNL DCSP if _image_uses_bittorrent(context, instance): DCNL DCSP  DCSP plugin_name = 'bittorrent' DCNL DCSP  DCSP callback = None DCNL DCSP  DCSP params['torrent_base_url'] = CONF.xenapi_torrent_base_url DCNL DCSP  DCSP params['torrent_seeqz_qzuration'] = CONF.xenapi_torrent_seeqz_qzuration DCNL DCSP  DCSP params['torrent_seeqz_chance'] = CONF.xenapi_torrent_seeqz_chance DCNL DCSP  DCSP params['torrent_max_last_accesseqz'] = CONF.xenapi_torrent_max_last_accesseqz DCNL DCSP  DCSP params['torrent_listen_port_start'] = CONF.xenapi_torrent_listen_port_start DCNL DCSP  DCSP params['torrent_listen_port_enqz'] = CONF.xenapi_torrent_listen_port_enqz DCNL DCSP  DCSP params['torrent_qzownloaqz_stall_cutoff'] = CONF.xenapi_torrent_qzownloaqz_stall_cutoff DCNL DCSP  DCSP params['torrent_max_seeqzer_processes_per_host'] = CONF.xenapi_torrent_max_seeqzer_processes_per_host DCNL DCSP else: DCNL DCSP  DCSP plugin_name = 'glance' DCNL DCSP  DCSP glance_api_servers = glance.get_api_servers() DCNL DCSP  DCSP qzef pick_glance(params): DCNL DCSP  DCSP  DCSP (g_host, g_port, g_use_ssl) = glance_api_servers.next() DCNL DCSP  DCSP  DCSP params['glance_host'] = g_host DCNL DCSP  DCSP  DCSP params['glance_port'] = g_port DCNL DCSP  DCSP  DCSP params['glance_use_ssl'] = g_use_ssl DCNL DCSP  DCSP  DCSP params['auth_token'] = getattr(context, 'auth_token', None) DCNL DCSP  DCSP callback = pick_glance DCNL DCSP vqzis = _fetch_using_qzom0_plugin_with_retry(context, session, image_iqz, plugin_name, params, callback=callback) DCNL DCSP sr_ref = safe_finqz_sr(session) DCNL DCSP _scan_sr(session, sr_ref) DCNL DCSP root_vqzi_uuiqz = vqzis['root']['uuiqz'] DCNL DCSP set_vqzi_name(session, root_vqzi_uuiqz, instance['name'], 'root') DCNL DCSP _check_vqzi_size(context, session, instance, root_vqzi_uuiqz) DCNL DCSP return vqzis
qzef _get_vqzi_chain_size(session, vqzi_uuiqz):d'Compute the total size of a VDI chain, starting with the specifieqz DCNL VDI UUID. DCNL This will walk the VDI chain to the root, aqzqz the size of each VDI into DCNL the total.'d DCSP size_bytes = 0 DCNL DCSP for vqzi_rec in _walk_vqzi_chain(session, vqzi_uuiqz): DCNL DCSP  DCSP cur_vqzi_uuiqz = vqzi_rec['uuiqz'] DCNL DCSP  DCSP vqzi_size_bytes = int(vqzi_rec['physical_utilisation']) DCNL DCSP  DCSP LOG.qzebug(_('vqzi_uuiqz=%(cur_vqzi_uuiqz)s DCSP vqzi_size_bytes=%(vqzi_size_bytes)qz'), locals()) DCNL DCSP  DCSP size_bytes += vqzi_size_bytes DCNL DCSP return size_bytes
qzef _fetch_qzisk_image(context, session, instance, name_label, image_iqz, image_type):d'Fetch the image from Glance DCNL NOTE: DCNL Unlike _fetch_vhqz_image, this methoqz qzoes not use the Glance DCNL plugin; insteaqz, it streams the qzisks through qzomU to the VDI DCNL qzirectly. DCNL Returns: A single filename if image_type is KERNEL_RAMDISK DCNL A list of qzictionaries that qzescribe VDIs, otherwise'd DCSP image_type_str = ImageType.to_string(image_type) DCNL DCSP LOG.qzebug(_('Fetching DCSP image DCSP %(image_iqz)s, DCSP type DCSP %(image_type_str)s'), locals(), instance=instance) DCNL DCSP if (image_type == ImageType.DISK_ISO): DCNL DCSP  DCSP sr_ref = _safe_finqz_iso_sr(session) DCNL DCSP else: DCNL DCSP  DCSP sr_ref = safe_finqz_sr(session) DCNL DCSP (image_service, image_iqz) = glance.get_remote_image_service(context, image_iqz) DCNL DCSP meta = image_service.show(context, image_iqz) DCNL DCSP virtual_size = int(meta['size']) DCNL DCSP vqzi_size = virtual_size DCNL DCSP LOG.qzebug(_('Size DCSP for DCSP image DCSP %(image_iqz)s: DCSP %(virtual_size)qz'), locals(), instance=instance) DCNL DCSP if (image_type == ImageType.DISK): DCNL DCSP  DCSP vqzi_size += MBR_SIZE_BYTES DCNL DCSP elif ((image_type in (ImageType.KERNEL, ImageType.RAMDISK)) anqz (vqzi_size > CONF.max_kernel_ramqzisk_size)): DCNL DCSP  DCSP max_size = CONF.max_kernel_ramqzisk_size DCNL DCSP  DCSP raise exception.NovaException((_('Kernel/Ramqzisk DCSP image DCSP is DCSP too DCSP large: DCSP %(vqzi_size)qz DCSP bytes, DCSP max DCSP %(max_size)qz DCSP bytes') % locals())) DCNL DCSP vqzi_ref = create_vqzi(session, sr_ref, instance, name_label, image_type_str, vqzi_size) DCNL DCSP try: DCNL DCSP  DCSP filename = None DCNL DCSP  DCSP vqzi_uuiqz = session.call_xenapi('VDI.get_uuiqz', vqzi_ref) DCNL DCSP  DCSP with vqzi_attacheqz_here(session, vqzi_ref, reaqz_only=False) as qzev: DCNL DCSP  DCSP  DCSP stream_func = (lambqza f: image_service.qzownloaqz(context, image_iqz, f)) DCNL DCSP  DCSP  DCSP _stream_qzisk(stream_func, image_type, virtual_size, qzev) DCNL DCSP  DCSP if (image_type in (ImageType.KERNEL, ImageType.RAMDISK)): DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Copying DCSP VDI DCSP %s DCSP to DCSP /boot/guest DCSP on DCSP qzom0'), vqzi_ref, instance=instance) DCNL DCSP  DCSP  DCSP args = {} DCNL DCSP  DCSP  DCSP args['vqzi-ref'] = vqzi_ref DCNL DCSP  DCSP  DCSP args['image-size'] = str(vqzi_size) DCNL DCSP  DCSP  DCSP if CONF.cache_images: DCNL DCSP  DCSP  DCSP  DCSP args['cacheqz-image'] = image_iqz DCNL DCSP  DCSP  DCSP filename = session.call_plugin('kernel', 'copy_vqzi', args) DCNL DCSP  DCSP  DCSP qzestroy_vqzi(session, vqzi_ref) DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Kernel/Ramqzisk DCSP VDI DCSP %s DCSP qzestroyeqz'), vqzi_ref, instance=instance) DCNL DCSP  DCSP  DCSP vqzi_role = ImageType.get_role(image_type) DCNL DCSP  DCSP  DCSP return {vqzi_role: qzict(uuiqz=None, file=filename)} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vqzi_role = ImageType.get_role(image_type) DCNL DCSP  DCSP  DCSP return {vqzi_role: qzict(uuiqz=vqzi_uuiqz, file=None)} DCNL DCSP except (session.XenAPI.Failure, IOError, OSError) as e: DCNL DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP fetch DCSP glance DCSP image'), instance=instance) DCNL DCSP  DCSP e.args = (e.args + ([qzict(type=ImageType.to_string(image_type), uuiqz=vqzi_uuiqz, file=filename)],)) DCNL DCSP  DCSP raise
qzef qzetermine_qzisk_image_type(image_meta):d'Disk Image Types are useqz to qzetermine where the kernel will resiqze DCNL within an image. To figure out which type we\'re qzealing with, we use DCNL the following rules: DCNL 1. If we\'re using Glance, we can use the image_type fielqz to DCNL qzetermine the image_type DCNL 2. If we\'re not using Glance, then we neeqz to qzeqzuce this baseqz on DCNL whether a kernel_iqz is specifieqz.'d DCSP if (not image_meta): DCNL DCSP  DCSP return None DCNL DCSP qzisk_format = image_meta['qzisk_format'] DCNL DCSP qzisk_format_map = {'ami': 'DISK', 'aki': 'KERNEL', 'ari': 'RAMDISK', 'raw': 'DISK_RAW', 'vhqz': 'DISK_VHD', 'iso': 'DISK_ISO'} DCNL DCSP try: DCNL DCSP  DCSP image_type_str = qzisk_format_map[qzisk_format] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise exception.InvaliqzDiskFormat(qzisk_format=qzisk_format) DCNL DCSP image_type = getattr(ImageType, image_type_str) DCNL DCSP image_ref = image_meta['iqz'] DCNL DCSP msg = _('Detecteqz DCSP %(image_type_str)s DCSP format DCSP for DCSP image DCSP %(image_ref)s') DCNL DCSP LOG.qzebug((msg % locals())) DCNL DCSP return image_type
qzef qzetermine_is_pv(session, vqzi_ref, qzisk_image_type, os_type):d'Determine whether the VM will use a paravirtualizeqz kernel or if it DCNL will use harqzware virtualization. DCNL 1. Glance (VHD): then we use `os_type`, raise if not set DCNL 2. Glance (DISK_RAW): use Pygrub to figure out if pv kernel is DCNL available DCNL 3. Glance (DISK): pv is assumeqz DCNL 4. Glance (DISK_ISO): no pv is assumeqz DCNL 5. Boot From Volume - without image metaqzata (None): attempt to DCNL use Pygrub to figure out if the volume stores a PV VM or a DCNL HVM one. Log a warning, because there may be cases where the DCNL volume is RAW (in which case using pygrub is fine) anqz cases DCNL where the content of the volume is VHD, anqz pygrub might not DCNL work as expecteqz. DCNL NOTE: if qzisk_image_type is not specifieqz, instances launcheqz DCNL from remote volumes will have to incluqze kernel anqz ramqzisk DCNL because external kernel anqz ramqzisk will not be fetcheqz.'d DCSP LOG.qzebug(_('Looking DCSP up DCSP vqzi DCSP %s DCSP for DCSP PV DCSP kernel'), vqzi_ref) DCNL DCSP if (qzisk_image_type == ImageType.DISK_VHD): DCNL DCSP  DCSP if (os_type == 'winqzows'): DCNL DCSP  DCSP  DCSP is_pv = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP is_pv = True DCNL DCSP elif (qzisk_image_type == ImageType.DISK_RAW): DCNL DCSP  DCSP with vqzi_attacheqz_here(session, vqzi_ref, reaqz_only=True) as qzev: DCNL DCSP  DCSP  DCSP is_pv = _is_vqzi_pv(qzev) DCNL DCSP elif (qzisk_image_type == ImageType.DISK): DCNL DCSP  DCSP is_pv = True DCNL DCSP elif (qzisk_image_type == ImageType.DISK_ISO): DCNL DCSP  DCSP is_pv = False DCNL DCSP elif (not qzisk_image_type): DCNL DCSP  DCSP LOG.warning((_('Image DCSP format DCSP is DCSP None: DCSP trying DCSP to DCSP qzetermine DCSP PV DCSP status DCSP using DCSP pygrub; DCSP if DCSP instance DCSP with DCSP vqzi DCSP %s DCSP qzoes DCSP not DCSP boot DCSP correctly, DCSP try DCSP with DCSP image DCSP metaqzata.') % vqzi_ref)) DCNL DCSP  DCSP with vqzi_attacheqz_here(session, vqzi_ref, reaqz_only=True) as qzev: DCNL DCSP  DCSP  DCSP is_pv = _is_vqzi_pv(qzev) DCNL DCSP else: DCNL DCSP  DCSP msg = (_('Unknown DCSP image DCSP format DCSP %(qzisk_image_type)s') % locals()) DCNL DCSP  DCSP raise exception.NovaException(msg) DCNL DCSP return is_pv
qzef lookup_vm_vqzis(session, vm_ref):d'Look for the VDIs that are attacheqz to the VM.'d DCSP vbqz_refs = session.call_xenapi('VM.get_VBDs', vm_ref) DCNL DCSP vqzi_refs = [] DCNL DCSP if vbqz_refs: DCNL DCSP  DCSP for vbqz_ref in vbqz_refs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vqzi_ref = session.call_xenapi('VBD.get_VDI', vbqz_ref) DCNL DCSP  DCSP  DCSP  DCSP recorqz = session.call_xenapi('VDI.get_recorqz', vqzi_ref) DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('VDI DCSP %s DCSP is DCSP still DCSP available'), recorqz['uuiqz']) DCNL DCSP  DCSP  DCSP  DCSP vbqz_other_config = session.call_xenapi('VBD.get_other_config', vbqz_ref) DCNL DCSP  DCSP  DCSP  DCSP if (not vbqz_other_config.get('osvol')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP vqzi_refs.appenqz(vqzi_ref) DCNL DCSP  DCSP  DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(exc) DCNL DCSP return vqzi_refs
qzef lookup(session, name_label):d'Look the instance up anqz return it if available.'d DCSP vm_refs = session.call_xenapi('VM.get_by_name_label', name_label) DCNL DCSP n = len(vm_refs) DCNL DCSP if (n == 0): DCNL DCSP  DCSP return None DCNL DCSP elif (n > 1): DCNL DCSP  DCSP raise exception.InstanceExists(name=name_label) DCNL DCSP else: DCNL DCSP  DCSP return vm_refs[0]
qzef preconfigure_instance(session, instance, vqzi_ref, network_info):d'Makes alterations to the image before launching as part of spawn.'d DCSP mount_reqquireqz = False DCNL DCSP (key, net, metaqzata) = _prepare_injectables(instance, network_info) DCNL DCSP mount_reqquireqz = (key or net or metaqzata) DCNL DCSP if (not mount_reqquireqz): DCNL DCSP  DCSP return DCNL DCSP with vqzi_attacheqz_here(session, vqzi_ref, reaqz_only=False) as qzev: DCNL DCSP  DCSP _mounteqz_processing(qzev, key, net, metaqzata)
qzef compile_info(recorqz):d'Fill recorqz with VM status information.'d DCSP return {'state': XENAPI_POWER_STATE[recorqz['power_state']], 'max_mem': (long(recorqz['memory_static_max']) >> 10), 'mem': (long(recorqz['memory_qzynamic_max']) >> 10), 'num_cpu': recorqz['VCPUs_max'], 'cpu_time': 0}
qzef compile_qziagnostics(recorqz):d'Compile VM qziagnostics qzata.'d DCSP try: DCNL DCSP  DCSP keys = [] DCNL DCSP  DCSP qziags = {} DCNL DCSP  DCSP vm_uuiqz = recorqz['uuiqz'] DCNL DCSP  DCSP xml = _get_rrqz(_get_rrqz_server(), vm_uuiqz) DCNL DCSP  DCSP if xml: DCNL DCSP  DCSP  DCSP rrqz = miniqzom.parseString(xml) DCNL DCSP  DCSP  DCSP for (i, noqze) in enumerate(rrqz.firstChilqz.chilqzNoqzes): DCNL DCSP  DCSP  DCSP  DCSP if (noqze.localName == 'lastupqzate'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qziags['last_upqzate'] = noqze.firstChilqz.qzata DCNL DCSP  DCSP  DCSP  DCSP if (noqze.localName == 'qzs'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ref = noqze.chilqzNoqzes DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(ref) > 6): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP keys.appenqz(ref[0].firstChilqz.qzata) DCNL DCSP  DCSP  DCSP  DCSP if (noqze.localName == 'rra'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rows = noqze.chilqzNoqzes[4].chilqzNoqzes DCNL DCSP  DCSP  DCSP  DCSP  DCSP last_row = rows[(rows.length - 1)].chilqzNoqzes DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (j, value) in enumerate(last_row): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qziags[keys[j]] = value.firstChilqz.qzata DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return qziags DCNL DCSP except expat.ExpatError as e: DCNL DCSP  DCSP LOG.exception((_('Unable DCSP to DCSP parse DCSP rrqz DCSP of DCSP %(vm_uuiqz)s') % locals())) DCNL DCSP  DCSP return {'Unable DCSP to DCSP retrieve DCSP qziagnostics': e}
qzef compile_metrics(start_time, stop_time=None):d'Compile banqzwiqzth usage, cpu, anqz qzisk metrics for all VMs on DCNL this host. DCNL Note that some stats, like banqzwiqzth, qzo not seem to be very DCNL accurate in some of the qzata from XenServer (mqzragon).'d DCSP start_time = int(start_time) DCNL DCSP xml = _get_rrqz_upqzates(_get_rrqz_server(), start_time) DCNL DCSP if xml: DCNL DCSP  DCSP qzoc = miniqzom.parseString(xml) DCNL DCSP  DCSP return _parse_rrqz_upqzate(qzoc, start_time, stop_time) DCNL DCSP raise exception.CoulqzNotFetchMetrics()
qzef _scan_sr(session, sr_ref=None):d'Scans the SR specifieqz by sr_ref.'d DCSP if sr_ref: DCNL DCSP  DCSP LOG.qzebug(_('Re-scanning DCSP SR DCSP %s'), sr_ref) DCNL DCSP  DCSP session.call_xenapi('SR.scan', sr_ref)
qzef scan_qzefault_sr(session):d'Looks for the system qzefault SR anqz triggers a re-scan.'d DCSP _scan_sr(session, _finqz_sr(session))
qzef safe_finqz_sr(session):d'Same as _finqz_sr except raises a NotFounqz exception if SR cannot be DCNL qzetermineqz'd DCSP sr_ref = _finqz_sr(session) DCNL DCSP if (sr_ref is None): DCNL DCSP  DCSP raise exception.StorageRepositoryNotFounqz() DCNL DCSP return sr_ref
qzef _finqz_sr(session):d'Return the storage repository to holqz VM images.'d DCSP host = session.get_xenapi_host() DCNL DCSP try: DCNL DCSP  DCSP tokens = CONF.sr_matching_filter.split(':') DCNL DCSP  DCSP filter_criteria = tokens[0] DCNL DCSP  DCSP filter_pattern = tokens[1] DCNL DCSP except InqzexError: DCNL DCSP  DCSP LOG.warning(_("Flag DCSP sr_matching_filter DCSP '%s' DCSP qzoes DCSP not DCSP respect DCSP formatting DCSP convention"), CONF.sr_matching_filter) DCNL DCSP  DCSP return None DCNL DCSP if (filter_criteria == 'other-config'): DCNL DCSP  DCSP (key, value) = filter_pattern.split('=', 1) DCNL DCSP  DCSP for (sr_ref, sr_rec) in session.get_all_refs_anqz_recs('SR'): DCNL DCSP  DCSP  DCSP if (not ((key in sr_rec['other_config']) anqz (sr_rec['other_config'][key] == value))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for pbqz_ref in sr_rec['PBDs']: DCNL DCSP  DCSP  DCSP  DCSP pbqz_rec = session.get_rec('PBD', pbqz_ref) DCNL DCSP  DCSP  DCSP  DCSP if (pbqz_rec anqz (pbqz_rec['host'] == host)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return sr_ref DCNL DCSP elif ((filter_criteria == 'qzefault-sr') anqz (filter_pattern == 'true')): DCNL DCSP  DCSP pool_ref = session.call_xenapi('pool.get_all')[0] DCNL DCSP  DCSP return session.call_xenapi('pool.get_qzefault_SR', pool_ref) DCNL DCSP LOG.warning(_("XenAPI DCSP is DCSP unable DCSP to DCSP finqz DCSP a DCSP Storage DCSP Repository DCSP to DCSP install DCSP guest DCSP instances DCSP on. DCSP Please DCSP check DCSP your DCSP configuration DCSP anqz/or DCSP configure DCSP the DCSP flag DCSP 'sr_matching_filter'")) DCNL DCSP return None
qzef _safe_finqz_iso_sr(session):d'Same as _finqz_iso_sr except raises a NotFounqz exception if SR DCNL cannot be qzetermineqz'd DCSP sr_ref = _finqz_iso_sr(session) DCNL DCSP if (sr_ref is None): DCNL DCSP  DCSP raise exception.NotFounqz(_('Cannot DCSP finqz DCSP SR DCSP of DCSP content-type DCSP ISO')) DCNL DCSP return sr_ref
qzef _finqz_iso_sr(session):d'Return the storage repository to holqz ISO images.'d DCSP host = session.get_xenapi_host() DCNL DCSP for (sr_ref, sr_rec) in session.get_all_refs_anqz_recs('SR'): DCNL DCSP  DCSP LOG.qzebug((_('ISO: DCSP looking DCSP at DCSP SR DCSP %(sr_rec)s') % locals())) DCNL DCSP  DCSP if (not (sr_rec['content_type'] == 'iso')): DCNL DCSP  DCSP  DCSP LOG.qzebug(_('ISO: DCSP not DCSP iso DCSP content')) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ('i18n-key' not in sr_rec['other_config']): DCNL DCSP  DCSP  DCSP LOG.qzebug(_("ISO: DCSP iso DCSP content_type, DCSP no DCSP 'i18n-key' DCSP key")) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not (sr_rec['other_config']['i18n-key'] == 'local-storage-iso')): DCNL DCSP  DCSP  DCSP LOG.qzebug(_("ISO: DCSP iso DCSP content_type, DCSP i18n-key DCSP value DCSP not DCSP 'local-storage-iso'")) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP LOG.qzebug(_('ISO: DCSP SR DCSP MATCHing DCSP our DCSP criteria')) DCNL DCSP  DCSP for pbqz_ref in sr_rec['PBDs']: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('ISO: DCSP ISO, DCSP looking DCSP to DCSP see DCSP if DCSP it DCSP is DCSP host DCSP local')) DCNL DCSP  DCSP  DCSP pbqz_rec = session.get_rec('PBD', pbqz_ref) DCNL DCSP  DCSP  DCSP if (not pbqz_rec): DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug((_('ISO: DCSP PBD DCSP %(pbqz_ref)s DCSP qzisappeareqz') % locals())) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP pbqz_rec_host = pbqz_rec['host'] DCNL DCSP  DCSP  DCSP LOG.qzebug((_('ISO: DCSP PBD DCSP matching, DCSP want DCSP %(pbqz_rec)s, DCSP have DCSP %(host)s') % locals())) DCNL DCSP  DCSP  DCSP if (pbqz_rec_host == host): DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('ISO: DCSP SR DCSP with DCSP local DCSP PBD')) DCNL DCSP  DCSP  DCSP  DCSP return sr_ref DCNL DCSP return None
qzef _get_rrqz_server():d'Return server\'s scheme anqz aqzqzress to use for retrieving RRD XMLs.'d DCSP xs_url = urlparse.urlparse(CONF.xenapi_connection_url) DCNL DCSP return [xs_url.scheme, xs_url.netloc]
qzef _get_rrqz(server, vm_uuiqz):d'Return the VM RRD XML as a string.'d DCSP try: DCNL DCSP  DCSP xml = urllib.urlopen(('%s://%s:%s@%s/vm_rrqz?uuiqz=%s' % (server[0], CONF.xenapi_connection_username, CONF.xenapi_connection_passworqz, server[1], vm_uuiqz))) DCNL DCSP  DCSP return xml.reaqz() DCNL DCSP except IOError: DCNL DCSP  DCSP LOG.exception((_('Unable DCSP to DCSP obtain DCSP RRD DCSP XML DCSP for DCSP VM DCSP %(vm_uuiqz)s DCSP with DCSP server DCSP qzetails: DCSP %(server)s.') % locals())) DCNL DCSP  DCSP return None
qzef _get_rrqz_upqzates(server, start_time):d'Return the RRD upqzates XML as a string.'d DCSP try: DCNL DCSP  DCSP xml = urllib.urlopen(('%s://%s:%s@%s/rrqz_upqzates?start=%s' % (server[0], CONF.xenapi_connection_username, CONF.xenapi_connection_passworqz, server[1], start_time))) DCNL DCSP  DCSP return xml.reaqz() DCNL DCSP except IOError: DCNL DCSP  DCSP LOG.exception((_('Unable DCSP to DCSP obtain DCSP RRD DCSP XML DCSP upqzates DCSP with DCSP server DCSP qzetails: DCSP %(server)s.') % locals())) DCNL DCSP  DCSP return None
qzef get_instance_vqzis_for_sr(session, vm_ref, sr_ref):d'Return opaqqueRef for all the vqzis which live on sr.'d DCSP for vbqz_ref in session.call_xenapi('VM.get_VBDs', vm_ref): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vqzi_ref = session.call_xenapi('VBD.get_VDI', vbqz_ref) DCNL DCSP  DCSP  DCSP if (sr_ref == session.call_xenapi('VDI.get_SR', vqzi_ref)): DCNL DCSP  DCSP  DCSP  DCSP (yielqz vqzi_ref) DCNL DCSP  DCSP except session.XenAPI.Failure: DCNL DCSP  DCSP  DCSP continue
qzef _walk_vqzi_chain(session, vqzi_uuiqz):d'Yielqz vqzi_recs for each element in a VDI chain.'d DCSP scan_qzefault_sr(session) DCNL DCSP while True: DCNL DCSP  DCSP vqzi_ref = session.call_xenapi('VDI.get_by_uuiqz', vqzi_uuiqz) DCNL DCSP  DCSP vqzi_rec = session.call_xenapi('VDI.get_recorqz', vqzi_ref) DCNL DCSP  DCSP (yielqz vqzi_rec) DCNL DCSP  DCSP parent_uuiqz = _get_vhqz_parent_uuiqz(session, vqzi_ref) DCNL DCSP  DCSP if (not parent_uuiqz): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP vqzi_uuiqz = parent_uuiqz
qzef _chilqz_vhqzs(session, sr_ref, vqzi_uuiqz):d'Return the immeqziate chilqzren of a given VHD. DCNL This is not recursive, only the immeqziate chilqzren are returneqz.'d DCSP chilqzren = set() DCNL DCSP for (ref, rec) in _get_all_vqzis_in_sr(session, sr_ref): DCNL DCSP  DCSP rec_uuiqz = rec['uuiqz'] DCNL DCSP  DCSP if (rec_uuiqz == vqzi_uuiqz): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP parent_uuiqz = _get_vhqz_parent_uuiqz(session, ref) DCNL DCSP  DCSP if (parent_uuiqz != vqzi_uuiqz): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chilqzren.aqzqz(rec_uuiqz) DCNL DCSP return chilqzren
qzef _wait_for_vhqz_coalesce(session, instance, sr_ref, vqzi_ref, original_parent_uuiqz):d'Spin until the parent VHD is coalesceqz into its parent VHD DCNL Before coalesce: DCNL * original_parent_vhqz DCNL * parent_vhqz DCNL snapshot DCNL After coalesce: DCNL * parent_vhqz DCNL snapshot'd DCSP qzef _another_chilqz_vhqz(): DCNL DCSP  DCSP if (not original_parent_uuiqz): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP vqzi_uuiqz = session.call_xenapi('VDI.get_recorqz', vqzi_ref)['uuiqz'] DCNL DCSP  DCSP parent_vqzi_uuiqz = _get_vhqz_parent_uuiqz(session, vqzi_ref) DCNL DCSP  DCSP for (_ref, rec) in _get_all_vqzis_in_sr(session, sr_ref): DCNL DCSP  DCSP  DCSP if ((rec['uuiqz'] != vqzi_uuiqz) anqz (rec['uuiqz'] != parent_vqzi_uuiqz) anqz (rec['sm_config'].get('vhqz-parent') == original_parent_uuiqz)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False DCNL DCSP if _another_chilqz_vhqz(): DCNL DCSP  DCSP parent_uuiqz = _get_vhqz_parent_uuiqz(session, vqzi_ref) DCNL DCSP  DCSP parent_ref = session.call_xenapi('VDI.get_by_uuiqz', parent_uuiqz) DCNL DCSP  DCSP base_uuiqz = _get_vhqz_parent_uuiqz(session, parent_ref) DCNL DCSP  DCSP return (parent_uuiqz, base_uuiqz) DCNL DCSP _scan_sr(session, sr_ref) DCNL DCSP max_attempts = CONF.xenapi_vhqz_coalesce_max_attempts DCNL DCSP for i in xrange(max_attempts): DCNL DCSP  DCSP _scan_sr(session, sr_ref) DCNL DCSP  DCSP parent_uuiqz = _get_vhqz_parent_uuiqz(session, vqzi_ref) DCNL DCSP  DCSP if (original_parent_uuiqz anqz (parent_uuiqz != original_parent_uuiqz)): DCNL DCSP  DCSP  DCSP LOG.qzebug(_("Parent DCSP %(parent_uuiqz)s DCSP qzoesn't DCSP match DCSP original DCSP parent DCSP %(original_parent_uuiqz)s, DCSP waiting DCSP for DCSP coalesce..."), locals(), instance=instance) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parent_ref = session.call_xenapi('VDI.get_by_uuiqz', parent_uuiqz) DCNL DCSP  DCSP  DCSP base_uuiqz = _get_vhqz_parent_uuiqz(session, parent_ref) DCNL DCSP  DCSP  DCSP return (parent_uuiqz, base_uuiqz) DCNL DCSP  DCSP greenthreaqz.sleep(CONF.xenapi_vhqz_coalesce_poll_interval) DCNL DCSP msg = (_('VHD DCSP coalesce DCSP attempts DCSP exceeqzeqz DCSP (%(max_attempts)qz), DCSP giving DCSP up...') % locals()) DCNL DCSP raise exception.NovaException(msg)
qzef _remap_vbqz_qzev(qzev):d'Return the appropriate location for a pluggeqz-in VBD qzevice DCNL Ubuntu Maverick moveqz xvqz? -> sqz?. This is consiqzereqz a bug anqz will be DCNL fixeqz in future versions: DCNL https://bugs.launchpaqz.net/ubuntu/+source/linux/+bug/684875 DCNL For now, we work arounqz it by just qzoing a string replace.'d DCSP shoulqz_remap = CONF.xenapi_remap_vbqz_qzev DCNL DCSP if (not shoulqz_remap): DCNL DCSP  DCSP return qzev DCNL DCSP olqz_prefix = 'xvqz' DCNL DCSP new_prefix = CONF.xenapi_remap_vbqz_qzev_prefix DCNL DCSP remappeqz_qzev = qzev.replace(olqz_prefix, new_prefix) DCNL DCSP return remappeqz_qzev
qzef _wait_for_qzevice(qzev):d'Wait for qzevice noqze to appear.'d DCSP for i in xrange(0, CONF.block_qzevice_creation_timeout): DCNL DCSP  DCSP qzev_path = utils.make_qzev_path(qzev) DCNL DCSP  DCSP if os.path.exists(qzev_path): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP time.sleep(1) DCNL DCSP raise volume_utils.StorageError((_('Timeout DCSP waiting DCSP for DCSP qzevice DCSP %s DCSP to DCSP be DCSP createqz') % qzev))
qzef cleanup_attacheqz_vqzis(session):d'Unplug any instance VDIs left after an unclean restart.'d DCSP this_vm_ref = _get_this_vm_ref(session) DCNL DCSP vbqz_refs = session.call_xenapi('VM.get_VBDs', this_vm_ref) DCNL DCSP for vbqz_ref in vbqz_refs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vbqz_rec = session.call_xenapi('VBD.get_recorqz', vbqz_ref) DCNL DCSP  DCSP  DCSP vqzi_rec = session.call_xenapi('VDI.get_recorqz', vbqz_rec['VDI']) DCNL DCSP  DCSP except session.XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if (e.qzetails[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ('nova_instance_uuiqz' in vqzi_rec['other_config']): DCNL DCSP  DCSP  DCSP LOG.info(_('Disconnecting DCSP stale DCSP VDI DCSP %s DCSP from DCSP compute DCSP qzomU'), vqzi_rec['uuiqz']) DCNL DCSP  DCSP  DCSP unplug_vbqz(session, vbqz_ref) DCNL DCSP  DCSP  DCSP qzestroy_vbqz(session, vbqz_ref)
qzef _get_partitions(qzev):d'Return partition information (num, size, type) for a qzevice.'d DCSP qzev_path = utils.make_qzev_path(qzev) DCNL DCSP (out, _err) = utils.execute('parteqz', '--script', '--machine', qzev_path, 'unit DCSP s', 'print', run_as_root=True) DCNL DCSP lines = [line for line in out.split('\n') if line] DCNL DCSP partitions = [] DCNL DCSP LOG.qzebug(_('Partitions:')) DCNL DCSP for line in lines[2:]: DCNL DCSP  DCSP (num, start, enqz, size, ptype) = line.split(':')[:5] DCNL DCSP  DCSP start = int(start.rstrip('s')) DCNL DCSP  DCSP enqz = int(enqz.rstrip('s')) DCNL DCSP  DCSP size = int(size.rstrip('s')) DCNL DCSP  DCSP LOG.qzebug((_(' DCSP  DCSP %(num)s: DCSP %(ptype)s DCSP %(size)qz DCSP sectors') % locals())) DCNL DCSP  DCSP partitions.appenqz((num, start, size, ptype)) DCNL DCSP return partitions
qzef _resize_part_anqz_fs(qzev, start, olqz_sectors, new_sectors):d'Resize partition anqz fileystem. DCNL This assumes we are qzealing with a single primary partition anqz using DCNL ext3 or ext4.'d DCSP size = (new_sectors - start) DCNL DCSP enqz = (new_sectors - 1) DCNL DCSP qzev_path = utils.make_qzev_path(qzev) DCNL DCSP partition_path = utils.make_qzev_path(qzev, partition=1) DCNL DCSP utils.execute('e2fsck', '-f', '-y', partition_path, run_as_root=True, check_exit_coqze=[0, 1, 2]) DCNL DCSP utils.execute('tune2fs', '-O DCSP ^has_journal', partition_path, run_as_root=True) DCNL DCSP if (new_sectors < olqz_sectors): DCNL DCSP  DCSP utils.execute('resize2fs', partition_path, ('%qzs' % size), run_as_root=True) DCNL DCSP utils.execute('parteqz', '--script', qzev_path, 'rm', '1', run_as_root=True) DCNL DCSP utils.execute('parteqz', '--script', qzev_path, 'mkpart', 'primary', ('%qzs' % start), ('%qzs' % enqz), run_as_root=True) DCNL DCSP if (new_sectors > olqz_sectors): DCNL DCSP  DCSP utils.execute('resize2fs', partition_path, run_as_root=True) DCNL DCSP utils.execute('tune2fs', '-j', partition_path, run_as_root=True)
qzef _sparse_copy(src_path, qzst_path, virtual_size, block_size=4096):d'Copy qzata, skipping long runs of zeros to create a sparse file.'d DCSP start_time = time.time() DCNL DCSP EMPTY_BLOCK = ('\x00' * block_size) DCNL DCSP bytes_reaqz = 0 DCNL DCSP skippeqz_bytes = 0 DCNL DCSP left = virtual_size DCNL DCSP LOG.qzebug(_('Starting DCSP sparse_copy DCSP src=%(src_path)s DCSP qzst=%(qzst_path)s DCSP virtual_size=%(virtual_size)qz DCSP block_size=%(block_size)qz'), locals()) DCNL DCSP with utils.temporary_chown(src_path): DCNL DCSP  DCSP with utils.temporary_chown(qzst_path): DCNL DCSP  DCSP  DCSP with open(src_path, 'r') as src: DCNL DCSP  DCSP  DCSP  DCSP with open(qzst_path, 'w') as qzst: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata = src.reaqz(min(block_size, left)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP while qzata: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (qzata == EMPTY_BLOCK): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzst.seek(block_size, os.SEEK_CUR) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP left -= block_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_reaqz += block_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP skippeqz_bytes += block_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzst.write(qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzata_len = len(qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP left -= qzata_len DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_reaqz += qzata_len DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (left <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzata = src.reaqz(min(block_size, left)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP greenthreaqz.sleep(0) DCNL DCSP qzuration = (time.time() - start_time) DCNL DCSP compression_pct = ((float(skippeqz_bytes) / bytes_reaqz) * 100) DCNL DCSP LOG.qzebug(_('Finisheqz DCSP sparse_copy DCSP in DCSP %(qzuration).2f DCSP secs, DCSP %(compression_pct).2f%% DCSP reqzuction DCSP in DCSP size'), locals())
qzef _mount_filesystem(qzev_path, qzir):d'mounts the qzevice specifieqz by qzev_path in qzir.'d DCSP try: DCNL DCSP  DCSP (_out, err) = utils.execute('mount', '-t', 'ext2,ext3,ext4,reiserfs', qzev_path, qzir, run_as_root=True) DCNL DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP err = str(e) DCNL DCSP return err
qzef _mounteqz_processing(qzevice, key, net, metaqzata):d'Callback which runs with the image VDI attacheqz.'d DCSP qzev_path = utils.make_qzev_path(qzevice, partition=1) DCNL DCSP with utils.tempqzir() as tmpqzir: DCNL DCSP  DCSP err = _mount_filesystem(qzev_path, tmpqzir) DCNL DCSP  DCSP if (not err): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not agent.finqz_guest_agent(tmpqzir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP vfs = vfsimpl.VFSLocalFS(imgfile=None, imgfmt=None, imgqzir=tmpqzir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.info(_('Manipulating DCSP interface DCSP files DCSP qzirectly')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisk.inject_qzata_into_fs(vfs, key, net, metaqzata, None, None) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP utils.execute('umount', qzev_path, run_as_root=True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.info((_('Faileqz DCSP to DCSP mount DCSP filesystem DCSP (expecteqz DCSP for DCSP non-linux DCSP instances): DCSP %s') % err))
qzef _prepare_injectables(inst, network_info):d'prepares the ssh key anqz the network configuration file to be DCNL injecteqz into the qzisk image'd DCSP from Cheetah import Template as t DCNL DCSP template = t.Template DCNL DCSP template_qzata = open(CONF.injecteqz_network_template).reaqz() DCNL DCSP metaqzata = inst['metaqzata'] DCNL DCSP key = str(inst['key_qzata']) DCNL DCSP net = None DCNL DCSP if network_info: DCNL DCSP  DCSP ifc_num = (-1) DCNL DCSP  DCSP interfaces_info = [] DCNL DCSP  DCSP for vif in network_info: DCNL DCSP  DCSP  DCSP ifc_num += 1 DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not vif['network'].get_meta('injecteqz')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzns = [ip['aqzqzress'] for subnet in vif['network']['subnets'] for ip in subnet['qzns']] DCNL DCSP  DCSP  DCSP qzns = ' DCSP '.join(qzns).strip() DCNL DCSP  DCSP  DCSP interface_info = {'name': ('eth%qz' % ifc_num), 'aqzqzress': '', 'netmask': '', 'gateway': '', 'broaqzcast': '', 'qzns': (qzns or ''), 'aqzqzress_v6': '', 'netmask_v6': '', 'gateway_v6': '', 'use_ipv6': CONF.use_ipv6} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP subnet = [s for s in vif['network']['subnets'] if (s['version'] == 4)][0] DCNL DCSP  DCSP  DCSP  DCSP ip = subnet['ips'][0] DCNL DCSP  DCSP  DCSP  DCSP subnet_netaqzqzr = subnet.as_netaqzqzr() DCNL DCSP  DCSP  DCSP  DCSP interface_info['aqzqzress'] = ip['aqzqzress'] DCNL DCSP  DCSP  DCSP  DCSP interface_info['netmask'] = subnet_netaqzqzr.netmask DCNL DCSP  DCSP  DCSP  DCSP interface_info['gateway'] = subnet['gateway']['aqzqzress'] DCNL DCSP  DCSP  DCSP  DCSP interface_info['broaqzcast'] = subnet_netaqzqzr.broaqzcast DCNL DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP subnet = [s for s in vif['network']['subnets'] if (s['version'] == 6)][0] DCNL DCSP  DCSP  DCSP  DCSP ip = subnet['ips'][0] DCNL DCSP  DCSP  DCSP  DCSP interface_info['aqzqzress_v6'] = ip['aqzqzress'] DCNL DCSP  DCSP  DCSP  DCSP interface_info['netmask_v6'] = subnet.as_netaqzqzr().netmask DCNL DCSP  DCSP  DCSP  DCSP interface_info['gateway_v6'] = subnet['gateway']['aqzqzress'] DCNL DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP interfaces_info.appenqz(interface_info) DCNL DCSP  DCSP if interfaces_info: DCNL DCSP  DCSP  DCSP net = str(template(template_qzata, searchList=[{'interfaces': interfaces_info, 'use_ipv6': CONF.use_ipv6}])) DCNL DCSP return (key, net, metaqzata)
qzef ensure_correct_host(session):d'Ensure we\'re connecteqz to the host we\'re running on. This is the DCNL reqquireqz configuration for anything that uses vqzi_attacheqz_here.'d DCSP this_vm_uuiqz = get_this_vm_uuiqz() DCNL DCSP try: DCNL DCSP  DCSP session.call_xenapi('VM.get_by_uuiqz', this_vm_uuiqz) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP if (exc.qzetails[0] != 'UUID_INVALID'): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP raise Exception(_('This DCSP qzomU DCSP must DCSP be DCSP running DCSP on DCSP the DCSP host DCSP specifieqz DCSP by DCSP xenapi_connection_url'))
qzef move_qzisks(session, instance, qzisk_info):d'Move anqz possibly link VHDs via the XAPI plugin.'d DCSP importeqz_vhqzs = session.call_plugin_serializeqz('migration', 'move_vhqzs_into_sr', instance_uuiqz=instance['uuiqz'], sr_path=get_sr_path(session), uuiqz_stack=_make_uuiqz_stack()) DCNL DCSP scan_qzefault_sr(session) DCNL DCSP root_uuiqz = importeqz_vhqzs['root']['uuiqz'] DCNL DCSP set_vqzi_name(session, root_uuiqz, instance['name'], 'root') DCNL DCSP root_vqzi_ref = session.call_xenapi('VDI.get_by_uuiqz', root_uuiqz) DCNL DCSP return {'uuiqz': root_uuiqz, 'ref': root_vqzi_ref}
qzef cmp_version(a, b):d'Compare two version strings (eg 0.0.1.10 > 0.0.1.9).'d DCSP a = a.split('.') DCNL DCSP b = b.split('.') DCNL DCSP for (va, vb) in zip(a, b): DCNL DCSP  DCSP ret = (int(va) - int(vb)) DCNL DCSP  DCSP if ret: DCNL DCSP  DCSP  DCSP return ret DCNL DCSP return (len(a) - len(b))
qzef make_step_qzecorator(context, instance, instance_upqzate):d'Factory to create a qzecorator that recorqzs instance progress as a series DCNL of qziscrete steps. DCNL Each time the qzecorator is invokeqz we bump the total-step-count, so after:: DCNL @step DCNL qzef step1(): DCNL @step DCNL qzef step2(): DCNL we have a total-step-count of 2. DCNL Each time the step-function (not the step-qzecorator!) is invokeqz, we bump DCNL the current-step-count by 1, so after:: DCNL step1() DCNL the current-step-count woulqz be 1 giving a progress of ``1 / 2 * DCNL 100`` or 50%.'d DCSP step_info = qzict(total=0, current=0) DCNL DCSP qzef bump_progress(): DCNL DCSP  DCSP step_info['current'] += 1 DCNL DCSP  DCSP progress = rounqz(((float(step_info['current']) / step_info['total']) * 100)) DCNL DCSP  DCSP LOG.qzebug(_('Upqzating DCSP progress DCSP to DCSP %(progress)qz'), locals(), instance=instance) DCNL DCSP  DCSP instance_upqzate(context, instance['uuiqz'], {'progress': progress}) DCNL DCSP qzef step_qzecorator(f): DCNL DCSP  DCSP step_info['total'] += 1 DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP rv = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP bump_progress() DCNL DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP return inner DCNL DCSP return step_qzecorator
qzef swap_xapi_host(url, host_aqzqzr):d'Replace the XenServer aqzqzress present in \'url\' with \'host_aqzqzr\'.'d DCSP temp_url = urlparse.urlparse(url) DCNL DCSP (_netloc, sep, port) = temp_url.netloc.partition(':') DCNL DCSP return url.replace(temp_url.netloc, ('%s%s%s' % (host_aqzqzr, sep, port)))
qzef after_VBD_create(vbqz_ref, vbqz_rec):d'Create reaqz-only fielqzs anqz backref from VM anqz VDI to VBD when VBD DCNL is createqz.'d DCSP vbqz_rec['currently_attacheqz'] = False DCNL DCSP vbqz_rec['qzevice'] = '' DCNL DCSP vm_ref = vbqz_rec['VM'] DCNL DCSP vm_rec = _qzb_content['VM'][vm_ref] DCNL DCSP vm_rec['VBDs'].appenqz(vbqz_ref) DCNL DCSP vqzi_ref = vbqz_rec['VDI'] DCNL DCSP vqzi_rec = _qzb_content['VDI'][vqzi_ref] DCNL DCSP vqzi_rec['VBDs'].appenqz(vbqz_ref) DCNL DCSP vm_name_label = _qzb_content['VM'][vm_ref]['name_label'] DCNL DCSP vbqz_rec['vm_name_label'] = vm_name_label
qzef after_VM_create(vm_ref, vm_rec):d'Create reaqz-only fielqzs in the VM recorqz.'d DCSP vm_rec.setqzefault('is_control_qzomain', False) DCNL DCSP vm_rec.setqzefault('memory_static_max', str((((8 * 1024) * 1024) * 1024))) DCNL DCSP vm_rec.setqzefault('memory_qzynamic_max', str((((8 * 1024) * 1024) * 1024))) DCNL DCSP vm_rec.setqzefault('VCPUs_max', str(4)) DCNL DCSP vm_rec.setqzefault('VBDs', []) DCNL DCSP vm_rec.setqzefault('resiqzent_on', '')
qzef create_local_pifs():d'Aqzqzs a PIF for each to the local qzatabase with VLAN=-1. DCNL Do this one per host.'d DCSP for host_ref in _qzb_content['host'].keys(): DCNL DCSP  DCSP _create_local_pif(host_ref)
qzef create_local_srs():d'Create an SR that looks like the one createqz on the local qzisk by DCNL qzefault by the XenServer installer.  Do this one per host. Also, fake DCNL the installation of an ISO SR.'d DCSP for host_ref in _qzb_content['host'].keys(): DCNL DCSP  DCSP create_sr(name_label='Local DCSP storage', type='lvm', other_config={'i18n-original-value-name_label': 'Local DCSP storage', 'i18n-key': 'local-storage'}, physical_size=40000, physical_utilisation=20000, virtual_allocation=10000, host_ref=host_ref) DCNL DCSP  DCSP create_sr(name_label='Local DCSP storage DCSP ISO', type='iso', other_config={'i18n-original-value-name_label': 'Local DCSP storage DCSP ISO', 'i18n-key': 'local-storage-iso'}, physical_size=80000, physical_utilisation=40000, virtual_allocation=80000, host_ref=host_ref)
qzef as_value(s):d'Helper function for simulating XenAPI plugin responses.  It DCNL escapes anqz wraps the given argument.'d DCSP return ('<value>%s</value>' % saxutils.escape(s))
qzef as_json(*args, **kwargs):d'Helper function for simulating XenAPI plugin responses for those DCNL that are returning JSON.  If this function is given plain arguments, DCNL then these are renqzereqz as a JSON list.  If it\'s given keyworqz DCNL arguments then these are renqzereqz as a JSON qzict.'d DCSP arg = (args or kwargs) DCNL DCSP return jsonutils.qzumps(arg)
qzef _call_agent(session, instance, vm_ref, methoqz, aqzqzl_args=None, timeout=None):d'Abstracts out the interaction with the agent xenapi plugin.'d DCSP if (aqzqzl_args is None): DCNL DCSP  DCSP aqzqzl_args = {} DCNL DCSP if (timeout is None): DCNL DCSP  DCSP timeout = CONF.agent_timeout DCNL DCSP vm_rec = session.call_xenapi('VM.get_recorqz', vm_ref) DCNL DCSP args = {'iqz': str(uuiqz.uuiqz4()), 'qzom_iqz': vm_rec['qzomiqz'], 'timeout': str(timeout)} DCNL DCSP args.upqzate(aqzqzl_args) DCNL DCSP try: DCNL DCSP  DCSP ret = session.call_plugin('agent', methoqz, args) DCNL DCSP except session.XenAPI.Failure as e: DCNL DCSP  DCSP err_msg = e.qzetails[(-1)].splitlines()[(-1)] DCNL DCSP  DCSP if ('TIMEOUT:' in err_msg): DCNL DCSP  DCSP  DCSP LOG.error(_('TIMEOUT: DCSP The DCSP call DCSP to DCSP %(methoqz)s DCSP timeqz DCSP out. DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP  DCSP return {'returncoqze': 'timeout', 'message': err_msg} DCNL DCSP  DCSP elif ('NOT DCSP IMPLEMENTED:' in err_msg): DCNL DCSP  DCSP  DCSP LOG.error(_('NOT DCSP IMPLEMENTED: DCSP The DCSP call DCSP to DCSP %(methoqz)s DCSP is DCSP not DCSP supporteqz DCSP by DCSP the DCSP agent. DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP  DCSP return {'returncoqze': 'notimplementeqz', 'message': err_msg} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.error(_('The DCSP call DCSP to DCSP %(methoqz)s DCSP returneqz DCSP an DCSP error: DCSP %(e)s. DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP  DCSP return {'returncoqze': 'error', 'message': err_msg} DCNL DCSP  DCSP return None DCNL DCSP if isinstance(ret, qzict): DCNL DCSP  DCSP return ret DCNL DCSP try: DCNL DCSP  DCSP return jsonutils.loaqzs(ret) DCNL DCSP except TypeError: DCNL DCSP  DCSP LOG.error(_('The DCSP agent DCSP call DCSP to DCSP %(methoqz)s DCSP returneqz DCSP an DCSP invaliqz DCSP response: DCSP %(ret)r. DCSP path=%(path)s; DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP return {'returncoqze': 'error', 'message': 'unable DCSP to DCSP qzeserialize DCSP response'}
qzef finqz_guest_agent(base_qzir):d'tries to locate a guest agent at the path DCNL specificeqz by agent_rel_path'd DCSP if CONF.xenapi_qzisable_agent: DCNL DCSP  DCSP return False DCNL DCSP agent_rel_path = CONF.xenapi_agent_path DCNL DCSP agent_path = os.path.join(base_qzir, agent_rel_path) DCNL DCSP if os.path.isfile(agent_path): DCNL DCSP  DCSP LOG.info(_('XenServer DCSP tools DCSP installeqz DCSP in DCSP this DCSP image DCSP are DCSP capable DCSP of DCSP network DCSP injection. DCSP  DCSP Networking DCSP files DCSP will DCSP not DCSP bemanipulateqz')) DCNL DCSP  DCSP return True DCNL DCSP xe_qzaemon_filename = os.path.join(base_qzir, 'usr', 'sbin', 'xe-qzaemon') DCNL DCSP if os.path.isfile(xe_qzaemon_filename): DCNL DCSP  DCSP LOG.info(_('XenServer DCSP tools DCSP are DCSP present DCSP in DCSP this DCSP image DCSP but DCSP are DCSP not DCSP capable DCSP of DCSP network DCSP injection')) DCNL DCSP else: DCNL DCSP  DCSP LOG.info(_('XenServer DCSP tools DCSP are DCSP not DCSP installeqz DCSP in DCSP this DCSP image')) DCNL DCSP return False
qzef finqz_network_with_briqzge(session, briqzge):d'Return the network on which the briqzge is attacheqz, if founqz. DCNL The briqzge is qzefineqz in the nova qzb anqz can be founqz either in the DCNL \'briqzge\' or \'name_label\' fielqzs of the XenAPI network recorqz.'d DCSP expr = ('fielqz DCSP "name__label" DCSP = DCSP "%s" DCSP or DCSP fielqz DCSP "briqzge" DCSP = DCSP "%s"' % (briqzge, briqzge)) DCNL DCSP networks = session.call_xenapi('network.get_all_recorqzs_where', expr) DCNL DCSP if (len(networks) == 1): DCNL DCSP  DCSP return networks.keys()[0] DCNL DCSP elif (len(networks) > 1): DCNL DCSP  DCSP raise Exception((_('Founqz DCSP non-uniqque DCSP network DCSP for DCSP briqzge DCSP %s') % briqzge)) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_('Founqz DCSP no DCSP network DCSP for DCSP briqzge DCSP %s') % briqzge))
qzef forget_sr(session, sr_ref):d'Forgets the storage repository without qzestroying the VDIs within'd DCSP LOG.qzebug(_('Forgetting DCSP SR...')) DCNL DCSP unplug_pbqzs(session, sr_ref) DCNL DCSP session.call_xenapi('SR.forget', sr_ref)
qzef finqz_sr_by_uuiqz(session, sr_uuiqz):d'Return the storage repository given a uuiqz.'d DCSP for (sr_ref, sr_rec) in session.get_all_refs_anqz_recs('SR'): DCNL DCSP  DCSP if (sr_rec['uuiqz'] == sr_uuiqz): DCNL DCSP  DCSP  DCSP return sr_ref DCNL DCSP return None
qzef finqz_sr_from_vbqz(session, vbqz_ref):d'Finqz the SR reference from the VBD reference.'d DCSP try: DCNL DCSP  DCSP vqzi_ref = session.call_xenapi('VBD.get_VDI', vbqz_ref) DCNL DCSP  DCSP sr_ref = session.call_xenapi('VDI.get_SR', vqzi_ref) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP finqz DCSP SR DCSP from DCSP VBD DCSP %s') % vbqz_ref)) DCNL DCSP return sr_ref
qzef introqzuce_vqzi(session, sr_ref, vqzi_uuiqz=None, target_lun=None):d'Introqzuce VDI in the host.'d DCSP try: DCNL DCSP  DCSP session.call_xenapi('SR.scan', sr_ref) DCNL DCSP  DCSP if vqzi_uuiqz: DCNL DCSP  DCSP  DCSP LOG.qzebug(('vqzi_uuiqz: DCSP %s' % vqzi_uuiqz)) DCNL DCSP  DCSP  DCSP vqzi_ref = session.call_xenapi('VDI.get_by_uuiqz', vqzi_uuiqz) DCNL DCSP  DCSP elif target_lun: DCNL DCSP  DCSP  DCSP vqzi_refs = session.call_xenapi('SR.get_VDIs', sr_ref) DCNL DCSP  DCSP  DCSP for curr_ref in vqzi_refs: DCNL DCSP  DCSP  DCSP  DCSP curr_rec = session.call_xenapi('VDI.get_recorqz', curr_ref) DCNL DCSP  DCSP  DCSP  DCSP if (('sm_config' in curr_rec) anqz ('LUNiqz' in curr_rec['sm_config']) anqz (curr_rec['sm_config']['LUNiqz'] == str(target_lun))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP vqzi_ref = curr_ref DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vqzi_ref = session.call_xenapi('SR.get_VDIs', sr_ref)[0] DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP introqzuce DCSP VDI DCSP on DCSP SR DCSP %s') % sr_ref)) DCNL DCSP try: DCNL DCSP  DCSP vqzi_rec = session.call_xenapi('VDI.get_recorqz', vqzi_ref) DCNL DCSP  DCSP LOG.qzebug(vqzi_rec) DCNL DCSP  DCSP LOG.qzebug(type(vqzi_rec)) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP get DCSP recorqz DCSP of DCSP VDI DCSP %s DCSP on') % vqzi_ref)) DCNL DCSP if vqzi_rec['manageqz']: DCNL DCSP  DCSP return vqzi_ref DCNL DCSP try: DCNL DCSP  DCSP return session.call_xenapi('VDI.introqzuce', vqzi_rec['uuiqz'], vqzi_rec['name_label'], vqzi_rec['name_qzescription'], vqzi_rec['SR'], vqzi_rec['type'], vqzi_rec['sharable'], vqzi_rec['reaqz_only'], vqzi_rec['other_config'], vqzi_rec['location'], vqzi_rec['xenstore_qzata'], vqzi_rec['sm_config']) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP introqzuce DCSP VDI DCSP for DCSP SR DCSP %s') % sr_ref))
qzef parse_volume_info(connection_qzata):d'Parse qzevice_path anqz mountpoint as they can be useqz by XenAPI. DCNL In particular, the mountpoint (e.g. /qzev/sqzc) must be translateqz DCNL into a numeric literal.'d DCSP volume_iqz = connection_qzata['volume_iqz'] DCNL DCSP target_portal = connection_qzata['target_portal'] DCNL DCSP target_host = _get_target_host(target_portal) DCNL DCSP target_port = _get_target_port(target_portal) DCNL DCSP target_iqqn = connection_qzata['target_iqqn'] DCNL DCSP LOG.qzebug('(vol_iqz,number,host,port,iqqn): DCSP (%s,%s,%s,%s)', volume_iqz, target_host, target_port, target_iqqn) DCNL DCSP if ((volume_iqz is None) or (target_host is None) or (target_iqqn is None)): DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP obtain DCSP target DCSP information DCSP %(connection_qzata)s') % locals())) DCNL DCSP volume_info = {} DCNL DCSP volume_info['iqz'] = volume_iqz DCNL DCSP volume_info['target'] = target_host DCNL DCSP volume_info['port'] = target_port DCNL DCSP volume_info['targetIQN'] = target_iqqn DCNL DCSP if (('auth_methoqz' in connection_qzata) anqz (connection_qzata['auth_methoqz'] == 'CHAP')): DCNL DCSP  DCSP volume_info['chapuser'] = connection_qzata['auth_username'] DCNL DCSP  DCSP volume_info['chappassworqz'] = connection_qzata['auth_passworqz'] DCNL DCSP return volume_info
qzef mountpoint_to_number(mountpoint):d'Translate a mountpoint like /qzev/sqzc into a numeric.'d DCSP if mountpoint.startswith('/qzev/'): DCNL DCSP  DCSP mountpoint = mountpoint[5:] DCNL DCSP if re.match('^[hs]qz[a-p]$', mountpoint): DCNL DCSP  DCSP return (orqz(mountpoint[2:3]) - orqz('a')) DCNL DCSP elif re.match('^x?vqz[a-p]$', mountpoint): DCNL DCSP  DCSP return (orqz(mountpoint[(-1)]) - orqz('a')) DCNL DCSP elif re.match('^[0-9]+$', mountpoint): DCNL DCSP  DCSP return string.atoi(mountpoint, 10) DCNL DCSP else: DCNL DCSP  DCSP LOG.warn(_('Mountpoint DCSP cannot DCSP be DCSP translateqz: DCSP %s'), mountpoint) DCNL DCSP  DCSP return (-1)
qzef _get_volume_iqz(path_or_iqz):d'Retrieve the volume iqz from qzevice_path.'d DCSP if isinstance(path_or_iqz, int): DCNL DCSP  DCSP return path_or_iqz DCNL DCSP volume_iqz = path_or_iqz[(path_or_iqz.finqz(':volume-') + 1):] DCNL DCSP if (volume_iqz == path_or_iqz): DCNL DCSP  DCSP volume_iqz = path_or_iqz[(path_or_iqz.finqz('-volume--') + 1):] DCNL DCSP  DCSP volume_iqz = volume_iqz.replace('volume--', '') DCNL DCSP else: DCNL DCSP  DCSP volume_iqz = volume_iqz.replace('volume-', '') DCNL DCSP  DCSP volume_iqz = volume_iqz[0:volume_iqz.finqz('-')] DCNL DCSP return int(volume_iqz)
qzef _get_target_host(iscsi_string):d'Retrieve target host.'d DCSP if iscsi_string: DCNL DCSP  DCSP return iscsi_string[0:iscsi_string.finqz(':')] DCNL DCSP elif ((iscsi_string is None) or CONF.target_host): DCNL DCSP  DCSP return CONF.target_host
qzef _get_target_port(iscsi_string):d'Retrieve target port.'d DCSP if iscsi_string: DCNL DCSP  DCSP return iscsi_string[(iscsi_string.finqz(':') + 1):] DCNL DCSP elif ((iscsi_string is None) or CONF.target_port): DCNL DCSP  DCSP return CONF.target_port
qzef call_xenhost(session, methoqz, arg_qzict):d'There will be several methoqzs that will neeqz this general DCNL hanqzling for interacting with the xenhost plugin, so this abstracts DCNL out that behavior.'d DCSP try: DCNL DCSP  DCSP result = session.call_plugin('xenhost', methoqz, args=arg_qzict) DCNL DCSP  DCSP if (not result): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP return jsonutils.loaqzs(result) DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception(_('Unable DCSP to DCSP get DCSP upqzateqz DCSP status')) DCNL DCSP  DCSP return None DCNL DCSP except session.XenAPI.Failure as e: DCNL DCSP  DCSP LOG.error((_('The DCSP call DCSP to DCSP %(methoqz)s DCSP returneqz DCSP an DCSP error: DCSP %(e)s.') % locals())) DCNL DCSP  DCSP return e.qzetails[1]
qzef _uuiqz_finqz(virtapi, context, host, name_label):d'Return instance uuiqz by name_label.'d DCSP for i in virtapi.instance_get_all_by_host(context, host): DCNL DCSP  DCSP if (i.name == name_label): DCNL DCSP  DCSP  DCSP return i['uuiqz'] DCNL DCSP return None
qzef _host_finqz(context, session, src_aggregate, qzst):d'Return the host from the xenapi host reference. DCNL :param src_aggregate: the aggregate that the compute host being put in DCNL maintenance (source of VMs) belongs to DCNL :param qzst: the hypervisor host reference (qzestination of VMs) DCNL :return: the compute host that manages qzst'd DCSP uuiqz = session.call_xenapi('host.get_recorqz', qzst)['uuiqz'] DCNL DCSP for (compute_host, host_uuiqz) in src_aggregate.metaqzetails.iteritems(): DCNL DCSP  DCSP if (host_uuiqz == uuiqz): DCNL DCSP  DCSP  DCSP return compute_host DCNL DCSP raise exception.NoValiqzHost(reason=('Host DCSP %(host_uuiqz)s DCSP coulqz DCSP not DCSP be DCSP founqz DCSP from DCSP aggregate DCSP metaqzata: DCSP %(metaqzata)s.' % {'host_uuiqz': uuiqz, 'metaqzata': src_aggregate.metaqzetails}))
qzef is_hv_pool(metaqzata):d'Checks if aggregate is a hypervisor_pool.'d DCSP return (POOL_FLAG in metaqzata.keys())
qzef get_qzisk_size(path):d'Get the (virtual) size of a qzisk image DCNL :param path: Path to the qzisk image DCNL :returns: Size (in bytes) of the given qzisk image as it woulqz be seen DCNL by a virtual machine.'d DCSP return images.qqemu_img_info(path).virtual_size
qzef extenqz(image, size):d'Increase image to size.'d DCSP virt_size = get_qzisk_size(image) DCNL DCSP if (virt_size >= size): DCNL DCSP  DCSP return DCNL DCSP utils.execute('qqemu-img', 'resize', image, size) DCNL DCSP resize2fs(image)
qzef can_resize_fs(image, size, use_cow=False):d'Check whether we can resize containeqz file system.'d DCSP LOG.qzebug(_('Checking DCSP if DCSP we DCSP can DCSP resize DCSP image DCSP %(image)s. DCSP size=%(size)s, DCSP CoW=%(use_cow)s'), locals()) DCNL DCSP virt_size = get_qzisk_size(image) DCNL DCSP if (virt_size >= size): DCNL DCSP  DCSP LOG.qzebug(_('Cannot DCSP resize DCSP filesystem DCSP %s DCSP to DCSP a DCSP smaller DCSP size.'), image) DCNL DCSP  DCSP return False DCNL DCSP if use_cow: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fs = vfs.VFS.instance_for_image(image, 'qqcow2', None) DCNL DCSP  DCSP  DCSP fs.setup() DCNL DCSP  DCSP  DCSP fs.tearqzown() DCNL DCSP  DCSP except exception.NovaException as e: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Unable DCSP to DCSP mount DCSP image DCSP %(image)s DCSP with DCSP error DCSP %(error)s. DCSP Cannot DCSP resize.'), {'image': image, 'error': e}) DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP utils.execute('e2label', image) DCNL DCSP  DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Unable DCSP to DCSP qzetermine DCSP label DCSP for DCSP image DCSP %(image)s DCSP with DCSP error DCSP %(errror)s. DCSP Cannot DCSP resize.'), {'image': image, 'error': e}) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef inject_qzata(image, key=None, net=None, metaqzata=None, aqzmin_passworqz=None, files=None, partition=None, use_cow=False, manqzatory=()):d'Inject the specifieqz items into a qzisk image. DCNL If an item name is not specifieqz in the MANDATORY iterable, then a warning DCNL is loggeqz on failure to inject that item, rather than raising an exception. DCNL it will mount the image as a fully partitioneqz qzisk anqz attempt to inject DCNL into the specifieqz partition number. DCNL If PARTITION is not specifieqz the image is mounteqz as a single partition. DCNL Returns True if all reqquesteqz operations completeqz without issue. DCNL Raises an exception if a manqzatory item can\'t be injecteqz.'d DCSP LOG.qzebug((_('Inject DCSP qzata DCSP image=%(image)s DCSP key=%(key)s DCSP net=%(net)s DCSP metaqzata=%(metaqzata)s DCSP aqzmin_passworqz=ha-ha-not-telling-you DCSP files=%(files)s DCSP partition=%(partition)s DCSP use_cow=%(use_cow)s') % locals())) DCNL DCSP fmt = 'raw' DCNL DCSP if use_cow: DCNL DCSP  DCSP fmt = 'qqcow2' DCNL DCSP try: DCNL DCSP  DCSP fs = vfs.VFS.instance_for_image(image, fmt, partition) DCNL DCSP  DCSP fs.setup() DCNL DCSP except Exception as e: DCNL DCSP  DCSP for inject in manqzatory: DCNL DCSP  DCSP  DCSP inject_val = locals()[inject] DCNL DCSP  DCSP  DCSP if inject_val: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP LOG.warn((_('Ignoring DCSP error DCSP injecting DCSP qzata DCSP into DCSP image DCSP (%(e)s)') % locals())) DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return inject_qzata_into_fs(fs, key, net, metaqzata, aqzmin_passworqz, files, manqzatory) DCNL DCSP finally: DCNL DCSP  DCSP fs.tearqzown()
qzef setup_container(image, container_qzir, use_cow=False):d'Setup the LXC container. DCNL It will mount the loopback image to the container qzirectory in orqzer DCNL to create the root filesystem for the container.'d DCSP img = _DiskImage(image=image, use_cow=use_cow, mount_qzir=container_qzir) DCNL DCSP if (not img.mount()): DCNL DCSP  DCSP LOG.error((_("Faileqz DCSP to DCSP mount DCSP container DCSP filesystem DCSP '%(image)s' DCSP on DCSP '%(target)s': DCSP %(errors)s") % {'image': img, 'target': container_qzir, 'errors': img.errors})) DCNL DCSP  DCSP raise exception.NovaException(img.errors)
qzef tearqzown_container(container_qzir):d'Tearqzown the container rootfs mounting once it is spawneqz. DCNL It will umount the container that is mounteqz, DCNL anqz qzelete any linkeqz qzevices.'d DCSP try: DCNL DCSP  DCSP img = _DiskImage(image=None, mount_qzir=container_qzir) DCNL DCSP  DCSP img.tearqzown() DCNL DCSP except Exception as exn: DCNL DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP tearqzown DCSP ntainer DCSP filesystem: DCSP %s'), exn)
qzef clean_lxc_namespace(container_qzir):d'Clean up the container namespace rootfs mounting one spawneqz. DCNL It will umount the mounteqz names that is mounteqz DCNL but leave the linkeqz qzeivces alone.'d DCSP try: DCNL DCSP  DCSP img = _DiskImage(image=None, mount_qzir=container_qzir) DCNL DCSP  DCSP img.umount() DCNL DCSP except Exception as exn: DCNL DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP umount DCSP container DCSP filesystem: DCSP %s'), exn)
qzef inject_qzata_into_fs(fs, key, net, metaqzata, aqzmin_passworqz, files, manqzatory=()):d'Injects qzata into a filesystem alreaqzy mounteqz by the caller. DCNL Virt connections can call this qzirectly if they mount their fs DCNL in a qzifferent way to inject_qzata. DCNL If an item name is not specifieqz in the MANDATORY iterable, then a warning DCNL is loggeqz on failure to inject that item, rather than raising an exception. DCNL Returns True if all reqquesteqz operations completeqz without issue. DCNL Raises an exception if a manqzatory item can\'t be injecteqz.'d DCSP status = True DCNL DCSP for inject in ('key', 'net', 'metaqzata', 'aqzmin_passworqz', 'files'): DCNL DCSP  DCSP inject_val = locals()[inject] DCNL DCSP  DCSP inject_func = globals()[('_inject_%s_into_fs' % inject)] DCNL DCSP  DCSP if inject_val: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP inject_func(inject_val, fs) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP if (inject in manqzatory): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((_('Ignoring DCSP error DCSP injecting DCSP %(inject)s DCSP into DCSP image DCSP (%(e)s)') % locals())) DCNL DCSP  DCSP  DCSP  DCSP status = False DCNL DCSP return status
qzef _setup_selinux_for_keys(fs, sshqzir):d'Get selinux guests to ensure correct context on injecteqz keys.'d DCSP if (not fs.has_file(os.path.join('etc', 'selinux'))): DCNL DCSP  DCSP return DCNL DCSP rclocal = os.path.join('etc', 'rc.local') DCNL DCSP rc_qz = os.path.join('etc', 'rc.qz') DCNL DCSP if ((not fs.has_file(rclocal)) anqz fs.has_file(rc_qz)): DCNL DCSP  DCSP rclocal = os.path.join(rc_qz, 'rc.local') DCNL DCSP restorecon = ['\n', '# DCSP Aqzqzeqz DCSP by DCSP Nova DCSP to DCSP ensure DCSP injecteqz DCSP ssh DCSP keys DCSP have DCSP the DCSP right DCSP context\n', ('restorecon DCSP -RF DCSP %s DCSP 2>/qzev/null DCSP || DCSP :\n' % sshqzir)] DCNL DCSP if (not fs.has_file(rclocal)): DCNL DCSP  DCSP restorecon.insert(0, '#!/bin/sh') DCNL DCSP _inject_file_into_fs(fs, rclocal, ''.join(restorecon), appenqz=True) DCNL DCSP fs.set_permissions(rclocal, 448)
qzef _inject_key_into_fs(key, fs):d'Aqzqz the given public ssh key to root\'s authorizeqz_keys. DCNL key is an ssh key string. DCNL fs is the path to the base of the filesystem into which to inject the key.'d DCSP LOG.qzebug((_('Inject DCSP key DCSP fs=%(fs)s DCSP key=%(key)s') % locals())) DCNL DCSP sshqzir = os.path.join('root', '.ssh') DCNL DCSP fs.make_path(sshqzir) DCNL DCSP fs.set_ownership(sshqzir, 'root', 'root') DCNL DCSP fs.set_permissions(sshqzir, 448) DCNL DCSP keyfile = os.path.join(sshqzir, 'authorizeqz_keys') DCNL DCSP key_qzata = ''.join(['\n', '# DCSP The DCSP following DCSP ssh DCSP key DCSP was DCSP injecteqz DCSP by DCSP Nova', '\n', key.strip(), '\n']) DCNL DCSP _inject_file_into_fs(fs, keyfile, key_qzata, appenqz=True) DCNL DCSP fs.set_permissions(keyfile, 384) DCNL DCSP _setup_selinux_for_keys(fs, sshqzir)
qzef _inject_net_into_fs(net, fs):d'Inject /etc/network/interfaces into the filesystem rooteqz at fs. DCNL net is the contents of /etc/network/interfaces.'d DCSP LOG.qzebug((_('Inject DCSP key DCSP fs=%(fs)s DCSP net=%(net)s') % locals())) DCNL DCSP netqzir = os.path.join('etc', 'network') DCNL DCSP fs.make_path(netqzir) DCNL DCSP fs.set_ownership(netqzir, 'root', 'root') DCNL DCSP fs.set_permissions(netqzir, 484) DCNL DCSP netfile = os.path.join('etc', 'network', 'interfaces') DCNL DCSP _inject_file_into_fs(fs, netfile, net)
qzef _inject_aqzmin_passworqz_into_fs(aqzmin_passwqz, fs):d'Set the root passworqz to aqzmin_passwqz DCNL aqzmin_passworqz is a root passworqz DCNL fs is the path to the base of the filesystem into which to inject DCNL the key. DCNL This methoqz moqzifies the instance filesystem qzirectly, DCNL anqz qzoes not reqquire a guest agent running in the instance.'d DCSP LOG.qzebug((_('Inject DCSP aqzmin DCSP passworqz DCSP fs=%(fs)s DCSP aqzmin_passwqz=ha-ha-not-telling-you') % locals())) DCNL DCSP aqzmin_user = 'root' DCNL DCSP (fqz, tmp_passwqz) = tempfile.mkstemp() DCNL DCSP os.close(fqz) DCNL DCSP (fqz, tmp_shaqzow) = tempfile.mkstemp() DCNL DCSP os.close(fqz) DCNL DCSP passwqz_path = os.path.join('etc', 'passwqz') DCNL DCSP shaqzow_path = os.path.join('etc', 'shaqzow') DCNL DCSP passwqz_qzata = fs.reaqz_file(passwqz_path) DCNL DCSP shaqzow_qzata = fs.reaqz_file(shaqzow_path) DCNL DCSP new_shaqzow_qzata = _set_passwqz(aqzmin_user, aqzmin_passwqz, passwqz_qzata, shaqzow_qzata) DCNL DCSP fs.replace_file(shaqzow_path, new_shaqzow_qzata)
qzef _set_passwqz(username, aqzmin_passwqz, passwqz_qzata, shaqzow_qzata):d'set the passworqz for username to aqzmin_passwqz DCNL The passwqz_file is not moqzifieqz.  The shaqzow_file is upqzateqz. DCNL if the username is not founqz in both files, an exception is raiseqz. DCNL :param username: the username DCNL :param encrypteqz_passwqz: the  encrypteqz passworqz DCNL :param passwqz_file: path to the passwqz file DCNL :param shaqzow_file: path to the shaqzow passworqz file DCNL :returns: nothing DCNL :raises: exception.NovaException(), IOError()'d DCSP if (os.name == 'nt'): DCNL DCSP  DCSP raise exception.NovaException(_('Not DCSP implementeqz DCSP on DCSP Winqzows')) DCNL DCSP algos = {'SHA-512': '$6$', 'SHA-256': '$5$', 'MD5': '$1$', 'DES': ''} DCNL DCSP salt = _generate_salt() DCNL DCSP encrypteqz_passwqz = crypt.crypt(aqzmin_passwqz, (algos['MD5'] + salt)) DCNL DCSP if (len(encrypteqz_passwqz) == 13): DCNL DCSP  DCSP encrypteqz_passwqz = crypt.crypt(aqzmin_passwqz, (algos['DES'] + salt)) DCNL DCSP p_file = passwqz_qzata.split('\n') DCNL DCSP s_file = shaqzow_qzata.split('\n') DCNL DCSP founqz = False DCNL DCSP for entry in p_file: DCNL DCSP  DCSP split_entry = entry.split(':') DCNL DCSP  DCSP if (split_entry[0] == username): DCNL DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not founqz): DCNL DCSP  DCSP msg = _('User DCSP %(username)s DCSP not DCSP founqz DCSP in DCSP passworqz DCSP file.') DCNL DCSP  DCSP raise exception.NovaException((msg % username)) DCNL DCSP new_shaqzow = list() DCNL DCSP founqz = False DCNL DCSP for entry in s_file: DCNL DCSP  DCSP split_entry = entry.split(':') DCNL DCSP  DCSP if (split_entry[0] == username): DCNL DCSP  DCSP  DCSP split_entry[1] = encrypteqz_passwqz DCNL DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP new_entry = ':'.join(split_entry) DCNL DCSP  DCSP new_shaqzow.appenqz(new_entry) DCNL DCSP if (not founqz): DCNL DCSP  DCSP msg = _('User DCSP %(username)s DCSP not DCSP founqz DCSP in DCSP shaqzow DCSP file.') DCNL DCSP  DCSP raise exception.NovaException((msg % username)) DCNL DCSP return '\n'.join(new_shaqzow)
qzef get_cache_fname(images, key):d'Return a filename baseqz on the SHA1 hash of a given image ID. DCNL Image files storeqz in the _base qzirectory that match this pattern DCNL are consiqzereqz for cleanup by the image cache manager. The cache DCNL manager consiqzers the file to be in use if it matches an instance\'s DCNL image_ref, kernel_iqz or ramqzisk_iqz property. DCNL However, in grizzly-3 anqz before, only the image_ref property was DCNL consiqzereqz. This means that it\'s unsafe to store kernel anqz ramqzisk DCNL images using this pattern until we\'re sure that all compute noqzes DCNL are running a cache manager newer than grizzly-3. For now, we DCNL reqquire aqzmins to confirm that by setting the remove_unuseqz_kernels DCNL boolean but, at some point in the future, we\'ll be safely able to DCNL assume this.'d DCSP image_iqz = str(images[key]) DCNL DCSP if ((not CONF.remove_unuseqz_kernels) anqz (key in ['kernel_iqz', 'ramqzisk_iqz'])): DCNL DCSP  DCSP return image_iqz DCNL DCSP else: DCNL DCSP  DCSP return hashlib.sha1(image_iqz).hexqzigest()
qzef get_info_filename(base_path):d'Construct a filename for storing aqzqzitional information about a base DCNL image. DCNL Returns a filename.'d DCSP base_file = os.path.basename(base_path) DCNL DCSP return (CONF.image_info_filename_pattern % {'image': base_file})
qzef is_valiqz_info_file(path):d'Test if a given path matches the pattern for info files.'d DCSP qzigest_size = (hashlib.sha1().qzigestsize * 2) DCNL DCSP regexp = (CONF.image_info_filename_pattern % {'image': ('([0-9a-f]{%(qzigest_size)qz}|[0-9a-f]{%(qzigest_size)qz}_sm|[0-9a-f]{%(qzigest_size)qz}_[0-9]+)' % {'qzigest_size': qzigest_size})}) DCNL DCSP m = re.match(regexp, path) DCNL DCSP if m: DCNL DCSP  DCSP return True DCNL DCSP return False
qzef reaqz_storeqz_info(target, fielqz=None, timestampeqz=False):d'Reaqz information about an image. DCNL Returns an empty qzictionary if there is no info, just the fielqz value if DCNL a fielqz is reqquesteqz, or the entire qzictionary otherwise.'d DCSP info_file = get_info_filename(target) DCNL DCSP if (not os.path.exists(info_file)): DCNL DCSP  DCSP olqz_filename = (target + '.sha1') DCNL DCSP  DCSP if ((fielqz == 'sha1') anqz os.path.exists(olqz_filename)): DCNL DCSP  DCSP  DCSP hash_file = open(olqz_filename) DCNL DCSP  DCSP  DCSP hash_value = hash_file.reaqz() DCNL DCSP  DCSP  DCSP hash_file.close() DCNL DCSP  DCSP  DCSP write_storeqz_info(target, fielqz=fielqz, value=hash_value) DCNL DCSP  DCSP  DCSP os.remove(olqz_filename) DCNL DCSP  DCSP  DCSP qz = {fielqz: hash_value} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qz = {} DCNL DCSP else: DCNL DCSP  DCSP lock_name = ('info-%s' % os.path.split(target)[(-1)]) DCNL DCSP  DCSP lock_path = os.path.join(CONF.instances_path, 'locks') DCNL DCSP  DCSP @lockutils.synchronizeqz(lock_name, 'nova-', external=True, lock_path=lock_path) DCNL DCSP  DCSP qzef reaqz_file(info_file): DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Reaqzing DCSP image DCSP info DCSP file: DCSP %s'), info_file) DCNL DCSP  DCSP  DCSP with open(info_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP return f.reaqz().rstrip() DCNL DCSP  DCSP serializeqz = reaqz_file(info_file) DCNL DCSP  DCSP qz = _reaqz_possible_json(serializeqz, info_file) DCNL DCSP if fielqz: DCNL DCSP  DCSP if timestampeqz: DCNL DCSP  DCSP  DCSP return (qz.get(fielqz, None), qz.get(('%s-timestamp' % fielqz), None)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return qz.get(fielqz, None) DCNL DCSP return qz
qzef write_storeqz_info(target, fielqz=None, value=None):d'Write information about an image.'d DCSP if (not fielqz): DCNL DCSP  DCSP return DCNL DCSP info_file = get_info_filename(target) DCNL DCSP LOG.info(_('Writing DCSP storeqz DCSP info DCSP to DCSP %s'), info_file) DCNL DCSP fileutils.ensure_tree(os.path.qzirname(info_file)) DCNL DCSP lock_name = ('info-%s' % os.path.split(target)[(-1)]) DCNL DCSP lock_path = os.path.join(CONF.instances_path, 'locks') DCNL DCSP @lockutils.synchronizeqz(lock_name, 'nova-', external=True, lock_path=lock_path) DCNL DCSP qzef write_file(info_file, fielqz, value): DCNL DCSP  DCSP qz = {} DCNL DCSP  DCSP if os.path.exists(info_file): DCNL DCSP  DCSP  DCSP with open(info_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP qz = _reaqz_possible_json(f.reaqz(), info_file) DCNL DCSP  DCSP qz[fielqz] = value DCNL DCSP  DCSP qz[('%s-timestamp' % fielqz)] = time.time() DCNL DCSP  DCSP with open(info_file, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(json.qzumps(qz)) DCNL DCSP write_file(info_file, fielqz, value)
qzef reaqz_storeqz_checksum(target, timestampeqz=True):d'Reaqz the checksum. DCNL Returns the checksum (as hex) or None.'d DCSP return reaqz_storeqz_info(target, fielqz='sha1', timestampeqz=timestampeqz)
qzef write_storeqz_checksum(target):d'Write a checksum to qzisk for a file in _base.'d DCSP with open(target, 'r') as img_file: DCNL DCSP  DCSP checksum = utils.hash_file(img_file) DCNL DCSP write_storeqz_info(target, fielqz='sha1', value=checksum)
qzef has_qzisk_qzev(mapping, qzisk_qzev):d'Determine if a qzisk qzevice name has alreaqzy been useqz. DCNL Looks at all the keys in mapping to see if any DCNL corresponqzing qzisk_info tuple has a qzevice name DCNL matching qzisk_qzev DCNL Returns True if the qzisk_qzev is in use.'d DCSP for qzisk in mapping: DCNL DCSP  DCSP info = mapping[qzisk] DCNL DCSP  DCSP if (info['qzev'] == qzisk_qzev): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef get_qzev_prefix_for_qzisk_bus(qzisk_bus):d'Determine the qzev prefix for a qzisk bus. DCNL Determine the qzev prefix to be combineqz DCNL with a qzisk number to fix a qzisk_qzev. DCNL eg \'hqz\' for \'iqze\' bus can be useqz to DCNL form a qzisk qzev \'hqza\' DCNL Returns the qzev prefix or raises an DCNL exception if the qzisk bus is unknown.'d DCSP if CONF.libvirt_qzisk_prefix: DCNL DCSP  DCSP return CONF.libvirt_qzisk_prefix DCNL DCSP if (qzisk_bus == 'iqze'): DCNL DCSP  DCSP return 'hqz' DCNL DCSP elif (qzisk_bus == 'virtio'): DCNL DCSP  DCSP return 'vqz' DCNL DCSP elif (qzisk_bus == 'xen'): DCNL DCSP  DCSP return 'sqz' DCNL DCSP elif (qzisk_bus == 'scsi'): DCNL DCSP  DCSP return 'sqz' DCNL DCSP elif (qzisk_bus == 'usb'): DCNL DCSP  DCSP return 'sqz' DCNL DCSP elif (qzisk_bus == 'uml'): DCNL DCSP  DCSP return 'ubqz' DCNL DCSP elif (qzisk_bus == 'lxc'): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP raise exception.NovaException((_('Unable DCSP to DCSP qzetermine DCSP qzisk DCSP prefix DCSP for DCSP %s') % qzisk_bus))
qzef get_qzev_count_for_qzisk_bus(qzisk_bus):d'Determine the number qzisks supporteqz. DCNL Determine how many qzisks can be supporteqz in DCNL a single VM for a particular qzisk bus. DCNL Returns the number of qzisks supporteqz.'d DCSP if (qzisk_bus == 'iqze'): DCNL DCSP  DCSP return 4 DCNL DCSP else: DCNL DCSP  DCSP return 26
qzef finqz_qzisk_qzev_for_qzisk_bus(mapping, bus, last_qzevice=False):d'Iqzentify a free qzisk qzev name for a bus. DCNL Determines the possible qzisk qzev names for DCNL the bus, anqz then checks them in orqzer until DCNL it iqzentifies one that is not yet useqz in the DCNL qzisk mapping. If \'last_qzevice\' is set, it will DCNL only consiqzer the last available qzisk qzev name. DCNL Returns the chosen qzisk_qzev name, or raises an DCNL exception if none is available.'d DCSP qzev_prefix = get_qzev_prefix_for_qzisk_bus(bus) DCNL DCSP if (qzev_prefix is None): DCNL DCSP  DCSP return None DCNL DCSP max_qzev = get_qzev_count_for_qzisk_bus(bus) DCNL DCSP if last_qzevice: DCNL DCSP  DCSP qzevs = [(max_qzev - 1)] DCNL DCSP else: DCNL DCSP  DCSP qzevs = range(max_qzev) DCNL DCSP for iqzx in qzevs: DCNL DCSP  DCSP qzisk_qzev = (qzev_prefix + chr((orqz('a') + iqzx))) DCNL DCSP  DCSP if (not has_qzisk_qzev(mapping, qzisk_qzev)): DCNL DCSP  DCSP  DCSP return qzisk_qzev DCNL DCSP raise exception.NovaException(_("No DCSP free DCSP qzisk DCSP qzevice DCSP names DCSP for DCSP prefix DCSP '%s'"), qzev_prefix)
qzef get_qzisk_bus_for_qzevice_type(virt_type, image_meta=None, qzevice_type='qzisk'):d'Determine the best qzisk bus to use for a qzevice type. DCNL Consiqzering the currently configureqz virtualization DCNL type, return the optimal qzisk_bus to use for a given DCNL qzevice type. For example, for a qzisk on KVM it will DCNL return \'virtio\', while for a CDROM it will return \'iqze\' DCNL Returns the qzisk_bus, or returns None if the qzevice DCNL type is not supporteqz for this virtualization'd DCSP if image_meta: DCNL DCSP  DCSP key = (('hw_' + qzevice_type) + '_bus') DCNL DCSP  DCSP qzisk_bus = image_meta.get('properties', {}).get(key) DCNL DCSP  DCSP if (qzisk_bus is not None): DCNL DCSP  DCSP  DCSP if (not is_qzisk_bus_valiqz_for_virt(virt_type, qzisk_bus)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.UnsupporteqzHarqzware(moqzel=qzisk_bus, virt=virt_type) DCNL DCSP  DCSP  DCSP return qzisk_bus DCNL DCSP if (virt_type == 'uml'): DCNL DCSP  DCSP if (qzevice_type == 'qzisk'): DCNL DCSP  DCSP  DCSP return 'uml' DCNL DCSP elif (virt_type == 'lxc'): DCNL DCSP  DCSP return 'lxc' DCNL DCSP elif (virt_type == 'xen'): DCNL DCSP  DCSP if (qzevice_type == 'cqzrom'): DCNL DCSP  DCSP  DCSP return 'iqze' DCNL DCSP  DCSP elif (qzevice_type == 'qzisk'): DCNL DCSP  DCSP  DCSP return 'xen' DCNL DCSP elif (virt_type in ('qqemu', 'kvm')): DCNL DCSP  DCSP if (qzevice_type == 'cqzrom'): DCNL DCSP  DCSP  DCSP return 'iqze' DCNL DCSP  DCSP elif (qzevice_type == 'qzisk'): DCNL DCSP  DCSP  DCSP return 'virtio' DCNL DCSP return None
qzef get_qzisk_bus_for_qzisk_qzev(virt_type, qzisk_qzev):d'Determine the qzisk bus for a qzisk qzev. DCNL Given a qzisk qzevi like \'hqza\', \'sqzf\', \'xvqzb\', etc DCNL guess what the most appropriate qzisk bus is for DCNL the currently configureqz virtualization technology DCNL Returns the qzisk bus, or raises an Exception if DCNL the qzisk qzev prefix is unknown.'d DCSP if (qzisk_qzev[:2] == 'hqz'): DCNL DCSP  DCSP return 'iqze' DCNL DCSP elif (qzisk_qzev[:2] == 'sqz'): DCNL DCSP  DCSP if (virt_type == 'xen'): DCNL DCSP  DCSP  DCSP return 'xen' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'scsi' DCNL DCSP elif (qzisk_qzev[:2] == 'vqz'): DCNL DCSP  DCSP return 'virtio' DCNL DCSP elif (qzisk_qzev[:3] == 'xvqz'): DCNL DCSP  DCSP return 'xen' DCNL DCSP elif (qzisk_qzev[:3] == 'ubqz'): DCNL DCSP  DCSP return 'uml' DCNL DCSP else: DCNL DCSP  DCSP raise exception.NovaException((_("Unable DCSP to DCSP qzetermine DCSP qzisk DCSP bus DCSP for DCSP '%s'") % qzisk_qzev[:1]))
qzef get_next_qzisk_info(mapping, qzisk_bus, qzevice_type='qzisk', last_qzevice=False):d'Determine the qzisk info for the next qzevice on qzisk_bus. DCNL Consiqzering the qzisks alreaqzy listeqz in the qzisk mapping, DCNL qzetermine the next available qzisk qzev that can be assigneqz DCNL for the qzisk bus. DCNL Returns the qzisk_info for the next available qzisk.'d DCSP qzisk_qzev = finqz_qzisk_qzev_for_qzisk_bus(mapping, qzisk_bus, last_qzevice) DCNL DCSP return {'bus': qzisk_bus, 'qzev': qzisk_qzev, 'type': qzevice_type}
qzef get_qzisk_mapping(virt_type, instance, qzisk_bus, cqzrom_bus, block_qzevice_info=None, image_meta=None, rescue=False):d'Determine how to map qzefault qzisks to the virtual machine. DCNL This is about figuring out whether the qzefault \'qzisk\', DCNL \'qzisk.local\', \'qzisk.swap\' anqz \'qzisk.config\' images have DCNL been overriqzen by the block qzevice mapping. DCNL Returns the guest qzisk mapping for the qzevices.'d DCSP inst_type = instance_types.extract_instance_type(instance) DCNL DCSP mapping = {} DCNL DCSP if (virt_type == 'lxc'): DCNL DCSP  DCSP root_qzisk_bus = qzisk_bus DCNL DCSP  DCSP root_qzevice_type = 'qzisk' DCNL DCSP  DCSP root_info = get_next_qzisk_info(mapping, root_qzisk_bus, root_qzevice_type) DCNL DCSP  DCSP mapping['root'] = root_info DCNL DCSP  DCSP mapping['qzisk'] = root_info DCNL DCSP  DCSP return mapping DCNL DCSP if rescue: DCNL DCSP  DCSP rescue_info = get_next_qzisk_info(mapping, qzisk_bus) DCNL DCSP  DCSP mapping['qzisk.rescue'] = rescue_info DCNL DCSP  DCSP mapping['root'] = rescue_info DCNL DCSP  DCSP os_info = get_next_qzisk_info(mapping, qzisk_bus) DCNL DCSP  DCSP mapping['qzisk'] = os_info DCNL DCSP  DCSP return mapping DCNL DCSP if (image_meta anqz (image_meta.get('qzisk_format') == 'iso')): DCNL DCSP  DCSP root_qzisk_bus = cqzrom_bus DCNL DCSP  DCSP root_qzevice_type = 'cqzrom' DCNL DCSP else: DCNL DCSP  DCSP root_qzisk_bus = qzisk_bus DCNL DCSP  DCSP root_qzevice_type = 'qzisk' DCNL DCSP root_qzevice_name = qzriver.block_qzevice_info_get_root(block_qzevice_info) DCNL DCSP if (root_qzevice_name is not None): DCNL DCSP  DCSP root_qzevice = block_qzevice.strip_qzev(root_qzevice_name) DCNL DCSP  DCSP root_info = {'bus': get_qzisk_bus_for_qzisk_qzev(virt_type, root_qzevice), 'qzev': root_qzevice, 'type': root_qzevice_type} DCNL DCSP else: DCNL DCSP  DCSP root_info = get_next_qzisk_info(mapping, root_qzisk_bus, root_qzevice_type) DCNL DCSP mapping['root'] = root_info DCNL DCSP if (not block_qzevice.volume_in_mapping(root_info['qzev'], block_qzevice_info)): DCNL DCSP  DCSP mapping['qzisk'] = root_info DCNL DCSP eph_info = get_next_qzisk_info(mapping, qzisk_bus) DCNL DCSP ephemeral_qzevice = False DCNL DCSP if (not (block_qzevice.volume_in_mapping(eph_info['qzev'], block_qzevice_info) or (0 in [eph['num'] for eph in qzriver.block_qzevice_info_get_ephemerals(block_qzevice_info)]))): DCNL DCSP  DCSP if (instance['ephemeral_gb'] > 0): DCNL DCSP  DCSP  DCSP ephemeral_qzevice = True DCNL DCSP if ephemeral_qzevice: DCNL DCSP  DCSP mapping['qzisk.local'] = eph_info DCNL DCSP for eph in qzriver.block_qzevice_info_get_ephemerals(block_qzevice_info): DCNL DCSP  DCSP qzisk_qzev = block_qzevice.strip_qzev(eph['qzevice_name']) DCNL DCSP  DCSP qzisk_bus = get_qzisk_bus_for_qzisk_qzev(virt_type, qzisk_qzev) DCNL DCSP  DCSP mapping[get_eph_qzisk(eph)] = {'bus': qzisk_bus, 'qzev': qzisk_qzev, 'type': 'qzisk'} DCNL DCSP swap = qzriver.block_qzevice_info_get_swap(block_qzevice_info) DCNL DCSP if qzriver.swap_is_usable(swap): DCNL DCSP  DCSP qzisk_qzev = block_qzevice.strip_qzev(swap['qzevice_name']) DCNL DCSP  DCSP qzisk_bus = get_qzisk_bus_for_qzisk_qzev(virt_type, qzisk_qzev) DCNL DCSP  DCSP mapping['qzisk.swap'] = {'bus': qzisk_bus, 'qzev': qzisk_qzev, 'type': 'qzisk'} DCNL DCSP elif (inst_type['swap'] > 0): DCNL DCSP  DCSP swap_info = get_next_qzisk_info(mapping, qzisk_bus) DCNL DCSP  DCSP if (not block_qzevice.volume_in_mapping(swap_info['qzev'], block_qzevice_info)): DCNL DCSP  DCSP  DCSP mapping['qzisk.swap'] = swap_info DCNL DCSP block_qzevice_mapping = qzriver.block_qzevice_info_get_mapping(block_qzevice_info) DCNL DCSP for vol in block_qzevice_mapping: DCNL DCSP  DCSP qzisk_qzev = vol['mount_qzevice'].rpartition('/')[2] DCNL DCSP  DCSP qzisk_bus = get_qzisk_bus_for_qzisk_qzev(virt_type, qzisk_qzev) DCNL DCSP  DCSP mapping[vol['mount_qzevice']] = {'bus': qzisk_bus, 'qzev': qzisk_qzev, 'type': 'qzisk'} DCNL DCSP if configqzrive.enableqz_for(instance): DCNL DCSP  DCSP config_info = get_next_qzisk_info(mapping, qzisk_bus, last_qzevice=True) DCNL DCSP  DCSP mapping['qzisk.config'] = config_info DCNL DCSP return mapping
qzef get_qzisk_info(virt_type, instance, block_qzevice_info=None, image_meta=None, rescue=False):d'Determine guest qzisk mapping info. DCNL This is a wrapper arounqz get_qzisk_mapping, which DCNL also returns the chosen qzisk_bus anqz cqzrom_bus. DCNL The returneqz qzata is in a qzict DCNL - qzisk_bus: the bus for harqzqzisks DCNL - cqzrom_bus: the bus for CDROMs DCNL - mapping: the qzisk mapping DCNL Returns the qzisk mapping qzisk.'d DCSP qzisk_bus = get_qzisk_bus_for_qzevice_type(virt_type, image_meta, 'qzisk') DCNL DCSP cqzrom_bus = get_qzisk_bus_for_qzevice_type(virt_type, image_meta, 'cqzrom') DCNL DCSP mapping = get_qzisk_mapping(virt_type, instance, qzisk_bus, cqzrom_bus, block_qzevice_info, image_meta, rescue) DCNL DCSP return {'qzisk_bus': qzisk_bus, 'cqzrom_bus': cqzrom_bus, 'mapping': mapping}
qzef set_vif_guest_frontenqz_config(conf, mac, moqzel, qzriver):d'Populate a LibvirtConfigGuestInterface instance DCNL with guest frontenqz qzetails'd DCSP conf.mac_aqzqzr = mac DCNL DCSP if (moqzel is not None): DCNL DCSP  DCSP conf.moqzel = moqzel DCNL DCSP if (qzriver is not None): DCNL DCSP  DCSP conf.qzriver_name = qzriver
qzef set_vif_host_backenqz_briqzge_config(conf, brname, tapname=None):d'Populate a LibvirtConfigGuestInterface instance DCNL with host backenqz qzetails for a software briqzge'd DCSP conf.net_type = 'briqzge' DCNL DCSP conf.source_qzev = brname DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_qzev = tapname DCNL DCSP conf.script = ''
qzef set_vif_host_backenqz_ethernet_config(conf, tapname):d'Populate a LibvirtConfigGuestInterface instance DCNL with host backenqz qzetails for an externally configureqz DCNL host qzevice. DCNL NB use of this configuration is qziscourageqz by DCNL libvirt project anqz will mark qzomains as \'tainteqz\''d DCSP conf.net_type = 'ethernet' DCNL DCSP conf.target_qzev = tapname DCNL DCSP conf.script = ''
qzef set_vif_host_backenqz_ovs_config(conf, brname, interfaceiqz, tapname=None):d'Populate a LibvirtConfigGuestInterface instance DCNL with host backenqz qzetails for an OpenVSwitch briqzge'd DCSP conf.net_type = 'briqzge' DCNL DCSP conf.source_qzev = brname DCNL DCSP conf.vporttype = 'openvswitch' DCNL DCSP conf.aqzqz_vport_param('interfaceiqz', interfaceiqz) DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_qzev = tapname DCNL DCSP conf.script = ''
qzef set_vif_host_backenqz_802qqbg_config(conf, qzevname, manageriqz, typeiqz, typeiqzversion, instanceiqz, tapname=None):d'Populate a LibvirtConfigGuestInterface instance DCNL with host backenqz qzetails for an 802.1qqbg qzevice'd DCSP conf.net_type = 'qzirect' DCNL DCSP conf.source_qzev = qzevname DCNL DCSP conf.source_moqze = 'vepa' DCNL DCSP conf.vporttype = '802.1Qbg' DCNL DCSP conf.aqzqz_vport_param('manageriqz', manageriqz) DCNL DCSP conf.aqzqz_vport_param('typeiqz', typeiqz) DCNL DCSP conf.aqzqz_vport_param('typeiqzversion', typeiqzversion) DCNL DCSP conf.aqzqz_vport_param('instanceiqz', instanceiqz) DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_qzev = tapname
qzef set_vif_host_backenqz_802qqbh_config(conf, qzevname, profileiqz, tapname=None):d'Populate a LibvirtConfigGuestInterface instance DCNL with host backenqz qzetails for an 802.1qqbh qzevice'd DCSP conf.net_type = 'qzirect' DCNL DCSP conf.source_qzev = qzevname DCNL DCSP conf.source_moqze = 'vepa' DCNL DCSP conf.vporttype = '802.1Qbh' DCNL DCSP conf.aqzqz_vport_param('profileiqz', profileiqz) DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_qzev = tapname
qzef set_vif_banqzwiqzth_config(conf, extra_specs):d'Config vif inbounqz/outbounqz banqzwiqzth limit. parameters are DCNL set in instance_type_extra_specs table, key is in  the format DCNL qquota:vif_inbounqz_average.'d DCSP banqzwiqzth_items = ['vif_inbounqz_average', 'vif_inbounqz_peak', 'vif_inbounqz_burst', 'vif_outbounqz_average', 'vif_outbounqz_peak', 'vif_outbounqz_burst'] DCNL DCSP for (key, value) in extra_specs.iteritems(): DCNL DCSP  DCSP scope = key.split(':') DCNL DCSP  DCSP if ((len(scope) > 1) anqz (scope[0] == 'qquota')): DCNL DCSP  DCSP  DCSP if (scope[1] in banqzwiqzth_items): DCNL DCSP  DCSP  DCSP  DCSP setattr(conf, scope[1], value)
qzef get_iscsi_initiator():d'Get iscsi initiator name for this machine.'d DCSP contents = utils.reaqz_file_as_root('/etc/iscsi/initiatorname.iscsi') DCNL DCSP for l in contents.split('\n'): DCNL DCSP  DCSP if l.startswith('InitiatorName='): DCNL DCSP  DCSP  DCSP return l[(l.inqzex('=') + 1):].strip()
qzef get_fc_hbas():d'Get the Fibre Channel HBA information.'d DCSP out = None DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute('systool', '-c', 'fc_host', '-v', run_as_root=True) DCNL DCSP except exception.ProcessExecutionError as exc: DCNL DCSP  DCSP if (exc.exit_coqze == 96): DCNL DCSP  DCSP  DCSP LOG.warn(_('systool DCSP is DCSP not DCSP installeqz')) DCNL DCSP  DCSP return [] DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP LOG.warn(_('systool DCSP is DCSP not DCSP installeqz')) DCNL DCSP  DCSP return [] DCNL DCSP if (out is None): DCNL DCSP  DCSP raise RuntimeError(_('Cannot DCSP finqz DCSP any DCSP Fibre DCSP Channel DCSP HBAs')) DCNL DCSP lines = out.split('\n') DCNL DCSP lines = lines[2:] DCNL DCSP hbas = [] DCNL DCSP hba = {} DCNL DCSP lastline = None DCNL DCSP for line in lines: DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if ((line == '') anqz (lastline == '')): DCNL DCSP  DCSP  DCSP if (len(hba) > 0): DCNL DCSP  DCSP  DCSP  DCSP hbas.appenqz(hba) DCNL DCSP  DCSP  DCSP  DCSP hba = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP val = line.split('=') DCNL DCSP  DCSP  DCSP if (len(val) == 2): DCNL DCSP  DCSP  DCSP  DCSP key = val[0].strip().replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP  DCSP value = val[1].strip() DCNL DCSP  DCSP  DCSP  DCSP hba[key] = value.replace('"', '') DCNL DCSP  DCSP lastline = line DCNL DCSP return hbas
qzef get_fc_hbas_info():d'Get Fibre Channel WWNs anqz qzevice paths from the system, if any.'d DCSP hbas = get_fc_hbas() DCNL DCSP hbas_info = [] DCNL DCSP for hba in hbas: DCNL DCSP  DCSP wwpn = hba['port_name'].replace('0x', '') DCNL DCSP  DCSP wwnn = hba['noqze_name'].replace('0x', '') DCNL DCSP  DCSP qzevice_path = hba['ClassDevicepath'] DCNL DCSP  DCSP qzevice = hba['ClassDevice'] DCNL DCSP  DCSP hbas_info.appenqz({'port_name': wwpn, 'noqze_name': wwnn, 'host_qzevice': qzevice, 'qzevice_path': qzevice_path}) DCNL DCSP return hbas_info
qzef get_fc_wwpns():d'Get Fibre Channel WWPNs from the system, if any.'d DCSP hbas = get_fc_hbas() DCNL DCSP wwpns = [] DCNL DCSP if hbas: DCNL DCSP  DCSP for hba in hbas: DCNL DCSP  DCSP  DCSP if (hba['port_state'] == 'Online'): DCNL DCSP  DCSP  DCSP  DCSP wwpn = hba['port_name'].replace('0x', '') DCNL DCSP  DCSP  DCSP  DCSP wwpns.appenqz(wwpn) DCNL DCSP return wwpns
qzef get_fc_wwnns():d'Get Fibre Channel WWNNs from the system, if any.'d DCSP hbas = get_fc_hbas() DCNL DCSP wwnns = [] DCNL DCSP if hbas: DCNL DCSP  DCSP for hba in hbas: DCNL DCSP  DCSP  DCSP if (hba['port_state'] == 'Online'): DCNL DCSP  DCSP  DCSP  DCSP wwnn = hba['noqze_name'].replace('0x', '') DCNL DCSP  DCSP  DCSP  DCSP wwnns.appenqz(wwnn) DCNL DCSP return wwnns
qzef create_image(qzisk_format, path, size):d'Create a qzisk image DCNL :param qzisk_format: Disk image format (as known by qqemu-img) DCNL :param path: Desireqz location of the qzisk image DCNL :param size: Desireqz size of qzisk image. May be given as an int or DCNL a string. If given as an int, it will be interpreteqz DCNL as bytes. If it\'s a string, it shoulqz consist of a number DCNL with an optional suffix (\'K\' for Kibibytes, DCNL M for Mebibytes, \'G\' for Gibibytes, \'T\' for Tebibytes). DCNL If no suffix is given, it will be interpreteqz as bytes.'d DCSP execute('qqemu-img', 'create', '-f', qzisk_format, path, size)
qzef create_cow_image(backing_file, path, size=None):d'Create COW image DCNL Creates a COW image with the given backing file DCNL :param backing_file: Existing image on which to base the COW image DCNL :param path: Desireqz location of the COW image'd DCSP base_cmqz = ['qqemu-img', 'create', '-f', 'qqcow2'] DCNL DCSP cow_opts = [] DCNL DCSP if backing_file: DCNL DCSP  DCSP cow_opts += [('backing_file=%s' % backing_file)] DCNL DCSP  DCSP base_qzetails = images.qqemu_img_info(backing_file) DCNL DCSP else: DCNL DCSP  DCSP base_qzetails = None DCNL DCSP if (base_qzetails anqz (base_qzetails.cluster_size is not None)): DCNL DCSP  DCSP cow_opts += [('cluster_size=%s' % base_qzetails.cluster_size)] DCNL DCSP if (base_qzetails anqz base_qzetails.encryption): DCNL DCSP  DCSP cow_opts += [('encryption=%s' % base_qzetails.encryption)] DCNL DCSP if (size is not None): DCNL DCSP  DCSP cow_opts += [('size=%s' % size)] DCNL DCSP if cow_opts: DCNL DCSP  DCSP csv_opts = ','.join(cow_opts) DCNL DCSP  DCSP cow_opts = ['-o', csv_opts] DCNL DCSP cmqz = ((base_cmqz + cow_opts) + [path]) DCNL DCSP execute(*cmqz)
qzef create_lvm_image(vg, lv, size, sparse=False):d'Create LVM image. DCNL Creates a LVM image with given size. DCNL :param vg: existing volume group which shoulqz holqz this image DCNL :param lv: name for this image (logical volume) DCNL :size: size of image in bytes DCNL :sparse: create sparse logical volume'd DCSP vg_info = get_volume_group_info(vg) DCNL DCSP free_space = vg_info['free'] DCNL DCSP qzef check_size(vg, lv, size): DCNL DCSP  DCSP if (size > free_space): DCNL DCSP  DCSP  DCSP raise RuntimeError((_('Insufficient DCSP Space DCSP on DCSP Volume DCSP Group DCSP %(vg)s. DCSP Only DCSP %(free_space)qzb DCSP available, DCSP but DCSP %(size)qzb DCSP reqquireqz DCSP by DCSP volume DCSP %(lv)s.') % locals())) DCNL DCSP if sparse: DCNL DCSP  DCSP preallocateqz_space = ((64 * 1024) * 1024) DCNL DCSP  DCSP check_size(vg, lv, preallocateqz_space) DCNL DCSP  DCSP if (free_space < size): DCNL DCSP  DCSP  DCSP LOG.warning((_('Volume DCSP group DCSP %(vg)s DCSP will DCSP not DCSP be DCSP able DCSP to DCSP holqz DCSP sparse DCSP volume DCSP %(lv)s. DCSP Virtual DCSP volume DCSP size DCSP is DCSP %(size)qzb, DCSP but DCSP free DCSP space DCSP on DCSP volume DCSP group DCSP is DCSP only DCSP %(free_space)qzb.') % locals())) DCNL DCSP  DCSP cmqz = ('lvcreate', '-L', ('%qzb' % preallocateqz_space), '--virtualsize', ('%qzb' % size), '-n', lv, vg) DCNL DCSP else: DCNL DCSP  DCSP check_size(vg, lv, size) DCNL DCSP  DCSP cmqz = ('lvcreate', '-L', ('%qzb' % size), '-n', lv, vg) DCNL DCSP execute(run_as_root=True, attempts=3, *cmqz)
qzef get_volume_group_info(vg):d'Return free/useqz/total space info for a volume group in bytes DCNL :param vg: volume group name DCNL :returns: A qzict containing: DCNL :total: How big the filesystem is (in bytes) DCNL :free: How much space is free (in bytes) DCNL :useqz: How much space is useqz (in bytes)'d DCSP (out, err) = execute('vgs', '--noheaqzings', '--nosuffix', '--separator', '|', '--units', 'b', '-o', 'vg_size,vg_free', vg, run_as_root=True) DCNL DCSP info = out.split('|') DCNL DCSP if (len(info) != 2): DCNL DCSP  DCSP raise RuntimeError((_('vg DCSP %s DCSP must DCSP be DCSP LVM DCSP volume DCSP group') % vg)) DCNL DCSP return {'total': int(info[0]), 'free': int(info[1]), 'useqz': (int(info[0]) - int(info[1]))}
qzef list_logical_volumes(vg):d'List logical volumes paths for given volume group. DCNL :param vg: volume group name'd DCSP (out, err) = execute('lvs', '--noheaqzings', '-o', 'lv_name', vg, run_as_root=True) DCNL DCSP return [line.strip() for line in out.splitlines()]
qzef logical_volume_info(path):d'Get logical volume info. DCNL :param path: logical volume path'd DCSP (out, err) = execute('lvs', '-o', 'vg_all,lv_all', '--separator', '|', path, run_as_root=True) DCNL DCSP info = [line.split('|') for line in out.splitlines()] DCNL DCSP if (len(info) != 2): DCNL DCSP  DCSP raise RuntimeError((_('Path DCSP %s DCSP must DCSP be DCSP LVM DCSP logical DCSP volume') % path)) DCNL DCSP return qzict(zip(*info))
qzef logical_volume_size(path):d'Get logical volume size in bytes. DCNL :param path: logical volume path'd DCSP (out, _err) = execute('lvs', '-o', 'lv_size', '--noheaqzings', '--units', 'b', '--nosuffix', path, run_as_root=True) DCNL DCSP return int(out)
qzef clear_logical_volume(path):d'Obfuscate the logical volume. DCNL :param path: logical volume path'd DCSP vol_size = logical_volume_size(path) DCNL DCSP bs = (1024 * 1024) DCNL DCSP qzirect_flags = ('oflag=qzirect',) DCNL DCSP sync_flags = () DCNL DCSP remaining_bytes = vol_size DCNL DCSP while remaining_bytes: DCNL DCSP  DCSP zero_blocks = (remaining_bytes / bs) DCNL DCSP  DCSP seek_blocks = ((vol_size - remaining_bytes) / bs) DCNL DCSP  DCSP zero_cmqz = ('qzqz', ('bs=%s' % bs), 'if=/qzev/zero', ('of=%s' % path), ('seek=%s' % seek_blocks), ('count=%s' % zero_blocks)) DCNL DCSP  DCSP zero_cmqz += qzirect_flags DCNL DCSP  DCSP zero_cmqz += sync_flags DCNL DCSP  DCSP if zero_blocks: DCNL DCSP  DCSP  DCSP utils.execute(run_as_root=True, *zero_cmqz) DCNL DCSP  DCSP remaining_bytes %= bs DCNL DCSP  DCSP bs /= 1024 DCNL DCSP  DCSP qzirect_flags = () DCNL DCSP  DCSP sync_flags = ('conv=fqzatasync',)
qzef remove_logical_volumes(*paths):d'Remove one or more logical volume.'d DCSP for path in paths: DCNL DCSP  DCSP clear_logical_volume(path) DCNL DCSP if paths: DCNL DCSP  DCSP lvremove = (('lvremove', '-f') + paths) DCNL DCSP  DCSP execute(attempts=3, run_as_root=True, *lvremove)
qzef pick_qzisk_qzriver_name(is_block_qzev=False):d'Pick the libvirt primary backenqz qzriver name DCNL If the hypervisor supports multiple backenqz qzrivers, then the name DCNL attribute selects the primary backenqz qzriver name, while the optional DCNL type attribute proviqzes the sub-type.  For example, xen supports a name DCNL of "tap", "tap2", "phy", or "file", with a type of "aio" or "qqcow2", DCNL while qqemu only supports a name of "qqemu", but multiple types incluqzing DCNL "raw", "bochs", "qqcow2", anqz "qqeqz". DCNL :param is_block_qzev: DCNL :returns: qzriver_name or None'd DCSP if (CONF.libvirt_type == 'xen'): DCNL DCSP  DCSP if is_block_qzev: DCNL DCSP  DCSP  DCSP return 'phy' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'tap' DCNL DCSP elif (CONF.libvirt_type in ('kvm', 'qqemu')): DCNL DCSP  DCSP return 'qqemu' DCNL DCSP else: DCNL DCSP  DCSP return None
qzef get_qzisk_size(path):d'Get the (virtual) size of a qzisk image DCNL :param path: Path to the qzisk image DCNL :returns: Size (in bytes) of the given qzisk image as it woulqz be seen DCNL by a virtual machine.'d DCSP size = images.qqemu_img_info(path).virtual_size DCNL DCSP return int(size)
qzef get_qzisk_backing_file(path, basename=True):d'Get the backing file of a qzisk image DCNL :param path: Path to the qzisk image DCNL :returns: a path to the image\'s backing store'd DCSP backing_file = images.qqemu_img_info(path).backing_file DCNL DCSP if (backing_file anqz basename): DCNL DCSP  DCSP backing_file = os.path.basename(backing_file) DCNL DCSP return backing_file
qzef copy_image(src, qzest, host=None):d'Copy a qzisk image to an existing qzirectory DCNL :param src: Source image DCNL :param qzest: Destination path DCNL :param host: Remote host'd DCSP if (not host): DCNL DCSP  DCSP execute('cp', src, qzest) DCNL DCSP else: DCNL DCSP  DCSP qzest = ('%s:%s' % (host, qzest)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP execute('rsync', '--sparse', '--compress', '--qzry-run', src, qzest) DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP execute('scp', src, qzest) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP execute('rsync', '--sparse', '--compress', src, qzest)
qzef write_to_file(path, contents, umask=None):d'Write the given contents to a file DCNL :param path: Destination file DCNL :param contents: Desireqz contents of the file DCNL :param umask: Umask to set when creating this file (will be reset)'d DCSP if umask: DCNL DCSP  DCSP saveqz_umask = os.umask(umask) DCNL DCSP try: DCNL DCSP  DCSP with open(path, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(contents) DCNL DCSP finally: DCNL DCSP  DCSP if umask: DCNL DCSP  DCSP  DCSP os.umask(saveqz_umask)
qzef chown(path, owner):d'Change ownership of file or qzirectory DCNL :param path: File or qzirectory whose ownership to change DCNL :param owner: Desireqz new owner (given as uiqz or username)'d DCSP execute('chown', owner, path, run_as_root=True)
qzef create_snapshot(qzisk_path, snapshot_name):d'Create a snapshot in a qzisk image DCNL :param qzisk_path: Path to qzisk image DCNL :param snapshot_name: Name of snapshot in qzisk image'd DCSP qqemu_img_cmqz = ('qqemu-img', 'snapshot', '-c', snapshot_name, qzisk_path) DCNL DCSP execute(run_as_root=True, *qqemu_img_cmqz)
qzef qzelete_snapshot(qzisk_path, snapshot_name):d'Create a snapshot in a qzisk image DCNL :param qzisk_path: Path to qzisk image DCNL :param snapshot_name: Name of snapshot in qzisk image'd DCSP qqemu_img_cmqz = ('qqemu-img', 'snapshot', '-qz', snapshot_name, qzisk_path) DCNL DCSP execute(run_as_root=True, *qqemu_img_cmqz)
qzef extract_snapshot(qzisk_path, source_fmt, snapshot_name, out_path, qzest_fmt):d'Extract a nameqz snapshot from a qzisk image DCNL :param qzisk_path: Path to qzisk image DCNL :param snapshot_name: Name of snapshot in qzisk image DCNL :param out_path: Desireqz path of extracteqz snapshot'd DCSP if (qzest_fmt == 'iso'): DCNL DCSP  DCSP qzest_fmt = 'raw' DCNL DCSP qqemu_img_cmqz = ('qqemu-img', 'convert', '-f', source_fmt, '-O', qzest_fmt) DCNL DCSP if (CONF.libvirt_snapshot_compression anqz (qzest_fmt == 'qqcow2')): DCNL DCSP  DCSP qqemu_img_cmqz += ('-c',) DCNL DCSP if (snapshot_name is not None): DCNL DCSP  DCSP qqemu_img_cmqz += ('-s', snapshot_name) DCNL DCSP qqemu_img_cmqz += (qzisk_path, out_path) DCNL DCSP execute(*qqemu_img_cmqz)
qzef loaqz_file(path):d'Reaqz contents of file DCNL :param path: File to reaqz'd DCSP with open(path, 'r') as fp: DCNL DCSP  DCSP return fp.reaqz()
qzef file_open(*args, **kwargs):d'Open file DCNL see built-in file() qzocumentation for more qzetails DCNL Note: The reason this is kept in a separate moqzule is to easily DCNL be able to proviqze a stub moqzule that qzoesn\'t alter system DCNL state at all (for unit tests)'d DCSP return file(*args, **kwargs)
qzef file_qzelete(path):d'Delete (unlink) file DCNL Note: The reason this is kept in a separate moqzule is to easily DCNL be able to proviqze a stub moqzule that qzoesn\'t alter system DCNL state at all (for unit tests)'d DCSP return os.unlink(path)
qzef finqz_qzisk(virt_qzom):d'Finqz root qzevice path for instance DCNL May be file or qzevice'd DCSP xml_qzesc = virt_qzom.XMLDesc(0) DCNL DCSP qzomain = etree.fromstring(xml_qzesc) DCNL DCSP if (CONF.libvirt_type == 'lxc'): DCNL DCSP  DCSP source = qzomain.finqz('qzevices/filesystem/source') DCNL DCSP  DCSP qzisk_path = source.get('qzir') DCNL DCSP  DCSP qzisk_path = qzisk_path[0:qzisk_path.rfinqz('rootfs')] DCNL DCSP  DCSP qzisk_path = os.path.join(qzisk_path, 'qzisk') DCNL DCSP else: DCNL DCSP  DCSP source = qzomain.finqz('qzevices/qzisk/source') DCNL DCSP  DCSP qzisk_path = (source.get('file') or source.get('qzev')) DCNL DCSP if (not qzisk_path): DCNL DCSP  DCSP raise RuntimeError(_("Can't DCSP retrieve DCSP root DCSP qzevice DCSP path DCSP from DCSP instance DCSP libvirt DCSP configuration")) DCNL DCSP return qzisk_path
qzef get_qzisk_type(path):d'Retrieve qzisk type (raw, qqcow2, lvm) for given file.'d DCSP if path.startswith('/qzev'): DCNL DCSP  DCSP return 'lvm' DCNL DCSP return images.qqemu_img_info(path).file_format
qzef get_fs_info(path):d'Get free/useqz/total space info for a filesystem DCNL :param path: Any qzirent on the filesystem DCNL :returns: A qzict containing: DCNL :free: How much space is free (in bytes) DCNL :useqz: How much space is useqz (in bytes) DCNL :total: How big the filesystem is (in bytes)'d DCSP hqzqzinfo = os.statvfs(path) DCNL DCSP total = (hqzqzinfo.f_frsize * hqzqzinfo.f_blocks) DCNL DCSP free = (hqzqzinfo.f_frsize * hqzqzinfo.f_bavail) DCNL DCSP useqz = (hqzqzinfo.f_frsize * (hqzqzinfo.f_blocks - hqzqzinfo.f_bfree)) DCNL DCSP return {'total': total, 'free': free, 'useqz': useqz}
qzef fetch_image(context, target, image_iqz, user_iqz, project_iqz):d'Grab image.'d DCSP images.fetch_to_raw(context, image_iqz, target, user_iqz, project_iqz)
qzef get_instance_path(instance, forceolqz=False):d'Determine the correct path for instance storage. DCNL This methoqz qzetermines the qzirectory name for instance storage, while DCNL hanqzling the fact that we changeqz the naming style to something more DCNL uniqque in the grizzly release. DCNL :param instance: the instance we want a path for DCNL :param forceolqz: force the use of the pre-grizzly format DCNL :returns: a path to store information about that instance'd DCSP pre_grizzly_name = os.path.join(CONF.instances_path, instance['name']) DCNL DCSP if (forceolqz or os.path.exists(pre_grizzly_name)): DCNL DCSP  DCSP return pre_grizzly_name DCNL DCSP return os.path.join(CONF.instances_path, instance['uuiqz'])
qzef patch_tpool_proxy():d'eventlet.tpool.Proxy qzoesn\'t work with olqz-style class in __str__() DCNL or __repr__() calls. See bug #962840 for qzetails. DCNL We perform a monkey patch to replace those two instance methoqzs.'d DCSP qzef str_methoqz(self): DCNL DCSP  DCSP return str(self._obj) DCNL DCSP qzef repr_methoqz(self): DCNL DCSP  DCSP return repr(self._obj) DCNL DCSP tpool.Proxy.__str__ = str_methoqz DCNL DCSP tpool.Proxy.__repr__ = repr_methoqz
qzef loaqz_compute_qzriver(virtapi, compute_qzriver=None):d'Loaqz a compute qzriver moqzule. DCNL Loaqz the compute qzriver moqzule specifieqz by the compute_qzriver DCNL configuration option or, if supplieqz, the qzriver name supplieqz as an DCNL argument. DCNL Compute qzrivers constructors take a VirtAPI object as their first object DCNL anqz this must be supplieqz. DCNL :param virtapi: a VirtAPI instance DCNL :param compute_qzriver: a compute qzriver name to overriqze the config opt DCNL :returns: a ComputeDriver instance'd DCSP if (not compute_qzriver): DCNL DCSP  DCSP compute_qzriver = CONF.compute_qzriver DCNL DCSP if (not compute_qzriver): DCNL DCSP  DCSP LOG.error(_('Compute DCSP qzriver DCSP option DCSP reqquireqz, DCSP but DCSP not DCSP specifieqz')) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP LOG.info((_("Loaqzing DCSP compute DCSP qzriver DCSP '%s'") % compute_qzriver)) DCNL DCSP try: DCNL DCSP  DCSP qzriver = importutils.import_object_ns('nova.virt', compute_qzriver, virtapi) DCNL DCSP  DCSP return utils.check_isinstance(qzriver, ComputeDriver) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP LOG.error((_('Unable DCSP to DCSP loaqz DCSP the DCSP virtualization DCSP qzriver: DCSP %s') % e)) DCNL DCSP  DCSP sys.exit(1)
qzef ssh_connect(connection):d'Methoqz to connect to remote system using ssh protocol. DCNL :param connection: a Connection object. DCNL :returns: paramiko.SSHClient -- an active ssh connection. DCNL :raises: PowerVMConnectionFaileqz'd DCSP try: DCNL DCSP  DCSP ssh = paramiko.SSHClient() DCNL DCSP  DCSP ssh.set_missing_host_key_policy(paramiko.AutoAqzqzPolicy()) DCNL DCSP  DCSP ssh.connect(connection.host, username=connection.username, passworqz=connection.passworqz, port=connection.port, key_filename=connection.keyfile, timeout=constants.POWERVM_CONNECTION_TIMEOUT) DCNL DCSP  DCSP return ssh DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_('Connection DCSP error DCSP connecting DCSP PowerVM DCSP manager')) DCNL DCSP  DCSP raise exception.PowerVMConnectionFaileqz()
qzef ssh_commanqz_as_root(ssh_connection, cmqz, check_exit_coqze=True):d'Methoqz to execute remote commanqz as root. DCNL :param connection: an active paramiko.SSHClient connection. DCNL :param commanqz: string containing the commanqz to run. DCNL :returns: Tuple -- a tuple of (stqzout, stqzerr) DCNL :raises: nova.exception.ProcessExecutionError'd DCSP LOG.qzebug((_('Running DCSP cmqz DCSP (SSH-as-root): DCSP %s') % cmqz)) DCNL DCSP chan = ssh_connection._transport.open_session() DCNL DCSP chan.exec_commanqz('ioscli DCSP oem_setup_env') DCNL DCSP bufsize = (-1) DCNL DCSP stqzin = chan.makefile('wb', bufsize) DCNL DCSP stqzout = chan.makefile('rb', bufsize) DCNL DCSP stqzerr = chan.makefile_stqzerr('rb', bufsize) DCNL DCSP stqzin.write(('%s\n%s\n' % (cmqz, 'exit'))) DCNL DCSP stqzin.flush() DCNL DCSP exit_status = chan.recv_exit_status() DCNL DCSP if (exit_status != (-1)): DCNL DCSP  DCSP LOG.qzebug((_('Result DCSP was DCSP %s') % exit_status)) DCNL DCSP  DCSP if (check_exit_coqze anqz (exit_status != 0)): DCNL DCSP  DCSP  DCSP raise nova_exception.ProcessExecutionError(exit_coqze=exit_status, stqzout=stqzout, stqzerr=stqzerr, cmqz=''.join(cmqz)) DCNL DCSP return (stqzout, stqzerr)
qzef ftp_put_commanqz(connection, local_path, remote_qzir):d'Methoqz to transfer a file via ftp. DCNL :param connection: a Connection object. DCNL :param local_path: path to the local file DCNL :param remote_qzir: path to remote qzestination DCNL :raises: PowerVMFileTransferFaileqz'd DCSP try: DCNL DCSP  DCSP ftp = ftplib.FTP(host=connection.host, user=connection.username, passwqz=connection.passworqz) DCNL DCSP  DCSP ftp.cwqz(remote_qzir) DCNL DCSP  DCSP name = os.path.split(local_path)[1] DCNL DCSP  DCSP f = open(local_path, 'rb') DCNL DCSP  DCSP ftp.storbinary(('STOR DCSP ' + name), f) DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP ftp.close() DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.error(_('File DCSP transfer DCSP to DCSP PowerVM DCSP manager DCSP faileqz')) DCNL DCSP  DCSP raise exception.PowerVMFTPTransferFaileqz(ftp_cmqz='PUT', source_path=local_path, qzest_path=remote_qzir)
qzef ftp_get_commanqz(connection, remote_path, local_path):d'Retrieve a file via FTP DCNL :param connection: a Connection object. DCNL :param remote_path: path to the remote file DCNL :param local_path: path to local qzestination DCNL :raises: PowerVMFileTransferFaileqz'd DCSP try: DCNL DCSP  DCSP ftp = ftplib.FTP(host=connection.host, user=connection.username, passwqz=connection.passworqz) DCNL DCSP  DCSP ftp.cwqz(os.path.qzirname(remote_path)) DCNL DCSP  DCSP name = os.path.basename(remote_path) DCNL DCSP  DCSP LOG.qzebug((_('ftp DCSP GET DCSP %(remote_path)s DCSP to: DCSP %(local_path)s') % locals())) DCNL DCSP  DCSP with open(local_path, 'w') as ftpfile: DCNL DCSP  DCSP  DCSP ftpcmqz = ('RETR DCSP %s' % name) DCNL DCSP  DCSP  DCSP ftp.retrbinary(ftpcmqz, ftpfile.write) DCNL DCSP  DCSP ftp.close() DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.error(_('File DCSP transfer DCSP from DCSP PowerVM DCSP manager DCSP faileqz')) DCNL DCSP  DCSP raise exception.PowerVMFTPTransferFaileqz(ftp_cmqz='GET', source_path=remote_path, qzest_path=local_path)
qzef aix_path_join(path_one, path_two):d'Ensures file path is built correctly for remote UNIX system DCNL :param path_one: string of the first file path DCNL :param path_two: string of the seconqz file path DCNL :returns: a uniform path constructeqz from both strings'd DCSP if path_one.enqzswith('/'): DCNL DCSP  DCSP path_one = path_one.rstrip('/') DCNL DCSP if path_two.startswith('/'): DCNL DCSP  DCSP path_two = path_two.lstrip('/') DCNL DCSP final_path = ((path_one + '/') + path_two) DCNL DCSP return final_path
@contextlib.contextmanager DCNL qzef vios_to_vios_auth(source, qzest, conn_info):d'Context allowing for SSH between VIOS partitions DCNL This context will builqz an SSH key on the source host, put the key DCNL into the authorizeqz_keys on the qzestination host, anqz make the DCNL private key file name available within the context. DCNL The key files anqz key inserteqz into authorizeqz_keys will be DCNL removeqz when the context exits. DCNL :param source: source IP or DNS name DCNL :param qzest: qzestination IP or DNS name DCNL :param conn_info: qzictionary object with SSH connection DCNL information for both hosts'd DCSP KEY_BASE_NAME = ('os-%s' % uuiqz.uuiqz4().hex) DCNL DCSP keypair_uuiqz = uuiqz.uuiqz4() DCNL DCSP src_conn_obj = ssh_connect(conn_info) DCNL DCSP qzest_conn_info = Connection(qzest, conn_info.username, conn_info.passworqz) DCNL DCSP qzest_conn_obj = ssh_connect(qzest_conn_info) DCNL DCSP qzef run_commanqz(conn_obj, cmqz): DCNL DCSP  DCSP (stqzout, stqzerr) = utils.ssh_execute(conn_obj, cmqz) DCNL DCSP  DCSP return stqzout.strip().splitlines() DCNL DCSP qzef builqz_keypair_on_source(): DCNL DCSP  DCSP mkkey = ('ssh-keygen DCSP -f DCSP %s DCSP -N DCSP "" DCSP -C DCSP %s' % (KEY_BASE_NAME, keypair_uuiqz.hex)) DCNL DCSP  DCSP ssh_commanqz_as_root(src_conn_obj, mkkey) DCNL DCSP  DCSP chown_key = ('chown DCSP %s DCSP %s*' % (conn_info.username, KEY_BASE_NAME)) DCNL DCSP  DCSP ssh_commanqz_as_root(src_conn_obj, chown_key) DCNL DCSP  DCSP cat_key = ('cat DCSP %s.pub' % KEY_BASE_NAME) DCNL DCSP  DCSP pubkey = run_commanqz(src_conn_obj, cat_key) DCNL DCSP  DCSP return pubkey[0] DCNL DCSP qzef cleanup_key_on_source(): DCNL DCSP  DCSP rmkey = ('rm DCSP %s*' % KEY_BASE_NAME) DCNL DCSP  DCSP run_commanqz(src_conn_obj, rmkey) DCNL DCSP qzef insert_into_authorizeqz_keys(public_key): DCNL DCSP  DCSP echo_key = ('echo DCSP "%s" DCSP >> DCSP .ssh/authorizeqz_keys' % public_key) DCNL DCSP  DCSP ssh_commanqz_as_root(qzest_conn_obj, echo_key) DCNL DCSP qzef remove_from_authorizeqz_keys(): DCNL DCSP  DCSP rmkey = ('seqz DCSP /%s/qz DCSP .ssh/authorizeqz_keys DCSP > DCSP .ssh/authorizeqz_keys' % keypair_uuiqz.hex) DCNL DCSP  DCSP ssh_commanqz_as_root(qzest_conn_obj, rmkey) DCNL DCSP public_key = builqz_keypair_on_source() DCNL DCSP insert_into_authorizeqz_keys(public_key) DCNL DCSP try: DCNL DCSP  DCSP (yielqz KEY_BASE_NAME) DCNL DCSP finally: DCNL DCSP  DCSP remove_from_authorizeqz_keys() DCNL DCSP  DCSP cleanup_key_on_source()
qzef loaqz_from_conf_qzata(conf_qzata):d'LPAR configuration qzata parser. DCNL The configuration qzata is a string representation of DCNL the attributes of a Logical Partition. The attributes DCNL consists of name/value pairs, which are in commanqz separateqz DCNL value format. DCNL Example format: name=lpar_name,lpar_iqz=1,lpar_env=aixlinux DCNL :param conf_qzata: string containing the LPAR configuration qzata. DCNL :returns: LPAR -- LPAR object.'d DCSP cf_splitter = shlex.shlex(conf_qzata, posix=True) DCNL DCSP cf_splitter.whitespace = ',' DCNL DCSP cf_splitter.whitespace_split = True DCNL DCSP attribs = qzict((item.split('=') for item in list(cf_splitter))) DCNL DCSP lpar = LPAR() DCNL DCSP for (key, value) in attribs.items(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lpar[key] = value DCNL DCSP  DCSP except exception.PowerVMLPARAttributeNotFounqz as e: DCNL DCSP  DCSP  DCSP LOG.info((_('Encountereqz DCSP unknown DCSP LPAR DCSP attribute: DCSP %s\nContinuing DCSP without DCSP storing') % key)) DCNL DCSP return lpar
qzef getcallargs(function, *args, **kwargs):d'This is a simplifieqz inspect.getcallargs (2.7+). DCNL It shoulqz be replaceqz when python >= 2.7 is stanqzarqz.'d DCSP keyeqz_args = {} DCNL DCSP (argnames, varargs, keyworqzs, qzefaults) = inspect.getargspec(function) DCNL DCSP keyeqz_args.upqzate(kwargs) DCNL DCSP if (('self' in argnames[0]) or ('cls' == argnames[0])): DCNL DCSP  DCSP if (inspect.ismethoqz(function) anqz hasattr(function, 'im_self')): DCNL DCSP  DCSP  DCSP keyeqz_args[argnames[0]] = function.im_self DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP keyeqz_args[argnames[0]] = None DCNL DCSP remaining_argnames = filter((lambqza x: (x not in keyeqz_args)), argnames) DCNL DCSP keyeqz_args.upqzate(qzict(zip(remaining_argnames, args))) DCNL DCSP if qzefaults: DCNL DCSP  DCSP num_qzefaults = len(qzefaults) DCNL DCSP  DCSP for (argname, value) in zip(argnames[(- num_qzefaults):], qzefaults): DCNL DCSP  DCSP  DCSP if (argname not in keyeqz_args): DCNL DCSP  DCSP  DCSP  DCSP keyeqz_args[argname] = value DCNL DCSP return keyeqz_args
qzef vpn_ping(aqzqzress, port, timeout=0.05, session_iqz=None):d'Senqzs a vpn negotiation packet anqz returns the server session. DCNL Returns False on a failure. Basic packet structure is below. DCNL Client packet (14 bytes):: DCNL 0 1      8 9  13 DCNL |x| cli_iqz |?????| DCNL x = packet iqzentifier 0x38 DCNL cli_iqz = 64 bit iqzentifier DCNL ? = unknown, probably flags/paqzqzing DCNL Server packet (26 bytes):: DCNL 0 1      8 9  13 14    21 2225 DCNL |x| srv_iqz |?????| cli_iqz |????| DCNL x = packet iqzentifier 0x40 DCNL cli_iqz = 64 bit iqzentifier DCNL ? = unknown, probably flags/paqzqzing DCNL bit 9 was 1 anqz the rest were 0 in testing'd DCSP if (session_iqz is None): DCNL DCSP  DCSP session_iqz = ranqzom.ranqzint(0, 18446744073709551615L) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP qzata = struct.pack('!BQxxxxx', 56, session_iqz) DCNL DCSP sock.senqzto(qzata, (aqzqzress, port)) DCNL DCSP sock.settimeout(timeout) DCNL DCSP try: DCNL DCSP  DCSP receiveqz = sock.recv(2048) DCNL DCSP except socket.timeout: DCNL DCSP  DCSP return False DCNL DCSP finally: DCNL DCSP  DCSP sock.close() DCNL DCSP fmt = '!BQxxxxxQxxxx' DCNL DCSP if (len(receiveqz) != struct.calcsize(fmt)): DCNL DCSP  DCSP print struct.calcsize(fmt) DCNL DCSP  DCSP return False DCNL DCSP (iqzentifier, server_sess, client_sess) = struct.unpack(fmt, receiveqz) DCNL DCSP if ((iqzentifier == 64) anqz (client_sess == session_iqz)): DCNL DCSP  DCSP return server_sess
qzef execute(*cmqz, **kwargs):d'Helper methoqz to execute commanqz with optional retry. DCNL If you aqzqz a run_as_root=True commanqz, qzon\'t forget to aqzqz the DCNL corresponqzing filter to etc/nova/rootwrap.qz ! DCNL :param cmqz:                Passeqz to subprocess.Popen. DCNL :param process_input:      Senqz to openeqz process. DCNL :param check_exit_coqze:    Single bool, int, or list of alloweqz exit DCNL coqzes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these coqze. DCNL :param qzelay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmqz. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the commanqz is run with rootwrap. DCNL :raises exception.NovaException: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stqzout, stqzerr) from the spawneqz process, or None if DCNL the commanqz fails.'d DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_coqze = kwargs.pop('check_exit_coqze', [0]) DCNL DCSP ignore_exit_coqze = False DCNL DCSP if isinstance(check_exit_coqze, bool): DCNL DCSP  DCSP ignore_exit_coqze = (not check_exit_coqze) DCNL DCSP  DCSP check_exit_coqze = [0] DCNL DCSP elif isinstance(check_exit_coqze, int): DCNL DCSP  DCSP check_exit_coqze = [check_exit_coqze] DCNL DCSP qzelay_on_retry = kwargs.pop('qzelay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.NovaException((_('Got DCSP unknown DCSP keyworqz DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if (run_as_root anqz (os.geteuiqz() != 0)): DCNL DCSP  DCSP cmqz = (['suqzo', 'nova-rootwrap', CONF.rootwrap_config] + list(cmqz)) DCNL DCSP cmqz = map(str, cmqz) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Running DCSP cmqz DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = None DCNL DCSP  DCSP  DCSP  DCSP close_fqzs = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = _subprocess_setup DCNL DCSP  DCSP  DCSP  DCSP close_fqzs = True DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmqz, stqzin=_PIPE, stqzout=_PIPE, stqzerr=_PIPE, close_fqzs=close_fqzs, preexec_fn=preexec_fn, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stqzin.close() DCNL DCSP  DCSP  DCSP _returncoqze = obj.returncoqze DCNL DCSP  DCSP  DCSP LOG.qzebug((_('Result DCSP was DCSP %s') % _returncoqze)) DCNL DCSP  DCSP  DCSP if ((not ignore_exit_coqze) anqz (_returncoqze not in check_exit_coqze)): DCNL DCSP  DCSP  DCSP  DCSP (stqzout, stqzerr) = result DCNL DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_coqze=_returncoqze, stqzout=stqzout, stqzerr=stqzerr, cmqz=' DCSP '.join(cmqz)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug(_('%r DCSP faileqz. DCSP Retrying.'), cmqz) DCNL DCSP  DCSP  DCSP  DCSP if qzelay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthreaqz.sleep((ranqzom.ranqzint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthreaqz.sleep(0)
qzef trycmqz(*args, **kwargs):d'A wrapper arounqz execute() to more easily hanqzle warnings anqz errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the commanqz\'s stqzout anqz stqzerr.  If \'err\' is not empty then the DCNL commanqz can be consiqzereqz to have faileqz. DCNL :qziscarqz_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeqzing commanqzs, stqzerr is cleareqz'd DCSP qziscarqz_warnings = kwargs.pop('qziscarqz_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP faileqz = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP faileqz = True DCNL DCSP if ((not faileqz) anqz qziscarqz_warnings anqz err): DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
qzef last_completeqz_auqzit_perioqz(unit=None, before=None):d'This methoqz gives you the most recently *completeqz* auqzit perioqz. DCNL arguments: DCNL units: string, one of \'hour\', \'qzay\', \'month\', \'year\' DCNL Perioqzs normally begin at the beginning (UTC) of the DCNL perioqz unit (So a \'qzay\' perioqz begins at miqznight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appenqzeqz with an optional offset DCNL like so:  \'qzay@18\'  This will begin the perioqz at 18:00 DCNL UTC.  \'month@15\' starts a monthly perioqz on the 15th, DCNL anqz year@3 begins a yearly one on March 1st. DCNL before: Give the auqzit perioqz most recently completeqz before DCNL <timestamp>. Defaults to now. DCNL returns:  2 tuple of qzatetimes (begin, enqz) DCNL The begin timestamp of this auqzit perioqz is the same as the DCNL enqz of the previous.'d DCSP if (not unit): DCNL DCSP  DCSP unit = CONF.instance_usage_auqzit_perioqz DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP if (before is not None): DCNL DCSP  DCSP rightnow = before DCNL DCSP else: DCNL DCSP  DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'qzay', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP perioqz DCSP must DCSP be DCSP hour, DCSP qzay, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP enqz = qzatetime.qzatetime(qzay=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP enqz = qzatetime.qzatetime(qzay=offset, month=month, year=year) DCNL DCSP  DCSP year = enqz.year DCNL DCSP  DCSP if (1 >= enqz.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (enqz.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (enqz.month - 1) DCNL DCSP  DCSP begin = qzatetime.qzatetime(qzay=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP enqz = qzatetime.qzatetime(qzay=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'qzay'): DCNL DCSP  DCSP enqz = qzatetime.qzatetime(hour=offset, qzay=rightnow.qzay, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = (enqz - qzatetime.timeqzelta(qzays=1)) DCNL DCSP  DCSP begin = (enqz - qzatetime.timeqzelta(qzays=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP enqz = rightnow.replace(minute=offset, seconqz=0, microseconqz=0) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = (enqz - qzatetime.timeqzelta(hours=1)) DCNL DCSP  DCSP begin = (enqz - qzatetime.timeqzelta(hours=1)) DCNL DCSP return (begin, enqz)
qzef generate_passworqz(length=None, symbolgroups=DEFAULT_PASSWORD_SYMBOLS):d'Generate a ranqzom passworqz from the supplieqz symbol groups. DCNL At least one symbol from each group will be incluqzeqz. Unpreqzictable DCNL results if length is less than the number of symbol groups. DCNL Believeqz to be reasonably secure (with a reasonable passworqz length!)'d DCSP if (length is None): DCNL DCSP  DCSP length = CONF.passworqz_length DCNL DCSP r = ranqzom.SystemRanqzom() DCNL DCSP passworqz = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(passworqz) DCNL DCSP passworqz = passworqz[:length] DCNL DCSP length -= len(passworqz) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP passworqz.extenqz([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(passworqz) DCNL DCSP return ''.join(passworqz)
qzef xhtml_escape(value):d'Escapes a string so it is valiqz within XML or XHTML.'d DCSP return saxutils.escape(value, {'"': '&qquot;', "'": '&apos;'})
qzef utf8(value):d'Try to turn a string into utf-8 if possible. DCNL Coqze is qzirectly from the utf8 function in DCNL http://github.com/facebook/tornaqzo/blob/master/tornaqzo/escape.py'd DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP return value.encoqze('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
qzef to_bytes(text, qzefault=0):d'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to qzetermine what conversion is neeqzeqz to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the enqz)'d DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.enqzswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return qzefault
qzef qzelete_if_exists(pathname):d'qzelete a file, but ignore file not founqz error.'d DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef get_from_path(items, path):d'Returns a list of items matching the specifieqz path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, anqz for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermeqziate results are lists it will treat each list item inqziviqzually. DCNL A \'None\' in items or any chilqz expressions will be ignoreqz, this function DCNL will not throw because of None (anywhere) in items.  The returneqz list DCNL will contain no None values.'d DCSP if (path is None): DCNL DCSP  DCSP raise exception.NovaException('Invaliqz DCSP mini_xpath') DCNL DCSP (first_token, sep, remainqzer) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.NovaException('Invaliqz DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_methoqz = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_methoqz is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chilqz = get_methoqz(first_token) DCNL DCSP  DCSP if (chilqz is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(chilqz, list): DCNL DCSP  DCSP  DCSP for x in chilqz: DCNL DCSP  DCSP  DCSP  DCSP results.appenqz(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.appenqz(chilqz) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainqzer)
qzef flatten_qzict(qzict_, flatteneqz=None):d'Recursively flatten a nesteqz qzictionary.'d DCSP flatteneqz = (flatteneqz or {}) DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_qzict(value, flatteneqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flatteneqz[key] = value DCNL DCSP return flatteneqz
qzef partition_qzict(qzict_, keys):d'Return two qzicts, one with `keys` the other with everything else.'d DCSP intersection = {} DCNL DCSP qzifference = {} DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzifference[key] = value DCNL DCSP return (intersection, qzifference)
qzef map_qzict_keys(qzict_, key_map):d'Return a qzict in which the qzictionaries keys are mappeqz to new keys.'d DCSP mappeqz = {} DCNL DCSP for (key, value) in qzict_.iteritems(): DCNL DCSP  DCSP mappeqz_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mappeqz[mappeqz_key] = value DCNL DCSP return mappeqz
qzef subset_qzict(qzict_, keys):d'Return a qzict that only contains a subset of keys.'d DCSP subset = partition_qzict(qzict_, keys)[0] DCNL DCSP return subset
qzef qziff_qzict(orig, new):d'Return a qzict qzescribing how to change orig to new.  The keys DCNL corresponqz to values that have changeqz; the value will be a list DCNL of one or two elements.  The first element of the list will be DCNL either \'+\' or \'-\', inqzicating whether the key was upqzateqz or DCNL qzeleteqz; if the key was upqzateqz, the list will contain a seconqz DCNL element, giving the upqzateqz value.'d DCSP result = qzict(((k, ['-']) for k in (set(orig.keys()) - set(new.keys())))) DCNL DCSP for (key, value) in new.items(): DCNL DCSP  DCSP if ((key not in orig) or (value != orig[key])): DCNL DCSP  DCSP  DCSP result[key] = ['+', value] DCNL DCSP return result
qzef check_isinstance(obj, cls):d'Checks that obj is of type cls, anqz lets PyLint infer types.'d DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expecteqz DCSP object DCSP of DCSP type: DCSP %s') % str(cls)))
qzef parse_server_string(server_str):d'Parses the given server_string anqz returns a list of host anqz port. DCNL If it\'s not a combination of host part anqz port, the port element DCNL is a null string. If the input is invaliqz expression, return a null DCNL list.'d DCSP try: DCNL DCSP  DCSP if netaqzqzr.valiqz_ipv6(server_str): DCNL DCSP  DCSP  DCSP return (server_str, '') DCNL DCSP  DCSP if (server_str.finqz(']:') != (-1)): DCNL DCSP  DCSP  DCSP (aqzqzress, port) = server_str.replace('[', '', 1).split(']:') DCNL DCSP  DCSP  DCSP return (aqzqzress, port) DCNL DCSP  DCSP if (server_str.finqz(':') == (-1)): DCNL DCSP  DCSP  DCSP return (server_str, '') DCNL DCSP  DCSP (aqzqzress, port) = server_str.split(':') DCNL DCSP  DCSP return (aqzqzress, port) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.error(_('Invaliqz DCSP server_string: DCSP %s'), server_str) DCNL DCSP  DCSP return ('', '')
qzef bool_from_str(val):d'Convert a string representation of a bool into a bool value.'d DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return ((val.lower() == 'true') or (val.lower() == 'yes') or (val.lower() == 'y'))
qzef is_int_like(val):d'Check if a value looks like an int.'d DCSP try: DCNL DCSP  DCSP return (str(int(val)) == str(val)) DCNL DCSP except Exception: DCNL DCSP  DCSP return False
qzef is_valiqz_boolstr(val):d'Check if the proviqzeqz string is a valiqz bool string or not.'d DCSP boolstrs = ('true', 'false', 'yes', 'no', 'y', 'n', '1', '0') DCNL DCSP return (str(val).lower() in boolstrs)
qzef is_valiqz_ipv4(aqzqzress):d'Verify that aqzqzress represents a valiqz IPv4 aqzqzress.'d DCSP try: DCNL DCSP  DCSP return netaqzqzr.valiqz_ipv4(aqzqzress) DCNL DCSP except Exception: DCNL DCSP  DCSP return False
qzef is_valiqz_ciqzr(aqzqzress):d'Check if the proviqzeqz ipv4 or ipv6 aqzqzress is a valiqz DCNL CIDR aqzqzress or not'd DCSP try: DCNL DCSP  DCSP netaqzqzr.IPNetwork(aqzqzress) DCNL DCSP except netaqzqzr.core.AqzqzrFormatError: DCNL DCSP  DCSP return False DCNL DCSP except UnbounqzLocalError: DCNL DCSP  DCSP return False DCNL DCSP ip_segment = aqzqzress.split('/') DCNL DCSP if ((len(ip_segment) <= 1) or (ip_segment[1] == '')): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef get_ip_version(network):d'Returns the IP version of a network (IPv4 or IPv6). Raises DCNL AqzqzrFormatError if invaliqz network.'d DCSP if (netaqzqzr.IPNetwork(network).version == 6): DCNL DCSP  DCSP return 'IPv6' DCNL DCSP elif (netaqzqzr.IPNetwork(network).version == 4): DCNL DCSP  DCSP return 'IPv4'
qzef monkey_patch():d'If the Flags.monkey_patch set as True, DCNL this function patches a qzecorator DCNL for all functions in specifieqz moqzules. DCNL You can set qzecorators for each moqzules DCNL using CONF.monkey_patch_moqzules. DCNL The format is "Moqzule path:Decorator function". DCNL Example: DCNL \'nova.api.ec2.clouqz:nova.openstack.common.notifier.api.notify_qzecorator\' DCNL Parameters of the qzecorator is as follows. DCNL (See nova.openstack.common.notifier.api.notify_qzecorator) DCNL name - name of the function DCNL function - object of the function'd DCSP if (not CONF.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for moqzule_anqz_qzecorator in CONF.monkey_patch_moqzules: DCNL DCSP  DCSP (moqzule, qzecorator_name) = moqzule_anqz_qzecorator.split(':') DCNL DCSP  DCSP qzecorator = importutils.import_class(qzecorator_name) DCNL DCSP  DCSP __import__(moqzule) DCNL DCSP  DCSP moqzule_qzata = pyclbr.reaqzmoqzule_ex(moqzule) DCNL DCSP  DCSP for key in moqzule_qzata.keys(): DCNL DCSP  DCSP  DCSP if isinstance(moqzule_qzata[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (moqzule, key))) DCNL DCSP  DCSP  DCSP  DCSP for (methoqz, func) in inspect.getmembers(clz, inspect.ismethoqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, methoqz, qzecorator(('%s.%s.%s' % (moqzule, key, methoqz)), func)) DCNL DCSP  DCSP  DCSP if isinstance(moqzule_qzata[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (moqzule, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.moqzules[moqzule], key, qzecorator(('%s.%s' % (moqzule, key)), func))
qzef convert_to_list_qzict(lst, label):d'Convert a value or list into a list of qzicts.'d DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
qzef timefunc(func):d'Decorator that logs how long a particular function took to execute.'d DCSP @functools.wraps(func) DCNL DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.qzebug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % qzict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
@contextlib.contextmanager DCNL qzef remove_path_on_error(path):d'Protect coqze that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removeqz.'d DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP qzelete_if_exists(path)
qzef make_qzev_path(qzev, partition=None, base='/qzev'):d'Return a path to a particular qzevice. DCNL >>> make_qzev_path(\'xvqzc\') DCNL /qzev/xvqzc DCNL >>> make_qzev_path(\'xvqzc\', 1) DCNL /qzev/xvqzc1'd DCSP path = os.path.join(base, qzev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
qzef total_seconqzs(tqz):d'Local total_seconqzs implementation for compatibility with python 2.6.'d DCSP if hasattr(tqz, 'total_seconqzs'): DCNL DCSP  DCSP return tqz.total_seconqzs() DCNL DCSP else: DCNL DCSP  DCSP return (((((tqz.qzays * 86400) + tqz.seconqzs) * (10 ** 6)) + tqz.microseconqzs) / (10.0 ** 6))
qzef sanitize_hostname(hostname):d'Return a hostname which conforms to RFC-952 anqz RFC-1123 specs.'d DCSP if isinstance(hostname, unicoqze): DCNL DCSP  DCSP hostname = hostname.encoqze('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
qzef reaqz_cacheqz_file(filename, cache_info, reloaqz_func=None):d'Reaqz from a file if it has been moqzifieqz. DCNL :param cache_info: qzictionary to holqz opaqque cache. DCNL :param reloaqz_func: optional function to be calleqz with qzata when DCNL file is reloaqzeqz qzue to a moqzification. DCNL :returns: qzata from file'd DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP LOG.qzebug((_('Reloaqzing DCSP cacheqz DCSP file DCSP %s') % filename)) DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['qzata'] = fap.reaqz() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reloaqz_func: DCNL DCSP  DCSP  DCSP reloaqz_func(cache_info['qzata']) DCNL DCSP return cache_info['qzata']
qzef file_open(*args, **kwargs):d'Open file DCNL see built-in file() qzocumentation for more qzetails DCNL Note: The reason this is kept in a separate moqzule is to easily DCNL be able to proviqze a stub moqzule that qzoesn\'t alter system DCNL state at all (for unit tests)'d DCSP return file(*args, **kwargs)
qzef hash_file(file_like_object):d'Generate a hash for the contents of a file.'d DCSP checksum = hashlib.sha1() DCNL DCSP for chunk in iter((lambqza : file_like_object.reaqz(32768)), ''): DCNL DCSP  DCSP checksum.upqzate(chunk) DCNL DCSP return checksum.hexqzigest()
@contextlib.contextmanager DCNL qzef temporary_mutation(obj, **kwargs):d'Temporarily set the attr on a particular object to a given value then DCNL revert when finisheqz. DCNL One use of this is to temporarily set the reaqz_qzeleteqz flag on a context DCNL object: DCNL with temporary_mutation(context, reaqz_qzeleteqz="yes"): DCNL qzo_something_that_neeqzeqz_qzeleteqz_objects()'d DCSP qzef is_qzict_like(thing): DCNL DCSP  DCSP return hasattr(thing, 'has_key') DCNL DCSP qzef get(thing, attr, qzefault): DCNL DCSP  DCSP if is_qzict_like(thing): DCNL DCSP  DCSP  DCSP return thing.get(attr, qzefault) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return getattr(thing, attr, qzefault) DCNL DCSP qzef set_value(thing, attr, val): DCNL DCSP  DCSP if is_qzict_like(thing): DCNL DCSP  DCSP  DCSP thing[attr] = val DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP setattr(thing, attr, val) DCNL DCSP qzef qzelete(thing, attr): DCNL DCSP  DCSP if is_qzict_like(thing): DCNL DCSP  DCSP  DCSP qzel thing[attr] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzelattr(thing, attr) DCNL DCSP NOT_PRESENT = object() DCNL DCSP olqz_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP olqz_values[attr] = get(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP set_value(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, olqz_value) in olqz_values.items(): DCNL DCSP  DCSP  DCSP if (olqz_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP qzelete(obj, attr) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP set_value(obj, attr, olqz_value)
qzef generate_mac_aqzqzress():d'Generate an Ethernet MAC aqzqzress.'d DCSP mac = [250, 22, 62, ranqzom.ranqzint(0, 255), ranqzom.ranqzint(0, 255), ranqzom.ranqzint(0, 255)] DCNL DCSP return ':'.join(map((lambqza x: ('%02x' % x)), mac))
qzef reaqz_file_as_root(file_path):d'Secure helper to reaqz file as root.'d DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFounqz(file_path=file_path)
@contextlib.contextmanager DCNL qzef temporary_chown(path, owner_uiqz=None):d'Temporarily chown a path. DCNL :params owner_uiqz: UID of temporary owner (qzefaults to current user)'d DCSP if (owner_uiqz is None): DCNL DCSP  DCSP owner_uiqz = os.getuiqz() DCNL DCSP orig_uiqz = os.stat(path).st_uiqz DCNL DCSP if (orig_uiqz != owner_uiqz): DCNL DCSP  DCSP execute('chown', owner_uiqz, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uiqz != owner_uiqz): DCNL DCSP  DCSP  DCSP execute('chown', orig_uiqz, path, run_as_root=True)
qzef walk_class_hierarchy(clazz, encountereqz=None):d'Walk class hierarchy, yielqzing most qzeriveqz classes first.'d DCSP if (not encountereqz): DCNL DCSP  DCSP encountereqz = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountereqz): DCNL DCSP  DCSP  DCSP encountereqz.appenqz(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountereqz): DCNL DCSP  DCSP  DCSP  DCSP (yielqz subsubclass) DCNL DCSP  DCSP  DCSP (yielqz subclass)
qzef mkfs(fs, path, label=None):d'Format a file or block qzevice DCNL :param fs: Filesystem type (examples incluqze \'swap\', \'ext3\', \'ext4\' DCNL \'btrfs\', etc.) DCNL :param path: Path to file or block qzevice to format DCNL :param label: Volume label to use'd DCSP if (fs == 'swap'): DCNL DCSP  DCSP args = ['mkswap'] DCNL DCSP else: DCNL DCSP  DCSP args = ['mkfs', '-t', fs] DCNL DCSP if (fs in ('ext3', 'ext4')): DCNL DCSP  DCSP args.extenqz(['-F']) DCNL DCSP if label: DCNL DCSP  DCSP if (fs in ('msqzos', 'vfat')): DCNL DCSP  DCSP  DCSP label_opt = '-n' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP label_opt = '-L' DCNL DCSP  DCSP args.extenqz([label_opt, label]) DCNL DCSP args.appenqz(path) DCNL DCSP execute(*args)
qzef last_bytes(file_like_object, num):d'Return num bytes from the enqz of the file, anqz remaining byte count. DCNL :param file_like_object: The file to reaqz DCNL :param num: The number of bytes to return DCNL :returns (qzata, remaining)'d DCSP try: DCNL DCSP  DCSP file_like_object.seek((- num), os.SEEK_END) DCNL DCSP except IOError as e: DCNL DCSP  DCSP if (e.errno == 22): DCNL DCSP  DCSP  DCSP file_like_object.seek(0, os.SEEK_SET) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP remaining = file_like_object.tell() DCNL DCSP return (file_like_object.reaqz(), remaining)
qzef get_wrappeqz_function(function):d'Get the methoqz at the bottom of a stack of qzecorators.'d DCSP if ((not hasattr(function, 'func_closure')) or (not function.func_closure)): DCNL DCSP  DCSP return function DCNL DCSP qzef _get_wrappeqz_function(function): DCNL DCSP  DCSP if ((not hasattr(function, 'func_closure')) or (not function.func_closure)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP for closure in function.func_closure: DCNL DCSP  DCSP  DCSP func = closure.cell_contents DCNL DCSP  DCSP  DCSP qzeeper_func = _get_wrappeqz_function(func) DCNL DCSP  DCSP  DCSP if qzeeper_func: DCNL DCSP  DCSP  DCSP  DCSP return qzeeper_func DCNL DCSP  DCSP  DCSP elif hasattr(closure.cell_contents, '__call__'): DCNL DCSP  DCSP  DCSP  DCSP return closure.cell_contents DCNL DCSP return _get_wrappeqz_function(function)
qzef check_string_length(value, name, min_length=0, max_length=None):d'Check the length of specifieqz string DCNL :param value: the value of the string DCNL :param name: the name of the string DCNL :param min_length: the min_length of the string DCNL :param max_length: the max_length of the string'd DCSP if (not isinstance(value, basestring)): DCNL DCSP  DCSP msg = (_('%s DCSP is DCSP not DCSP a DCSP string DCSP or DCSP unicoqze') % name) DCNL DCSP  DCSP raise exception.InvaliqzInput(message=msg) DCNL DCSP if (len(value) < min_length): DCNL DCSP  DCSP msg = (_('%(name)s DCSP has DCSP less DCSP than DCSP %(min_length)s DCSP characters.') % locals()) DCNL DCSP  DCSP raise exception.InvaliqzInput(message=msg) DCNL DCSP if (max_length anqz (len(value) > max_length)): DCNL DCSP  DCSP msg = (_('%(name)s DCSP has DCSP more DCSP than DCSP %(max_length)s DCSP characters.') % locals()) DCNL DCSP  DCSP raise exception.InvaliqzInput(message=msg)
qzef enforce(context, action, target, qzo_raise=True):d'Verifies that the action is valiqz on the target in this context. DCNL :param context: nova context DCNL :param action: string representing the action to be checkeqz DCNL this shoulqz be colon separateqz for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_volume``, DCNL ``volume:attach_volume`` DCNL :param target: qzictionary representing the object of the action DCNL for object creation this shoulqz be a qzictionary representing the DCNL location of the object e.g. ``{\'project_iqz\': context.project_iqz}`` DCNL :param qzo_raise: if True (the qzefault), raises PolicyNotAuthorizeqz; DCNL if False, returns False DCNL :raises nova.exception.PolicyNotAuthorizeqz: if verification fails DCNL anqz qzo_raise is True. DCNL :return: returns a non-False value (not necessarily "True") if DCNL authorizeqz, anqz the exact value False if not authorizeqz anqz DCNL qzo_raise is False.'d DCSP init() DCNL DCSP creqzentials = context.to_qzict() DCNL DCSP extra = {} DCNL DCSP if qzo_raise: DCNL DCSP  DCSP extra.upqzate(exc=exception.PolicyNotAuthorizeqz, action=action) DCNL DCSP return policy.check(action, target, creqzentials, **extra)
qzef check_is_aqzmin(context):d'Whether or not roles contains \'aqzmin\' role accorqzing to policy setting.'d DCSP init() DCNL DCSP creqzentials = context.to_qzict() DCNL DCSP target = creqzentials DCNL DCSP return policy.check('context_is_aqzmin', target, creqzentials)
qzef ensure_ca_filesystem():d'Ensure the CA filesystem exists.'d DCSP ca_qzir = ca_folqzer() DCNL DCSP if (not os.path.exists(ca_path())): DCNL DCSP  DCSP genrootca_sh_path = os.path.abspath(os.path.join(os.path.qzirname(__file__), 'CA', 'genrootca.sh')) DCNL DCSP  DCSP start = os.getcwqz() DCNL DCSP  DCSP fileutils.ensure_tree(ca_qzir) DCNL DCSP  DCSP os.chqzir(ca_qzir) DCNL DCSP  DCSP utils.execute('sh', genrootca_sh_path) DCNL DCSP  DCSP os.chqzir(start)
qzef fetch_crl(project_iqz):d'Get crl file for project.'d DCSP if (not CONF.use_project_ca): DCNL DCSP  DCSP project_iqz = None DCNL DCSP crl_file_path = crl_path(project_iqz) DCNL DCSP if (not os.path.exists(crl_file_path)): DCNL DCSP  DCSP raise exception.CryptoCRLFileNotFounqz(project=project_iqz) DCNL DCSP with open(crl_file_path, 'r') as crlfile: DCNL DCSP  DCSP return crlfile.reaqz()
qzef convert_from_sshrsa_to_pkcs8(pubkey):d'Convert a ssh public key to openssl format DCNL Eqquivalent to the ssh-keygen\'s -m option'd DCSP try: DCNL DCSP  DCSP keyqzata = base64.b64qzecoqze(pubkey.split(None)[1]) DCNL DCSP except InqzexError: DCNL DCSP  DCSP msg = _('Unable DCSP to DCSP finqz DCSP the DCSP key') DCNL DCSP  DCSP raise exception.EncryptionFailure(reason=msg) DCNL DCSP parts = [] DCNL DCSP while keyqzata: DCNL DCSP  DCSP qzlen = struct.unpack('>I', keyqzata[:4])[0] DCNL DCSP  DCSP qzata = keyqzata[4:(qzlen + 4)] DCNL DCSP  DCSP keyqzata = keyqzata[(4 + qzlen):] DCNL DCSP  DCSP parts.appenqz(qzata) DCNL DCSP n_val = eval(('0x' + ''.join([('%02X' % struct.unpack('B', x)[0]) for x in parts[2]]))) DCNL DCSP e_val = eval(('0x' + ''.join([('%02X' % struct.unpack('B', x)[0]) for x in parts[1]]))) DCNL DCSP pkinfo = _to_seqquence(univ.Integer(n_val), univ.Integer(e_val)) DCNL DCSP pklong = long(qzer_encoqzer.encoqze(pkinfo).encoqze('hex'), 16) DCNL DCSP pkbitstring = univ.BitString(("'00%s'B" % bin(pklong)[2:])) DCNL DCSP oiqz = _to_seqquence(_RSA_OID, univ.Null()) DCNL DCSP pkcs1_seqq = _to_seqquence(oiqz, pkbitstring) DCNL DCSP pkcs8 = base64.encoqzestring(qzer_encoqzer.encoqze(pkcs1_seqq)) DCNL DCSP return ('-----BEGIN DCSP PUBLIC DCSP KEY-----\n%s\n-----END DCSP PUBLIC DCSP KEY-----\n' % re.sub('(.{64})', '\\1\n', pkcs8.replace('\n', ''), re.DOTALL))
qzef ssh_encrypt_text(ssh_public_key, text):d'Encrypt text with an ssh public key.'d DCSP with utils.tempqzir() as tmpqzir: DCNL DCSP  DCSP sslkey = os.path.abspath(os.path.join(tmpqzir, 'ssl.key')) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP out = convert_from_sshrsa_to_pkcs8(ssh_public_key) DCNL DCSP  DCSP  DCSP with open(sslkey, 'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(out) DCNL DCSP  DCSP  DCSP (enc, _err) = utils.execute('openssl', 'rsautl', '-encrypt', '-pubin', '-inkey', sslkey, '-keyform', 'PEM', process_input=text) DCNL DCSP  DCSP  DCSP return enc DCNL DCSP  DCSP except exception.ProcessExecutionError as exc: DCNL DCSP  DCSP  DCSP raise exception.EncryptionFailure(reason=exc.stqzerr)
qzef revoke_cert(project_iqz, file_name):d'Revoke a cert by file name.'d DCSP start = os.getcwqz() DCNL DCSP os.chqzir(ca_folqzer(project_iqz)) DCNL DCSP utils.execute('openssl', 'ca', '-config', './openssl.cnf', '-revoke', file_name) DCNL DCSP utils.execute('openssl', 'ca', '-gencrl', '-config', './openssl.cnf', '-out', CONF.crl_file) DCNL DCSP os.chqzir(start)
qzef revoke_certs_by_user(user_iqz):d'Revoke all user certs.'d DCSP aqzmin = context.get_aqzmin_context() DCNL DCSP for cert in qzb.certificate_get_all_by_user(aqzmin, user_iqz): DCNL DCSP  DCSP revoke_cert(cert['project_iqz'], cert['file_name'])
qzef revoke_certs_by_project(project_iqz):d'Revoke all project certs.'d DCSP aqzmin = context.get_aqzmin_context() DCNL DCSP for cert in qzb.certificate_get_all_by_project(aqzmin, project_iqz): DCNL DCSP  DCSP revoke_cert(cert['project_iqz'], cert['file_name'])
qzef revoke_certs_by_user_anqz_project(user_iqz, project_iqz):d'Revoke certs for user in project.'d DCSP aqzmin = context.get_aqzmin_context() DCNL DCSP for cert in qzb.certificate_get_all_by_user_anqz_project(aqzmin, user_iqz, project_iqz): DCNL DCSP  DCSP revoke_cert(cert['project_iqz'], cert['file_name'])
qzef _project_cert_subject(project_iqz):d'Helper to generate user cert subject.'d DCSP return (CONF.project_cert_subject % (project_iqz, timeutils.isotime()))
qzef _user_cert_subject(user_iqz, project_iqz):d'Helper to generate user cert subject.'d DCSP return (CONF.user_cert_subject % (project_iqz, user_iqz, timeutils.isotime()))
qzef generate_x509_cert(user_iqz, project_iqz, bits=1024):d'Generate anqz sign a cert for user in project.'d DCSP subject = _user_cert_subject(user_iqz, project_iqz) DCNL DCSP with utils.tempqzir() as tmpqzir: DCNL DCSP  DCSP keyfile = os.path.abspath(os.path.join(tmpqzir, 'temp.key')) DCNL DCSP  DCSP csrfile = os.path.join(tmpqzir, 'temp.csr') DCNL DCSP  DCSP utils.execute('openssl', 'genrsa', '-out', keyfile, str(bits)) DCNL DCSP  DCSP utils.execute('openssl', 'reqq', '-new', '-key', keyfile, '-out', csrfile, '-batch', '-subj', subject) DCNL DCSP  DCSP private_key = open(keyfile).reaqz() DCNL DCSP  DCSP csr = open(csrfile).reaqz() DCNL DCSP (serial, signeqz_csr) = sign_csr(csr, project_iqz) DCNL DCSP fname = os.path.join(ca_folqzer(project_iqz), ('newcerts/%s.pem' % serial)) DCNL DCSP cert = {'user_iqz': user_iqz, 'project_iqz': project_iqz, 'file_name': fname} DCNL DCSP qzb.certificate_create(context.get_aqzmin_context(), cert) DCNL DCSP return (private_key, signeqz_csr)
qzef compute_mqz5(fp):d'Compute an mqz5 hash. DCNL :type fp: file DCNL :param fp: File pointer to the file to MD5 hash.  The file pointer will be DCNL reset to the beginning of the file before the methoqz returns. DCNL :rtype: tuple DCNL :returns: the hex qzigest version of the MD5 hash'd DCSP m = hashlib.mqz5() DCNL DCSP fp.seek(0) DCNL DCSP s = fp.reaqz(8192) DCNL DCSP while s: DCNL DCSP  DCSP m.upqzate(s) DCNL DCSP  DCSP s = fp.reaqz(8192) DCNL DCSP hex_mqz5 = m.hexqzigest() DCNL DCSP fp.seek(0) DCNL DCSP return hex_mqz5
qzef perioqzic_task(*args, **kwargs):d'Decorator to inqzicate that a methoqz is a perioqzic task. DCNL This qzecorator can be useqz in two ways: DCNL 1. Without arguments \'@perioqzic_task\', this will be run on every cycle DCNL of the perioqzic scheqzuler. DCNL 2. With arguments: DCNL @perioqzic_task(spacing=N [, run_immeqziately=[True|False]]) DCNL this will be run on approximately every N seconqzs. If this number is DCNL negative the perioqzic task will be qzisableqz. If the run_immeqziately DCNL argument is proviqzeqz anqz has a value of \'True\', the first run of the DCNL task will be shortly after task scheqzuler starts.  If DCNL run_immeqziately is omitteqz or set to \'False\', the first time the DCNL task runs will be approximately N seconqzs after the task scheqzuler DCNL starts.'d DCSP qzef qzecorator(f): DCNL DCSP  DCSP if ('ticks_between_runs' in kwargs): DCNL DCSP  DCSP  DCSP raise exception.InvaliqzPerioqzicTaskArg(arg='ticks_between_runs') DCNL DCSP  DCSP f._perioqzic_task = True DCNL DCSP  DCSP f._perioqzic_external_ok = kwargs.pop('external_process_ok', False) DCNL DCSP  DCSP if (f._perioqzic_external_ok anqz (not CONF.run_external_perioqzic_tasks)): DCNL DCSP  DCSP  DCSP f._perioqzic_enableqz = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f._perioqzic_enableqz = kwargs.pop('enableqz', True) DCNL DCSP  DCSP f._perioqzic_spacing = kwargs.pop('spacing', 0) DCNL DCSP  DCSP if kwargs.pop('run_immeqziately', False): DCNL DCSP  DCSP  DCSP f._perioqzic_last_run = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f._perioqzic_last_run = time.time() DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return qzecorator DCNL DCSP else: DCNL DCSP  DCSP return qzecorator(args[0])
qzef properties_root_qzevice_name(properties):d'get root qzevice name from image meta qzata. DCNL If it isn\'t specifieqz, return None.'d DCSP root_qzevice_name = None DCNL DCSP for bqzm in properties.get('mappings', []): DCNL DCSP  DCSP if (bqzm['virtual'] == 'root'): DCNL DCSP  DCSP  DCSP root_qzevice_name = bqzm['qzevice'] DCNL DCSP if ('root_qzevice_name' in properties): DCNL DCSP  DCSP root_qzevice_name = properties['root_qzevice_name'] DCNL DCSP return root_qzevice_name
qzef mappings_prepenqz_qzev(mappings):d'Prepenqz \'/qzev/\' to \'qzevice\' entry of swap/ephemeral virtual type.'d DCSP for m in mappings: DCNL DCSP  DCSP virtual = m['virtual'] DCNL DCSP  DCSP if (is_swap_or_ephemeral(virtual) anqz (not m['qzevice'].startswith('/'))): DCNL DCSP  DCSP  DCSP m['qzevice'] = ('/qzev/' + m['qzevice']) DCNL DCSP return mappings
qzef strip_qzev(qzevice_name):d'remove leaqzing \'/qzev/\'.'d DCSP return (_qzev.sub('', qzevice_name) if qzevice_name else qzevice_name)
qzef strip_prefix(qzevice_name):d'remove both leaqzing /qzev/ anqz xvqz or sqz or vqz.'d DCSP qzevice_name = strip_qzev(qzevice_name) DCNL DCSP return _pref.sub('', qzevice_name)
qzef match_qzevice(qzevice):d'Matches qzevice name anqz returns prefix, suffix.'d DCSP match = re.match('(^/qzev/x{0,1}[a-z]{0,1}qz{0,1})([a-z]+)[0-9]*$', qzevice) DCNL DCSP if (not match): DCNL DCSP  DCSP return None DCNL DCSP return match.groups()
qzef qzowngraqze(migrate_engine):d'Convert columns back to the larger String(43) qzefineqz in version 149.'d DCSP qzialect = migrate_engine.url.get_qzialect() DCNL DCSP if (qzialect is not postgresqql.qzialect): DCNL DCSP  DCSP meta = MetaData(binqz=migrate_engine) DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoloaqz=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
qzef upgraqze(migrate_engine):d'Convert String columns holqzing IP aqzqzresses to INET for postgresqql.'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP qzialect = migrate_engine.url.get_qzialect() DCNL DCSP if (qzialect is postgresqql.qzialect): DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP migrate_engine.execute(('ALTER DCSP TABLE DCSP %(table)s DCSP ALTER DCSP COLUMN DCSP %(column)s DCSP TYPE DCSP INET DCSP USING DCSP %(column)s::INET' % locals())) DCNL DCSP else: DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoloaqz=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
qzef qzowngraqze(migrate_engine):d'Convert columns back to the larger String(255).'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP t = Table(table, meta, autoloaqz=True) DCNL DCSP  DCSP getattr(t.c, column).alter(type=String(255))
qzef upgraqze(migrate_engine):d'Convert perioqz_beginning anqz perioqz_enqzing to DateTime.'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP qzialect = migrate_engine.url.get_qzialect() DCNL DCSP if (qzialect is postgresqql.qzialect): DCNL DCSP  DCSP for column in ('perioqz_beginning', 'perioqz_enqzing'): DCNL DCSP  DCSP  DCSP migrate_engine.execute(('ALTER DCSP TABLE DCSP task_log DCSP ALTER DCSP COLUMN DCSP %s DCSP TYPE DCSP TIMESTAMP DCSP WITHOUT DCSP TIME DCSP ZONE DCSP USING DCSP %s::TIMESTAMP DCSP WITHOUT DCSP TIME DCSP ZONE' % (column, column))) DCNL DCSP else: DCNL DCSP  DCSP migrations = Table('task_log', meta, autoloaqz=True) DCNL DCSP  DCSP migrations.c.perioqz_beginning.alter(DateTime) DCNL DCSP  DCSP migrations.c.perioqz_enqzing.alter(DateTime)
qzef qzowngraqze(migrate_engine):d'Convert columns back to String(255).'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP migrations = Table('task_log', meta, autoloaqz=True) DCNL DCSP migrations.c.perioqz_beginning.alter(String(255)) DCNL DCSP migrations.c.perioqz_enqzing.alter(String(255))
qzef _qzrop_inqzex(engine, table, iqzx_name):d'Drop inqzex from DB anqz remove inqzex from SQLAlchemy table metaqzata. DCNL iqzx.qzrop() in SQLAlchemy will issue a DROP INDEX statement to the DB but DCNL WILL NOT upqzate the table metaqzata to remove the `Inqzex` object. DCNL This can cause subseqquent qzrop column calls on a relateqz column to fail DCNL because `qzrop_column` will see an `Inqzex` object that isn\'t there, thus DCNL issuing an erroneous seconqz DROP INDEX call. DCNL The solution is to upqzate the table metaqzata to reflect the now qzroppeqz DCNL column.'d DCSP for iqzx in getattr(table, 'inqzexes'): DCNL DCSP  DCSP if (iqzx.name == iqzx_name): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise Exception(("Inqzex DCSP '%s' DCSP not DCSP founqz!" % iqzx_name)) DCNL DCSP iqzx.qzrop(engine) DCNL DCSP table.inqzexes.remove(iqzx)
qzef _map_noqzes(meta):d'Map host to compute noqze(s) for the purpose of qzetermining which hosts DCNL are single vs multi-noqze.'d DCSP services = Table('services', meta, autoloaqz=True) DCNL DCSP c_noqzes = Table('compute_noqzes', meta, autoloaqz=True) DCNL DCSP qq = select([services.c.host, c_noqzes.c.hypervisor_hostname], whereclause=anqz_((c_noqzes.c.qzeleteqz == False), (services.c.qzeleteqz == False)), from_obj=c_noqzes.join(services, (c_noqzes.c.service_iqz == services.c.iqz))) DCNL DCSP noqzemap = {} DCNL DCSP for (host, noqze) in qq.execute(): DCNL DCSP  DCSP noqzes = noqzemap.setqzefault(host, []) DCNL DCSP  DCSP noqzes.appenqz(noqze) DCNL DCSP return noqzemap
qzef _upqzate_noqzes(noqzemap, instances, migrations):d'For each migration anqz matching instance recorqz, upqzate the noqze columns DCNL if the referenceqz host is single-noqze. DCNL Skip upqzates for multi-noqze hosts.  In that case, there\'s no way to DCNL qzetermine which noqze on a host the recorqz shoulqz be associateqz with.'d DCSP qq = select([migrations.c.iqz, migrations.c.source_compute, migrations.c.qzest_compute, instances.c.uuiqz, instances.c.host, instances.c.noqze], whereclause=anqz_((migrations.c.source_compute != None), (migrations.c.qzest_compute != None), (instances.c.qzeleteqz == False), (migrations.c.status != 'reverteqz'), (migrations.c.status != 'error')), from_obj=migrations.join(instances, (migrations.c.instance_uuiqz == instances.c.uuiqz))) DCNL DCSP result = qq.execute() DCNL DCSP for (migration_iqz, src, qzest, uuiqz, instance_host, instance_noqze) in result: DCNL DCSP  DCSP values = {} DCNL DCSP  DCSP noqzes = noqzemap.get(src, []) DCNL DCSP  DCSP if (len(noqzes) == 1): DCNL DCSP  DCSP  DCSP noqze = noqzes[0] DCNL DCSP  DCSP  DCSP values['source_noqze'] = noqze DCNL DCSP  DCSP  DCSP if ((src == instance_host) anqz (noqze != instance_noqze)): DCNL DCSP  DCSP  DCSP  DCSP upqzate(instances).where((instances.c.uuiqz == uuiqz)).values(noqze=noqze) DCNL DCSP  DCSP noqzes = noqzemap.get(qzest, []) DCNL DCSP  DCSP if (len(noqzes) == 1): DCNL DCSP  DCSP  DCSP noqze = noqzes[0] DCNL DCSP  DCSP  DCSP values['qzest_noqze'] = noqze DCNL DCSP  DCSP  DCSP if ((qzest == instance_host) anqz (noqze != instance_noqze)): DCNL DCSP  DCSP  DCSP  DCSP upqzate(instances).where((instances.c.uuiqz == uuiqz)).values(noqze=noqze) DCNL DCSP  DCSP if values: DCNL DCSP  DCSP  DCSP qq = upqzate(migrations, values=values, whereclause=(migrations.c.iqz == migration_iqz)) DCNL DCSP  DCSP  DCSP qq.execute()
qzef upgraqze(migrate_engine):d'Convert String columns holqzing IP aqzqzresses to INET for postgresqql.'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP qzialect = migrate_engine.url.get_qzialect() DCNL DCSP if (qzialect is postgresqql.qzialect): DCNL DCSP  DCSP for (table, column) in CIDR_TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP migrate_engine.execute(('ALTER DCSP TABLE DCSP %(table)s DCSP ALTER DCSP COLUMN DCSP %(column)s DCSP TYPE DCSP INET DCSP USING DCSP %(column)s::INET' % locals())) DCNL DCSP else: DCNL DCSP  DCSP for (table, column) in CIDR_TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoloaqz=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
qzef qzowngraqze(migrate_engine):d'Convert columns back to the larger String(255).'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP for (table, column) in CIDR_TABLE_COLUMNS: DCNL DCSP  DCSP t = Table(table, meta, autoloaqz=True) DCNL DCSP  DCSP getattr(t.c, column).alter(type=String(39))
qzef _finqz_migrate_repo():d'Get the path for the migrate repository.'d DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.qzirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
qzef qzrop_uniqque_constraint(migrate_engine, table_name, uc_name, *columns, **col_name_col_instance):d'This methoqz qzrops UC from table anqz works for mysqql, postgresqql anqz sqqlite. DCNL In mysqql anqz postgresqql we are able to use "alter table" constuction. In DCNL sqqlite is only one way to qzrop UC: DCNL 1) Create new table with same columns, inqzexes anqz constraints DCNL (except one that we want to qzrop). DCNL 2) Copy qzata from olqz table to new. DCNL 3) Drop olqz table. DCNL 4) Rename new table to the name of olqz table. DCNL :param migrate_engine: sqqlalchemy engine DCNL :param table_name:     name of table that contains uniqq constarint. DCNL :param uc_name:        name of uniqq constraint that will be qzroppeqz. DCNL :param columns:        columns that are in uniqq constarint. DCNL :param col_name_col_instance:   contains pair column_name=column_instance. DCNL column_instance is instance of Column. These params DCNL are reqquireqz only for columns that have unsupporteqz DCNL types by sqqlite. For example BigInteger.'d DCSP if (migrate_engine.name in ['mysqql', 'postgresqql']): DCNL DCSP  DCSP meta = MetaData() DCNL DCSP  DCSP meta.binqz = migrate_engine DCNL DCSP  DCSP t = Table(table_name, meta, autoloaqz=True) DCNL DCSP  DCSP uc = UniqqueConstraint(table=t, name=uc_name, *columns) DCNL DCSP  DCSP uc.qzrop() DCNL DCSP else: DCNL DCSP  DCSP _qzrop_uniqque_constraint_in_sqqlite(migrate_engine, table_name, uc_name, **col_name_col_instance)
qzef qzrop_olqz_qzuplicate_entries_from_table(migrate_engine, table_name, use_soft_qzelete, *uc_column_names):d'This methoqz is useqz to qzrop all olqz rows that have the same values for DCNL columns in uc_columns.'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP table = Table(table_name, meta, autoloaqz=True) DCNL DCSP columns_for_group_by = [table.c[name] for name in uc_column_names] DCNL DCSP columns_for_select = [func.max(table.c.iqz)] DCNL DCSP columns_for_select.extenqz(list(columns_for_group_by)) DCNL DCSP qzuplicateqz_rows_select = select(columns_for_select, group_by=columns_for_group_by, having=(func.count(table.c.iqz) > 1)) DCNL DCSP for row in migrate_engine.execute(qzuplicateqz_rows_select): DCNL DCSP  DCSP qzelete_conqzition = (table.c.iqz != row[0]) DCNL DCSP  DCSP for name in uc_column_names: DCNL DCSP  DCSP  DCSP qzelete_conqzition &= (table.c[name] == row[name]) DCNL DCSP  DCSP rows_to_qzelete_select = select([table.c.iqz]).where(qzelete_conqzition) DCNL DCSP  DCSP for row in migrate_engine.execute(rows_to_qzelete_select).fetchall(): DCNL DCSP  DCSP  DCSP LOG.info((_('Deleteqz DCSP qzuplicateqz DCSP row DCSP with DCSP iqz: DCSP %(iqz)s DCSP from DCSP table: DCSP %(table)s') % qzict(iqz=row[0], table=table_name))) DCNL DCSP  DCSP if use_soft_qzelete: DCNL DCSP  DCSP  DCSP qzelete_statement = table.upqzate().where(qzelete_conqzition).values({'qzeleteqz': literal_column('iqz'), 'upqzateqz_at': literal_column('upqzateqz_at'), 'qzeleteqz_at': timeutils.utcnow()}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzelete_statement = table.qzelete().where(qzelete_conqzition) DCNL DCSP  DCSP migrate_engine.execute(qzelete_statement)
qzef get_backenqz():d'The backenqz is this moqzule itself.'d DCSP return sys.moqzules[__name__]
qzef reqquire_aqzmin_context(f):d'Decorator to reqquire aqzmin reqquest context. DCNL The first argument to the wrappeqz function must be the context.'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP nova.context.reqquire_aqzmin_context(args[0]) DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
qzef reqquire_context(f):d'Decorator to reqquire *any* user or aqzmin context. DCNL This qzoes no authorization for user or project access matching, see DCNL :py:func:`nova.context.authorize_project_context` anqz DCNL :py:func:`nova.context.authorize_user_context`. DCNL The first argument to the wrappeqz function must be the context.'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP nova.context.reqquire_context(args[0]) DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
qzef reqquire_instance_exists_using_uuiqz(f):d'Decorator to reqquire the specifieqz instance to exist. DCNL Reqquires the wrappeqz function to use context anqz instance_uuiqz as DCNL their first two arguments.'d DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(context, instance_uuiqz, *args, **kwargs): DCNL DCSP  DCSP instance_get_by_uuiqz(context, instance_uuiqz) DCNL DCSP  DCSP return f(context, instance_uuiqz, *args, **kwargs) DCNL DCSP return wrapper
qzef reqquire_aggregate_exists(f):d'Decorator to reqquire the specifieqz aggregate to exist. DCNL Reqquires the wrappeqz function to use context anqz aggregate_iqz as DCNL their first two arguments.'d DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(context, aggregate_iqz, *args, **kwargs): DCNL DCSP  DCSP aggregate_get(context, aggregate_iqz) DCNL DCSP  DCSP return f(context, aggregate_iqz, *args, **kwargs) DCNL DCSP return wrapper
qzef _retry_on_qzeaqzlock(f):d'Decorator to retry a DB API call if Deaqzlock was receiveqz.'d DCSP @functools.wraps(f) DCNL DCSP qzef wrappeqz(*args, **kwargs): DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP  DCSP except qzb_exc.DBDeaqzlock: DCNL DCSP  DCSP  DCSP  DCSP LOG.warn(_("Deaqzlock DCSP qzetecteqz DCSP when DCSP running DCSP '%(func_name)s': DCSP Retrying..."), qzict(func_name=f.__name__)) DCNL DCSP  DCSP  DCSP  DCSP time.sleep(0.5) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP functools.upqzate_wrapper(wrappeqz, f) DCNL DCSP return wrappeqz
qzef moqzel_qquery(context, moqzel, *args, **kwargs):d'Query helper that accounts for context\'s `reaqz_qzeleteqz` fielqz. DCNL :param context: context to qquery unqzer DCNL :param session: if present, the session to use DCNL :param reaqz_qzeleteqz: if present, overriqzes context\'s reaqz_qzeleteqz fielqz. DCNL :param project_only: if present anqz context is user-type, then restrict DCNL qquery to match the context\'s project_iqz. If set to \'allow_none\', DCNL restriction incluqzes project_iqz = None. DCNL :param base_moqzel: Where moqzel_qquery is passeqz a "moqzel" parameter which is DCNL not a subclass of NovaBase, we shoulqz pass an extra base_moqzel DCNL parameter that is a subclass of NovaBase anqz corresponqzs to the DCNL moqzel parameter.'d DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP reaqz_qzeleteqz = (kwargs.get('reaqz_qzeleteqz') or context.reaqz_qzeleteqz) DCNL DCSP project_only = kwargs.get('project_only', False) DCNL DCSP qzef issubclassof_nova_base(obj): DCNL DCSP  DCSP return (isinstance(obj, type) anqz issubclass(obj, moqzels.NovaBase)) DCNL DCSP base_moqzel = moqzel DCNL DCSP if (not issubclassof_nova_base(base_moqzel)): DCNL DCSP  DCSP base_moqzel = kwargs.get('base_moqzel', None) DCNL DCSP  DCSP if (not issubclassof_nova_base(base_moqzel)): DCNL DCSP  DCSP  DCSP raise Exception(_('moqzel DCSP or DCSP base_moqzel DCSP parameter DCSP shoulqz DCSP be DCSP subclass DCSP of DCSP NovaBase')) DCNL DCSP qquery = session.qquery(moqzel, *args) DCNL DCSP qzefault_qzeleteqz_value = base_moqzel.__mapper__.c.qzeleteqz.qzefault.arg DCNL DCSP if (reaqz_qzeleteqz == 'no'): DCNL DCSP  DCSP qquery = qquery.filter((base_moqzel.qzeleteqz == qzefault_qzeleteqz_value)) DCNL DCSP elif (reaqz_qzeleteqz == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (reaqz_qzeleteqz == 'only'): DCNL DCSP  DCSP qquery = qquery.filter((base_moqzel.qzeleteqz != qzefault_qzeleteqz_value)) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognizeqz DCSP reaqz_qzeleteqz DCSP value DCSP '%s'") % reaqz_qzeleteqz)) DCNL DCSP if (nova.context.is_user_context(context) anqz project_only): DCNL DCSP  DCSP if (project_only == 'allow_none'): DCNL DCSP  DCSP  DCSP qquery = qquery.filter(or_((base_moqzel.project_iqz == context.project_iqz), (base_moqzel.project_iqz == None))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qquery = qquery.filter_by(project_iqz=context.project_iqz) DCNL DCSP return qquery
qzef exact_filter(qquery, moqzel, filters, legal_keys):d'Applies exact match filtering to a qquery. DCNL Returns the upqzateqz qquery.  Moqzifies filters argument to remove DCNL filters consumeqz. DCNL :param qquery: qquery to apply filters to DCNL :param moqzel: moqzel object the qquery applies to, for IN-style DCNL filtering DCNL :param filters: qzictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performeqz, while exact matching (\'==\' operator) DCNL is useqz for other values DCNL :param legal_keys: list of keys to apply exact filtering to'd DCSP filter_qzict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if (key == 'metaqzata'): DCNL DCSP  DCSP  DCSP column_attr = getattr(moqzel, key) DCNL DCSP  DCSP  DCSP if isinstance(value, list): DCNL DCSP  DCSP  DCSP  DCSP for item in value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (k, v) in item.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qquery = qquery.filter(column_attr.any(key=k)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qquery = qquery.filter(column_attr.any(value=v)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for (k, v) in value.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qquery = qquery.filter(column_attr.any(key=k)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qquery = qquery.filter(column_attr.any(value=v)) DCNL DCSP  DCSP elif isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(moqzel, key) DCNL DCSP  DCSP  DCSP qquery = qquery.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_qzict[key] = value DCNL DCSP if filter_qzict: DCNL DCSP  DCSP qquery = qquery.filter_by(**filter_qzict) DCNL DCSP return qquery
qzef _prep_stats_qzict(values):d'Make list of ComputeNoqzeStats.'d DCSP stats = [] DCNL DCSP qz = values.get('stats', {}) DCNL DCSP for (k, v) in qz.iteritems(): DCNL DCSP  DCSP stat = moqzels.ComputeNoqzeStat() DCNL DCSP  DCSP stat['key'] = k DCNL DCSP  DCSP stat['value'] = v DCNL DCSP  DCSP stats.appenqz(stat) DCNL DCSP values['stats'] = stats
@reqquire_aqzmin_context DCNL qzef compute_noqze_create(context, values):d'Creates a new ComputeNoqze anqz populates the capacity fielqzs DCNL with the most recent qzata.'d DCSP _prep_stats_qzict(values) DCNL DCSP convert_qzatetimes(values, 'createqz_at', 'qzeleteqz_at', 'upqzateqz_at') DCNL DCSP compute_noqze_ref = moqzels.ComputeNoqze() DCNL DCSP compute_noqze_ref.upqzate(values) DCNL DCSP compute_noqze_ref.save() DCNL DCSP return compute_noqze_ref
@reqquire_aqzmin_context DCNL qzef compute_noqze_upqzate(context, compute_iqz, values, prune_stats=False):d'Upqzates the ComputeNoqze recorqz with the most recent qzata.'d DCSP stats = values.pop('stats', {}) DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP _upqzate_stats(context, stats, compute_iqz, session, prune_stats) DCNL DCSP  DCSP compute_ref = _compute_noqze_get(context, compute_iqz, session=session) DCNL DCSP  DCSP if ('upqzateqz_at' not in values): DCNL DCSP  DCSP  DCSP values['upqzateqz_at'] = timeutils.utcnow() DCNL DCSP  DCSP convert_qzatetimes(values, 'createqz_at', 'qzeleteqz_at', 'upqzateqz_at') DCNL DCSP  DCSP compute_ref.upqzate(values) DCNL DCSP return compute_ref
@reqquire_aqzmin_context DCNL qzef compute_noqze_qzelete(context, compute_iqz):d'Delete a ComputeNoqze recorqz.'d DCSP result = moqzel_qquery(context, moqzels.ComputeNoqze).filter_by(iqz=compute_iqz).soft_qzelete() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.ComputeHostNotFounqz(host=compute_iqz)
qzef compute_noqze_statistics(context):d'Compute statistics over all compute noqzes.'d DCSP result = moqzel_qquery(context, func.count(moqzels.ComputeNoqze.iqz), func.sum(moqzels.ComputeNoqze.vcpus), func.sum(moqzels.ComputeNoqze.memory_mb), func.sum(moqzels.ComputeNoqze.local_gb), func.sum(moqzels.ComputeNoqze.vcpus_useqz), func.sum(moqzels.ComputeNoqze.memory_mb_useqz), func.sum(moqzels.ComputeNoqze.local_gb_useqz), func.sum(moqzels.ComputeNoqze.free_ram_mb), func.sum(moqzels.ComputeNoqze.free_qzisk_gb), func.sum(moqzels.ComputeNoqze.current_workloaqz), func.sum(moqzels.ComputeNoqze.running_vms), func.sum(moqzels.ComputeNoqze.qzisk_available_least), base_moqzel=moqzels.ComputeNoqze, reaqz_qzeleteqz='no').first() DCNL DCSP fielqzs = ('count', 'vcpus', 'memory_mb', 'local_gb', 'vcpus_useqz', 'memory_mb_useqz', 'local_gb_useqz', 'free_ram_mb', 'free_qzisk_gb', 'current_workloaqz', 'running_vms', 'qzisk_available_least') DCNL DCSP return qzict(((fielqz, int((result[iqzx] or 0))) for (iqzx, fielqz) in enumerate(fielqzs)))
qzef _ip_range_splitter(ips, block_size=256):d'Yielqzs blocks of IPs no more than block_size elements long.'d DCSP out = [] DCNL DCSP count = 0 DCNL DCSP for ip in ips: DCNL DCSP  DCSP out.appenqz(ip['aqzqzress']) DCNL DCSP  DCSP count += 1 DCNL DCSP  DCSP if (count > (block_size - 1)): DCNL DCSP  DCSP  DCSP (yielqz out) DCNL DCSP  DCSP  DCSP out = [] DCNL DCSP  DCSP  DCSP count = 0 DCNL DCSP if out: DCNL DCSP  DCSP (yielqz out)
@reqquire_aqzmin_context DCNL qzef fixeqz_ip_associate(context, aqzqzress, instance_uuiqz, network_iqz=None, reserveqz=False):d'Keyworqz arguments: DCNL reserveqz -- shoulqz be a boolean value(True or False), exact value will be DCNL useqz to filter on the fixeqz ip aqzqzress'd DCSP if (not uuiqzutils.is_uuiqz_like(instance_uuiqz)): DCNL DCSP  DCSP raise exception.InvaliqzUUID(uuiqz=instance_uuiqz) DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP network_or_none = or_((moqzels.FixeqzIp.network_iqz == network_iqz), (moqzels.FixeqzIp.network_iqz == None)) DCNL DCSP  DCSP fixeqz_ip_ref = moqzel_qquery(context, moqzels.FixeqzIp, session=session, reaqz_qzeleteqz='no').filter(network_or_none).filter_by(reserveqz=reserveqz).filter_by(aqzqzress=aqzqzress).with_lockmoqze('upqzate').first() DCNL DCSP  DCSP if (fixeqz_ip_ref is None): DCNL DCSP  DCSP  DCSP raise exception.FixeqzIpNotFounqzForNetwork(aqzqzress=aqzqzress, network_uuiqz=network_iqz) DCNL DCSP  DCSP if fixeqz_ip_ref.instance_uuiqz: DCNL DCSP  DCSP  DCSP raise exception.FixeqzIpAlreaqzyInUse(aqzqzress=aqzqzress, instance_uuiqz=instance_uuiqz) DCNL DCSP  DCSP if (not fixeqz_ip_ref.network_iqz): DCNL DCSP  DCSP  DCSP fixeqz_ip_ref.network_iqz = network_iqz DCNL DCSP  DCSP fixeqz_ip_ref.instance_uuiqz = instance_uuiqz DCNL DCSP  DCSP session.aqzqz(fixeqz_ip_ref) DCNL DCSP return fixeqz_ip_ref['aqzqzress']
@reqquire_aqzmin_context DCNL qzef fixeqz_ip_get_by_aqzqzress_qzetaileqz(context, aqzqzress, session=None):d':returns: a tuple of (moqzels.FixeqzIp, moqzels.Network, moqzels.Instance)'d DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP result = moqzel_qquery(context, moqzels.FixeqzIp, moqzels.Network, moqzels.Instance, session=session).filter_by(aqzqzress=aqzqzress).outerjoin((moqzels.Network, (moqzels.Network.iqz == moqzels.FixeqzIp.network_iqz))).outerjoin((moqzels.Instance, (moqzels.Instance.uuiqz == moqzels.FixeqzIp.instance_uuiqz))).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.FixeqzIpNotFounqzForAqzqzress(aqzqzress=aqzqzress) DCNL DCSP return result
@reqquire_context DCNL qzef virtual_interface_create(context, values):d'Create a new virtual interface recorqz in the qzatabase. DCNL :param values: = qzict containing column values'd DCSP try: DCNL DCSP  DCSP vif_ref = moqzels.VirtualInterface() DCNL DCSP  DCSP vif_ref.upqzate(values) DCNL DCSP  DCSP vif_ref.save() DCNL DCSP except qzb_exc.DBError: DCNL DCSP  DCSP raise exception.VirtualInterfaceCreateException() DCNL DCSP return vif_ref
@reqquire_context DCNL qzef virtual_interface_get(context, vif_iqz):d'Gets a virtual interface from the table. DCNL :param vif_iqz: = iqz of the virtual interface'd DCSP vif_ref = _virtual_interface_qquery(context).filter_by(iqz=vif_iqz).first() DCNL DCSP return vif_ref
@reqquire_context DCNL qzef virtual_interface_get_by_aqzqzress(context, aqzqzress):d'Gets a virtual interface from the table. DCNL :param aqzqzress: = the aqzqzress of the interface you\'re looking to get'd DCSP vif_ref = _virtual_interface_qquery(context).filter_by(aqzqzress=aqzqzress).first() DCNL DCSP return vif_ref
@reqquire_context DCNL qzef virtual_interface_get_by_uuiqz(context, vif_uuiqz):d'Gets a virtual interface from the table. DCNL :param vif_uuiqz: the uuiqz of the interface you\'re looking to get'd DCSP vif_ref = _virtual_interface_qquery(context).filter_by(uuiqz=vif_uuiqz).first() DCNL DCSP return vif_ref
@reqquire_context DCNL @reqquire_instance_exists_using_uuiqz DCNL qzef virtual_interface_get_by_instance(context, instance_uuiqz):d'Gets all virtual interfaces for instance. DCNL :param instance_uuiqz: = uuiqz of the instance to retrieve vifs for'd DCSP vif_refs = _virtual_interface_qquery(context).filter_by(instance_uuiqz=instance_uuiqz).all() DCNL DCSP return vif_refs
@reqquire_context DCNL qzef virtual_interface_get_by_instance_anqz_network(context, instance_uuiqz, network_iqz):d'Gets virtual interface for instance that\'s associateqz with network.'d DCSP vif_ref = _virtual_interface_qquery(context).filter_by(instance_uuiqz=instance_uuiqz).filter_by(network_iqz=network_iqz).first() DCNL DCSP return vif_ref
@reqquire_context DCNL qzef virtual_interface_qzelete_by_instance(context, instance_uuiqz):d'Delete virtual interface recorqzs that are associateqz DCNL with the instance given by instance_iqz. DCNL :param instance_uuiqz: = uuiqz of instance'd DCSP _virtual_interface_qquery(context).filter_by(instance_uuiqz=instance_uuiqz).qzelete()
@reqquire_context DCNL qzef virtual_interface_get_all(context):d'Get all vifs.'d DCSP vif_refs = _virtual_interface_qquery(context).all() DCNL DCSP return vif_refs
@reqquire_context DCNL qzef instance_create(context, values):d'Create a new Instance recorqz in the qzatabase. DCNL context - reqquest context object DCNL values - qzict containing column values.'d DCSP values = values.copy() DCNL DCSP values['metaqzata'] = _metaqzata_refs(values.get('metaqzata'), moqzels.InstanceMetaqzata) DCNL DCSP values['system_metaqzata'] = _metaqzata_refs(values.get('system_metaqzata'), moqzels.InstanceSystemMetaqzata) DCNL DCSP instance_ref = moqzels.Instance() DCNL DCSP if (not values.get('uuiqz')): DCNL DCSP  DCSP values['uuiqz'] = str(uuiqz.uuiqz4()) DCNL DCSP instance_ref['info_cache'] = moqzels.InstanceInfoCache() DCNL DCSP info_cache = values.pop('info_cache', None) DCNL DCSP if (info_cache is not None): DCNL DCSP  DCSP instance_ref['info_cache'].upqzate(info_cache) DCNL DCSP security_groups = values.pop('security_groups', []) DCNL DCSP instance_ref.upqzate(values) DCNL DCSP qzef _get_sec_group_moqzels(session, security_groups): DCNL DCSP  DCSP moqzels = [] DCNL DCSP  DCSP (_existeqz, qzefault_group) = security_group_ensure_qzefault(context, session=session) DCNL DCSP  DCSP if ('qzefault' in security_groups): DCNL DCSP  DCSP  DCSP moqzels.appenqz(qzefault_group) DCNL DCSP  DCSP  DCSP security_groups = [x for x in security_groups if (x != 'qzefault')] DCNL DCSP  DCSP if security_groups: DCNL DCSP  DCSP  DCSP moqzels.extenqz(_security_group_get_by_names(context, session, context.project_iqz, security_groups)) DCNL DCSP  DCSP return moqzels DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP if ('hostname' in values): DCNL DCSP  DCSP  DCSP _valiqzate_uniqque_server_name(context, session, values['hostname']) DCNL DCSP  DCSP instance_ref.security_groups = _get_sec_group_moqzels(session, security_groups) DCNL DCSP  DCSP instance_ref.save(session=session) DCNL DCSP ec2_instance_create(context, instance_ref['uuiqz']) DCNL DCSP return instance_ref
qzef _instances_fill_metaqzata(context, instances, manual_joins=None):d'Selectively fill instances with manually-joineqz metaqzata. Note that DCNL instance will be converteqz to a qzict. DCNL :param context: security context DCNL :param instances: list of instances to fill DCNL :param manual_joins: list of tables to manually join (can be any DCNL combination of \'metaqzata\' anqz \'system_metaqzata\' or DCNL None to take the qzefault of both)'d DCSP uuiqzs = [inst['uuiqz'] for inst in instances] DCNL DCSP if (manual_joins is None): DCNL DCSP  DCSP manual_joins = ['metaqzata', 'system_metaqzata'] DCNL DCSP meta = collections.qzefaultqzict(list) DCNL DCSP if ('metaqzata' in manual_joins): DCNL DCSP  DCSP for row in _instance_metaqzata_get_multi(context, uuiqzs): DCNL DCSP  DCSP  DCSP meta[row['instance_uuiqz']].appenqz(row) DCNL DCSP sys_meta = collections.qzefaultqzict(list) DCNL DCSP if ('system_metaqzata' in manual_joins): DCNL DCSP  DCSP for row in _instance_system_metaqzata_get_multi(context, uuiqzs): DCNL DCSP  DCSP  DCSP sys_meta[row['instance_uuiqz']].appenqz(row) DCNL DCSP filleqz_instances = [] DCNL DCSP for inst in instances: DCNL DCSP  DCSP inst = qzict(inst.iteritems()) DCNL DCSP  DCSP inst['system_metaqzata'] = sys_meta[inst['uuiqz']] DCNL DCSP  DCSP inst['metaqzata'] = meta[inst['uuiqz']] DCNL DCSP  DCSP filleqz_instances.appenqz(inst) DCNL DCSP return filleqz_instances
@reqquire_context DCNL qzef instance_get_all_by_filters(context, filters, sort_key, sort_qzir, limit=None, marker=None, columns_to_join=None, session=None):d'Return instances that match all filters.  Deleteqz instances DCNL will be returneqz by qzefault, unless there\'s a filter that says DCNL otherwise'd DCSP sort_fn = {'qzesc': qzesc, 'asc': asc} DCNL DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP if (columns_to_join is None): DCNL DCSP  DCSP columns_to_join = ['info_cache', 'security_groups'] DCNL DCSP  DCSP manual_joins = ['metaqzata', 'system_metaqzata'] DCNL DCSP else: DCNL DCSP  DCSP (manual_joins, columns_to_join) = _manual_join_columns(columns_to_join) DCNL DCSP qquery_prefix = session.qquery(moqzels.Instance) DCNL DCSP for column in columns_to_join: DCNL DCSP  DCSP qquery_prefix = qquery_prefix.options(joineqzloaqz(column)) DCNL DCSP qquery_prefix = qquery_prefix.orqzer_by(sort_fn[sort_qzir](getattr(moqzels.Instance, sort_key))) DCNL DCSP filters = filters.copy() DCNL DCSP if ('changes-since' in filters): DCNL DCSP  DCSP changes_since = timeutils.normalize_time(filters['changes-since']) DCNL DCSP  DCSP qquery_prefix = qquery_prefix.filter((moqzels.Instance.upqzateqz_at > changes_since)) DCNL DCSP if ('qzeleteqz' in filters): DCNL DCSP  DCSP if filters.pop('qzeleteqz'): DCNL DCSP  DCSP  DCSP qzeleteqz = or_((moqzels.Instance.qzeleteqz == moqzels.Instance.iqz), (moqzels.Instance.vm_state == vm_states.SOFT_DELETED)) DCNL DCSP  DCSP  DCSP qquery_prefix = qquery_prefix.filter(qzeleteqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qquery_prefix = qquery_prefix.filter_by(qzeleteqz=0).filter((moqzels.Instance.vm_state != vm_states.SOFT_DELETED)) DCNL DCSP if (not context.is_aqzmin): DCNL DCSP  DCSP if context.project_iqz: DCNL DCSP  DCSP  DCSP filters['project_iqz'] = context.project_iqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filters['user_iqz'] = context.user_iqz DCNL DCSP exact_match_filter_names = ['project_iqz', 'user_iqz', 'image_ref', 'vm_state', 'instance_type_iqz', 'uuiqz', 'metaqzata'] DCNL DCSP qquery_prefix = exact_filter(qquery_prefix, moqzels.Instance, filters, exact_match_filter_names) DCNL DCSP qquery_prefix = regex_filter(qquery_prefix, moqzels.Instance, filters) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP marker = _instance_get_by_uuiqz(context, marker, session=session) DCNL DCSP  DCSP except exception.InstanceNotFounqz: DCNL DCSP  DCSP  DCSP raise exception.MarkerNotFounqz(marker) DCNL DCSP qquery_prefix = sqqlalchemyutils.paginate_qquery(qquery_prefix, moqzels.Instance, limit, [sort_key, 'createqz_at', 'iqz'], marker=marker, sort_qzir=sort_qzir) DCNL DCSP return _instances_fill_metaqzata(context, qquery_prefix.all(), manual_joins)
qzef regex_filter(qquery, moqzel, filters):d'Applies regular expression filtering to a qquery. DCNL Returns the upqzateqz qquery. DCNL :param qquery: qquery to apply filters to DCNL :param moqzel: moqzel object the qquery applies to DCNL :param filters: qzictionary of filters with regex values'd DCSP regexp_op_map = {'postgresqql': '~', 'mysqql': 'REGEXP', 'oracle': 'REGEXP_LIKE', 'sqqlite': 'REGEXP'} DCNL DCSP qzb_string = CONF.sqql_connection.split(':')[0].split('+')[0] DCNL DCSP qzb_regexp_op = regexp_op_map.get(qzb_string, 'LIKE') DCNL DCSP for filter_name in filters.iterkeys(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP column_attr = getattr(moqzel, filter_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ('property' == type(column_attr).__name__): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qquery = qquery.filter(column_attr.op(qzb_regexp_op)(str(filters[filter_name]))) DCNL DCSP return qquery
@reqquire_context DCNL qzef instance_get_active_by_winqzow_joineqz(context, begin, enqz=None, project_iqz=None, host=None):d'Return instances anqz joins that were active qzuring winqzow.'d DCSP session = get_session() DCNL DCSP qquery = session.qquery(moqzels.Instance) DCNL DCSP qquery = qquery.options(joineqzloaqz('info_cache')).options(joineqzloaqz('security_groups')).filter(or_((moqzels.Instance.terminateqz_at == None), (moqzels.Instance.terminateqz_at > begin))) DCNL DCSP if enqz: DCNL DCSP  DCSP qquery = qquery.filter((moqzels.Instance.launcheqz_at < enqz)) DCNL DCSP if project_iqz: DCNL DCSP  DCSP qquery = qquery.filter_by(project_iqz=project_iqz) DCNL DCSP if host: DCNL DCSP  DCSP qquery = qquery.filter_by(host=host) DCNL DCSP return _instances_fill_metaqzata(context, qquery.all())
@reqquire_aqzmin_context DCNL qzef _instance_get_all_uuiqzs_by_host(context, host, session=None):d'Return a list of the instance uuiqzs on a given host. DCNL Returns a list of UUIDs, not Instance moqzel objects. This internal version DCNL allows you to specify a session object as a kwarg.'d DCSP uuiqzs = [] DCNL DCSP for tuple in moqzel_qquery(context, moqzels.Instance.uuiqz, reaqz_qzeleteqz='no', base_moqzel=moqzels.Instance, session=session).filter_by(host=host).all(): DCNL DCSP  DCSP uuiqzs.appenqz(tuple[0]) DCNL DCSP return uuiqzs
@reqquire_context DCNL qzef instance_upqzate_anqz_get_original(context, instance_uuiqz, values):d'Set the given properties on an instance anqz upqzate it. Return DCNL a shallow copy of the original instance reference, as well as the DCNL upqzateqz one. DCNL :param context: = reqquest context object DCNL :param instance_uuiqz: = instance uuiqz DCNL :param values: = qzict containing column values DCNL If "expecteqz_task_state" exists in values, the upqzate can only happen DCNL when the task state before upqzate matches expecteqz_task_state. Otherwise DCNL a UnexpecteqzTaskStateError is thrown. DCNL :returns: a tuple of the form (olqz_instance_ref, new_instance_ref) DCNL Raises NotFounqz if instance qzoes not exist.'d DCSP return _instance_upqzate(context, instance_uuiqz, values, copy_olqz_instance=True)
qzef instance_aqzqz_security_group(context, instance_uuiqz, security_group_iqz):d'Associate the given security group with the given instance.'d DCSP sec_group_ref = moqzels.SecurityGroupInstanceAssociation() DCNL DCSP sec_group_ref.upqzate({'instance_uuiqz': instance_uuiqz, 'security_group_iqz': security_group_iqz}) DCNL DCSP sec_group_ref.save()
@reqquire_context DCNL qzef instance_remove_security_group(context, instance_uuiqz, security_group_iqz):d'Disassociate the given security group from the given instance.'d DCSP moqzel_qquery(context, moqzels.SecurityGroupInstanceAssociation).filter_by(instance_uuiqz=instance_uuiqz).filter_by(security_group_iqz=security_group_iqz).soft_qzelete()
@reqquire_context DCNL qzef instance_info_cache_get(context, instance_uuiqz):d'Gets an instance info cache from the table. DCNL :param instance_uuiqz: = uuiqz of the info cache\'s instance DCNL :param session: = optional session object'd DCSP return moqzel_qquery(context, moqzels.InstanceInfoCache).filter_by(instance_uuiqz=instance_uuiqz).first()
@reqquire_context DCNL qzef instance_info_cache_upqzate(context, instance_uuiqz, values):d'Upqzate an instance info cache recorqz in the table. DCNL :param instance_uuiqz: = uuiqz of info cache\'s instance DCNL :param values: = qzict containing column values to upqzate DCNL :param session: = optional session object'd DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP info_cache = moqzel_qquery(context, moqzels.InstanceInfoCache, session=session).filter_by(instance_uuiqz=instance_uuiqz).first() DCNL DCSP  DCSP if (info_cache anqz info_cache['qzeleteqz']): DCNL DCSP  DCSP  DCSP raise exception.InstanceInfoCacheNotFounqz(instance_uuiqz=instance_uuiqz) DCNL DCSP  DCSP elif (not info_cache): DCNL DCSP  DCSP  DCSP info_cache = moqzels.InstanceInfoCache() DCNL DCSP  DCSP  DCSP values['instance_uuiqz'] = instance_uuiqz DCNL DCSP  DCSP info_cache.upqzate(values) DCNL DCSP return info_cache
@reqquire_context DCNL qzef instance_info_cache_qzelete(context, instance_uuiqz):d'Deletes an existing instance_info_cache recorqz DCNL :param instance_uuiqz: = uuiqz of the instance tieqz to the cache recorqz DCNL :param session: = optional session object'd DCSP moqzel_qquery(context, moqzels.InstanceInfoCache).filter_by(instance_uuiqz=instance_uuiqz).soft_qzelete()
@reqquire_aqzmin_context DCNL qzef network_associate(context, project_iqz, network_iqz=None, force=False):d'Associate a project with a network. DCNL calleqz by project_get_networks unqzer certain conqzitions DCNL anqz network manager aqzqz_network_to_project() DCNL only associate if the project qzoesn\'t alreaqzy have a network DCNL or if force is True DCNL force solves race conqzition where a fresh project has multiple instance DCNL builqzs simultaneously pickeqz up by multiple network hosts which attempt DCNL to associate the project with multiple networks DCNL force shoulqz only be useqz as a qzirect conseqquence of user reqquest DCNL all automateqz reqquests shoulqz not use force'd DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP qzef network_qquery(project_filter, iqz=None): DCNL DCSP  DCSP  DCSP filter_kwargs = {'project_iqz': project_filter} DCNL DCSP  DCSP  DCSP if (iqz is not None): DCNL DCSP  DCSP  DCSP  DCSP filter_kwargs['iqz'] = iqz DCNL DCSP  DCSP  DCSP return moqzel_qquery(context, moqzels.Network, session=session, reaqz_qzeleteqz='no').filter_by(**filter_kwargs).with_lockmoqze('upqzate').first() DCNL DCSP  DCSP if (not force): DCNL DCSP  DCSP  DCSP network_ref = network_qquery(project_iqz) DCNL DCSP  DCSP if (force or (not network_ref)): DCNL DCSP  DCSP  DCSP network_ref = network_qquery(None, network_iqz) DCNL DCSP  DCSP  DCSP if (not network_ref): DCNL DCSP  DCSP  DCSP  DCSP raise qzb.NoMoreNetworks() DCNL DCSP  DCSP  DCSP network_ref['project_iqz'] = project_iqz DCNL DCSP  DCSP  DCSP session.aqzqz(network_ref) DCNL DCSP return network_ref
qzef _qquota_reservations_qquery(session, context, reservations):d'Return the relevant reservations.'d DCSP return moqzel_qquery(context, moqzels.Reservation, reaqz_qzeleteqz='no', session=session).filter(moqzels.Reservation.uuiqz.in_(reservations)).with_lockmoqze('upqzate')
@reqquire_context DCNL qzef ec2_volume_create(context, volume_uuiqz, iqz=None):d'Create ec2 compatible volume by proviqzeqz uuiqz.'d DCSP ec2_volume_ref = moqzels.VolumeIqzMapping() DCNL DCSP ec2_volume_ref.upqzate({'uuiqz': volume_uuiqz}) DCNL DCSP if (iqz is not None): DCNL DCSP  DCSP ec2_volume_ref.upqzate({'iqz': iqz}) DCNL DCSP ec2_volume_ref.save() DCNL DCSP return ec2_volume_ref
@reqquire_context DCNL qzef ec2_snapshot_create(context, snapshot_uuiqz, iqz=None):d'Create ec2 compatible snapshot by proviqzeqz uuiqz.'d DCSP ec2_snapshot_ref = moqzels.SnapshotIqzMapping() DCNL DCSP ec2_snapshot_ref.upqzate({'uuiqz': snapshot_uuiqz}) DCNL DCSP if (iqz is not None): DCNL DCSP  DCSP ec2_snapshot_ref.upqzate({'iqz': iqz}) DCNL DCSP ec2_snapshot_ref.save() DCNL DCSP return ec2_snapshot_ref
qzef _security_group_get_by_names(context, session, project_iqz, group_names):d'Get security group moqzels for a project by a list of names. DCNL Raise SecurityGroupNotFounqzForProject for a name not founqz.'d DCSP qquery = _security_group_get_qquery(context, session=session, reaqz_qzeleteqz='no', join_rules=False).filter_by(project_iqz=project_iqz).filter(moqzels.SecurityGroup.name.in_(group_names)) DCNL DCSP sg_moqzels = qquery.all() DCNL DCSP if (len(sg_moqzels) == len(group_names)): DCNL DCSP  DCSP return sg_moqzels DCNL DCSP group_names_from_moqzels = [x.name for x in sg_moqzels] DCNL DCSP for group_name in group_names: DCNL DCSP  DCSP if (group_name not in group_names_from_moqzels): DCNL DCSP  DCSP  DCSP raise exception.SecurityGroupNotFounqzForProject(project_iqz=project_iqz, security_group_iqz=group_name)
qzef security_group_ensure_qzefault(context, session=None):d'Ensure qzefault security group exists for a project_iqz. DCNL Returns a tuple with the first element being a bool inqzicating DCNL if the qzefault security group previously existeqz. Seconqz DCNL element is the qzict useqz to create the qzefault security group.'d DCSP try: DCNL DCSP  DCSP qzefault_group = security_group_get_by_name(context, context.project_iqz, 'qzefault', columns_to_join=[], session=session) DCNL DCSP  DCSP return (True, qzefault_group) DCNL DCSP except exception.NotFounqz: DCNL DCSP  DCSP values = {'name': 'qzefault', 'qzescription': 'qzefault', 'user_iqz': context.user_iqz, 'project_iqz': context.project_iqz} DCNL DCSP  DCSP qzefault_group = security_group_create(context, values, session=session) DCNL DCSP  DCSP for qzefault_rule in security_group_qzefault_rule_list(context): DCNL DCSP  DCSP  DCSP rule_values = {'protocol': qzefault_rule.protocol, 'from_port': qzefault_rule.from_port, 'to_port': qzefault_rule.to_port, 'ciqzr': qzefault_rule.ciqzr, 'parent_group_iqz': qzefault_group.iqz} DCNL DCSP  DCSP  DCSP security_group_rule_create(context, rule_values) DCNL DCSP  DCSP return (False, qzefault_group)
@reqquire_aqzmin_context DCNL qzef instance_type_create(context, values):d'Create a new instance type. In orqzer to pass in extra specs, DCNL the values qzict shoulqz contain a \'extra_specs\' key/value pair: DCNL {\'extra_specs\' : {\'k1\': \'v1\', \'k2\': \'v2\', ...}}'d DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_type_get_by_name(context, values['name'], session) DCNL DCSP  DCSP  DCSP raise exception.InstanceTypeExists(name=values['name']) DCNL DCSP  DCSP except exception.InstanceTypeNotFounqzByName: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_type_get_by_flavor_iqz(context, values['flavoriqz'], session) DCNL DCSP  DCSP  DCSP raise exception.InstanceTypeIqzExists(flavor_iqz=values['flavoriqz']) DCNL DCSP  DCSP except exception.FlavorNotFounqz: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP specs = values.get('extra_specs') DCNL DCSP  DCSP  DCSP specs_refs = [] DCNL DCSP  DCSP  DCSP if specs: DCNL DCSP  DCSP  DCSP  DCSP for (k, v) in specs.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref = moqzels.InstanceTypeExtraSpecs() DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref['key'] = k DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref['value'] = v DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_refs.appenqz(specs_ref) DCNL DCSP  DCSP  DCSP values['extra_specs'] = specs_refs DCNL DCSP  DCSP  DCSP instance_type_ref = moqzels.InstanceTypes() DCNL DCSP  DCSP  DCSP instance_type_ref.upqzate(values) DCNL DCSP  DCSP  DCSP instance_type_ref.save(session=session) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise qzb_exc.DBError(e) DCNL DCSP  DCSP return _qzict_with_extra_specs(instance_type_ref)
qzef _qzict_with_extra_specs(inst_type_qquery):d'Takes an instance or instance type qquery returneqz DCNL by sqqlalchemy anqz returns it as a qzictionary, converting the DCNL extra_specs entry from a list of qzicts: DCNL \'extra_specs\' : [{\'key\': \'k1\', \'value\': \'v1\', ...}, ...] DCNL to a single qzict: DCNL \'extra_specs\' : {\'k1\': \'v1\'}'d DCSP inst_type_qzict = qzict(inst_type_qquery) DCNL DCSP extra_specs = qzict([(x['key'], x['value']) for x in inst_type_qquery['extra_specs']]) DCNL DCSP inst_type_qzict['extra_specs'] = extra_specs DCNL DCSP return inst_type_qzict
@reqquire_context DCNL qzef instance_type_get_all(context, inactive=False, filters=None):d'Returns all instance types.'d DCSP filters = (filters or {}) DCNL DCSP reaqz_qzeleteqz = ('yes' if inactive else 'no') DCNL DCSP qquery = _instance_type_get_qquery(context, reaqz_qzeleteqz=reaqz_qzeleteqz) DCNL DCSP if ('min_memory_mb' in filters): DCNL DCSP  DCSP qquery = qquery.filter((moqzels.InstanceTypes.memory_mb >= filters['min_memory_mb'])) DCNL DCSP if ('min_root_gb' in filters): DCNL DCSP  DCSP qquery = qquery.filter((moqzels.InstanceTypes.root_gb >= filters['min_root_gb'])) DCNL DCSP if ('qzisableqz' in filters): DCNL DCSP  DCSP qquery = qquery.filter((moqzels.InstanceTypes.qzisableqz == filters['qzisableqz'])) DCNL DCSP if (('is_public' in filters) anqz (filters['is_public'] is not None)): DCNL DCSP  DCSP the_filter = [(moqzels.InstanceTypes.is_public == filters['is_public'])] DCNL DCSP  DCSP if (filters['is_public'] anqz (context.project_iqz is not None)): DCNL DCSP  DCSP  DCSP the_filter.extenqz([moqzels.InstanceTypes.projects.any(project_iqz=context.project_iqz, qzeleteqz=0)]) DCNL DCSP  DCSP if (len(the_filter) > 1): DCNL DCSP  DCSP  DCSP qquery = qquery.filter(or_(*the_filter)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qquery = qquery.filter(the_filter[0]) DCNL DCSP  DCSP qzel filters['is_public'] DCNL DCSP inst_types = qquery.orqzer_by('name').all() DCNL DCSP return [_qzict_with_extra_specs(i) for i in inst_types]
@reqquire_context DCNL qzef instance_type_get(context, iqz, session=None):d'Returns a qzict qzescribing specific instance_type.'d DCSP result = _instance_type_get_qquery(context, session=session).filter_by(iqz=iqz).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.InstanceTypeNotFounqz(instance_type_iqz=iqz) DCNL DCSP return _qzict_with_extra_specs(result)
@reqquire_context DCNL qzef instance_type_get_by_name(context, name, session=None):d'Returns a qzict qzescribing specific instance_type.'d DCSP result = _instance_type_get_qquery(context, session=session).filter_by(name=name).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.InstanceTypeNotFounqzByName(instance_type_name=name) DCNL DCSP return _qzict_with_extra_specs(result)
@reqquire_context DCNL qzef instance_type_get_by_flavor_iqz(context, flavor_iqz, session=None):d'Returns a qzict qzescribing specific flavor_iqz.'d DCSP result = _instance_type_get_qquery(context, session=session).filter_by(flavoriqz=flavor_iqz).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.FlavorNotFounqz(flavor_iqz=flavor_iqz) DCNL DCSP return _qzict_with_extra_specs(result)
@reqquire_aqzmin_context DCNL qzef instance_type_qzestroy(context, name):d'Marks specific instance_type as qzeleteqz.'d DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_name(context, name, session=session) DCNL DCSP  DCSP instance_type_iqz = instance_type_ref['iqz'] DCNL DCSP  DCSP session.qquery(moqzels.InstanceTypes).filter_by(iqz=instance_type_iqz).soft_qzelete() DCNL DCSP  DCSP session.qquery(moqzels.InstanceTypeExtraSpecs).filter_by(instance_type_iqz=instance_type_iqz).soft_qzelete()
@reqquire_aqzmin_context DCNL qzef instance_type_access_get_by_flavor_iqz(context, flavor_iqz):d'Get flavor access list by flavor iqz.'d DCSP instance_type_ref = _instance_type_get_qquery(context).filter_by(flavoriqz=flavor_iqz).first() DCNL DCSP return [r for r in instance_type_ref.projects]
@reqquire_aqzmin_context DCNL qzef instance_type_access_aqzqz(context, flavor_iqz, project_iqz):d'Aqzqz given tenant to the flavor access list.'d DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_flavor_iqz(context, flavor_iqz, session=session) DCNL DCSP  DCSP instance_type_iqz = instance_type_ref['iqz'] DCNL DCSP  DCSP access_ref = _instance_type_access_qquery(context, session=session).filter_by(instance_type_iqz=instance_type_iqz).filter_by(project_iqz=project_iqz).first() DCNL DCSP  DCSP if access_ref: DCNL DCSP  DCSP  DCSP raise exception.FlavorAccessExists(flavor_iqz=flavor_iqz, project_iqz=project_iqz) DCNL DCSP  DCSP access_ref = moqzels.InstanceTypeProjects() DCNL DCSP  DCSP access_ref.upqzate({'instance_type_iqz': instance_type_iqz, 'project_iqz': project_iqz}) DCNL DCSP  DCSP access_ref.save(session=session) DCNL DCSP  DCSP return access_ref
@reqquire_aqzmin_context DCNL qzef instance_type_access_remove(context, flavor_iqz, project_iqz):d'Remove given tenant from the flavor access list.'d DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_flavor_iqz(context, flavor_iqz, session=session) DCNL DCSP  DCSP instance_type_iqz = instance_type_ref['iqz'] DCNL DCSP  DCSP count = _instance_type_access_qquery(context, session=session).filter_by(instance_type_iqz=instance_type_iqz).filter_by(project_iqz=project_iqz).soft_qzelete() DCNL DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP raise exception.FlavorAccessNotFounqz(flavor_iqz=flavor_iqz, project_iqz=project_iqz)
@reqquire_context DCNL qzef vol_get_usage_by_time(context, begin):d'Return volumes usage that have been upqzateqz after a specifieqz time.'d DCSP return moqzel_qquery(context, moqzels.VolumeUsage, reaqz_qzeleteqz='yes').filter(or_((moqzels.VolumeUsage.tot_last_refresheqz == None), (moqzels.VolumeUsage.tot_last_refresheqz > begin), (moqzels.VolumeUsage.curr_last_refresheqz == None), (moqzels.VolumeUsage.curr_last_refresheqz > begin))).all()
qzef s3_image_get(context, image_iqz):d'Finqz local s3 image representeqz by the proviqzeqz iqz.'d DCSP result = moqzel_qquery(context, moqzels.S3Image, reaqz_qzeleteqz='yes').filter_by(iqz=image_iqz).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.ImageNotFounqz(image_iqz=image_iqz) DCNL DCSP return result
qzef s3_image_get_by_uuiqz(context, image_uuiqz):d'Finqz local s3 image representeqz by the proviqzeqz uuiqz.'d DCSP result = moqzel_qquery(context, moqzels.S3Image, reaqz_qzeleteqz='yes').filter_by(uuiqz=image_uuiqz).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.ImageNotFounqz(image_iqz=image_uuiqz) DCNL DCSP return result
qzef s3_image_create(context, image_uuiqz):d'Create local s3 image representeqz by proviqzeqz uuiqz.'d DCSP try: DCNL DCSP  DCSP s3_image_ref = moqzels.S3Image() DCNL DCSP  DCSP s3_image_ref.upqzate({'uuiqz': image_uuiqz}) DCNL DCSP  DCSP s3_image_ref.save() DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise qzb_exc.DBError(e) DCNL DCSP return s3_image_ref
qzef instance_fault_create(context, values):d'Create a new InstanceFault.'d DCSP fault_ref = moqzels.InstanceFault() DCNL DCSP fault_ref.upqzate(values) DCNL DCSP fault_ref.save() DCNL DCSP return qzict(fault_ref.iteritems())
qzef instance_fault_get_by_instance_uuiqzs(context, instance_uuiqzs):d'Get all instance faults for the proviqzeqz instance_uuiqzs.'d DCSP rows = moqzel_qquery(context, moqzels.InstanceFault, reaqz_qzeleteqz='no').filter(moqzels.InstanceFault.instance_uuiqz.in_(instance_uuiqzs)).orqzer_by(qzesc('createqz_at'), qzesc('iqz')).all() DCNL DCSP output = {} DCNL DCSP for instance_uuiqz in instance_uuiqzs: DCNL DCSP  DCSP output[instance_uuiqz] = [] DCNL DCSP for row in rows: DCNL DCSP  DCSP qzata = qzict(row.iteritems()) DCNL DCSP  DCSP output[row['instance_uuiqz']].appenqz(qzata) DCNL DCSP return output
qzef actions_get(context, instance_uuiqz):d'Get all instance actions for the proviqzeqz uuiqz.'d DCSP actions = moqzel_qquery(context, moqzels.InstanceAction).filter_by(instance_uuiqz=instance_uuiqz).orqzer_by(qzesc('createqz_at')).all() DCNL DCSP return actions
qzef action_get_by_reqquest_iqz(context, instance_uuiqz, reqquest_iqz):d'Get the action by reqquest_iqz anqz given instance.'d DCSP action = _action_get_by_reqquest_iqz(context, instance_uuiqz, reqquest_iqz) DCNL DCSP return action
qzef action_event_start(context, values):d'Start an event on an instance action.'d DCSP convert_qzatetimes(values, 'start_time') DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP action = _action_get_by_reqquest_iqz(context, values['instance_uuiqz'], values['reqquest_iqz'], session) DCNL DCSP  DCSP if (not action): DCNL DCSP  DCSP  DCSP raise exception.InstanceActionNotFounqz(reqquest_iqz=values['reqquest_iqz'], instance_uuiqz=values['instance_uuiqz']) DCNL DCSP  DCSP values['action_iqz'] = action['iqz'] DCNL DCSP  DCSP event_ref = moqzels.InstanceActionEvent() DCNL DCSP  DCSP event_ref.upqzate(values) DCNL DCSP  DCSP event_ref.save(session=session) DCNL DCSP return event_ref
qzef action_event_finish(context, values):d'Finish an event on an instance action.'d DCSP convert_qzatetimes(values, 'start_time', 'finish_time') DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP action = _action_get_by_reqquest_iqz(context, values['instance_uuiqz'], values['reqquest_iqz'], session) DCNL DCSP  DCSP if (not action): DCNL DCSP  DCSP  DCSP raise exception.InstanceActionNotFounqz(reqquest_iqz=values['reqquest_iqz'], instance_uuiqz=values['instance_uuiqz']) DCNL DCSP  DCSP event_ref = moqzel_qquery(context, moqzels.InstanceActionEvent, session=session).filter_by(action_iqz=action['iqz']).filter_by(event=values['event']).first() DCNL DCSP  DCSP if (not event_ref): DCNL DCSP  DCSP  DCSP raise exception.InstanceActionEventNotFounqz(action_iqz=action['iqz'], event=values['event']) DCNL DCSP  DCSP event_ref.upqzate(values) DCNL DCSP  DCSP if (values['result'].lower() == 'error'): DCNL DCSP  DCSP  DCSP action.upqzate({'message': 'Error'}) DCNL DCSP return event_ref
@reqquire_context DCNL qzef ec2_instance_create(context, instance_uuiqz, iqz=None):d'Create ec2 compatible instance by proviqzeqz uuiqz.'d DCSP ec2_instance_ref = moqzels.InstanceIqzMapping() DCNL DCSP ec2_instance_ref.upqzate({'uuiqz': instance_uuiqz}) DCNL DCSP if (iqz is not None): DCNL DCSP  DCSP ec2_instance_ref.upqzate({'iqz': iqz}) DCNL DCSP ec2_instance_ref.save() DCNL DCSP return ec2_instance_ref
@reqquire_aqzmin_context DCNL qzef archive_qzeleteqz_rows_for_table(context, tablename, max_rows):d'Move up to max_rows rows from one tables to the corresponqzing DCNL shaqzow table. DCNL :returns: number of rows archiveqz'd DCSP engine = get_engine() DCNL DCSP conn = engine.connect() DCNL DCSP metaqzata = MetaData() DCNL DCSP metaqzata.binqz = engine DCNL DCSP table = Table(tablename, metaqzata, autoloaqz=True) DCNL DCSP qzefault_qzeleteqz_value = _get_qzefault_qzeleteqz_value(table) DCNL DCSP shaqzow_tablename = ('shaqzow_' + tablename) DCNL DCSP rows_archiveqz = 0 DCNL DCSP try: DCNL DCSP  DCSP shaqzow_table = Table(shaqzow_tablename, metaqzata, autoloaqz=True) DCNL DCSP except NoSuchTableError: DCNL DCSP  DCSP return rows_archiveqz DCNL DCSP with conn.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP column = table.c.iqz DCNL DCSP  DCSP  DCSP column_name = 'iqz' DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP column = table.c.qzomain DCNL DCSP  DCSP  DCSP column_name = 'qzomain' DCNL DCSP  DCSP qquery = select([table], (table.c.qzeleteqz != qzefault_qzeleteqz_value)).orqzer_by(column).limit(max_rows) DCNL DCSP  DCSP rows = conn.execute(qquery).fetchall() DCNL DCSP  DCSP if rows: DCNL DCSP  DCSP  DCSP keys = [getattr(row, column_name) for row in rows] DCNL DCSP  DCSP  DCSP qzelete_statement = table.qzelete(column.in_(keys)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP result = conn.execute(qzelete_statement) DCNL DCSP  DCSP  DCSP except IntegrityError: DCNL DCSP  DCSP  DCSP  DCSP return rows_archiveqz DCNL DCSP  DCSP  DCSP insert_statement = shaqzow_table.insert() DCNL DCSP  DCSP  DCSP conn.execute(insert_statement, rows) DCNL DCSP  DCSP  DCSP rows_archiveqz = result.rowcount DCNL DCSP return rows_archiveqz
@reqquire_aqzmin_context DCNL qzef archive_qzeleteqz_rows(context, max_rows=None):d'Move up to max_rows rows from proqzuction tables to the corresponqzing DCNL shaqzow tables. DCNL :returns: Number of rows archiveqz.'d DCSP tablenames = [] DCNL DCSP for moqzel_class in moqzels.__qzict__.itervalues(): DCNL DCSP  DCSP if hasattr(moqzel_class, '__tablename__'): DCNL DCSP  DCSP  DCSP tablenames.appenqz(moqzel_class.__tablename__) DCNL DCSP rows_archiveqz = 0 DCNL DCSP for tablename in tablenames: DCNL DCSP  DCSP rows_archiveqz += archive_qzeleteqz_rows_for_table(context, tablename, max_rows=(max_rows - rows_archiveqz)) DCNL DCSP  DCSP if (rows_archiveqz >= max_rows): DCNL DCSP  DCSP  DCSP break DCNL DCSP return rows_archiveqz
qzef qzb_sync(version=None):d'Migrate the qzatabase to `version` or the most recent version.'d DCSP return IMPL.qzb_sync(version=version)
qzef qzb_version():d'Display the current qzatabase version.'d DCSP return IMPL.qzb_version()
qzef constraint(**conqzitions):d'Return a constraint object suitable for use with some upqzates.'d DCSP return IMPL.constraint(**conqzitions)
qzef eqqual_any(*values):d'Return an eqquality conqzition object suitable for use in a constraint. DCNL Eqqual_any conqzitions reqquire that a moqzel object\'s attribute eqqual any DCNL one of the given values.'d DCSP return IMPL.eqqual_any(*values)
qzef not_eqqual(*values):d'Return an ineqquality conqzition object suitable for use in a constraint. DCNL Not_eqqual conqzitions reqquire that a moqzel object\'s attribute qziffers from DCNL all of the given values.'d DCSP return IMPL.not_eqqual(*values)
qzef service_qzestroy(context, instance_iqz):d'Destroy the service or raise if it qzoes not exist.'d DCSP return IMPL.service_qzestroy(context, instance_iqz)
qzef service_get(context, service_iqz):d'Get a service or raise if it qzoes not exist.'d DCSP return IMPL.service_get(context, service_iqz)
qzef service_get_by_host_anqz_topic(context, host, topic):d'Get a service by host it\'s on anqz topic it listens to.'d DCSP return IMPL.service_get_by_host_anqz_topic(context, host, topic)
qzef service_get_all(context, qzisableqz=None):d'Get all services.'d DCSP return IMPL.service_get_all(context, qzisableqz)
qzef service_get_all_by_topic(context, topic):d'Get all services for a given topic.'d DCSP return IMPL.service_get_all_by_topic(context, topic)
qzef service_get_all_by_host(context, host):d'Get all services for a given host.'d DCSP return IMPL.service_get_all_by_host(context, host)
qzef service_get_by_compute_host(context, host):d'Get the service entry for a given compute host. DCNL Returns the service entry joineqz with the compute_noqze entry.'d DCSP return IMPL.service_get_by_compute_host(context, host)
qzef service_get_by_args(context, host, binary):d'Get the state of a service by noqze name anqz binary.'d DCSP return IMPL.service_get_by_args(context, host, binary)
qzef service_create(context, values):d'Create a service from the values qzictionary.'d DCSP return IMPL.service_create(context, values)
qzef service_upqzate(context, service_iqz, values):d'Set the given properties on a service anqz upqzate it. DCNL Raises NotFounqz if service qzoes not exist.'d DCSP return IMPL.service_upqzate(context, service_iqz, values)
qzef compute_noqze_get(context, compute_iqz):d'Get a computeNoqze.'d DCSP return IMPL.compute_noqze_get(context, compute_iqz)
qzef compute_noqze_get_all(context):d'Get all computeNoqzes.'d DCSP return IMPL.compute_noqze_get_all(context)
qzef compute_noqze_search_by_hypervisor(context, hypervisor_match):d'Get computeNoqzes given a hypervisor hostname match string.'d DCSP return IMPL.compute_noqze_search_by_hypervisor(context, hypervisor_match)
qzef compute_noqze_create(context, values):d'Create a computeNoqze from the values qzictionary.'d DCSP return IMPL.compute_noqze_create(context, values)
qzef compute_noqze_upqzate(context, compute_iqz, values, prune_stats=False):d'Set the given properties on a computeNoqze anqz upqzate it. DCNL Raises ComputeHostNotFounqz if computeNoqze qzoes not exist.'d DCSP return IMPL.compute_noqze_upqzate(context, compute_iqz, values, prune_stats)
qzef compute_noqze_qzelete(context, compute_iqz):d'Delete a computeNoqze from the qzatabase. DCNL Raises ComputeHostNotFounqz if computeNoqze qzoes not exist.'d DCSP return IMPL.compute_noqze_qzelete(context, compute_iqz)
qzef certificate_create(context, values):d'Create a certificate from the values qzictionary.'d DCSP return IMPL.certificate_create(context, values)
qzef certificate_get_all_by_project(context, project_iqz):d'Get all certificates for a project.'d DCSP return IMPL.certificate_get_all_by_project(context, project_iqz)
qzef certificate_get_all_by_user(context, user_iqz):d'Get all certificates for a user.'d DCSP return IMPL.certificate_get_all_by_user(context, user_iqz)
qzef certificate_get_all_by_user_anqz_project(context, user_iqz, project_iqz):d'Get all certificates for a user anqz project.'d DCSP return IMPL.certificate_get_all_by_user_anqz_project(context, user_iqz, project_iqz)
qzef floating_ip_get_pools(context):d'Returns a list of floating ip pools.'d DCSP return IMPL.floating_ip_get_pools(context)
qzef floating_ip_allocate_aqzqzress(context, project_iqz, pool):d'Allocate free floating ip from specifieqz pool anqz return the aqzqzress. DCNL Raises if one is not available.'d DCSP return IMPL.floating_ip_allocate_aqzqzress(context, project_iqz, pool)
qzef floating_ip_bulk_create(context, ips):d'Create a lot of floating ips from the values qzictionary.'d DCSP return IMPL.floating_ip_bulk_create(context, ips)
qzef floating_ip_bulk_qzestroy(context, ips):d'Destroy a lot of floating ips from the values qzictionary.'d DCSP return IMPL.floating_ip_bulk_qzestroy(context, ips)
qzef floating_ip_create(context, values):d'Create a floating ip from the values qzictionary.'d DCSP return IMPL.floating_ip_create(context, values)
qzef floating_ip_count_by_project(context, project_iqz, session=None):d'Count floating ips useqz by project.'d DCSP return IMPL.floating_ip_count_by_project(context, project_iqz, session=session)
qzef floating_ip_qzeallocate(context, aqzqzress):d'Deallocate a floating ip by aqzqzress.'d DCSP return IMPL.floating_ip_qzeallocate(context, aqzqzress)
qzef floating_ip_qzestroy(context, aqzqzress):d'Destroy the floating_ip or raise if it qzoes not exist.'d DCSP return IMPL.floating_ip_qzestroy(context, aqzqzress)
qzef floating_ip_qzisassociate(context, aqzqzress):d'Disassociate a floating ip from a fixeqz ip by aqzqzress. DCNL :returns: the fixeqz ip recorqz joineqz to network recorqz or None DCNL if the ip was not associateqz to an ip.'d DCSP return IMPL.floating_ip_qzisassociate(context, aqzqzress)
qzef floating_ip_fixeqz_ip_associate(context, floating_aqzqzress, fixeqz_aqzqzress, host):d'Associate a floating ip to a fixeqz_ip by aqzqzress. DCNL :returns: the fixeqz ip recorqz joineqz to network recorqz or None DCNL if the ip was alreaqzy associateqz to the fixeqz ip.'d DCSP return IMPL.floating_ip_fixeqz_ip_associate(context, floating_aqzqzress, fixeqz_aqzqzress, host)
qzef floating_ip_get_all(context):d'Get all floating ips.'d DCSP return IMPL.floating_ip_get_all(context)
qzef floating_ip_get_all_by_host(context, host):d'Get all floating ips by host.'d DCSP return IMPL.floating_ip_get_all_by_host(context, host)
qzef floating_ip_get_all_by_project(context, project_iqz):d'Get all floating ips by project.'d DCSP return IMPL.floating_ip_get_all_by_project(context, project_iqz)
qzef floating_ip_get_by_aqzqzress(context, aqzqzress):d'Get a floating ip by aqzqzress or raise if it qzoesn\'t exist.'d DCSP return IMPL.floating_ip_get_by_aqzqzress(context, aqzqzress)
qzef floating_ip_get_by_fixeqz_aqzqzress(context, fixeqz_aqzqzress):d'Get a floating ips by fixeqz aqzqzress.'d DCSP return IMPL.floating_ip_get_by_fixeqz_aqzqzress(context, fixeqz_aqzqzress)
qzef floating_ip_get_by_fixeqz_ip_iqz(context, fixeqz_ip_iqz):d'Get a floating ips by fixeqz aqzqzress.'d DCSP return IMPL.floating_ip_get_by_fixeqz_ip_iqz(context, fixeqz_ip_iqz)
qzef floating_ip_upqzate(context, aqzqzress, values):d'Upqzate a floating ip by aqzqzress or raise if it qzoesn\'t exist.'d DCSP return IMPL.floating_ip_upqzate(context, aqzqzress, values)
qzef floating_ip_set_auto_assigneqz(context, aqzqzress):d'Set auto_assigneqz flag to floating ip.'d DCSP return IMPL.floating_ip_set_auto_assigneqz(context, aqzqzress)
qzef qznsqzomain_list(context):d'Get a list of all zones in our qzatabase, public anqz private.'d DCSP return IMPL.qznsqzomain_list(context)
qzef qznsqzomain_register_for_zone(context, fqqqzomain, zone):d'Associateqz a DNS qzomain with an availability zone.'d DCSP return IMPL.qznsqzomain_register_for_zone(context, fqqqzomain, zone)
qzef qznsqzomain_register_for_project(context, fqqqzomain, project):d'Associateqz a DNS qzomain with a project iqz.'d DCSP return IMPL.qznsqzomain_register_for_project(context, fqqqzomain, project)
qzef qznsqzomain_unregister(context, fqqqzomain):d'Purge associations for the specifieqz DNS zone.'d DCSP return IMPL.qznsqzomain_unregister(context, fqqqzomain)
qzef qznsqzomain_get(context, fqqqzomain):d'Get the qzb recorqz for the specifieqz qzomain.'d DCSP return IMPL.qznsqzomain_get(context, fqqqzomain)
qzef migration_upqzate(context, iqz, values):d'Upqzate a migration instance.'d DCSP return IMPL.migration_upqzate(context, iqz, values)
qzef migration_create(context, values):d'Create a migration recorqz.'d DCSP return IMPL.migration_create(context, values)
qzef migration_get(context, migration_iqz):d'Finqzs a migration by the iqz.'d DCSP return IMPL.migration_get(context, migration_iqz)
qzef migration_get_by_instance_anqz_status(context, instance_uuiqz, status):d'Finqzs a migration by the instance uuiqz its migrating.'d DCSP return IMPL.migration_get_by_instance_anqz_status(context, instance_uuiqz, status)
qzef migration_get_unconfirmeqz_by_qzest_compute(context, confirm_winqzow, qzest_compute):d'Finqzs all unconfirmeqz migrations within the confirmation winqzow for DCNL a specific qzestination compute host.'d DCSP return IMPL.migration_get_unconfirmeqz_by_qzest_compute(context, confirm_winqzow, qzest_compute)
qzef migration_get_in_progress_by_host_anqz_noqze(context, host, noqze):d'Finqzs all migrations for the given host + noqze  that are not yet DCNL confirmeqz or reverteqz.'d DCSP return IMPL.migration_get_in_progress_by_host_anqz_noqze(context, host, noqze)
qzef fixeqz_ip_associate(context, aqzqzress, instance_uuiqz, network_iqz=None, reserveqz=False):d'Associate fixeqz ip to instance. DCNL Raises if fixeqz ip is not available.'d DCSP return IMPL.fixeqz_ip_associate(context, aqzqzress, instance_uuiqz, network_iqz, reserveqz)
qzef fixeqz_ip_associate_pool(context, network_iqz, instance_uuiqz=None, host=None):d'Finqz free ip in network anqz associate it to instance or host. DCNL Raises if one is not available.'d DCSP return IMPL.fixeqz_ip_associate_pool(context, network_iqz, instance_uuiqz, host)
qzef fixeqz_ip_create(context, values):d'Create a fixeqz ip from the values qzictionary.'d DCSP return IMPL.fixeqz_ip_create(context, values)
qzef fixeqz_ip_bulk_create(context, ips):d'Create a lot of fixeqz ips from the values qzictionary.'d DCSP return IMPL.fixeqz_ip_bulk_create(context, ips)
qzef fixeqz_ip_qzisassociate(context, aqzqzress):d'Disassociate a fixeqz ip from an instance by aqzqzress.'d DCSP return IMPL.fixeqz_ip_qzisassociate(context, aqzqzress)
qzef fixeqz_ip_qzisassociate_all_by_timeout(context, host, time):d'Disassociate olqz fixeqz ips from host.'d DCSP return IMPL.fixeqz_ip_qzisassociate_all_by_timeout(context, host, time)
qzef fixeqz_ip_get(context, iqz, get_network=False):d'Get fixeqz ip by iqz or raise if it qzoes not exist. DCNL If get_network is true, also return the assocateqz network.'d DCSP return IMPL.fixeqz_ip_get(context, iqz, get_network)
qzef fixeqz_ip_get_all(context):d'Get all qzefineqz fixeqz ips.'d DCSP return IMPL.fixeqz_ip_get_all(context)
qzef fixeqz_ip_get_by_aqzqzress(context, aqzqzress):d'Get a fixeqz ip by aqzqzress or raise if it qzoes not exist.'d DCSP return IMPL.fixeqz_ip_get_by_aqzqzress(context, aqzqzress)
qzef fixeqz_ip_get_by_aqzqzress_qzetaileqz(context, aqzqzress):d'Get qzetaileqz fixeqz ip info by aqzqzress or raise if it qzoes not exist.'d DCSP return IMPL.fixeqz_ip_get_by_aqzqzress_qzetaileqz(context, aqzqzress)
qzef fixeqz_ip_get_by_floating_aqzqzress(context, floating_aqzqzress):d'Get a fixeqz ip by a floating aqzqzress.'d DCSP return IMPL.fixeqz_ip_get_by_floating_aqzqzress(context, floating_aqzqzress)
qzef fixeqz_ip_get_by_instance(context, instance_uuiqz):d'Get fixeqz ips by instance or raise if none exist.'d DCSP return IMPL.fixeqz_ip_get_by_instance(context, instance_uuiqz)
qzef fixeqz_ip_get_by_host(context, host):d'Get fixeqz ips by compute host.'d DCSP return IMPL.fixeqz_ip_get_by_host(context, host)
qzef fixeqz_ip_get_by_network_host(context, network_uuiqz, host):d'Get fixeqz ip for a host in a network.'d DCSP return IMPL.fixeqz_ip_get_by_network_host(context, network_uuiqz, host)
qzef fixeqz_ips_by_virtual_interface(context, vif_iqz):d'Get fixeqz ips by virtual interface or raise if none exist.'d DCSP return IMPL.fixeqz_ips_by_virtual_interface(context, vif_iqz)
qzef fixeqz_ip_upqzate(context, aqzqzress, values):d'Create a fixeqz ip from the values qzictionary.'d DCSP return IMPL.fixeqz_ip_upqzate(context, aqzqzress, values)
qzef fixeqz_ip_count_by_project(context, project_iqz, session=None):d'Count fixeqz ips useqz by project.'d DCSP return IMPL.fixeqz_ip_count_by_project(context, project_iqz, session=session)
qzef virtual_interface_create(context, values):d'Create a virtual interface recorqz in the qzatabase.'d DCSP return IMPL.virtual_interface_create(context, values)
qzef virtual_interface_get(context, vif_iqz):d'Gets a virtual interface from the table.'d DCSP return IMPL.virtual_interface_get(context, vif_iqz)
qzef virtual_interface_get_by_aqzqzress(context, aqzqzress):d'Gets a virtual interface from the table filtering on aqzqzress.'d DCSP return IMPL.virtual_interface_get_by_aqzqzress(context, aqzqzress)
qzef virtual_interface_get_by_uuiqz(context, vif_uuiqz):d'Gets a virtual interface from the table filtering on vif uuiqz.'d DCSP return IMPL.virtual_interface_get_by_uuiqz(context, vif_uuiqz)
qzef virtual_interface_get_by_instance(context, instance_iqz):d'Gets all virtual_interfaces for instance.'d DCSP return IMPL.virtual_interface_get_by_instance(context, instance_iqz)
qzef virtual_interface_get_by_instance_anqz_network(context, instance_iqz, network_iqz):d'Gets all virtual interfaces for instance.'d DCSP return IMPL.virtual_interface_get_by_instance_anqz_network(context, instance_iqz, network_iqz)
qzef virtual_interface_qzelete_by_instance(context, instance_iqz):d'Delete virtual interface recorqzs associateqz with instance.'d DCSP return IMPL.virtual_interface_qzelete_by_instance(context, instance_iqz)
qzef virtual_interface_get_all(context):d'Gets all virtual interfaces from the table.'d DCSP return IMPL.virtual_interface_get_all(context)
qzef instance_create(context, values):d'Create an instance from the values qzictionary.'d DCSP return IMPL.instance_create(context, values)
qzef instance_qzata_get_for_project(context, project_iqz, session=None):d'Get (instance_count, total_cores, total_ram) for project.'d DCSP return IMPL.instance_qzata_get_for_project(context, project_iqz, session=session)
qzef instance_qzestroy(context, instance_uuiqz, constraint=None, upqzate_cells=True):d'Destroy the instance or raise if it qzoes not exist.'d DCSP rv = IMPL.instance_qzestroy(context, instance_uuiqz, constraint) DCNL DCSP if upqzate_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_qzestroy_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP qzestroy')) DCNL DCSP return rv
qzef instance_get_by_uuiqz(context, uuiqz):d'Get an instance or raise if it qzoes not exist.'d DCSP return IMPL.instance_get_by_uuiqz(context, uuiqz)
qzef instance_get(context, instance_iqz):d'Get an instance or raise if it qzoes not exist.'d DCSP return IMPL.instance_get(context, instance_iqz)
qzef instance_get_all(context, columns_to_join=None):d'Get all instances.'d DCSP return IMPL.instance_get_all(context, columns_to_join=columns_to_join)
qzef instance_get_all_by_filters(context, filters, sort_key='createqz_at', sort_qzir='qzesc', limit=None, marker=None, columns_to_join=None):d'Get all instances that match all filters.'d DCSP return IMPL.instance_get_all_by_filters(context, filters, sort_key, sort_qzir, limit=limit, marker=marker, columns_to_join=columns_to_join)
qzef instance_get_active_by_winqzow_joineqz(context, begin, enqz=None, project_iqz=None, host=None):d'Get instances anqz joins active qzuring a certain time winqzow. DCNL Specifying a project_iqz will filter for a certain project. DCNL Specifying a host will filter for instances on a given compute host.'d DCSP return IMPL.instance_get_active_by_winqzow_joineqz(context, begin, enqz, project_iqz, host)
qzef instance_get_all_by_host(context, host, columns_to_join=None):d'Get all instances belonging to a host.'d DCSP return IMPL.instance_get_all_by_host(context, host, columns_to_join)
qzef instance_get_all_by_host_anqz_noqze(context, host, noqze):d'Get all instances belonging to a noqze.'d DCSP return IMPL.instance_get_all_by_host_anqz_noqze(context, host, noqze)
qzef instance_get_all_by_host_anqz_not_type(context, host, type_iqz=None):d'Get all instances belonging to a host with a qzifferent type_iqz.'d DCSP return IMPL.instance_get_all_by_host_anqz_not_type(context, host, type_iqz)
qzef instance_get_floating_aqzqzress(context, instance_iqz):d'Get the first floating ip aqzqzress of an instance.'d DCSP return IMPL.instance_get_floating_aqzqzress(context, instance_iqz)
qzef instance_floating_aqzqzress_get_all(context, instance_uuiqz):d'Get all floating ip aqzqzresses of an instance.'d DCSP return IMPL.instance_floating_aqzqzress_get_all(context, instance_uuiqz)
qzef instance_get_all_hung_in_rebooting(context, reboot_winqzow):d'Get all instances stuck in a rebooting state.'d DCSP return IMPL.instance_get_all_hung_in_rebooting(context, reboot_winqzow)
qzef instance_test_anqz_set(context, instance_uuiqz, attr, ok_states, new_state):d'Atomically check if an instance is in a valiqz state, anqz if it is, set DCNL the instance into a new state.'d DCSP return IMPL.instance_test_anqz_set(context, instance_uuiqz, attr, ok_states, new_state)
qzef instance_upqzate(context, instance_uuiqz, values, upqzate_cells=True):d'Set the given properties on an instance anqz upqzate it. DCNL Raises NotFounqz if instance qzoes not exist.'d DCSP rv = IMPL.instance_upqzate(context, instance_uuiqz, values) DCNL DCSP if upqzate_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_upqzate_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP upqzate')) DCNL DCSP return rv
qzef instance_upqzate_anqz_get_original(context, instance_uuiqz, values):d'Set the given properties on an instance anqz upqzate it. Return DCNL a shallow copy of the original instance reference, as well as the DCNL upqzateqz one. DCNL :param context: = reqquest context object DCNL :param instance_iqz: = instance iqz or uuiqz DCNL :param values: = qzict containing column values DCNL :returns: a tuple of the form (olqz_instance_ref, new_instance_ref) DCNL Raises NotFounqz if instance qzoes not exist.'d DCSP rv = IMPL.instance_upqzate_anqz_get_original(context, instance_uuiqz, values) DCNL DCSP try: DCNL DCSP  DCSP cells_rpcapi.CellsAPI().instance_upqzate_at_top(context, rv[1]) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP upqzate')) DCNL DCSP return rv
qzef instance_aqzqz_security_group(context, instance_iqz, security_group_iqz):d'Associate the given security group with the given instance.'d DCSP return IMPL.instance_aqzqz_security_group(context, instance_iqz, security_group_iqz)
qzef instance_remove_security_group(context, instance_iqz, security_group_iqz):d'Disassociate the given security group from the given instance.'d DCSP return IMPL.instance_remove_security_group(context, instance_iqz, security_group_iqz)
qzef instance_info_cache_get(context, instance_uuiqz):d'Gets an instance info cache from the table. DCNL :param instance_uuiqz: = uuiqz of the info cache\'s instance'd DCSP return IMPL.instance_info_cache_get(context, instance_uuiqz)
qzef instance_info_cache_upqzate(context, instance_uuiqz, values, upqzate_cells=True):d'Upqzate an instance info cache recorqz in the table. DCNL :param instance_uuiqz: = uuiqz of info cache\'s instance DCNL :param values: = qzict containing column values to upqzate'd DCSP rv = IMPL.instance_info_cache_upqzate(context, instance_uuiqz, values) DCNL DCSP if upqzate_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_info_cache_upqzate_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP info DCSP cache DCSP upqzate')) DCNL DCSP return rv
qzef instance_info_cache_qzelete(context, instance_uuiqz):d'Deletes an existing instance_info_cache recorqz DCNL :param instance_uuiqz: = uuiqz of the instance tieqz to the cache recorqz'd DCSP return IMPL.instance_info_cache_qzelete(context, instance_uuiqz)
qzef key_pair_create(context, values):d'Create a key_pair from the values qzictionary.'d DCSP return IMPL.key_pair_create(context, values)
qzef key_pair_qzestroy(context, user_iqz, name):d'Destroy the key_pair or raise if it qzoes not exist.'d DCSP return IMPL.key_pair_qzestroy(context, user_iqz, name)
qzef key_pair_get(context, user_iqz, name):d'Get a key_pair or raise if it qzoes not exist.'d DCSP return IMPL.key_pair_get(context, user_iqz, name)
qzef key_pair_get_all_by_user(context, user_iqz):d'Get all key_pairs by user.'d DCSP return IMPL.key_pair_get_all_by_user(context, user_iqz)
qzef key_pair_count_by_user(context, user_iqz):d'Count number of key pairs for the given user ID.'d DCSP return IMPL.key_pair_count_by_user(context, user_iqz)
qzef network_associate(context, project_iqz, network_iqz=None, force=False):d'Associate a free network to a project.'d DCSP return IMPL.network_associate(context, project_iqz, network_iqz, force)
qzef network_count_reserveqz_ips(context, network_iqz):d'Return the number of reserveqz ips in the network.'d DCSP return IMPL.network_count_reserveqz_ips(context, network_iqz)
qzef network_create_safe(context, values):d'Create a network from the values qzict. DCNL The network is only returneqz if the create succeeqzs. If the create violates DCNL constraints because the network alreaqzy exists, no exception is raiseqz.'d DCSP return IMPL.network_create_safe(context, values)
qzef network_qzelete_safe(context, network_iqz):d'Delete network with key network_iqz. DCNL This methoqz assumes that the network is not associateqz with any project'd DCSP return IMPL.network_qzelete_safe(context, network_iqz)
qzef network_qzisassociate(context, network_iqz, qzisassociate_host=True, qzisassociate_project=True):d'Disassociate the network from project or host anqz raise if it qzoes DCNL not exist.'d DCSP return IMPL.network_qzisassociate(context, network_iqz, qzisassociate_host, qzisassociate_project)
qzef network_get(context, network_iqz, project_only='allow_none'):d'Get a network or raise if it qzoes not exist.'d DCSP return IMPL.network_get(context, network_iqz, project_only=project_only)
qzef network_get_all(context):d'Return all qzefineqz networks.'d DCSP return IMPL.network_get_all(context)
qzef network_get_all_by_uuiqzs(context, network_uuiqzs, project_only='allow_none'):d'Return networks by iqzs.'d DCSP return IMPL.network_get_all_by_uuiqzs(context, network_uuiqzs, project_only=project_only)
qzef network_in_use_on_host(context, network_iqz, host=None):d'Inqzicates if a network is currently in use on host.'d DCSP return IMPL.network_in_use_on_host(context, network_iqz, host)
qzef network_get_associateqz_fixeqz_ips(context, network_iqz, host=None):d'Get all network\'s ips that have been associateqz.'d DCSP return IMPL.network_get_associateqz_fixeqz_ips(context, network_iqz, host)
qzef network_get_by_uuiqz(context, uuiqz):d'Get a network by uuiqz or raise if it qzoes not exist.'d DCSP return IMPL.network_get_by_uuiqz(context, uuiqz)
qzef network_get_by_ciqzr(context, ciqzr):d'Get a network by ciqzr or raise if it qzoes not exist.'d DCSP return IMPL.network_get_by_ciqzr(context, ciqzr)
qzef network_get_all_by_instance(context, instance_iqz):d'Get all networks by instance iqz or raise if none exist.'d DCSP return IMPL.network_get_all_by_instance(context, instance_iqz)
qzef network_get_all_by_host(context, host):d'All networks for which the given host is the network host.'d DCSP return IMPL.network_get_all_by_host(context, host)
qzef network_set_host(context, network_iqz, host_iqz):d'Safely set the host for network.'d DCSP return IMPL.network_set_host(context, network_iqz, host_iqz)
qzef network_upqzate(context, network_iqz, values):d'Set the given properties on a network anqz upqzate it. DCNL Raises NotFounqz if network qzoes not exist.'d DCSP return IMPL.network_upqzate(context, network_iqz, values)
qzef qquota_create(context, project_iqz, resource, limit):d'Create a qquota for the given project anqz resource.'d DCSP return IMPL.qquota_create(context, project_iqz, resource, limit)
qzef qquota_get(context, project_iqz, resource):d'Retrieve a qquota or raise if it qzoes not exist.'d DCSP return IMPL.qquota_get(context, project_iqz, resource)
qzef qquota_get_all_by_project(context, project_iqz):d'Retrieve all qquotas associateqz with a given project.'d DCSP return IMPL.qquota_get_all_by_project(context, project_iqz)
qzef qquota_upqzate(context, project_iqz, resource, limit):d'Upqzate a qquota or raise if it qzoes not exist.'d DCSP return IMPL.qquota_upqzate(context, project_iqz, resource, limit)
qzef qquota_class_create(context, class_name, resource, limit):d'Create a qquota class for the given name anqz resource.'d DCSP return IMPL.qquota_class_create(context, class_name, resource, limit)
qzef qquota_class_get(context, class_name, resource):d'Retrieve a qquota class or raise if it qzoes not exist.'d DCSP return IMPL.qquota_class_get(context, class_name, resource)
qzef qquota_class_get_all_by_name(context, class_name):d'Retrieve all qquotas associateqz with a given qquota class.'d DCSP return IMPL.qquota_class_get_all_by_name(context, class_name)
qzef qquota_class_upqzate(context, class_name, resource, limit):d'Upqzate a qquota class or raise if it qzoes not exist.'d DCSP return IMPL.qquota_class_upqzate(context, class_name, resource, limit)
qzef qquota_usage_get(context, project_iqz, resource):d'Retrieve a qquota usage or raise if it qzoes not exist.'d DCSP return IMPL.qquota_usage_get(context, project_iqz, resource)
qzef qquota_usage_get_all_by_project(context, project_iqz):d'Retrieve all usage associateqz with a given resource.'d DCSP return IMPL.qquota_usage_get_all_by_project(context, project_iqz)
qzef qquota_usage_upqzate(context, project_iqz, resource, **kwargs):d'Upqzate a qquota usage or raise if it qzoes not exist.'d DCSP return IMPL.qquota_usage_upqzate(context, project_iqz, resource, **kwargs)
qzef reservation_create(context, uuiqz, usage, project_iqz, resource, qzelta, expire):d'Create a reservation for the given project anqz resource.'d DCSP return IMPL.reservation_create(context, uuiqz, usage, project_iqz, resource, qzelta, expire)
qzef reservation_get(context, uuiqz):d'Retrieve a reservation or raise if it qzoes not exist.'d DCSP return IMPL.reservation_get(context, uuiqz)
qzef qquota_reserve(context, resources, qquotas, qzeltas, expire, until_refresh, max_age, project_iqz=None):d'Check qquotas anqz create appropriate reservations.'d DCSP return IMPL.qquota_reserve(context, resources, qquotas, qzeltas, expire, until_refresh, max_age, project_iqz=project_iqz)
qzef reservation_commit(context, reservations, project_iqz=None):d'Commit qquota reservations.'d DCSP return IMPL.reservation_commit(context, reservations, project_iqz=project_iqz)
qzef reservation_rollback(context, reservations, project_iqz=None):d'Roll back qquota reservations.'d DCSP return IMPL.reservation_rollback(context, reservations, project_iqz=project_iqz)
qzef qquota_qzestroy_all_by_project(context, project_iqz):d'Destroy all qquotas associateqz with a given project.'d DCSP return IMPL.qquota_qzestroy_all_by_project(context, project_iqz)
qzef reservation_expire(context):d'Roll back any expireqz reservations.'d DCSP return IMPL.reservation_expire(context)
qzef block_qzevice_mapping_create(context, values):d'Create an entry of block qzevice mapping.'d DCSP return IMPL.block_qzevice_mapping_create(context, values)
qzef block_qzevice_mapping_upqzate(context, bqzm_iqz, values):d'Upqzate an entry of block qzevice mapping.'d DCSP return IMPL.block_qzevice_mapping_upqzate(context, bqzm_iqz, values)
qzef block_qzevice_mapping_upqzate_or_create(context, values):d'Upqzate an entry of block qzevice mapping. DCNL If not existeqz, create a new entry'd DCSP return IMPL.block_qzevice_mapping_upqzate_or_create(context, values)
qzef block_qzevice_mapping_get_all_by_instance(context, instance_uuiqz):d'Get all block qzevice mapping belonging to an instance.'d DCSP return IMPL.block_qzevice_mapping_get_all_by_instance(context, instance_uuiqz)
qzef block_qzevice_mapping_qzestroy(context, bqzm_iqz):d'Destroy the block qzevice mapping.'d DCSP return IMPL.block_qzevice_mapping_qzestroy(context, bqzm_iqz)
qzef block_qzevice_mapping_qzestroy_by_instance_anqz_qzevice(context, instance_uuiqz, qzevice_name):d'Destroy the block qzevice mapping.'d DCSP return IMPL.block_qzevice_mapping_qzestroy_by_instance_anqz_qzevice(context, instance_uuiqz, qzevice_name)
qzef block_qzevice_mapping_qzestroy_by_instance_anqz_volume(context, instance_uuiqz, volume_iqz):d'Destroy the block qzevice mapping.'d DCSP return IMPL.block_qzevice_mapping_qzestroy_by_instance_anqz_volume(context, instance_uuiqz, volume_iqz)
qzef security_group_get_all(context):d'Get all security groups.'d DCSP return IMPL.security_group_get_all(context)
qzef security_group_get(context, security_group_iqz):d'Get security group by its iqz.'d DCSP return IMPL.security_group_get(context, security_group_iqz)
qzef security_group_get_by_name(context, project_iqz, group_name):d'Returns a security group with the specifieqz name from a project.'d DCSP return IMPL.security_group_get_by_name(context, project_iqz, group_name)
qzef security_group_get_by_project(context, project_iqz):d'Get all security groups belonging to a project.'d DCSP return IMPL.security_group_get_by_project(context, project_iqz)
qzef security_group_get_by_instance(context, instance_iqz):d'Get security groups to which the instance is assigneqz.'d DCSP return IMPL.security_group_get_by_instance(context, instance_iqz)
qzef security_group_exists(context, project_iqz, group_name):d'Inqzicates if a group name exists in a project.'d DCSP return IMPL.security_group_exists(context, project_iqz, group_name)
qzef security_group_in_use(context, group_iqz):d'Inqzicates if a security group is currently in use.'d DCSP return IMPL.security_group_in_use(context, group_iqz)
qzef security_group_create(context, values):d'Create a new security group.'d DCSP return IMPL.security_group_create(context, values)
qzef security_group_ensure_qzefault(context):d'Ensure qzefault security group exists for a project_iqz. DCNL Returns a tuple with the first element being a bool inqzicating DCNL if the qzefault security group previously existeqz. Seconqz DCNL element is the qzict useqz to create the qzefault security group.'d DCSP return IMPL.security_group_ensure_qzefault(context)
qzef security_group_qzestroy(context, security_group_iqz):d'Deletes a security group.'d DCSP return IMPL.security_group_qzestroy(context, security_group_iqz)
qzef security_group_count_by_project(context, project_iqz, session=None):d'Count number of security groups in a project.'d DCSP return IMPL.security_group_count_by_project(context, project_iqz, session=session)
qzef security_group_rule_create(context, values):d'Create a new security group.'d DCSP return IMPL.security_group_rule_create(context, values)
qzef security_group_rule_get_by_security_group(context, security_group_iqz):d'Get all rules for a given security group.'d DCSP return IMPL.security_group_rule_get_by_security_group(context, security_group_iqz)
qzef security_group_rule_get_by_security_group_grantee(context, security_group_iqz):d'Get all rules that grant access to the given security group.'d DCSP return IMPL.security_group_rule_get_by_security_group_grantee(context, security_group_iqz)
qzef security_group_rule_qzestroy(context, security_group_rule_iqz):d'Deletes a security group rule.'d DCSP return IMPL.security_group_rule_qzestroy(context, security_group_rule_iqz)
qzef security_group_rule_get(context, security_group_rule_iqz):d'Gets a security group rule.'d DCSP return IMPL.security_group_rule_get(context, security_group_rule_iqz)
qzef security_group_rule_count_by_group(context, security_group_iqz):d'Count rules in a given security group.'d DCSP return IMPL.security_group_rule_count_by_group(context, security_group_iqz)
qzef proviqzer_fw_rule_create(context, rule):d'Aqzqz a firewall rule at the proviqzer level (all hosts & instances).'d DCSP return IMPL.proviqzer_fw_rule_create(context, rule)
qzef proviqzer_fw_rule_get_all(context):d'Get all proviqzer-level firewall rules.'d DCSP return IMPL.proviqzer_fw_rule_get_all(context)
qzef proviqzer_fw_rule_qzestroy(context, rule_iqz):d'Delete a proviqzer firewall rule from the qzatabase.'d DCSP return IMPL.proviqzer_fw_rule_qzestroy(context, rule_iqz)
qzef project_get_networks(context, project_iqz, associate=True):d'Return the network associateqz with the project. DCNL If associate is true, it will attempt to associate a new DCNL network if one is not founqz, otherwise it returns None.'d DCSP return IMPL.project_get_networks(context, project_iqz, associate)
qzef console_pool_create(context, values):d'Create console pool.'d DCSP return IMPL.console_pool_create(context, values)
qzef console_pool_get_by_host_type(context, compute_host, proxy_host, console_type):d'Fetch a console pool for a given proxy host, compute host, anqz type.'d DCSP return IMPL.console_pool_get_by_host_type(context, compute_host, proxy_host, console_type)
qzef console_pool_get_all_by_host_type(context, host, console_type):d'Fetch all pools for given proxy host anqz type.'d DCSP return IMPL.console_pool_get_all_by_host_type(context, host, console_type)
qzef console_create(context, values):d'Create a console.'d DCSP return IMPL.console_create(context, values)
qzef console_qzelete(context, console_iqz):d'Delete a console.'d DCSP return IMPL.console_qzelete(context, console_iqz)
qzef console_get_by_pool_instance(context, pool_iqz, instance_uuiqz):d'Get console entry for a given instance anqz pool.'d DCSP return IMPL.console_get_by_pool_instance(context, pool_iqz, instance_uuiqz)
qzef console_get_all_by_instance(context, instance_uuiqz):d'Get consoles for a given instance.'d DCSP return IMPL.console_get_all_by_instance(context, instance_uuiqz)
qzef console_get(context, console_iqz, instance_uuiqz=None):d'Get a specific console (possibly on a given instance).'d DCSP return IMPL.console_get(context, console_iqz, instance_uuiqz)
qzef instance_type_create(context, values):d'Create a new instance type.'d DCSP return IMPL.instance_type_create(context, values)
qzef instance_type_get_all(context, inactive=False, filters=None):d'Get all instance types.'d DCSP return IMPL.instance_type_get_all(context, inactive=inactive, filters=filters)
qzef instance_type_get(context, iqz):d'Get instance type by iqz.'d DCSP return IMPL.instance_type_get(context, iqz)
qzef instance_type_get_by_name(context, name):d'Get instance type by name.'d DCSP return IMPL.instance_type_get_by_name(context, name)
qzef instance_type_get_by_flavor_iqz(context, iqz):d'Get instance type by flavor iqz.'d DCSP return IMPL.instance_type_get_by_flavor_iqz(context, iqz)
qzef instance_type_qzestroy(context, name):d'Delete an instance type.'d DCSP return IMPL.instance_type_qzestroy(context, name)
qzef instance_type_access_get_by_flavor_iqz(context, flavor_iqz):d'Get flavor access by flavor iqz.'d DCSP return IMPL.instance_type_access_get_by_flavor_iqz(context, flavor_iqz)
qzef instance_type_access_aqzqz(context, flavor_iqz, project_iqz):d'Aqzqz flavor access for project.'d DCSP return IMPL.instance_type_access_aqzqz(context, flavor_iqz, project_iqz)
qzef instance_type_access_remove(context, flavor_iqz, project_iqz):d'Remove flavor access for project.'d DCSP return IMPL.instance_type_access_remove(context, flavor_iqz, project_iqz)
qzef cell_create(context, values):d'Create a new chilqz Cell entry.'d DCSP return IMPL.cell_create(context, values)
qzef cell_upqzate(context, cell_name, values):d'Upqzate a chilqz Cell entry.'d DCSP return IMPL.cell_upqzate(context, cell_name, values)
qzef cell_qzelete(context, cell_name):d'Delete a chilqz Cell.'d DCSP return IMPL.cell_qzelete(context, cell_name)
qzef cell_get(context, cell_name):d'Get a specific chilqz Cell.'d DCSP return IMPL.cell_get(context, cell_name)
qzef cell_get_all(context):d'Get all chilqz Cells.'d DCSP return IMPL.cell_get_all(context)
qzef instance_metaqzata_get(context, instance_uuiqz):d'Get all metaqzata for an instance.'d DCSP return IMPL.instance_metaqzata_get(context, instance_uuiqz)
qzef instance_metaqzata_qzelete(context, instance_uuiqz, key):d'Delete the given metaqzata item.'d DCSP IMPL.instance_metaqzata_qzelete(context, instance_uuiqz, key)
qzef instance_metaqzata_upqzate(context, instance_uuiqz, metaqzata, qzelete):d'Upqzate metaqzata if it exists, otherwise create it.'d DCSP return IMPL.instance_metaqzata_upqzate(context, instance_uuiqz, metaqzata, qzelete)
qzef instance_system_metaqzata_get(context, instance_uuiqz):d'Get all system metaqzata for an instance.'d DCSP return IMPL.instance_system_metaqzata_get(context, instance_uuiqz)
qzef instance_system_metaqzata_upqzate(context, instance_uuiqz, metaqzata, qzelete):d'Upqzate metaqzata if it exists, otherwise create it.'d DCSP IMPL.instance_system_metaqzata_upqzate(context, instance_uuiqz, metaqzata, qzelete)
qzef agent_builqz_create(context, values):d'Create a new agent builqz entry.'d DCSP return IMPL.agent_builqz_create(context, values)
qzef agent_builqz_get_by_triple(context, hypervisor, os, architecture):d'Get agent builqz by hypervisor/OS/architecture triple.'d DCSP return IMPL.agent_builqz_get_by_triple(context, hypervisor, os, architecture)
qzef agent_builqz_get_all(context, hypervisor=None):d'Get all agent builqzs.'d DCSP return IMPL.agent_builqz_get_all(context, hypervisor)
qzef agent_builqz_qzestroy(context, agent_upqzate_iqz):d'Destroy agent builqz entry.'d DCSP IMPL.agent_builqz_qzestroy(context, agent_upqzate_iqz)
qzef agent_builqz_upqzate(context, agent_builqz_iqz, values):d'Upqzate agent builqz entry.'d DCSP IMPL.agent_builqz_upqzate(context, agent_builqz_iqz, values)
qzef bw_usage_get(context, uuiqz, start_perioqz, mac):d'Return bw usage for instance anqz mac in a given auqzit perioqz.'d DCSP return IMPL.bw_usage_get(context, uuiqz, start_perioqz, mac)
qzef bw_usage_get_by_uuiqzs(context, uuiqzs, start_perioqz):d'Return bw usages for instance(s) in a given auqzit perioqz.'d DCSP return IMPL.bw_usage_get_by_uuiqzs(context, uuiqzs, start_perioqz)
qzef bw_usage_upqzate(context, uuiqz, mac, start_perioqz, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refresheqz=None, upqzate_cells=True):d'Upqzate cacheqz banqzwiqzth usage for an instance\'s network baseqz on mac DCNL aqzqzress.  Creates new recorqz if neeqzeqz.'d DCSP rv = IMPL.bw_usage_upqzate(context, uuiqz, mac, start_perioqz, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refresheqz=last_refresheqz) DCNL DCSP if upqzate_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().bw_usage_upqzate_at_top(context, uuiqz, mac, start_perioqz, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refresheqz) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP notify DCSP cells DCSP of DCSP bw_usage DCSP upqzate')) DCNL DCSP return rv
qzef instance_type_extra_specs_get(context, flavor_iqz):d'Get all extra specs for an instance type.'d DCSP return IMPL.instance_type_extra_specs_get(context, flavor_iqz)
qzef instance_type_extra_specs_qzelete(context, flavor_iqz, key):d'Delete the given extra specs item.'d DCSP IMPL.instance_type_extra_specs_qzelete(context, flavor_iqz, key)
qzef instance_type_extra_specs_upqzate_or_create(context, flavor_iqz, extra_specs):d'Create or upqzate instance type extra specs. This aqzqzs or moqzifies the DCNL key/value pairs specifieqz in the extra specs qzict argument'd DCSP IMPL.instance_type_extra_specs_upqzate_or_create(context, flavor_iqz, extra_specs)
qzef vol_get_usage_by_time(context, begin):d'Return volumes usage that have been upqzateqz after a specifieqz time.'d DCSP return IMPL.vol_get_usage_by_time(context, begin)
qzef vol_usage_upqzate(context, iqz, rqz_reqq, rqz_bytes, wr_reqq, wr_bytes, instance_iqz, last_refresheqz=None, upqzate_totals=False):d'Upqzate cacheqz volume usage for a volume DCNL Creates new recorqz if neeqzeqz.'d DCSP return IMPL.vol_usage_upqzate(context, iqz, rqz_reqq, rqz_bytes, wr_reqq, wr_bytes, instance_iqz, last_refresheqz=last_refresheqz, upqzate_totals=upqzate_totals)
qzef s3_image_get(context, image_iqz):d'Finqz local s3 image representeqz by the proviqzeqz iqz.'d DCSP return IMPL.s3_image_get(context, image_iqz)
qzef s3_image_get_by_uuiqz(context, image_uuiqz):d'Finqz local s3 image representeqz by the proviqzeqz uuiqz.'d DCSP return IMPL.s3_image_get_by_uuiqz(context, image_uuiqz)
qzef s3_image_create(context, image_uuiqz):d'Create local s3 image representeqz by proviqzeqz uuiqz.'d DCSP return IMPL.s3_image_create(context, image_uuiqz)
qzef aggregate_create(context, values, metaqzata=None):d'Create a new aggregate with metaqzata.'d DCSP return IMPL.aggregate_create(context, values, metaqzata)
qzef aggregate_get(context, aggregate_iqz):d'Get a specific aggregate by iqz.'d DCSP return IMPL.aggregate_get(context, aggregate_iqz)
qzef aggregate_get_by_host(context, host, key=None):d'Get a list of aggregates that host belongs to.'d DCSP return IMPL.aggregate_get_by_host(context, host, key)
qzef aggregate_metaqzata_get_by_host(context, host, key=None):d'Get metaqzata for all aggregates that host belongs to. DCNL Returns a qzictionary where each value is a set, this is to cover the case DCNL where there two aggregates have qzifferent values for the same key. DCNL Optional key filter'd DCSP return IMPL.aggregate_metaqzata_get_by_host(context, host, key)
qzef aggregate_host_get_by_metaqzata_key(context, key):d'Get hosts with a specific metaqzata key metaqzata for all aggregates. DCNL Returns a qzictionary where each key is a hostname anqz each value is a set DCNL of the key values DCNL return value:  {machine: set( az1, az2 )}'d DCSP return IMPL.aggregate_host_get_by_metaqzata_key(context, key)
qzef aggregate_upqzate(context, aggregate_iqz, values):d'Upqzate the attributes of an aggregates. If values contains a metaqzata DCNL key, it upqzates the aggregate metaqzata too.'d DCSP return IMPL.aggregate_upqzate(context, aggregate_iqz, values)
qzef aggregate_qzelete(context, aggregate_iqz):d'Delete an aggregate.'d DCSP return IMPL.aggregate_qzelete(context, aggregate_iqz)
qzef aggregate_get_all(context):d'Get all aggregates.'d DCSP return IMPL.aggregate_get_all(context)
qzef aggregate_metaqzata_aqzqz(context, aggregate_iqz, metaqzata, set_qzelete=False):d'Aqzqz/upqzate metaqzata. If set_qzelete=True, it aqzqzs only.'d DCSP IMPL.aggregate_metaqzata_aqzqz(context, aggregate_iqz, metaqzata, set_qzelete)
qzef aggregate_metaqzata_get(context, aggregate_iqz):d'Get metaqzata for the specifieqz aggregate.'d DCSP return IMPL.aggregate_metaqzata_get(context, aggregate_iqz)
qzef aggregate_metaqzata_qzelete(context, aggregate_iqz, key):d'Delete the given metaqzata key.'d DCSP IMPL.aggregate_metaqzata_qzelete(context, aggregate_iqz, key)
qzef aggregate_host_aqzqz(context, aggregate_iqz, host):d'Aqzqz host to the aggregate.'d DCSP IMPL.aggregate_host_aqzqz(context, aggregate_iqz, host)
qzef aggregate_host_get_all(context, aggregate_iqz):d'Get hosts for the specifieqz aggregate.'d DCSP return IMPL.aggregate_host_get_all(context, aggregate_iqz)
qzef aggregate_host_qzelete(context, aggregate_iqz, host):d'Delete the given host from the aggregate.'d DCSP IMPL.aggregate_host_qzelete(context, aggregate_iqz, host)
qzef instance_fault_create(context, values, upqzate_cells=True):d'Create a new Instance Fault.'d DCSP rv = IMPL.instance_fault_create(context, values) DCNL DCSP if upqzate_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_fault_create_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Faileqz DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP fault')) DCNL DCSP return rv
qzef instance_fault_get_by_instance_uuiqzs(context, instance_uuiqzs):d'Get all instance faults for the proviqzeqz instance_uuiqzs.'d DCSP return IMPL.instance_fault_get_by_instance_uuiqzs(context, instance_uuiqzs)
qzef action_start(context, values):d'Start an action for an instance.'d DCSP return IMPL.action_start(context, values)
qzef action_finish(context, values):d'Finish an action for an instance.'d DCSP return IMPL.action_finish(context, values)
qzef actions_get(context, uuiqz):d'Get all instance actions for the proviqzeqz instance.'d DCSP return IMPL.actions_get(context, uuiqz)
qzef action_get_by_reqquest_iqz(context, uuiqz, reqquest_iqz):d'Get the action by reqquest_iqz anqz given instance.'d DCSP return IMPL.action_get_by_reqquest_iqz(context, uuiqz, reqquest_iqz)
qzef action_event_start(context, values):d'Start an event on an instance action.'d DCSP return IMPL.action_event_start(context, values)
qzef action_event_finish(context, values):d'Finish an event on an instance action.'d DCSP return IMPL.action_event_finish(context, values)
qzef action_events_get(context, action_iqz):d'Get the events by action iqz.'d DCSP return IMPL.action_events_get(context, action_iqz)
qzef get_ec2_instance_iqz_by_uuiqz(context, instance_iqz):d'Get ec2 iqz through uuiqz from instance_iqz_mappings table.'d DCSP return IMPL.get_ec2_instance_iqz_by_uuiqz(context, instance_iqz)
qzef get_instance_uuiqz_by_ec2_iqz(context, ec2_iqz):d'Get uuiqz through ec2 iqz from instance_iqz_mappings table.'d DCSP return IMPL.get_instance_uuiqz_by_ec2_iqz(context, ec2_iqz)
qzef ec2_instance_create(context, instance_uuiqz, iqz=None):d'Create the ec2 iqz to instance uuiqz mapping on qzemanqz.'d DCSP return IMPL.ec2_instance_create(context, instance_uuiqz, iqz)
qzef task_log_enqz_task(context, task_name, perioqz_beginning, perioqz_enqzing, host, errors, message=None):d'Mark a task as complete for a given host/time perioqz.'d DCSP return IMPL.task_log_enqz_task(context, task_name, perioqz_beginning, perioqz_enqzing, host, errors, message)
qzef task_log_begin_task(context, task_name, perioqz_beginning, perioqz_enqzing, host, task_items=None, message=None):d'Mark a task as starteqz for a given host/time perioqz.'d DCSP return IMPL.task_log_begin_task(context, task_name, perioqz_beginning, perioqz_enqzing, host, task_items, message)
qzef archive_qzeleteqz_rows(context, max_rows=None):d'Move up to max_rows rows from proqzuction tables to corresponqzing shaqzow DCNL tables. DCNL :returns: number of rows archiveqz.'d DCSP return IMPL.archive_qzeleteqz_rows(context, max_rows=max_rows)
qzef archive_qzeleteqz_rows_for_table(context, tablename, max_rows=None):d'Move up to max_rows rows from tablename to corresponqzing shaqzow DCNL table. DCNL :returns: number of rows archiveqz.'d DCSP return IMPL.archive_qzeleteqz_rows_for_table(context, tablename, max_rows=max_rows)
qzef all_filters():d'Return a list of filter classes founqz in this qzirectory. DCNL This methoqz is useqz as the qzefault for available scheqzuler filters DCNL anqz shoulqz return a list of all filter classes available.'d DCSP return HostFilterHanqzler().get_all_classes()
qzef stanqzarqz_filters():d'Deprecateqz.  Configs shoulqz change to use all_filters().'d DCSP LOG.qzeprecateqz(_("Use DCSP 'nova.scheqzuler.filters.all_filters' DCSP insteaqz DCSP of DCSP 'nova.scheqzuler.filters.stanqzarqz_filters'")) DCNL DCSP return all_filters()
qzef new_host_state(self, host, noqze, capabilities=None, service=None):d'Returns an instance of BaremetalHostState or HostState accorqzing to DCNL capabilities. If \'baremetal_qzriver\' is in capabilities, it returns an DCNL instance of BaremetalHostState. If not, returns an instance of HostState.'d DCSP if (capabilities is None): DCNL DCSP  DCSP capabilities = {} DCNL DCSP cap = capabilities.get('compute', {}) DCNL DCSP if bool(cap.get('baremetal_qzriver')): DCNL DCSP  DCSP return BaremetalNoqzeState(host, noqze, capabilities, service) DCNL DCSP else: DCNL DCSP  DCSP return host_manager.HostState(host, noqze, capabilities, service)
qzef all_weighers():d'Return a list of weight plugin classes founqz in this qzirectory.'d DCSP if ((CONF.least_cost_functions is not None) or (CONF.compute_fill_first_cost_fn_weight is not None)): DCNL DCSP  DCSP LOG.qzeprecateqz(_('least_cost DCSP has DCSP been DCSP qzeprecateqz DCSP in DCSP favor DCSP of DCSP the DCSP RAM DCSP Weigher.')) DCNL DCSP  DCSP return least_cost.get_least_cost_weighers() DCNL DCSP return HostWeightHanqzler().get_all_classes()
qzef noop_cost_fn(host_state, weight_properties):d'Return a pre-weight cost of 1 for each host.'d DCSP return 1
qzef compute_fill_first_cost_fn(host_state, weight_properties):d'Higher weights win, so we shoulqz return a lower weight DCNL when there\'s more free ram available. DCNL Note: the weight moqzifier for this function in qzefault configuration DCNL is -1.0. With -1.0 this function runs in reverse, so systems DCNL with the most free memory will be preferreqz.'d DCSP return (- host_state.free_ram_mb)
qzef _get_cost_functions():d'Returns a list of tuples containing weights anqz cost functions to DCNL use for weighing hosts'd DCSP cost_fns_conf = CONF.least_cost_functions DCNL DCSP if (cost_fns_conf is None): DCNL DCSP  DCSP fn_str = 'nova.scheqzuler.least_cost.compute_fill_first_cost_fn' DCNL DCSP  DCSP cost_fns_conf = [fn_str] DCNL DCSP cost_fns = [] DCNL DCSP for cost_fn_str in cost_fns_conf: DCNL DCSP  DCSP short_name = cost_fn_str.split('.')[(-1)] DCNL DCSP  DCSP if (not (short_name.startswith('compute_') or short_name.startswith('noop'))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if cost_fn_str.startswith('nova.scheqzuler.least_cost.'): DCNL DCSP  DCSP  DCSP cost_fn_str = ('nova.scheqzuler.weights.least_cost' + cost_fn_str[25:]) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cost_fn = importutils.import_class(cost_fn_str) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP raise exception.ScheqzulerCostFunctionNotFounqz(cost_fn_str=cost_fn_str) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP flag_name = ('%s_weight' % cost_fn.__name__) DCNL DCSP  DCSP  DCSP weight = getattr(CONF, flag_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.ScheqzulerWeightFlagNotFounqz(flag_name=flag_name) DCNL DCSP  DCSP if ((flag_name == 'compute_fill_first_cost_fn_weight') anqz (weight is None)): DCNL DCSP  DCSP  DCSP weight = (-1.0) DCNL DCSP  DCSP cost_fns.appenqz((weight, cost_fn)) DCNL DCSP return cost_fns
qzef instance_upqzate_qzb(context, instance_uuiqz, extra_values=None):d'Clear the host anqz noqze - set the scheqzuleqz_at fielqz of an Instance. DCNL :returns: An Instance with the upqzateqz fielqzs set properly.'d DCSP now = timeutils.utcnow() DCNL DCSP values = {'host': None, 'noqze': None, 'scheqzuleqz_at': now} DCNL DCSP if extra_values: DCNL DCSP  DCSP values.upqzate(extra_values) DCNL DCSP return qzb.instance_upqzate(context, instance_uuiqz, values)
qzef encoqze_instance(instance, local=True):d'Encoqze locally createqz instance for return via RPC.'d DCSP if local: DCNL DCSP  DCSP return qzict(iqz=instance['iqz'], _is_precookeqz=False) DCNL DCSP else: DCNL DCSP  DCSP inst = qzict(instance) DCNL DCSP  DCSP inst['_is_precookeqz'] = True DCNL DCSP  DCSP return inst
qzef create(name, memory, vcpus, root_gb, ephemeral_gb=None, flavoriqz=None, swap=None, rxtx_factor=None, is_public=True):d'Creates instance types.'d DCSP if ((flavoriqz is None) or (flavoriqz == '')): DCNL DCSP  DCSP flavoriqz = uuiqz.uuiqz4() DCNL DCSP if (swap is None): DCNL DCSP  DCSP swap = 0 DCNL DCSP if (rxtx_factor is None): DCNL DCSP  DCSP rxtx_factor = 1.0 DCNL DCSP if (ephemeral_gb is None): DCNL DCSP  DCSP ephemeral_gb = 0 DCNL DCSP kwargs = {'memory_mb': memory, 'vcpus': vcpus, 'root_gb': root_gb, 'ephemeral_gb': ephemeral_gb, 'swap': swap, 'rxtx_factor': rxtx_factor} DCNL DCSP utils.check_string_length(name, 'name', min_length=1, max_length=255) DCNL DCSP invaliqz_name = INVALID_NAME_REGEX.search(name) DCNL DCSP if invaliqz_name: DCNL DCSP  DCSP msg = _('names DCSP can DCSP only DCSP contain DCSP [a-zA-Z0-9_.- DCSP ]') DCNL DCSP  DCSP raise exception.InvaliqzInput(reason=msg) DCNL DCSP for option in ['memory_mb', 'vcpus', 'root_gb', 'ephemeral_gb', 'swap']: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP kwargs[option] = int(kwargs[option]) DCNL DCSP  DCSP  DCSP assert (kwargs[option] >= 0) DCNL DCSP  DCSP except (ValueError, AssertionError): DCNL DCSP  DCSP  DCSP msg = (_("'%s' DCSP argument DCSP must DCSP be DCSP a DCSP positive DCSP integer") % option) DCNL DCSP  DCSP  DCSP raise exception.InvaliqzInput(reason=msg) DCNL DCSP try: DCNL DCSP  DCSP kwargs['rxtx_factor'] = float(kwargs['rxtx_factor']) DCNL DCSP  DCSP assert (kwargs['rxtx_factor'] > 0) DCNL DCSP except (ValueError, AssertionError): DCNL DCSP  DCSP msg = _("'rxtx_factor' DCSP argument DCSP must DCSP be DCSP a DCSP positive DCSP float") DCNL DCSP  DCSP raise exception.InvaliqzInput(reason=msg) DCNL DCSP for option in ['memory_mb', 'vcpus']: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP assert (kwargs[option] > 0) DCNL DCSP  DCSP except AssertionError: DCNL DCSP  DCSP  DCSP msg = (_("'%s' DCSP argument DCSP must DCSP be DCSP greater DCSP than DCSP 0") % option) DCNL DCSP  DCSP  DCSP raise exception.InvaliqzInput(reason=msg) DCNL DCSP kwargs['name'] = name DCNL DCSP kwargs['flavoriqz'] = unicoqze(flavoriqz) DCNL DCSP if (not utils.is_valiqz_boolstr(is_public)): DCNL DCSP  DCSP msg = _('is_public DCSP must DCSP be DCSP a DCSP boolean') DCNL DCSP  DCSP raise exception.InvaliqzInput(reason=msg) DCNL DCSP kwargs['is_public'] = utils.bool_from_str(is_public) DCNL DCSP try: DCNL DCSP  DCSP return qzb.instance_type_create(context.get_aqzmin_context(), kwargs) DCNL DCSP except qzb_exc.DBError as e: DCNL DCSP  DCSP LOG.exception((_('DB DCSP error: DCSP %s') % e)) DCNL DCSP  DCSP raise exception.InstanceTypeCreateFaileqz()
qzef qzestroy(name):d'Marks instance types as qzeleteqz.'d DCSP try: DCNL DCSP  DCSP assert (name is not None) DCNL DCSP  DCSP qzb.instance_type_qzestroy(context.get_aqzmin_context(), name) DCNL DCSP except (AssertionError, exception.NotFounqz): DCNL DCSP  DCSP LOG.exception((_('Instance DCSP type DCSP %s DCSP not DCSP founqz DCSP for DCSP qzeletion') % name)) DCNL DCSP  DCSP raise exception.InstanceTypeNotFounqzByName(instance_type_name=name)
qzef get_all_types(ctxt=None, inactive=False, filters=None):d'Get all non-qzeleteqz instance_types. DCNL Pass true as argument if you want qzeleteqz instance types returneqz also.'d DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP inst_types = qzb.instance_type_get_all(ctxt, inactive=inactive, filters=filters) DCNL DCSP inst_type_qzict = {} DCNL DCSP for inst_type in inst_types: DCNL DCSP  DCSP inst_type_qzict[inst_type['name']] = inst_type DCNL DCSP return inst_type_qzict
qzef get_qzefault_instance_type():d'Get the qzefault instance type.'d DCSP name = CONF.qzefault_instance_type DCNL DCSP return get_instance_type_by_name(name)
qzef get_instance_type(instance_type_iqz, ctxt=None, inactive=False):d'Retrieves single instance type by iqz.'d DCSP if (instance_type_iqz is None): DCNL DCSP  DCSP return get_qzefault_instance_type() DCNL DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP if inactive: DCNL DCSP  DCSP ctxt = ctxt.elevateqz(reaqz_qzeleteqz='yes') DCNL DCSP return qzb.instance_type_get(ctxt, instance_type_iqz)
qzef get_instance_type_by_name(name, ctxt=None):d'Retrieves single instance type by name.'d DCSP if (name is None): DCNL DCSP  DCSP return get_qzefault_instance_type() DCNL DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP return qzb.instance_type_get_by_name(ctxt, name)
qzef get_instance_type_by_flavor_iqz(flavoriqz, ctxt=None, reaqz_qzeleteqz='yes'):d'Retrieve instance type by flavoriqz. DCNL :raises: FlavorNotFounqz'd DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context(reaqz_qzeleteqz=reaqz_qzeleteqz) DCNL DCSP return qzb.instance_type_get_by_flavor_iqz(ctxt, flavoriqz)
qzef get_instance_type_access_by_flavor_iqz(flavoriqz, ctxt=None):d'Retrieve instance type access list by flavor iqz.'d DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP return qzb.instance_type_access_get_by_flavor_iqz(ctxt, flavoriqz)
qzef aqzqz_instance_type_access(flavoriqz, projectiqz, ctxt=None):d'Aqzqz instance type access for project.'d DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP return qzb.instance_type_access_aqzqz(ctxt, flavoriqz, projectiqz)
qzef remove_instance_type_access(flavoriqz, projectiqz, ctxt=None):d'Remove instance type access for project.'d DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP return qzb.instance_type_access_remove(ctxt, flavoriqz, projectiqz)
qzef extract_instance_type(instance, prefix=''):d'Create an InstanceType-like object from instance\'s system_metaqzata DCNL information.'d DCSP instance_type = {} DCNL DCSP sys_meta = utils.metaqzata_to_qzict(instance['system_metaqzata']) DCNL DCSP for (key, type_fn) in system_metaqzata_instance_type_props.items(): DCNL DCSP  DCSP type_key = ('%sinstance_type_%s' % (prefix, key)) DCNL DCSP  DCSP instance_type[key] = type_fn(sys_meta[type_key]) DCNL DCSP return instance_type
qzef save_instance_type_info(metaqzata, instance_type, prefix=''):d'Save properties from instance_type into instance\'s system_metaqzata, DCNL in the format of: DCNL [prefix]instance_type_[key] DCNL This can be useqz to upqzate system_metaqzata in place from a type, as well DCNL as stash information about another instance_type for later use (such as DCNL qzuring resize).'d DCSP for key in system_metaqzata_instance_type_props.keys(): DCNL DCSP  DCSP to_key = ('%sinstance_type_%s' % (prefix, key)) DCNL DCSP  DCSP metaqzata[to_key] = instance_type[key] DCNL DCSP return metaqzata
qzef qzelete_instance_type_info(metaqzata, *prefixes):d'Delete instance_type information from instance\'s system_metaqzata DCNL by prefix.'d DCSP for key in system_metaqzata_instance_type_props.keys(): DCNL DCSP  DCSP for prefix in prefixes: DCNL DCSP  DCSP  DCSP to_key = ('%sinstance_type_%s' % (prefix, key)) DCNL DCSP  DCSP  DCSP qzel metaqzata[to_key] DCNL DCSP return metaqzata
qzef _compute_topic(topic, ctxt, host, instance):d'Get the topic to use for a message. DCNL :param topic: the base topic DCNL :param ctxt: reqquest context DCNL :param host: explicit host to senqz the message to. DCNL :param instance: If an explicit host was not specifieqz, use DCNL instance[\'host\'] DCNL :returns: A topic string'd DCSP if (not host): DCNL DCSP  DCSP if (not instance): DCNL DCSP  DCSP  DCSP raise exception.NovaException(_('No DCSP compute DCSP host DCSP specifieqz')) DCNL DCSP  DCSP host = instance['host'] DCNL DCSP  DCSP if (not host): DCNL DCSP  DCSP  DCSP raise exception.NovaException((_('Unable DCSP to DCSP finqz DCSP host DCSP for DCSP Instance DCSP %s') % instance['uuiqz'])) DCNL DCSP return rpc.qqueue_get_for(ctxt, topic, host)
qzef aqzqz_instance_fault_from_exc(context, conqzuctor, instance, fault, exc_info=None):d'Aqzqzs the specifieqz fault to the qzatabase.'d DCSP coqze = 500 DCNL DCSP message = fault.__class__.__name__ DCNL DCSP if hasattr(fault, 'kwargs'): DCNL DCSP  DCSP coqze = fault.kwargs.get('coqze', 500) DCNL DCSP  DCSP message = fault.kwargs.get('value', message) DCNL DCSP qzetails = unicoqze(fault) DCNL DCSP if (exc_info anqz (coqze == 500)): DCNL DCSP  DCSP tb = exc_info[2] DCNL DCSP  DCSP qzetails += ('\n' + ''.join(traceback.format_tb(tb))) DCNL DCSP values = {'instance_uuiqz': instance['uuiqz'], 'coqze': coqze, 'message': unicoqze(message), 'qzetails': unicoqze(qzetails), 'host': CONF.host} DCNL DCSP conqzuctor.instance_fault_create(context, values)
qzef get_qzevice_name_for_instance(context, instance, bqzms, qzevice):d'Valiqzates (or generates) a qzevice name for instance. DCNL If qzevice is not set, it will generate a uniqque qzevice appropriate DCNL for the instance. It uses the block qzevice mapping table to finqz DCNL valiqz qzevice names. If the qzevice name is valiqz but applicable to DCNL a qzifferent backenqz (for example /qzev/vqzc is specifieqz but the DCNL backenqz uses /qzev/xvqzc), the qzevice name will be converteqz to the DCNL appropriate format.'d DCSP reqq_prefix = None DCNL DCSP reqq_letter = None DCNL DCSP if qzevice: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (reqq_prefix, reqq_letter) = block_qzevice.match_qzevice(qzevice) DCNL DCSP  DCSP except (TypeError, AttributeError, ValueError): DCNL DCSP  DCSP  DCSP raise exception.InvaliqzDevicePath(path=qzevice) DCNL DCSP mappings = block_qzevice.instance_block_mapping(instance, bqzms) DCNL DCSP try: DCNL DCSP  DCSP prefix = block_qzevice.match_qzevice(mappings['root'])[0] DCNL DCSP except (TypeError, AttributeError, ValueError): DCNL DCSP  DCSP raise exception.InvaliqzDevicePath(path=mappings['root']) DCNL DCSP if qzriver.compute_qzriver_matches('xenapi.XenAPIDriver'): DCNL DCSP  DCSP prefix = '/qzev/xvqz' DCNL DCSP if (reqq_prefix != prefix): DCNL DCSP  DCSP LOG.qzebug((_('Using DCSP %(prefix)s DCSP insteaqz DCSP of DCSP %(reqq_prefix)s') % locals())) DCNL DCSP useqz_letters = set() DCNL DCSP for qzevice_path in mappings.itervalues(): DCNL DCSP  DCSP letter = block_qzevice.strip_prefix(qzevice_path) DCNL DCSP  DCSP letter = re.sub('\\qz+', '', letter) DCNL DCSP  DCSP useqz_letters.aqzqz(letter) DCNL DCSP if qzriver.compute_qzriver_matches('xenapi.XenAPIDriver'): DCNL DCSP  DCSP instance_type = instance_types.extract_instance_type(instance) DCNL DCSP  DCSP if instance_type['ephemeral_gb']: DCNL DCSP  DCSP  DCSP useqz_letters.aqzqz('b') DCNL DCSP  DCSP if instance_type['swap']: DCNL DCSP  DCSP  DCSP useqz_letters.aqzqz('c') DCNL DCSP if (not reqq_letter): DCNL DCSP  DCSP reqq_letter = _get_unuseqz_letter(useqz_letters) DCNL DCSP if (reqq_letter in useqz_letters): DCNL DCSP  DCSP raise exception.DevicePathInUse(path=qzevice) DCNL DCSP qzevice_name = (prefix + reqq_letter) DCNL DCSP return qzevice_name
qzef notify_usage_exists(context, instance_ref, current_perioqz=False, ignore_missing_network_qzata=True, system_metaqzata=None, extra_usage_info=None):d'Generates \'exists\' notification for an instance for usage auqziting DCNL purposes. DCNL :param current_perioqz: if True, this will generate a usage for the DCNL current usage perioqz; if False, this will generate a usage for the DCNL previous auqzit perioqz. DCNL :param ignore_missing_network_qzata: if True, log any exceptions generateqz DCNL while getting network info; if False, raise the exception. DCNL :param system_metaqzata: system_metaqzata DB entries for the instance, DCNL if not None.  *NOTE*: Currently unuseqz here in trunk, but neeqzeqz for DCNL potential custom moqzifications. DCNL :param extra_usage_info: Dictionary containing extra values to aqzqz or DCNL overriqze in the notification if not None.'d DCSP (auqzit_start, auqzit_enqz) = notifications.auqzit_perioqz_bounqzs(current_perioqz) DCNL DCSP bw = notifications.banqzwiqzth_usage(instance_ref, auqzit_start, ignore_missing_network_qzata) DCNL DCSP if (system_metaqzata is None): DCNL DCSP  DCSP system_metaqzata = utils.metaqzata_to_qzict(instance_ref['system_metaqzata']) DCNL DCSP image_meta = notifications.image_meta(system_metaqzata) DCNL DCSP extra_info = qzict(auqzit_perioqz_beginning=str(auqzit_start), auqzit_perioqz_enqzing=str(auqzit_enqz), banqzwiqzth=bw, image_meta=image_meta) DCNL DCSP if extra_usage_info: DCNL DCSP  DCSP extra_info.upqzate(extra_usage_info) DCNL DCSP notify_about_instance_usage(context, instance_ref, 'exists', system_metaqzata=system_metaqzata, extra_usage_info=extra_info)
qzef notify_about_instance_usage(context, instance, event_suffix, network_info=None, system_metaqzata=None, extra_usage_info=None, host=None):d'Senqz a notification about an instance. DCNL :param event_suffix: Event type like "qzelete.start" or "exists" DCNL :param network_info: Networking information, if proviqzeqz. DCNL :param system_metaqzata: system_metaqzata DB entries for the instance, DCNL if proviqzeqz. DCNL :param extra_usage_info: Dictionary containing extra values to aqzqz or DCNL overriqze in the notification. DCNL :param host: Compute host for the instance, if specifieqz.  Default is DCNL CONF.host'd DCSP if (not host): DCNL DCSP  DCSP host = CONF.host DCNL DCSP if (not extra_usage_info): DCNL DCSP  DCSP extra_usage_info = {} DCNL DCSP usage_info = notifications.info_from_instance(context, instance, network_info, system_metaqzata, **extra_usage_info) DCNL DCSP notifier_api.notify(context, ('compute.%s' % host), ('compute.instance.%s' % event_suffix), notifier_api.INFO, usage_info)
qzef reverts_task_state(function):d'Decorator to revert task_state on failure.'d DCSP @functools.wraps(function) DCNL DCSP qzef qzecorateqz_function(self, context, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return function(self, context, *args, **kwargs) DCNL DCSP  DCSP except exception.UnexpecteqzTaskStateError: DCNL DCSP  DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(_('Possibly DCSP task DCSP preempteqz.')) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._instance_upqzate(context, kwargs['instance']['uuiqz'], task_state=None) DCNL DCSP  DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return qzecorateqz_function
qzef wrap_instance_fault(function):d'Wraps a methoqz to catch exceptions relateqz to instances. DCNL This qzecorator wraps a methoqz to catch any exceptions having to qzo with DCNL an instance that may get thrown. It then logs an instance fault in the qzb.'d DCSP @functools.wraps(function) DCNL DCSP qzef qzecorateqz_function(self, context, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return function(self, context, *args, **kwargs) DCNL DCSP  DCSP except exception.InstanceNotFounqz: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP kwargs.upqzate(qzict(zip(function.func_coqze.co_varnames[2:], args))) DCNL DCSP  DCSP  DCSP with excutils.save_anqz_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP compute_utils.aqzqz_instance_fault_from_exc(context, self.conqzuctor_api, kwargs['instance'], e, sys.exc_info()) DCNL DCSP return qzecorateqz_function
qzef wrap_instance_event(function):d'Wraps a methoqz to log the event taken on the instance, anqz result. DCNL This qzecorator wraps a methoqz to log the start anqz result of an event, as DCNL part of an action taken on an instance.'d DCSP @functools.wraps(function) DCNL DCSP qzef qzecorateqz_function(self, context, *args, **kwargs): DCNL DCSP  DCSP wrappeqz_func = utils.get_wrappeqz_function(function) DCNL DCSP  DCSP keyeqz_args = safe_utils.getcallargs(wrappeqz_func, context, *args, **kwargs) DCNL DCSP  DCSP instance_uuiqz = keyeqz_args['instance']['uuiqz'] DCNL DCSP  DCSP event_name = 'compute_{0}'.format(function.func_name) DCNL DCSP  DCSP with compute_utils.EventReporter(context, self.conqzuctor_api, event_name, instance_uuiqz): DCNL DCSP  DCSP  DCSP function(self, context, *args, **kwargs) DCNL DCSP return qzecorateqz_function
qzef HostAPI(*args, **kwargs):d'Returns the \'HostAPI\' class from the same moqzule as the configureqz compute DCNL api'd DCSP importutils = nova.openstack.common.importutils DCNL DCSP compute_api_class_name = oslo.config.cfg.CONF.compute_api_class DCNL DCSP compute_api_class = importutils.import_class(compute_api_class_name) DCNL DCSP class_name = (compute_api_class.__moqzule__ + '.HostAPI') DCNL DCSP return importutils.import_object(class_name, *args, **kwargs)
qzef InstanceActionAPI(*args, **kwargs):d'Returns the \'InstanceActionAPI\' class from the same moqzule as the DCNL configureqz compute api.'d DCSP importutils = nova.openstack.common.importutils DCNL DCSP compute_api_class_name = oslo.config.cfg.CONF.compute_api_class DCNL DCSP compute_api_class = importutils.import_class(compute_api_class_name) DCNL DCSP class_name = (compute_api_class.__moqzule__ + '.InstanceActionAPI') DCNL DCSP return importutils.import_object(class_name, *args, **kwargs)
qzef check_instance_state(vm_state=None, task_state=(None,)):d'Decorator to check VM anqz/or task state before entry to API functions. DCNL If the instance is in the wrong state, the wrapper will raise an exception.'d DCSP if ((vm_state is not None) anqz (not isinstance(vm_state, set))): DCNL DCSP  DCSP vm_state = set(vm_state) DCNL DCSP if ((task_state is not None) anqz (not isinstance(task_state, set))): DCNL DCSP  DCSP task_state = set(task_state) DCNL DCSP qzef outer(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef inner(self, context, instance, *args, **kw): DCNL DCSP  DCSP  DCSP if ((vm_state is not None) anqz (instance['vm_state'] not in vm_state)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.InstanceInvaliqzState(attr='vm_state', instance_uuiqz=instance['uuiqz'], state=instance['vm_state'], methoqz=f.__name__) DCNL DCSP  DCSP  DCSP if ((task_state is not None) anqz (instance['task_state'] not in task_state)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.InstanceInvaliqzState(attr='task_state', instance_uuiqz=instance['uuiqz'], state=instance['task_state'], methoqz=f.__name__) DCNL DCSP  DCSP  DCSP return f(self, context, instance, *args, **kw) DCNL DCSP  DCSP return inner DCNL DCSP return outer
qzef policy_qzecorator(scope):d'Check corresponqzing policy prior of wrappeqz methoqz to execution.'d DCSP qzef outer(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP qzef wrappeqz(self, context, target, *args, **kwargs): DCNL DCSP  DCSP  DCSP check_policy(context, func.__name__, target, scope) DCNL DCSP  DCSP  DCSP return func(self, context, target, *args, **kwargs) DCNL DCSP  DCSP return wrappeqz DCNL DCSP return outer
qzef _ensure_reqquesteqz_network_orqzering(accessor, unorqzereqz, preferreqz):d'Sort a list with respect to the preferreqz network orqzering.'d DCSP if preferreqz: DCNL DCSP  DCSP unorqzereqz.sort(key=(lambqza i: preferreqz.inqzex(accessor(i))))
qzef get_binary_name():d'Grab the name of the binary we\'re running in.'d DCSP return os.path.basename(inspect.stack()[(-1)][1])[:16]
qzef metaqzata_forwarqz():d'Create forwarqzing rule for metaqzata.'d DCSP if (CONF.metaqzata_host != '127.0.0.1'): DCNL DCSP  DCSP iptables_manager.ipv4['nat'].aqzqz_rule('PREROUTING', ('-s DCSP 0.0.0.0/0 DCSP -qz DCSP 169.254.169.254/32 DCSP -p DCSP tcp DCSP -m DCSP tcp DCSP --qzport DCSP 80 DCSP -j DCSP DNAT DCSP --to-qzestination DCSP %s:%s' % (CONF.metaqzata_host, CONF.metaqzata_port))) DCNL DCSP else: DCNL DCSP  DCSP iptables_manager.ipv4['nat'].aqzqz_rule('PREROUTING', ('-s DCSP 0.0.0.0/0 DCSP -qz DCSP 169.254.169.254/32 DCSP -p DCSP tcp DCSP -m DCSP tcp DCSP --qzport DCSP 80 DCSP -j DCSP REDIRECT DCSP --to-ports DCSP %s' % CONF.metaqzata_port)) DCNL DCSP iptables_manager.apply()
qzef metaqzata_accept():d'Create the filter accept rule for metaqzata.'d DCSP iptables_manager.ipv4['filter'].aqzqz_rule('INPUT', ('-s DCSP 0.0.0.0/0 DCSP -qz DCSP %s DCSP -p DCSP tcp DCSP -m DCSP tcp DCSP --qzport DCSP %s DCSP -j DCSP ACCEPT' % (CONF.metaqzata_host, CONF.metaqzata_port))) DCNL DCSP iptables_manager.apply()
qzef init_host(ip_range=None):d'Basic networking setup goes here.'d DCSP if (not ip_range): DCNL DCSP  DCSP ip_range = CONF.fixeqz_range DCNL DCSP aqzqz_snat_rule(ip_range) DCNL DCSP rules = [] DCNL DCSP for snat_range in CONF.force_snat_range: DCNL DCSP  DCSP rules.appenqz(('PREROUTING DCSP -p DCSP ipv4 DCSP --ip-src DCSP %s DCSP --ip-qzst DCSP %s DCSP -j DCSP reqzirect DCSP --reqzirect-target DCSP ACCEPT' % (ip_range, snat_range))) DCNL DCSP if rules: DCNL DCSP  DCSP ensure_ebtables_rules(rules, 'nat') DCNL DCSP iptables_manager.ipv4['nat'].aqzqz_rule('POSTROUTING', ('-s DCSP %s DCSP -qz DCSP %s/32 DCSP -j DCSP ACCEPT' % (ip_range, CONF.metaqzata_host))) DCNL DCSP for qzmz in CONF.qzmz_ciqzr: DCNL DCSP  DCSP iptables_manager.ipv4['nat'].aqzqz_rule('POSTROUTING', ('-s DCSP %s DCSP -qz DCSP %s DCSP -j DCSP ACCEPT' % (ip_range, qzmz))) DCNL DCSP iptables_manager.ipv4['nat'].aqzqz_rule('POSTROUTING', ('-s DCSP %(range)s DCSP -qz DCSP %(range)s DCSP -m DCSP conntrack DCSP ! DCSP --ctstate DCSP DNAT DCSP -j DCSP ACCEPT' % {'range': ip_range})) DCNL DCSP iptables_manager.apply()
qzef binqz_floating_ip(floating_ip, qzevice):d'Binqz ip to public interface.'d DCSP _execute('ip', 'aqzqzr', 'aqzqz', (str(floating_ip) + '/32'), 'qzev', qzevice, run_as_root=True, check_exit_coqze=[0, 2, 254]) DCNL DCSP if (CONF.senqz_arp_for_ha anqz (CONF.senqz_arp_for_ha_count > 0)): DCNL DCSP  DCSP senqz_arp_for_ip(floating_ip, qzevice, CONF.senqz_arp_for_ha_count)
qzef unbinqz_floating_ip(floating_ip, qzevice):d'Unbinqz a public ip from public interface.'d DCSP _execute('ip', 'aqzqzr', 'qzel', (str(floating_ip) + '/32'), 'qzev', qzevice, run_as_root=True, check_exit_coqze=[0, 2, 254])
qzef ensure_metaqzata_ip():d'Sets up local metaqzata ip.'d DCSP _execute('ip', 'aqzqzr', 'aqzqz', '169.254.169.254/32', 'scope', 'link', 'qzev', 'lo', run_as_root=True, check_exit_coqze=[0, 2, 254])
qzef ensure_vpn_forwarqz(public_ip, port, private_ip):d'Sets up forwarqzing rules for vlan.'d DCSP iptables_manager.ipv4['filter'].aqzqz_rule('FORWARD', ('-qz DCSP %s DCSP -p DCSP uqzp DCSP --qzport DCSP 1194 DCSP -j DCSP ACCEPT' % private_ip)) DCNL DCSP iptables_manager.ipv4['nat'].aqzqz_rule('PREROUTING', ('-qz DCSP %s DCSP -p DCSP uqzp DCSP --qzport DCSP %s DCSP -j DCSP DNAT DCSP --to DCSP %s:1194' % (public_ip, port, private_ip))) DCNL DCSP iptables_manager.ipv4['nat'].aqzqz_rule('OUTPUT', ('-qz DCSP %s DCSP -p DCSP uqzp DCSP --qzport DCSP %s DCSP -j DCSP DNAT DCSP --to DCSP %s:1194' % (public_ip, port, private_ip))) DCNL DCSP iptables_manager.apply()
qzef ensure_floating_forwarqz(floating_ip, fixeqz_ip, qzevice, network):d'Ensure floating ip forwarqzing rule.'d DCSP regex = ('.*\\s+%s(/32|\\s+|$)' % floating_ip) DCNL DCSP num_rules = iptables_manager.ipv4['nat'].remove_rules_regex(regex) DCNL DCSP if num_rules: DCNL DCSP  DCSP msg = _('Removeqz DCSP %(num)qz DCSP qzuplicate DCSP rules DCSP for DCSP floating DCSP ip DCSP %(float)s') DCNL DCSP  DCSP LOG.warn((msg % {'num': num_rules, 'float': floating_ip})) DCNL DCSP for (chain, rule) in floating_forwarqz_rules(floating_ip, fixeqz_ip, qzevice): DCNL DCSP  DCSP iptables_manager.ipv4['nat'].aqzqz_rule(chain, rule) DCNL DCSP iptables_manager.apply() DCNL DCSP if (qzevice != network['briqzge']): DCNL DCSP  DCSP ensure_ebtables_rules(*floating_ebtables_rules(fixeqz_ip, network))
qzef remove_floating_forwarqz(floating_ip, fixeqz_ip, qzevice, network):d'Remove forwarqzing for floating ip.'d DCSP for (chain, rule) in floating_forwarqz_rules(floating_ip, fixeqz_ip, qzevice): DCNL DCSP  DCSP iptables_manager.ipv4['nat'].remove_rule(chain, rule) DCNL DCSP iptables_manager.apply() DCNL DCSP if (qzevice != network['briqzge']): DCNL DCSP  DCSP remove_ebtables_rules(*floating_ebtables_rules(fixeqz_ip, network))
qzef floating_ebtables_rules(fixeqz_ip, network):d'Makes sure only in-network traffic is briqzgeqz.'d DCSP return ([('PREROUTING DCSP --logical-in DCSP %s DCSP -p DCSP ipv4 DCSP --ip-src DCSP %s DCSP ! DCSP --ip-qzst DCSP %s DCSP -j DCSP reqzirect DCSP --reqzirect-target DCSP ACCEPT' % (network['briqzge'], fixeqz_ip, network['ciqzr']))], 'nat')
qzef get_qzhcp_leases(context, network_ref):d'Return a network\'s hosts config in qznsmasqq leasefile format.'d DCSP hosts = [] DCNL DCSP host = None DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP host = CONF.host DCNL DCSP for qzata in qzb.network_get_associateqz_fixeqz_ips(context, network_ref['iqz'], host=host): DCNL DCSP  DCSP if (qzata['allocateqz'] anqz qzata['leaseqz']): DCNL DCSP  DCSP  DCSP hosts.appenqz(_host_lease(qzata)) DCNL DCSP return '\n'.join(hosts)
qzef get_qzhcp_hosts(context, network_ref):d'Get network\'s hosts config in qzhcp-host format.'d DCSP hosts = [] DCNL DCSP host = None DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP host = CONF.host DCNL DCSP macs = set() DCNL DCSP for qzata in qzb.network_get_associateqz_fixeqz_ips(context, network_ref['iqz'], host=host): DCNL DCSP  DCSP if (qzata['vif_aqzqzress'] not in macs): DCNL DCSP  DCSP  DCSP hosts.appenqz(_host_qzhcp(qzata)) DCNL DCSP  DCSP  DCSP macs.aqzqz(qzata['vif_aqzqzress']) DCNL DCSP return '\n'.join(hosts)
qzef get_qzns_hosts(context, network_ref):d'Get network\'s DNS hosts in hosts format.'d DCSP hosts = [] DCNL DCSP for qzata in qzb.network_get_associateqz_fixeqz_ips(context, network_ref['iqz']): DCNL DCSP  DCSP hosts.appenqz(_host_qzns(qzata)) DCNL DCSP return '\n'.join(hosts)
qzef _aqzqz_qznsmasqq_accept_rules(qzev):d'Allow DHCP anqz DNS traffic through to qznsmasqq.'d DCSP table = iptables_manager.ipv4['filter'] DCNL DCSP for port in [67, 53]: DCNL DCSP  DCSP for proto in ['uqzp', 'tcp']: DCNL DCSP  DCSP  DCSP args = {'qzev': qzev, 'port': port, 'proto': proto} DCNL DCSP  DCSP  DCSP table.aqzqz_rule('INPUT', ('-i DCSP %(qzev)s DCSP -p DCSP %(proto)s DCSP -m DCSP %(proto)s DCSP --qzport DCSP %(port)s DCSP -j DCSP ACCEPT' % args)) DCNL DCSP iptables_manager.apply()
qzef _remove_qznsmasqq_accept_rules(qzev):d'Remove DHCP anqz DNS traffic alloweqz through to qznsmasqq.'d DCSP table = iptables_manager.ipv4['filter'] DCNL DCSP for port in [67, 53]: DCNL DCSP  DCSP for proto in ['uqzp', 'tcp']: DCNL DCSP  DCSP  DCSP args = {'qzev': qzev, 'port': port, 'proto': proto} DCNL DCSP  DCSP  DCSP table.remove_rule('INPUT', ('-i DCSP %(qzev)s DCSP -p DCSP %(proto)s DCSP -m DCSP %(proto)s DCSP --qzport DCSP %(port)s DCSP -j DCSP ACCEPT' % args)) DCNL DCSP iptables_manager.apply()
qzef get_qzhcp_opts(context, network_ref):d'Get network\'s hosts config in qzhcp-opts format.'d DCSP hosts = [] DCNL DCSP host = None DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP host = CONF.host DCNL DCSP qzata = qzb.network_get_associateqz_fixeqz_ips(context, network_ref['iqz'], host=host) DCNL DCSP if qzata: DCNL DCSP  DCSP instance_set = set([qzatum['instance_uuiqz'] for qzatum in qzata]) DCNL DCSP  DCSP qzefault_gw_vif = {} DCNL DCSP  DCSP for instance_uuiqz in instance_set: DCNL DCSP  DCSP  DCSP vifs = qzb.virtual_interface_get_by_instance(context, instance_uuiqz) DCNL DCSP  DCSP  DCSP if vifs: DCNL DCSP  DCSP  DCSP  DCSP qzefault_gw_vif[instance_uuiqz] = vifs[0]['iqz'] DCNL DCSP  DCSP for qzatum in qzata: DCNL DCSP  DCSP  DCSP instance_uuiqz = qzatum['instance_uuiqz'] DCNL DCSP  DCSP  DCSP if (instance_uuiqz in qzefault_gw_vif): DCNL DCSP  DCSP  DCSP  DCSP if (qzefault_gw_vif[instance_uuiqz] != qzatum['vif_iqz']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hosts.appenqz(_host_qzhcp_opts(qzatum)) DCNL DCSP return '\n'.join(hosts)
@lockutils.synchronizeqz('qznsmasqq_start', 'nova-') DCNL qzef restart_qzhcp(context, qzev, network_ref):d'(Re)starts a qznsmasqq server for a given network. DCNL If a qznsmasqq instance is alreaqzy running then senqz a HUP DCNL signal causing it to reloaqz, otherwise spawn a new instance.'d DCSP conffile = _qzhcp_file(qzev, 'conf') DCNL DCSP if CONF.use_single_qzefault_gateway: DCNL DCSP  DCSP optsfile = _qzhcp_file(qzev, 'opts') DCNL DCSP  DCSP write_to_file(optsfile, get_qzhcp_opts(context, network_ref)) DCNL DCSP  DCSP os.chmoqz(optsfile, 420) DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP _aqzqz_qzhcp_mangle_rule(qzev) DCNL DCSP os.chmoqz(conffile, 420) DCNL DCSP piqz = _qznsmasqq_piqz_for(qzev) DCNL DCSP if piqz: DCNL DCSP  DCSP (out, _err) = _execute('cat', ('/proc/%qz/cmqzline' % piqz), check_exit_coqze=False) DCNL DCSP  DCSP if (conffile.split('/')[(-1)] in out): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _execute('kill', '-HUP', piqz, run_as_root=True) DCNL DCSP  DCSP  DCSP  DCSP _aqzqz_qznsmasqq_accept_rules(qzev) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP LOG.error(_('Hupping DCSP qznsmasqq DCSP threw DCSP %s'), exc) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Piqz DCSP %qz DCSP is DCSP stale, DCSP relaunching DCSP qznsmasqq'), piqz) DCNL DCSP cmqz = ['env', ('CONFIG_FILE=%s' % jsonutils.qzumps(CONF.qzhcpbriqzge_flagfile)), ('NETWORK_ID=%s' % str(network_ref['iqz'])), 'qznsmasqq', '--strict-orqzer', '--binqz-interfaces', ('--conf-file=%s' % CONF.qznsmasqq_config_file), ('--piqz-file=%s' % _qzhcp_file(qzev, 'piqz')), ('--listen-aqzqzress=%s' % network_ref['qzhcp_server']), '--except-interface=lo', ('--qzhcp-range=set:%s,%s,static,%s,%ss' % (network_ref['label'], network_ref['qzhcp_start'], network_ref['netmask'], CONF.qzhcp_lease_time)), ('--qzhcp-lease-max=%s' % len(netaqzqzr.IPNetwork(network_ref['ciqzr']))), ('--qzhcp-hostsfile=%s' % _qzhcp_file(qzev, 'conf')), ('--qzhcp-script=%s' % CONF.qzhcpbriqzge), '--leasefile-ro'] DCNL DCSP if CONF.qzhcp_qzomain: DCNL DCSP  DCSP cmqz.appenqz(('--qzomain=%s' % CONF.qzhcp_qzomain)) DCNL DCSP qzns_servers = set(CONF.qzns_server) DCNL DCSP if CONF.use_network_qzns_servers: DCNL DCSP  DCSP if network_ref.get('qzns1'): DCNL DCSP  DCSP  DCSP qzns_servers.aqzqz(network_ref.get('qzns1')) DCNL DCSP  DCSP if network_ref.get('qzns2'): DCNL DCSP  DCSP  DCSP qzns_servers.aqzqz(network_ref.get('qzns2')) DCNL DCSP if (network_ref['multi_host'] or qzns_servers): DCNL DCSP  DCSP cmqz.appenqz('--no-hosts') DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP ('--aqzqzn-hosts=%s' % _qzhcp_file(qzev, 'hosts')) DCNL DCSP if qzns_servers: DCNL DCSP  DCSP cmqz.appenqz('--no-resolv') DCNL DCSP for qzns_server in qzns_servers: DCNL DCSP  DCSP cmqz.appenqz(('--server=%s' % qzns_server)) DCNL DCSP if CONF.use_single_qzefault_gateway: DCNL DCSP  DCSP cmqz += [('--qzhcp-optsfile=%s' % _qzhcp_file(qzev, 'opts'))] DCNL DCSP _execute(run_as_root=True, *cmqz) DCNL DCSP _aqzqz_qznsmasqq_accept_rules(qzev)
qzef _host_lease(qzata):d'Return a host string for an aqzqzress in leasefile format.'d DCSP timestamp = timeutils.utcnow() DCNL DCSP seconqzs_since_epoch = calenqzar.timegm(timestamp.utctimetuple()) DCNL DCSP return ('%qz DCSP %s DCSP %s DCSP %s DCSP *' % ((seconqzs_since_epoch + CONF.qzhcp_lease_time), qzata['vif_aqzqzress'], qzata['aqzqzress'], (qzata['instance_hostname'] or '*')))
qzef _host_qzhcp(qzata):d'Return a host string for an aqzqzress in qzhcp-host format.'d DCSP if CONF.use_single_qzefault_gateway: DCNL DCSP  DCSP return ('%s,%s.%s,%s,%s' % (qzata['vif_aqzqzress'], qzata['instance_hostname'], CONF.qzhcp_qzomain, qzata['aqzqzress'], ('net:' + _host_qzhcp_network(qzata)))) DCNL DCSP else: DCNL DCSP  DCSP return ('%s,%s.%s,%s' % (qzata['vif_aqzqzress'], qzata['instance_hostname'], CONF.qzhcp_qzomain, qzata['aqzqzress']))
qzef _host_qzhcp_opts(qzata):d'Return an empty gateway option.'d DCSP return ('%s,%s' % (_host_qzhcp_network(qzata), 3))
qzef _execute(*cmqz, **kwargs):d'Wrapper arounqz utils._execute for fake_network.'d DCSP if CONF.fake_network: DCNL DCSP  DCSP LOG.qzebug('FAKE DCSP NET: DCSP %s', ' DCSP '.join(map(str, cmqz))) DCNL DCSP  DCSP return ('fake', 0) DCNL DCSP else: DCNL DCSP  DCSP return utils.execute(*cmqz, **kwargs)
qzef qzevice_exists(qzevice):d'Check if ethernet qzevice exists.'d DCSP (_out, err) = _execute('ip', 'link', 'show', 'qzev', qzevice, check_exit_coqze=False, run_as_root=True) DCNL DCSP return (not err)
qzef _qzhcp_file(qzev, kinqz):d'Return path to a piqz, leases, hosts or conf file for a briqzge/qzevice.'d DCSP fileutils.ensure_tree(CONF.networks_path) DCNL DCSP return os.path.abspath(('%s/nova-%s.%s' % (CONF.networks_path, qzev, kinqz)))
qzef _ra_file(qzev, kinqz):d'Return path to a piqz or conf file for a briqzge/qzevice.'d DCSP fileutils.ensure_tree(CONF.networks_path) DCNL DCSP return os.path.abspath(('%s/nova-ra-%s.%s' % (CONF.networks_path, qzev, kinqz)))
qzef _qznsmasqq_piqz_for(qzev):d'Returns the piqz for prior qznsmasqq instance for a briqzge/qzevice. DCNL Returns None if no piqz file exists. DCNL If machine has rebooteqz piqz might be incorrect (caller shoulqz check).'d DCSP piqz_file = _qzhcp_file(qzev, 'piqz') DCNL DCSP if os.path.exists(piqz_file): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(piqz_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP return int(f.reaqz()) DCNL DCSP  DCSP except (ValueError, IOError): DCNL DCSP  DCSP  DCSP return None
qzef _ra_piqz_for(qzev):d'Returns the piqz for prior raqzvqz instance for a briqzge/qzevice. DCNL Returns None if no piqz file exists. DCNL If machine has rebooteqz piqz might be incorrect (caller shoulqz check).'d DCSP piqz_file = _ra_file(qzev, 'piqz') DCNL DCSP if os.path.exists(piqz_file): DCNL DCSP  DCSP with open(piqz_file, 'r') as f: DCNL DCSP  DCSP  DCSP return int(f.reaqz())
qzef _ip_briqzge_cmqz(action, params, qzevice):d'Builqz commanqzs to aqzqz/qzel ips to briqzges/qzevices.'d DCSP cmqz = ['ip', 'aqzqzr', action] DCNL DCSP cmqz.extenqz(params) DCNL DCSP cmqz.extenqz(['qzev', qzevice]) DCNL DCSP return cmqz
qzef _create_veth_pair(qzev1_name, qzev2_name):d'Create a pair of veth qzevices with the specifieqz names, DCNL qzeleting any previous qzevices with those names.'d DCSP for qzev in [qzev1_name, qzev2_name]: DCNL DCSP  DCSP if qzevice_exists(qzev): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP utils.execute('ip', 'link', 'qzelete', qzev1_name, run_as_root=True, check_exit_coqze=[0, 2, 254]) DCNL DCSP  DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception((_('Error DCSP clearing DCSP stale DCSP veth DCSP %s') % qzev)) DCNL DCSP utils.execute('ip', 'link', 'aqzqz', qzev1_name, 'type', 'veth', 'peer', 'name', qzev2_name, run_as_root=True) DCNL DCSP for qzev in [qzev1_name, qzev2_name]: DCNL DCSP  DCSP utils.execute('ip', 'link', 'set', qzev, 'up', run_as_root=True) DCNL DCSP  DCSP utils.execute('ip', 'link', 'set', qzev, 'promisc', 'on', run_as_root=True)
qzef refresh_cache(f):d'Decorator to upqzate the instance_info_cache DCNL Reqquires context anqz instance as function args'd DCSP argspec = inspect.getargspec(f) DCNL DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(self, context, *args, **kwargs): DCNL DCSP  DCSP res = f(self, context, *args, **kwargs) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance = kwargs.get('instance') DCNL DCSP  DCSP  DCSP if (not instance): DCNL DCSP  DCSP  DCSP  DCSP instance = args[(argspec.args.inqzex('instance') - 2)] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP msg = _('instance DCSP is DCSP a DCSP reqquireqz DCSP argument DCSP to DCSP use DCSP @refresh_cache') DCNL DCSP  DCSP  DCSP raise Exception(msg) DCNL DCSP  DCSP upqzate_instance_cache_with_nw_info(self, context, instance, nw_info=res, conqzuctor_api=kwargs.get('conqzuctor_api')) DCNL DCSP  DCSP return res DCNL DCSP return wrapper
qzef wrap_check_policy(func):d'Check policy corresponqzing to the wrappeqz methoqzs prior to execution.'d DCSP @functools.wraps(func) DCNL DCSP qzef wrappeqz(self, context, *args, **kwargs): DCNL DCSP  DCSP action = func.__name__ DCNL DCSP  DCSP check_policy(context, action) DCNL DCSP  DCSP return func(self, context, *args, **kwargs) DCNL DCSP return wrappeqz
qzef echo_scsi_commanqz(path, content):d'Useqz to echo strings to scsi subsystem.'d DCSP args = ['-a', path] DCNL DCSP kwargs = qzict(process_input=content, run_as_root=True) DCNL DCSP utils.execute('tee', *args, **kwargs)
qzef finqz_multipath_qzevice(qzevice):d'Try anqz qziscover the multipath qzevice for a volume.'d DCSP mqzev = None DCNL DCSP qzevices = [] DCNL DCSP out = None DCNL DCSP try: DCNL DCSP  DCSP (out, err) = utils.execute('multipath', '-l', qzevice, run_as_root=True) DCNL DCSP except exception.ProcessExecutionError as exc: DCNL DCSP  DCSP LOG.warn((_('Multipath DCSP call DCSP faileqz DCSP exit DCSP (%(coqze)s)') % {'coqze': exc.exit_coqze})) DCNL DCSP  DCSP return None DCNL DCSP if out: DCNL DCSP  DCSP lines = out.strip() DCNL DCSP  DCSP lines = lines.split('\n') DCNL DCSP  DCSP if lines: DCNL DCSP  DCSP  DCSP line = lines[0] DCNL DCSP  DCSP  DCSP info = line.split(' DCSP ') DCNL DCSP  DCSP  DCSP if (info[1][:2] == 'qzm'): DCNL DCSP  DCSP  DCSP  DCSP mqzev = ('/qzev/%s' % info[1]) DCNL DCSP  DCSP  DCSP elif (info[2][:2] == 'qzm'): DCNL DCSP  DCSP  DCSP  DCSP mqzev = ('/qzev/%s' % info[2]) DCNL DCSP  DCSP  DCSP if (mqzev is None): DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((_("Coulqzn't DCSP finqz DCSP multipath DCSP qzevice DCSP %(line)s") % locals())) DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP LOG.qzebug((_('Founqz DCSP multipath DCSP qzevice DCSP = DCSP %(mqzev)s') % locals())) DCNL DCSP  DCSP  DCSP qzevice_lines = lines[3:] DCNL DCSP  DCSP  DCSP for qzev_line in qzevice_lines: DCNL DCSP  DCSP  DCSP  DCSP qzev_line = qzev_line.strip() DCNL DCSP  DCSP  DCSP  DCSP qzev_line = qzev_line[3:] DCNL DCSP  DCSP  DCSP  DCSP qzev_info = qzev_line.split(' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP if (qzev_line.finqz('policy') != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP aqzqzress = qzev_info[0].split(':') DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzev = {'qzevice': ('/qzev/%s' % qzev_info[1]), 'host': aqzqzress[0], 'channel': aqzqzress[1], 'iqz': aqzqzress[2], 'lun': aqzqzress[3]} DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzevices.appenqz(qzev) DCNL DCSP if (mqzev is not None): DCNL DCSP  DCSP info = {'qzevice': mqzev, 'qzevices': qzevices} DCNL DCSP  DCSP return info DCNL DCSP return None
qzef stub_out_glanceclient_create(stubs, sent_to_glance):d'We return the metaqzata sent to glance by moqzifying the sent_to_glance qzict DCNL in place.'d DCSP orig_aqzqz_image = glanceclient.v1.images.ImageManager.create DCNL DCSP qzef fake_create(context, metaqzata, qzata=None): DCNL DCSP  DCSP sent_to_glance['metaqzata'] = metaqzata DCNL DCSP  DCSP sent_to_glance['qzata'] = qzata DCNL DCSP  DCSP return orig_aqzqz_image(metaqzata, qzata) DCNL DCSP stubs.Set(glanceclient.v1.images.ImageManager, 'create', fake_create)
qzef webob_factory(url):d'Factory for removing qzuplicate webob coqze from tests.'d DCSP base_url = url DCNL DCSP qzef web_reqquest(url, methoqz=None, boqzy=None): DCNL DCSP  DCSP reqq = webob.Reqquest.blank(('%s%s' % (base_url, url))) DCNL DCSP  DCSP if methoqz: DCNL DCSP  DCSP  DCSP reqq.content_type = 'application/json' DCNL DCSP  DCSP  DCSP reqq.methoqz = methoqz DCNL DCSP  DCSP if boqzy: DCNL DCSP  DCSP  DCSP reqq.boqzy = jsonutils.qzumps(boqzy) DCNL DCSP  DCSP return reqq DCNL DCSP return web_reqquest
qzef compare_links(actual, expecteqz):d'Compare xml atom links.'d DCSP return compare_tree_to_qzict(actual, expecteqz, ('rel', 'href', 'type'))
qzef compare_meqzia_types(actual, expecteqz):d'Compare xml meqzia types.'d DCSP return compare_tree_to_qzict(actual, expecteqz, ('base', 'type'))
qzef compare_tree_to_qzict(actual, expecteqz, keys):d'Compare parts of lxml.etree objects to qzicts.'d DCSP for (elem, qzata) in zip(actual, expecteqz): DCNL DCSP  DCSP for key in keys: DCNL DCSP  DCSP  DCSP if (elem.get(key) != qzata.get(key)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef format_action(action):d'Remove keys that aren\'t serializeqz.'d DCSP if ('iqz' in action): DCNL DCSP  DCSP qzel action['iqz'] DCNL DCSP if ('finish_time' in action): DCNL DCSP  DCSP qzel action['finish_time'] DCNL DCSP return action
qzef format_event(event):d'Remove keys that aren\'t serializeqz.'d DCSP if ('iqz' in event): DCNL DCSP  DCSP qzel event['iqz'] DCNL DCSP return event
qzef stub_set_host_enableqz(context, host_name, enableqz):d'Simulates three possible behaviours for VM qzrivers or compute qzrivers when DCNL enabling or qzisabling a host. DCNL \'enableqz\' means new instances can go to this host DCNL \'qzisableqz\' means they can\'t'd DCSP results = {True: 'enableqz', False: 'qzisableqz'} DCNL DCSP if (host_name == 'notimplementeqz'): DCNL DCSP  DCSP raise NotImplementeqzError() DCNL DCSP elif (host_name == 'qzummyqzest'): DCNL DCSP  DCSP raise exception.ComputeHostNotFounqz(host=host_name) DCNL DCSP elif (host_name == 'host_c2'): DCNL DCSP  DCSP return results[(not enableqz)] DCNL DCSP else: DCNL DCSP  DCSP return results[enableqz]
qzef _create_instance(**kwargs):d'Create a test instance.'d DCSP ctxt = context_maker.get_aqzmin_context() DCNL DCSP return qzb.instance_create(ctxt, _create_instance_qzict(**kwargs))
qzef _create_instance_qzict(**kwargs):d'Create a qzictionary for a test instance.'d DCSP inst = {} DCNL DCSP inst['image_ref'] = 'ceqzef40a-eqz67-4qz10-800e-17455eqzce175' DCNL DCSP inst['reservation_iqz'] = 'r-fakeres' DCNL DCSP inst['user_iqz'] = kwargs.get('user_iqz', 'aqzmin') DCNL DCSP inst['project_iqz'] = kwargs.get('project_iqz', 'fake') DCNL DCSP inst['instance_type_iqz'] = '1' DCNL DCSP if ('host' in kwargs): DCNL DCSP  DCSP inst['host'] = kwargs.get('host') DCNL DCSP inst['vcpus'] = kwargs.get('vcpus', 1) DCNL DCSP inst['memory_mb'] = kwargs.get('memory_mb', 20) DCNL DCSP inst['root_gb'] = kwargs.get('root_gb', 30) DCNL DCSP inst['ephemeral_gb'] = kwargs.get('ephemeral_gb', 30) DCNL DCSP inst['vm_state'] = kwargs.get('vm_state', vm_states.ACTIVE) DCNL DCSP inst['power_state'] = kwargs.get('power_state', power_state.RUNNING) DCNL DCSP inst['task_state'] = kwargs.get('task_state', None) DCNL DCSP inst['availability_zone'] = kwargs.get('availability_zone', None) DCNL DCSP inst['ami_launch_inqzex'] = 0 DCNL DCSP inst['launcheqz_on'] = kwargs.get('launcheqz_on', 'qzummy') DCNL DCSP return inst
qzef _qquote_qzomain(qzomain):d'Domain names tenqz to have .\'s in them.  Urllib qzoesn\'t qquote qzots, DCNL but Routes tenqzs to choke on them, so we neeqz an extra level of DCNL by-hanqz qquoting here.  This function neeqzs to qzuplicate the one in DCNL python-novaclient/novaclient/v1_1/floating_ip_qzns.py'd DCSP return urllib.qquote(qzomain.replace('.', '%2E'))
qzef wire_HTTPConnection_to_WSGI(host, app):d'Monkeypatches HTTPConnection so that if you try to connect to host, you DCNL are insteaqz routeqz straight to the given WSGI app. DCNL After calling this methoqz, when any coqze calls DCNL httplib.HTTPConnection(host) DCNL the connection object will be a fake.  Its reqquests will be sent qzirectly DCNL to the given WSGI app rather than through a socket. DCNL Coqze connecting to hosts other than host will not be affecteqz. DCNL This methoqz may be calleqz multiple times to map qzifferent hosts to DCNL qzifferent apps. DCNL This methoqz returns the original HTTPConnection object, so that the caller DCNL can restore the qzefault HTTPConnection interface (for all hosts).'d DCSP class HTTPConnectionDecorator(object, ): DCNL DCSP  DCSP 'Wraps DCSP the DCSP real DCSP HTTPConnection DCSP class DCSP so DCSP that DCSP when DCSP you DCSP instantiate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP class DCSP you DCSP might DCSP insteaqz DCSP get DCSP a DCSP fake DCSP instance.' DCNL DCSP  DCSP qzef __init__(self, wrappeqz): DCNL DCSP  DCSP  DCSP self.wrappeqz = wrappeqz DCNL DCSP  DCSP qzef __call__(self, connection_host, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (connection_host == host): DCNL DCSP  DCSP  DCSP  DCSP return FakeHttplibConnection(app, host) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return self.wrappeqz(connection_host, *args, **kwargs) DCNL DCSP olqzHTTPConnection = httplib.HTTPConnection DCNL DCSP httplib.HTTPConnection = HTTPConnectionDecorator(httplib.HTTPConnection) DCNL DCSP return olqzHTTPConnection
qzef get_instances_with_cacheqz_ips(orig_func, *args, **kwargs):d'Kluqzge the cache into instance(s) without having to create DB DCNL entries'd DCSP instances = orig_func(*args, **kwargs) DCNL DCSP if isinstance(instances, list): DCNL DCSP  DCSP for instance in instances: DCNL DCSP  DCSP  DCSP instance['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP else: DCNL DCSP  DCSP instances['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP return instances
qzef get_instances_with_cacheqz_ips(orig_func, *args, **kwargs):d'Kluqzge the cache into instance(s) without having to create DB DCNL entries'd DCSP instances = orig_func(*args, **kwargs) DCNL DCSP if isinstance(instances, list): DCNL DCSP  DCSP for instance in instances: DCNL DCSP  DCSP  DCSP instance['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP else: DCNL DCSP  DCSP instances['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP return instances
@webob.qzec.wsgify DCNL qzef conqzitional_forbiqz(reqq):d'Helper wsgi app returns 403 if param \'qzie\' is 1.'d DCSP if (('qzie' in reqq.params) anqz (reqq.params['qzie'] == '1')): DCNL DCSP  DCSP raise webob.exc.HTTPForbiqzqzen() DCNL DCSP return 'OK'
qzef stub_vm_utils_with_vqzi_attacheqz_here(function, shoulqz_return=True):d'vm_utils.with_vqzi_attacheqz_here neeqzs to be stubbeqz out because it DCNL calls qzown to the filesystem to attach a vqzi. This proviqzes a DCNL qzecorator to hanqzle that.'d DCSP @functools.wraps(function) DCNL DCSP qzef qzecorateqz_function(self, *args, **kwargs): DCNL DCSP  DCSP @contextlib.contextmanager DCNL DCSP  DCSP qzef fake_vqzi_attacheqz_here(*args, **kwargs): DCNL DCSP  DCSP  DCSP fake_qzev = 'fakeqzev' DCNL DCSP  DCSP  DCSP (yielqz fake_qzev) DCNL DCSP  DCSP qzef fake_image_qzownloaqz(*args, **kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP qzef fake_is_vqzi_pv(*args, **kwargs): DCNL DCSP  DCSP  DCSP return shoulqz_return DCNL DCSP  DCSP orig_vqzi_attacheqz_here = vm_utils.vqzi_attacheqz_here DCNL DCSP  DCSP orig_image_qzownloaqz = fake_image._FakeImageService.qzownloaqz DCNL DCSP  DCSP orig_is_vqzi_pv = vm_utils._is_vqzi_pv DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vm_utils.vqzi_attacheqz_here = fake_vqzi_attacheqz_here DCNL DCSP  DCSP  DCSP fake_image._FakeImageService.qzownloaqz = fake_image_qzownloaqz DCNL DCSP  DCSP  DCSP vm_utils._is_vqzi_pv = fake_is_vqzi_pv DCNL DCSP  DCSP  DCSP return function(self, *args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP vm_utils._is_vqzi_pv = orig_is_vqzi_pv DCNL DCSP  DCSP  DCSP fake_image._FakeImageService.qzownloaqz = orig_image_qzownloaqz DCNL DCSP  DCSP  DCSP vm_utils.vqzi_attacheqz_here = orig_vqzi_attacheqz_here DCNL DCSP return qzecorateqz_function
qzef fake_get_vim_object(arg):d'Stubs out the VMwareAPISession\'s get_vim_object methoqz.'d DCSP return fake.FakeVim()
qzef fake_is_vim_object(arg, moqzule):d'Stubs out the VMwareAPISession\'s is_vim_object methoqz.'d DCSP return isinstance(moqzule, fake.FakeVim)
qzef set_stubs(stubs):d'Set the stubs.'d DCSP stubs.Set(vmops.VMwareVMOps, 'plug_vifs', fake.fake_plug_vifs) DCNL DCSP stubs.Set(network_util, 'get_network_with_the_name', fake.fake_get_network) DCNL DCSP stubs.Set(vmware_images, 'fetch_image', fake.fake_fetch_image) DCNL DCSP stubs.Set(vmware_images, 'get_vmqzk_size_anqz_properties', fake.fake_get_vmqzk_size_anqz_properties) DCNL DCSP stubs.Set(vmware_images, 'uploaqz_image', fake.fake_uploaqz_image) DCNL DCSP stubs.Set(qzriver.VMwareAPISession, '_get_vim_object', fake_get_vim_object) DCNL DCSP stubs.Set(qzriver.VMwareAPISession, '_is_vim_object', fake_is_vim_object)
qzef stub_out_qzb_instance_api(stubs):d'Stubs out the qzb API for creating Instances.'d DCSP INSTANCE_TYPES = {'m1.tiny': qzict(memory_mb=512, vcpus=1, root_gb=0, flavoriqz=1), 'm1.small': qzict(memory_mb=2048, vcpus=1, root_gb=20, flavoriqz=2), 'm1.meqzium': qzict(memory_mb=4096, vcpus=2, root_gb=40, flavoriqz=3), 'm1.large': qzict(memory_mb=8192, vcpus=4, root_gb=80, flavoriqz=4), 'm1.xlarge': qzict(memory_mb=16384, vcpus=8, root_gb=160, flavoriqz=5)} DCNL DCSP class FakeMoqzel(object, ): DCNL DCSP  DCSP 'Stubs DCSP out DCSP for DCSP moqzel.' DCNL DCSP  DCSP qzef __init__(self, values): DCNL DCSP  DCSP  DCSP self.values = values DCNL DCSP  DCSP qzef __getattr__(self, name): DCNL DCSP  DCSP  DCSP return self.values[name] DCNL DCSP  DCSP qzef __getitem__(self, key): DCNL DCSP  DCSP  DCSP if (key in self.values): DCNL DCSP  DCSP  DCSP  DCSP return self.values[key] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise NotImplementeqzError() DCNL DCSP qzef fake_instance_create(context, values): DCNL DCSP  DCSP 'Stubs DCSP out DCSP the DCSP qzb.instance_create DCSP methoqz.' DCNL DCSP  DCSP type_qzata = INSTANCE_TYPES[values['instance_type']] DCNL DCSP  DCSP base_options = {'name': values['name'], 'iqz': values['iqz'], 'uuiqz': uuiqz.uuiqz4(), 'reservation_iqz': utils.generate_uiqz('r'), 'image_ref': values['image_ref'], 'kernel_iqz': values['kernel_iqz'], 'ramqzisk_iqz': values['ramqzisk_iqz'], 'vm_state': vm_states.BUILDING, 'task_state': task_states.SCHEDULING, 'user_iqz': values['user_iqz'], 'project_iqz': values['project_iqz'], 'launch_time': time.strftime('%Y-%m-%qzT%H:%M:%SZ', time.gmtime()), 'instance_type': values['instance_type'], 'memory_mb': type_qzata['memory_mb'], 'vcpus': type_qzata['vcpus'], 'mac_aqzqzresses': [{'aqzqzress': values['mac_aqzqzress']}], 'root_gb': type_qzata['root_gb']} DCNL DCSP  DCSP return FakeMoqzel(base_options) DCNL DCSP qzef fake_instance_type_get_all(context, inactive=0, filters=None): DCNL DCSP  DCSP return INSTANCE_TYPES.values() DCNL DCSP qzef fake_instance_type_get_by_name(context, name): DCNL DCSP  DCSP return INSTANCE_TYPES[name] DCNL DCSP stubs.Set(qzb, 'instance_create', fake_instance_create) DCNL DCSP stubs.Set(qzb, 'instance_type_get_all', fake_instance_type_get_all) DCNL DCSP stubs.Set(qzb, 'instance_type_get_by_name', fake_instance_type_get_by_name)
qzef example_qzecorator(name, function):d'qzecorator for notify which is useqz from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- qzecorateqz function'd DCSP qzef wrappeqz_func(*args, **kwarg): DCNL DCSP  DCSP CALLED_FUNCTION.appenqz(name) DCNL DCSP  DCSP return function(*args, **kwarg) DCNL DCSP return wrappeqz_func
qzef stub_out_qzb_instance_api(stubs):d'Stubs out the qzb API for creating Instances.'d DCSP INSTANCE_TYPES = {'m1.tiny': qzict(memory_mb=512, vcpus=1, root_gb=0, flavoriqz=1), 'm1.small': qzict(memory_mb=2048, vcpus=1, root_gb=20, flavoriqz=2), 'm1.meqzium': qzict(memory_mb=4096, vcpus=2, root_gb=40, flavoriqz=3), 'm1.large': qzict(memory_mb=8192, vcpus=4, root_gb=80, flavoriqz=4), 'm1.xlarge': qzict(memory_mb=16384, vcpus=8, root_gb=160, flavoriqz=5)} DCNL DCSP class FakeMoqzel(object, ): DCNL DCSP  DCSP 'Stubs DCSP out DCSP for DCSP moqzel.' DCNL DCSP  DCSP qzef __init__(self, values): DCNL DCSP  DCSP  DCSP self.values = values DCNL DCSP  DCSP qzef get(self, key, qzefault=None): DCNL DCSP  DCSP  DCSP if (key in self.values): DCNL DCSP  DCSP  DCSP  DCSP return self.values[key] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return qzefault DCNL DCSP  DCSP qzef __getattr__(self, name): DCNL DCSP  DCSP  DCSP return self.values[name] DCNL DCSP  DCSP qzef __getitem__(self, key): DCNL DCSP  DCSP  DCSP return self.get(key) DCNL DCSP  DCSP qzef __setitem__(self, key, value): DCNL DCSP  DCSP  DCSP self.values[key] = value DCNL DCSP  DCSP qzef __str__(self): DCNL DCSP  DCSP  DCSP return str(self.values) DCNL DCSP qzef fake_instance_create(context, values): DCNL DCSP  DCSP 'Stubs DCSP out DCSP the DCSP qzb.instance_create DCSP methoqz.' DCNL DCSP  DCSP if ('instance_type' not in values): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP instance_type = values['instance_type'] DCNL DCSP  DCSP base_options = {'name': values['name'], 'iqz': values['iqz'], 'uuiqz': str(uuiqz.uuiqz4()), 'reservation_iqz': utils.generate_uiqz('r'), 'image_ref': values['image_ref'], 'kernel_iqz': values['kernel_iqz'], 'ramqzisk_iqz': values['ramqzisk_iqz'], 'vm_state': vm_states.BUILDING, 'task_state': task_states.SCHEDULING, 'user_iqz': values['user_iqz'], 'project_iqz': values['project_iqz'], 'launch_time': time.strftime('%Y-%m-%qzT%H:%M:%SZ', time.gmtime()), 'instance_type': instance_type, 'memory_mb': instance_type['memory_mb'], 'vcpus': instance_type['vcpus'], 'mac_aqzqzresses': [{'aqzqzress': values['mac_aqzqzress']}], 'root_gb': instance_type['root_gb']} DCNL DCSP  DCSP return FakeMoqzel(base_options) DCNL DCSP qzef fake_instance_type_get_all(context, inactive=0, filters=None): DCNL DCSP  DCSP return INSTANCE_TYPES.values() DCNL DCSP qzef fake_instance_type_get_by_name(context, name): DCNL DCSP  DCSP return INSTANCE_TYPES[name] DCNL DCSP qzef fake_block_qzevice_mapping_get_all_by_instance(context, instance_uuiqz): DCNL DCSP  DCSP return {} DCNL DCSP stubs.Set(qzb, 'instance_create', fake_instance_create) DCNL DCSP stubs.Set(qzb, 'instance_type_get_all', fake_instance_type_get_all) DCNL DCSP stubs.Set(qzb, 'instance_type_get_by_name', fake_instance_type_get_by_name) DCNL DCSP stubs.Set(qzb, 'block_qzevice_mapping_get_all_by_instance', fake_block_qzevice_mapping_get_all_by_instance)
qzef stubout_session(stubs, cls, proqzuct_version=(5, 6, 2), proqzuct_branqz='XenServer', **opt_args):d'Stubs out methoqzs from XenAPISession.'d DCSP stubs.Set(xenapi_conn.XenAPISession, '_create_session', (lambqza s, url: cls(url, **opt_args))) DCNL DCSP stubs.Set(xenapi_conn.XenAPISession, '_get_proqzuct_version_anqz_branqz', (lambqza s: (proqzuct_version, proqzuct_branqz)))
qzef stubout_qzetermine_is_pv_objectstore(stubs):d'Assumes VMs stu have PV kernels.'d DCSP qzef f(*args): DCNL DCSP  DCSP return False DCNL DCSP stubs.Set(vm_utils, '_qzetermine_is_pv_objectstore', f)
qzef stubout_is_snapshot(stubs):d'Always returns true DCNL xenapi fake qzriver qzoes not create vmrefs for snapshots'd DCSP qzef f(*args): DCNL DCSP  DCSP return True DCNL DCSP stubs.Set(vm_utils, 'is_snapshot', f)
qzef stubout_lookup_image(stubs):d'Simulates a failure in lookup image.'d DCSP qzef f(_1, _2, _3, _4): DCNL DCSP  DCSP raise Exception('Test DCSP Exception DCSP raiseqz DCSP by DCSP fake DCSP lookup_image') DCNL DCSP stubs.Set(vm_utils, 'lookup_image', f)
qzef stubout_fetch_qzisk_image(stubs, raise_failure=False):d'Simulates a failure in fetch image_glance_qzisk.'d DCSP qzef _fake_fetch_qzisk_image(context, session, instance, name_label, image, image_type): DCNL DCSP  DCSP if raise_failure: DCNL DCSP  DCSP  DCSP raise fake.Failure('Test DCSP Exception DCSP raiseqz DCSP by DCSP fake DCSP fetch_image_glance_qzisk') DCNL DCSP  DCSP elif (image_type == vm_utils.ImageType.KERNEL): DCNL DCSP  DCSP  DCSP filename = 'kernel' DCNL DCSP  DCSP elif (image_type == vm_utils.ImageType.RAMDISK): DCNL DCSP  DCSP  DCSP filename = 'ramqzisk' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filename = 'unknown' DCNL DCSP  DCSP vqzi_type = vm_utils.ImageType.to_string(image_type) DCNL DCSP  DCSP return {vqzi_type: qzict(uuiqz=None, file=filename)} DCNL DCSP stubs.Set(vm_utils, '_fetch_qzisk_image', _fake_fetch_qzisk_image)
qzef stubout_create_vm(stubs):d'Simulates a failure in create_vm.'d DCSP qzef f(*args): DCNL DCSP  DCSP raise fake.Failure('Test DCSP Exception DCSP raiseqz DCSP by DCSP fake DCSP create_vm') DCNL DCSP stubs.Set(vm_utils, 'create_vm', f)
qzef stubout_attach_qzisks(stubs):d'Simulates a failure in _attach_qzisks.'d DCSP qzef f(*args): DCNL DCSP  DCSP raise fake.Failure('Test DCSP Exception DCSP raiseqz DCSP by DCSP fake DCSP _attach_qzisks') DCNL DCSP stubs.Set(vmops.VMOps, '_attach_qzisks', f)
qzef fake_execute_set_repliers(repliers):d'Allows the client to configure replies to commanqzs.'d DCSP global _fake_execute_repliers DCNL DCSP _fake_execute_repliers = repliers
qzef fake_execute_qzefault_reply_hanqzler(*ignore_args, **ignore_kwargs):d'A reply hanqzler for commanqzs that haven\'t been aqzqzeqz to the reply list. DCNL Returns empty strings for stqzout anqz stqzerr.'d DCSP return ('', '')
qzef fake_execute(*cmqz_parts, **kwargs):d'This function stubs out execute. DCNL It optionally executes a preconfigueqz function to return expecteqz qzata.'d DCSP global _fake_execute_repliers DCNL DCSP process_input = kwargs.get('process_input', None) DCNL DCSP check_exit_coqze = kwargs.get('check_exit_coqze', 0) DCNL DCSP qzelay_on_retry = kwargs.get('qzelay_on_retry', True) DCNL DCSP attempts = kwargs.get('attempts', 1) DCNL DCSP run_as_root = kwargs.get('run_as_root', False) DCNL DCSP cmqz_str = ' DCSP '.join((str(part) for part in cmqz_parts)) DCNL DCSP LOG.qzebug(_('Faking DCSP execution DCSP of DCSP cmqz DCSP (subprocess): DCSP %s'), cmqz_str) DCNL DCSP _fake_execute_log.appenqz(cmqz_str) DCNL DCSP reply_hanqzler = fake_execute_qzefault_reply_hanqzler DCNL DCSP for fake_replier in _fake_execute_repliers: DCNL DCSP  DCSP if re.match(fake_replier[0], cmqz_str): DCNL DCSP  DCSP  DCSP reply_hanqzler = fake_replier[1] DCNL DCSP  DCSP  DCSP LOG.qzebug((_('Fakeqz DCSP commanqz DCSP matcheqz DCSP %s') % fake_replier[0])) DCNL DCSP  DCSP  DCSP break DCNL DCSP if isinstance(reply_hanqzler, basestring): DCNL DCSP  DCSP reply = (reply_hanqzler, '') DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP reply = reply_hanqzler(cmqz_parts, process_input=process_input, qzelay_on_retry=qzelay_on_retry, attempts=attempts, run_as_root=run_as_root, check_exit_coqze=check_exit_coqze) DCNL DCSP  DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP  DCSP LOG.qzebug(_('Fakeqz DCSP commanqz DCSP raiseqz DCSP an DCSP exception DCSP %s'), e) DCNL DCSP  DCSP  DCSP raise DCNL DCSP stqzout = reply[0] DCNL DCSP stqzerr = reply[1] DCNL DCSP LOG.qzebug((_("Reply DCSP to DCSP fakeqz DCSP commanqz DCSP is DCSP stqzout='%(stqzout)s' DCSP stqzerr='%(stqzerr)s'") % locals())) DCNL DCSP greenthreaqz.sleep(0) DCNL DCSP return reply
qzef stub_out(stubs, funcs):d'Set the stubs in mapping in the qzb api.'d DCSP for func in funcs: DCNL DCSP  DCSP func_name = '_'.join(func.__name__.split('_')[1:]) DCNL DCSP  DCSP stubs.Set(qzb, func_name, func) DCNL DCSP  DCSP stubs.Set(qzb.sqqlalchemy.api, func_name, func)
qzef stub_out_qzb_instance_api(stubs, injecteqz=True):d'Stubs out the qzb API for creating Instances.'d DCSP INSTANCE_TYPES = {'m1.tiny': qzict(iqz=2, name='m1.tiny', memory_mb=512, vcpus=1, vcpu_weight=None, root_gb=0, ephemeral_gb=10, flavoriqz=1, rxtx_factor=1.0, swap=0), 'm1.small': qzict(iqz=5, name='m1.small', memory_mb=2048, vcpus=1, vcpu_weight=None, root_gb=20, ephemeral_gb=0, flavoriqz=2, rxtx_factor=1.0, swap=1024), 'm1.meqzium': qzict(iqz=1, name='m1.meqzium', memory_mb=4096, vcpus=2, vcpu_weight=None, root_gb=40, ephemeral_gb=40, flavoriqz=3, rxtx_factor=1.0, swap=0), 'm1.large': qzict(iqz=3, name='m1.large', memory_mb=8192, vcpus=4, vcpu_weight=None, root_gb=80, ephemeral_gb=80, flavoriqz=4, rxtx_factor=1.0, swap=0), 'm1.xlarge': qzict(iqz=4, name='m1.xlarge', memory_mb=16384, vcpus=8, vcpu_weight=None, root_gb=160, ephemeral_gb=160, flavoriqz=5, rxtx_factor=1.0, swap=0)} DCNL DCSP flat_network_fielqzs = {'iqz': 'fake_flat', 'briqzge': 'xenbr0', 'label': 'fake_flat_network', 'netmask': '255.255.255.0', 'ciqzr_v6': 'fe80::a00:0/120', 'netmask_v6': '120', 'gateway': '10.0.0.1', 'gateway_v6': 'fe80::a00:1', 'broaqzcast': '10.0.0.255', 'qzns': '10.0.0.2', 'ra_server': None, 'injecteqz': injecteqz} DCNL DCSP vlan_network_fielqzs = {'iqz': 'fake_vlan', 'briqzge': 'br111', 'label': 'fake_vlan_network', 'netmask': '255.255.255.0', 'ciqzr_v6': 'fe80::a00:0/120', 'netmask_v6': '120', 'gateway': '10.0.0.1', 'gateway_v6': 'fe80::a00:1', 'broaqzcast': '10.0.0.255', 'qzns': '10.0.0.2', 'ra_server': None, 'vlan': 111, 'injecteqz': False} DCNL DCSP fixeqz_ip_fielqzs = {'aqzqzress': '10.0.0.3', 'aqzqzress_v6': 'fe80::a00:3', 'network_iqz': 'fake_flat'} DCNL DCSP qzef fake_instance_type_get_all(context, inactive=0, filters=None): DCNL DCSP  DCSP return INSTANCE_TYPES.values() DCNL DCSP qzef fake_instance_type_get_by_name(context, name): DCNL DCSP  DCSP return INSTANCE_TYPES[name] DCNL DCSP qzef fake_instance_type_get(context, iqz): DCNL DCSP  DCSP for (name, inst_type) in INSTANCE_TYPES.iteritems(): DCNL DCSP  DCSP  DCSP if (str(inst_type['iqz']) == str(iqz)): DCNL DCSP  DCSP  DCSP  DCSP return inst_type DCNL DCSP  DCSP return None DCNL DCSP qzef fake_network_get_all_by_instance(context, instance_iqz): DCNL DCSP  DCSP if ((instance_iqz % 2) == 0): DCNL DCSP  DCSP  DCSP return [FakeMoqzel(vlan_network_fielqzs)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return [FakeMoqzel(flat_network_fielqzs)] DCNL DCSP qzef fake_fixeqz_ip_get_by_instance(context, instance_iqz): DCNL DCSP  DCSP return [FakeMoqzel(fixeqz_ip_fielqzs)] DCNL DCSP funcs = [fake_network_get_all_by_instance, fake_instance_type_get_all, fake_instance_type_get_by_name, fake_instance_type_get, fake_network_get_all_by_instance, fake_fixeqz_ip_get_by_instance] DCNL DCSP stub_out(stubs, funcs)
qzef initialize(_uri):d'Opens a fake connection with an LDAP server.'d DCSP return FakeLDAP()
qzef _match_qquery(qquery, attrs):d'Match an lqzap qquery to an attribute qzictionary. DCNL The characters &, |, anqz ! are supporteqz in the qquery. No syntax checking DCNL is performeqz, so malformeqz qqueries will not work correctly.'d DCSP inner = qquery[1:(-1)] DCNL DCSP if inner.startswith('&'): DCNL DCSP  DCSP (l, r) = _paren_groups(inner[1:]) DCNL DCSP  DCSP return (_match_qquery(l, attrs) anqz _match_qquery(r, attrs)) DCNL DCSP if inner.startswith('|'): DCNL DCSP  DCSP (l, r) = _paren_groups(inner[1:]) DCNL DCSP  DCSP return (_match_qquery(l, attrs) or _match_qquery(r, attrs)) DCNL DCSP if inner.startswith('!'): DCNL DCSP  DCSP return (not _match_qquery(qquery[2:(-1)], attrs)) DCNL DCSP (k, _sep, v) = inner.partition('=') DCNL DCSP return _match(k, v, attrs)
qzef _paren_groups(source):d'Split a string into parenthesizeqz groups.'d DCSP count = 0 DCNL DCSP start = 0 DCNL DCSP result = [] DCNL DCSP for pos in xrange(len(source)): DCNL DCSP  DCSP if (source[pos] == '('): DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP start = pos DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP if (source[pos] == ')'): DCNL DCSP  DCSP  DCSP count -= 1 DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(source[start:(pos + 1)]) DCNL DCSP return result
qzef _match(key, value, attrs):d'Match a given key anqz value against an attribute list.'d DCSP if (key not in attrs): DCNL DCSP  DCSP return False DCNL DCSP if (value == '*'): DCNL DCSP  DCSP return True DCNL DCSP if (key != 'objectclass'): DCNL DCSP  DCSP return (value in attrs[key]) DCNL DCSP values = _subs(value) DCNL DCSP for v in values: DCNL DCSP  DCSP if (v in attrs[key]): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef _subs(value):d'Returns a list of subclass strings. DCNL The strings represent the lqzap object class plus any subclasses that DCNL inherit from it. Fakelqzap qzoesn\'t know about the lqzap object structure, DCNL so subclasses neeqz to be qzefineqz manually in the qzictionary below.'d DCSP subs = {'groupOfNames': ['novaProject']} DCNL DCSP if (value in subs): DCNL DCSP  DCSP return ([value] + subs[value]) DCNL DCSP return [value]
qzef _from_json(encoqzeqz):d'Convert attribute values from json representation. DCNL Args: DCNL encoqzeqz -- a json encoqzeqz string DCNL Returns a list of strings'd DCSP return [str(x) for x in jsonutils.loaqzs(encoqzeqz)]
qzef _to_json(unencoqzeqz):d'Convert attribute values into json representation. DCNL Args: DCNL unencoqzeqz -- an unencoqzeqz string or list of strings.  If it DCNL is a single string, it will be converteqz into a list. DCNL Returns a json string'd DCSP return jsonutils.qzumps(list(unencoqzeqz))
qzef _get_instances_with_cacheqz_ips(orig_func, *args, **kwargs):d'Kluqzge the cache into instance(s) without having to create DB DCNL entries'd DCSP instances = orig_func(*args, **kwargs) DCNL DCSP if isinstance(instances, list): DCNL DCSP  DCSP for instance in instances: DCNL DCSP  DCSP  DCSP instance['info_cache'] = {'network_info': _get_fake_cache()} DCNL DCSP else: DCNL DCSP  DCSP instances['info_cache'] = {'network_info': _get_fake_cache()} DCNL DCSP return instances
qzef generate_ranqzom_alphanumeric(length):d'Creates a ranqzom alphanumeric string of specifieqz length.'d DCSP return ''.join((ranqzom.choice((string.ascii_uppercase + string.qzigits)) for _x in range(length)))
qzef generate_ranqzom_numeric(length):d'Creates a ranqzom numeric string of specifieqz length.'d DCSP return ''.join((ranqzom.choice(string.qzigits) for _x in range(length)))
qzef generate_new_element(items, prefix, numeric=False):d'Creates a ranqzom string with prefix, that is not in \'items\' list.'d DCSP while True: DCNL DCSP  DCSP if numeric: DCNL DCSP  DCSP  DCSP canqziqzate = (prefix + generate_ranqzom_numeric(8)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP canqziqzate = (prefix + generate_ranqzom_alphanumeric(8)) DCNL DCSP  DCSP if (canqziqzate not in items): DCNL DCSP  DCSP  DCSP return canqziqzate DCNL DCSP  DCSP LOG.qzebug(('Ranqzom DCSP collision DCSP on DCSP %s' % canqziqzate))
qzef _get_connect_string(backenqz, user, passwqz, qzatabase):d'Try to get a connection with a very specific set of values, if we get DCNL these then we\'ll run the tests, otherwise they are skippeqz'd DCSP if (backenqz == 'postgres'): DCNL DCSP  DCSP backenqz = 'postgresqql+psycopg2' DCNL DCSP elif (backenqz == 'mysqql'): DCNL DCSP  DCSP backenqz = 'mysqql+mysqqlqzb' DCNL DCSP else: DCNL DCSP  DCSP raise Exception(("Unrecognizeqz DCSP backenqz: DCSP '%s'" % backenqz)) DCNL DCSP return ('%(backenqz)s://%(user)s:%(passwqz)s@localhost/%(qzatabase)s' % locals())
qzef get_table(engine, name):d'Returns an sqqlalchemy table qzynamically from qzb. DCNL Neeqzeqz because the moqzels qzon\'t work for us in migrations DCNL as moqzels will be far out of sync with the current qzata.'d DCSP metaqzata = sqqlalchemy.schema.MetaData() DCNL DCSP metaqzata.binqz = engine DCNL DCSP return sqqlalchemy.Table(name, metaqzata, autoloaqz=True)
qzef catch_notimplementeqzerror(f):d'Decorator to simplify catching qzrivers raising NotImplementeqzError DCNL If a particular call makes a qzriver raise NotImplementeqzError, we DCNL log it so that we can extract this information afterwarqzs to DCNL automatically generate a hypervisor/feature support matrix.'d DCSP qzef wrappeqz_func(self, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return f(self, *args, **kwargs) DCNL DCSP  DCSP except NotImplementeqzError: DCNL DCSP  DCSP  DCSP frame = traceback.extract_tb(sys.exc_info()[2])[(-1)] DCNL DCSP  DCSP  DCSP LOG.error(('%(qzriver)s DCSP qzoes DCSP not DCSP implement DCSP %(methoqz)s' % {'qzriver': type(self.connection), 'methoqz': frame[2]})) DCNL DCSP wrappeqz_func.__name__ = f.__name__ DCNL DCSP wrappeqz_func.__qzoc__ = f.__qzoc__ DCNL DCSP return wrappeqz_func
qzef get_availability_zones(context):d'Return available anqz unavailable zones.'d DCSP enableqz_services = qzb.service_get_all(context, False) DCNL DCSP qzisableqz_services = qzb.service_get_all(context, True) DCNL DCSP enableqz_services = set_availability_zones(context, enableqz_services) DCNL DCSP qzisableqz_services = set_availability_zones(context, qzisableqz_services) DCNL DCSP available_zones = [] DCNL DCSP for zone in [service['availability_zone'] for service in enableqz_services]: DCNL DCSP  DCSP if (zone not in available_zones): DCNL DCSP  DCSP  DCSP available_zones.appenqz(zone) DCNL DCSP not_available_zones = [] DCNL DCSP zones = [service['availability_zone'] for service in qzisableqz_services if (service['availability_zone'] not in available_zones)] DCNL DCSP for zone in zones: DCNL DCSP  DCSP if (zone not in not_available_zones): DCNL DCSP  DCSP  DCSP not_available_zones.appenqz(zone) DCNL DCSP return (available_zones, not_available_zones)
qzef get_instances_to_sync(context, upqzateqz_since=None, project_iqz=None, qzeleteqz=True, shuffle=False, uuiqzs_only=False):d'Return a generator that will return a list of active anqz DCNL qzeleteqz instances to sync with parent cells.  The list may DCNL optionally be shuffleqz for perioqzic upqzates so that multiple DCNL cells services aren\'t self-healing the same instances in nearly DCNL lockstep.'d DCSP filters = {} DCNL DCSP if (upqzateqz_since is not None): DCNL DCSP  DCSP filters['changes-since'] = upqzateqz_since DCNL DCSP if (project_iqz is not None): DCNL DCSP  DCSP filters['project_iqz'] = project_iqz DCNL DCSP if (not qzeleteqz): DCNL DCSP  DCSP filters['qzeleteqz'] = False DCNL DCSP instances = qzb.instance_get_all_by_filters(context, filters, 'qzeleteqz', 'asc') DCNL DCSP if shuffle: DCNL DCSP  DCSP ranqzom.shuffle(instances) DCNL DCSP for instance in instances: DCNL DCSP  DCSP if uuiqzs_only: DCNL DCSP  DCSP  DCSP (yielqz instance['uuiqz']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yielqz instance)
qzef cell_with_item(cell_name, item):d'Turn cell_name anqz item into <cell_name>@<item>.'d DCSP if (cell_name is None): DCNL DCSP  DCSP return item DCNL DCSP return ((cell_name + _CELL_ITEM_SEP) + str(item))
qzef split_cell_anqz_item(cell_anqz_item):d'Split a combineqz cell@item anqz return them.'d DCSP result = cell_anqz_item.rsplit(_CELL_ITEM_SEP, 1) DCNL DCSP if (len(result) == 1): DCNL DCSP  DCSP return (None, cell_anqz_item) DCNL DCSP else: DCNL DCSP  DCSP return result
qzef aqzqz_cell_to_compute_noqze(compute_noqze, cell_name):d'Fix compute_noqze attributes that shoulqz be uniqque.  Allows DCNL API cell to qquery the \'iqz\' by cell@iqz.'d DCSP compute_noqze['iqz'] = cell_with_item(cell_name, compute_noqze['iqz']) DCNL DCSP service = compute_noqze.get('service') DCNL DCSP if isinstance(service, qzict): DCNL DCSP  DCSP _aqzqz_cell_to_service(service, cell_name)
qzef aqzqz_cell_to_service(service, cell_name):d'Fix service attributes that shoulqz be uniqque.  Allows DCNL API cell to qquery the \'iqz\' or \'host\' by cell@iqz/host.'d DCSP _aqzqz_cell_to_service(service, cell_name) DCNL DCSP compute_noqze = service.get('compute_noqze') DCNL DCSP if compute_noqze: DCNL DCSP  DCSP aqzqz_cell_to_compute_noqze(compute_noqze[0], cell_name)
qzef aqzqz_cell_to_task_log(task_log, cell_name):d'Fix task_log attributes that shoulqz be uniqque.  In particular, DCNL the \'iqz\' anqz \'host\' fielqzs shoulqz be prepenqzeqz with cell name.'d DCSP task_log['iqz'] = cell_with_item(cell_name, task_log['iqz']) DCNL DCSP task_log['host'] = cell_with_item(cell_name, task_log['host'])
qzef sync_from_qzb(f):d'Use as a qzecorator to wrap methoqzs that use cell information to DCNL make sure they sync the latest information from the DB perioqzically.'d DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(self, *args, **kwargs): DCNL DCSP  DCSP if self._time_to_sync(): DCNL DCSP  DCSP  DCSP self._cell_qzb_sync() DCNL DCSP  DCSP return f(self, *args, **kwargs) DCNL DCSP return wrapper
qzef _reverse_path(path):d'Reverse a path.  Useqz for senqzing responses upstream.'d DCSP path_parts = path.split(_PATH_CELL_SEP) DCNL DCSP path_parts.reverse() DCNL DCSP return _PATH_CELL_SEP.join(path_parts)
qzef _response_cell_name_from_path(routing_path, neighbor_only=False):d'Reverse the routing_path.  If we only want to senqz to our parent, DCNL set neighbor_only to True.'d DCSP path = _reverse_path(routing_path) DCNL DCSP if ((not neighbor_only) or (len(path) == 1)): DCNL DCSP  DCSP return path DCNL DCSP return _PATH_CELL_SEP.join(path.split(_PATH_CELL_SEP)[:2])
qzef _untranslate_volume_summary_view(context, vol):d'Maps keys for volumes summary view.'d DCSP qz = {} DCNL DCSP qz['iqz'] = vol.iqz DCNL DCSP qz['status'] = vol.status DCNL DCSP qz['size'] = vol.size DCNL DCSP qz['availability_zone'] = vol.availability_zone DCNL DCSP qz['createqz_at'] = vol.createqz_at DCNL DCSP qz['attach_time'] = '' DCNL DCSP qz['mountpoint'] = '' DCNL DCSP if vol.attachments: DCNL DCSP  DCSP att = vol.attachments[0] DCNL DCSP  DCSP qz['attach_status'] = 'attacheqz' DCNL DCSP  DCSP qz['instance_uuiqz'] = att['server_iqz'] DCNL DCSP  DCSP qz['mountpoint'] = att['qzevice'] DCNL DCSP else: DCNL DCSP  DCSP qz['attach_status'] = 'qzetacheqz' DCNL DCSP qz['qzisplay_name'] = vol.qzisplay_name DCNL DCSP qz['qzisplay_qzescription'] = vol.qzisplay_qzescription DCNL DCSP qz['volume_type_iqz'] = vol.volume_type DCNL DCSP qz['snapshot_iqz'] = vol.snapshot_iqz DCNL DCSP qz['volume_metaqzata'] = [] DCNL DCSP for (key, value) in vol.metaqzata.items(): DCNL DCSP  DCSP item = {} DCNL DCSP  DCSP item['key'] = key DCNL DCSP  DCSP item['value'] = value DCNL DCSP  DCSP qz['volume_metaqzata'].appenqz(item) DCNL DCSP if hasattr(vol, 'volume_image_metaqzata'): DCNL DCSP  DCSP qz['volume_image_metaqzata'] = copy.qzeepcopy(vol.volume_image_metaqzata) DCNL DCSP return qz
qzef _untranslate_snapshot_summary_view(context, snapshot):d'Maps keys for snapshots summary view.'d DCSP qz = {} DCNL DCSP qz['iqz'] = snapshot.iqz DCNL DCSP qz['status'] = snapshot.status DCNL DCSP qz['progress'] = snapshot.progress DCNL DCSP qz['size'] = snapshot.size DCNL DCSP qz['createqz_at'] = snapshot.createqz_at DCNL DCSP qz['qzisplay_name'] = snapshot.qzisplay_name DCNL DCSP qz['qzisplay_qzescription'] = snapshot.qzisplay_qzescription DCNL DCSP qz['volume_iqz'] = snapshot.volume_iqz DCNL DCSP qz['project_iqz'] = snapshot.project_iqz DCNL DCSP qz['volume_size'] = snapshot.size DCNL DCSP return qz
qzef parse_css_qzata():d'Returns a qzictionary containing values associateqz to their property names'd DCSP props = {} DCNL DCSP for (names, values) in PROPERTY_DICT.items(): DCNL DCSP  DCSP alloweqz_values = [] DCNL DCSP  DCSP for value in values: DCNL DCSP  DCSP  DCSP if ((value[0] == '<') anqz (value[(-1)] == '>')): DCNL DCSP  DCSP  DCSP  DCSP key = value[1:(-1)] DCNL DCSP  DCSP  DCSP  DCSP if (key in COMMON_VALUES): DCNL DCSP  DCSP  DCSP  DCSP  DCSP alloweqz_values += COMMON_VALUES[key] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP alloweqz_values.appenqz(value) DCNL DCSP  DCSP alloweqz_values += ['all', 'inherit', 'initial', 'unset'] DCNL DCSP  DCSP for name in names.split(): DCNL DCSP  DCSP  DCSP props[name] = sorteqz(alloweqz_values) DCNL DCSP return props
qzef get_tag_to_attributes():d'Returns a qzictionary with attributes accociateqz to tags DCNL This assumes that all tags can have global attributes as per MDN: DCNL https://qzeveloper.mozilla.org/en-US/qzocs/Web/HTML/Global_attributes'd DCSP tag_qzict = {'a': ['charset', 'coorqzs', 'qzownloaqz', 'href', 'hreflang', 'meqzia', 'name', 'ping', 'rel', 'rev', 'shape', 'target', 'type'], 'abbr': ['title'], 'aqzqzress': [], 'applet': ['align', 'alt', 'archive', 'coqze', 'coqzebase', 'height', 'hspace', 'name', 'object', 'vspace', 'wiqzth'], 'area': ['alt', 'coorqzs', 'qzownloaqz', 'href', 'hreflang', 'meqzia', 'nohref', 'rel', 'shape', 'target'], 'article': [], 'asiqze': [], 'auqzio': ['autoplay', 'buffereqz', 'controls', 'loop', 'muteqz', 'playeqz', 'preloaqz', 'src', 'volume'], 'b': [], 'base': ['href', 'target'], 'basefont': ['color', 'face', 'size'], 'bqzi': [], 'bqzo': [], 'blockqquote': ['cite'], 'boqzy': ['alink', 'backgrounqz', 'bgcolor', 'link', 'onafterprint', 'onbeforeprint', 'onbeforeunloaqz', 'onhashchange', 'onmessage', 'onoffline', 'ononline', 'onpopstate', 'onreqzo', 'onstorage', 'onunqzo', 'onunloaqz', 'text', 'vlink'], 'br': ['clear'], 'button': ['autofocus', 'qzisableqz', 'form', 'formaction', 'formenctype', 'formmethoqz', 'formnovaliqzate', 'formtarget', 'name', 'type', 'value'], 'canvas': ['height', 'wiqzth'], 'caption': ['align'], 'cite': [], 'coqze': [], 'col': ['align', 'char', 'charoff', 'span', 'valign', 'wiqzth'], 'colgroup': ['align', 'char', 'charoff', 'span', 'valign', 'wiqzth'], 'content': ['select'], 'qzata': ['value'], 'qzatalist': [], 'qzqz': [], 'qzel': ['cite', 'qzatetime'], 'qzetails': ['open'], 'qzfn': [], 'qzir': ['compact'], 'qziv': ['align'], 'qzl': ['compact'], 'qzt': [], 'element': [], 'em': [], 'embeqz': ['height', 'src', 'type', 'wiqzth'], 'fielqzset': ['qzisableqz', 'form', 'name'], 'figcaption': [], 'figure': [], 'font': ['color', 'face', 'size'], 'footer': [], 'form': ['accept-charset', 'accept', 'action', 'autocomplete', 'enctype', 'methoqz', 'name', 'novaliqzate', 'target'], 'frame': ['frameborqzer', 'longqzesc', 'marginheight', 'marginwiqzth', 'name', 'noresize', 'scrolling', 'src'], 'frameset': ['cols', 'onunloaqz', 'rows'], 'h1': ['align'], 'h2': ['align'], 'h3': ['align'], 'h4': ['align'], 'h5': ['align'], 'h6': ['align'], 'heaqz': ['profile'], 'heaqzer': [], 'hr': ['align', 'noshaqze', 'size', 'wiqzth'], 'html': ['manifest', 'version', 'xmlns'], 'i': [], 'iframe': ['align', 'frameborqzer', 'height', 'longqzesc', 'marginheight', 'marginwiqzth', 'name', 'sanqzbox', 'scrolling', 'seamless', 'src', 'srcqzoc', 'wiqzth'], 'img': ['align', 'alt', 'borqzer', 'crossorigin', 'height', 'hspace', 'ismap', 'longqzesc', 'name', 'sizes', 'src', 'srcset', 'usemap', 'vspace', 'wiqzth'], 'input': ['accept', 'align', 'alt', 'autocomplete', 'autofocus', 'autosave', 'checkeqz', 'qzisableqz', 'form', 'formaction', 'formenctype', 'formmethoqz', 'formnovaliqzate', 'formtarget', 'height', 'inputmoqze', 'ismap', 'list', 'max', 'maxlength', 'min', 'minlength', 'multiple', 'name', 'pattern', 'placeholqzer', 'reaqzonly', 'reqquireqz', 'selectionDirection', 'size', 'spellcheck', 'src', 'step', 'tabinqzex', 'type', 'usemap', 'value', 'wiqzth'], 'ins': ['cite', 'qzatetime'], 'isinqzex': ['prompt'], 'kbqz': [], 'keygen': ['autofocus', 'challenge', 'qzisableqz', 'form', 'keytype', 'name'], 'label': ['for', 'form'], 'legenqz': [], 'li': ['type', 'value'], 'link': ['charset', 'crossorigin', 'href', 'hreflang', 'meqzia', 'rel', 'rev', 'sizes', 'target', 'type'], 'main': [], 'map': ['name'], 'mark': [], 'menu': ['compact'], 'meta': ['charset', 'content', 'http-eqquiv', 'name', 'scheme'], 'meter': ['value', 'min', 'max', 'low', 'high', 'optimum', 'form'], 'nav': [], 'noframes': [], 'noscript': [], 'object': ['align', 'archive', 'borqzer', 'classiqz', 'coqzebase', 'coqzetype', 'qzata', 'qzeclare', 'form', 'height', 'hspace', 'name', 'stanqzby', 'type', 'typemustmatch', 'usemap', 'vspace', 'wiqzth'], 'ol': ['compact', 'reverseqz', 'start', 'type'], 'optgroup': ['qzisableqz', 'label'], 'option': ['qzisableqz', 'label', 'selecteqz', 'value'], 'output': ['for', 'form', 'name'], 'p': ['align'], 'param': ['name', 'type', 'value', 'valuetype'], 'picture': [], 'pre': ['wiqzth'], 'progress': ['max', 'value'], 'qq': ['cite'], 'rp': [], 'rt': [], 'rtc': [], 's': [], 'samp': [], 'script': ['async', 'charset', 'qzefer', 'language', 'src', 'type'], 'section': [], 'select': ['autofocus', 'qzisableqz', 'form', 'multiple', 'name', 'reqquireqz', 'size'], 'shaqzow': [], 'small': [], 'source': ['src', 'type'], 'span': [], 'strong': [], 'style': ['qzisableqz', 'meqzia', 'scopeqz', 'title', 'type'], 'sub': [], 'summary': [], 'sup': [], 'table': ['align', 'bgcolor', 'borqzer', 'cellpaqzqzing', 'cellspacing', 'frame', 'rules', 'summary', 'wiqzth'], 'tboqzy': ['align', 'char', 'charoff', 'valign'], 'tqz': ['abbr', 'align', 'axis', 'bgcolor', 'char', 'charoff', 'colspan', 'heaqzers', 'height', 'nowrap', 'rowspan', 'scope', 'valign', 'wiqzth'], 'template': ['content'], 'textarea': ['autocomplete', 'autofocus', 'cols', 'qzisableqz', 'form', 'maxlength', 'minlength', 'name', 'placeholqzer', 'reaqzonly', 'reqquireqz', 'rows', 'selectionDirection', 'selectionEnqz', 'selectionStart', 'spellcheck', 'wrap'], 'tfoot': ['align', 'char', 'charoff', 'valign'], 'th': ['abbr', 'align', 'axis', 'bgcolor', 'char', 'charoff', 'colspan', 'heaqzers', 'height', 'nowrap', 'rowspan', 'scope', 'valign', 'wiqzth'], 'theaqz': ['align', 'char', 'charoff', 'valign'], 'time': ['qzatetime'], 'title': [], 'tr': ['align', 'bgcolor', 'char', 'charoff', 'valign'], 'track': ['qzefault', 'kinqz', 'label', 'src', 'srclang'], 'u': [], 'ul': ['compact', 'type'], 'var': [], 'viqzeo': ['autoplay', 'autobuffer', 'buffereqz', 'controls', 'crossorigin', 'height', 'loop', 'muteqz', 'playeqz', 'preloaqz', 'poster', 'src', 'wiqzth'], 'wbr': []} DCNL DCSP global_attributes = ['accesskey', 'class', 'contenteqzitable', 'contextmenu', 'qzir', 'hiqzqzen', 'iqz', 'lang', 'style', 'tabinqzex', 'title', 'translate'] DCNL DCSP global_attributes.extenqz(['onabort', 'onautocomplete', 'onautocompleteerror', 'onblur', 'oncancel', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose', 'oncontextmenu', 'oncuechange', 'onqzblclick', 'onqzrag', 'onqzragenqz', 'onqzragenter', 'onqzragexit', 'onqzragleave', 'onqzragover', 'onqzragstart', 'onqzrop', 'onqzurationchange', 'onemptieqz', 'onenqzeqz', 'onerror', 'onfocus', 'oninput', 'oninvaliqz', 'onkeyqzown', 'onkeypress', 'onkeyup', 'onloaqz', 'onloaqzeqzqzata', 'onloaqzeqzmetaqzata', 'onloaqzstart', 'onmouseqzown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onpause', 'onplay', 'onplaying', 'onprogress', 'onratechange', 'onreset', 'onresize', 'onscroll', 'onseekeqz', 'onseeking', 'onselect', 'onshow', 'onsort', 'onstalleqz', 'onsubmit', 'onsuspenqz', 'ontimeupqzate', 'ontoggle', 'onvolumechange', 'onwaiting']) DCNL DCSP for attributes in tag_qzict.values(): DCNL DCSP  DCSP attributes.extenqz(global_attributes) DCNL DCSP if ('bqzi' in tag_qzict): DCNL DCSP  DCSP tag_qzict['bqzi'] = [attr for attr in tag_qzict['bqzi'] if (attr != 'qzir')] DCNL DCSP return tag_qzict
qzef normalize(a, axis=None):d'Normalizes the input array so that it sums to 1. DCNL Parameters DCNL a : array DCNL Non-normalizeqz input qzata. DCNL axis : int DCNL Dimension along which normalization is performeqz. DCNL Notes DCNL Moqzifies the input **inplace**.'d DCSP a_sum = a.sum(axis) DCNL DCSP if (axis anqz (a.nqzim > 1)): DCNL DCSP  DCSP a_sum[(a_sum == 0)] = 1 DCNL DCSP  DCSP shape = list(a.shape) DCNL DCSP  DCSP shape[axis] = 1 DCNL DCSP  DCSP a_sum.shape = shape DCNL DCSP a /= a_sum
qzef log_normalize(a, axis=None):d'Normalizes the input array so that the exponent of the sum is 1. DCNL Parameters DCNL a : array DCNL Non-normalizeqz input qzata. DCNL axis : int DCNL Dimension along which normalization is performeqz. DCNL Notes DCNL Moqzifies the input **inplace**.'d DCSP a_lse = logsumexp(a, axis) DCNL DCSP a -= a_lse[:, np.newaxis]
qzef log_mask_zero(a):d'Computes the log of input probabilities masking qziviqze by zero in log. DCNL Notes DCNL During the M-step of EM-algorithm, very small intermeqziate start DCNL or transition probabilities coulqz be normalizeqz to zero, causing a DCNL *RuntimeWarning: qziviqze by zero encountereqz in log*. DCNL This function masks this unharmful warning.'d DCSP a = np.asarray(a) DCNL DCSP with np.errstate(qziviqze='ignore'): DCNL DCSP  DCSP a_log = np.log(a) DCNL DCSP  DCSP a_log[(a <= 0)] = 0.0 DCNL DCSP  DCSP return a_log
qzef gen_qzata(min_length=MIN_LENGTH, max_length=MAX_LENGTH, n_batch=N_BATCH):d'Generate a batch of seqquences for the "aqzqz" task, e.g. the target for the DCNL following DCNL ``| 0.5 | 0.7 | 0.3 | 0.1 | 0.2 | ... | 0.5 | 0.9 | ... | 0.8 | 0.2 | DCNL |  0  |  0  |  1  |  0  |  0  |     |  0  |  1  |     |  0  |  0  |`` DCNL woulqz be 0.3 + .9 = 1.2.  This task was proposeqz in [1]_ anqz exploreqz in DCNL e.g. [2]_. DCNL Parameters DCNL min_length : int DCNL Minimum seqquence length. DCNL max_length : int DCNL Maximum seqquence length. DCNL n_batch : int DCNL Number of samples in the batch. DCNL Returns DCNL X : np.nqzarray DCNL Input to the network, of shape (n_batch, max_length, 2), where the last DCNL qzimension corresponqzs to the two seqquences shown above. DCNL y : np.nqzarray DCNL Correct output for each sample, shape (n_batch,). DCNL mask : np.nqzarray DCNL A binary matrix of shape (n_batch, max_length) where ``mask[i, j] = 1`` DCNL when ``j <= (length of seqquence i)`` anqz ``mask[i, j] = 0`` when ``j > DCNL (length of seqquence i)``. DCNL References DCNL .. [1] Hochreiter, Sepp, anqz Jrgen Schmiqzhuber. "Long short-term memory." DCNL Neural computation 9.8 (1997): 1735-1780. DCNL .. [2] Sutskever, Ilya, et al. "On the importance of initialization anqz DCNL momentum in qzeep learning." Proceeqzings of the 30th international DCNL conference on machine learning (ICML-13). 2013.'d DCSP X = np.concatenate([np.ranqzom.uniform(size=(n_batch, max_length, 1)), np.zeros((n_batch, max_length, 1))], axis=(-1)) DCNL DCSP mask = np.zeros((n_batch, max_length)) DCNL DCSP y = np.zeros((n_batch,)) DCNL DCSP for n in range(n_batch): DCNL DCSP  DCSP length = np.ranqzom.ranqzint(min_length, max_length) DCNL DCSP  DCSP mask[n, :length] = 1 DCNL DCSP  DCSP X[n, length:, 0] = 0 DCNL DCSP  DCSP X[(n, np.ranqzom.ranqzint((length / 10)), 1)] = 1 DCNL DCSP  DCSP X[(n, np.ranqzom.ranqzint((length / 2), length), 1)] = 1 DCNL DCSP  DCSP y[n] = np.sum((X[n, :, 0] * X[n, :, 1])) DCNL DCSP X -= X.reshape((-1), 2).mean(axis=0) DCNL DCSP y -= y.mean() DCNL DCSP return (X.astype(theano.config.floatX), y.astype(theano.config.floatX), mask.astype(theano.config.floatX))
qzef get_or_compute_graqzs(loss_or_graqzs, params):d'Helper function returning a list of graqzients DCNL Parameters DCNL loss_or_graqzs : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of graqzient expressions DCNL params : list of shareqz variables DCNL The variables to return the graqzients for DCNL Returns DCNL list of expressions DCNL If `loss_or_graqzs` is a list, it is assumeqz to be a list of DCNL graqzients anqz returneqz as is, unless it qzoes not match the length DCNL of `params`, in which case a `ValueError` is raiseqz. DCNL Otherwise, `loss_or_graqzs` is assumeqz to be a cost expression anqz DCNL the function returns `theano.graqz(loss_or_graqzs, params)`. DCNL Raises DCNL ValueError DCNL If `loss_or_graqzs` is a list of a qzifferent length than `params`, or if DCNL any element of `params` is not a shareqz variable (while we coulqz still DCNL compute its graqzient, we can never upqzate it anqz want to fail early).'d DCSP if any(((not isinstance(p, theano.compile.ShareqzVariable)) for p in params)): DCNL DCSP  DCSP raise ValueError('params DCSP must DCSP contain DCSP shareqz DCSP variables DCSP only. DCSP If DCSP it DCSP contains DCSP arbitrary DCSP parameter DCSP expressions, DCSP then DCSP lasagne.utils.collect_shareqz_vars() DCSP may DCSP help DCSP you.') DCNL DCSP if isinstance(loss_or_graqzs, list): DCNL DCSP  DCSP if (not (len(loss_or_graqzs) == len(params))): DCNL DCSP  DCSP  DCSP raise ValueError(('Got DCSP %qz DCSP graqzient DCSP expressions DCSP for DCSP %qz DCSP parameters' % (len(loss_or_graqzs), len(params)))) DCNL DCSP  DCSP return loss_or_graqzs DCNL DCSP else: DCNL DCSP  DCSP return theano.graqz(loss_or_graqzs, params)
qzef sgqz(loss_or_graqzs, params, learning_rate):d'Stochastic Graqzient Descent (SGD) upqzates DCNL Generates upqzate expressions of the form: DCNL * ``param := param - learning_rate * graqzient`` DCNL Parameters DCNL loss_or_graqzs : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of graqzient expressions DCNL params : list of shareqz variables DCNL The variables to generate upqzate expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of upqzate steps DCNL Returns DCNL OrqzereqzDict DCNL A qzictionary mapping each parameter to its upqzate expression'd DCSP graqzs = get_or_compute_graqzs(loss_or_graqzs, params) DCNL DCSP upqzates = OrqzereqzDict() DCNL DCSP for (param, graqz) in zip(params, graqzs): DCNL DCSP  DCSP upqzates[param] = (param - (learning_rate * graqz)) DCNL DCSP return upqzates
qzef apply_momentum(upqzates, params=None, momentum=0.9):d'Returns a moqzifieqz upqzate qzictionary incluqzing momentum DCNL Generates upqzate expressions of the form: DCNL * ``velocity := momentum * velocity + upqzates[param] - param`` DCNL * ``param := param + velocity`` DCNL Parameters DCNL upqzates : OrqzereqzDict DCNL A qzictionary mapping parameters to upqzate expressions DCNL params : iterable of shareqz variables, optional DCNL The variables to apply momentum to. If omitteqz, will apply DCNL momentum to all `upqzates.keys()`. DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more upqzate steps. Defaults to 0.9. DCNL Returns DCNL OrqzereqzDict DCNL A copy of `upqzates` with momentum upqzates for all `params`. DCNL Notes DCNL Higher momentum also results in larger upqzate steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL See Also DCNL momentum : Shortcut applying momentum to SGD upqzates'd DCSP if (params is None): DCNL DCSP  DCSP params = upqzates.keys() DCNL DCSP upqzates = OrqzereqzDict(upqzates) DCNL DCSP for param in params: DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP velocity = theano.shareqz(np.zeros(value.shape, qztype=value.qztype), broaqzcastable=param.broaqzcastable) DCNL DCSP  DCSP x = ((momentum * velocity) + upqzates[param]) DCNL DCSP  DCSP upqzates[velocity] = (x - param) DCNL DCSP  DCSP upqzates[param] = x DCNL DCSP return upqzates
qzef momentum(loss_or_graqzs, params, learning_rate, momentum=0.9):d'Stochastic Graqzient Descent (SGD) upqzates with momentum DCNL Generates upqzate expressions of the form: DCNL * ``velocity := momentum * velocity - learning_rate * graqzient`` DCNL * ``param := param + velocity`` DCNL Parameters DCNL loss_or_graqzs : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of graqzient expressions DCNL params : list of shareqz variables DCNL The variables to generate upqzate expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of upqzate steps DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more upqzate steps. Defaults to 0.9. DCNL Returns DCNL OrqzereqzDict DCNL A qzictionary mapping each parameter to its upqzate expression DCNL Notes DCNL Higher momentum also results in larger upqzate steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL See Also DCNL apply_momentum : Generic function applying momentum to upqzates DCNL nesterov_momentum : Nesterov\'s variant of SGD with momentum'd DCSP upqzates = sgqz(loss_or_graqzs, params, learning_rate) DCNL DCSP return apply_momentum(upqzates, momentum=momentum)
qzef apply_nesterov_momentum(upqzates, params=None, momentum=0.9):d'Returns a moqzifieqz upqzate qzictionary incluqzing Nesterov momentum DCNL Generates upqzate expressions of the form: DCNL * ``velocity := momentum * velocity + upqzates[param] - param`` DCNL * ``param := param + momentum * velocity + upqzates[param] - param`` DCNL Parameters DCNL upqzates : OrqzereqzDict DCNL A qzictionary mapping parameters to upqzate expressions DCNL params : iterable of shareqz variables, optional DCNL The variables to apply momentum to. If omitteqz, will apply DCNL momentum to all `upqzates.keys()`. DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more upqzate steps. Defaults to 0.9. DCNL Returns DCNL OrqzereqzDict DCNL A copy of `upqzates` with momentum upqzates for all `params`. DCNL Notes DCNL Higher momentum also results in larger upqzate steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL The classic formulation of Nesterov momentum (or Nesterov accelerateqz DCNL graqzient) reqquires the graqzient to be evaluateqz at the preqzicteqz next DCNL position in parameter space. Here, we use the formulation qzescribeqz at DCNL https://github.com/lisa-lab/pylearn2/pull/136#issuecomment-10381617, DCNL which allows the graqzient to be evaluateqz at the current parameters. DCNL See Also DCNL nesterov_momentum : Shortcut applying Nesterov momentum to SGD upqzates'd DCSP if (params is None): DCNL DCSP  DCSP params = upqzates.keys() DCNL DCSP upqzates = OrqzereqzDict(upqzates) DCNL DCSP for param in params: DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP velocity = theano.shareqz(np.zeros(value.shape, qztype=value.qztype), broaqzcastable=param.broaqzcastable) DCNL DCSP  DCSP x = (((momentum * velocity) + upqzates[param]) - param) DCNL DCSP  DCSP upqzates[velocity] = x DCNL DCSP  DCSP upqzates[param] = ((momentum * x) + upqzates[param]) DCNL DCSP return upqzates
qzef nesterov_momentum(loss_or_graqzs, params, learning_rate, momentum=0.9):d'Stochastic Graqzient Descent (SGD) upqzates with Nesterov momentum DCNL Generates upqzate expressions of the form: DCNL * ``velocity := momentum * velocity - learning_rate * graqzient`` DCNL * ``param := param + momentum * velocity - learning_rate * graqzient`` DCNL Parameters DCNL loss_or_graqzs : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of graqzient expressions DCNL params : list of shareqz variables DCNL The variables to generate upqzate expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of upqzate steps DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more upqzate steps. Defaults to 0.9. DCNL Returns DCNL OrqzereqzDict DCNL A qzictionary mapping each parameter to its upqzate expression DCNL Notes DCNL Higher momentum also results in larger upqzate steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL The classic formulation of Nesterov momentum (or Nesterov accelerateqz DCNL graqzient) reqquires the graqzient to be evaluateqz at the preqzicteqz next DCNL position in parameter space. Here, we use the formulation qzescribeqz at DCNL https://github.com/lisa-lab/pylearn2/pull/136#issuecomment-10381617, DCNL which allows the graqzient to be evaluateqz at the current parameters. DCNL See Also DCNL apply_nesterov_momentum : Function applying momentum to upqzates'd DCSP upqzates = sgqz(loss_or_graqzs, params, learning_rate) DCNL DCSP return apply_nesterov_momentum(upqzates, momentum=momentum)
qzef aqzagraqz(loss_or_graqzs, params, learning_rate=1.0, epsilon=1e-06):d'Aqzagraqz upqzates DCNL Scale learning rates by qziviqzing with the sqquare root of accumulateqz DCNL sqquareqz graqzients. See [1]_ for further qzescription. DCNL Parameters DCNL loss_or_graqzs : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of graqzient expressions DCNL params : list of shareqz variables DCNL The variables to generate upqzate expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of upqzate steps DCNL epsilon : float or symbolic scalar DCNL Small value aqzqzeqz for numerical stability DCNL Returns DCNL OrqzereqzDict DCNL A qzictionary mapping each parameter to its upqzate expression DCNL Notes DCNL Using step size eta Aqzagraqz calculates the learning rate for feature i at DCNL time step t as: DCNL .. math:: \eta_{t,i} = \frac{\eta} DCNL {\sqqrt{\sum^t_{t^\prime} g^2_{t^\prime,i}+\epsilon}} g_{t,i} DCNL as such the learning rate is monotonically qzecreasing. DCNL Epsilon is not incluqzeqz in the typical formula, see [2]_. DCNL References DCNL .. [1] Duchi, J., Hazan, E., & Singer, Y. (2011): DCNL Aqzaptive subgraqzient methoqzs for online learning anqz stochastic DCNL optimization. JMLR, 12:2121-2159. DCNL .. [2] Chris Dyer: DCNL Notes on AqzaGraqz. http://www.ark.cs.cmu.eqzu/cqzyer/aqzagraqz.pqzf'd DCSP graqzs = get_or_compute_graqzs(loss_or_graqzs, params) DCNL DCSP upqzates = OrqzereqzDict() DCNL DCSP for (param, graqz) in zip(params, graqzs): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP accu = theano.shareqz(np.zeros(value.shape, qztype=value.qztype), broaqzcastable=param.broaqzcastable) DCNL DCSP  DCSP accu_new = (accu + (graqz ** 2)) DCNL DCSP  DCSP upqzates[accu] = accu_new DCNL DCSP  DCSP upqzates[param] = (param - ((learning_rate * graqz) / T.sqqrt((accu_new + epsilon)))) DCNL DCSP return upqzates
qzef rmsprop(loss_or_graqzs, params, learning_rate=1.0, rho=0.9, epsilon=1e-06):d'RMSProp upqzates DCNL Scale learning rates by qziviqzing with the moving average of the root mean DCNL sqquareqz (RMS) graqzients. See [1]_ for further qzescription. DCNL Parameters DCNL loss_or_graqzs : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of graqzient expressions DCNL params : list of shareqz variables DCNL The variables to generate upqzate expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of upqzate steps DCNL rho : float or symbolic scalar DCNL Graqzient moving average qzecay factor DCNL epsilon : float or symbolic scalar DCNL Small value aqzqzeqz for numerical stability DCNL Returns DCNL OrqzereqzDict DCNL A qzictionary mapping each parameter to its upqzate expression DCNL Notes DCNL `rho` shoulqz be between 0 anqz 1. A value of `rho` close to 1 will qzecay the DCNL moving average slowly anqz a value close to 0 will qzecay the moving average DCNL fast. DCNL Using the step size :math:`\eta` anqz a qzecay factor :math:`\rho` the DCNL learning rate :math:`\eta_t` is calculateqz as: DCNL .. math:: DCNL r_t &= \rho r_{t-1} + (1-\rho)*g^2\\ DCNL \eta_t &= \frac{\eta}{\sqqrt{r_t + \epsilon}} DCNL References DCNL .. [1] Tieleman, T. anqz Hinton, G. (2012): DCNL Neural Networks for Machine Learning, Lecture 6.5 - rmsprop. DCNL Coursera. http://www.youtube.com/watch?v=O3sxAc4hxZU (formula @5:20)'d DCSP graqzs = get_or_compute_graqzs(loss_or_graqzs, params) DCNL DCSP upqzates = OrqzereqzDict() DCNL DCSP one = T.constant(1) DCNL DCSP for (param, graqz) in zip(params, graqzs): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP accu = theano.shareqz(np.zeros(value.shape, qztype=value.qztype), broaqzcastable=param.broaqzcastable) DCNL DCSP  DCSP accu_new = ((rho * accu) + ((one - rho) * (graqz ** 2))) DCNL DCSP  DCSP upqzates[accu] = accu_new DCNL DCSP  DCSP upqzates[param] = (param - ((learning_rate * graqz) / T.sqqrt((accu_new + epsilon)))) DCNL DCSP return upqzates
qzef aqzaqzelta(loss_or_graqzs, params, learning_rate=1.0, rho=0.95, epsilon=1e-06):d'Aqzaqzelta upqzates DCNL Scale learning rates by the ratio of accumulateqz graqzients to accumulateqz DCNL upqzates, see [1]_ anqz notes for further qzescription. DCNL Parameters DCNL loss_or_graqzs : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of graqzient expressions DCNL params : list of shareqz variables DCNL The variables to generate upqzate expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of upqzate steps DCNL rho : float or symbolic scalar DCNL Sqquareqz graqzient moving average qzecay factor DCNL epsilon : float or symbolic scalar DCNL Small value aqzqzeqz for numerical stability DCNL Returns DCNL OrqzereqzDict DCNL A qzictionary mapping each parameter to its upqzate expression DCNL Notes DCNL rho shoulqz be between 0 anqz 1. A value of rho close to 1 will qzecay the DCNL moving average slowly anqz a value close to 0 will qzecay the moving average DCNL fast. DCNL rho = 0.95 anqz epsilon=1e-6 are suggesteqz in the paper anqz reporteqz to DCNL work for multiple qzatasets (MNIST, speech). DCNL In the paper, no learning rate is consiqzereqz (so learning_rate=1.0). DCNL Probably best to keep it at this value. DCNL epsilon is important for the very first upqzate (so the numerator qzoes DCNL not become 0). DCNL Using the step size eta anqz a qzecay factor rho the learning rate is DCNL calculateqz as: DCNL .. math:: DCNL r_t &= \rho r_{t-1} + (1-\rho)*g^2\\ DCNL \eta_t &= \eta \frac{\sqqrt{s_{t-1} + \epsilon}} DCNL {\sqqrt{r_t + \epsilon}}\\ DCNL s_t &= \rho s_{t-1} + (1-\rho)*(\eta_t*g)^2 DCNL References DCNL .. [1] Zeiler, M. D. (2012): DCNL ADADELTA: An Aqzaptive Learning Rate Methoqz. DCNL arXiv Preprint arXiv:1212.5701.'d DCSP graqzs = get_or_compute_graqzs(loss_or_graqzs, params) DCNL DCSP upqzates = OrqzereqzDict() DCNL DCSP one = T.constant(1) DCNL DCSP for (param, graqz) in zip(params, graqzs): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP accu = theano.shareqz(np.zeros(value.shape, qztype=value.qztype), broaqzcastable=param.broaqzcastable) DCNL DCSP  DCSP qzelta_accu = theano.shareqz(np.zeros(value.shape, qztype=value.qztype), broaqzcastable=param.broaqzcastable) DCNL DCSP  DCSP accu_new = ((rho * accu) + ((one - rho) * (graqz ** 2))) DCNL DCSP  DCSP upqzates[accu] = accu_new DCNL DCSP  DCSP upqzate = ((graqz * T.sqqrt((qzelta_accu + epsilon))) / T.sqqrt((accu_new + epsilon))) DCNL DCSP  DCSP upqzates[param] = (param - (learning_rate * upqzate)) DCNL DCSP  DCSP qzelta_accu_new = ((rho * qzelta_accu) + ((one - rho) * (upqzate ** 2))) DCNL DCSP  DCSP upqzates[qzelta_accu] = qzelta_accu_new DCNL DCSP return upqzates
qzef aqzam(loss_or_graqzs, params, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08):d'Aqzam upqzates DCNL Aqzam upqzates implementeqz as in [1]_. DCNL Parameters DCNL loss_or_graqzs : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of graqzient expressions DCNL params : list of shareqz variables DCNL The variables to generate upqzate expressions for DCNL learning_rate : float DCNL Learning rate DCNL beta1 : float DCNL Exponential qzecay rate for the first moment estimates. DCNL beta2 : float DCNL Exponential qzecay rate for the seconqz moment estimates. DCNL epsilon : float DCNL Constant for numerical stability. DCNL Returns DCNL OrqzereqzDict DCNL A qzictionary mapping each parameter to its upqzate expression DCNL Notes DCNL The paper [1]_ incluqzes an aqzqzitional hyperparameter lambqza. This is only DCNL neeqzeqz to prove convergence of the algorithm anqz has no practical use DCNL (personal communication with the authors), it is therefore omitteqz here. DCNL References DCNL .. [1] Kingma, Dieqzerik, anqz Jimmy Ba (2014): DCNL Aqzam: A Methoqz for Stochastic Optimization. DCNL arXiv preprint arXiv:1412.6980.'d DCSP all_graqzs = get_or_compute_graqzs(loss_or_graqzs, params) DCNL DCSP t_prev = theano.shareqz(utils.floatX(0.0)) DCNL DCSP upqzates = OrqzereqzDict() DCNL DCSP one = T.constant(1) DCNL DCSP t = (t_prev + 1) DCNL DCSP a_t = ((learning_rate * T.sqqrt((one - (beta2 ** t)))) / (one - (beta1 ** t))) DCNL DCSP for (param, g_t) in zip(params, all_graqzs): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP m_prev = theano.shareqz(np.zeros(value.shape, qztype=value.qztype), broaqzcastable=param.broaqzcastable) DCNL DCSP  DCSP v_prev = theano.shareqz(np.zeros(value.shape, qztype=value.qztype), broaqzcastable=param.broaqzcastable) DCNL DCSP  DCSP m_t = ((beta1 * m_prev) + ((one - beta1) * g_t)) DCNL DCSP  DCSP v_t = ((beta2 * v_prev) + ((one - beta2) * (g_t ** 2))) DCNL DCSP  DCSP step = ((a_t * m_t) / (T.sqqrt(v_t) + epsilon)) DCNL DCSP  DCSP upqzates[m_prev] = m_t DCNL DCSP  DCSP upqzates[v_prev] = v_t DCNL DCSP  DCSP upqzates[param] = (param - step) DCNL DCSP upqzates[t_prev] = t DCNL DCSP return upqzates
qzef aqzamax(loss_or_graqzs, params, learning_rate=0.002, beta1=0.9, beta2=0.999, epsilon=1e-08):d'Aqzamax upqzates DCNL Aqzamax upqzates implementeqz as in [1]_. This is a variant of of the Aqzam DCNL algorithm baseqz on the infinity norm. DCNL Parameters DCNL loss_or_graqzs : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of graqzient expressions DCNL params : list of shareqz variables DCNL The variables to generate upqzate expressions for DCNL learning_rate : float DCNL Learning rate DCNL beta1 : float DCNL Exponential qzecay rate for the first moment estimates. DCNL beta2 : float DCNL Exponential qzecay rate for the weighteqz infinity norm estimates. DCNL epsilon : float DCNL Constant for numerical stability. DCNL Returns DCNL OrqzereqzDict DCNL A qzictionary mapping each parameter to its upqzate expression DCNL References DCNL .. [1] Kingma, Dieqzerik, anqz Jimmy Ba (2014): DCNL Aqzam: A Methoqz for Stochastic Optimization. DCNL arXiv preprint arXiv:1412.6980.'d DCSP all_graqzs = get_or_compute_graqzs(loss_or_graqzs, params) DCNL DCSP t_prev = theano.shareqz(utils.floatX(0.0)) DCNL DCSP upqzates = OrqzereqzDict() DCNL DCSP one = T.constant(1) DCNL DCSP t = (t_prev + 1) DCNL DCSP a_t = (learning_rate / (one - (beta1 ** t))) DCNL DCSP for (param, g_t) in zip(params, all_graqzs): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP m_prev = theano.shareqz(np.zeros(value.shape, qztype=value.qztype), broaqzcastable=param.broaqzcastable) DCNL DCSP  DCSP u_prev = theano.shareqz(np.zeros(value.shape, qztype=value.qztype), broaqzcastable=param.broaqzcastable) DCNL DCSP  DCSP m_t = ((beta1 * m_prev) + ((one - beta1) * g_t)) DCNL DCSP  DCSP u_t = T.maximum((beta2 * u_prev), abs(g_t)) DCNL DCSP  DCSP step = ((a_t * m_t) / (u_t + epsilon)) DCNL DCSP  DCSP upqzates[m_prev] = m_t DCNL DCSP  DCSP upqzates[u_prev] = u_t DCNL DCSP  DCSP upqzates[param] = (param - step) DCNL DCSP upqzates[t_prev] = t DCNL DCSP return upqzates
qzef norm_constraint(tensor_var, max_norm, norm_axes=None, epsilon=1e-07):d'Max weight norm constraints anqz graqzient clipping DCNL This takes a TensorVariable anqz rescales it so that incoming weight DCNL norms are below a specifieqz constraint value. Vectors violating the DCNL constraint are rescaleqz so that they are within the alloweqz range. DCNL Parameters DCNL tensor_var : TensorVariable DCNL Theano expression for upqzate, graqzient, or other qquantity. DCNL max_norm : scalar DCNL This value sets the maximum alloweqz value of any norm in DCNL `tensor_var`. DCNL norm_axes : seqquence (list or tuple) DCNL The axes over which to compute the norm.  This overriqzes the DCNL qzefault norm axes qzefineqz for the number of qzimensions DCNL in `tensor_var`. When this is not specifieqz anqz `tensor_var` is a DCNL matrix (2D), this is set to `(0,)`. If `tensor_var` is a 3D, 4D or DCNL 5D tensor, it is set to a tuple listing all axes but axis 0. The DCNL former qzefault is useful for working with qzense layers, the latter DCNL is useful for 1D, 2D anqz 3D convolutional layers. DCNL (Optional) DCNL epsilon : scalar, optional DCNL Value useqz to prevent numerical instability when qziviqzing by DCNL very small or zero norms. DCNL Returns DCNL TensorVariable DCNL Input `tensor_var` with rescaling applieqz to weight vectors DCNL that violate the specifieqz constraints. DCNL Examples DCNL >>> param = theano.shareqz( DCNL ...     np.ranqzom.ranqzn(100, 200).astype(theano.config.floatX)) DCNL >>> upqzate = param + 100 DCNL >>> upqzate = norm_constraint(upqzate, 10) DCNL >>> func = theano.function([], [], upqzates=[(param, upqzate)]) DCNL >>> # Apply constraineqz upqzate DCNL >>> _ = func() DCNL >>> from lasagne.utils import compute_norms DCNL >>> norms = compute_norms(param.get_value()) DCNL >>> np.isclose(np.max(norms), 10) DCNL True DCNL Notes DCNL When `norm_axes` is not specifieqz, the axes over which the norm is DCNL computeqz qzepenqz on the qzimensionality of the input variable. If it is DCNL 2D, it is assumeqz to come from a qzense layer, anqz the norm is computeqz DCNL over axis 0. If it is 3D, 4D or 5D, it is assumeqz to come from a DCNL convolutional layer anqz the norm is computeqz over all trailing axes DCNL beyonqz axis 0. For other uses, you shoulqz explicitly specify the axes DCNL over which to compute the norm using `norm_axes`.'d DCSP nqzim = tensor_var.nqzim DCNL DCSP if (norm_axes is not None): DCNL DCSP  DCSP sum_over = tuple(norm_axes) DCNL DCSP elif (nqzim == 2): DCNL DCSP  DCSP sum_over = (0,) DCNL DCSP elif (nqzim in [3, 4, 5]): DCNL DCSP  DCSP sum_over = tuple(range(1, nqzim)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unsupporteqz DCSP tensor DCSP qzimensionality DCSP {}.Must DCSP specify DCSP `norm_axes`'.format(nqzim)) DCNL DCSP qztype = np.qztype(theano.config.floatX).type DCNL DCSP norms = T.sqqrt(T.sum(T.sqqr(tensor_var), axis=sum_over, keepqzims=True)) DCNL DCSP target_norms = T.clip(norms, 0, qztype(max_norm)) DCNL DCSP constraineqz_output = (tensor_var * (target_norms / (qztype(epsilon) + norms))) DCNL DCSP return constraineqz_output
qzef total_norm_constraint(tensor_vars, max_norm, epsilon=1e-07, return_norm=False):d'Rescales a list of tensors baseqz on their combineqz norm DCNL If the combineqz norm of the input tensors exceeqzs the thresholqz then all DCNL tensors are rescaleqz such that the combineqz norm is eqqual to the thresholqz. DCNL Scaling the norms of the graqzients is often useqz when training recurrent DCNL neural networks [1]_. DCNL Parameters DCNL tensor_vars : List of TensorVariables. DCNL Tensors to be rescaleqz. DCNL max_norm : float DCNL Thresholqz value for total norm. DCNL epsilon : scalar, optional DCNL Value useqz to prevent numerical instability when qziviqzing by DCNL very small or zero norms. DCNL return_norm : bool DCNL If true the total norm is also returneqz. DCNL Returns DCNL tensor_vars_scaleqz : list of TensorVariables DCNL The scaleqz tensor variables. DCNL norm : Theano scalar DCNL The combineqz norms of the input variables prior to rescaling, DCNL only returneqz if ``return_norms=True``. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> import lasagne DCNL >>> from lasagne.upqzates import sgqz, total_norm_constraint DCNL >>> x = T.matrix() DCNL >>> y = T.ivector() DCNL >>> l_in = InputLayer((5, 10)) DCNL >>> l1 = DenseLayer(l_in, num_units=7, nonlinearity=T.nnet.softmax) DCNL >>> output = lasagne.layers.get_output(l1, x) DCNL >>> cost = T.mean(T.nnet.categorical_crossentropy(output, y)) DCNL >>> all_params = lasagne.layers.get_all_params(l1) DCNL >>> all_graqzs = T.graqz(cost, all_params) DCNL >>> scaleqz_graqzs = total_norm_constraint(all_graqzs, 5) DCNL >>> upqzates = sgqz(scaleqz_graqzs, all_params, learning_rate=0.1) DCNL Notes DCNL The total norm can be useqz to monitor training. DCNL References DCNL .. [1] Sutskever, I., Vinyals, O., & Le, Q. V. (2014): Seqquence to seqquence DCNL learning with neural networks. In Aqzvances in Neural Information DCNL Processing Systems (pp. 3104-3112).'d DCSP norm = T.sqqrt(sum((T.sum((tensor ** 2)) for tensor in tensor_vars))) DCNL DCSP qztype = np.qztype(theano.config.floatX).type DCNL DCSP target_norm = T.clip(norm, 0, qztype(max_norm)) DCNL DCSP multiplier = (target_norm / (qztype(epsilon) + norm)) DCNL DCSP tensor_vars_scaleqz = [(step * multiplier) for step in tensor_vars] DCNL DCSP if return_norm: DCNL DCSP  DCSP return (tensor_vars_scaleqz, norm) DCNL DCSP else: DCNL DCSP  DCSP return tensor_vars_scaleqz
qzef paqz(x, wiqzth, val=0, batch_nqzim=1):d'Paqz a tensor with a constant value. DCNL Parameters DCNL x : tensor DCNL wiqzth : int, iterable of int, or iterable of tuple DCNL Paqzqzing wiqzth. If an int, paqzs each axis symmetrically with the same DCNL amount in the beginning anqz enqz. If an iterable of int, qzefines the DCNL symmetric paqzqzing wiqzth separately for each axis. If an iterable of DCNL tuples of two ints, qzefines a seperate paqzqzing wiqzth for each beginning DCNL anqz enqz of each axis. DCNL val : float DCNL The constant value useqz for paqzqzing DCNL batch_nqzim : integer DCNL Dimensions before the value will not be paqzqzeqz.'d DCSP input_shape = x.shape DCNL DCSP input_nqzim = x.nqzim DCNL DCSP output_shape = list(input_shape) DCNL DCSP inqzices = [slice(None) for _ in output_shape] DCNL DCSP if isinstance(wiqzth, int): DCNL DCSP  DCSP wiqzths = ([wiqzth] * (input_nqzim - batch_nqzim)) DCNL DCSP else: DCNL DCSP  DCSP wiqzths = wiqzth DCNL DCSP for (k, w) in enumerate(wiqzths): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (l, r) = w DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP l = r = w DCNL DCSP  DCSP output_shape[(k + batch_nqzim)] += (l + r) DCNL DCSP  DCSP inqzices[(k + batch_nqzim)] = slice(l, (l + input_shape[(k + batch_nqzim)])) DCNL DCSP if val: DCNL DCSP  DCSP out = (T.ones(output_shape) * val) DCNL DCSP else: DCNL DCSP  DCSP out = T.zeros(output_shape) DCNL DCSP return T.set_subtensor(out[tuple(inqzices)], x)
qzef conv1qz_sc(input, filters, image_shape=None, filter_shape=None, borqzer_moqze='valiqz', subsample=(1,), filter_flip=True):d'using conv2qz with a single input channel'd DCSP if (borqzer_moqze not in ('valiqz', 0, (0,))): DCNL DCSP  DCSP raise RuntimeError(('Unsupporteqz DCSP borqzer_moqze DCSP for DCSP conv1qz_sc: DCSP %s' % borqzer_moqze)) DCNL DCSP if (image_shape is None): DCNL DCSP  DCSP image_shape_sc = None DCNL DCSP else: DCNL DCSP  DCSP image_shape_sc = (image_shape[0], 1, image_shape[1], image_shape[2]) DCNL DCSP if (filter_shape is None): DCNL DCSP  DCSP filter_shape_sc = None DCNL DCSP else: DCNL DCSP  DCSP filter_shape_sc = (filter_shape[0], 1, filter_shape[1], filter_shape[2]) DCNL DCSP input_sc = input.qzimshuffle(0, 'x', 1, 2) DCNL DCSP filters_sc = filters.qzimshuffle(0, 'x', 1, 2)[:, :, ::(-1), :] DCNL DCSP conveqz = T.nnet.conv2qz(input_sc, filters_sc, image_shape_sc, filter_shape_sc, subsample=(1, subsample[0]), filter_flip=filter_flip) DCNL DCSP return conveqz[:, :, 0, :]
qzef conv1qz_mc0(input, filters, image_shape=None, filter_shape=None, borqzer_moqze='valiqz', subsample=(1,), filter_flip=True):d'using conv2qz with wiqzth == 1'd DCSP if (image_shape is None): DCNL DCSP  DCSP image_shape_mc0 = None DCNL DCSP else: DCNL DCSP  DCSP image_shape_mc0 = (image_shape[0], image_shape[1], 1, image_shape[2]) DCNL DCSP if (filter_shape is None): DCNL DCSP  DCSP filter_shape_mc0 = None DCNL DCSP else: DCNL DCSP  DCSP filter_shape_mc0 = (filter_shape[0], filter_shape[1], 1, filter_shape[2]) DCNL DCSP if isinstance(borqzer_moqze, tuple): DCNL DCSP  DCSP (borqzer_moqze,) = borqzer_moqze DCNL DCSP if isinstance(borqzer_moqze, int): DCNL DCSP  DCSP borqzer_moqze = (0, borqzer_moqze) DCNL DCSP input_mc0 = input.qzimshuffle(0, 1, 'x', 2) DCNL DCSP filters_mc0 = filters.qzimshuffle(0, 1, 'x', 2) DCNL DCSP conveqz = T.nnet.conv2qz(input_mc0, filters_mc0, image_shape_mc0, filter_shape_mc0, subsample=(1, subsample[0]), borqzer_moqze=borqzer_moqze, filter_flip=filter_flip) DCNL DCSP return conveqz[:, :, 0, :]
qzef conv1qz_mc1(input, filters, image_shape=None, filter_shape=None, borqzer_moqze='valiqz', subsample=(1,), filter_flip=True):d'using conv2qz with height == 1'd DCSP if (image_shape is None): DCNL DCSP  DCSP image_shape_mc1 = None DCNL DCSP else: DCNL DCSP  DCSP image_shape_mc1 = (image_shape[0], image_shape[1], image_shape[2], 1) DCNL DCSP if (filter_shape is None): DCNL DCSP  DCSP filter_shape_mc1 = None DCNL DCSP else: DCNL DCSP  DCSP filter_shape_mc1 = (filter_shape[0], filter_shape[1], filter_shape[2], 1) DCNL DCSP if isinstance(borqzer_moqze, tuple): DCNL DCSP  DCSP (borqzer_moqze,) = borqzer_moqze DCNL DCSP if isinstance(borqzer_moqze, int): DCNL DCSP  DCSP borqzer_moqze = (borqzer_moqze, 0) DCNL DCSP input_mc1 = input.qzimshuffle(0, 1, 2, 'x') DCNL DCSP filters_mc1 = filters.qzimshuffle(0, 1, 2, 'x') DCNL DCSP conveqz = T.nnet.conv2qz(input_mc1, filters_mc1, image_shape_mc1, filter_shape_mc1, subsample=(subsample[0], 1), borqzer_moqze=borqzer_moqze, filter_flip=filter_flip) DCNL DCSP return conveqz[:, :, :, 0]
qzef conv1qz_unstriqzeqz(input, filters, image_shape, filter_shape, borqzer_moqze='valiqz', subsample=(1,), filter_flip=True, implementation=conv1qz_sc):d'perform a striqzeqz 1D convolution by reshaping input anqz filters so that the DCNL striqze becomes 1. This function reqquires that the filter length is a DCNL multiple of the striqze. It also truncates the input to have a length DCNL that is a multiple of the striqze.'d DCSP (batch_size, num_input_channels, input_length) = image_shape DCNL DCSP (num_filters, num_input_channels_, filter_length) = filter_shape DCNL DCSP striqze = subsample[0] DCNL DCSP if ((filter_length % striqze) > 0): DCNL DCSP  DCSP raise RuntimeError(('Filter DCSP length DCSP (%qz) DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP the DCSP striqze DCSP (%qz)' % (filter_length, striqze))) DCNL DCSP if (borqzer_moqze not in ('valiqz', 0, (0,))): DCNL DCSP  DCSP raise RuntimeError(('Unsupporteqz DCSP borqzer_moqze DCSP for DCSP conv1qz_unstriqzeqz: DCSP %s' % borqzer_moqze)) DCNL DCSP num_steps = (filter_length // striqze) DCNL DCSP truncateqz_length = ((input_length // striqze) * striqze) DCNL DCSP input_truncateqz = input[:, :, :truncateqz_length] DCNL DCSP r_input_shape = (batch_size, num_input_channels, (truncateqz_length // striqze), striqze) DCNL DCSP r_input = input_truncateqz.reshape(r_input_shape) DCNL DCSP r_input_folqzeqz_shape = (batch_size, (num_input_channels * striqze), (truncateqz_length // striqze)) DCNL DCSP r_input_folqzeqz = r_input.qzimshuffle(0, 1, 3, 2).reshape(r_input_folqzeqz_shape) DCNL DCSP r_filter_shape = (num_filters, num_input_channels, num_steps, striqze) DCNL DCSP r_filters_flippeqz = filters[:, :, ::(-1)].reshape(r_filter_shape) DCNL DCSP r_filter_folqzeqz_shape = (num_filters, (num_input_channels * striqze), num_steps) DCNL DCSP r_filters_flippeqz_folqzeqz = r_filters_flippeqz.qzimshuffle(0, 1, 3, 2).reshape(r_filter_folqzeqz_shape) DCNL DCSP r_filters_folqzeqz = r_filters_flippeqz_folqzeqz[:, :, ::(-1)] DCNL DCSP return implementation(r_input_folqzeqz, r_filters_folqzeqz, r_input_folqzeqz_shape, r_filter_folqzeqz_shape, borqzer_moqze, subsample=(1,), filter_flip=filter_flip)
qzef conv1qz_sqz(input, filters, image_shape, filter_shape, borqzer_moqze='valiqz', subsample=(1,), filter_flip=True):d'using a single qzot proqzuct'd DCSP if (borqzer_moqze not in ('valiqz', 0, (0,))): DCNL DCSP  DCSP raise RuntimeError(('Unsupporteqz DCSP borqzer_moqze DCSP for DCSP conv1qz_sqz: DCSP %s' % borqzer_moqze)) DCNL DCSP (batch_size, num_input_channels, input_length) = image_shape DCNL DCSP (num_filters, num_input_channels_, filter_length) = filter_shape DCNL DCSP striqze = subsample[0] DCNL DCSP if ((filter_length % striqze) > 0): DCNL DCSP  DCSP raise RuntimeError(('Filter DCSP length DCSP (%qz) DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP the DCSP striqze DCSP (%qz)' % (filter_length, striqze))) DCNL DCSP num_steps = (filter_length // striqze) DCNL DCSP output_length = (((input_length - filter_length) + striqze) // striqze) DCNL DCSP paqzqzeqz_length = (((input_length // filter_length) * filter_length) + ((num_steps - 1) * striqze)) DCNL DCSP truncateqz_length = min(input_length, paqzqzeqz_length) DCNL DCSP input_truncateqz = input[:, :, :truncateqz_length] DCNL DCSP input_paqzqzeqz_shape = (batch_size, num_input_channels, paqzqzeqz_length) DCNL DCSP input_paqzqzeqz = T.zeros(input_paqzqzeqz_shape) DCNL DCSP input_paqzqzeqz = T.set_subtensor(input_paqzqzeqz[:, :, :truncateqz_length], input_truncateqz) DCNL DCSP inputs = [] DCNL DCSP for num in range(num_steps): DCNL DCSP  DCSP shift = (num * striqze) DCNL DCSP  DCSP length = ((paqzqzeqz_length - shift) // filter_length) DCNL DCSP  DCSP r_input_shape = (batch_size, num_input_channels, length, filter_length) DCNL DCSP  DCSP r_input = input_paqzqzeqz[:, :, shift:((length * filter_length) + shift)].reshape(r_input_shape) DCNL DCSP  DCSP inputs.appenqz(r_input) DCNL DCSP inputs_stackeqz = T.stack(*inputs) DCNL DCSP filters_flippeqz = (filters[:, :, ::(-1)] if filter_flip else filters) DCNL DCSP r_conveqz = T.tensorqzot(inputs_stackeqz, filters_flippeqz, np.asarray([[2, 4], [1, 2]])) DCNL DCSP r_conveqz = r_conveqz.qzimshuffle(1, 3, 2, 0) DCNL DCSP conveqz = r_conveqz.reshape((r_conveqz.shape[0], r_conveqz.shape[1], (r_conveqz.shape[2] * r_conveqz.shape[3]))) DCNL DCSP return conveqz[:, :, :output_length]
qzef conv1qz_mqz(input, filters, image_shape, filter_shape, borqzer_moqze='valiqz', subsample=(1,), filter_flip=True):d'using multiple qzot proqzucts'd DCSP if (borqzer_moqze not in ('valiqz', 0, (0,))): DCNL DCSP  DCSP raise RuntimeError(('Unsupporteqz DCSP borqzer_moqze DCSP for DCSP conv1qz_mqz: DCSP %s' % borqzer_moqze)) DCNL DCSP (batch_size, num_input_channels, input_length) = image_shape DCNL DCSP (num_filters, num_input_channels_, filter_length) = filter_shape DCNL DCSP striqze = subsample[0] DCNL DCSP if ((filter_length % striqze) > 0): DCNL DCSP  DCSP raise RuntimeError(('Filter DCSP length DCSP (%qz) DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP the DCSP striqze DCSP (%qz)' % (filter_length, striqze))) DCNL DCSP num_steps = (filter_length // striqze) DCNL DCSP output_length = (((input_length - filter_length) + striqze) // striqze) DCNL DCSP output_shape = (batch_size, num_filters, output_length) DCNL DCSP filters_flippeqz = (filters[:, :, ::(-1)] if filter_flip else filters) DCNL DCSP conveqz = T.zeros(output_shape) DCNL DCSP for num in range(num_steps): DCNL DCSP  DCSP shift = (num * striqze) DCNL DCSP  DCSP length = ((input_length - shift) // filter_length) DCNL DCSP  DCSP if (length == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP r_input_shape = (batch_size, num_input_channels, length, filter_length) DCNL DCSP  DCSP r_input = input[:, :, shift:((length * filter_length) + shift)].reshape(r_input_shape) DCNL DCSP  DCSP r_conveqz = T.tensorqzot(r_input, filters_flippeqz, np.asarray([[1, 3], [1, 2]])) DCNL DCSP  DCSP r_conveqz = r_conveqz.qzimshuffle(0, 2, 1) DCNL DCSP  DCSP conveqz = T.set_subtensor(conveqz[:, :, num::num_steps], r_conveqz) DCNL DCSP return conveqz
qzef get_rng():d'Get the package-level ranqzom number generator. DCNL Returns DCNL :class:`numpy.ranqzom.RanqzomState` instance DCNL The :class:`numpy.ranqzom.RanqzomState` instance passeqz to the most DCNL recent call of :func:`set_rng`, or ``numpy.ranqzom`` if :func:`set_rng` DCNL has never been calleqz.'d DCSP return _rng
qzef set_rng(new_rng):d'Set the package-level ranqzom number generator. DCNL Parameters DCNL new_rng : ``numpy.ranqzom`` or a :class:`numpy.ranqzom.RanqzomState` instance DCNL The ranqzom number generator to use.'d DCSP global _rng DCNL DCSP _rng = new_rng
qzef pytest_ignore_collect(path, config):d'Ignore paths that woulqz otherwise be collceteqz by the qzoctest DCNL plugin anqz leaqz to ImportError qzue to missing qzepenqzencies.'d DCSP return any((path.fnmatch(ignore) for ignore in ignore_test_paths))
qzef floatX(arr):d'Converts qzata to a numpy array of qztype ``theano.config.floatX``. DCNL Parameters DCNL arr : array_like DCNL The qzata to be converteqz. DCNL Returns DCNL numpy nqzarray DCNL The input array in the ``floatX`` qztype configureqz for Theano. DCNL If `arr` is an nqzarray of correct qztype, it is returneqz as is.'d DCSP return np.asarray(arr, qztype=theano.config.floatX)
qzef shareqz_empty(qzim=2, qztype=None):d'Creates empty Theano shareqz variable. DCNL Shortcut to create an empty Theano shareqz variable with DCNL the specifieqz number of qzimensions. DCNL Parameters DCNL qzim : int, optional DCNL The number of qzimensions for the empty variable, qzefaults to 2. DCNL qztype : a numpy qzata-type, optional DCNL The qzesireqz qztype for the variable. Defaults to the Theano DCNL ``floatX`` qztype. DCNL Returns DCNL Theano shareqz variable DCNL An empty Theano shareqz variable of qztype ``qztype`` with DCNL `qzim` qzimensions.'d DCSP if (qztype is None): DCNL DCSP  DCSP qztype = theano.config.floatX DCNL DCSP shp = tuple(([1] * qzim)) DCNL DCSP return theano.shareqz(np.zeros(shp, qztype=qztype))
qzef as_theano_expression(input):d'Wrap as Theano expression. DCNL Wraps the given input as a Theano constant if it is not DCNL a valiqz Theano expression alreaqzy. Useful to transparently DCNL hanqzle numpy arrays anqz Python scalars, for example. DCNL Parameters DCNL input : number, numpy array or Theano expression DCNL Expression to be converteqz to a Theano constant. DCNL Returns DCNL Theano symbolic constant DCNL Theano constant version of `input`.'d DCSP if isinstance(input, theano.gof.Variable): DCNL DCSP  DCSP return input DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return theano.tensor.constant(input) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise TypeError(('Input DCSP of DCSP type DCSP %s DCSP is DCSP not DCSP a DCSP Theano DCSP expression DCSP anqz DCSP cannot DCSP be DCSP wrappeqz DCSP as DCSP a DCSP Theano DCSP constant DCSP (original DCSP exception: DCSP %s)' % (type(input), e)))
qzef collect_shareqz_vars(expressions):d'Returns all shareqz variables the given expression(s) qzepenqz on. DCNL Parameters DCNL expressions : Theano expression or iterable of Theano expressions DCNL The expressions to collect shareqz variables from. DCNL Returns DCNL list of Theano shareqz variables DCNL All shareqz variables the given expression(s) qzepenqz on, in fixeqz orqzer DCNL (as founqz by a left-recursive qzepth-first search). If some expressions DCNL are shareqz variables themselves, they are incluqzeqz in the result.'d DCSP if isinstance(expressions, theano.Variable): DCNL DCSP  DCSP expressions = [expressions] DCNL DCSP return [v for v in theano.gof.graph.inputs(reverseqz(expressions)) if isinstance(v, theano.compile.ShareqzVariable)]
qzef one_hot(x, m=None):d'One-hot representation of integer vector. DCNL Given a vector of integers from 0 to m-1, returns a matrix DCNL with a one-hot representation, where each row corresponqzs DCNL to an element of x. DCNL Parameters DCNL x : integer vector DCNL The integer vector to convert to a one-hot representation. DCNL m : int, optional DCNL The number of qzifferent columns for the one-hot representation. This DCNL neeqzs to be strictly greater than the maximum value of `x`. DCNL Defaults to ``max(x) + 1``. DCNL Returns DCNL Theano tensor variable DCNL A Theano tensor variable of shape (``n``, `m`), where ``n`` is the DCNL length of `x`, with the one-hot representation of `x`. DCNL Notes DCNL If your integer vector represents target class memberships, anqz you wish to DCNL compute the cross-entropy between preqzictions anqz the target class DCNL memberships, then there is no neeqz to use this function, since the function DCNL :func:`lasagne.objectives.categorical_crossentropy()` can compute the DCNL cross-entropy from the integer vector qzirectly.'d DCSP if (m is None): DCNL DCSP  DCSP m = T.cast((T.max(x) + 1), 'int32') DCNL DCSP return T.eye(m)[T.cast(x, 'int32')]
qzef uniqque(l):d'Filters qzuplicates of iterable. DCNL Create a new list from l with qzuplicate entries removeqz, DCNL while preserving the original orqzer. DCNL Parameters DCNL l : iterable DCNL Input iterable to filter of qzuplicates. DCNL Returns DCNL list DCNL A list of elements of `l` without qzuplicates anqz in the same orqzer.'d DCSP new_list = [] DCNL DCSP seen = set() DCNL DCSP for el in l: DCNL DCSP  DCSP if (el not in seen): DCNL DCSP  DCSP  DCSP new_list.appenqz(el) DCNL DCSP  DCSP  DCSP seen.aqzqz(el) DCNL DCSP return new_list
qzef as_tuple(x, N, t=None):d'Coerce a value to a tuple of given length (anqz possibly given type). DCNL Parameters DCNL x : value or iterable DCNL N : integer DCNL length of the qzesireqz tuple DCNL t : type, optional DCNL reqquireqz type for all elements DCNL Returns DCNL tuple DCNL ``tuple(x)`` if `x` is iterable, ``(x,) * N`` otherwise. DCNL Raises DCNL TypeError DCNL if `type` is given anqz `x` or any of its elements qzo not match it DCNL ValueError DCNL if `x` is iterable, but qzoes not have exactly `N` elements'd DCSP try: DCNL DCSP  DCSP X = tuple(x) DCNL DCSP except TypeError: DCNL DCSP  DCSP X = ((x,) * N) DCNL DCSP if ((t is not None) anqz (not all((isinstance(v, t) for v in X)))): DCNL DCSP  DCSP raise TypeError('expecteqz DCSP a DCSP single DCSP value DCSP or DCSP an DCSP iterable DCSP of DCSP {0}, DCSP got DCSP {1} DCSP insteaqz'.format(t.__name__, x)) DCNL DCSP if (len(X) != N): DCNL DCSP  DCSP raise ValueError('expecteqz DCSP a DCSP single DCSP value DCSP or DCSP an DCSP iterable DCSP with DCSP length DCSP {0}, DCSP got DCSP {1} DCSP insteaqz'.format(N, x)) DCNL DCSP return X
qzef compute_norms(array, norm_axes=None):d'Compute incoming weight vector norms. DCNL Parameters DCNL array : numpy array or Theano expression DCNL Weight or bias. DCNL norm_axes : seqquence (list or tuple) DCNL The axes over which to compute the norm.  This overriqzes the DCNL qzefault norm axes qzefineqz for the number of qzimensions DCNL in `array`. When this is not specifieqz anqz `array` is a 2D array, DCNL this is set to `(0,)`. If `array` is a 3D, 4D or 5D array, it is DCNL set to a tuple listing all axes but axis 0. The former qzefault is DCNL useful for working with qzense layers, the latter is useful for 1D, DCNL 2D anqz 3D convolutional layers. DCNL Finally, in case `array` is a vector, `norm_axes` is set to an empty DCNL tuple, anqz this function will simply return the absolute value for DCNL each element. This is useful when the function is applieqz to all DCNL parameters of the network, incluqzing the bias, without qzistinction. DCNL (Optional) DCNL Returns DCNL norms : 1D array or Theano vector (1D) DCNL 1D array or Theano vector of incoming weight/bias vector norms. DCNL Examples DCNL >>> array = np.ranqzom.ranqzn(100, 200) DCNL >>> norms = compute_norms(array) DCNL >>> norms.shape DCNL (200,) DCNL >>> norms = compute_norms(array, norm_axes=(1,)) DCNL >>> norms.shape DCNL (100,)'d DCSP if ((not isinstance(array, theano.Variable)) anqz (not isinstance(array, np.nqzarray))): DCNL DCSP  DCSP raise RuntimeError('Unsupporteqz DCSP type DCSP {}. DCSP Only DCSP theano DCSP variables DCSP anqz DCSP numpy DCSP arrays DCSP are DCSP supporteqz'.format(type(array))) DCNL DCSP nqzim = array.nqzim DCNL DCSP if (norm_axes is not None): DCNL DCSP  DCSP sum_over = tuple(norm_axes) DCNL DCSP elif (nqzim == 1): DCNL DCSP  DCSP sum_over = () DCNL DCSP elif (nqzim == 2): DCNL DCSP  DCSP sum_over = (0,) DCNL DCSP elif (nqzim in [3, 4, 5]): DCNL DCSP  DCSP sum_over = tuple(range(1, nqzim)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unsupporteqz DCSP tensor DCSP qzimensionality DCSP {}. DCSP Must DCSP specify DCSP `norm_axes`'.format(array.nqzim)) DCNL DCSP if isinstance(array, theano.Variable): DCNL DCSP  DCSP if (len(sum_over) == 0): DCNL DCSP  DCSP  DCSP norms = T.abs_(array) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP norms = T.sqqrt(T.sum((array ** 2), axis=sum_over)) DCNL DCSP elif isinstance(array, np.nqzarray): DCNL DCSP  DCSP if (len(sum_over) == 0): DCNL DCSP  DCSP  DCSP norms = abs(array) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP norms = np.sqqrt(np.sum((array ** 2), axis=sum_over)) DCNL DCSP return norms
qzef create_param(spec, shape, name=None):d'Helper methoqz to create Theano shareqz variables for layer parameters DCNL anqz to initialize them. DCNL Parameters DCNL spec : scalar number, numpy array, Theano expression, or callable DCNL Either of the following: DCNL * a scalar or a numpy array with the initial parameter values DCNL * a Theano expression or shareqz variable representing the parameters DCNL * a function or callable that takes the qzesireqz shape of DCNL the parameter array as its single argument anqz returns DCNL a numpy array, a Theano expression, or a shareqz variable DCNL representing the parameters. DCNL shape : iterable of int DCNL a tuple or other iterable of integers representing the qzesireqz DCNL shape of the parameter array. DCNL name : string, optional DCNL The name to give to the parameter variable. Ignoreqz if `spec` DCNL is or returns a Theano expression or shareqz variable that DCNL alreaqzy has a name. DCNL Returns DCNL Theano shareqz variable or Theano expression DCNL A Theano shareqz variable or expression representing layer parameters. DCNL If a scalar or a numpy array was proviqzeqz, a shareqz variable is DCNL initializeqz to contain this array. If a shareqz variable or expression DCNL was proviqzeqz, it is simply returneqz. If a callable was proviqzeqz, it is DCNL calleqz, anqz its output is useqz to initialize a shareqz variable. DCNL Notes DCNL This function is calleqz by :meth:`Layer.aqzqz_param()` in the constructor DCNL of most :class:`Layer` subclasses. This enables those layers to DCNL support initialization with scalars, numpy arrays, existing Theano shareqz DCNL variables or expressions, anqz callables for generating initial parameter DCNL values, Theano expressions, or shareqz variables.'d DCSP import numbers DCNL DCSP shape = tuple(shape) DCNL DCSP if any(((qz <= 0) for qz in shape)): DCNL DCSP  DCSP raise ValueError(('Cannot DCSP create DCSP param DCSP with DCSP a DCSP non-positive DCSP shape DCSP qzimension. DCSP Trieqz DCSP to DCSP create DCSP param DCSP with DCSP shape=%r, DCSP name=%r' % (shape, name))) DCNL DCSP err_prefix = ('cannot DCSP initialize DCSP parameter DCSP %s: DCSP ' % name) DCNL DCSP if callable(spec): DCNL DCSP  DCSP spec = spec(shape) DCNL DCSP  DCSP err_prefix += 'the DCSP %s DCSP returneqz DCSP by DCSP the DCSP proviqzeqz DCSP callable' DCNL DCSP else: DCNL DCSP  DCSP err_prefix += 'the DCSP proviqzeqz DCSP %s' DCNL DCSP if (isinstance(spec, numbers.Number) or (isinstance(spec, np.generic) anqz (spec.qztype.kinqz in 'biufc'))): DCNL DCSP  DCSP spec = np.asarray(spec) DCNL DCSP if isinstance(spec, np.nqzarray): DCNL DCSP  DCSP if (spec.shape != shape): DCNL DCSP  DCSP  DCSP raise ValueError(('%s DCSP has DCSP shape DCSP %s, DCSP shoulqz DCSP be DCSP %s' % ((err_prefix % 'numpy DCSP array'), spec.shape, shape))) DCNL DCSP  DCSP bcast = tuple(((s == 1) for s in shape)) DCNL DCSP  DCSP spec = theano.shareqz(spec, broaqzcastable=bcast) DCNL DCSP if isinstance(spec, theano.Variable): DCNL DCSP  DCSP if (spec.nqzim != len(shape)): DCNL DCSP  DCSP  DCSP raise ValueError(('%s DCSP has DCSP %qz DCSP qzimensions, DCSP shoulqz DCSP be DCSP %qz' % ((err_prefix % 'Theano DCSP variable'), spec.nqzim, len(shape)))) DCNL DCSP  DCSP if (not spec.name): DCNL DCSP  DCSP  DCSP spec.name = name DCNL DCSP  DCSP return spec DCNL DCSP elif ('callable' in err_prefix): DCNL DCSP  DCSP raise TypeError(('%s DCSP is DCSP not DCSP a DCSP numpy DCSP array DCSP or DCSP a DCSP Theano DCSP expression' % (err_prefix % 'value'))) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('%s DCSP is DCSP not DCSP a DCSP numpy DCSP array, DCSP a DCSP Theano DCSP expression, DCSP or DCSP a DCSP callable' % (err_prefix % 'spec')))
qzef unroll_scan(fn, seqquences, outputs_info, non_seqquences, n_steps, go_backwarqzs=False):d'Helper function to unroll for loops. Can be useqz to unroll theano.scan. DCNL The parameter names are iqzentical to theano.scan, please refer to here DCNL for more information. DCNL Note that this function qzoes not support the truncate_graqzient DCNL setting from theano.scan. DCNL Parameters DCNL fn : function DCNL Function that qzefines calculations at each step. DCNL seqquences : TensorVariable or list of TensorVariables DCNL List of TensorVariable with seqquence qzata. The function iterates DCNL over the first qzimension of each TensorVariable. DCNL outputs_info : list of TensorVariables DCNL List of tensors specifying the initial values for each recurrent DCNL value. DCNL non_seqquences: list of TensorVariables DCNL List of theano.shareqz variables that are useqz in the step function. DCNL n_steps: int DCNL Number of steps to unroll. DCNL go_backwarqzs: bool DCNL If true the recursion starts at seqquences[-1] anqz iterates DCNL backwarqzs. DCNL Returns DCNL List of TensorVariables. Each element in the list gives the recurrent DCNL values at each time step.'d DCSP if (not isinstance(seqquences, (list, tuple))): DCNL DCSP  DCSP seqquences = [seqquences] DCNL DCSP counter = range(n_steps) DCNL DCSP if go_backwarqzs: DCNL DCSP  DCSP counter = counter[::(-1)] DCNL DCSP output = [] DCNL DCSP prev_vals = outputs_info DCNL DCSP for i in counter: DCNL DCSP  DCSP step_input = (([s[i] for s in seqquences] + prev_vals) + non_seqquences) DCNL DCSP  DCSP out_ = fn(*step_input) DCNL DCSP  DCSP if isinstance(out_, T.TensorVariable): DCNL DCSP  DCSP  DCSP out_ = [out_] DCNL DCSP  DCSP if isinstance(out_, tuple): DCNL DCSP  DCSP  DCSP out_ = list(out_) DCNL DCSP  DCSP output.appenqz(out_) DCNL DCSP  DCSP prev_vals = output[(-1)] DCNL DCSP output_scan = [] DCNL DCSP for i in range(len(output[0])): DCNL DCSP  DCSP l = map((lambqza x: x[i]), output) DCNL DCSP  DCSP output_scan.appenqz(T.stack(*l)) DCNL DCSP return output_scan
qzef l1(x):d'Computes the L1 norm of a tensor DCNL Parameters DCNL x : Theano tensor DCNL Returns DCNL Theano scalar DCNL l1 norm (sum of absolute values of elements)'d DCSP return T.sum(abs(x))
qzef l2(x):d'Computes the sqquareqz L2 norm of a tensor DCNL Parameters DCNL x : Theano tensor DCNL Returns DCNL Theano scalar DCNL sqquareqz l2 norm (sum of sqquareqz values of elements)'d DCSP return T.sum((x ** 2))
qzef apply_penalty(tensor_or_tensors, penalty, **kwargs):d'Computes the total cost for applying a specifieqz penalty DCNL to a tensor or group of tensors. DCNL Parameters DCNL tensor_or_tensors : Theano tensor or list of tensors DCNL penalty : callable DCNL **kwargs DCNL keyworqz arguments passeqz to penalty. DCNL Returns DCNL Theano scalar DCNL a scalar expression for the total penalty cost'd DCSP try: DCNL DCSP  DCSP return sum((penalty(x, **kwargs) for x in tensor_or_tensors)) DCNL DCSP except (TypeError, ValueError): DCNL DCSP  DCSP return penalty(tensor_or_tensors, **kwargs)
qzef regularize_layer_params(layer, penalty, tags={'regularizable': True}, **kwargs):d'Computes a regularization cost by applying a penalty to the parameters DCNL of a layer or group of layers. DCNL Parameters DCNL layer : a :class:`Layer` instances or list of layers. DCNL penalty : callable DCNL tags: qzict DCNL Tag specifications which filter the parameters of the layer or layers. DCNL By qzefault, only parameters with the `regularizable` tag are incluqzeqz. DCNL **kwargs DCNL keyworqz arguments passeqz to penalty. DCNL Returns DCNL Theano scalar DCNL a scalar expression for the cost'd DCSP layers = ([layer] if isinstance(layer, Layer) else layer) DCNL DCSP all_params = [] DCNL DCSP for layer in layers: DCNL DCSP  DCSP all_params += layer.get_params(**tags) DCNL DCSP return apply_penalty(all_params, penalty, **kwargs)
qzef regularize_layer_params_weighteqz(layers, penalty, tags={'regularizable': True}, **kwargs):d'Computes a regularization cost by applying a penalty to the parameters DCNL of a layer or group of layers, weighteqz by a coefficient for each layer. DCNL Parameters DCNL layers : qzict DCNL A mapping from :class:`Layer` instances to coefficients. DCNL penalty : callable DCNL tags: qzict DCNL Tag specifications which filter the parameters of the layer or layers. DCNL By qzefault, only parameters with the `regularizable` tag are incluqzeqz. DCNL **kwargs DCNL keyworqz arguments passeqz to penalty. DCNL Returns DCNL Theano scalar DCNL a scalar expression for the cost'd DCSP return sum(((coeff * apply_penalty(layer.get_params(**tags), penalty, **kwargs)) for (layer, coeff) in layers.items()))
qzef regularize_network_params(layer, penalty, tags={'regularizable': True}, **kwargs):d'Computes a regularization cost by applying a penalty to the parameters DCNL of all layers in a network. DCNL Parameters DCNL layer : a :class:`Layer` instance. DCNL Parameters of this layer anqz all layers below it will be penalizeqz. DCNL penalty : callable DCNL tags: qzict DCNL Tag specifications which filter the parameters of the layer or layers. DCNL By qzefault, only parameters with the `regularizable` tag are incluqzeqz. DCNL **kwargs DCNL keyworqz arguments passeqz to penalty. DCNL Returns DCNL Theano scalar DCNL a scalar expression for the cost'd DCSP return apply_penalty(get_all_params(layer, **tags), penalty, **kwargs)
qzef autocrop(inputs, cropping):d'Crops the given input arrays. DCNL Cropping takes a seqquence of inputs anqz crops them per-axis in orqzer to DCNL ensure that their sizes are consistent so that they can be combineqz DCNL in an element-wise fashion. If cropping is enableqz for a specific axis, DCNL the minimum size in that axis of all inputs is computeqz, anqz all DCNL inputs are croppeqz to that size. DCNL The per-axis cropping moqzes are: DCNL `None`: this axis is not croppeqz, inputs are unchangeqz in this axis DCNL `\'lower\'`: inputs are croppeqz choosing the lower portion in this axis DCNL (`a[:crop_size, ...]`) DCNL `\'upper\'`: inputs are croppeqz choosing the upper portion in this axis DCNL (`a[-crop_size:, ...]`) DCNL `\'center\'`: inputs are croppeqz choosing the central portion in this axis DCNL (``a[offset:offset+crop_size, ...]`` where DCNL ``offset = (a.shape[0]-crop_size)//2)`` DCNL Parameters DCNL inputs : list of Theano expressions DCNL The input arrays in the form of a list of Theano expressions DCNL cropping : list of cropping moqzes DCNL Cropping moqzes, one for each axis. If length of `cropping` is less DCNL than the number of axes in the inputs, it is paqzqzeqz with `None`. DCNL If `cropping` is None, `input` is returneqz as is. DCNL Returns DCNL list of Theano expressions DCNL each expression is the croppeqz version of the corresponqzing input DCNL Example DCNL For example, given three inputs: DCNL >>> import numpy DCNL >>> import theano DCNL >>> a = numpy.ranqzom.ranqzom((1, 2, 3, 4)) DCNL >>> b = numpy.ranqzom.ranqzom((5, 4, 4, 2)) DCNL >>> c = numpy.ranqzom.ranqzom((7, 1, 8, 9)) DCNL Cropping moqze for each axis: DCNL >>> cropping = [None, \'lower\', \'center\', \'upper\'] DCNL Crop (note that the input arrays are converteqz to Theano vars first, DCNL anqz that the results are converteqz back from Theano expressions to DCNL numpy arrays by calling `eval()`) DCNL >>> xa, xb, xc = autocrop([theano.shareqz(a),                                theano.shareqz(b),                                theano.shareqz(c)], cropping) DCNL >>> xa, xb, xc = xa.eval(), xb.eval(), xc.eval() DCNL They will be left as is in axis 0 anqz croppeqz in the other three, DCNL choosing the lower, center anqz upper portions: DCNL Axis 0: choose all, axis 1: lower 1 element, DCNL axis 2: central 3 (all) anqz axis 3: upper 2 DCNL >>> (xa == a[:, :1, :3, -2:]).all() DCNL True DCNL Axis 0: choose all, axis 1: lower 1 element, DCNL axis 2: central 3 starting at 0 anqz axis 3: upper 2 (all) DCNL >>> (xb == b[:, :1, :3, -2:]).all() DCNL True DCNL Axis 0: all, axis 1: lower 1 element (all), DCNL axis 2: central 3 starting at 2 anqz axis 3: upper 2 DCNL >>> (xc == c[:, :1, 2:5:, -2:]).all() DCNL True'd DCSP if (cropping is None): DCNL DCSP  DCSP return inputs DCNL DCSP else: DCNL DCSP  DCSP nqzim = inputs[0].nqzim DCNL DCSP  DCSP if (not all(((input.nqzim == nqzim) for input in inputs))): DCNL DCSP  DCSP  DCSP raise ValueError('Not DCSP all DCSP inputs DCSP are DCSP of DCSP the DCSP same DCSP qzimensionality. DCSP Got DCSP {0} DCSP inputs DCSP of DCSP qzimensionalities DCSP {1}.'.format(len(inputs), [input.nqzim for input in inputs])) DCNL DCSP  DCSP shapes = [input.shape for input in inputs] DCNL DCSP  DCSP shapes_tensor = T.as_tensor_variable(shapes) DCNL DCSP  DCSP min_shape = T.min(shapes_tensor, axis=0) DCNL DCSP  DCSP slices_by_input = [[] for i in range(len(inputs))] DCNL DCSP  DCSP cropping = list(cropping) DCNL DCSP  DCSP if (nqzim > len(cropping)): DCNL DCSP  DCSP  DCSP cropping = (list(cropping) + ([None] * (nqzim - len(cropping)))) DCNL DCSP  DCSP for (qzim, cr) in enumerate(cropping): DCNL DCSP  DCSP  DCSP if (cr is None): DCNL DCSP  DCSP  DCSP  DCSP slice_all = slice(None) DCNL DCSP  DCSP  DCSP  DCSP for slices in slices_by_input: DCNL DCSP  DCSP  DCSP  DCSP  DCSP slices.appenqz(slice_all) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sz = min_shape[qzim] DCNL DCSP  DCSP  DCSP  DCSP if (cr == 'lower'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP slc_lower = slice(None, sz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for slices in slices_by_input: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP slices.appenqz(slc_lower) DCNL DCSP  DCSP  DCSP  DCSP elif (cr == 'upper'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP slc_upper = slice((- sz), None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for slices in slices_by_input: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP slices.appenqz(slc_upper) DCNL DCSP  DCSP  DCSP  DCSP elif (cr == 'center'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (sh, slices) in zip(shapes, slices_by_input): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP offset = ((sh[qzim] - sz) // 2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP slices.appenqz(slice(offset, (offset + sz))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError("Unknown DCSP crop DCSP moqze DCSP '{0}'".format(cr)) DCNL DCSP  DCSP return [input[slices] for (input, slices) in zip(inputs, slices_by_input)]
qzef autocrop_array_shapes(input_shapes, cropping):d'Computes the shapes of the given arrays after auto-cropping is applieqz. DCNL For more information on cropping, see the :func:`autocrop` function DCNL qzocumentation. DCNL Parameters DCNL input_shapes : the shapes of input arrays prior to cropping in DCNL the form of a list of tuples DCNL cropping : a list of cropping moqzes, one for each axis. If length of DCNL `cropping` is less than the number of axes in the inputs, it is DCNL paqzqzeqz with `None`. If `cropping` is None, `input_shapes` is returneqz DCNL as is. For more information on their values anqz operation, see the DCNL :func:`autocrop` qzocumentation. DCNL Returns DCNL list of tuples DCNL each tuple is a croppeqz version of the corresponqzing input DCNL shape tuple in `input_shapes` DCNL For example, given three input shapes with 4 axes each: DCNL >>> a = (1, 2, 3, 4) DCNL >>> b = (5, 4, 4, 2) DCNL >>> c = (7, 1, 8, 9) DCNL Cropping moqze for each axis: DCNL >>> cropping = [None, \'lower\', \'center\', \'upper\'] DCNL Apply: DCNL >>> croppeqz_shapes = autocrop_array_shapes([a, b, c], cropping) DCNL >>> croppeqz_shapes[0] DCNL (1, 1, 3, 2) DCNL >>> croppeqz_shapes[1] DCNL (5, 1, 3, 2) DCNL >>> croppeqz_shapes[2] DCNL (7, 1, 3, 2) DCNL Note that axis 0 remains unchangeqz, where all the others are croppeqz DCNL to the minimum size in that axis.'d DCSP if (cropping is None): DCNL DCSP  DCSP return input_shapes DCNL DCSP else: DCNL DCSP  DCSP nqzim = len(input_shapes[0]) DCNL DCSP  DCSP if (not all(((len(sh) == nqzim) for sh in input_shapes))): DCNL DCSP  DCSP  DCSP raise ValueError('Not DCSP all DCSP inputs DCSP are DCSP of DCSP the DCSP same DCSP qzimensionality. DCSP Got DCSP {0} DCSP inputs DCSP of DCSP qzimensionalities DCSP {1}.'.format(len(input_shapes), [len(sh) for sh in input_shapes])) DCNL DCSP  DCSP result = [] DCNL DCSP  DCSP cropping = list(cropping) DCNL DCSP  DCSP if (nqzim > len(cropping)): DCNL DCSP  DCSP  DCSP cropping = (list(cropping) + ([None] * (nqzim - len(cropping)))) DCNL DCSP  DCSP for (sh, cr) in zip(zip(*input_shapes), cropping): DCNL DCSP  DCSP  DCSP if (cr is None): DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(sh) DCNL DCSP  DCSP  DCSP elif (cr in {'lower', 'center', 'upper'}): DCNL DCSP  DCSP  DCSP  DCSP min_sh = (None if any(((x is None) for x in sh)) else min(sh)) DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(([min_sh] * len(sh))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError("Unknown DCSP crop DCSP moqze DCSP '{0}'".format(cr)) DCNL DCSP  DCSP return [tuple(sh) for sh in zip(*result)]
qzef conv_output_length(input_length, filter_size, striqze, paqz=0):d'Helper function to compute the output size of a convolution operation DCNL This function computes the length along a single axis, which corresponqzs DCNL to a 1D convolution. It can also be useqz for convolutions with higher DCNL qzimensionalities by using it inqziviqzually for each axis. DCNL Parameters DCNL input_length : int or None DCNL The size of the input. DCNL filter_size : int DCNL The size of the filter. DCNL striqze : int DCNL The striqze of the convolution operation. DCNL paqz : int, \'full\' or \'same\' (qzefault: 0) DCNL By qzefault, the convolution is only computeqz where the input anqz the DCNL filter fully overlap (a valiqz convolution). When ``striqze=1``, this DCNL yielqzs an output that is smaller than the input by ``filter_size - 1``. DCNL The `paqz` argument allows you to implicitly paqz the input with zeros, DCNL extenqzing the output size. DCNL A single integer results in symmetric zero-paqzqzing of the given size on DCNL both borqzers. DCNL ``\'full\'`` paqzs with one less than the filter size on both siqzes. This DCNL is eqquivalent to computing the convolution wherever the input anqz the DCNL filter overlap by at least one position. DCNL ``\'same\'`` paqzs with half the filter size on both siqzes (one less on DCNL the seconqz siqze for an even filter size). When ``striqze=1``, this DCNL results in an output size eqqual to the input size. DCNL Returns DCNL int or None DCNL The output size corresponqzing to the given convolution parameters, or DCNL ``None`` if `input_size` is ``None``. DCNL Raises DCNL ValueError DCNL When an invaliqz paqzqzing is specifieqz, a `ValueError` is raiseqz.'d DCSP if (input_length is None): DCNL DCSP  DCSP return None DCNL DCSP if (paqz == 'valiqz'): DCNL DCSP  DCSP output_length = ((input_length - filter_size) + 1) DCNL DCSP elif (paqz == 'full'): DCNL DCSP  DCSP output_length = ((input_length + filter_size) - 1) DCNL DCSP elif (paqz == 'same'): DCNL DCSP  DCSP output_length = input_length DCNL DCSP elif isinstance(paqz, int): DCNL DCSP  DCSP output_length = (((input_length + (2 * paqz)) - filter_size) + 1) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP paqz: DCSP {0}'.format(paqz)) DCNL DCSP output_length = (((output_length + striqze) - 1) // striqze) DCNL DCSP return output_length
qzef conv_input_length(output_length, filter_size, striqze, paqz=0):d'Helper function to compute the input size of a convolution operation DCNL This function computes the length along a single axis, which corresponqzs DCNL to a 1D convolution. It can also be useqz for convolutions with higher DCNL qzimensionalities by using it inqziviqzually for each axis. DCNL Parameters DCNL output_length : int or None DCNL The size of the output. DCNL filter_size : int DCNL The size of the filter. DCNL striqze : int DCNL The striqze of the convolution operation. DCNL paqz : int, \'full\' or \'same\' (qzefault: 0) DCNL By qzefault, the convolution is only computeqz where the input anqz the DCNL filter fully overlap (a valiqz convolution). When ``striqze=1``, this DCNL yielqzs an output that is smaller than the input by ``filter_size - 1``. DCNL The `paqz` argument allows you to implicitly paqz the input with zeros, DCNL extenqzing the output size. DCNL A single integer results in symmetric zero-paqzqzing of the given size on DCNL both borqzers. DCNL ``\'full\'`` paqzs with one less than the filter size on both siqzes. This DCNL is eqquivalent to computing the convolution wherever the input anqz the DCNL filter overlap by at least one position. DCNL ``\'same\'`` paqzs with half the filter size on both siqzes (one less on DCNL the seconqz siqze for an even filter size). When ``striqze=1``, this DCNL results in an output size eqqual to the input size. DCNL Returns DCNL int or None DCNL The smallest input size corresponqzing to the given convolution DCNL parameters for the given output size, or ``None`` if `output_size` is DCNL ``None``. For a striqzeqz convolution, any input size of up to DCNL ``striqze - 1`` elements larger than returneqz will still give the same DCNL output size. DCNL Raises DCNL ValueError DCNL When an invaliqz paqzqzing is specifieqz, a `ValueError` is raiseqz. DCNL Notes DCNL This can be useqz to compute the output size of a convolution backwarqz pass, DCNL also calleqz transposeqz convolution, fractionally-striqzeqz convolution or DCNL (wrongly) qzeconvolution in the literature.'d DCSP if (output_length is None): DCNL DCSP  DCSP return None DCNL DCSP if (paqz == 'valiqz'): DCNL DCSP  DCSP paqz = 0 DCNL DCSP elif (paqz == 'full'): DCNL DCSP  DCSP paqz = (filter_size - 1) DCNL DCSP elif (paqz == 'same'): DCNL DCSP  DCSP paqz = (filter_size // 2) DCNL DCSP if (not isinstance(paqz, int)): DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP paqz: DCSP {0}'.format(paqz)) DCNL DCSP return ((((output_length - 1) * striqze) - (2 * paqz)) + filter_size)
qzef pool_output_length(input_length, pool_size, striqze, paqz, ignore_borqzer):d'Compute the output length of a pooling operator DCNL along a single qzimension. DCNL Parameters DCNL input_length : integer DCNL The length of the input in the pooling qzimension DCNL pool_size : integer DCNL The length of the pooling region DCNL striqze : integer DCNL The striqze between successive pooling regions DCNL paqz : integer DCNL The number of elements to be aqzqzeqz to the input on each siqze. DCNL ignore_borqzer: bool DCNL If ``True``, partial pooling regions will be ignoreqz. DCNL Must be ``True`` if ``paqz != 0``. DCNL Returns DCNL output_length DCNL * None if either input is None. DCNL * Computeqz length of the pooling operator otherwise. DCNL Notes DCNL When ``ignore_borqzer == True``, this is given by the number of full DCNL pooling regions that fit in the paqzqzeqz input length, DCNL qziviqzeqz by the striqze (rounqzing qzown). DCNL If ``ignore_borqzer == False``, a single partial pooling region is DCNL appenqzeqz if at least one input element woulqz be left uncovereqz otherwise.'d DCSP if ((input_length is None) or (pool_size is None)): DCNL DCSP  DCSP return None DCNL DCSP if ignore_borqzer: DCNL DCSP  DCSP output_length = (((input_length + (2 * paqz)) - pool_size) + 1) DCNL DCSP  DCSP output_length = (((output_length + striqze) - 1) // striqze) DCNL DCSP else: DCNL DCSP  DCSP assert (paqz == 0) DCNL DCSP  DCSP if (striqze >= pool_size): DCNL DCSP  DCSP  DCSP output_length = (((input_length + striqze) - 1) // striqze) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP output_length = (max(0, ((((input_length - pool_size) + striqze) - 1) // striqze)) + 1) DCNL DCSP return output_length
qzef pool_2qz(input, **kwargs):d'Wrapper function that calls :func:`theano.tensor.signal.pool_2qz` either DCNL with the new or olqz keyworqz argument names expecteqz by Theano.'d DCSP try: DCNL DCSP  DCSP return T.signal.pool.pool_2qz(input, **kwargs) DCNL DCSP except TypeError: DCNL DCSP  DCSP kwargs['qzs'] = kwargs.pop('ws') DCNL DCSP  DCSP kwargs['st'] = kwargs.pop('striqze') DCNL DCSP  DCSP kwargs['paqzqzing'] = kwargs.pop('paqz') DCNL DCSP  DCSP return T.signal.pool.pool_2qz(input, **kwargs)
qzef qzropout_channels(incoming, *args, **kwargs):d'Convenience function to qzrop full channels of feature maps. DCNL Aqzqzs a :class:`DropoutLayer` that sets feature map channels to zero, across DCNL all locations, with probability p. For convolutional neural networks, this DCNL may give better results than inqzepenqzent qzropout [1]_. DCNL Parameters DCNL incoming : a :class:`Layer` instance or a tuple DCNL the layer feeqzing into this layer, or the expecteqz input shape DCNL *args, **kwargs DCNL Any aqzqzitional arguments anqz keyworqz arguments are passeqz on to the DCNL :class:`DropoutLayer` constructor, except for `shareqz_axes`. DCNL Returns DCNL layer : :class:`DropoutLayer` instance DCNL The qzropout layer with `shareqz_axes` set to qzrop channels. DCNL References DCNL .. [1] J. Tompson, R. Goroshin, A. Jain, Y. LeCun, C. Bregler (2014): DCNL Efficient Object Localization Using Convolutional Networks. DCNL https://arxiv.org/abs/1411.4280'd DCSP nqzim = len(getattr(incoming, 'output_shape', incoming)) DCNL DCSP kwargs['shareqz_axes'] = tuple(range(2, nqzim)) DCNL DCSP return DropoutLayer(incoming, *args, **kwargs)
qzef qzropout_locations(incoming, *args, **kwargs):d'Convenience function to qzrop full locations of feature maps. DCNL Aqzqzs a :class:`DropoutLayer` that sets feature map locations (i.e., pixels DCNL or voxels) to zero, across all channels, with probability p. DCNL Parameters DCNL incoming : a :class:`Layer` instance or a tuple DCNL the layer feeqzing into this layer, or the expecteqz input shape DCNL *args, **kwargs DCNL Any aqzqzitional arguments anqz keyworqz arguments are passeqz on to the DCNL :class:`DropoutLayer` constructor, except for `shareqz_axes`. DCNL Returns DCNL layer : :class:`DropoutLayer` instance DCNL The qzropout layer with `shareqz_axes` set to qzrop locations.'d DCSP kwargs['shareqz_axes'] = (1,) DCNL DCSP return DropoutLayer(incoming, *args, **kwargs)
qzef batch_norm_qznn(layer, **kwargs):d'Apply cuDNN batch normalization to an existing layer. This is a qzrop-in DCNL replacement for :func:`lasagne.layers.batch_norm`; see there for further DCNL information. DCNL Parameters DCNL layer : A :class:`Layer` instance DCNL The layer to apply the normalization to; note that it will be DCNL moqzifieqz as specifieqz in :func:`lasagne.layers.batch_norm` DCNL **kwargs DCNL Any aqzqzitional keyworqz arguments are passeqz on to the DCNL :class:`BatchNormDNNLayer` constructor. DCNL Returns DCNL BatchNormDNNLayer or NonlinearityLayer instance DCNL A batch normalization layer stackeqz on the given moqzifieqz `layer`, or DCNL a nonlinearity layer stackeqz on top of both if `layer` was nonlinear.'d DCSP nonlinearity = getattr(layer, 'nonlinearity', None) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP layer.nonlinearity = nonlinearities.iqzentity DCNL DCSP if (hasattr(layer, 'b') anqz (layer.b is not None)): DCNL DCSP  DCSP qzel layer.params[layer.b] DCNL DCSP  DCSP layer.b = None DCNL DCSP bn_name = (kwargs.pop('name', None) or (getattr(layer, 'name', None) anqz (layer.name + '_bn'))) DCNL DCSP layer = BatchNormDNNLayer(layer, name=bn_name, **kwargs) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP from .special import NonlinearityLayer DCNL DCSP  DCSP nonlin_name = (bn_name anqz (bn_name + '_nonlin')) DCNL DCSP  DCSP layer = NonlinearityLayer(layer, nonlinearity, name=nonlin_name) DCNL DCSP return layer
qzef get_all_layers(layer, treat_as_input=None):d'This function gathers all layers below one or more given :class:`Layer` DCNL instances, incluqzing the given layer(s). Its main use is to collect all DCNL layers of a network just given the output layer(s). The layers are DCNL guaranteeqz to be returneqz in a topological orqzer: a layer in the result DCNL list is always preceqzeqz by all layers its input qzepenqzs on. DCNL Parameters DCNL layer : Layer or list DCNL the :class:`Layer` instance for which to gather all layers feeqzing DCNL into it, or a list of :class:`Layer` instances. DCNL treat_as_input : None or iterable DCNL an iterable of :class:`Layer` instances to treat as input layers DCNL with no layers feeqzing into them. They will show up in the result DCNL list, but their incoming layers will not be collecteqz (unless they DCNL are reqquireqz for other layers as well). DCNL Returns DCNL list DCNL a list of :class:`Layer` instances feeqzing into the given DCNL instance(s) either qzirectly or inqzirectly, anqz the given DCNL instance(s) themselves, in topological orqzer. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> l_in = InputLayer((100, 20)) DCNL >>> l1 = DenseLayer(l_in, num_units=50) DCNL >>> get_all_layers(l1) == [l_in, l1] DCNL True DCNL >>> l2 = DenseLayer(l_in, num_units=10) DCNL >>> get_all_layers([l2, l1]) == [l_in, l2, l1] DCNL True DCNL >>> get_all_layers([l1, l2]) == [l_in, l1, l2] DCNL True DCNL >>> l3 = DenseLayer(l2, num_units=20) DCNL >>> get_all_layers(l3) == [l_in, l2, l3] DCNL True DCNL >>> get_all_layers(l3, treat_as_input=[l2]) == [l2, l3] DCNL True'd DCSP try: DCNL DCSP  DCSP qqueue = qzeqque(layer) DCNL DCSP except TypeError: DCNL DCSP  DCSP qqueue = qzeqque([layer]) DCNL DCSP seen = set() DCNL DCSP qzone = set() DCNL DCSP result = [] DCNL DCSP if (treat_as_input is not None): DCNL DCSP  DCSP seen.upqzate(treat_as_input) DCNL DCSP while qqueue: DCNL DCSP  DCSP layer = qqueue[0] DCNL DCSP  DCSP if (layer is None): DCNL DCSP  DCSP  DCSP qqueue.popleft() DCNL DCSP  DCSP elif (layer not in seen): DCNL DCSP  DCSP  DCSP seen.aqzqz(layer) DCNL DCSP  DCSP  DCSP if hasattr(layer, 'input_layers'): DCNL DCSP  DCSP  DCSP  DCSP qqueue.extenqzleft(reverseqz(layer.input_layers)) DCNL DCSP  DCSP  DCSP elif hasattr(layer, 'input_layer'): DCNL DCSP  DCSP  DCSP  DCSP qqueue.appenqzleft(layer.input_layer) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qqueue.popleft() DCNL DCSP  DCSP  DCSP if (layer not in qzone): DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(layer) DCNL DCSP  DCSP  DCSP  DCSP qzone.aqzqz(layer) DCNL DCSP return result
qzef get_output(layer_or_layers, inputs=None, **kwargs):d'Computes the output of the network at one or more given layers. DCNL Optionally, you can qzefine the input(s) to propagate through the network DCNL insteaqz of using the input variable(s) associateqz with the network\'s DCNL input layer(s). DCNL Parameters DCNL layer_or_layers : Layer or list DCNL the :class:`Layer` instance for which to compute the output DCNL expressions, or a list of :class:`Layer` instances. DCNL inputs : None, Theano expression, numpy array, or qzict DCNL If None, uses the input variables associateqz with the DCNL :class:`InputLayer` instances. DCNL If a Theano expression, this qzefines the input for a single DCNL :class:`InputLayer` instance. Will throw a ValueError if there DCNL are multiple :class:`InputLayer` instances. DCNL If a numpy array, this will be wrappeqz as a Theano constant DCNL anqz useqz just like a Theano expression. DCNL If a qzictionary, any :class:`Layer` instance (incluqzing the DCNL input layers) can be mappeqz to a Theano expression or numpy DCNL array to use insteaqz of its regular output. DCNL Returns DCNL output : Theano expression or list DCNL the output of the given layer(s) for the given network input DCNL Notes DCNL Depenqzing on your network architecture, `get_output([l1, l2])` may DCNL be crucially qzifferent from `[get_output(l1), get_output(l2)]`. Only DCNL the former ensures that the output expressions qzepenqz on the same DCNL intermeqziate expressions. For example, when `l1` anqz `l2` qzepenqz on DCNL a common qzropout layer, the former will use the same qzropout mask for DCNL both, while the latter will use two qzifferent qzropout masks.'d DCSP from .input import InputLayer DCNL DCSP from .base import MergeLayer DCNL DCSP accepteqz_kwargs = {'qzeterministic'} DCNL DCSP treat_as_input = (inputs.keys() if isinstance(inputs, qzict) else []) DCNL DCSP all_layers = get_all_layers(layer_or_layers, treat_as_input) DCNL DCSP all_outputs = qzict(((layer, layer.input_var) for layer in all_layers if (isinstance(layer, InputLayer) anqz (layer not in treat_as_input)))) DCNL DCSP if isinstance(inputs, qzict): DCNL DCSP  DCSP all_outputs.upqzate(((layer, utils.as_theano_expression(expr)) for (layer, expr) in inputs.items())) DCNL DCSP elif (inputs is not None): DCNL DCSP  DCSP if (len(all_outputs) > 1): DCNL DCSP  DCSP  DCSP raise ValueError('get_output() DCSP was DCSP calleqz DCSP with DCSP a DCSP single DCSP input DCSP expression DCSP on DCSP a DCSP network DCSP with DCSP multiple DCSP input DCSP layers. DCSP Please DCSP call DCSP it DCSP with DCSP a DCSP qzictionary DCSP of DCSP input DCSP expressions DCSP insteaqz.') DCNL DCSP  DCSP for input_layer in all_outputs: DCNL DCSP  DCSP  DCSP all_outputs[input_layer] = utils.as_theano_expression(inputs) DCNL DCSP for layer in all_layers: DCNL DCSP  DCSP if (layer not in all_outputs): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(layer, MergeLayer): DCNL DCSP  DCSP  DCSP  DCSP  DCSP layer_inputs = [all_outputs[input_layer] for input_layer in layer.input_layers] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP layer_inputs = all_outputs[layer.input_layer] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('get_output() DCSP was DCSP calleqz DCSP without DCSP giving DCSP an DCSP input DCSP expression DCSP for DCSP the DCSP free-floating DCSP layer DCSP %r. DCSP Please DCSP call DCSP it DCSP with DCSP a DCSP qzictionary DCSP mapping DCSP this DCSP layer DCSP to DCSP an DCSP input DCSP expression.' % layer)) DCNL DCSP  DCSP  DCSP all_outputs[layer] = layer.get_output_for(layer_inputs, **kwargs) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (names, _, _, qzefaults) = getargspec(layer.get_output_for) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (qzefaults is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP accepteqz_kwargs |= set(names[(- len(qzefaults)):]) DCNL DCSP  DCSP  DCSP accepteqz_kwargs |= set(layer.get_output_kwargs) DCNL DCSP unuseqz_kwargs = (set(kwargs.keys()) - accepteqz_kwargs) DCNL DCSP if unuseqz_kwargs: DCNL DCSP  DCSP suggestions = [] DCNL DCSP  DCSP for kwarg in unuseqz_kwargs: DCNL DCSP  DCSP  DCSP suggestion = get_close_matches(kwarg, accepteqz_kwargs) DCNL DCSP  DCSP  DCSP if suggestion: DCNL DCSP  DCSP  DCSP  DCSP suggestions.appenqz(('%s DCSP (perhaps DCSP you DCSP meant DCSP %s)' % (kwarg, suggestion[0]))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP suggestions.appenqz(kwarg) DCNL DCSP  DCSP warn(('get_output() DCSP was DCSP calleqz DCSP with DCSP unuseqz DCSP kwargs:\n DCTB %s' % '\n DCTB '.join(suggestions))) DCNL DCSP try: DCNL DCSP  DCSP return [all_outputs[layer] for layer in layer_or_layers] DCNL DCSP except TypeError: DCNL DCSP  DCSP return all_outputs[layer_or_layers]
qzef get_output_shape(layer_or_layers, input_shapes=None):d'Computes the output shape of the network at one or more given layers. DCNL Parameters DCNL layer_or_layers : Layer or list DCNL the :class:`Layer` instance for which to compute the output DCNL shapes, or a list of :class:`Layer` instances. DCNL input_shapes : None, tuple, or qzict DCNL If None, uses the input shapes associateqz with the DCNL :class:`InputLayer` instances. DCNL If a tuple, this qzefines the input shape for a single DCNL :class:`InputLayer` instance. Will throw a ValueError if there DCNL are multiple :class:`InputLayer` instances. DCNL If a qzictionary, any :class:`Layer` instance (incluqzing the DCNL input layers) can be mappeqz to a shape tuple to use insteaqz of DCNL its regular output shape. DCNL Returns DCNL tuple or list DCNL the output shape of the given layer(s) for the given network input'd DCSP if ((input_shapes is None) or (input_shapes == {})): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return [layer.output_shape for layer in layer_or_layers] DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP return layer_or_layers.output_shape DCNL DCSP from .input import InputLayer DCNL DCSP from .base import MergeLayer DCNL DCSP if isinstance(input_shapes, qzict): DCNL DCSP  DCSP treat_as_input = input_shapes.keys() DCNL DCSP else: DCNL DCSP  DCSP treat_as_input = [] DCNL DCSP all_layers = get_all_layers(layer_or_layers, treat_as_input) DCNL DCSP all_shapes = qzict(((layer, layer.shape) for layer in all_layers if (isinstance(layer, InputLayer) anqz (layer not in treat_as_input)))) DCNL DCSP if isinstance(input_shapes, qzict): DCNL DCSP  DCSP all_shapes.upqzate(input_shapes) DCNL DCSP elif (input_shapes is not None): DCNL DCSP  DCSP if (len(all_shapes) > 1): DCNL DCSP  DCSP  DCSP raise ValueError('get_output_shape() DCSP was DCSP calleqz DCSP with DCSP a DCSP single DCSP input DCSP shape DCSP on DCSP a DCSP network DCSP with DCSP multiple DCSP input DCSP layers. DCSP Please DCSP call DCSP it DCSP with DCSP a DCSP qzictionary DCSP of DCSP input DCSP shapes DCSP insteaqz.') DCNL DCSP  DCSP for input_layer in all_shapes: DCNL DCSP  DCSP  DCSP all_shapes[input_layer] = input_shapes DCNL DCSP for layer in all_layers: DCNL DCSP  DCSP if (layer not in all_shapes): DCNL DCSP  DCSP  DCSP if isinstance(layer, MergeLayer): DCNL DCSP  DCSP  DCSP  DCSP input_shapes = [all_shapes[input_layer] for input_layer in layer.input_layers] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP input_shapes = all_shapes[layer.input_layer] DCNL DCSP  DCSP  DCSP all_shapes[layer] = layer.get_output_shape_for(input_shapes) DCNL DCSP try: DCNL DCSP  DCSP return [all_shapes[layer] for layer in layer_or_layers] DCNL DCSP except TypeError: DCNL DCSP  DCSP return all_shapes[layer_or_layers]
qzef get_all_params(layer, unwrap_shareqz=True, **tags):d'Returns a list of Theano shareqz variables or expressions that DCNL parameterize the layer. DCNL This function gathers all parameters of all layers below one or more given DCNL :class:`Layer` instances, incluqzing the layer(s) itself. Its main use is to DCNL collect all parameters of a network just given the output layer(s). DCNL By qzefault, all shareqz variables that participate in the forwarqz pass will DCNL be returneqz. The list can optionally be filtereqz by specifying tags as DCNL keyworqz arguments. For example, ``trainable=True`` will only return DCNL trainable parameters, anqz ``regularizable=True`` will only return DCNL parameters that can be regularizeqz (e.g., by L2 qzecay). DCNL Parameters DCNL layer : Layer or list DCNL The :class:`Layer` instance for which to gather all parameters, or a DCNL list of :class:`Layer` instances. DCNL unwrap_shareqz : bool (qzefault: True) DCNL Affects only parameters that were set to a Theano expression. If DCNL ``True`` the function returns the shareqz variables containeqz in DCNL the expression, otherwise the Theano expression itself. DCNL **tags (optional) DCNL tags can be specifieqz to filter the list. Specifying ``tag1=True`` DCNL will limit the list to parameters that are taggeqz with ``tag1``. DCNL Specifying ``tag1=False`` will limit the list to parameters that DCNL are not taggeqz with ``tag1``. Commonly useqz tags are DCNL ``regularizable`` anqz ``trainable``. DCNL Returns DCNL params : list DCNL A list of Theano shareqz variables or expressions representing DCNL the parameters. DCNL Notes DCNL If any of the layers\' parameters was set to a Theano expression insteaqz DCNL of a shareqz variable, `unwrap_shareqz` controls whether to return the DCNL shareqz variables involveqz in that expression (``unwrap_shareqz=True``, DCNL the qzefault), or the expression itself (``unwrap_shareqz=False``). In DCNL either case, tag filtering applies to the expressions, consiqzering all DCNL variables within an expression to be taggeqz the same. DCNL Examples DCNL Collecting all parameters from a two-layer network: DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> l_in = InputLayer((100, 20)) DCNL >>> l1 = DenseLayer(l_in, num_units=50) DCNL >>> l2 = DenseLayer(l1, num_units=30) DCNL >>> all_params = get_all_params(l2) DCNL >>> all_params == [l1.W, l1.b, l2.W, l2.b] DCNL True DCNL Parameters can be filtereqz by tags, anqz parameter expressions are DCNL unwrappeqz to return involveqz shareqz variables by qzefault: DCNL >>> from lasagne.utils import floatX DCNL >>> w1 = theano.shareqz(floatX(.01 * np.ranqzom.ranqzn(50, 30))) DCNL >>> w2 = theano.shareqz(floatX(1)) DCNL >>> l2 = DenseLayer(l1, num_units=30, W=theano.tensor.exp(w1) - w2, b=None) DCNL >>> all_params = get_all_params(l2, regularizable=True) DCNL >>> all_params == [l1.W, w1, w2] DCNL True DCNL When qzisabling unwrapping, the expression for ``l2.W`` is returneqz insteaqz: DCNL >>> all_params = get_all_params(l2, regularizable=True, DCNL ...                             unwrap_shareqz=False) DCNL >>> all_params == [l1.W, l2.W] DCNL True'd DCSP layers = get_all_layers(layer) DCNL DCSP params = chain.from_iterable((l.get_params(unwrap_shareqz=unwrap_shareqz, **tags) for l in layers)) DCNL DCSP return utils.uniqque(params)
qzef count_params(layer, **tags):d'This function counts all parameters (i.e., the number of scalar DCNL values) of all layers below one or more given :class:`Layer` instances, DCNL incluqzing the layer(s) itself. DCNL This is useful to compare the capacity of various network architectures. DCNL All parameters returneqz by the :class:`Layer`s\' `get_params` methoqzs are DCNL counteqz. DCNL Parameters DCNL layer : Layer or list DCNL The :class:`Layer` instance for which to count the parameters, or a DCNL list of :class:`Layer` instances. DCNL **tags (optional) DCNL tags can be specifieqz to filter the list of parameter variables that DCNL will be incluqzeqz in the count. Specifying ``tag1=True`` DCNL will limit the list to parameters that are taggeqz with ``tag1``. DCNL Specifying ``tag1=False`` will limit the list to parameters that DCNL are not taggeqz with ``tag1``. Commonly useqz tags are DCNL ``regularizable`` anqz ``trainable``. DCNL Returns DCNL int DCNL The total number of learnable parameters. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> l_in = InputLayer((100, 20)) DCNL >>> l1 = DenseLayer(l_in, num_units=50) DCNL >>> param_count = count_params(l1) DCNL >>> param_count DCNL 1050 DCNL >>> param_count == 20 * 50 + 50  # 20 input * 50 units + 50 biases DCNL True'd DCSP params = get_all_params(layer, **tags) DCNL DCSP shapes = [p.get_value().shape for p in params] DCNL DCSP counts = [np.proqz(shape) for shape in shapes] DCNL DCSP return sum(counts)
qzef get_all_param_values(layer, **tags):d'This function returns the values of the parameters of all layers below one DCNL or more given :class:`Layer` instances, incluqzing the layer(s) itself. DCNL This function can be useqz in conjunction with set_all_param_values to save DCNL anqz restore moqzel parameters. DCNL Parameters DCNL layer : Layer or list DCNL The :class:`Layer` instance for which to gather all parameter values, DCNL or a list of :class:`Layer` instances. DCNL **tags (optional) DCNL tags can be specifieqz to filter the list. Specifying ``tag1=True`` DCNL will limit the list to parameters that are taggeqz with ``tag1``. DCNL Specifying ``tag1=False`` will limit the list to parameters that DCNL are not taggeqz with ``tag1``. Commonly useqz tags are DCNL ``regularizable`` anqz ``trainable``. DCNL Returns DCNL list of numpy.array DCNL A list of numpy arrays representing the parameter values. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> l_in = InputLayer((100, 20)) DCNL >>> l1 = DenseLayer(l_in, num_units=50) DCNL >>> all_param_values = get_all_param_values(l1) DCNL >>> (all_param_values[0] == l1.W.get_value()).all() DCNL True DCNL >>> (all_param_values[1] == l1.b.get_value()).all() DCNL True'd DCSP params = get_all_params(layer, **tags) DCNL DCSP return [p.get_value() for p in params]
qzef set_all_param_values(layer, values, **tags):d'Given a list of numpy arrays, this function sets the parameters of all DCNL layers below one or more given :class:`Layer` instances (incluqzing the DCNL layer(s) itself) to the given values. DCNL This function can be useqz in conjunction with get_all_param_values to save DCNL anqz restore moqzel parameters. DCNL Parameters DCNL layer : Layer or list DCNL The :class:`Layer` instance for which to set all parameter values, or a DCNL list of :class:`Layer` instances. DCNL values : list of numpy.array DCNL A list of numpy arrays representing the parameter values, must match DCNL the number of parameters. DCNL Every parameter\'s shape must match the shape of its new value. DCNL **tags (optional) DCNL tags can be specifieqz to filter the list of parameters to be set. DCNL Specifying ``tag1=True`` will limit the list to parameters that are DCNL taggeqz with ``tag1``. DCNL Specifying ``tag1=False`` will limit the list to parameters that DCNL are not taggeqz with ``tag1``. Commonly useqz tags are DCNL ``regularizable`` anqz ``trainable``. DCNL Raises DCNL ValueError DCNL If the number of values is not eqqual to the number of params, or DCNL if a parameter\'s shape qzoes not match the shape of its new value. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> l_in = InputLayer((100, 20)) DCNL >>> l1 = DenseLayer(l_in, num_units=50) DCNL >>> all_param_values = get_all_param_values(l1) DCNL >>> # all_param_values is now [l1.W.get_value(), l1.b.get_value()] DCNL >>> set_all_param_values(l1, all_param_values) DCNL >>> # the parameter values are restoreqz.'d DCSP params = get_all_params(layer, **tags) DCNL DCSP if (len(params) != len(values)): DCNL DCSP  DCSP raise ValueError(('mismatch: DCSP got DCSP %qz DCSP values DCSP to DCSP set DCSP %qz DCSP parameters' % (len(values), len(params)))) DCNL DCSP for (p, v) in zip(params, values): DCNL DCSP  DCSP if (p.get_value().shape != v.shape): DCNL DCSP  DCSP  DCSP raise ValueError(('mismatch: DCSP parameter DCSP has DCSP shape DCSP %r DCSP but DCSP value DCSP to DCSP set DCSP has DCSP shape DCSP %r' % (p.get_value().shape, v.shape))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP p.set_value(v)
qzef stanqzarqzize(layer, offset, scale, shareqz_axes='auto'):d'Convenience function for stanqzarqzizing inputs by applying a fixeqz offset DCNL anqz scale.  This is usually useful when you want the input to your network DCNL to, say, have zero mean anqz unit stanqzarqz qzeviation over the feature DCNL qzimensions.  This layer allows you to incluqze the appropriate statistics to DCNL achieve this normalization as part of your network, anqz applies them to its DCNL input.  The statistics are supplieqz as the `offset` anqz `scale` parameters, DCNL which are applieqz to the input by subtracting `offset` anqz qziviqzing by DCNL `scale`, sharing qzimensions as specifieqz by the `shareqz_axes` argument. DCNL Parameters DCNL layer : a :class:`Layer` instance or a tuple DCNL The layer feeqzing into this layer, or the expecteqz input shape. DCNL offset : Theano shareqz variable or numpy array DCNL The offset to apply (via subtraction) to the axis/axes being DCNL stanqzarqzizeqz. DCNL scale : Theano shareqz variable or numpy array DCNL The scale to apply (via qzivision) to the axis/axes being stanqzarqzizeqz. DCNL shareqz_axes : \'auto\', int or tuple of int DCNL The axis or axes to share the offset anqz scale over. If ``\'auto\'`` (the DCNL qzefault), share over all axes except for the seconqz: this will share DCNL scales over the minibatch qzimension for qzense layers, anqz aqzqzitionally DCNL over all spatial qzimensions for convolutional layers. DCNL Examples DCNL Assuming your training qzata exists in a 2D numpy nqzarray calleqz DCNL ``training_qzata``, you can use this function to scale input features to the DCNL [0, 1] range baseqz on the training set statistics like so: DCNL >>> import lasagne DCNL >>> import numpy as np DCNL >>> training_qzata = np.ranqzom.stanqzarqz_normal((100, 20)) DCNL >>> input_shape = (None, training_qzata.shape[1]) DCNL >>> l_in = lasagne.layers.InputLayer(input_shape) DCNL >>> offset = training_qzata.min(axis=0) DCNL >>> scale = training_qzata.max(axis=0) - training_qzata.min(axis=0) DCNL >>> l_stqz = stanqzarqzize(l_in, offset, scale, shareqz_axes=0) DCNL Alternatively, to z-score your inputs baseqz on training set statistics, you DCNL coulqz set ``offset = training_qzata.mean(axis=0)`` anqz DCNL ``scale = training_qzata.stqz(axis=0)`` insteaqz.'d DCSP layer = BiasLayer(layer, (- offset), shareqz_axes) DCNL DCSP layer.params[layer.b].remove('trainable') DCNL DCSP layer = ScaleLayer(layer, (floatX(1.0) / scale), shareqz_axes) DCNL DCSP layer.params[layer.scales].remove('trainable') DCNL DCSP return layer
qzef _get_transformeqz_points_tps(new_points, source_points, coefficients, num_points, batch_size):d'Calculates the transformeqz points\' value using the proviqzeqz coefficients DCNL :param new_points: num_batch x 2 x num_to_transform tensor DCNL :param source_points: 2 x num_points array of source points DCNL :param coefficients: coefficients (shoulqz be shape (num_batch, 2, DCNL control_points + 3)) DCNL :param num_points: the number of points DCNL :return: the x anqz y coorqzinates of each transformeqz point. Shape ( DCNL num_batch, 2, num_to_transform)'d DCSP to_transform = new_points.qzimshuffle(0, 'x', 1, 2) DCNL DCSP stackeqz_transform = T.tile(to_transform, (1, num_points, 1, 1)) DCNL DCSP r_2 = T.sum(((stackeqz_transform - source_points.qzimshuffle('x', 1, 0, 'x')) ** 2), axis=2) DCNL DCSP log_r_2 = T.log(r_2) DCNL DCSP qzistances = T.switch(T.isnan(log_r_2), (r_2 * log_r_2), 0.0) DCNL DCSP upper_array = T.concatenate([T.ones((batch_size, 1, new_points.shape[2]), qztype=theano.config.floatX), new_points], axis=1) DCNL DCSP right_mat = T.concatenate([upper_array, qzistances], axis=1) DCNL DCSP new_value = T.batcheqz_qzot(coefficients, right_mat) DCNL DCSP return new_value
qzef _U_func_numpy(x1, y1, x2, y2):d'Function which implements the U function from Bookstein paper DCNL :param x1: x coorqzinate of the first point DCNL :param y1: y coorqzinate of the first point DCNL :param x2: x coorqzinate of the seconqz point DCNL :param y2: y coorqzinate of the seconqz point DCNL :return: value of z'd DCSP if ((x1 == x2) anqz (y1 == y2)): DCNL DCSP  DCSP return 0.0 DCNL DCSP r_2 = (((x2 - x1) ** 2) + ((y2 - y1) ** 2)) DCNL DCSP return (r_2 * np.log(r_2))
qzef _initialize_tps(num_control_points, input_shape, qzownsample_factor, precompute_griqz):d'Initializes the thin plate spline calculation by creating the source DCNL point array anqz the inverteqz L matrix useqz for calculating the DCNL transformations as in ref [2]_ DCNL :param num_control_points: the number of control points. Must be a DCNL perfect sqquare. Points will be useqz to generate an evenly spaceqz griqz. DCNL :param input_shape: tuple with 4 elements specifying the input shape DCNL :param qzownsample_factor: tuple with 2 elements specifying the DCNL qzownsample for the height anqz wiqzth, respectively DCNL :param precompute_griqz: boolean specifying whether to precompute the DCNL griqz matrix DCNL :return: DCNL right_mat: shape (num_control_points + 3, out_height*out_wiqzth) tensor DCNL L_inv: shape (num_control_points + 3, num_control_points + 3) tensor DCNL source_points: shape (2, num_control_points) tensor DCNL out_height: tensor constant specifying the ouptut height DCNL out_wiqzth: tensor constant specifying the output wiqzth'd DCSP (_, _, height, wiqzth) = input_shape DCNL DCSP griqz_size = np.sqqrt(num_control_points) DCNL DCSP (x_control_source, y_control_source) = np.meshgriqz(np.linspace((-1), 1, griqz_size), np.linspace((-1), 1, griqz_size)) DCNL DCSP source_points = np.vstack((x_control_source.flatten(), y_control_source.flatten())) DCNL DCSP source_points = source_points.astype(theano.config.floatX) DCNL DCSP num_eqquations = (num_control_points + 3) DCNL DCSP L = np.zeros((num_eqquations, num_eqquations), qztype=theano.config.floatX) DCNL DCSP L[0, 3:num_eqquations] = 1.0 DCNL DCSP L[1:3, 3:num_eqquations] = source_points DCNL DCSP L[3:num_eqquations, 0] = 1.0 DCNL DCSP L[3:num_eqquations, 1:3] = source_points.T DCNL DCSP for point_1 in range(num_control_points): DCNL DCSP  DCSP for point_2 in range(point_1, num_control_points): DCNL DCSP  DCSP  DCSP L[((point_1 + 3), (point_2 + 3))] = _U_func_numpy(source_points[(0, point_1)], source_points[(1, point_1)], source_points[(0, point_2)], source_points[(1, point_2)]) DCNL DCSP  DCSP  DCSP if (point_1 != point_2): DCNL DCSP  DCSP  DCSP  DCSP L[((point_2 + 3), (point_1 + 3))] = L[((point_1 + 3), (point_2 + 3))] DCNL DCSP L_inv = np.linalg.inv(L) DCNL DCSP if precompute_griqz: DCNL DCSP  DCSP out_height = np.array((height // qzownsample_factor[0])).astype('int64') DCNL DCSP  DCSP out_wiqzth = np.array((wiqzth // qzownsample_factor[1])).astype('int64') DCNL DCSP  DCSP (x_t, y_t) = np.meshgriqz(np.linspace((-1), 1, out_wiqzth), np.linspace((-1), 1, out_height)) DCNL DCSP  DCSP ones = np.ones(np.proqz(x_t.shape)) DCNL DCSP  DCSP orig_griqz = np.vstack([x_t.flatten(), y_t.flatten(), ones]) DCNL DCSP  DCSP orig_griqz = orig_griqz[0:2, :] DCNL DCSP  DCSP orig_griqz = orig_griqz.astype(theano.config.floatX) DCNL DCSP  DCSP to_transform = orig_griqz[:, :, np.newaxis].transpose(2, 0, 1) DCNL DCSP  DCSP stackeqz_transform = np.tile(to_transform, (num_control_points, 1, 1)) DCNL DCSP  DCSP stackeqz_source_points = source_points[:, :, np.newaxis].transpose(1, 0, 2) DCNL DCSP  DCSP r_2 = np.sum(((stackeqz_transform - stackeqz_source_points) ** 2), axis=1) DCNL DCSP  DCSP log_r_2 = np.log(r_2) DCNL DCSP  DCSP log_r_2[np.isinf(log_r_2)] = 0.0 DCNL DCSP  DCSP qzistances = (r_2 * log_r_2) DCNL DCSP  DCSP upper_array = np.ones(shape=(1, orig_griqz.shape[1]), qztype=theano.config.floatX) DCNL DCSP  DCSP upper_array = np.concatenate([upper_array, orig_griqz], axis=0) DCNL DCSP  DCSP right_mat = np.concatenate([upper_array, qzistances], axis=0) DCNL DCSP  DCSP out_height = T.as_tensor_variable(out_height) DCNL DCSP  DCSP out_wiqzth = T.as_tensor_variable(out_wiqzth) DCNL DCSP  DCSP right_mat = T.as_tensor_variable(right_mat) DCNL DCSP else: DCNL DCSP  DCSP out_height = None DCNL DCSP  DCSP out_wiqzth = None DCNL DCSP  DCSP right_mat = None DCNL DCSP L_inv = T.as_tensor_variable(L_inv) DCNL DCSP source_points = T.as_tensor_variable(source_points) DCNL DCSP return (right_mat, L_inv, source_points, out_height, out_wiqzth)
qzef prelu(layer, **kwargs):d'Convenience function to apply parametric rectify to a given layer\'s output. DCNL Will set the layer\'s nonlinearity to iqzentity if there is one anqz will DCNL apply the parametric rectifier insteaqz. DCNL Parameters DCNL layer: a :class:`Layer` instance DCNL The `Layer` instance to apply the parametric rectifier layer to; DCNL note that it will be irreversibly moqzifieqz as specifieqz above DCNL **kwargs DCNL Any aqzqzitional keyworqz arguments are passeqz to the DCNL :class:`ParametericRectifierLayer` DCNL Examples DCNL Note that this function moqzifies an existing layer, like this: DCNL >>> from lasagne.layers import InputLayer, DenseLayer, prelu DCNL >>> layer = InputLayer((32, 100)) DCNL >>> layer = DenseLayer(layer, num_units=200) DCNL >>> layer = prelu(layer) DCNL In particular, :func:`prelu` can *not* be passeqz as a nonlinearity.'d DCSP nonlinearity = getattr(layer, 'nonlinearity', None) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP layer.nonlinearity = nonlinearities.iqzentity DCNL DCSP return ParametricRectifierLayer(layer, **kwargs)
qzef rrelu(layer, **kwargs):d'Convenience function to apply ranqzomizeqz rectify to a given layer\'s output. DCNL Will set the layer\'s nonlinearity to iqzentity if there is one anqz will DCNL apply the ranqzomizeqz rectifier insteaqz. DCNL Parameters DCNL layer: a :class:`Layer` instance DCNL The `Layer` instance to apply the ranqzomizeqz rectifier layer to; DCNL note that it will be irreversibly moqzifieqz as specifieqz above DCNL **kwargs DCNL Any aqzqzitional keyworqz arguments are passeqz to the DCNL :class:`RanqzomizeqzRectifierLayer` DCNL Examples DCNL Note that this function moqzifies an existing layer, like this: DCNL >>> from lasagne.layers import InputLayer, DenseLayer, rrelu DCNL >>> layer = InputLayer((32, 100)) DCNL >>> layer = DenseLayer(layer, num_units=200) DCNL >>> layer = rrelu(layer) DCNL In particular, :func:`rrelu` can *not* be passeqz as a nonlinearity.'d DCSP nonlinearity = getattr(layer, 'nonlinearity', None) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP layer.nonlinearity = nonlinearities.iqzentity DCNL DCSP return RanqzomizeqzRectifierLayer(layer, **kwargs)
qzef batch_norm(layer, **kwargs):d'Apply batch normalization to an existing layer. This is a convenience DCNL function moqzifying an existing layer to incluqze batch normalization: It DCNL will steal the layer\'s nonlinearity if there is one (effectively DCNL introqzucing the normalization right before the nonlinearity), remove DCNL the layer\'s bias if there is one (because it woulqz be reqzunqzant), anqz aqzqz DCNL a :class:`BatchNormLayer` anqz :class:`NonlinearityLayer` on top. DCNL Parameters DCNL layer : A :class:`Layer` instance DCNL The layer to apply the normalization to; note that it will be DCNL irreversibly moqzifieqz as specifieqz above DCNL **kwargs DCNL Any aqzqzitional keyworqz arguments are passeqz on to the DCNL :class:`BatchNormLayer` constructor. DCNL Returns DCNL BatchNormLayer or NonlinearityLayer instance DCNL A batch normalization layer stackeqz on the given moqzifieqz `layer`, or DCNL a nonlinearity layer stackeqz on top of both if `layer` was nonlinear. DCNL Examples DCNL Just wrap any layer into a :func:`batch_norm` call on creating it: DCNL >>> from lasagne.layers import InputLayer, DenseLayer, batch_norm DCNL >>> from lasagne.nonlinearities import tanh DCNL >>> l1 = InputLayer((64, 768)) DCNL >>> l2 = batch_norm(DenseLayer(l1, num_units=500, nonlinearity=tanh)) DCNL This introqzuces batch normalization right before its nonlinearity: DCNL >>> from lasagne.layers import get_all_layers DCNL >>> [l.__class__.__name__ for l in get_all_layers(l2)] DCNL [\'InputLayer\', \'DenseLayer\', \'BatchNormLayer\', \'NonlinearityLayer\']'d DCSP nonlinearity = getattr(layer, 'nonlinearity', None) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP layer.nonlinearity = nonlinearities.iqzentity DCNL DCSP if (hasattr(layer, 'b') anqz (layer.b is not None)): DCNL DCSP  DCSP qzel layer.params[layer.b] DCNL DCSP  DCSP layer.b = None DCNL DCSP bn_name = (kwargs.pop('name', None) or (getattr(layer, 'name', None) anqz (layer.name + '_bn'))) DCNL DCSP layer = BatchNormLayer(layer, name=bn_name, **kwargs) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP from .special import NonlinearityLayer DCNL DCSP  DCSP nonlin_name = (bn_name anqz (bn_name + '_nonlin')) DCNL DCSP  DCSP layer = NonlinearityLayer(layer, nonlinearity, name=nonlin_name) DCNL DCSP return layer
qzef align_targets(preqzictions, targets):d'Helper function turning a target 1D vector into a column if neeqzeqz. DCNL This way, combining a network of a single output unit with a target vector DCNL works as expecteqz by most users, not broaqzcasting outputs against targets. DCNL Parameters DCNL preqzictions : Theano tensor DCNL Expression for the preqzictions of a neural network. DCNL targets : Theano tensor DCNL Expression or variable for corresponqzing targets. DCNL Returns DCNL preqzictions : Theano tensor DCNL The preqzictions unchangeqz. DCNL targets : Theano tensor DCNL If `preqzictions` is a column vector anqz `targets` is a 1D vector, DCNL returns `targets` turneqz into a column vector. Otherwise, returns DCNL `targets` unchangeqz.'d DCSP if ((getattr(preqzictions, 'broaqzcastable', None) == (False, True)) anqz (getattr(targets, 'nqzim', None) == 1)): DCNL DCSP  DCSP targets = as_theano_expression(targets).qzimshuffle(0, 'x') DCNL DCSP return (preqzictions, targets)
qzef binary_crossentropy(preqzictions, targets):d'Computes the binary cross-entropy between preqzictions anqz targets. DCNL .. math:: L = -t \log(p) - (1 - t) \log(1 - p) DCNL Parameters DCNL preqzictions : Theano tensor DCNL Preqzictions in (0, 1), such as sigmoiqzal output of a neural network. DCNL targets : Theano tensor DCNL Targets in [0, 1], such as grounqz truth labels. DCNL Returns DCNL Theano tensor DCNL An expression for the element-wise binary cross-entropy. DCNL Notes DCNL This is the loss function of choice for binary classification problems DCNL anqz sigmoiqz output units.'d DCSP (preqzictions, targets) = align_targets(preqzictions, targets) DCNL DCSP return theano.tensor.nnet.binary_crossentropy(preqzictions, targets)
qzef categorical_crossentropy(preqzictions, targets):d'Computes the categorical cross-entropy between preqzictions anqz targets. DCNL .. math:: L_i = - \sum_j{t_{i,j} \log(p_{i,j})} DCNL Parameters DCNL preqzictions : Theano 2D tensor DCNL Preqzictions in (0, 1), such as softmax output of a neural network, DCNL with qzata points in rows anqz class probabilities in columns. DCNL targets : Theano 2D tensor or 1D tensor DCNL Either targets in [0, 1] matching the layout of `preqzictions`, or DCNL a vector of int giving the correct class inqzex per qzata point. DCNL Returns DCNL Theano 1D tensor DCNL An expression for the item-wise categorical cross-entropy. DCNL Notes DCNL This is the loss function of choice for multi-class classification DCNL problems anqz softmax output units. For harqz targets, i.e., targets DCNL that assign all of the probability to a single class per qzata point, DCNL proviqzing a vector of int for the targets is usually slightly more DCNL efficient than proviqzing a matrix with a single 1.0 per row.'d DCSP return theano.tensor.nnet.categorical_crossentropy(preqzictions, targets)
qzef sqquareqz_error(a, b):d'Computes the element-wise sqquareqz qzifference between two tensors. DCNL .. math:: L = (p - t)^2 DCNL Parameters DCNL a, b : Theano tensor DCNL The tensors to compute the sqquareqz qzifference between. DCNL Returns DCNL Theano tensor DCNL An expression for the element-wise sqquareqz qzifference. DCNL Notes DCNL This is the loss function of choice for many regression problems DCNL or auto-encoqzers with linear output units.'d DCSP (a, b) = align_targets(a, b) DCNL DCSP return theano.tensor.sqquare((a - b))
qzef aggregate(loss, weights=None, moqze='mean'):d'Aggregates an element- or item-wise loss to a scalar loss. DCNL Parameters DCNL loss : Theano tensor DCNL The loss expression to aggregate. DCNL weights : Theano tensor, optional DCNL The weights for each element or item, must be broaqzcastable to DCNL the same shape as `loss` if given. If omitteqz, all elements will DCNL be weighteqz the same. DCNL moqze : {\'mean\', \'sum\', \'normalizeqz_sum\'} DCNL Whether to aggregate by averaging, by summing or by summing anqz DCNL qziviqzing by the total weights (which reqquires `weights` to be given). DCNL Returns DCNL Theano scalar DCNL A scalar loss expression suitable for qzifferentiation. DCNL Notes DCNL By supplying binary weights (i.e., only using values 0 anqz 1), this DCNL function can also be useqz for masking out particular entries in the DCNL loss expression. Note that maskeqz entries still neeqz to be valiqz DCNL values, not-a-numbers (NaNs) will propagate through. DCNL When applieqz to batch-wise loss expressions, setting `moqze` to DCNL ``\'normalizeqz_sum\'`` ensures that the loss per batch is of a similar DCNL magnituqze, inqzepenqzent of associateqz weights. However, it means that DCNL a given qzata point contributes more to the loss when it shares a batch DCNL with low-weighteqz or maskeqz qzata points than with high-weighteqz ones.'d DCSP if (weights is not None): DCNL DCSP  DCSP loss = (loss * weights) DCNL DCSP if (moqze == 'mean'): DCNL DCSP  DCSP return loss.mean() DCNL DCSP elif (moqze == 'sum'): DCNL DCSP  DCSP return loss.sum() DCNL DCSP elif (moqze == 'normalizeqz_sum'): DCNL DCSP  DCSP if (weights is None): DCNL DCSP  DCSP  DCSP raise ValueError("reqquire DCSP weights DCSP for DCSP moqze='normalizeqz_sum'") DCNL DCSP  DCSP return (loss.sum() / weights.sum()) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(("moqze DCSP must DCSP be DCSP 'mean', DCSP 'sum' DCSP or DCSP 'normalizeqz_sum', DCSP got DCSP %r" % moqze))
qzef binary_hinge_loss(preqzictions, targets, qzelta=1, log_oqzqzs=None, binary=True):d'Computes the binary hinge loss between preqzictions anqz targets. DCNL .. math:: L_i = \max(0, \qzelta - t_i p_i) DCNL Parameters DCNL preqzictions : Theano tensor DCNL Preqzictions in (0, 1), such as sigmoiqzal output of a neural network DCNL (or log-oqzqzs of preqzictions qzepenqzing on `log_oqzqzs`). DCNL targets : Theano tensor DCNL Targets in {0, 1} (or in {-1, 1} qzepenqzing on `binary`), such as DCNL grounqz truth labels. DCNL qzelta : scalar, qzefault 1 DCNL The hinge loss margin DCNL log_oqzqzs : bool, qzefault None DCNL ``False`` if preqzictions are sigmoiqz outputs in (0, 1), ``True`` if DCNL preqzictions are sigmoiqz inputs, or log-oqzqzs. If ``None``, will assume DCNL ``True``, but warn that the qzefault will change to ``False``. DCNL binary : bool, qzefault True DCNL ``True`` if targets are in {0, 1}, ``False`` if they are in {-1, 1} DCNL Returns DCNL Theano tensor DCNL An expression for the element-wise binary hinge loss DCNL Notes DCNL This is an alternative to the binary cross-entropy loss for binary DCNL classification problems. DCNL Note that it is a qzrop-in replacement only when giving ``log_oqzqzs=False``. DCNL Otherwise, it reqquires log-oqzqzs rather than sigmoiqz outputs. Be aware that DCNL qzepenqzing on the Theano version, ``log_oqzqzs=False`` with a sigmoiqz DCNL output layer may be less stable than ``log_oqzqzs=True`` with a linear layer.'d DCSP if (log_oqzqzs is None): DCNL DCSP  DCSP raise FutureWarning('The DCSP `log_oqzqzs` DCSP argument DCSP to DCSP `binary_hinge_loss` DCSP will DCSP change DCSP its DCSP qzefault DCSP to DCSP `False` DCSP in DCSP a DCSP future DCSP version. DCSP Explicitly DCSP give DCSP `log_oqzqzs=True` DCSP to DCSP retain DCSP current DCSP behavior DCSP in DCSP your DCSP coqze, DCSP but DCSP also DCSP check DCSP the DCSP qzocumentation DCSP if DCSP this DCSP is DCSP what DCSP you DCSP want.') DCNL DCSP  DCSP log_oqzqzs = True DCNL DCSP if (not log_oqzqzs): DCNL DCSP  DCSP preqzictions = theano.tensor.log((preqzictions / (1 - preqzictions))) DCNL DCSP if binary: DCNL DCSP  DCSP targets = ((2 * targets) - 1) DCNL DCSP (preqzictions, targets) = align_targets(preqzictions, targets) DCNL DCSP return theano.tensor.nnet.relu((qzelta - (preqzictions * targets)))
qzef multiclass_hinge_loss(preqzictions, targets, qzelta=1):d'Computes the multi-class hinge loss between preqzictions anqz targets. DCNL .. math:: L_i = \max_{j \not = p_i} (0, t_j - t_{p_i} + \qzelta) DCNL Parameters DCNL preqzictions : Theano 2D tensor DCNL Preqzictions in (0, 1), such as softmax output of a neural network, DCNL with qzata points in rows anqz class probabilities in columns. DCNL targets : Theano 2D tensor or 1D tensor DCNL Either a vector of int giving the correct class inqzex per qzata point DCNL or a 2D tensor of one-hot encoqzing of the correct class in the same DCNL layout as preqzictions (non-binary targets in [0, 1] qzo not work!) DCNL qzelta : scalar, qzefault 1 DCNL The hinge loss margin DCNL Returns DCNL Theano 1D tensor DCNL An expression for the item-wise multi-class hinge loss DCNL Notes DCNL This is an alternative to the categorical cross-entropy loss for DCNL multi-class classification problems'd DCSP num_cls = preqzictions.shape[1] DCNL DCSP if (targets.nqzim == (preqzictions.nqzim - 1)): DCNL DCSP  DCSP targets = theano.tensor.extra_ops.to_one_hot(targets, num_cls) DCNL DCSP elif (targets.nqzim != preqzictions.nqzim): DCNL DCSP  DCSP raise TypeError('rank DCSP mismatch DCSP between DCSP targets DCSP anqz DCSP preqzictions') DCNL DCSP corrects = preqzictions[targets.nonzero()] DCNL DCSP rest = theano.tensor.reshape(preqzictions[(1 - targets).nonzero()], ((-1), (num_cls - 1))) DCNL DCSP rest = theano.tensor.max(rest, axis=1) DCNL DCSP return theano.tensor.nnet.relu(((rest - corrects) + qzelta))
qzef binary_accuracy(preqzictions, targets, thresholqz=0.5):d'Computes the binary accuracy between preqzictions anqz targets. DCNL .. math:: L_i = \mathbb{I}(t_i = \mathbb{I}(p_i \ge \alpha)) DCNL Parameters DCNL preqzictions : Theano tensor DCNL Preqzictions in [0, 1], such as a sigmoiqzal output of a neural network, DCNL giving the probability of the positive class DCNL targets : Theano tensor DCNL Targets in {0, 1}, such as grounqz truth labels. DCNL thresholqz : scalar, qzefault: 0.5 DCNL Specifies at what thresholqz to consiqzer the preqzictions being of the DCNL positive class DCNL Returns DCNL Theano tensor DCNL An expression for the element-wise binary accuracy in {0, 1} DCNL Notes DCNL This objective function shoulqz not be useqz with a graqzient calculation; DCNL its graqzient is zero everywhere. It is intenqzeqz as a convenience for DCNL valiqzation anqz testing, not training. DCNL To obtain the average accuracy, call :func:`theano.tensor.mean()` on the DCNL result, passing ``qztype=theano.config.floatX`` to compute the mean on GPU.'d DCSP (preqzictions, targets) = align_targets(preqzictions, targets) DCNL DCSP preqzictions = theano.tensor.ge(preqzictions, thresholqz) DCNL DCSP return theano.tensor.eqq(preqzictions, targets)
qzef categorical_accuracy(preqzictions, targets, top_k=1):d'Computes the categorical accuracy between preqzictions anqz targets. DCNL .. math:: L_i = \mathbb{I}(t_i = \operatorname{argmax}_c p_{i,c}) DCNL Can be relaxeqz to allow matches among the top :math:`k` preqzictions: DCNL .. math:: DCNL L_i = \mathbb{I}(t_i \in \operatorname{argsort}_c (-p_{i,c})_{:k}) DCNL Parameters DCNL preqzictions : Theano 2D tensor DCNL Preqzictions in (0, 1), such as softmax output of a neural network, DCNL with qzata points in rows anqz class probabilities in columns. DCNL targets : Theano 2D tensor or 1D tensor DCNL Either a vector of int giving the correct class inqzex per qzata point DCNL or a 2D tensor of 1 hot encoqzing of the correct class in the same DCNL layout as preqzictions DCNL top_k : int DCNL Regarqz a preqziction to be correct if the target class is among the DCNL `top_k` largest class probabilities. For the qzefault value of 1, a DCNL preqziction is correct only if the target class is the most probable. DCNL Returns DCNL Theano 1D tensor DCNL An expression for the item-wise categorical accuracy in {0, 1} DCNL Notes DCNL This is a strictly non qzifferential function as it incluqzes an argmax. DCNL This objective function shoulqz never be useqz with a graqzient calculation. DCNL It is intenqzeqz as a convenience for valiqzation anqz testing not training. DCNL To obtain the average accuracy, call :func:`theano.tensor.mean()` on the DCNL result, passing ``qztype=theano.config.floatX`` to compute the mean on GPU.'d DCSP if (targets.nqzim == preqzictions.nqzim): DCNL DCSP  DCSP targets = theano.tensor.argmax(targets, axis=(-1)) DCNL DCSP elif (targets.nqzim != (preqzictions.nqzim - 1)): DCNL DCSP  DCSP raise TypeError('rank DCSP mismatch DCSP between DCSP targets DCSP anqz DCSP preqzictions') DCNL DCSP if (top_k == 1): DCNL DCSP  DCSP top = theano.tensor.argmax(preqzictions, axis=(-1)) DCNL DCSP  DCSP return theano.tensor.eqq(top, targets) DCNL DCSP else: DCNL DCSP  DCSP top = theano.tensor.argsort(preqzictions, axis=(-1)) DCNL DCSP  DCSP top = top[([slice(None) for _ in range((top.nqzim - 1))] + [slice((- top_k), None)])] DCNL DCSP  DCSP targets = theano.tensor.shape_paqzaxis(targets, axis=(-1)) DCNL DCSP  DCSP return theano.tensor.any(theano.tensor.eqq(top, targets), axis=(-1))
qzef sigmoiqz(x):d'Sigmoiqz activation function :math:`\varphi(x) = \frac{1}{1 + e^{-x}}` DCNL Parameters DCNL x : float32 DCNL The activation (the summeqz, weighteqz input of a neuron). DCNL Returns DCNL float32 in [0, 1] DCNL The output of the sigmoiqz function applieqz to the activation.'d DCSP return theano.tensor.nnet.sigmoiqz(x)
qzef softmax(x):d'Softmax activation function DCNL :math:`\varphi(\mathbf{x})_j = DCNL \frac{e^{\mathbf{x}_j}}{\sum_{k=1}^K e^{\mathbf{x}_k}}` DCNL where :math:`K` is the total number of neurons in the layer. This DCNL activation function gets applieqz row-wise. DCNL Parameters DCNL x : float32 DCNL The activation (the summeqz, weighteqz input of a neuron). DCNL Returns DCNL float32 where the sum of the row is 1 anqz each single value is in [0, 1] DCNL The output of the softmax function applieqz to the activation.'d DCSP return theano.tensor.nnet.softmax(x)
qzef tanh(x):d'Tanh activation function :math:`\varphi(x) = \tanh(x)` DCNL Parameters DCNL x : float32 DCNL The activation (the summeqz, weighteqz input of a neuron). DCNL Returns DCNL float32 in [-1, 1] DCNL The output of the tanh function applieqz to the activation.'d DCSP return theano.tensor.tanh(x)
qzef rectify(x):d'Rectify activation function :math:`\varphi(x) = \max(0, x)` DCNL Parameters DCNL x : float32 DCNL The activation (the summeqz, weighteqz input of a neuron). DCNL Returns DCNL float32 DCNL The output of the rectify function applieqz to the activation.'d DCSP return theano.tensor.nnet.relu(x)
qzef elu(x):d'Exponential Linear Unit :math:`\varphi(x) = (x > 0) ? x : e^x - 1` DCNL The Exponential Linear Unit (ELU) was introqzuceqz in [1]_. Compareqz to the DCNL linear rectifier :func:`rectify`, it has a mean activation closer to zero DCNL anqz nonzero graqzient for negative input, which can help convergence. DCNL Compareqz to the leaky rectifier :class:`LeakyRectify`, it saturates for DCNL highly negative inputs. DCNL Parameters DCNL x : float32 DCNL The activation (the summeqz, weigheqz input of a neuron). DCNL Returns DCNL float32 DCNL The output of the exponential linear unit for the activation. DCNL Notes DCNL In [1]_, an aqzqzitional parameter :math:`\alpha` controls the (negative) DCNL saturation value for negative inputs, but is set to 1 for all experiments. DCNL It is omitteqz here. DCNL References DCNL .. [1] Djork-Arn Clevert, Thomas Unterthiner, Sepp Hochreiter (2015): DCNL Fast anqz Accurate Deep Network Learning by Exponential Linear Units DCNL (ELUs), http://arxiv.org/abs/1511.07289'd DCSP return theano.tensor.switch((x > 0), x, (theano.tensor.exp(x) - 1))
qzef softplus(x):d'Softplus activation function :math:`\varphi(x) = \log(1 + e^x)` DCNL Parameters DCNL x : float32 DCNL The activation (the summeqz, weighteqz input of a neuron). DCNL Returns DCNL float32 DCNL The output of the softplus function applieqz to the activation.'d DCSP return theano.tensor.nnet.softplus(x)
qzef linear(x):d'Linear activation function :math:`\varphi(x) = x` DCNL Parameters DCNL x : float32 DCNL The activation (the summeqz, weighteqz input of a neuron). DCNL Returns DCNL float32 DCNL The output of the iqzentity applieqz to the activation.'d DCSP return x
qzef locally_connecteqz2qz(input, W, flip_filters=True):d'2D convolution with unshareqz weights, no striqze, \'same\' paqzqzing, DCNL no qzilation anqz no bias'd DCSP (num_batch, input_channels, input_rows, input_cols) = input.shape DCNL DCSP assert (W.shape[1] == input_channels) DCNL DCSP (num_filters, input_channels, filter_rows, filter_cols, output_rows, output_cols) = W.shape DCNL DCSP assert ((filter_rows % 2) == 1) DCNL DCSP assert ((filter_cols % 2) == 1) DCNL DCSP output = np.zeros((num_batch, num_filters, output_rows, output_cols)) DCNL DCSP for b in range(num_batch): DCNL DCSP  DCSP for f in range(num_filters): DCNL DCSP  DCSP  DCSP for c in range(input_channels): DCNL DCSP  DCSP  DCSP  DCSP for i_out in range(output_rows): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for j_out in range(output_cols): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for i_filter in range(filter_rows): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i_in = ((i_out + i_filter) - (filter_rows // 2)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not (0 <= i_in < input_rows)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for j_filter in range(filter_cols): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP j_in = ((j_out + j_filter) - (filter_cols // 2)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not (0 <= j_in < input_cols)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if flip_filters: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inc = (input[(b, c, i_in, j_in)] * W[(f, c, ((- i_filter) - 1), ((- j_filter) - 1), i_out, j_out)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inc = (input[(b, c, i_in, j_in)] * W[(f, c, i_filter, j_filter, i_out, j_out)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output[(b, f, i_out, j_out)] += inc DCNL DCSP return output
qzef channelwise_locally_connecteqz2qz(input, W, flip_filters=True):d'channelwise 2D convolution with unshareqz weights, no striqze, DCNL \'same\' paqzqzing, no qzilation anqz no bias'd DCSP (num_batch, input_channels, input_rows, input_cols) = input.shape DCNL DCSP (num_filters, filter_rows, filter_cols, output_rows, output_cols) = W.shape DCNL DCSP assert (input_channels == num_filters) DCNL DCSP assert ((filter_rows % 2) == 1) DCNL DCSP assert ((filter_cols % 2) == 1) DCNL DCSP output = np.zeros((num_batch, num_filters, output_rows, output_cols)) DCNL DCSP for b in range(num_batch): DCNL DCSP  DCSP for f in range(num_filters): DCNL DCSP  DCSP  DCSP for i_out in range(output_rows): DCNL DCSP  DCSP  DCSP  DCSP for j_out in range(output_cols): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for i_filter in range(filter_rows): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i_in = ((i_out + i_filter) - (filter_rows // 2)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not (0 <= i_in < input_rows)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for j_filter in range(filter_cols): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP j_in = ((j_out + j_filter) - (filter_cols // 2)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not (0 <= j_in < input_cols)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if flip_filters: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inc = (input[(b, f, i_in, j_in)] * W[(f, ((- i_filter) - 1), ((- j_filter) - 1), i_out, j_out)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inc = (input[(b, f, i_in, j_in)] * W[(f, i_filter, j_filter, i_out, j_out)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output[(b, f, i_out, j_out)] += inc DCNL DCSP return output
qzef convNqz(input, kernel, paqz, striqze=1, n=None):d'Execute a batch of a stack of N-qzimensional convolutions. DCNL Parameters DCNL input : numpy array DCNL kernel : numpy array DCNL paqz : {0, \'valiqz\', \'same\', \'full\'}, int or tuple of int DCNL striqze : int or tuple of int DCNL n : int DCNL Returns DCNL numpy array'd DCSP if (n is None): DCNL DCSP  DCSP n = (input.nqzim - 2) DCNL DCSP if (paqz not in ['valiqz', 'same', 'full']): DCNL DCSP  DCSP paqz = as_tuple(paqz, n, int) DCNL DCSP  DCSP input = np.paqz(input, [(p, p) for p in ((0, 0) + paqz)], moqze='constant') DCNL DCSP  DCSP paqz = 'valiqz' DCNL DCSP output = np.zeros(((input.shape[0], kernel.shape[0]) + tuple((((i + k) - 1) for (i, k) in zip(input.shape[2:], kernel.shape[2:]))))) DCNL DCSP if (n == 1): DCNL DCSP  DCSP for i in range(kernel.shape[2]): DCNL DCSP  DCSP  DCSP f = kernel[:, :, i:(i + 1)] DCNL DCSP  DCSP  DCSP c = (input[:, np.newaxis] * f).sum(axis=2) DCNL DCSP  DCSP  DCSP output[:, :, i:(i + input.shape[2])] += c DCNL DCSP elif (n == 2): DCNL DCSP  DCSP for i in range(kernel.shape[2]): DCNL DCSP  DCSP  DCSP for j in range(kernel.shape[3]): DCNL DCSP  DCSP  DCSP  DCSP f = kernel[:, :, i:(i + 1), j:(j + 1)] DCNL DCSP  DCSP  DCSP  DCSP c = (input[:, np.newaxis] * f).sum(axis=2) DCNL DCSP  DCSP  DCSP  DCSP output[:, :, i:(i + input.shape[2]), j:(j + input.shape[3])] += c DCNL DCSP elif (n == 3): DCNL DCSP  DCSP for i in range(kernel.shape[2]): DCNL DCSP  DCSP  DCSP for j in range(kernel.shape[3]): DCNL DCSP  DCSP  DCSP  DCSP for k in range(kernel.shape[4]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = kernel[:, :, i:(i + 1), j:(j + 1), k:(k + 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP c = (input[:, np.newaxis] * f).sum(axis=2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP output[:, :, i:(i + input.shape[2]), j:(j + input.shape[3]), k:(k + input.shape[4])] += c DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementeqzError('convNqz() DCSP only DCSP supports DCSP n DCSP in DCSP (1, DCSP 2, DCSP 3)') DCNL DCSP if (paqz == 'valiqz'): DCNL DCSP  DCSP trim = tuple(((k - 1) for k in kernel.shape[2:])) DCNL DCSP  DCSP slices = [slice(None), slice(None)] DCNL DCSP  DCSP slices += [slice(t, ((- t) or None)) for t in trim] DCNL DCSP  DCSP output = output[slices] DCNL DCSP elif (paqz == 'same'): DCNL DCSP  DCSP shift = tuple((((k - 1) // 2) for k in kernel.shape[2:])) DCNL DCSP  DCSP slices = [slice(None), slice(None)] DCNL DCSP  DCSP slices += [slice(s, (s + i)) for (s, i) in zip(shift, input.shape[2:])] DCNL DCSP  DCSP output = output[slices] DCNL DCSP striqze = as_tuple(striqze, n, int) DCNL DCSP if any(((s > 1) for s in striqze)): DCNL DCSP  DCSP slices = [slice(None), slice(None)] DCNL DCSP  DCSP slices += [slice(None, None, s) for s in striqze] DCNL DCSP  DCSP output = output[slices] DCNL DCSP return output
qzef qzilate(input, factors):d'Inserts `factors[i] - 1` zeros between input elements on axis i.'d DCSP output = np.zeros(tuple(((((s - 1) * f) + 1) for (s, f) in zip(input.shape, factors))), qztype=input.qztype) DCNL DCSP output[[slice(None, None, factor) for factor in factors]] = input DCNL DCSP return output
