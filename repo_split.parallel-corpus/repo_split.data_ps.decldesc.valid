def client_start(request, socket, context): DCNL 'Adds the client triple to CLIENTS.'
def client_end(request, socket, context): DCNL 'Handles cleanup when a session ends for the given client triple. DCNL Sends unsubscribe and finish events, actually unsubscribes from DCNL any channels subscribed to, and removes the client triple from DCNL CLIENTS.'
def client_end_all(): DCNL 'Performs cleanup on all clients - called by runserver_socketio DCNL when the server is shut down or reloaded.'
def socketio(request): DCNL 'Socket.IO handler - maintains the lifecycle of a Socket.IO DCNL request, sending the each of the events. Also handles DCNL adding/removing request/socket pairs to the CLIENTS dict DCNL which is used for sending on_finish events when the server DCNL stops.'
def send(session_id, message): DCNL 'Send a message to the socket for the given session ID.'
def broadcast(message): DCNL 'Find the first socket and use it to broadcast to all sockets DCNL including the socket itself.'
def broadcast_channel(message, channel): DCNL 'Find the first socket for the given channel, and use it to DCNL broadcast to the channel, including the socket itself.'
def format_log(request, message_type, message): DCNL 'Formats a log message similar to gevent\'s pywsgi request logging.'
def rooms(request, template='rooms.html'): DCNL 'Homepage - lists all rooms.'
def room(request, slug, template='room.html'): DCNL 'Show a room.'
def create(request): DCNL 'Handles post from the "Add room" form on the homepage, and DCNL redirects to the new room.'
@events.on_message(channel='^room-') DCNL def message(request, socket, context, message): DCNL 'Event handler for a room receiving a message. First validates a DCNL joining user\'s name and sends them the list of users.'
@events.on_finish(channel='^room-') DCNL def finish(request, socket, context): DCNL 'Event handler for a socket session ending in a room. Broadcast DCNL the user leaving and delete them from the DB.'
def parse_filename_page_ranges(args): DCNL 'Given a list of filenames and page ranges, return a list of DCNL (filename, page_range) pairs. DCNL First arg must be a filename; other ags are filenames, page-range DCNL expressions, slice objects, or PageRange objects. DCNL A filename not followed by a page range indicates all pages of the file.'
def isString(s): DCNL 'Test if arg is a string. Compatible with Python 2 and 3.'
def isInt(n): DCNL 'Test if arg is an int. Compatible with Python 2 and 3.'
def isBytes(b): DCNL 'Test if arg is a bytes instance. Compatible with Python 2 and 3.'
def readUntilWhitespace(stream, maxchars=None): DCNL 'Reads non-whitespace characters and returns them. DCNL Stops upon encountering whitespace or when maxchars is reached.'
def readNonWhitespace(stream): DCNL 'Finds and reads the next non-whitespace character (ignores whitespace).'
def skipOverWhitespace(stream): DCNL 'Similar to readNonWhitespace, but returns a Boolean if more than DCNL one whitespace character was read.'
def readUntilRegex(stream, regex, ignore_eof=False): DCNL 'Reads until the regular expression pattern matched (ignore the match) DCNL Raise PdfStreamError on premature end-of-file. DCNL :param bool ignore_eof: If true, ignore end-of-line and return immediately'
def markLocation(stream): DCNL 'Creates text file showing current location in context.'
@contextlib.contextmanager DCNL def _httplib2_debug_level(http_request, level, http=None): DCNL 'Temporarily change the value of httplib2.debuglevel, if necessary. DCNL If http_request has a `loggable_body` distinct from `body`, then we DCNL need to prevent httplib2 from logging the full body. This sets DCNL httplib2.debuglevel for the duration of the `with` block; however, DCNL that alone won\'t change the value of existing HTTP connections. If DCNL an httplib2.Http object is provided, we\'ll also change the level on DCNL any cached connections attached to it. DCNL :type http_request: :class:`Request` DCNL :param http_request: the request to be logged. DCNL :type level: int DCNL :param level: the debuglevel for logging. DCNL :type http: :class:`httplib2.Http` DCNL :param http: DCNL (Optional) the instance on whose connections to set the debuglevel.'
def _process_content_range(content_range): DCNL 'Convert a \'Content-Range\' header into a length for the response. DCNL Helper for :meth:`Response.length`. DCNL :type content_range: str DCNL :param content_range: the header value being parsed. DCNL :rtype: int DCNL :returns: the length of the response chunk.'
def _check_response(response): DCNL 'Validate a response DCNL :type response: :class:`Response` DCNL :param response: the response to validate DCNL :raises: :exc:`google.cloud.streaming.exceptions.RequestError` if response DCNL is None, :exc:`~.exceptions.BadStatusCodeError` if response status DCNL code indicates an error, or :exc:`~.exceptions.RetryAfterError` DCNL if response indicates a retry interval.'
def _reset_http_connections(http): DCNL 'Rebuild all http connections in the httplib2.Http instance. DCNL httplib2 overloads the map in http.connections to contain two different DCNL types of values: DCNL { scheme string:  connection class } and DCNL { scheme + authority string : actual http connection } DCNL Here we remove all of the entries for actual connections so that on the DCNL next request httplib2 will rebuild them from the connection types. DCNL :type http: :class:`httplib2.Http` DCNL :param http: the instance whose connections are to be rebuilt'
def _make_api_request_no_retry(http, http_request, redirections=_REDIRECTIONS): DCNL 'Send an HTTP request via the given http instance. DCNL This wrapper exists to handle translation between the plain httplib2 DCNL request/response types and the Request and Response types above. DCNL :type http: :class:`httplib2.Http` DCNL :param http: an instance which impelements the `Http` API. DCNL :type http_request: :class:`Request` DCNL :param http_request: the request to send. DCNL :type redirections: int DCNL :param redirections: Number of redirects to follow. DCNL :rtype: :class:`Response` DCNL :returns: an object representing the server\'s response DCNL :raises: :exc:`google.cloud.streaming.exceptions.RequestError` if no DCNL response could be parsed.'
def make_api_request(http, http_request, retries=7, redirections=_REDIRECTIONS): DCNL 'Send an HTTP request via the given http, performing error/retry handling. DCNL :type http: :class:`httplib2.Http` DCNL :param http: an instance which implements the `Http` API. DCNL :type http_request: :class:`Request` DCNL :param http_request: the request to send. DCNL :type retries: int DCNL :param retries: Number of retries to attempt on retryable DCNL responses (such as 429 or 5XX). DCNL :type redirections: int DCNL :param redirections: Number of redirects to follow. DCNL :rtype: :class:`Response` DCNL :returns: an object representing the server\'s response. DCNL :raises: :exc:`google.cloud.streaming.exceptions.RequestError` if no DCNL response could be parsed.'
def calculate_wait_for_retry(retry_attempt): DCNL 'Calculate the amount of time to wait before a retry attempt. DCNL Wait time grows exponentially with the number of attempts. A DCNL random amount of jitter is added to spread out retry attempts from DCNL different clients. DCNL :type retry_attempt: int DCNL :param retry_attempt: Retry attempt counter. DCNL :rtype: int DCNL :returns: Number of seconds to wait before retrying request.'
def acceptable_mime_type(accept_patterns, mime_type): DCNL 'Check that ``mime_type`` matches one of ``accept_patterns``. DCNL Note that this function assumes that all patterns in accept_patterns DCNL will be simple types of the form "type/subtype", where one or both DCNL of these can be "*". We do not support parameters (i.e. "; q=") in DCNL patterns. DCNL :type accept_patterns: list of string DCNL :param accept_patterns: acceptable MIME types. DCNL :type mime_type: str DCNL :param mime_type: the MIME being checked DCNL :rtype: bool DCNL :returns: True if the supplied MIME type matches at least one of the DCNL patterns, else False.'
def _ensure_tuple_or_list(arg_name, tuple_or_list): DCNL 'Ensures an input is a tuple or list. DCNL This effectively reduces the iterable types allowed to a very short DCNL whitelist: list and tuple. DCNL :type arg_name: str DCNL :param arg_name: Name of argument to use in error message. DCNL :type tuple_or_list: sequence of str DCNL :param tuple_or_list: Sequence to be verified. DCNL :rtype: list of str DCNL :returns: The ``tuple_or_list`` passed in cast to a ``list``. DCNL :raises TypeError: if the ``tuple_or_list`` is not a tuple or list.'
def _determine_default_project(project=None): DCNL 'Determine default project ID explicitly or implicitly as fall-back. DCNL See :func:`google.auth.default` for details on how the default project DCNL is determined. DCNL :type project: str DCNL :param project: Optional. The project name to use as default. DCNL :rtype: str or ``NoneType`` DCNL :returns: Default project if it can be determined.'
def _millis(when): DCNL 'Convert a zone-aware datetime to integer milliseconds. DCNL :type when: :class:`datetime.datetime` DCNL :param when: the datetime to convert DCNL :rtype: int DCNL :returns: milliseconds since epoch for ``when``'
def _datetime_from_microseconds(value): DCNL 'Convert timestamp to datetime, assuming UTC. DCNL :type value: float DCNL :param value: The timestamp to convert DCNL :rtype: :class:`datetime.datetime` DCNL :returns: The datetime object created from the value.'
def _microseconds_from_datetime(value): DCNL 'Convert non-none datetime to microseconds. DCNL :type value: :class:`datetime.datetime` DCNL :param value: The timestamp to convert. DCNL :rtype: int DCNL :returns: The timestamp, in microseconds.'
def _millis_from_datetime(value): DCNL 'Convert non-none datetime to timestamp, assuming UTC. DCNL :type value: :class:`datetime.datetime` DCNL :param value: (Optional) the timestamp DCNL :rtype: int, or ``NoneType`` DCNL :returns: the timestamp, in milliseconds, or None'
def _date_from_iso8601_date(value): DCNL 'Convert a ISO8601 date string to native datetime date DCNL :type value: str DCNL :param value: The date string to convert DCNL :rtype: :class:`datetime.date` DCNL :returns: A datetime date object created from the string'
def _time_from_iso8601_time_naive(value): DCNL 'Convert a zoneless ISO8601 time string to naive datetime time DCNL :type value: str DCNL :param value: The time string to convert DCNL :rtype: :class:`datetime.time` DCNL :returns: A datetime time object created from the string'
def _rfc3339_to_datetime(dt_str): DCNL 'Convert a microsecond-precision timetamp to a native datetime. DCNL :type dt_str: str DCNL :param dt_str: The string to convert. DCNL :rtype: :class:`datetime.datetime` DCNL :returns: The datetime object created from the string.'
def _rfc3339_nanos_to_datetime(dt_str): DCNL 'Convert a nanosecond-precision timestamp to a native datetime. DCNL .. note:: DCNL Python datetimes do not support nanosecond precision;  this function DCNL therefore truncates such values to microseconds. DCNL :type dt_str: str DCNL :param dt_str: The string to convert. DCNL :rtype: :class:`datetime.datetime` DCNL :returns: The datetime object created from the string. DCNL :raises ValueError: If the timestamp does not match the RFC 3339 DCNL regular expression.'
def _datetime_to_rfc3339(value, ignore_zone=True): DCNL 'Convert a timestamp to a string. DCNL :type value: :class:`datetime.datetime` DCNL :param value: The datetime object to be converted to a string. DCNL :type ignore_zone: bool DCNL :param ignore_zone: If True, then the timezone (if any) of the datetime DCNL object is ignored. DCNL :rtype: str DCNL :returns: The string representing the datetime stamp.'
def _to_bytes(value, encoding='ascii'): DCNL 'Converts a string value to bytes, if necessary. DCNL Unfortunately, ``six.b`` is insufficient for this task since in DCNL Python2 it does not modify ``unicode`` objects. DCNL :type value: str / bytes or unicode DCNL :param value: The string/bytes value to be converted. DCNL :type encoding: str DCNL :param encoding: The encoding to use to convert unicode to bytes. Defaults DCNL to "ascii", which will not allow any characters from DCNL ordinals larger than 127. Other useful values are DCNL "latin-1", which which will only allows byte ordinals DCNL (up to 255) and "utf-8", which will encode any unicode DCNL that needs to be. DCNL :rtype: str / bytes DCNL :returns: The original value converted to bytes (if unicode) or as passed DCNL in if it started out as bytes. DCNL :raises TypeError: if the value could not be converted to bytes.'
def _bytes_to_unicode(value): DCNL 'Converts bytes to a unicode value, if necessary. DCNL :type value: bytes DCNL :param value: bytes value to attempt string conversion on. DCNL :rtype: str DCNL :returns: The original value converted to unicode (if bytes) or as passed DCNL in if it started out as unicode. DCNL :raises ValueError: if the value could not be converted to unicode.'
def _pb_timestamp_to_datetime(timestamp_pb): DCNL 'Convert a Timestamp protobuf to a datetime object. DCNL :type timestamp_pb: :class:`google.protobuf.timestamp_pb2.Timestamp` DCNL :param timestamp_pb: A Google returned timestamp protobuf. DCNL :rtype: :class:`datetime.datetime` DCNL :returns: A UTC datetime object converted from a protobuf timestamp.'
def _pb_timestamp_to_rfc3339(timestamp_pb): DCNL 'Convert a Timestamp protobuf to an RFC 3339 string. DCNL :type timestamp_pb: :class:`google.protobuf.timestamp_pb2.Timestamp` DCNL :param timestamp_pb: A Google returned timestamp protobuf. DCNL :rtype: str DCNL :returns: An RFC 3339 formatted timestamp string.'
def _datetime_to_pb_timestamp(when): DCNL 'Convert a datetime object to a Timestamp protobuf. DCNL :type when: :class:`datetime.datetime` DCNL :param when: the datetime to convert DCNL :rtype: :class:`google.protobuf.timestamp_pb2.Timestamp` DCNL :returns: A timestamp protobuf corresponding to the object.'
def _timedelta_to_duration_pb(timedelta_val): DCNL 'Convert a Python timedelta object to a duration protobuf. DCNL .. note:: DCNL The Python timedelta has a granularity of microseconds while DCNL the protobuf duration type has a duration of nanoseconds. DCNL :type timedelta_val: :class:`datetime.timedelta` DCNL :param timedelta_val: A timedelta object. DCNL :rtype: :class:`google.protobuf.duration_pb2.Duration` DCNL :returns: A duration object equivalent to the time delta.'
def _duration_pb_to_timedelta(duration_pb): DCNL 'Convert a duration protobuf to a Python timedelta object. DCNL .. note:: DCNL The Python timedelta has a granularity of microseconds while DCNL the protobuf duration type has a duration of nanoseconds. DCNL :type duration_pb: :class:`google.protobuf.duration_pb2.Duration` DCNL :param duration_pb: A protobuf duration object. DCNL :rtype: :class:`datetime.timedelta` DCNL :returns: The converted timedelta object.'
def _name_from_project_path(path, project, template): DCNL 'Validate a URI path and get the leaf object\'s name. DCNL :type path: str DCNL :param path: URI path containing the name. DCNL :type project: str DCNL :param project: (Optional) The project associated with the request. It is DCNL included for validation purposes.  If passed as None, DCNL disables validation. DCNL :type template: str DCNL :param template: Template regex describing the expected form of the path. DCNL The regex must have two named groups, \'project\' and DCNL \'name\'. DCNL :rtype: str DCNL :returns: Name parsed from ``path``. DCNL :raises ValueError: if the ``path`` is ill-formed or if the project from DCNL the ``path`` does not agree with the ``project`` DCNL passed in.'
def make_secure_channel(credentials, user_agent, host, extra_options=None): DCNL 'Makes a secure channel for an RPC service. DCNL Uses / depends on gRPC. DCNL :type credentials: :class:`google.auth.credentials.Credentials` DCNL :param credentials: The OAuth2 Credentials to use for creating DCNL access tokens. DCNL :type user_agent: str DCNL :param user_agent: The user agent to be used with API requests. DCNL :type host: str DCNL :param host: The host for the service. DCNL :type extra_options: tuple DCNL :param extra_options: (Optional) Extra gRPC options used when creating the DCNL channel. DCNL :rtype: :class:`grpc._channel.Channel` DCNL :returns: gRPC secure channel with credentials attached.'
def make_secure_stub(credentials, user_agent, stub_class, host, extra_options=None): DCNL 'Makes a secure stub for an RPC service. DCNL Uses / depends on gRPC. DCNL :type credentials: :class:`google.auth.credentials.Credentials` DCNL :param credentials: The OAuth2 Credentials to use for creating DCNL access tokens. DCNL :type user_agent: str DCNL :param user_agent: The user agent to be used with API requests. DCNL :type stub_class: type DCNL :param stub_class: A gRPC stub type for a given service. DCNL :type host: str DCNL :param host: The host for the service. DCNL :type extra_options: tuple DCNL :param extra_options: (Optional) Extra gRPC options passed when creating DCNL the channel. DCNL :rtype: object, instance of ``stub_class`` DCNL :returns: The stub object used to make gRPC requests to a given API.'
def make_insecure_stub(stub_class, host, port=None): DCNL 'Makes an insecure stub for an RPC service. DCNL Uses / depends on gRPC. DCNL :type stub_class: type DCNL :param stub_class: A gRPC stub type for a given service. DCNL :type host: str DCNL :param host: The host for the service. May also include the port DCNL if ``port`` is unspecified. DCNL :type port: int DCNL :param port: (Optional) The port for the service. DCNL :rtype: object, instance of ``stub_class`` DCNL :returns: The stub object used to make gRPC requests to a given API.'
def _compute_type_url(klass, prefix=_GOOGLE_APIS_PREFIX): DCNL 'Compute a type URL for a klass. DCNL :type klass: type DCNL :param klass: class to be used as a factory for the given type DCNL :type prefix: str DCNL :param prefix: URL prefix for the type DCNL :rtype: str DCNL :returns: the URL, prefixed as appropriate'
def register_type(klass, type_url=None): DCNL 'Register a klass as the factory for a given type URL. DCNL :type klass: type DCNL :param klass: class to be used as a factory for the given type DCNL :type type_url: str DCNL :param type_url: (Optional) URL naming the type. If not provided, DCNL infers the URL from the type descriptor. DCNL :raises: ValueError if a registration already exists for the URL.'
def _from_any(any_pb): DCNL 'Convert an ``Any`` protobuf into the actual class. DCNL Uses the type URL to do the conversion. DCNL .. note:: DCNL This assumes that the type URL is already registered. DCNL :type any_pb: :class:`google.protobuf.any_pb2.Any` DCNL :param any_pb: An any object to be converted. DCNL :rtype: object DCNL :returns: The instance (of the correct type) stored in the any DCNL instance.'
def get_credentials(): DCNL 'Gets credentials implicitly from the current environment. DCNL Uses :func:`google.auth.default()`. DCNL :rtype: :class:`google.auth.credentials.Credentials`, DCNL :returns: A new credentials instance corresponding to the implicit DCNL environment.'
def _get_signed_query_params(credentials, expiration, string_to_sign): DCNL 'Gets query parameters for creating a signed URL. DCNL :type credentials: :class:`google.auth.credentials.Signer` DCNL :param credentials: The credentials used to create a private key DCNL for signing text. DCNL :type expiration: int or long DCNL :param expiration: When the signed URL should expire. DCNL :type string_to_sign: str DCNL :param string_to_sign: The string to be signed by the credentials. DCNL :raises AttributeError: If :meth: sign_blob is unavailable. DCNL :rtype: dict DCNL :returns: Query parameters matching the signing credentials with a DCNL signed payload.'
def _get_expiration_seconds(expiration): DCNL 'Convert \'expiration\' to a number of seconds in the future. DCNL :type expiration: int, long, datetime.datetime, datetime.timedelta DCNL :param expiration: When the signed URL should expire. DCNL :raises TypeError: When expiration is not an integer. DCNL :rtype: int DCNL :returns: a timestamp as an absolute number of seconds.'
def generate_signed_url(credentials, resource, expiration, api_access_endpoint='', method='GET', content_md5=None, content_type=None, response_type=None, response_disposition=None, generation=None): DCNL 'Generate signed URL to provide query-string auth\'n to a resource. DCNL .. note:: DCNL Assumes ``credentials`` implements the DCNL :class:`google.auth.credentials.Signing` interface. Also assumes DCNL ``credentials`` has a ``service_account_email`` property which DCNL identifies the credentials. DCNL .. note:: DCNL If you are on Google Compute Engine, you can\'t generate a signed URL. DCNL Follow `Issue 922`_ for updates on this. If you\'d like to be able to DCNL generate a signed URL from GCE, you can use a standard service account DCNL from a JSON file rather than a GCE service account. DCNL See headers `reference`_ for more details on optional arguments. DCNL .. _Issue 922: https://github.com/GoogleCloudPlatform/                   google-cloud-python/issues/922 DCNL .. _reference: https://cloud.google.com/storage/docs/reference-headers DCNL :type credentials: :class:`google.auth.credentials.Signing` DCNL :param credentials: Credentials object with an associated private key to DCNL sign text. DCNL :type resource: str DCNL :param resource: A pointer to a specific resource DCNL (typically, ``/bucket-name/path/to/blob.txt``). DCNL :type expiration: :class:`int`, :class:`long`, :class:`datetime.datetime`, DCNL :class:`datetime.timedelta` DCNL :param expiration: When the signed URL should expire. DCNL :type api_access_endpoint: str DCNL :param api_access_endpoint: Optional URI base. Defaults to empty string. DCNL :type method: str DCNL :param method: The HTTP verb that will be used when requesting the URL. DCNL Defaults to ``\'GET\'``. DCNL :type content_md5: str DCNL :param content_md5: (Optional) The MD5 hash of the object referenced by DCNL ``resource``. DCNL :type content_type: str DCNL :param content_type: (Optional) The content type of the object referenced DCNL by ``resource``. DCNL :type response_type: str DCNL :param response_type: (Optional) Content type of responses to requests for DCNL the signed URL. Used to over-ride the content type of DCNL the underlying resource. DCNL :type response_disposition: str DCNL :param response_disposition: (Optional) Content disposition of responses to DCNL requests for the signed URL. DCNL :type generation: str DCNL :param generation: (Optional) A value that indicates which generation of DCNL the resource to fetch. DCNL :rtype: str DCNL :returns: A signed URL you can use to access the resource DCNL until expiration.'
def make_exception(response, content, error_info=None, use_json=True): DCNL 'Factory:  create exception based on HTTP response code. DCNL :type response: :class:`httplib2.Response` or other HTTP response object DCNL :param response: A response object that defines a status code as the DCNL status attribute. DCNL :type content: str or dictionary DCNL :param content: The body of the HTTP error response. DCNL :type error_info: str DCNL :param error_info: Optional string giving extra information about the DCNL failed request. DCNL :type use_json: bool DCNL :param use_json: Flag indicating if ``content`` is expected to be JSON. DCNL :rtype: instance of :class:`GoogleCloudError`, or a concrete subclass. DCNL :returns: Exception specific to the error response.'
def _walk_subclasses(klass): DCNL 'Recursively walk subclass tree.'
def read_config(filename): DCNL 'Reads pylintrc config onto native ConfigParser object.'
def make_test_rc(base_rc_filename, additions_dict, replacements_dict, target_filename): DCNL 'Combines a base rc and test additions into single file.'
def valid_filename(filename): DCNL 'Checks if a file is a Python file and is not ignored.'
def is_production_filename(filename): DCNL 'Checks if the file contains production code. DCNL :rtype: bool DCNL :returns: Boolean indicating production status.'
def get_python_files(all_files=None): DCNL 'Gets a list of all Python files in the repository that need linting. DCNL Relies on :func:`get_affected_files()` to determine which files should DCNL be considered. DCNL NOTE: This requires ``git`` to be installed and requires that this DCNL is run within the ``git`` repository. DCNL :type all_files: list DCNL :param all_files: Optional list of files to be linted. DCNL :rtype: tuple DCNL :returns: A tuple containing two lists. The first list DCNL contains all production files, the next all test files.'
def lint_fileset(filenames, rcfile, description): DCNL 'Lints a group of files using a given rcfile.'
def main(): DCNL 'Script entry point. Lints both sets of files.'
def get_examples_from_docstring(doc_str): DCNL 'Parse doctest style code examples from a docstring.'
def package_files(generated_json_dir, docs_build_dir, static_json_dir, tag='master'): DCNL 'Copy app and JSON files into a convenient place to deploy from. DCNL Structure needs to be... DCNL root DCNL - src/ DCNL - images/ DCNL - app.js DCNL - app.css DCNL - vendor.js DCNL - vendor.css DCNL - json/ DCNL - master/ DCNL - toc.json DCNL - types.json DCNL - index.json DCNL - overview.html DCNL - home.html DCNL - index.html DCNL - manifest.json'
def main(): DCNL 'Run pycodestyle on all Python files in the repository.'
def get_package_directories(): DCNL 'Get a list of directories containing sub-packages. DCNL :rtype: list DCNL :returns: A list of all sub-package directories.'
def get_travis_directories(package_list): DCNL 'Get list of packages that need to be tested on Travis CI. DCNL See: https://travis-ci.com/ DCNL If the current Travis build is for a pull request (PR), this will DCNL limit the directories to the ones impacted by the PR. Otherwise DCNL it will just test all package directories. DCNL :type package_list: list DCNL :param package_list: The list of **all** valid packages with unit tests. DCNL :rtype: list DCNL :returns: A list of all package directories where tests DCNL need to be run.'
def verify_packages(subset, all_packages): DCNL 'Verify that a subset of packages are among all packages. DCNL :type subset: list DCNL :param subset: List of a subset of package names. DCNL :type all_packages: list DCNL :param all_packages: List of all package names. DCNL :raises: :class:`~exceptions.ValueError` if there are unknown packages DCNL in ``subset``'
def get_test_packages(): DCNL 'Get a list of packages which need tests run. DCNL Filters the package list in the following order: DCNL * Check command line for packages passed in as positional arguments DCNL * Check if the the local remote and local branch environment variables DCNL have been set to specify a remote branch to diff against. DCNL * Check if in Travis, then limit the subset based on changes DCNL in a Pull Request ("push" builds to branches may not have DCNL any filtering) DCNL * Just use all packages DCNL An additional check is done for the cases when a diff is computed (i.e. DCNL using local remote and local branch environment variables, and on Travis). DCNL Once the filtered list of **changed** packages is found, the package DCNL dependency graph is used to add any additional packages which depend on DCNL the changed packages. DCNL :rtype: list DCNL :returns: A list of all package directories where tests DCNL need be run.'
def run_package(package, tox_env): DCNL 'Run tox environment for a given package. DCNL :type package: str DCNL :param package: The name of the subdirectory which holds the sub-package. DCNL This will be a path relative to ``PROJECT_ROOT``. DCNL :type tox_env: str DCNL :param tox_env: The ``tox`` environment(s) to run in each sub-package. DCNL :rtype: bool DCNL :returns: Flag indicating if the test run succeeded.'
def get_parser(): DCNL 'Get simple ``argparse`` parser to determine configuration. DCNL :rtype: :class:`argparse.ArgumentParser` DCNL :returns: The parser for this script.'
def get_tox_env_from_version(): DCNL 'Get ``tox`` environment from the current Python version. DCNL :rtype: str DCNL :returns: The current ``tox`` environment to be used, e.g. ``"py27"``. DCNL :raises: :class:`EnvironmentError` if the first two options DCNL don\'t yield any value and the current version of DCNL Python is not in ``ACCEPTED_VERSIONS``.'
def get_tox_env(): DCNL 'Get the environment to be used with ``tox``. DCNL Tries to infer the ``tox`` environment in the following order DCNL * From the ``--tox-env`` command line flag DCNL * From the ``TOXENV`` environment variable DCNL * From the version of the current running Python DCNL :rtype: str DCNL :returns: The current ``tox`` environment to be used, e.g. ``"py27"``.'
def main(): DCNL 'Run all the unit tests that need to be run.'
def is_valid_module(filename): DCNL 'Determines if a filename is a valid Python module. DCNL Assumes if is just the end of a path (i.e. does not contain DCNL ``os.path.sep``. DCNL :type filename: str DCNL :param filename: The name of a file. DCNL :rtype: bool DCNL :returns: Flag indicating if the filename is valid.'
def get_public_modules(path, base_package=None): DCNL 'Get list of all public modules relative to a path. DCNL :type path: str DCNL :param path: The path containing the python modules. DCNL :type base_package: str DCNL :param base_package: (Optional) A package to prepend in DCNL front of the path. DCNL :rtype: list DCNL :returns: List of all modules found.'
def verify_modules(build_root='_build'): DCNL 'Verify modules included. DCNL :type build_root: str DCNL :param build_root: The root of the directory where docs are built into. DCNL Defaults to ``_build``.'
def get_parser(): DCNL 'Get simple ``argparse`` parser to determine package. DCNL :rtype: :class:`argparse.ArgumentParser` DCNL :returns: The parser for this script.'
def main(): DCNL 'Main script to verify modules included.'
def in_travis(): DCNL 'Detect if we are running in Travis. DCNL .. _Travis env docs: https://docs.travis-ci.com/user/                         environment-variables                         #Default-Environment-Variables DCNL See `Travis env docs`_. DCNL :rtype: bool DCNL :returns: Flag indicating if we are running on Travis.'
def in_travis_pr(): DCNL 'Detect if we are running in a pull request on Travis. DCNL .. _Travis env docs: https://docs.travis-ci.com/user/                         environment-variables                         #Default-Environment-Variables DCNL See `Travis env docs`_. DCNL .. note:: DCNL This assumes we already know we are running in Travis. DCNL :rtype: bool DCNL :returns: Flag indicating if we are in a pull request on Travis.'
def travis_branch(): DCNL 'Get the current branch of the PR. DCNL .. _Travis env docs: https://docs.travis-ci.com/user/                         environment-variables                         #Default-Environment-Variables DCNL See `Travis env docs`_. DCNL .. note:: DCNL This assumes we already know we are running in Travis DCNL during a PR. DCNL :rtype: str DCNL :returns: The name of the branch the current pull request is DCNL changed against. DCNL :raises: :class:`~exceptions.OSError` if the ``TRAVIS_BRANCH_ENV`` DCNL environment variable isn\'t set during a pull request DCNL build.'
def check_output(*args): DCNL 'Run a command on the operation system. DCNL :type args: tuple DCNL :param args: Arguments to pass to ``subprocess.check_output``. DCNL :rtype: str DCNL :returns: The raw STDOUT from the command (converted from bytes DCNL if necessary).'
def rootname(filename): DCNL 'Get the root directory that a file is contained in. DCNL :type filename: str DCNL :param filename: The path / name of a file. DCNL :rtype: str DCNL :returns: The root directory containing the file.'
def get_changed_packages(blob_name1, blob_name2, package_list): DCNL 'Get a list of packages which have changed between two changesets. DCNL :type blob_name1: str DCNL :param blob_name1: The name of a commit hash or branch name or other DCNL ``git`` artifact. DCNL :type blob_name2: str DCNL :param blob_name2: The name of a commit hash or branch name or other DCNL ``git`` artifact. DCNL :type package_list: list DCNL :param package_list: The list of **all** valid packages with unit tests. DCNL :rtype: list DCNL :returns: A list of all package directories that have changed DCNL between ``blob_name1`` and ``blob_name2``. Starts DCNL with a list of valid packages (``package_list``) DCNL and filters out the unchanged directories.'
def local_diff_branch(): DCNL 'Get a remote branch to diff against in a local checkout. DCNL Checks if the the local remote and local branch environment DCNL variables specify a remote branch. DCNL :rtype: str DCNL :returns: The diffbase `{remote}/{branch}` if the environment DCNL variables are defined. If not, returns ``None``.'
def get_affected_files(allow_limited=True): DCNL 'Gets a list of files in the repository. DCNL By default, returns all files via ``git ls-files``. However, in some cases DCNL uses a specific commit or branch (a so-called diff base) to compare DCNL against for changed files. (This requires ``allow_limited=True``.) DCNL To speed up linting on Travis pull requests against master, we manually DCNL set the diff base to the branch the pull request is against. We don\'t do DCNL this on "push" builds since "master" will be the currently checked out DCNL code. One could potentially use ${TRAVIS_COMMIT_RANGE} to find a diff base DCNL but this value is not dependable. DCNL To allow faster local ``tox`` runs, the local remote and local branch DCNL environment variables can be set to specify a remote branch to diff DCNL against. DCNL :type allow_limited: bool DCNL :param allow_limited: Boolean indicating if a reduced set of files can DCNL be used. DCNL :rtype: pair DCNL :returns: Tuple of the diff base using the list of filenames to be DCNL linted.'
def get_required_packages(file_contents): DCNL 'Get required packages from a ``setup.py`` file. DCNL Makes the following assumptions: DCNL * ``install_requires=REQUIREMENTS`` occurs in the call to DCNL ``setup()`` in the ``file_contents``. DCNL * The text ``install_requires`` occurs nowhere else in the file. DCNL * The text ``REQUIREMENTS`` only appears when being passed to DCNL ``setup()`` (as above) and when being defined. DCNL * The ``REQUIREMENTS`` variable is a list and the text from the DCNL ``setup.py`` file containing that list can be parsed using DCNL ``ast.literal_eval()``. DCNL :type file_contents: str DCNL :param file_contents: The contents of a ``setup.py`` file. DCNL :rtype: list DCNL :returns: The list of required packages. DCNL :raises: :class:`~exceptions.ValueError` if the file is in an DCNL unexpected format.'
def get_dependency_graph(package_list): DCNL 'Get a directed graph of package dependencies. DCNL :type package_list: list DCNL :param package_list: The list of **all** valid packages. DCNL :rtype: dict DCNL :returns: A dictionary where keys are packages and values are DCNL the set of packages that depend on the key.'
def follow_dependencies(subset, package_list): DCNL 'Get a directed graph of package dependencies. DCNL :type subset: list DCNL :param subset: List of a subset of package names. DCNL :type package_list: list DCNL :param package_list: The list of **all** valid packages. DCNL :rtype: list DCNL :returns: An expanded list of packages containing everything DCNL in ``subset`` and any packages that depend on those.'
def main(): DCNL 'Get the current package directory. DCNL Prints the package directory out so callers can consume it.'
def transform_old_to_new(line, old_module, new_module, ignore_import_from=False): DCNL 'Transforms from an old module to a new one. DCNL First checks if a line starts with DCNL "from {old_module} import ..." DCNL then checks if the line contains DCNL "import {old_module} ..." DCNL then checks if the line starts with (ignoring whitespace) DCNL "{old_module} ..." DCNL and finally checks if the line contians DCNL "\'some-dict-key\': {old_module} ..." DCNL In any of these cases, "{old_module}" is replaced with "{new_module}". DCNL If none match, nothing is returned. DCNL :type line: str DCNL :param line: The line to be transformed. DCNL :type old_module: str DCNL :param old_module: The import to be re-written. DCNL :type new_module: str DCNL :param new_module: The new location of the re-written import. DCNL :type ignore_import_from: bool DCNL :param ignore_import_from: Flag to determine if the "from * import" DCNL statements should be ignored. DCNL :rtype: :class:`str` or :data:`NoneType <types.NoneType>` DCNL :returns: The transformed line if the old module was found, otherwise DCNL does nothing.'
def transform_line(line): DCNL 'Transforms an import line in a PB2 module. DCNL If the line is not an import of one of the packages in ``REPLACEMENTS``, DCNL does nothing and returns the original. Otherwise it replaces the package DCNL matched with our local package. DCNL :type line: str DCNL :param line: The line to be transformed. DCNL :rtype: str DCNL :returns: The transformed line.'
def rewrite_file(filename): DCNL 'Rewrites a given PB2 modules. DCNL :type filename: str DCNL :param filename: The name of the file to be rewritten.'
def main(): DCNL 'Rewrites all PB2 files.'
def config_name_from_full_name(full_name): DCNL 'Extract the config name from a full resource name. DCNL >>> config_name_from_full_name(\'projects/my-proj/configs/my-config\') DCNL "my-config" DCNL :type full_name: str DCNL :param full_name: DCNL The full resource name of a config. The full resource name looks like DCNL ``projects/project-name/configs/config-name`` and is returned as the DCNL ``name`` field of a config resource.  See: DCNL https://cloud.google.com/deployment-manager/runtime-configurator/reference/rest/v1beta1/projects.configs DCNL :rtype: str DCNL :returns: The config\'s short name, given its full resource name. DCNL :raises: :class:`ValueError` if ``full_name`` is not the expected format'
def variable_name_from_full_name(full_name): DCNL 'Extract the variable name from a full resource name. DCNL >>> variable_name_from_full_name( DCNL \'projects/my-proj/configs/my-config/variables/var-name\') DCNL "var-name" DCNL >>> variable_name_from_full_name( DCNL \'projects/my-proj/configs/my-config/variables/another/var/name\') DCNL "another/var/name" DCNL :type full_name: str DCNL :param full_name: DCNL The full resource name of a variable. The full resource name looks like DCNL ``projects/prj-name/configs/cfg-name/variables/var-name`` and is DCNL returned as the ``name`` field of a variable resource.  See: DCNL https://cloud.google.com/deployment-manager/runtime-configurator/reference/rest/v1beta1/projects.configs.variables DCNL :rtype: str DCNL :returns: The variable\'s short name, given its full resource name. DCNL :raises: :class:`ValueError` if ``full_name`` is not the expected format'
def _item_to_variable(iterator, resource): DCNL 'Convert a JSON variable to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that has retrieved the item. DCNL :type resource: dict DCNL :param resource: An item to be converted to a variable. DCNL :rtype: :class:`.Variable` DCNL :returns: The next variable in the page.'
def _item_to_project(iterator, resource): DCNL 'Convert a JSON project to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that has retrieved the item. DCNL :type resource: dict DCNL :param resource: A resource to be converted to a project. DCNL :rtype: :class:`.Project` DCNL :returns: The next project in the page.'
def check_environment(): DCNL 'Check what environment this is running in. DCNL In particular, if the environment is Travis. DCNL :rtype: tuple DCNL :returns: A pair of booleans. The first indicates if the test DCNL is running in Travis and the second indicates if DCNL the current build is a non-PR for a merge to master.'
def decrypt_keyfile(): DCNL 'Decrypt a keyfile.'
def prepare_to_run(): DCNL 'Prepare to run system tests. DCNL If on Travis during a PR, exit the entire program; there is DCNL no need to run the system tests. DCNL If on Travis during a build for a non-PR merge to master, DCNL decrypts stored keyfile.'
def get_parser(): DCNL 'Get an argument parser to determine a list of packages.'
def get_modules(): DCNL 'Get the list of modules names to run system tests for.'
def main(): DCNL 'Run all the system tests if necessary.'
def _retry_all(_): DCNL 'Retry all caught exceptions.'
def _wait_until_complete(operation, max_attempts=5): DCNL 'Wait until an operation has completed. DCNL :type operation: :class:`google.cloud.operation.Operation` DCNL :param operation: Operation that has not completed. DCNL :type max_attempts: int DCNL :param max_attempts: (Optional) The maximum number of times to check if DCNL the operation has completed. Defaults to 5. DCNL :rtype: bool DCNL :returns: Boolean indicating if the operation is complete.'
def _retry_on_unavailable(exc): DCNL 'Retry only errors whose status code is \'UNAVAILABLE\'.'
def get_parser(): DCNL 'Get simple ``argparse`` parser to determine package. DCNL :rtype: :class:`argparse.ArgumentParser` DCNL :returns: The parser for this script.'
def get_start_command(package): DCNL 'Get command line arguments for starting emulator. DCNL :type package: str DCNL :param package: The package to start an emulator for. DCNL :rtype: tuple DCNL :returns: The arguments to be used, in a tuple.'
def get_env_init_command(package): DCNL 'Get command line arguments for getting emulator env. info. DCNL :type package: str DCNL :param package: The package to get environment info for. DCNL :rtype: tuple DCNL :returns: The arguments to be used, in a tuple.'
def datastore_wait_ready(popen): DCNL 'Wait until the datastore emulator is ready to use. DCNL :type popen: :class:`subprocess.Popen` DCNL :param popen: An open subprocess to interact with.'
def wait_ready_prefix(popen, prefix): DCNL 'Wait until the a process encounters a line with matching prefix. DCNL :type popen: :class:`subprocess.Popen` DCNL :param popen: An open subprocess to interact with. DCNL :type prefix: str DCNL :param prefix: The prefix to match'
def wait_ready(package, popen): DCNL 'Wait until the emulator is ready to use. DCNL :type package: str DCNL :param package: The package to check if ready. DCNL :type popen: :class:`subprocess.Popen` DCNL :param popen: An open subprocess to interact with. DCNL :raises: :class:`KeyError` if the ``package`` is not among DCNL ``datastore``, ``pubsub`` or ``bigtable``.'
def cleanup(pid): DCNL 'Cleanup a process (including all of its children). DCNL :type pid: int DCNL :param pid: Process ID.'
def run_tests_in_emulator(package): DCNL 'Spawn an emulator instance and run the system tests. DCNL :type package: str DCNL :param package: The package to run system tests against.'
def main(): DCNL 'Main method to run this script.'
def _consume_topics(pubsub_client): DCNL 'Consume entire iterator. DCNL :type pubsub_client: :class:`~google.cloud.pubsub.client.Client` DCNL :param pubsub_client: Client to use to retrieve topics. DCNL :rtype: list DCNL :returns: List of all topics encountered.'
def _consume_subscriptions(topic): DCNL 'Consume entire iterator. DCNL :type topic: :class:`~google.cloud.pubsub.topic.Topic` DCNL :param topic: Topic to use to retrieve subscriptions. DCNL :rtype: list DCNL :returns: List of all subscriptions encountered.'
def unique_resource_id(delimiter='_'): DCNL 'A unique identifier for a resource. DCNL Intended to help locate resources created in particular DCNL testing environments and at particular times.'
def _retry_on_unavailable(exc): DCNL 'Retry only errors whose status code is \'UNAVAILABLE\'. DCNL :type exc: :class:`~google.gax.errors.GaxError` DCNL :param exc: The exception that was caught. DCNL :rtype: bool DCNL :returns: Boolean indicating if the exception was UNAVAILABLE.'
def _consume_entries(logger): DCNL 'Consume all log entries from logger iterator. DCNL :type logger: :class:`~google.cloud.logging.logger.Logger` DCNL :param logger: A Logger containing entries. DCNL :rtype: list DCNL :returns: List of all entries consumed.'
def _list_entries(logger): DCNL 'Retry-ing list entries in a logger. DCNL Retry until there are actual results and retry on any DCNL failures. DCNL :type logger: :class:`~google.cloud.logging.logger.Logger` DCNL :param logger: A Logger containing entries. DCNL :rtype: list DCNL :returns: List of all entries consumed.'
def _bad_copy(bad_request): DCNL 'Predicate: pass only exceptions for a failed copyTo.'
def _empty_bucket(bucket): DCNL 'Empty a bucket of all existing blobs. DCNL This accounts (partially) for the eventual consistency of the DCNL list blobs API call.'
def _rate_limit_exceeded(forbidden): DCNL 'Predicate: pass only exceptions with \'rateLimitExceeded\' as reason.'
def _operation_complete(result): DCNL 'Return operation result.'
def _wait_until_complete(operation, max_attempts=5): DCNL 'Wait until an operation has completed. DCNL :type operation: :class:`google.cloud.operation.Operation` DCNL :param operation: Operation that has not completed. DCNL :type max_attempts: int DCNL :param max_attempts: (Optional) The maximum number of times to check if DCNL the operation has completed. Defaults to 5. DCNL :rtype: bool DCNL :returns: Boolean indicating if the operation is complete.'
def _make_typed_value(value): DCNL 'Create a dict representing a TypedValue API object. DCNL Typed values are objects with the value itself as the value, keyed by the DCNL type of the value. They are used when writing points to time series. This DCNL method returns the dict representation for the TypedValue. DCNL This method uses the Python type of the object to infer the correct DCNL type to send to the API. For example, a Python float will be sent to the DCNL API with "doubleValue" as its key. DCNL See: https://cloud.google.com/monitoring/api/ref_v3/rest/v3/TypedValue DCNL :type value: bool, int, float, str, or dict DCNL :param value: value to infer the typed value of. DCNL :rtype: dict DCNL :returns: A dict'
def _build_label_filter(category, *args, **kwargs): DCNL 'Construct a filter string to filter on metric or resource labels.'
def _build_dataframe(time_series_iterable, label=None, labels=None): DCNL 'Build a :mod:`pandas` dataframe out of time series. DCNL :type time_series_iterable: DCNL iterable over :class:`~google.cloud.monitoring.timeseries.TimeSeries` DCNL :param time_series_iterable: DCNL An iterable (e.g., a query object) yielding time series. DCNL :type label: str DCNL :param label: DCNL (Optional) The label name to use for the dataframe header. This can be DCNL the name of a resource label or metric label (e.g., DCNL ``"instance_name"``), or the string ``"resource_type"``. DCNL :type labels: list of strings, or None DCNL :param labels: DCNL A list or tuple of label names to use for the dataframe header. DCNL If more than one label name is provided, the resulting dataframe DCNL will have a multi-level column header. DCNL Specifying neither ``label`` or ``labels`` results in a dataframe DCNL with a multi-level column header including the resource type and DCNL all available resource and metric labels. DCNL Specifying both ``label`` and ``labels`` is an error. DCNL :rtype: :class:`pandas.DataFrame` DCNL :returns: A dataframe where each column represents one time series.'
def _sorted_resource_labels(labels): DCNL 'Sort label names, putting well-known resource labels first.'
def _group_id_from_name(path, project=None): DCNL 'Validate a group URI path and get the group ID. DCNL :type path: str DCNL :param path: URI path for a group API request. DCNL :type project: str DCNL :param project: (Optional) The project associated with the request. It is DCNL included for validation purposes. DCNL :rtype: str DCNL :returns: Group ID parsed from ``path``. DCNL :raises: :class:`ValueError` if the ``path`` is ill-formed or if DCNL the project from the ``path`` does not agree with the DCNL ``project`` passed in.'
def _group_name_from_id(project, group_id): DCNL 'Build the group name given the project and group ID. DCNL :type project: str DCNL :param project: The project associated with the group. DCNL :type group_id: str DCNL :param group_id: The group ID. DCNL :rtype: str DCNL :returns: The fully qualified name of the group.'
def _item_to_resource_record_set(iterator, resource): DCNL 'Convert a JSON resource record set value to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that has retrieved the item. DCNL :type resource: dict DCNL :param resource: An item to be converted to a resource record set. DCNL :rtype: :class:`~.resource_record_set.ResourceRecordSet` DCNL :returns: The next resource record set in the page.'
def _item_to_changes(iterator, resource): DCNL 'Convert a JSON "changes" value to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that has retrieved the item. DCNL :type resource: dict DCNL :param resource: An item to be converted to a "changes". DCNL :rtype: :class:`.Changes` DCNL :returns: The next "changes" in the page.'
def _item_to_zone(iterator, resource): DCNL 'Convert a JSON managed zone to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that has retrieved the item. DCNL :type resource: dict DCNL :param resource: An item to be converted to a managed zone. DCNL :rtype: :class:`.ManagedZone` DCNL :returns: The next managed zone in the page.'
def snippet(func): DCNL 'Mark ``func`` as a snippet example function.'
@snippet DCNL def instantiate_client(_unused_client, _unused_to_delete): DCNL 'Instantiate client.'
@snippet DCNL def client_list_entries(client, to_delete): DCNL 'List entries via client.'
def client_list_entries_multi_project(client, to_delete): DCNL 'List entries via client across multiple projects.'
@snippet DCNL def logger_usage(client, to_delete): DCNL 'Logger usage.'
@snippet DCNL def metric_crud(client, to_delete): DCNL 'Metric CRUD.'
@snippet DCNL def sink_storage(client, to_delete): DCNL 'Sink log entries to storage.'
@snippet DCNL def sink_bigquery(client, to_delete): DCNL 'Sink log entries to bigquery.'
@snippet DCNL def sink_pubsub(client, to_delete): DCNL 'Sink log entries to pubsub.'
def snippet(func): DCNL 'Mark ``func`` as a snippet example function.'
@snippet DCNL def client_list_topics(client, to_delete): DCNL 'List topics for a project.'
@snippet DCNL def client_list_subscriptions(client, to_delete): DCNL 'List all subscriptions for a project.'
@snippet DCNL def topic_create(client, to_delete): DCNL 'Create a topic.'
@snippet DCNL def topic_exists(client, to_delete): DCNL 'Test existence of a topic.'
@snippet DCNL def topic_delete(client, to_delete): DCNL 'Delete a topic.'
@snippet DCNL def topic_iam_policy(client, to_delete): DCNL 'Fetch / set a topic\'s IAM policy.'
def topic_check_iam_permissions(client, to_delete): DCNL 'Check topic IAM permissions.'
@snippet DCNL def topic_publish_messages(client, to_delete): DCNL 'Publish messages to a topic.'
@snippet DCNL def topic_subscription(client, to_delete): DCNL 'Create subscriptions to a topic.'
def topic_subscription_push(client, to_delete): DCNL 'Create subscriptions to a topic.'
@snippet DCNL def subscription_lifecycle(client, to_delete): DCNL 'Test lifecycle of a subscription.'
@snippet DCNL def subscription_pull(client, to_delete): DCNL 'Pull messges from a subscribed topic.'
@snippet DCNL def subscription_pull_w_autoack(client, to_delete): DCNL 'Pull messges from a topic, auto-acknowldging them'
@snippet DCNL def subscription_iam_policy(client, to_delete): DCNL 'Fetch / set a subscription\'s IAM policy.'
def subscription_check_iam_permissions(client, to_delete): DCNL 'Check subscription IAM permissions.'
def snippet(func): DCNL 'Mark ``func`` as a snippet example function.'
@snippet DCNL def client_list_datasets(client, _): DCNL 'List datasets for a project.'
@snippet DCNL def dataset_create(client, to_delete): DCNL 'Create a dataset.'
@snippet DCNL def dataset_exists(client, to_delete): DCNL 'Test existence of a dataset.'
@snippet DCNL def dataset_reload(client, to_delete): DCNL 'Reload a dataset\'s metadata.'
@snippet DCNL def dataset_patch(client, to_delete): DCNL 'Patch a dataset\'s metadata.'
@snippet DCNL def dataset_update(client, to_delete): DCNL 'Update a dataset\'s metadata.'
@snippet DCNL def dataset_delete(client, _): DCNL 'Delete a dataset.'
@snippet DCNL def dataset_list_tables(client, to_delete): DCNL 'List tables within a dataset.'
@snippet DCNL def table_create(client, to_delete): DCNL 'Create a table.'
@snippet DCNL def table_exists(client, to_delete): DCNL 'Test existence of a table.'
@snippet DCNL def table_reload(client, to_delete): DCNL 'Reload a table\'s metadata.'
@snippet DCNL def table_patch(client, to_delete): DCNL 'Patch a table\'s metadata.'
@snippet DCNL def table_update(client, to_delete): DCNL 'Update a table\'s metadata.'
@snippet DCNL def table_insert_fetch_data(client, to_delete): DCNL 'Insert / fetch table data.'
@snippet DCNL def table_upload_from_file(client, to_delete): DCNL 'Upload table data from a CSV file.'
@snippet DCNL def table_delete(client, to_delete): DCNL 'Delete a table.'
@snippet DCNL def client_list_jobs(client, _): DCNL 'List jobs for a project.'
@snippet DCNL def client_run_sync_query(client, _): DCNL 'Run a synchronous query.'
@snippet DCNL def client_run_sync_query_w_param(client, _): DCNL 'Run a synchronous query using a query parameter'
@snippet DCNL def client_run_sync_query_paged(client, _): DCNL 'Run a synchronous query with paged results.'
@snippet DCNL def client_run_sync_query_timeout(client, _): DCNL 'Run a synchronous query w/ timeout'
def snippet(func): DCNL 'Mark ``func`` as a snippet example function.'
def _configure_job_metadata(metadata, allow_jagged_rows, allow_quoted_newlines, create_disposition, encoding, field_delimiter, ignore_unknown_values, max_bad_records, quote_character, skip_leading_rows, write_disposition): DCNL 'Helper for :meth:`Table.upload_from_file`.'
def _parse_schema_resource(info): DCNL 'Parse a resource fragment into a schema field. DCNL :type info: mapping DCNL :param info: should contain a "fields" key to be parsed DCNL :rtype: list of :class:`SchemaField`, or ``NoneType`` DCNL :returns: a list of parsed fields, or ``None`` if no "fields" key is DCNL present in ``info``.'
def _build_schema_resource(fields): DCNL 'Generate a resource fragment for a schema. DCNL :type fields: sequence of :class:`SchemaField` DCNL :param fields: schema to be dumped DCNL :rtype: mapping DCNL :returns: a mapping describing the schema of the supplied fields.'
def _item_to_row(iterator, resource): DCNL 'Convert a JSON row to the native object. DCNL .. note:: DCNL This assumes that the ``schema`` attribute has been DCNL added to the iterator after being created, which DCNL should be done by the caller. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: dict DCNL :param resource: An item to be converted to a row. DCNL :rtype: tuple DCNL :returns: The next row in the page.'
def _rows_page_start(iterator, page, response): DCNL 'Grab total rows after a :class:`~google.cloud.iterator.Page` started. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type page: :class:`~google.cloud.iterator.Page` DCNL :param page: The page that was just created. DCNL :type response: dict DCNL :param response: The JSON API response for a page of rows in a table.'
def _convert_timestamp(value): DCNL 'Helper for :meth:`Table.insert_data`.'
def _item_to_project(iterator, resource): DCNL 'Convert a JSON project to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: dict DCNL :param resource: An item to be converted to a project. DCNL :rtype: :class:`.Project` DCNL :returns: The next project in the page.'
def _item_to_dataset(iterator, resource): DCNL 'Convert a JSON dataset to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: dict DCNL :param resource: An item to be converted to a dataset. DCNL :rtype: :class:`.Dataset` DCNL :returns: The next dataset in the page.'
def _item_to_job(iterator, resource): DCNL 'Convert a JSON job to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: dict DCNL :param resource: An item to be converted to a job. DCNL :rtype: job instance. DCNL :returns: The next job in the page.'
def _not_null(value, field): DCNL 'Check whether \'value\' should be coerced to \'field\' type.'
def _int_from_json(value, field): DCNL 'Coerce \'value\' to an int, if set or not nullable.'
def _float_from_json(value, field): DCNL 'Coerce \'value\' to a float, if set or not nullable.'
def _bool_from_json(value, field): DCNL 'Coerce \'value\' to a bool, if set or not nullable.'
def _string_from_json(value, _): DCNL 'NOOP string -> string coercion'
def _bytes_from_json(value, field): DCNL 'Base64-decode value'
def _timestamp_from_json(value, field): DCNL 'Coerce \'value\' to a datetime, if set or not nullable.'
def _datetime_from_json(value, field): DCNL 'Coerce \'value\' to a datetime, if set or not nullable.'
def _date_from_json(value, field): DCNL 'Coerce \'value\' to a datetime date, if set or not nullable'
def _time_from_json(value, field): DCNL 'Coerce \'value\' to a datetime date, if set or not nullable'
def _record_from_json(value, field): DCNL 'Coerce \'value\' to a mapping, if set or not nullable.'
def _int_to_json(value): DCNL 'Coerce \'value\' to an JSON-compatible representation.'
def _float_to_json(value): DCNL 'Coerce \'value\' to an JSON-compatible representation.'
def _bool_to_json(value): DCNL 'Coerce \'value\' to an JSON-compatible representation.'
def _bytes_to_json(value): DCNL 'Coerce \'value\' to an JSON-compatible representation.'
def _timestamp_to_json(value): DCNL 'Coerce \'value\' to an JSON-compatible representation.'
def _datetime_to_json(value): DCNL 'Coerce \'value\' to an JSON-compatible representation.'
def _date_to_json(value): DCNL 'Coerce \'value\' to an JSON-compatible representation.'
def _time_to_json(value): DCNL 'Coerce \'value\' to an JSON-compatible representation.'
def _row_from_json(row, schema): DCNL 'Convert JSON row data to row with appropriate types. DCNL :type row: dict DCNL :param row: A JSON response row to be converted. DCNL :type schema: tuple DCNL :param schema: A tuple of DCNL :class:`~google.cloud.bigquery.schema.SchemaField`. DCNL :rtype: tuple DCNL :returns: A tuple of data converted to native types.'
def _rows_from_json(rows, schema): DCNL 'Convert JSON row data to rows with appropriate types.'
def _item_to_table(iterator, resource): DCNL 'Convert a JSON table to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: dict DCNL :param resource: An item to be converted to a table. DCNL :rtype: :class:`~google.cloud.bigquery.table.Table` DCNL :returns: The next table in the page.'
def build_flask_context(request): DCNL 'Builds an HTTP context object from a Flask (Werkzeug) request object. DCNL This helper method extracts the relevant HTTP context from a Flask request DCNL object into an object ready to be sent to Error Reporting. DCNL .. code-block:: python DCNL >>> @app.errorhandler(HTTPException) DCNL ... def handle_error(exc): DCNL ...     client.report_exception( DCNL ...         http_context=build_flask_context(request)) DCNL ...     # rest of error response code here DCNL :type request: :class:`werkzeug.wrappers.request` DCNL :param request: The Flask request object to convert. DCNL :rtype: :class:`~google.cloud.error_reporting.client.HTTPContext` DCNL :returns: An HTTPContext object ready to be sent to the Stackdriver Error DCNL Reporting API.'
def _log_entry_mapping_to_pb(mapping): DCNL 'Helper for :meth:`write_entries`, et aliae DCNL Performs "impedance matching" between the protobuf attrs and DCNL the keys expected in the JSON API.'
def _item_to_entry(iterator, entry_pb, loggers): DCNL 'Convert a log entry protobuf to the native object. DCNL .. note:: DCNL This method does not have the correct signature to be used as DCNL the ``item_to_value`` argument to DCNL :class:`~google.cloud.iterator.Iterator`. It is intended to be DCNL patched with a mutable ``loggers`` argument that can be updated DCNL on subsequent calls. For an example, see how the method is DCNL used above in :meth:`_LoggingAPI.list_entries`. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type entry_pb: :class:`.log_entry_pb2.LogEntry` DCNL :param entry_pb: Log entry protobuf returned from the API. DCNL :type loggers: dict DCNL :param loggers: DCNL A mapping of logger fullnames -> loggers.  If the logger DCNL that owns the entry is not in ``loggers``, the entry DCNL will have a newly-created logger. DCNL :rtype: :class:`~google.cloud.logging.entries._BaseEntry` DCNL :returns: The next log entry in the page.'
def _item_to_sink(iterator, log_sink_pb): DCNL 'Convert a sink protobuf to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type log_sink_pb: DCNL :class:`.logging_config_pb2.LogSink` DCNL :param log_sink_pb: Sink protobuf returned from the API. DCNL :rtype: :class:`~google.cloud.logging.sink.Sink` DCNL :returns: The next sink in the page.'
def _item_to_metric(iterator, log_metric_pb): DCNL 'Convert a metric protobuf to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type log_metric_pb: DCNL :class:`.logging_metrics_pb2.LogMetric` DCNL :param log_metric_pb: Metric protobuf returned from the API. DCNL :rtype: :class:`~google.cloud.logging.metric.Metric` DCNL :returns: The next metric in the page.'
def make_gax_logging_api(client): DCNL 'Create an instance of the GAX Logging API. DCNL :type client: :class:`~google.cloud.logging.client.Client` DCNL :param client: The client that holds configuration details. DCNL :rtype: :class:`_LoggingAPI` DCNL :returns: A metrics API instance with the proper credentials.'
def make_gax_metrics_api(client): DCNL 'Create an instance of the GAX Metrics API. DCNL :type client: :class:`~google.cloud.logging.client.Client` DCNL :param client: The client that holds configuration details. DCNL :rtype: :class:`_MetricsAPI` DCNL :returns: A metrics API instance with the proper credentials.'
def make_gax_sinks_api(client): DCNL 'Create an instance of the GAX Sinks API. DCNL :type client: :class:`~google.cloud.logging.client.Client` DCNL :param client: The client that holds configuration details. DCNL :rtype: :class:`_SinksAPI` DCNL :returns: A metrics API instance with the proper credentials.'
def entry_from_resource(resource, client, loggers): DCNL 'Detect correct entry type from resource and instantiate. DCNL :type resource: dict DCNL :param resource: One entry resource from API response. DCNL :type client: :class:`~google.cloud.logging.client.Client` DCNL :param client: Client that owns the log entry. DCNL :type loggers: dict DCNL :param loggers: DCNL A mapping of logger fullnames -> loggers.  If the logger DCNL that owns the entry is not in ``loggers``, the entry DCNL will have a newly-created logger. DCNL :rtype: :class:`~google.cloud.logging.entries._BaseEntry` DCNL :returns: The entry instance, constructed via the resource'
def logger_name_from_path(path): DCNL 'Validate a logger URI path and get the logger name. DCNL :type path: str DCNL :param path: URI path for a logger API request. DCNL :rtype: str DCNL :returns: Logger name parsed from ``path``. DCNL :raises: :class:`ValueError` if the ``path`` is ill-formed or if DCNL the project from the ``path`` does not agree with the DCNL ``project`` passed in.'
def _item_to_entry(iterator, resource, loggers): DCNL 'Convert a log entry resource to the native object. DCNL .. note:: DCNL This method does not have the correct signature to be used as DCNL the ``item_to_value`` argument to DCNL :class:`~google.cloud.iterator.Iterator`. It is intended to be DCNL patched with a mutable ``loggers`` argument that can be updated DCNL on subsequent calls. For an example, see how the method is DCNL used above in :meth:`_LoggingAPI.list_entries`. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: dict DCNL :param resource: Log entry JSON resource returned from the API. DCNL :type loggers: dict DCNL :param loggers: DCNL A mapping of logger fullnames -> loggers.  If the logger DCNL that owns the entry is not in ``loggers``, the entry DCNL will have a newly-created logger. DCNL :rtype: :class:`~google.cloud.logging.entries._BaseEntry` DCNL :returns: The next log entry in the page.'
def _item_to_sink(iterator, resource): DCNL 'Convert a sink resource to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: dict DCNL :param resource: Sink JSON resource returned from the API. DCNL :rtype: :class:`~google.cloud.logging.sink.Sink` DCNL :returns: The next sink in the page.'
def _item_to_metric(iterator, resource): DCNL 'Convert a metric resource to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: dict DCNL :param resource: Metric JSON resource returned from the API. DCNL :rtype: :class:`~google.cloud.logging.metric.Metric` DCNL :returns: The next metric in the page.'
def format_stackdriver_json(record, message): DCNL 'Helper to format a LogRecord in in Stackdriver fluentd format. DCNL :rtype: str DCNL :returns: JSON str to be written to the log file.'
def setup_logging(handler, excluded_loggers=EXCLUDED_LOGGER_DEFAULTS, log_level=logging.INFO): DCNL 'Attach a logging handler to the Python root logger DCNL Excludes loggers that this library itself uses to avoid DCNL infinite recursion. DCNL :type handler: :class:`logging.handler` DCNL :param handler: the handler to attach to the global handler DCNL :type excluded_loggers: tuple DCNL :param excluded_loggers: (Optional) The loggers to not attach the handler DCNL to. This will always include the loggers in the DCNL path of the logging client itself. DCNL :type log_level: int DCNL :param log_level: (Optional) Python logging log level. Defaults to DCNL :const:`logging.INFO`. DCNL Example: DCNL .. code-block:: python DCNL import logging DCNL import google.cloud.logging DCNL from google.cloud.logging.handlers import CloudLoggingHandler DCNL client = google.cloud.logging.Client() DCNL handler = CloudLoggingHandler(client) DCNL google.cloud.logging.setup_logging(handler) DCNL logging.getLogger().setLevel(logging.DEBUG) DCNL logging.error(\'bad news\')  # API call'
def _build_request_data(sample, language_code=None, max_alternatives=None, profanity_filter=None, speech_context=None): DCNL 'Builds the request data before making API request. DCNL :type sample: :class:`~google.cloud.speech.sample.Sample` DCNL :param sample: Instance of ``Sample`` containing audio information. DCNL :type language_code: str DCNL :param language_code: (Optional) The language of the supplied audio as DCNL BCP-47 language tag. Example: ``\'en-GB\'``. DCNL If omitted, defaults to ``\'en-US\'``. DCNL :type max_alternatives: int DCNL :param max_alternatives: (Optional) Maximum number of recognition DCNL hypotheses to be returned. The server may DCNL return fewer than maxAlternatives. DCNL Valid values are 0-30. A value of 0 or 1 DCNL will return a maximum of 1. Defaults to 1 DCNL :type profanity_filter: bool DCNL :param profanity_filter: If True, the server will attempt to filter DCNL out profanities, replacing all but the DCNL initial character in each filtered word with DCNL asterisks, e.g. ``\'f***\'``. If False or DCNL omitted, profanities won\'t be filtered out. DCNL :type speech_context: list DCNL :param speech_context: A list of strings (max 50) containing words and DCNL phrases "hints" so that the speech recognition DCNL is more likely to recognize them. This can be DCNL used to improve the accuracy for specific words DCNL and phrases. This can also be used to add new DCNL words to the vocabulary of the recognizer. DCNL :rtype: dict DCNL :returns: Dictionary with required data for Google Speech API.'
def _stream_requests(sample, language_code=None, max_alternatives=None, profanity_filter=None, speech_context=None, single_utterance=None, interim_results=None): DCNL 'Generate stream of requests from sample. DCNL :type sample: :class:`~google.cloud.speech.sample.Sample` DCNL :param sample: Instance of ``Sample`` containing audio information. DCNL :type language_code: str DCNL :param language_code: (Optional) The language of the supplied audio as DCNL BCP-47 language tag. Example: ``\'en-GB\'``. DCNL If omitted, defaults to ``\'en-US\'``. DCNL :type max_alternatives: int DCNL :param max_alternatives: (Optional) Maximum number of recognition DCNL hypotheses to be returned. The server may DCNL return fewer than maxAlternatives. DCNL Valid values are 0-30. A value of 0 or 1 DCNL will return a maximum of 1. Defaults to 1 DCNL :type profanity_filter: bool DCNL :param profanity_filter: (Optional) If True, the server will attempt to DCNL filter out profanities, replacing all but the DCNL initial character in each filtered word with DCNL asterisks, e.g. ``\'f***\'``. If False or DCNL omitted, profanities won\'t be filtered out. DCNL :type speech_context: list DCNL :param speech_context: (Optional) A list of strings (max 50) containing DCNL words and phrases "hints" so that the speech DCNL recognition is more likely to recognize them. DCNL This can be used to improve the accuracy for DCNL specific words and phrases. This can also be used to DCNL add new words to the vocabulary of the recognizer. DCNL :type single_utterance: bool DCNL :param single_utterance: (Optional) If false or omitted, the recognizer DCNL will perform continuous recognition DCNL (continuing to process audio even if the user DCNL pauses speaking) until the client closes the DCNL output stream (gRPC API) or when the maximum DCNL time limit has been reached. Multiple DCNL SpeechRecognitionResults with the is_final DCNL flag set to true may be returned. DCNL If true, the recognizer will detect a single DCNL spoken utterance. When it detects that the DCNL user has paused or stopped speaking, it will DCNL return an END_OF_UTTERANCE event and cease DCNL recognition. It will return no more than one DCNL SpeechRecognitionResult with the is_final flag DCNL set to true. DCNL :type interim_results: bool DCNL :param interim_results: (Optional) If true, interim results (tentative DCNL hypotheses) may be returned as they become DCNL available (these interim results are indicated DCNL with the is_final=false flag). If false or DCNL omitted, only is_final=true result(s) are DCNL returned.'
def _make_streaming_request(sample, language_code, max_alternatives, profanity_filter, speech_context, single_utterance, interim_results): DCNL 'Build streaming request. DCNL :type sample: :class:`~google.cloud.speech.sample.Sample` DCNL :param sample: Instance of ``Sample`` containing audio information. DCNL :type language_code: str DCNL :param language_code: The language of the supplied audio as DCNL BCP-47 language tag. Example: ``\'en-GB\'``. DCNL If omitted, defaults to ``\'en-US\'``. DCNL :type max_alternatives: int DCNL :param max_alternatives: Maximum number of recognition DCNL hypotheses to be returned. The server may DCNL return fewer than maxAlternatives. DCNL Valid values are 0-30. A value of 0 or 1 DCNL will return a maximum of 1. Defaults to 1 DCNL :type profanity_filter: bool DCNL :param profanity_filter: If True, the server will attempt to filter DCNL out profanities, replacing all but the DCNL initial character in each filtered word with DCNL asterisks, e.g. ``\'f***\'``. If False or DCNL omitted, profanities won\'t be filtered out. DCNL :type speech_context: list DCNL :param speech_context: A list of strings (max 50) containing words and DCNL phrases "hints" so that the speech recognition DCNL is more likely to recognize them. This can be DCNL used to improve the accuracy for specific words DCNL and phrases. This can also be used to add new DCNL words to the vocabulary of the recognizer. DCNL :type single_utterance: bool DCNL :param single_utterance: If false or omitted, the recognizer DCNL will perform continuous recognition DCNL (continuing to process audio even if the user DCNL pauses speaking) until the client closes the DCNL output stream (gRPC API) or when the maximum DCNL time limit has been reached. Multiple DCNL SpeechRecognitionResults with the is_final DCNL flag set to true may be returned. DCNL If true, the recognizer will detect a single DCNL spoken utterance. When it detects that the DCNL user has paused or stopped speaking, it will DCNL return an END_OF_UTTERANCE event and cease DCNL recognition. It will return no more than one DCNL SpeechRecognitionResult with the is_final flag DCNL set to true. DCNL :type interim_results: bool DCNL :param interim_results: If true, interim results (tentative DCNL hypotheses) may be returned as they become DCNL available (these interim results are indicated DCNL with the is_final=false flag). If false or DCNL omitted, only is_final=true result(s) are DCNL returned. DCNL :rtype: DCNL :class:`~grpc.speech.v1beta1.cloud_speech_pb2.StreamingRecognizeRequest` DCNL :returns: Instance of ``StreamingRecognizeRequest``.'
def _message_pb_from_mapping(message): DCNL 'Helper for :meth:`_PublisherAPI.topic_publish`. DCNL Performs "impedance matching" between the protobuf attrs and the keys DCNL expected in the JSON API.'
def _message_pb_to_mapping(message_pb): DCNL 'Helper for :meth:`pull`, et aliae DCNL Performs "impedance matching" between the protobuf attrs and the keys DCNL expected in the JSON API.'
def _received_message_pb_to_mapping(received_message_pb): DCNL 'Helper for :meth:`pull`, et aliae DCNL Performs "impedance matching" between the protobuf attrs and the keys DCNL expected in the JSON API.'
def make_gax_publisher_api(credentials=None, host=None): DCNL 'Create an instance of the GAX Publisher API. DCNL If the ``credentials`` are omitted, then we create an insecure DCNL ``channel`` pointing at the local Pub / Sub emulator. DCNL :type credentials: :class:`~google.auth.credentials.Credentials` DCNL :param credentials: (Optional) Credentials for getting access DCNL tokens. DCNL :type host: str DCNL :param host: (Optional) The host for an insecure channel. Only DCNL used if ``credentials`` are omitted. DCNL :rtype: :class:`.publisher_client.PublisherClient` DCNL :returns: A publisher API instance with the proper channel.'
def make_gax_subscriber_api(credentials=None, host=None): DCNL 'Create an instance of the GAX Subscriber API. DCNL If the ``credentials`` are omitted, then we create an insecure DCNL ``channel`` pointing at the local Pub / Sub emulator. DCNL :type credentials: :class:`~google.auth.credentials.Credentials` DCNL :param credentials: (Optional) Credentials for getting access DCNL tokens. DCNL :type host: str DCNL :param host: (Optional) The host for an insecure channel. Only DCNL used if ``credentials`` are omitted. DCNL :rtype: :class:`.subscriber_client.SubscriberClient` DCNL :returns: A subscriber API instance with the proper channel.'
def _item_to_topic(iterator, resource): DCNL 'Convert a protobuf topic to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: :class:`.pubsub_pb2.Topic` DCNL :param resource: A topic returned from the API. DCNL :rtype: :class:`~google.cloud.pubsub.topic.Topic` DCNL :returns: The next topic in the page.'
def _item_to_subscription_for_topic(iterator, subscription_path): DCNL 'Convert a subscription name to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type subscription_path: str DCNL :param subscription_path: Subscription path returned from the API. DCNL :rtype: :class:`~google.cloud.pubsub.subscription.Subscription` DCNL :returns: The next subscription in the page.'
def _item_to_sub_for_client(iterator, sub_pb, topics): DCNL 'Convert a subscription protobuf to the native object. DCNL .. note:: DCNL This method does not have the correct signature to be used as DCNL the ``item_to_value`` argument to DCNL :class:`~google.cloud.iterator.Iterator`. It is intended to be DCNL patched with a mutable topics argument that can be updated DCNL on subsequent calls. For an example, see how the method is DCNL used above in :meth:`_SubscriberAPI.list_subscriptions`. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type sub_pb: :class:`.pubsub_pb2.Subscription` DCNL :param sub_pb: A subscription returned from the API. DCNL :type topics: dict DCNL :param topics: A dictionary of topics to be used (and modified) DCNL as new subscriptions are created bound to topics. DCNL :rtype: :class:`~google.cloud.pubsub.subscription.Subscription` DCNL :returns: The next subscription in the page.'
def topic_name_from_path(path, project): DCNL 'Validate a topic URI path and get the topic name. DCNL :type path: str DCNL :param path: URI path for a topic API request. DCNL :type project: str DCNL :param project: The project associated with the request. It is DCNL included for validation purposes. DCNL :rtype: str DCNL :returns: Topic name parsed from ``path``. DCNL :raises: :class:`ValueError` if the ``path`` is ill-formed or if DCNL the project from the ``path`` does not agree with the DCNL ``project`` passed in.'
def subscription_name_from_path(path, project): DCNL 'Validate a subscription URI path and get the subscription name. DCNL :type path: str DCNL :param path: URI path for a subscription API request. DCNL :type project: str DCNL :param project: The project associated with the request. It is DCNL included for validation purposes. DCNL :rtype: str DCNL :returns: subscription name parsed from ``path``. DCNL :raises: :class:`ValueError` if the ``path`` is ill-formed or if DCNL the project from the ``path`` does not agree with the DCNL ``project`` passed in.'
def _base64_unicode(value): DCNL 'Helper to base64 encode and make JSON serializable. DCNL :type value: str DCNL :param value: String value to be base64 encoded and made serializable. DCNL :rtype: str DCNL :returns: Base64 encoded string/unicode value.'
def _transform_messages_base64(messages, transform, key=None): DCNL 'Helper for base64 encoding and decoding messages. DCNL :type messages: list DCNL :param messages: List of dictionaries with message data. DCNL :type transform: :class:`~types.FunctionType` DCNL :param transform: Function to encode/decode the message data. DCNL :type key: str DCNL :param key: Index to access messages.'
def _item_to_topic(iterator, resource): DCNL 'Convert a JSON topic to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: dict DCNL :param resource: A topic returned from the API. DCNL :rtype: :class:`~google.cloud.pubsub.topic.Topic` DCNL :returns: The next topic in the page.'
def _item_to_subscription_for_topic(iterator, subscription_path): DCNL 'Convert a subscription name to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type subscription_path: str DCNL :param subscription_path: Subscription path returned from the API. DCNL :rtype: :class:`~google.cloud.pubsub.subscription.Subscription` DCNL :returns: The next subscription in the page.'
def _item_to_sub_for_client(iterator, resource, topics): DCNL 'Convert a subscription to the native object. DCNL .. note:: DCNL This method does not have the correct signature to be used as DCNL the ``item_to_value`` argument to DCNL :class:`~google.cloud.iterator.Iterator`. It is intended to be DCNL patched with a mutable topics argument that can be updated DCNL on subsequent calls. For an example, see how the method is DCNL used above in :meth:`_SubscriberAPI.list_subscriptions`. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: dict DCNL :param resource: A subscription returned from the API. DCNL :type topics: dict DCNL :param topics: A dictionary of topics to be used (and modified) DCNL as new subscriptions are created bound to topics. DCNL :rtype: :class:`~google.cloud.pubsub.subscription.Subscription` DCNL :returns: The next subscription in the page.'
def _to_gapic_feature(feature): DCNL 'Helper function to convert a ``Feature`` to a gRPC ``Feature``. DCNL :type feature: :class:`~google.cloud.vision.feature.Feature` DCNL :param feature: Local ``Feature`` class to be converted to gRPC ``Feature`` DCNL instance. DCNL :rtype: :class:`~google.cloud.grpc.vision.v1.image_annotator_pb2.Feature` DCNL :returns: gRPC ``Feature`` converted from DCNL :class:`~google.cloud.vision.feature.Feature`.'
def _to_gapic_image(image): DCNL 'Helper function to convert an ``Image`` to a gRPC ``Image``. DCNL :type image: :class:`~google.cloud.vision.image.Image` DCNL :param image: Local ``Image`` class to be converted to gRPC ``Image``. DCNL :rtype: :class:`~google.cloud.grpc.vision.v1.image_annotator_pb2.Image` DCNL :returns: gRPC ``Image`` converted from DCNL :class:`~google.cloud.vision.image.Image`.'
def _process_image_annotations(image): DCNL 'Helper for processing annotation types from protobuf. DCNL :type image: :class:`~google.cloud.grpc.vision.v1.image_annotator_pb2.                 AnnotateImageResponse` DCNL :param image: ``AnnotateImageResponse`` from protobuf. DCNL :rtype: dict DCNL :returns: Dictionary populated with entities from response.'
def _make_entity_from_pb(annotations): DCNL 'Create an entity from a protobuf response. DCNL :type annotations: DCNL :class:`~google.cloud.grpc.vision.v1.image_annotator_pb2.EntityAnnotation` DCNL :param annotations: protobuf instance of ``EntityAnnotation``. DCNL :rtype: list DCNL :returns: List of ``EntityAnnotation``.'
def _make_faces_from_pb(faces): DCNL 'Create face objects from a protobuf response. DCNL :type faces: DCNL :class:`~google.cloud.grpc.vision.v1.image_annotator_pb2.FaceAnnotation` DCNL :param faces: Protobuf instance of ``FaceAnnotation``. DCNL :rtype: list DCNL :returns: List of ``Face``.'
def _make_image_properties_from_pb(image_properties): DCNL 'Create ``ImageProperties`` object from a protobuf response. DCNL :type image_properties: :class:`~google.cloud.grpc.vision.v1.                            image_annotator_pb2.ImagePropertiesAnnotation` DCNL :param image_properties: Protobuf instance of DCNL ``ImagePropertiesAnnotation``. DCNL :rtype: list or ``None`` DCNL :returns: List of ``ImageProperties`` or ``None``.'
def _make_safe_search_from_pb(safe_search): DCNL 'Create ``SafeSearchAnnotation`` object from a protobuf response. DCNL :type safe_search: :class:`~google.cloud.grpc.vision.v1.                            image_annotator_pb2.SafeSearchAnnotation` DCNL :param safe_search: Protobuf instance of ``SafeSearchAnnotation``. DCNL :rtype: :class: `~google.cloud.vision.safe_search.SafeSearchAnnotation` DCNL :returns: Instance of ``SafeSearchAnnotation``.'
def _entity_from_response_type(feature_type, results): DCNL 'Convert a JSON result to an entity type based on the feature. DCNL :rtype: list DCNL :returns: List containing any of DCNL :class:`~google.cloud.vision.entity.EntityAnnotation`, DCNL :class:`~google.cloud.vision.face.Face` DCNL or one of DCNL :class:`~google.cloud.vision.safe_search.SafeSearchAnnotation`, DCNL :class:`~google.cloud.vision.color.ImagePropertiesAnnotation`.'
def _get_pb_likelihood(likelihood): DCNL 'Convert protobuf Likelihood integer value to Likelihood enum. DCNL :type likelihood: int DCNL :param likelihood: Protobuf integer representing ``Likelihood``. DCNL :rtype: :class:`~google.cloud.vision.likelihood.Likelihood` DCNL :returns: Enum ``Likelihood`` converted from protobuf value.'
def _make_request(image, features): DCNL 'Prepare request object to send to Vision API. DCNL :type image: :class:`~google.cloud.vision.image.Image` DCNL :param image: Instance of ``Image``. DCNL :type features: list of :class:`~google.cloud.vision.feature.Feature` DCNL :param features: Either a list of ``Feature`` instances or a single DCNL instance of ``Feature``. DCNL :rtype: dict DCNL :returns: Dictionary prepared to send to the Vision API.'
def _get_gcd_project(): DCNL 'Gets the GCD application ID if it can be inferred.'
def _determine_default_project(project=None): DCNL 'Determine default project explicitly or implicitly as fall-back. DCNL In implicit case, supports four environments. In order of precedence, the DCNL implicit environments are: DCNL * DATASTORE_DATASET environment variable (for ``gcd`` / emulator testing) DCNL * GOOGLE_CLOUD_PROJECT environment variable DCNL * Google App Engine application ID DCNL * Google Compute Engine project ID (from metadata server) DCNL :type project: str DCNL :param project: Optional. The project to use as default. DCNL :rtype: str or ``NoneType`` DCNL :returns: Default project if it can be determined.'
def _extended_lookup(connection, project, key_pbs, missing=None, deferred=None, eventual=False, transaction_id=None): DCNL 'Repeat lookup until all keys found (unless stop requested). DCNL Helper function for :meth:`Client.get_multi`. DCNL :type connection: :class:`google.cloud.datastore._http.Connection` DCNL :param connection: The connection used to connect to datastore. DCNL :type project: str DCNL :param project: The project to make the request for. DCNL :type key_pbs: list of :class:`.entity_pb2.Key` DCNL :param key_pbs: The keys to retrieve from the datastore. DCNL :type missing: list DCNL :param missing: (Optional) If a list is passed, the key-only entity DCNL protobufs returned by the backend as "missing" will be DCNL copied into it. DCNL :type deferred: list DCNL :param deferred: (Optional) If a list is passed, the key protobufs returned DCNL by the backend as "deferred" will be copied into it. DCNL :type eventual: bool DCNL :param eventual: If False (the default), request ``STRONG`` read DCNL consistency.  If True, request ``EVENTUAL`` read DCNL consistency. DCNL :type transaction_id: str DCNL :param transaction_id: If passed, make the request in the scope of DCNL the given transaction.  Incompatible with DCNL ``eventual==True``. DCNL :rtype: list of :class:`.entity_pb2.Entity` DCNL :returns: The requested entities. DCNL :raises: :class:`ValueError` if missing / deferred are not null or DCNL empty list.'
def _assign_entity_to_pb(entity_pb, entity): DCNL 'Copy ``entity`` into ``entity_pb``. DCNL Helper method for ``Batch.put``. DCNL :type entity_pb: :class:`.entity_pb2.Entity` DCNL :param entity_pb: The entity owned by a mutation. DCNL :type entity: :class:`google.cloud.datastore.entity.Entity` DCNL :param entity: The entity being updated within the batch / transaction.'
def _pb_from_query(query): DCNL 'Convert a Query instance to the corresponding protobuf. DCNL :type query: :class:`Query` DCNL :param query: The source query. DCNL :rtype: :class:`.query_pb2.Query` DCNL :returns: A protobuf that can be sent to the protobuf API.  N.b. that DCNL it does not contain "in-flight" fields for ongoing query DCNL executions (cursors, offset, limit).'
def _item_to_entity(iterator, entity_pb): DCNL 'Convert a raw protobuf entity to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type entity_pb: DCNL :class:`.entity_pb2.Entity` DCNL :param entity_pb: An entity protobuf to convert to a native entity. DCNL :rtype: :class:`~google.cloud.datastore.entity.Entity` DCNL :returns: The next entity in the page.'
def _validate_project(project, parent): DCNL 'Ensure the project is set appropriately. DCNL If ``parent`` is passed, skip the test (it will be checked / fixed up DCNL later). DCNL If ``project`` is unset, attempt to infer the project from the environment. DCNL :type project: str DCNL :param project: A project. DCNL :type parent: :class:`google.cloud.datastore.key.Key` DCNL :param parent: (Optional) The parent of the key or ``None``. DCNL :rtype: str DCNL :returns: The ``project`` passed in, or implied from the environment. DCNL :raises: :class:`ValueError` if ``project`` is ``None`` and no project DCNL can be inferred from the parent.'
def _get_meaning(value_pb, is_list=False): DCNL 'Get the meaning from a protobuf value. DCNL :type value_pb: :class:`.entity_pb2.Value` DCNL :param value_pb: The protobuf value to be checked for an DCNL associated meaning. DCNL :type is_list: bool DCNL :param is_list: Boolean indicating if the ``value_pb`` contains DCNL a list value. DCNL :rtype: int DCNL :returns: The meaning for the ``value_pb`` if one is set, else DCNL :data:`None`. For a list value, if there are disagreeing DCNL means it just returns a list of meanings. If all the DCNL list meanings agree, it just condenses them.'
def _new_value_pb(entity_pb, name): DCNL 'Add (by name) a new ``Value`` protobuf to an entity protobuf. DCNL :type entity_pb: :class:`.entity_pb2.Entity` DCNL :param entity_pb: An entity protobuf to add a new property to. DCNL :type name: str DCNL :param name: The name of the new property. DCNL :rtype: :class:`.entity_pb2.Value` DCNL :returns: The new ``Value`` protobuf that was added to the entity.'
def _property_tuples(entity_pb): DCNL 'Iterator of name, ``Value`` tuples from entity properties. DCNL :type entity_pb: :class:`.entity_pb2.Entity` DCNL :param entity_pb: An entity protobuf to add a new property to. DCNL :rtype: :class:`generator` DCNL :returns: An iterator that yields tuples of a name and ``Value`` DCNL corresponding to properties on the entity.'
def entity_from_protobuf(pb): DCNL 'Factory method for creating an entity based on a protobuf. DCNL The protobuf should be one returned from the Cloud Datastore DCNL Protobuf API. DCNL :type pb: :class:`.entity_pb2.Entity` DCNL :param pb: The Protobuf representing the entity. DCNL :rtype: :class:`google.cloud.datastore.entity.Entity` DCNL :returns: The entity derived from the protobuf.'
def _set_pb_meaning_from_entity(entity, name, value, value_pb, is_list=False): DCNL 'Add meaning information (from an entity) to a protobuf. DCNL :type entity: :class:`google.cloud.datastore.entity.Entity` DCNL :param entity: The entity to be turned into a protobuf. DCNL :type name: str DCNL :param name: The name of the property. DCNL :type value: object DCNL :param value: The current value stored as property ``name``. DCNL :type value_pb: :class:`.entity_pb2.Value` DCNL :param value_pb: The protobuf value to add meaning / meanings to. DCNL :type is_list: bool DCNL :param is_list: (Optional) Boolean indicating if the ``value`` is DCNL a list value.'
def entity_to_protobuf(entity): DCNL 'Converts an entity into a protobuf. DCNL :type entity: :class:`google.cloud.datastore.entity.Entity` DCNL :param entity: The entity to be turned into a protobuf. DCNL :rtype: :class:`.entity_pb2.Entity` DCNL :returns: The protobuf representing the entity.'
def key_from_protobuf(pb): DCNL 'Factory method for creating a key based on a protobuf. DCNL The protobuf should be one returned from the Cloud Datastore DCNL Protobuf API. DCNL :type pb: :class:`.entity_pb2.Key` DCNL :param pb: The Protobuf representing the key. DCNL :rtype: :class:`google.cloud.datastore.key.Key` DCNL :returns: a new `Key` instance'
def _pb_attr_value(val): DCNL 'Given a value, return the protobuf attribute name and proper value. DCNL The Protobuf API uses different attribute names based on value types DCNL rather than inferring the type.  This function simply determines the DCNL proper attribute name based on the type of the value provided and DCNL returns the attribute name as well as a properly formatted value. DCNL Certain value types need to be coerced into a different type (such DCNL as a `datetime.datetime` into an integer timestamp, or a DCNL `google.cloud.datastore.key.Key` into a Protobuf representation.  This DCNL function handles that for you. DCNL .. note:: DCNL Values which are "text" (\'unicode\' in Python2, \'str\' in Python3) map DCNL to \'string_value\' in the datastore;  values which are "bytes" DCNL (\'str\' in Python2, \'bytes\' in Python3) map to \'blob_value\'. DCNL For example: DCNL >>> _pb_attr_value(1234) DCNL (\'integer_value\', 1234) DCNL >>> _pb_attr_value(\'my_string\') DCNL (\'string_value\', \'my_string\') DCNL :type val: `datetime.datetime`, :class:`google.cloud.datastore.key.Key`, DCNL bool, float, integer, string DCNL :param val: The value to be scrutinized. DCNL :rtype: tuple DCNL :returns: A tuple of the attribute name and proper value type.'
def _get_value_from_value_pb(value_pb): DCNL 'Given a protobuf for a Value, get the correct value. DCNL The Cloud Datastore Protobuf API returns a Property Protobuf which DCNL has one value set and the rest blank.  This function retrieves the DCNL the one value provided. DCNL Some work is done to coerce the return value into a more useful type DCNL (particularly in the case of a timestamp value, or a key value). DCNL :type value_pb: :class:`.entity_pb2.Value` DCNL :param value_pb: The Value Protobuf. DCNL :rtype: object DCNL :returns: The value provided by the Protobuf. DCNL :raises: :class:`ValueError <exceptions.ValueError>` if no value type DCNL has been set.'
def _set_protobuf_value(value_pb, val): DCNL 'Assign \'val\' to the correct subfield of \'value_pb\'. DCNL The Protobuf API uses different attribute names based on value types DCNL rather than inferring the type. DCNL Some value types (entities, keys, lists) cannot be directly DCNL assigned; this function handles them correctly. DCNL :type value_pb: :class:`.entity_pb2.Value` DCNL :param value_pb: The value protobuf to which the value is being assigned. DCNL :type val: :class:`datetime.datetime`, boolean, float, integer, string, DCNL :class:`google.cloud.datastore.key.Key`, DCNL :class:`google.cloud.datastore.entity.Entity` DCNL :param val: The value to be assigned.'
@contextlib.contextmanager DCNL def _grpc_catch_rendezvous(): DCNL 'Re-map gRPC exceptions that happen in context. DCNL .. _code.proto: https://github.com/googleapis/googleapis/blob/                    master/google/rpc/code.proto DCNL Remaps gRPC exceptions to the classes defined in DCNL :mod:`~google.cloud.exceptions` (according to the description DCNL in `code.proto`_).'
def _set_read_options(request, eventual, transaction_id): DCNL 'Validate rules for read options, and assign to the request. DCNL Helper method for ``lookup()`` and ``run_query``. DCNL :raises: :class:`ValueError` if ``eventual`` is ``True`` and the DCNL ``transaction_id`` is not ``None``.'
def _add_keys_to_request(request_field_pb, key_pbs): DCNL 'Add protobuf keys to a request object. DCNL :type request_field_pb: `RepeatedCompositeFieldContainer` DCNL :param request_field_pb: A repeated proto field that contains keys. DCNL :type key_pbs: list of :class:`.entity_pb2.Key` DCNL :param key_pbs: The keys to add to a request.'
def _parse_commit_response(commit_response_pb): DCNL 'Extract response data from a commit response. DCNL :type commit_response_pb: :class:`.datastore_pb2.CommitResponse` DCNL :param commit_response_pb: The protobuf response from a commit request. DCNL :rtype: tuple DCNL :returns: The pair of the number of index updates and a list of DCNL :class:`.entity_pb2.Key` for each incomplete key DCNL that was completed in the commit.'
def _get_encryption_headers(key, source=False): DCNL 'Builds customer encryption key headers DCNL :type key: bytes DCNL :param key: 32 byte key to build request key and hash. DCNL :type source: bool DCNL :param source: If true, return headers for the "source" blob; otherwise, DCNL return headers for the "destination" blob. DCNL :rtype: dict DCNL :returns: dict of HTTP headers being sent in request.'
def _item_to_bucket(iterator, item): DCNL 'Convert a JSON bucket to the native object. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that has retrieved the item. DCNL :type item: dict DCNL :param item: An item to be converted to a bucket. DCNL :rtype: :class:`.Bucket` DCNL :returns: The next bucket in the page.'
def _generate_faux_mime_message(parser, response, content): DCNL 'Convert response, content -> (multipart) email.message. DCNL Helper for _unpack_batch_response.'
def _unpack_batch_response(response, content): DCNL 'Convert response, content -> [(headers, payload)]. DCNL Creates a generator of tuples of emulating the responses to DCNL :meth:`httplib2.Http.request` (a pair of headers and payload). DCNL :type response: :class:`httplib2.Response` DCNL :param response: HTTP response / headers from a request. DCNL :type content: str DCNL :param content: Response payload with a batch response.'
def _scalar_property(fieldname): DCNL 'Create a property descriptor around the :class:`_PropertyMixin` helpers.'
def _write_buffer_to_hash(buffer_object, hash_obj, digest_block_size=8192): DCNL 'Read blocks from a buffer and update a hash with them. DCNL :type buffer_object: bytes buffer DCNL :param buffer_object: Buffer containing bytes used to update a hash object. DCNL :type hash_obj: object that implements update DCNL :param hash_obj: A hash object (MD5 or CRC32-C). DCNL :type digest_block_size: int DCNL :param digest_block_size: The block size to write to the hash. DCNL Defaults to 8192.'
def _base64_md5hash(buffer_object): DCNL 'Get MD5 hash of bytes (as base64). DCNL :type buffer_object: bytes buffer DCNL :param buffer_object: Buffer containing bytes used to compute an MD5 DCNL hash (as base64). DCNL :rtype: str DCNL :returns: A base64 encoded digest of the MD5 hash.'
def _blobs_page_start(iterator, page, response): DCNL 'Grab prefixes after a :class:`~google.cloud.iterator.Page` started. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type page: :class:`~google.cloud.iterator.Page` DCNL :param page: The page that was just created. DCNL :type response: dict DCNL :param response: The JSON API response for a page of blobs.'
def _item_to_blob(iterator, item): DCNL 'Convert a JSON blob to the native object. DCNL .. note:: DCNL This assumes that the ``bucket`` attribute has been DCNL added to the iterator after being created. DCNL :type iterator: :class:`~google.cloud.iterator.Iterator` DCNL :param iterator: The iterator that has retrieved the item. DCNL :type item: dict DCNL :param item: An item to be converted to a blob. DCNL :rtype: :class:`.Blob` DCNL :returns: The next blob in the page.'
def _parse_readrows_acceptance_tests(filename): DCNL 'Parse acceptance tests from JSON DCNL See: DCNL https://github.com/GoogleCloudPlatform/cloud-bigtable-client/blob/    4d3185662ca61bc9fa1bdf1ec0166f6e5ecf86c6/bigtable-client-core/src/    test/resources/com/google/cloud/bigtable/grpc/scanner/v2/ DCNL read-rows-acceptance-test.json'
def _raise_if(predicate, *args): DCNL 'Helper for validation methods.'
def _create_row_request(table_name, row_key=None, start_key=None, end_key=None, filter_=None, limit=None): DCNL 'Creates a request to read rows in a table. DCNL :type table_name: str DCNL :param table_name: The name of the table to read from. DCNL :type row_key: bytes DCNL :param row_key: (Optional) The key of a specific row to read from. DCNL :type start_key: bytes DCNL :param start_key: (Optional) The beginning of a range of row keys to DCNL read from. The range will include ``start_key``. If DCNL left empty, will be interpreted as the empty string. DCNL :type end_key: bytes DCNL :param end_key: (Optional) The end of a range of row keys to read from. DCNL The range will not include ``end_key``. If left empty, DCNL will be interpreted as an infinite string. DCNL :type filter_: :class:`.RowFilter` DCNL :param filter_: (Optional) The filter to apply to the contents of the DCNL specified row(s). If unset, reads the entire table. DCNL :type limit: int DCNL :param limit: (Optional) The read will terminate after committing to N DCNL rows\' worth of results. The default (zero) is to return DCNL all results. DCNL :rtype: :class:`data_messages_v2_pb2.ReadRowsRequest` DCNL :returns: The ``ReadRowsRequest`` protobuf corresponding to the inputs. DCNL :raises: :class:`ValueError <exceptions.ValueError>` if both DCNL ``row_key`` and one of ``start_key`` and ``end_key`` are set'
def _prepare_create_request(instance): DCNL 'Creates a protobuf request for a CreateInstance request. DCNL :type instance: :class:`Instance` DCNL :param instance: The instance to be created. DCNL :rtype: :class:`.messages_v2_pb2.CreateInstanceRequest` DCNL :returns: The CreateInstance request object containing the instance info.'
def _make_data_stub(client): DCNL 'Creates gRPC stub to make requests to the Data API. DCNL :type client: :class:`Client` DCNL :param client: The client that will hold the stub. DCNL :rtype: :class:`._generated.bigtable_pb2.BigtableStub` DCNL :returns: A gRPC stub object.'
def _make_instance_stub(client): DCNL 'Creates gRPC stub to make requests to the Instance Admin API. DCNL :type client: :class:`Client` DCNL :param client: The client that will hold the stub. DCNL :rtype: :class:`.bigtable_instance_admin_pb2.BigtableInstanceAdminStub` DCNL :returns: A gRPC stub object.'
def _make_operations_stub(client): DCNL 'Creates gRPC stub to make requests to the Operations API. DCNL These are for long-running operations of the Instance Admin API, DCNL hence the host and port matching. DCNL :type client: :class:`Client` DCNL :param client: The client that will hold the stub. DCNL :rtype: :class:`google.longrunning.operations_grpc.OperationsStub` DCNL :returns: A gRPC stub object.'
def _make_table_stub(client): DCNL 'Creates gRPC stub to make requests to the Table Admin API. DCNL :type client: :class:`Client` DCNL :param client: The client that will hold the stub. DCNL :rtype: :class:`.bigtable_instance_admin_pb2.BigtableTableAdminStub` DCNL :returns: A gRPC stub object.'
def _prepare_create_request(cluster): DCNL 'Creates a protobuf request for a CreateCluster request. DCNL :type cluster: :class:`Cluster` DCNL :param cluster: The cluster to be created. DCNL :rtype: :class:`.messages_v2_pb2.CreateClusterRequest` DCNL :returns: The CreateCluster request object containing the cluster info.'
def _parse_rmw_row_response(row_response): DCNL 'Parses the response to a ``ReadModifyWriteRow`` request. DCNL :type row_response: :class:`.data_v2_pb2.Row` DCNL :param row_response: The response row (with only modified cells) from a DCNL ``ReadModifyWriteRow`` request. DCNL :rtype: dict DCNL :returns: The new contents of all modified cells. Returned as a DCNL dictionary of column families, each of which holds a DCNL dictionary of columns. Each column contains a list of cells DCNL modified. Each cell is represented with a two-tuple with the DCNL value (in bytes) and the timestamp for the cell. For example: DCNL .. code:: python DCNL u\'col-fam-id\': { DCNL b\'col-name1\': [ DCNL (b\'cell-val\', datetime.datetime(...)), DCNL (b\'cell-val-newer\', datetime.datetime(...)), DCNL b\'col-name2\': [ DCNL (b\'altcol-cell-val\', datetime.datetime(...)), DCNL u\'col-fam-id2\': { DCNL b\'col-name3-but-other-fam\': [ DCNL (b\'foo\', datetime.datetime(...)),'
def _parse_family_pb(family_pb): DCNL 'Parses a Family protobuf into a dictionary. DCNL :type family_pb: :class:`._generated.data_pb2.Family` DCNL :param family_pb: A protobuf DCNL :rtype: tuple DCNL :returns: A string and dictionary. The string is the name of the DCNL column family and the dictionary has column names (within the DCNL family) as keys and cell lists as values. Each cell is DCNL represented with a two-tuple with the value (in bytes) and the DCNL timestamp for the cell. For example: DCNL .. code:: python DCNL b\'col-name1\': [ DCNL (b\'cell-val\', datetime.datetime(...)), DCNL (b\'cell-val-newer\', datetime.datetime(...)), DCNL b\'col-name2\': [ DCNL (b\'altcol-cell-val\', datetime.datetime(...)),'
def _gc_rule_from_pb(gc_rule_pb): DCNL 'Convert a protobuf GC rule to a native object. DCNL :type gc_rule_pb: :class:`.table_v2_pb2.GcRule` DCNL :param gc_rule_pb: The GC rule to convert. DCNL :rtype: :class:`GarbageCollectionRule` or :data:`NoneType <types.NoneType>` DCNL :returns: An instance of one of the native rules defined DCNL in :module:`column_family` or :data:`None` if no values were DCNL set on the protobuf passed in. DCNL :raises: :class:`ValueError <exceptions.ValueError>` if the rule name DCNL is unexpected.'
def get_most_frequent_response(input_statement, response_list): DCNL ':param input_statement: A statement, that closely matches an input to the chat bot. DCNL :type input_statement: Statement DCNL :param response_list: A list of statement options to choose a response from. DCNL :type response_list: list DCNL :return: The response statement with the greatest number of occurrences. DCNL :rtype: Statement'
def get_first_response(input_statement, response_list): DCNL ':param input_statement: A statement, that closely matches an input to the chat bot. DCNL :type input_statement: Statement DCNL :param response_list: A list of statement options to choose a response from. DCNL :type response_list: list DCNL :return: Return the first statement in the response list. DCNL :rtype: Statement'
def get_random_response(input_statement, response_list): DCNL ':param input_statement: A statement, that closely matches an input to the chat bot. DCNL :type input_statement: Statement DCNL :param response_list: A list of statement options to choose a response from. DCNL :type response_list: list DCNL :return: Choose a random response from the selection. DCNL :rtype: Statement'
def clean_whitespace(chatbot, statement): DCNL 'Remove any consecutive whitespace characters from the statement text.'
def unescape_html(chatbot, statement): DCNL 'Convert escaped html characters into unescaped html characters. DCNL For example: "&lt;b&gt;" becomes "<b>".'
def convert_to_ascii(chatbot, statement): DCNL 'Converts unicode characters to ASCII character equivalents. DCNL For example: "p fdral" becomes "pa federal".'
def import_module(dotted_path): DCNL 'Imports the specified module based on the DCNL dot notated import path for the module.'
def initialize_class(data, **kwargs): DCNL ':param data: A string or dictionary containing a import_path attribute.'
def validate_adapter_class(validate_class, adapter_class): DCNL 'Raises an exception if validate_class is not a DCNL subclass of adapter_class. DCNL :param validate_class: The class to be validated. DCNL :type validate_class: class DCNL :param adapter_class: The class type to check against. DCNL :type adapter_class: class DCNL :raises: Adapter.InvalidAdapterTypeException'
def input_function(): DCNL 'Normalizes reading input between python 2 and 3. DCNL The function \'raw_input\' becomes \'input\' in Python 3.'
def nltk_download_corpus(resource_path): DCNL 'Download the specified NLTK corpus file DCNL unless it has already been downloaded. DCNL Returns True if the corpus needed to be downloaded.'
def remove_stopwords(tokens, language): DCNL 'Takes a language (i.e. \'english\'), and a set of word tokens. DCNL Returns the tokenized text with any stopwords removed. DCNL Stop words are words like "is, the, a, ..."'
def levenshtein_distance(statement, other_statement): DCNL 'Compare two statements based on the Levenshtein distance DCNL of each statement\'s text. DCNL For example, there is a 65% similarity between the statements DCNL "where is the post office?" and "looking for the post office" DCNL based on the Levenshtein distance algorithm. DCNL :return: The percent of similarity between the text of the statements. DCNL :rtype: float'
def synset_distance(statement, other_statement): DCNL 'Calculate the similarity of two statements. DCNL This is based on the total maximum synset similarity between each word in each sentence. DCNL This algorithm uses the `wordnet`_ functionality of `NLTK`_ to determine the similarity DCNL of two statements based on the path similarity between each token of each statement. DCNL This is essentially an evaluation of the closeness of synonyms. DCNL :return: The percent of similarity between the closest synset distance. DCNL :rtype: float DCNL .. _wordnet: http://www.nltk.org/howto/wordnet.html DCNL .. _NLTK: http://www.nltk.org/'
def sentiment_comparison(statement, other_statement): DCNL 'Calculate the similarity of two statements based on the closeness of DCNL the sentiment value calculated for each statement. DCNL :return: The percent of similarity between the sentiment value. DCNL :rtype: float'
def jaccard_similarity(statement, other_statement, threshold=0.5): DCNL 'Calculates the similarity of two statements based on the Jaccard index. DCNL The Jaccard index is composed of a numerator and denominator. DCNL In the numerator, we count the number of items that are shared between the sets. DCNL In the denominator, we count the total number of items across both sets. DCNL Let\'s say we define sentences to be equivalent if 50% or more of their tokens are equivalent. DCNL Here are two sample sentences: DCNL The young cat is hungry. DCNL The cat is very hungry. DCNL When we parse these sentences to remove stopwords, we end up with the following two sets: DCNL {young, cat, hungry} DCNL {cat, very, hungry} DCNL In our example above, our intersection is {cat, hungry}, which has count of two. DCNL The union of the sets is {young, cat, very, hungry}, which has a count of four. DCNL Therefore, our `Jaccard similarity index`_ is two divided by four, or 50%. DCNL Given our threshold above, we would consider this to be a match. DCNL .. _`Jaccard similarity index`: https://en.wikipedia.org/wiki/Jaccard_index'
def hashnum(number): DCNL 'Hash of numbers DCNL Append more number to modify your match'
def convert_string_to_number(value): DCNL 'Convert strings to numbers'
def convert_time_to_hour_minute(hour, minute, convention): DCNL 'Convert time to hour, minute'
def date_from_quarter(base_date, ordinal, year): DCNL 'Extract date from quarter of a year'
def date_from_relative_day(base_date, time, dow): DCNL 'Converts relative day to time DCNL Ex: this tuesday, last tuesday'
def date_from_relative_week_year(base_date, time, dow, ordinal=1): DCNL 'Converts relative day to time DCNL Eg. this tuesday, last tuesday'
def date_from_adverb(base_date, name): DCNL 'Convert Day adverbs to dates DCNL Tomorrow => Date DCNL Today => Date'
def date_from_duration(base_date, number_as_string, unit, duration, base_time=None): DCNL 'Find dates from duration DCNL Eg: 20 days from now DCNL Currently does not support strings like "20 days from last monday".'
def this_week_day(base_date, weekday): DCNL 'Finds coming weekday'
def previous_week_day(base_date, weekday): DCNL 'Finds previous weekday'
def next_week_day(base_date, weekday): DCNL 'Finds next weekday'
def datetime_parsing(text, base_date=datetime.now()): DCNL 'Extract datetime objects from a string of text.'
def generate_strings(total_strings, string_length=20): DCNL 'Generate a list of random strings.'
def _euclidean_dist(vector_a, vector_b): DCNL ':param vector_a:    A list of numbers. DCNL :param vector_b:    A list of numbers. DCNL :returns:           The euclidean distance between the two vectors.'
def _get_closest_matches(input_attributes, target_attributes): DCNL ':param input_attributes:    First dictionary of objects to attribute tuples. DCNL :param target_attributes:   Second dictionary of blocks to attribute tuples. DCNL :returns:                   A dictionary of objects in the input_attributes to the closest objects in the DCNL target_attributes.'
def _levenshtein_distance(s1, s2): DCNL ':param s1:  A list or string DCNL :param s2:  Another list or string DCNL :returns:    The levenshtein distance between the two'
def _normalized_levenshtein_distance(s1, s2, acceptable_differences): DCNL 'This function calculates the levenshtein distance but allows for elements in the lists to be different by any number DCNL in the set acceptable_differences. DCNL :param s1:                      A list. DCNL :param s2:                      Another list. DCNL :param acceptable_differences:  A set of numbers. If (s2[i]-s1[i]) is in the set then they are considered equal. DCNL :returns:'
def _is_better_match(x, y, matched_a, matched_b, attributes_dict_a, attributes_dict_b): DCNL ':param x:                   The first element of a possible match. DCNL :param y:                   The second element of a possible match. DCNL :param matched_a:           The current matches for the first set. DCNL :param matched_b:           The current matches for the second set. DCNL :param attributes_dict_a:   The attributes for each element in the first set. DCNL :param attributes_dict_b:   The attributes for each element in the second set. DCNL :returns:                   True/False'
def differing_constants(block_a, block_b): DCNL 'Compares two basic blocks and finds all the constants that differ from the first block to the second. DCNL :param block_a: The first block to compare. DCNL :param block_b: The second block to compare. DCNL :returns:       Returns a list of differing constants in the form of ConstantChange, which has the offset in the DCNL block and the respective constants.'
def compare_cfg(standard, g, function_list): DCNL 'Standard graph comes with addresses only, and it is based on instructions, not on basic blocks'
def cfg_fast_functions_check(arch, binary_path, func_addrs, func_features): DCNL 'Generate a fast CFG on the given binary, and test if all specified functions are found DCNL :param str arch: the architecture, will be prepended to `binary_path` DCNL :param str binary_path: path to the binary under the architecture directory DCNL :param dict func_addrs: A collection of function addresses that should be recovered DCNL :param dict func_features: A collection of features for some of the functions DCNL :return: None'
def cfg_fast_edges_check(arch, binary_path, edges): DCNL 'Generate a fast CFG on the given binary, and test if all edges are found. DCNL :param str arch: the architecture, will be prepended to `binary_path` DCNL :param str binary_path: path to the binary under the architecture directory DCNL :param list edges: a list of edges DCNL :return: None'
def test_cle_gdb(): DCNL 'Test for `info proc mappings`'
def test_sharedlibs(): DCNL 'Test for info sharedlibrary'
def write_commit_patch(f, commit, contents, progress, version=None, encoding=None): DCNL 'Write a individual file patch. DCNL :param commit: Commit object DCNL :param progress: Tuple with current patch number and total. DCNL :return: tuple with filename and contents'
def get_summary(commit): DCNL 'Determine the summary line for use in a filename. DCNL :param commit: Commit DCNL :return: Summary string'
def unified_diff(a, b, fromfile, tofile, n=3): DCNL 'difflib.unified_diff that doesn\'t write any dates or trailing spaces. DCNL Based on the same function in Python2.6.5-rc2\'s difflib.py'
def is_binary(content): DCNL 'See if the first few bytes contain any null characters. DCNL :param content: Bytestring to check for binary content'
def write_object_diff(f, store, old_file, new_file, diff_binary=False): DCNL 'Write the diff for an object. DCNL :param f: File-like object to write to DCNL :param store: Store to retrieve objects from, if necessary DCNL :param old_file: (path, mode, hexsha) tuple DCNL :param new_file: (path, mode, hexsha) tuple DCNL :param diff_binary: Whether to diff files even if they DCNL are considered binary files by is_binary(). DCNL :note: the tuple elements should be None for nonexistant files'
def gen_diff_header(paths, modes, shas): DCNL 'Write a blob diff header. DCNL :param paths: Tuple with old and new path DCNL :param modes: Tuple with old and new modes DCNL :param shas: Tuple with old and new shas'
def write_blob_diff(f, old_file, new_file): DCNL 'Write blob diff. DCNL :param f: File-like object to write to DCNL :param old_file: (path, mode, hexsha) tuple (None if nonexisting) DCNL :param new_file: (path, mode, hexsha) tuple (None if nonexisting) DCNL :note: The use of write_object_diff is recommended over this function.'
def write_tree_diff(f, store, old_tree, new_tree, diff_binary=False): DCNL 'Write tree diff. DCNL :param f: File-like object to write to. DCNL :param old_tree: Old tree id DCNL :param new_tree: New tree id DCNL :param diff_binary: Whether to diff files even if they DCNL are considered binary files by is_binary().'
def git_am_patch_split(f, encoding=None): DCNL 'Parse a git-am-style patch and split it up into bits. DCNL :param f: File-like object to parse DCNL :param encoding: Encoding to use when creating Git objects DCNL :return: Tuple with commit object, diff contents and git version'
def parse_patch_message(msg, encoding=None): DCNL 'Extract a Commit object and patch from an e-mail message. DCNL :param msg: An email message (email.message.Message) DCNL :param encoding: Encoding to use to encode Git commits DCNL :return: Tuple with commit object, diff contents and git version'
def S_ISGITLINK(m): DCNL 'Check if a mode indicates a submodule. DCNL :param m: Mode to check DCNL :return: a ``boolean``'
def sha_to_hex(sha): DCNL 'Takes a string and returns the hex of the sha within'
def hex_to_sha(hex): DCNL 'Takes a hex sha and returns a binary sha'
def hex_to_filename(path, hex): DCNL 'Takes a hex sha and returns its filename relative to the given path.'
def filename_to_hex(filename): DCNL 'Takes an object filename and returns its corresponding hex sha.'
def object_header(num_type, length): DCNL 'Return an object header for the given numeric type and text length.'
def serializable_property(name, docstring=None): DCNL 'A property that helps tracking whether serialization is necessary.'
def object_class(type): DCNL 'Get the object class corresponding to the given type. DCNL :param type: Either a type name string or a numeric type. DCNL :return: The ShaFile subclass corresponding to the given type, or None if DCNL type is not a valid type name/number.'
def check_hexsha(hex, error_msg): DCNL 'Check if a string is a valid hex sha string. DCNL :param hex: Hex string to check DCNL :param error_msg: Error message to use in exception DCNL :raise ObjectFormatException: Raised when the string is not valid'
def check_identity(identity, error_msg): DCNL 'Check if the specified identity is valid. DCNL This will raise an exception if the identity is not valid. DCNL :param identity: Identity string DCNL :param error_msg: Error message to use in exception'
def git_line(*items): DCNL 'Formats items into a space sepreated line.'
def _parse_message(chunks): DCNL 'Parse a message with a list of fields and a body. DCNL :param chunks: the raw chunks of the tag or commit object. DCNL :return: iterator of tuples of (field, value), one per header line, in the DCNL order read from the text, possibly including duplicates. Includes a DCNL field named None for the freeform tag/commit text.'
def parse_tree(text, strict=False): DCNL 'Parse a tree text. DCNL :param text: Serialized text to parse DCNL :return: iterator of tuples of (name, mode, sha) DCNL :raise ObjectFormatException: if the object was malformed in some way'
def serialize_tree(items): DCNL 'Serialize the items in a tree to a text. DCNL :param items: Sorted iterable over (name, mode, sha) tuples DCNL :return: Serialized tree text as chunks'
def sorted_tree_items(entries, name_order): DCNL 'Iterate over a tree entries dictionary. DCNL :param name_order: If True, iterate entries in order of their name. If DCNL False, iterate entries in tree order, that is, treat subtree entries as DCNL having \'/\' appended. DCNL :param entries: Dictionary mapping names to (mode, sha) tuples DCNL :return: Iterator over (name, mode, hexsha)'
def key_entry(entry): DCNL 'Sort key for tree entry. DCNL :param entry: (name, value) tuplee'
def key_entry_name_order(entry): DCNL 'Sort key for tree entry in name order.'
def pretty_format_tree_entry(name, mode, hexsha, encoding='utf-8'): DCNL 'Pretty format tree entry. DCNL :param name: Name of the directory entry DCNL :param mode: Mode of entry DCNL :param hexsha: Hexsha of the referenced object DCNL :return: string describing the tree entry'
def parse_timezone(text): DCNL 'Parse a timezone text fragment (e.g. \'+0100\'). DCNL :param text: Text to parse. DCNL :return: Tuple with timezone as seconds difference to UTC DCNL and a boolean indicating whether this was a UTC timezone DCNL prefixed with a negative sign (-0000).'
def format_timezone(offset, unnecessary_negative_timezone=False): DCNL 'Format a timezone for Git serialization. DCNL :param offset: Timezone offset as seconds difference to UTC DCNL :param unnecessary_negative_timezone: Whether to use a minus sign for DCNL UTC or positive timezones (-0000 and --700 rather than +0000 / +0700).'
def parse_commit(chunks): DCNL 'Parse a commit object from chunks. DCNL :param chunks: Chunks to parse DCNL :return: Tuple of (tree, parents, author_info, commit_info, DCNL encoding, mergetag, gpgsig, message, extra)'
def tree_lookup_path(lookup_obj, root_sha, path): DCNL 'Look up an object in a Git tree. DCNL :param lookup_obj: Callback for retrieving object by SHA1 DCNL :param root_sha: SHA1 of the root tree DCNL :param path: Path to lookup DCNL :return: A tuple of (mode, SHA) of the resulting path.'
def _collect_filetree_revs(obj_store, tree_sha, kset): DCNL 'Collect SHA1s of files and directories for specified tree. DCNL :param obj_store: Object store to get objects by SHA from DCNL :param tree_sha: tree reference to walk DCNL :param kset: set to fill with references to files and directories'
def _split_commits_and_tags(obj_store, lst, ignore_unknown=False): DCNL 'Split object id list into three lists with commit, tag, and other SHAs. DCNL Commits referenced by tags are included into commits DCNL list as well. Only SHA1s known in this repository will get DCNL through, and unless ignore_unknown argument is True, KeyError DCNL is thrown for SHA1 missing in the repository DCNL :param obj_store: Object store to get objects by SHA1 from DCNL :param lst: Collection of commit and tag SHAs DCNL :param ignore_unknown: True to skip SHA1 missing in the repository DCNL silently. DCNL :return: A tuple of (commits, tags, others) SHA1s'
def ensure_dir_exists(dirname): DCNL 'Ensure a directory exists, creating if necessary.'
def _fancy_rename(oldname, newname): DCNL 'Rename file with temporary backup file to rollback if rename fails'
def GitFile(filename, mode='rb', bufsize=(-1)): DCNL 'Create a file object that obeys the git file locking protocol. DCNL :return: a builtin file object or a _GitFile object DCNL :note: See _GitFile for a description of the file locking protocol. DCNL Only read-only and write-only (binary) modes are supported; r+, w+, and a DCNL are not.  To read and write from the same file, you can take advantage of DCNL the fact that opening a file for write does not actually open the file you DCNL request.'
def _topo_reorder(entries, get_parents=(lambda commit: commit.parents)): DCNL 'Reorder an iterable of entries topologically. DCNL This works best assuming the entries are already in almost-topological DCNL order, e.g. in commit time order. DCNL :param entries: An iterable of WalkEntry objects. DCNL :param get_parents: Optional function for getting the parents of a commit. DCNL :return: iterator over WalkEntry objects from entries in FIFO order, except DCNL where a parent would be yielded before any of its children.'
def open_repo(path_or_repo): DCNL 'Open an argument that can be a repository or a path for a repository.'
@contextmanager DCNL def _noop_context_manager(obj): DCNL 'Context manager that has the same api as closing but does nothing.'
def open_repo_closing(path_or_repo): DCNL 'Open an argument that can be a repository or a path for a repository. DCNL returns a context manager that will close the repo on exit if the argument DCNL is a path, else does nothing if the argument is a repo.'
def archive(repo, committish=None, outstream=default_bytes_out_stream, errstream=default_bytes_err_stream): DCNL 'Create an archive. DCNL :param repo: Path of repository for which to generate an archive. DCNL :param committish: Commit SHA1 or ref to use DCNL :param outstream: Output stream (defaults to stdout) DCNL :param errstream: Error stream (defaults to stderr)'
def update_server_info(repo='.'): DCNL 'Update server info files for a repository. DCNL :param repo: path to the repository'
def symbolic_ref(repo, ref_name, force=False): DCNL 'Set git symbolic ref into HEAD. DCNL :param repo: path to the repository DCNL :param ref_name: short name of the new ref DCNL :param force: force settings without checking if it exists in refs/heads'
def commit(repo='.', message=None, author=None, committer=None): DCNL 'Create a new commit. DCNL :param repo: Path to repository DCNL :param message: Optional commit message DCNL :param author: Optional author name and email DCNL :param committer: Optional committer name and email DCNL :return: SHA1 of the new commit'
def commit_tree(repo, tree, message=None, author=None, committer=None): DCNL 'Create a new commit object. DCNL :param repo: Path to repository DCNL :param tree: An existing tree object DCNL :param author: Optional author name and email DCNL :param committer: Optional committer name and email'
def init(path='.', bare=False): DCNL 'Create a new git repository. DCNL :param path: Path to repository. DCNL :param bare: Whether to create a bare repository. DCNL :return: A Repo instance'
def clone(source, target=None, bare=False, checkout=None, errstream=default_bytes_err_stream, outstream=None, origin='origin'): DCNL 'Clone a local or remote git repository. DCNL :param source: Path or URL for source repository DCNL :param target: Path to target repository (optional) DCNL :param bare: Whether or not to create a bare repository DCNL :param checkout: Whether or not to check-out HEAD after cloning DCNL :param errstream: Optional stream to write progress to DCNL :param outstream: Optional stream to write progress to (deprecated) DCNL :return: The new repository'
def add(repo='.', paths=None): DCNL 'Add files to the staging area. DCNL :param repo: Repository for the files DCNL :param paths: Paths to add.  No value passed stages all modified files.'
def rm(repo='.', paths=None): DCNL 'Remove files from the staging area. DCNL :param repo: Repository for the files DCNL :param paths: Paths to remove'
def print_commit(commit, decode, outstream=sys.stdout): DCNL 'Write a human-readable commit log entry. DCNL :param commit: A `Commit` object DCNL :param outstream: A stream file to write to'
def print_tag(tag, decode, outstream=sys.stdout): DCNL 'Write a human-readable tag. DCNL :param tag: A `Tag` object DCNL :param decode: Function for decoding bytes to unicode string DCNL :param outstream: A stream to write to'
def show_blob(repo, blob, decode, outstream=sys.stdout): DCNL 'Write a blob to a stream. DCNL :param repo: A `Repo` object DCNL :param blob: A `Blob` object DCNL :param decode: Function for decoding bytes to unicode string DCNL :param outstream: A stream file to write to'
def show_commit(repo, commit, decode, outstream=sys.stdout): DCNL 'Show a commit to a stream. DCNL :param repo: A `Repo` object DCNL :param commit: A `Commit` object DCNL :param decode: Function for decoding bytes to unicode string DCNL :param outstream: Stream to write to'
def show_tree(repo, tree, decode, outstream=sys.stdout): DCNL 'Print a tree to a stream. DCNL :param repo: A `Repo` object DCNL :param tree: A `Tree` object DCNL :param decode: Function for decoding bytes to unicode string DCNL :param outstream: Stream to write to'
def show_tag(repo, tag, decode, outstream=sys.stdout): DCNL 'Print a tag to a stream. DCNL :param repo: A `Repo` object DCNL :param tag: A `Tag` object DCNL :param decode: Function for decoding bytes to unicode string DCNL :param outstream: Stream to write to'
def print_name_status(changes): DCNL 'Print a simple status summary, listing changed files.'
def log(repo='.', paths=None, outstream=sys.stdout, max_entries=None, reverse=False, name_status=False): DCNL 'Write commit logs. DCNL :param repo: Path to repository DCNL :param paths: Optional set of specific paths to print entries for DCNL :param outstream: Stream to write log output to DCNL :param reverse: Reverse order in which entries are printed DCNL :param name_status: Print name status DCNL :param max_entries: Optional maximum number of entries to display'
def show(repo='.', objects=None, outstream=sys.stdout, default_encoding=DEFAULT_ENCODING): DCNL 'Print the changes in a commit. DCNL :param repo: Path to repository DCNL :param objects: Objects to show (defaults to [HEAD]) DCNL :param outstream: Stream to write to DCNL :param default_encoding: Default encoding to use if none is set in the commit'
def diff_tree(repo, old_tree, new_tree, outstream=sys.stdout): DCNL 'Compares the content and mode of blobs found via two tree objects. DCNL :param repo: Path to repository DCNL :param old_tree: Id of old tree DCNL :param new_tree: Id of new tree DCNL :param outstream: Stream to write to'
def rev_list(repo, commits, outstream=sys.stdout): DCNL 'Lists commit objects in reverse chronological order. DCNL :param repo: Path to repository DCNL :param commits: Commits over which to iterate DCNL :param outstream: Stream to write to'
def tag_create(repo, tag, author=None, message=None, annotated=False, objectish='HEAD', tag_time=None, tag_timezone=None): DCNL 'Creates a tag in git via dulwich calls: DCNL :param repo: Path to repository DCNL :param tag: tag string DCNL :param author: tag author (optional, if annotated is set) DCNL :param message: tag message (optional) DCNL :param annotated: whether to create an annotated tag DCNL :param objectish: object the tag should point at, defaults to HEAD DCNL :param tag_time: Optional time for annotated tag DCNL :param tag_timezone: Optional timezone for annotated tag'
def tag_list(repo, outstream=sys.stdout): DCNL 'List all tags. DCNL :param repo: Path to repository DCNL :param outstream: Stream to write tags to'
def tag_delete(repo, name): DCNL 'Remove a tag. DCNL :param repo: Path to repository DCNL :param name: Name of tag to remove'
def reset(repo, mode, committish='HEAD'): DCNL 'Reset current HEAD to the specified state. DCNL :param repo: Path to repository DCNL :param mode: Mode ("hard", "soft", "mixed")'
def push(repo, remote_location, refspecs=None, outstream=default_bytes_out_stream, errstream=default_bytes_err_stream): DCNL 'Remote push with dulwich via dulwich.client DCNL :param repo: Path to repository DCNL :param remote_location: Location of the remote DCNL :param refspecs: relative path to the refs to push to remote DCNL :param outstream: A stream file to write output DCNL :param errstream: A stream file to write errors'
def pull(repo, remote_location, refspecs=None, outstream=default_bytes_out_stream, errstream=default_bytes_err_stream): DCNL 'Pull from remote via dulwich.client DCNL :param repo: Path to repository DCNL :param remote_location: Location of the remote DCNL :param refspec: refspecs to fetch DCNL :param outstream: A stream file to write to output DCNL :param errstream: A stream file to write to errors'
def status(repo='.'): DCNL 'Returns staged, unstaged, and untracked changes relative to the HEAD. DCNL :param repo: Path to repository or repository object DCNL :return: GitStatus tuple, DCNL staged -    list of staged paths (diff index/HEAD) DCNL unstaged -  list of unstaged paths (diff index/working-tree) DCNL untracked - list of untracked, un-ignored & non-.git paths'
def get_tree_changes(repo): DCNL 'Return add/delete/modify changes to tree by comparing index to HEAD. DCNL :param repo: repo path or object DCNL :return: dict with lists for each type of change'
def daemon(path='.', address=None, port=None): DCNL 'Run a daemon serving Git requests over TCP/IP. DCNL :param path: Path to the directory to serve. DCNL :param address: Optional address to listen on (defaults to ::) DCNL :param port: Optional port to listen on (defaults to TCP_GIT_PORT)'
def web_daemon(path='.', address=None, port=None): DCNL 'Run a daemon serving Git requests over HTTP. DCNL :param path: Path to the directory to serve DCNL :param address: Optional address to listen on (defaults to ::) DCNL :param port: Optional port to listen on (defaults to 80)'
def upload_pack(path='.', inf=None, outf=None): DCNL 'Upload a pack file after negotiating its contents using smart protocol. DCNL :param path: Path to the repository DCNL :param inf: Input stream to communicate with client DCNL :param outf: Output stream to communicate with client'
def receive_pack(path='.', inf=None, outf=None): DCNL 'Receive a pack file after negotiating its contents using smart protocol. DCNL :param path: Path to the repository DCNL :param inf: Input stream to communicate with client DCNL :param outf: Output stream to communicate with client'
def branch_delete(repo, name): DCNL 'Delete a branch. DCNL :param repo: Path to the repository DCNL :param name: Name of the branch'
def branch_create(repo, name, objectish=None, force=False): DCNL 'Create a branch. DCNL :param repo: Path to the repository DCNL :param name: Name of the new branch DCNL :param objectish: Target object to point new branch at (defaults to HEAD) DCNL :param force: Force creation of branch, even if it already exists'
def branch_list(repo): DCNL 'List all branches. DCNL :param repo: Path to the repository'
def fetch(repo, remote_location, outstream=sys.stdout, errstream=default_bytes_err_stream): DCNL 'Fetch objects from a remote server. DCNL :param repo: Path to the repository DCNL :param remote_location: String identifying a remote server DCNL :param outstream: Output stream (defaults to stdout) DCNL :param errstream: Error stream (defaults to stderr) DCNL :return: Dictionary with refs on the remote'
def ls_remote(remote): DCNL 'List the refs in a remote. DCNL :param remote: Remote repository location DCNL :return: Dictionary with remote refs'
def repack(repo): DCNL 'Repack loose files in a repository. DCNL Currently this only packs loose objects. DCNL :param repo: Path to the repository'
def pack_objects(repo, object_ids, packf, idxf, delta_window_size=None): DCNL 'Pack objects into a file. DCNL :param repo: Path to the repository DCNL :param object_ids: List of object ids to write DCNL :param packf: File-like object to write to DCNL :param idxf: File-like object to write to (can be None)'
def ls_tree(repo, tree_ish=None, outstream=sys.stdout, recursive=False, name_only=False): DCNL 'List contents of a tree. DCNL :param repo: Path to the repository DCNL :param tree_ish: Tree id to list DCNL :param outstream: Output stream (defaults to stdout) DCNL :param recursive: Whether to recursively list files DCNL :param name_only: Only print item name'
def _fileno_can_read(fileno): DCNL 'Check if a file descriptor is readable.'
def find_git_command(): DCNL 'Find command to run for system Git (usually C Git).'
def get_transport_and_path_from_url(url, config=None, **kwargs): DCNL 'Obtain a git client from a URL. DCNL :param url: URL to open (a unicode string) DCNL :param config: Optional config object DCNL :param thin_packs: Whether or not thin packs should be retrieved DCNL :param report_activity: Optional callback for reporting transport DCNL activity. DCNL :return: Tuple with client instance and relative path.'
def get_transport_and_path(location, **kwargs): DCNL 'Obtain a git client from a URL. DCNL :param location: URL or path (a string) DCNL :param config: Optional config object DCNL :param thin_packs: Whether or not thin packs should be retrieved DCNL :param report_activity: Optional callback for reporting transport DCNL activity. DCNL :return: Tuple with client instance and relative path.'
def parse_graftpoints(graftpoints): DCNL 'Convert a list of graftpoints into a dict DCNL :param graftpoints: Iterator of graftpoint lines DCNL Each line is formatted as: DCNL <commit sha1> <parent sha1> [<parent sha1>]* DCNL Resulting dictionary is: DCNL <commit sha1>: [<parent sha1>*] DCNL https://git.wiki.kernel.org/index.php/GraftPoint'
def serialize_graftpoints(graftpoints): DCNL 'Convert a dictionary of grafts into string DCNL The graft dictionary is: DCNL <commit sha1>: [<parent sha1>*] DCNL Each line is formatted as: DCNL <commit sha1> <parent sha1> [<parent sha1>]* DCNL https://git.wiki.kernel.org/index.php/GraftPoint'
def read_gitfile(f): DCNL 'Read a ``.git`` file. DCNL The first line of the file should start with "gitdir: " DCNL :param f: File-like object to read from DCNL :return: A path'
def check_ref_format(refname): DCNL 'Check if a refname is correctly formatted. DCNL Implements all the same rules as git-check-ref-format[1]. DCNL [1] http://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html DCNL :param refname: The refname to check DCNL :return: True if refname is valid, False otherwise'
def _split_ref_line(line): DCNL 'Split a single ref line into a tuple of SHA1 and name.'
def read_packed_refs(f): DCNL 'Read a packed refs file. DCNL :param f: file-like object to read from DCNL :return: Iterator over tuples with SHA1s and ref names.'
def read_packed_refs_with_peeled(f): DCNL 'Read a packed refs file including peeled refs. DCNL Assumes the "# pack-refs with: peeled" line was already read. Yields tuples DCNL with ref names, SHA1s, and peeled SHA1s (or None). DCNL :param f: file-like object to read from, seek\'ed to the second line'
def write_packed_refs(f, packed_refs, peeled_refs=None): DCNL 'Write a packed refs file. DCNL :param f: empty file-like object to write to DCNL :param packed_refs: dict of refname to sha of packed refs to write DCNL :param peeled_refs: dict of refname to peeled value of sha'
def write_info_refs(refs, store): DCNL 'Generate info refs.'
def pkt_line(data): DCNL 'Wrap data in a pkt-line. DCNL :param data: The data to wrap, as a str or None. DCNL :return: The data prefixed with its length in pkt-line format; if data was DCNL None, returns the flush-pkt (\'0000\').'
def extract_capabilities(text): DCNL 'Extract a capabilities list from a string, if present. DCNL :param text: String to extract from DCNL :return: Tuple with text with capabilities removed and list of capabilities'
def extract_want_line_capabilities(text): DCNL 'Extract a capabilities list from a want line, if present. DCNL Note that want lines have capabilities separated from the rest of the line DCNL by a space instead of a null byte. Thus want lines have the form: DCNL want obj-id cap1 cap2 ... DCNL :param text: Want line to extract from DCNL :return: Tuple with text with capabilities removed and list of capabilities'
def ack_type(capabilities): DCNL 'Extract the ack type from a capabilities list.'
def _split_proto_line(line, allowed): DCNL 'Split a line read from the wire. DCNL :param line: The line read from the wire. DCNL :param allowed: An iterable of command names that should be allowed. DCNL Command names not listed below as possible return values will be DCNL ignored.  If None, any commands from the possible return values are DCNL allowed. DCNL :return: a tuple having one of the following forms: DCNL (\'want\', obj_id) DCNL (\'have\', obj_id) DCNL (\'done\', None) DCNL (None, None)  (for a flush-pkt) DCNL :raise UnexpectedCommandError: if the line cannot be parsed into one of the DCNL allowed return values.'
def _find_shallow(store, heads, depth): DCNL 'Find shallow commits according to a given depth. DCNL :param store: An ObjectStore for looking up objects. DCNL :param heads: Iterable of head SHAs to start walking from. DCNL :param depth: The depth of ancestors to include. A depth of one includes DCNL only the heads themselves. DCNL :return: A tuple of (shallow, not_shallow), sets of SHAs that should be DCNL considered shallow and unshallow according to the arguments. Note that DCNL these sets may overlap if a commit is reachable along multiple paths.'
def _all_wants_satisfied(store, haves, wants): DCNL 'Check whether all the current wants are satisfied by a set of haves. DCNL :param store: Object store to retrieve objects from DCNL :param haves: A set of commits we know the client has. DCNL :param wants: A set of commits the client wants DCNL :note: Wants are specified with set_wants rather than passed in since DCNL in the current interface they are determined outside this class.'
def main(argv=sys.argv): DCNL 'Entry point for starting a TCP git server.'
def serve_command(handler_cls, argv=sys.argv, backend=None, inf=sys.stdin, outf=sys.stdout): DCNL 'Serve a single command. DCNL This is mostly useful for the implementation of commands used by e.g. git+ssh. DCNL :param handler_cls: `Handler` class to use for the request DCNL :param argv: execv-style command-line arguments. Defaults to sys.argv. DCNL :param backend: `Backend` to use DCNL :param inf: File-like object to read from, defaults to standard input. DCNL :param outf: File-like object to write to, defaults to standard output. DCNL :return: Exit code for use with sys.exit. 0 on success, 1 on failure.'
def generate_info_refs(repo): DCNL 'Generate an info refs file.'
def generate_objects_info_packs(repo): DCNL 'Generate an index for for packs.'
def update_server_info(repo): DCNL 'Generate server info for dumb file access. DCNL This generates info/refs and objects/info/packs, DCNL similar to "git update-server-info".'
def get_recent_tags(projdir=PROJDIR): DCNL 'Get list of tags in order from newest to oldest and their datetimes. DCNL :param projdir: path to ``.git`` DCNL :returns: list of tags sorted by commit time from newest to oldest DCNL Each tag in the list contains the tag name, commit time, commit id, author DCNL and any tag meta. If a tag isn\'t annotated, then its tag meta is ``None``. DCNL Otherwise the tag meta is a tuple containing the tag time, tag id and tag DCNL name. Time is in UTC.'
def get_current_version(projdir=PROJDIR, pattern=PATTERN, logger=None): DCNL 'Return the most recent tag, using an options regular expression pattern. DCNL The default pattern will strip any characters preceding the first semantic DCNL version. *EG*: "Release-0.2.1-rc.1" will be come "0.2.1-rc.1". If no match DCNL is found, then the most recent tag is return without modification. DCNL :param projdir: path to ``.git`` DCNL :param pattern: regular expression pattern with group that matches version DCNL :param logger: a Python logging instance to capture exception DCNL :returns: tag matching first group in regular expression pattern'
def load_conf(path=None, file=None): DCNL 'Load configuration in global var CONF DCNL :param path: The path to the configuration file DCNL :param file: If provided read instead the file like object'
def swift_load_pack_index(scon, filename): DCNL 'Read a pack index file from Swift DCNL :param scon: a `SwiftConnector` instance DCNL :param filename: Path to the index file objectise DCNL :return: a `PackIndexer` instance'
def cmd_daemon(args): DCNL 'Entry point for starting a TCP git server.'
def default_logging_config(): DCNL 'Set up the default Dulwich loggers.'
def remove_null_handler(): DCNL 'Remove the null handler from the Dulwich loggers. DCNL If a caller wants to set up logging using something other than DCNL default_logging_config, calling this function first is a minor optimization DCNL to avoid the overhead of using the _NullHandler.'
def pathsplit(path): DCNL 'Split a /-delimited path into a directory part and a basename. DCNL :param path: The path to split. DCNL :return: Tuple with directory name and basename'
def pathjoin(*args): DCNL 'Join a /-delimited path.'
def read_cache_time(f): DCNL 'Read a cache time. DCNL :param f: File-like object to read from DCNL :return: Tuple with seconds and nanoseconds'
def write_cache_time(f, t): DCNL 'Write a cache time. DCNL :param f: File-like object to write to DCNL :param t: Time to write (as int, float or tuple with secs and nsecs)'
def read_cache_entry(f): DCNL 'Read an entry from a cache file. DCNL :param f: File-like object to read from DCNL :return: tuple with: device, inode, mode, uid, gid, size, sha, flags'
def write_cache_entry(f, entry): DCNL 'Write an index entry to a file. DCNL :param f: File object DCNL :param entry: Entry to write, tuple with: DCNL (name, ctime, mtime, dev, ino, mode, uid, gid, size, sha, flags)'
def read_index(f): DCNL 'Read an index file, yielding the individual entries.'
def read_index_dict(f): DCNL 'Read an index file and return it as a dictionary. DCNL :param f: File object to read from'
def write_index(f, entries): DCNL 'Write an index file. DCNL :param f: File-like object to write to DCNL :param entries: Iterable over the entries to write'
def write_index_dict(f, entries): DCNL 'Write an index file based on the contents of a dictionary.'
def cleanup_mode(mode): DCNL 'Cleanup a mode value. DCNL This will return a mode that can be stored in a tree object. DCNL :param mode: Mode to clean up.'
def commit_tree(object_store, blobs): DCNL 'Commit a new tree. DCNL :param object_store: Object store to add trees to DCNL :param blobs: Iterable over blob path, sha, mode entries DCNL :return: SHA1 of the created tree.'
def commit_index(object_store, index): DCNL 'Create a new tree from an index. DCNL :param object_store: Object store to save the tree in DCNL :param index: Index file DCNL :note: This function is deprecated, use index.commit() instead. DCNL :return: Root tree sha.'
def changes_from_tree(names, lookup_entry, object_store, tree, want_unchanged=False): DCNL 'Find the differences between the contents of a tree and DCNL a working copy. DCNL :param names: Iterable of names in the working copy DCNL :param lookup_entry: Function to lookup an entry in the working copy DCNL :param object_store: Object store to use for retrieving tree contents DCNL :param tree: SHA1 of the root tree, or None for an empty tree DCNL :param want_unchanged: Whether unchanged files should be reported DCNL :return: Iterator over tuples with (oldpath, newpath), (oldmode, newmode), DCNL (oldsha, newsha)'
def index_entry_from_stat(stat_val, hex_sha, flags, mode=None): DCNL 'Create a new index entry from a stat value. DCNL :param stat_val: POSIX stat_result instance DCNL :param hex_sha: Hex sha of the object DCNL :param flags: Index flags'
def build_file_from_blob(blob, mode, target_path, honor_filemode=True): DCNL 'Build a file or symlink on disk based on a Git object. DCNL :param obj: The git object DCNL :param mode: File mode DCNL :param target_path: Path to write to DCNL :param honor_filemode: An optional flag to honor core.filemode setting in DCNL config file, default is core.filemode=True, change executable bit DCNL :return: stat object for the file'
def validate_path(path, element_validator=validate_path_element_default): DCNL 'Default path validator that just checks for .git/.'
def build_index_from_tree(root_path, index_path, object_store, tree_id, honor_filemode=True, validate_path_element=validate_path_element_default): DCNL 'Generate and materialize index from a tree DCNL :param tree_id: Tree to materialize DCNL :param root_path: Target dir for materialized index files DCNL :param index_path: Target path for generated index DCNL :param object_store: Non-empty object store holding tree contents DCNL :param honor_filemode: An optional flag to honor core.filemode setting in DCNL config file, default is core.filemode=True, change executable bit DCNL :param validate_path_element: Function to validate path elements to check out; DCNL default just refuses .git and .. directories. DCNL :note:: existing index is wiped and contents are not merged DCNL in a working dir. Suitable only for fresh clones.'
def blob_from_path_and_stat(fs_path, st): DCNL 'Create a blob from a path and a stat object. DCNL :param fs_path: Full file system path to file DCNL :param st: A stat object DCNL :return: A `Blob` object'
def get_unstaged_changes(index, root_path): DCNL 'Walk through an index and check for differences against working tree. DCNL :param index: index to check DCNL :param root_path: path in which to find files DCNL :return: iterator over paths with unstaged changes'
def _tree_to_fs_path(root_path, tree_path): DCNL 'Convert a git tree path to a file system path. DCNL :param root_path: Root filesystem path DCNL :param tree_path: Git tree path as bytes DCNL :return: File system path.'
def _fs_to_tree_path(fs_path, fs_encoding=None): DCNL 'Convert a file system path to a git tree path. DCNL :param fs_path: File system path. DCNL :param fs_encoding: File system encoding DCNL :return:  Git tree path as bytes'
def take_msb_bytes(read, crc32=None): DCNL 'Read bytes marked with most significant bit. DCNL :param read: Read function'
def read_zlib_chunks(read_some, unpacked, include_comp=False, buffer_size=_ZLIB_BUFSIZE): DCNL 'Read zlib data from a buffer. DCNL This function requires that the buffer have additional data following the DCNL compressed data, which is guaranteed to be the case for git pack files. DCNL :param read_some: Read function that returns at least one byte, but may DCNL return less than the requested size. DCNL :param unpacked: An UnpackedObject to write result data to. If its crc32 DCNL attr is not None, the CRC32 of the compressed bytes will be computed DCNL using this starting CRC32. DCNL After this function, will have the following attrs set: DCNL * comp_chunks    (if include_comp is True) DCNL * decomp_chunks DCNL * decomp_len DCNL * crc32 DCNL :param include_comp: If True, include compressed data in the result. DCNL :param buffer_size: Size of the read buffer. DCNL :return: Leftover unused data from the decompression. DCNL :raise zlib.error: if a decompression error occurred.'
def iter_sha1(iter): DCNL 'Return the hexdigest of the SHA1 over a set of names. DCNL :param iter: Iterator over string objects DCNL :return: 40-byte hex sha1 digest'
def load_pack_index(path): DCNL 'Load an index file by path. DCNL :param filename: Path to the index file DCNL :return: A PackIndex loaded from the given path'
def load_pack_index_file(path, f): DCNL 'Load an index file from a file-like object. DCNL :param path: Path for the index file DCNL :param f: File-like object DCNL :return: A PackIndex loaded from the given file'
def bisect_find_sha(start, end, sha, unpack_name): DCNL 'Find a SHA in a data blob with sorted SHAs. DCNL :param start: Start index of range to search DCNL :param end: End index of range to search DCNL :param sha: Sha to find DCNL :param unpack_name: Callback to retrieve SHA by index DCNL :return: Index of the SHA, or None if it wasn\'t found'
def read_pack_header(read): DCNL 'Read the header of a pack file. DCNL :param read: Read function DCNL :return: Tuple of (pack version, number of objects). If no data is available DCNL to read, returns (None, None).'
def unpack_object(read_all, read_some=None, compute_crc32=False, include_comp=False, zlib_bufsize=_ZLIB_BUFSIZE): DCNL 'Unpack a Git object. DCNL :param read_all: Read function that blocks until the number of requested DCNL bytes are read. DCNL :param read_some: Read function that returns at least one byte, but may not DCNL return the number of bytes requested. DCNL :param compute_crc32: If True, compute the CRC32 of the compressed data. If DCNL False, the returned CRC32 will be None. DCNL :param include_comp: If True, include compressed data in the result. DCNL :param zlib_bufsize: An optional buffer size for zlib operations. DCNL :return: A tuple of (unpacked, unused), where unused is the unused data DCNL leftover from decompression, and unpacked in an UnpackedObject with DCNL the following attrs set: DCNL * obj_chunks     (for non-delta types) DCNL * pack_type_num DCNL * delta_base     (for delta types) DCNL * comp_chunks    (if include_comp is True) DCNL * decomp_chunks DCNL * decomp_len DCNL * crc32          (if compute_crc32 is True)'
def _compute_object_size(value): DCNL 'Compute the size of a unresolved object for use with LRUSizeCache.'
def obj_sha(type, chunks): DCNL 'Compute the SHA for a numeric type and object chunks.'
def compute_file_sha(f, start_ofs=0, end_ofs=0, buffer_size=(1 << 16)): DCNL 'Hash a portion of a file into a new SHA. DCNL :param f: A file-like object to read from that supports seek(). DCNL :param start_ofs: The offset in the file to start reading at. DCNL :param end_ofs: The offset in the file to end reading at, relative to the DCNL end of the file. DCNL :param buffer_size: A buffer size for reading. DCNL :return: A new SHA object updated with data read from the file.'
def pack_object_header(type_num, delta_base, size): DCNL 'Create a pack object header for the given object info. DCNL :param type_num: Numeric type of the object. DCNL :param delta_base: Delta base offset or ref, or None for whole objects. DCNL :param size: Uncompressed object size. DCNL :return: A header for a packed object.'
def write_pack_object(f, type, object, sha=None): DCNL 'Write pack object to a file. DCNL :param f: File to write to DCNL :param type: Numeric type of the object DCNL :param object: Object to write DCNL :return: Tuple with offset at which the object was written, and crc32'
def write_pack(filename, objects, deltify=None, delta_window_size=None): DCNL 'Write a new pack data file. DCNL :param filename: Path to the new pack file (without .pack extension) DCNL :param objects: Iterable of (object, path) tuples to write. DCNL Should provide __len__ DCNL :param window_size: Delta window size DCNL :param deltify: Whether to deltify pack objects DCNL :return: Tuple with checksum of pack file and index file'
def write_pack_header(f, num_objects): DCNL 'Write a pack header for the given number of objects.'
def deltify_pack_objects(objects, window_size=None): DCNL 'Generate deltas for pack objects. DCNL :param objects: An iterable of (object, path) tuples to deltify. DCNL :param window_size: Window size; None for default DCNL :return: Iterator over type_num, object id, delta_base, content DCNL delta_base is None for full text entries'
def write_pack_objects(f, objects, delta_window_size=None, deltify=False): DCNL 'Write a new pack data file. DCNL :param f: File to write to DCNL :param objects: Iterable of (object, path) tuples to write. DCNL Should provide __len__ DCNL :param window_size: Sliding window size for searching for deltas; DCNL Set to None for default window size. DCNL :param deltify: Whether to deltify objects DCNL :return: Dict mapping id -> (offset, crc32 checksum), pack checksum'
def write_pack_data(f, num_records, records): DCNL 'Write a new pack data file. DCNL :param f: File to write to DCNL :param num_records: Number of records DCNL :param records: Iterator over type_num, object_id, delta_base, raw DCNL :return: Dict mapping id -> (offset, crc32 checksum), pack checksum'
def write_pack_index_v1(f, entries, pack_checksum): DCNL 'Write a new pack index file. DCNL :param f: A file-like object to write to DCNL :param entries: List of tuples with object name (sha), offset_in_pack, DCNL and crc32_checksum. DCNL :param pack_checksum: Checksum of the pack file. DCNL :return: The SHA of the written index file'
def create_delta(base_buf, target_buf): DCNL 'Use python difflib to work out how to transform base_buf to target_buf. DCNL :param base_buf: Base buffer DCNL :param target_buf: Target buffer'
def apply_delta(src_buf, delta): DCNL 'Based on the similar function in git\'s patch-delta.c. DCNL :param src_buf: Source buffer DCNL :param delta: Delta instructions'
def write_pack_index_v2(f, entries, pack_checksum): DCNL 'Write a new pack index file. DCNL :param f: File-like object to write to DCNL :param entries: List of tuples with object name (sha), offset_in_pack, and DCNL crc32_checksum. DCNL :param pack_checksum: Checksum of the pack file. DCNL :return: The SHA of the index file written'
def url_prefix(mat): DCNL 'Extract the URL prefix from a regex match. DCNL :param mat: A regex match object. DCNL :returns: The URL prefix, defined as the text before the match in the DCNL original string. Normalized to start with one leading slash and end with DCNL zero.'
def get_repo(backend, mat): DCNL 'Get a Repo instance for the given backend and URL regex match.'
def send_file(req, f, content_type): DCNL 'Send a file-like object to the request output. DCNL :param req: The HTTPGitRequest object to send output to. DCNL :param f: An open file-like object to send; will be closed. DCNL :param content_type: The MIME type for the file. DCNL :return: Iterator over the contents of the file, as chunks.'
def make_wsgi_chain(*args, **kwargs): DCNL 'Factory function to create an instance of HTTPGitApplication, DCNL correctly wrapped with needed middleware.'
def main(argv=sys.argv): DCNL 'Entry point for starting an HTTP git server.'
def parse_object(repo, objectish): DCNL 'Parse a string referring to an object. DCNL :param repo: A `Repo` object DCNL :param objectish: A string referring to an object DCNL :return: A git object DCNL :raise KeyError: If the object can not be found'
def parse_ref(container, refspec): DCNL 'Parse a string referring to a reference. DCNL :param container: A RefsContainer object DCNL :param refspec: A string referring to a ref DCNL :return: A ref DCNL :raise KeyError: If the ref can not be found'
def parse_reftuple(lh_container, rh_container, refspec): DCNL 'Parse a reftuple spec. DCNL :param lh_container: A RefsContainer object DCNL :param hh_container: A RefsContainer object DCNL :param refspec: A string DCNL :return: A tuple with left and right ref DCNL :raise KeyError: If one of the refs can not be found'
def parse_reftuples(lh_container, rh_container, refspecs): DCNL 'Parse a list of reftuple specs to a list of reftuples. DCNL :param lh_container: A RefsContainer object DCNL :param hh_container: A RefsContainer object DCNL :param refspecs: A list of refspecs or a string DCNL :return: A list of refs DCNL :raise KeyError: If one of the refs can not be found'
def parse_refs(container, refspecs): DCNL 'Parse a list of refspecs to a list of refs. DCNL :param container: A RefsContainer object DCNL :param refspecs: A list of refspecs or a string DCNL :return: A list of refs DCNL :raise KeyError: If one of the refs can not be found'
def parse_commit_range(repo, committishs): DCNL 'Parse a string referring to a range of commits. DCNL :param repo: A `Repo` object DCNL :param committishs: A string referring to a range of commits. DCNL :return: An iterator over `Commit` objects DCNL :raise KeyError: When the reference commits can not be found DCNL :raise ValueError: If the range can not be parsed'
def parse_commit(repo, committish): DCNL 'Parse a string referring to a single commit. DCNL :param repo: A` Repo` object DCNL :param commitish: A string referring to a single commit. DCNL :return: A Commit object DCNL :raise KeyError: When the reference commits can not be found DCNL :raise ValueError: If the range can not be parsed'
def _merge_entries(path, tree1, tree2): DCNL 'Merge the entries of two trees. DCNL :param path: A path to prepend to all tree entry names. DCNL :param tree1: The first Tree object to iterate, or None. DCNL :param tree2: The second Tree object to iterate, or None. DCNL :return: A list of pairs of TreeEntry objects for each pair of entries in DCNL the trees. If an entry exists in one tree but not the other, the other DCNL entry will have all attributes set to None. If neither entry\'s path is DCNL None, they are guaranteed to match.'
def walk_trees(store, tree1_id, tree2_id, prune_identical=False): DCNL 'Recursively walk all the entries of two trees. DCNL Iteration is depth-first pre-order, as in e.g. os.walk. DCNL :param store: An ObjectStore for looking up objects. DCNL :param tree1_id: The SHA of the first Tree object to iterate, or None. DCNL :param tree2_id: The SHA of the second Tree object to iterate, or None. DCNL :param prune_identical: If True, identical subtrees will not be walked. DCNL :return: Iterator over Pairs of TreeEntry objects for each pair of entries DCNL in the trees and their subtrees recursively. If an entry exists in one DCNL tree but not the other, the other entry will have all attributes set DCNL to None. If neither entry\'s path is None, they are guaranteed to DCNL match.'
def tree_changes(store, tree1_id, tree2_id, want_unchanged=False, rename_detector=None): DCNL 'Find the differences between the contents of two trees. DCNL :param store: An ObjectStore for looking up objects. DCNL :param tree1_id: The SHA of the source tree. DCNL :param tree2_id: The SHA of the target tree. DCNL :param want_unchanged: If True, include TreeChanges for unmodified entries DCNL as well. DCNL :param rename_detector: RenameDetector object for detecting renames. DCNL :return: Iterator over TreeChange instances for each change between the DCNL source and target tree.'
def tree_changes_for_merge(store, parent_tree_ids, tree_id, rename_detector=None): DCNL 'Get the tree changes for a merge tree relative to all its parents. DCNL :param store: An ObjectStore for looking up objects. DCNL :param parent_tree_ids: An iterable of the SHAs of the parent trees. DCNL :param tree_id: The SHA of the merge tree. DCNL :param rename_detector: RenameDetector object for detecting renames. DCNL :return: Iterator over lists of TreeChange objects, one per conflicted path DCNL in the merge. DCNL Each list contains one element per parent, with the TreeChange for that DCNL path relative to that parent. An element may be None if it never DCNL existed in one parent and was deleted in two others. DCNL A path is only included in the output if it is a conflict, i.e. its SHA DCNL in the merge tree is not found in any of the parents, or in the case of DCNL deletes, if not all of the old SHAs match.'
def _count_blocks(obj): DCNL 'Count the blocks in an object. DCNL Splits the data into blocks either on lines or <=64-byte chunks of lines. DCNL :param obj: The object to count blocks for. DCNL :return: A dict of block hashcode -> total bytes occurring.'
def _common_bytes(blocks1, blocks2): DCNL 'Count the number of common bytes in two block count dicts. DCNL :param block1: The first dict of block hashcode -> total bytes. DCNL :param block2: The second dict of block hashcode -> total bytes. DCNL :return: The number of bytes in common between blocks1 and blocks2. This is DCNL only approximate due to possible hash collisions.'
def _similarity_score(obj1, obj2, block_cache=None): DCNL 'Compute a similarity score for two objects. DCNL :param obj1: The first object to score. DCNL :param obj2: The second object to score. DCNL :param block_cache: An optional dict of SHA to block counts to cache DCNL results between calls. DCNL :return: The similarity score between the two objects, defined as the DCNL number of bytes in common between the two objects divided by the DCNL maximum size, scaled to the range 0-100.'
def format_reflog_line(old_sha, new_sha, committer, timestamp, timezone, message): DCNL 'Generate a single reflog line. DCNL :param old_sha: Old Commit SHA DCNL :param new_sha: New Commit SHA DCNL :param committer: Committer name and e-mail DCNL :param timestamp: Timestamp DCNL :param timezone: Timezone DCNL :param message: Message'
def parse_reflog_line(line): DCNL 'Parse a reflog line. DCNL :param line: Line to parse DCNL :return: Tuple of (old_sha, new_sha, committer, timestamp, timezone, DCNL message)'
def read_reflog(f): DCNL 'Read reflog. DCNL :param f: File-like object DCNL :returns: Iterator over Entry objects'
def _split_commits_and_tags(obj_store, lst, ignore_unknown=False, pool=None): DCNL 'Split object id list into two list with commit SHA1s and tag SHA1s. DCNL Same implementation as object_store._split_commits_and_tags DCNL except we use gevent to parallelize object retrieval.'
def tar_stream(store, tree, mtime, format=''): DCNL 'Generate a tar stream for the contents of a Git tree. DCNL Returns a generator that lazily assembles a .tar.gz archive, yielding it in DCNL pieces (bytestrings). To obtain the complete .tar.gz binary file, simply DCNL concatenate these chunks. DCNL :param store: Object store to retrieve objects from DCNL :param tree: Tree object for the tree root DCNL :param mtime: UNIX timestamp that is assigned as the modification time for DCNL all files DCNL :param format: Optional compression format for tarball DCNL :return: Bytestrings'
def _walk_tree(store, tree, root=''): DCNL 'Recursively walk a dulwich Tree, yielding tuples of DCNL (absolute path, TreeEntry) along the way.'
def ignore_error(error): DCNL 'Check whether this error is safe to ignore.'
def git_version(git_path=_DEFAULT_GIT): DCNL 'Attempt to determine the version of git currently installed. DCNL :param git_path: Path to the git executable; defaults to the version in DCNL the system path. DCNL :return: A tuple of ints of the form (major, minor, point, sub-point), or DCNL None if no git installation was found.'
def require_git_version(required_version, git_path=_DEFAULT_GIT): DCNL 'Require git version >= version, or skip the calling test. DCNL :param required_version: A tuple of ints of the form (major, minor, point, DCNL sub-point); ommitted components default to 0. DCNL :param git_path: Path to the git executable; defaults to the version in DCNL the system path. DCNL :raise ValueError: if the required version tuple has too many parts. DCNL :raise SkipTest: if no suitable git version was found at the given path.'
def run_git(args, git_path=_DEFAULT_GIT, input=None, capture_stdout=False, **popen_kwargs): DCNL 'Run a git command. DCNL Input is piped from the input parameter and output is sent to the standard DCNL streams, unless capture_stdout is set. DCNL :param args: A list of args to the git command. DCNL :param git_path: Path to to the git executable. DCNL :param input: Input data to be sent to stdin. DCNL :param capture_stdout: Whether to capture and return stdout. DCNL :param popen_kwargs: Additional kwargs for subprocess.Popen; DCNL stdin/stdout args are ignored. DCNL :return: A tuple of (returncode, stdout contents). If capture_stdout is DCNL False, None will be returned as stdout contents. DCNL :raise OSError: if the git executable was not found.'
def run_git_or_fail(args, git_path=_DEFAULT_GIT, input=None, **popen_kwargs): DCNL 'Run a git command, capture stdout/stderr, and fail if git fails.'
def import_repo_to_dir(name): DCNL 'Import a repo from a fast-export file in a temporary directory. DCNL These are used rather than binary repos for compat tests because they are DCNL more compact and human-editable, and we already depend on git. DCNL :param name: The name of the repository export file, relative to DCNL dulwich/tests/data/repos. DCNL :returns: The path to the imported repository.'
def check_for_daemon(limit=10, delay=0.1, timeout=0.1, port=TCP_GIT_PORT): DCNL 'Check for a running TCP daemon. DCNL Defaults to checking 10 times with a delay of 0.1 sec between tries. DCNL :param limit: Number of attempts before deciding no daemon is running. DCNL :param delay: Delay between connection attempts. DCNL :param timeout: Socket timeout for connection attempts. DCNL :param port: Port on which we expect the daemon to appear. DCNL :returns: A boolean, true if a daemon is running on the specified port, DCNL false if not.'
def open_repo(name, temp_dir=None): DCNL 'Open a copy of a repo in a temporary directory. DCNL Use this function for accessing repos in dulwich/tests/data/repos to avoid DCNL accidentally or intentionally modifying those repos in place. Use DCNL tear_down_repo to delete any temp files created. DCNL :param name: The name of the repository, relative to DCNL dulwich/tests/data/repos DCNL :param temp_dir: temporary directory to initialize to. If not provided, a DCNL temporary directory will be created. DCNL :returns: An initialized Repo object that lives in a temporary directory.'
def tear_down_repo(repo): DCNL 'Tear down a test repository.'
def make_object(cls, **attrs): DCNL 'Make an object for testing and assign some members. DCNL This method creates a new subclass to allow arbitrary attribute DCNL reassignment, which is not otherwise possible with objects having __slots__. DCNL :param attrs: dict of attributes to set on the new object. DCNL :return: A newly initialized object of type cls.'
def make_commit(**attrs): DCNL 'Make a Commit object with a default set of members. DCNL :param attrs: dict of attributes to overwrite from the default values. DCNL :return: A newly initialized Commit object.'
def make_tag(target, **attrs): DCNL 'Make a Tag object with a default set of values. DCNL :param target: object to be tagged (Commit, Blob, Tree, etc) DCNL :param attrs: dict of attributes to overwrite from the default values. DCNL :return: A newly initialized Tag object.'
def functest_builder(method, func): DCNL 'Generate a test method that tests the given function.'
def ext_functest_builder(method, func): DCNL 'Generate a test method that tests the given extension function. DCNL This is intended to generate test methods that test both a pure-Python DCNL version and an extension version using common test code. The extension test DCNL will raise SkipTest if the extension is not found. DCNL Sample usage: DCNL class MyTest(TestCase); DCNL def _do_some_test(self, func_impl): DCNL self.assertEqual(\'foo\', func_impl()) DCNL test_foo = functest_builder(_do_some_test, foo_py) DCNL test_foo_extension = ext_functest_builder(_do_some_test, _foo_c) DCNL :param method: The method to run. It must must two parameters, self and the DCNL function implementation to test. DCNL :param func: The function implementation to pass to method.'
def build_pack(f, objects_spec, store=None): DCNL 'Write test pack data from a concise spec. DCNL :param f: A file-like object to write the pack to. DCNL :param objects_spec: A list of (type_num, obj). For non-delta types, obj DCNL is the string of that object\'s data. DCNL For delta types, obj is a tuple of (base, data), where: DCNL * base can be either an index in objects_spec of the base for that DCNL * delta; or for a ref delta, a SHA, in which case the resulting pack DCNL * will be thin and the base will be an external ref. DCNL * data is a string of the full, non-deltified data for that object. DCNL Note that offsets/refs and deltas are computed within this function. DCNL :param store: An optional ObjectStore for looking up external refs. DCNL :return: A list of tuples in the order specified by objects_spec: DCNL (offset, type num, data, sha, CRC32)'
def build_commit_graph(object_store, commit_spec, trees=None, attrs=None): DCNL 'Build a commit graph from a concise specification. DCNL Sample usage: DCNL >>> c1, c2, c3 = build_commit_graph(store, [[1], [2, 1], [3, 1, 2]]) DCNL >>> store[store[c3].parents[0]] == c1 DCNL True DCNL >>> store[store[c3].parents[1]] == c2 DCNL True DCNL If not otherwise specified, commits will refer to the empty tree and have DCNL commit times increasing in the same order as the commit spec. DCNL :param object_store: An ObjectStore to commit objects to. DCNL :param commit_spec: An iterable of iterables of ints defining the commit DCNL graph. Each entry defines one commit, and entries must be in topological DCNL order. The first element of each entry is a commit number, and the DCNL remaining elements are its parents. The commit numbers are only DCNL meaningful for the call to make_commits; since real commit objects are DCNL created, they will get created with real, opaque SHAs. DCNL :param trees: An optional dict of commit number -> tree spec for building DCNL trees for commits. The tree spec is an iterable of (path, blob, mode) or DCNL (path, blob) entries; if mode is omitted, it defaults to the normal file DCNL mode (0100644). DCNL :param attrs: A dict of commit number -> (dict of attribute -> value) for DCNL assigning additional values to the commits. DCNL :return: The list of commit objects created. DCNL :raise ValueError: If an undefined commit identifier is listed as a parent.'
def setup_warning_catcher(): DCNL 'Wrap warnings.showwarning with code that records warnings.'
def _escape_value(value): DCNL 'Escape a value.'
def parse_submodules(config): DCNL 'Parse a gitmodules GitConfig file, returning submodules. DCNL :param config: A `ConfigFile` DCNL :return: list of tuples (submodule path, url, name), DCNL where name is quoted part of the section\'s name.'
def resource_path(relative_path): DCNL 'Get absolute path to resource, works for dev and for PyInstaller'
def combine(left, right): DCNL 'Stack images horizontally.'
def extract_docstring(filename, ignore_heading=False): DCNL 'Extract a module-level docstring, if any'
def generate_example_rst(app): DCNL 'Generate the list of examples, as well as the contents of DCNL examples.'
def _thumbnail_div(subdir, full_dir, fname, snippet): DCNL 'Generates RST to place a thumbnail in a gallery'
def generate_dir_rst(directory, example_dir, root_dir, plot_gallery, seen_backrefs): DCNL 'Generate the rst file for an example directory.'
def make_thumbnail(in_fname, out_fname, width, height): DCNL 'Make a thumbnail with the same aspect ratio centered in an DCNL image with a given width and height'
def get_short_module_name(module_name, obj_name): DCNL 'Get the shortest possible module name'
def identify_names(code): DCNL 'Builds a codeobj summary by identifying and resovles used names DCNL >>> code = \'\'\' DCNL ... from a.b import c DCNL ... import d as e DCNL ... print(c) DCNL ... e.HelloWorld().f.g DCNL >>> for name, o in sorted(identify_names(code).items()): DCNL ...     print(name, o[\'name\'], o[\'module\'], o[\'module_short\']) DCNL c c a.b a.b DCNL e.HelloWorld HelloWorld d d'
def generate_file_rst(fname, target_dir, src_dir, root_dir, plot_gallery): DCNL 'Generate the rst file for a given example. DCNL Returns the set of sklearn functions/classes imported in the example.'
def approx_fprime(x, f, eps=None, *args): DCNL 'Central difference approximation of the gradient of a scalar function.'
def check_grad(layer, x0, seed=1, eps=None, rtol=None, atol=None): DCNL 'Numerical gradient checking of layer bprop.'
def check_grad(loss, x0, y0, seed=1, eps=None, rtol=None, atol=None): DCNL 'Numerical gradient checking of loss functions.'
def img_tile(imgs, aspect_ratio=1.0, tile_shape=None, border=1, border_color=0): DCNL 'Tile images in a grid. DCNL If tile_shape is provided only as many images as specified in tile_shape DCNL will be included in the output.'
def approx_fprime(x, f, eps=None, *args): DCNL 'Central difference approximation of the gradient of a scalar function.'
def seek_end_of_dict(module_data, start_line, start_col, next_node_line, next_node_col): DCNL 'Look for the end of a dict in a set of lines DCNL We know the starting position of the dict and we know the start of the DCNL next code node but in between there may be multiple newlines and comments. DCNL There may also be multiple python statements on the same line (separated DCNL by semicolons) DCNL Examples:: DCNL ANSIBLE_METADATA = {[..]} DCNL DOCUMENTATION = [..] DCNL ANSIBLE_METADATA = {[..]} # Optional comments with confusing junk => {} DCNL # Optional comments {} DCNL DOCUMENTATION = [..] DCNL ANSIBLE_METADATA = { DCNL # Optional comments {} DCNL DOCUMENTATION = [..] DCNL ANSIBLE_METADATA = {[..]} ; DOCUMENTATION = [..] DCNL ANSIBLE_METADATA = {}EOF'
def seek_end_of_string(module_data, start_line, start_col, next_node_line, next_node_col): DCNL 'This is much trickier than finding the end of a dict.  A dict has only one DCNL ending character, "}".  Strings have four potential ending characters.  We DCNL have to parse the beginning of the string to determine what the ending DCNL character will be. DCNL Examples: DCNL ANSIBLE_METADATA = \'\'\'[..]\'\'\' # Optional comment with confusing chars \'\'\' DCNL # Optional comment with confusing chars \'\'\' DCNL DOCUMENTATION = [..] DCNL ANSIBLE_METADATA = \'\'\' DCNL DOCUMENTATIONS = [..] DCNL ANSIBLE_METADATA = \'\'\'[..]\'\'\' ; DOCUMENTATION = [..] DCNL SHORT_NAME = ANSIBLE_METADATA = \'\'\'[..]\'\'\' ; DOCUMENTATION = [..] DCNL String marker variants: DCNL Each of these come in u, r, and b variants: DCNL * u\'[..]\' DCNL * b\'[..]\' DCNL * r\'[..]\' DCNL * ur\'[..]\' DCNL * ru\'[..]\' DCNL * br\'[..]\' DCNL * b\'[..]\' DCNL * rb\'[..]\''
def extract_metadata(module_data): DCNL 'Extract the metadata from a module DCNL :arg module_data: Byte string containing a module\'s code DCNL :returns: a tuple of metadata (a dict), line the metadata starts on, DCNL column the metadata starts on, line the metadata ends on, column the DCNL metadata ends on, and the names the metadata is assigned to.  One of DCNL the names the metadata is assigned to will be ANSIBLE_METADATA If no DCNL metadata is found, the tuple will be (None, -1, -1, -1, -1, None)'
def find_documentation(module_data): DCNL 'Find the DOCUMENTATION metadata for a module file'
def remove_metadata(module_data, start_line, start_col, end_line, end_col): DCNL 'Remove a section of a module file'
def insert_metadata(module_data, new_metadata, insertion_line, targets=('ANSIBLE_METADATA',)): DCNL 'Insert a new set of metadata at a specified line'
def parse_assigned_metadata_initial(csvfile): DCNL 'Fields: DCNL :0: Module name DCNL :1: Core (x if so) DCNL :2: Extras (x if so) DCNL :3: Category DCNL :4: Supported/SLA DCNL :5: Committer DCNL :6: Stable DCNL :7: Deprecated DCNL :8: Notes DCNL :9: Team Notes DCNL :10: Notes 2 DCNL :11: final supported_by field'
def parse_assigned_metadata(csvfile): DCNL 'Fields: DCNL :0: Module name DCNL :1: supported_by  string.  One of the valid support fields DCNL core, community, unmaintained, committer DCNL :2: stableinterface DCNL :3: preview DCNL :4: deprecated DCNL :5: removed DCNL :6: tested DCNL https://github.com/ansible/proposals/issues/30'
def metadata_summary(plugins, version=None): DCNL 'Compile information about the metadata status for a list of modules DCNL :arg plugins: List of plugins to look for.  Each entry in the list is DCNL a tuple of (module name, full path to module) DCNL :kwarg version: If given, make sure the modules have this version of DCNL metadata or higher. DCNL :returns: A tuple consisting of a list of modules with no metadata at the DCNL required version and a list of files that have metadata at the DCNL required version.'
def add_from_csv(csv_file, version=None, overwrite=False): DCNL 'Implement the subcommand to add metadata from a csv file'
def add_default(version=None, overwrite=False): DCNL 'Implement the subcommand to add default metadata to modules DCNL Add the default metadata to any plugin which lacks it. DCNL :kwarg version: If given, the metadata must be at least this version. DCNL Otherwise, treat the module as not having existing metadata. DCNL :kwarg overwrite: If True, overwrite any existing metadata.  Otherwise, DCNL do not modify files which have metadata at an appropriate version'
def report(version=None): DCNL 'Implement the report subcommand DCNL Print out all the modules that have metadata and all the ones that do not. DCNL :kwarg version: If given, the metadata must be at least this version. DCNL Otherwise return it as not having metadata'
def rst_ify(text): DCNL 'convert symbols like I(this is in italics) to valid restructured text'
def html_ify(text): DCNL 'convert symbols like I(this is in italics) to valid HTML'
def rst_fmt(text, fmt): DCNL 'helper for Jinja2 to do format strings'
def rst_xline(width, char='='): DCNL 'return a restructured text line of a given length'
def write_data(text, options, outputname, module): DCNL 'dumps module output to a file or the screen, as requested'
def list_modules(module_dir, depth=0): DCNL 'returns a hash of categories, each category being a hash of module names to file paths'
def generate_parser(): DCNL 'generate an optparse parser'
def validate_options(options): DCNL 'validate option parser options'
def main(): DCNL 'Main entry point.'
def injector(): DCNL ':rtype: list[str], dict[str, str]'
def runner(): DCNL ':rtype: list[str], dict[str, str]'
def cover(): DCNL ':rtype: list[str], dict[str, str]'
def coverage_command(self_dir, version): DCNL ':type self_dir: str DCNL :type version: str DCNL :rtype: list[str], dict[str, str]'
def find_executable(executable): DCNL ':type executable: str DCNL :rtype: str'
def command_coverage_combine(args): DCNL 'Patch paths in coverage files and merge into a single file. DCNL :type args: CoverageConfig'
def command_coverage_report(args): DCNL ':type args: CoverageConfig'
def command_coverage_html(args): DCNL ':type args: CoverageConfig'
def command_coverage_xml(args): DCNL ':type args: CoverageConfig'
def command_coverage_erase(args): DCNL ':type args: CoverageConfig'
def initialize_coverage(args): DCNL ':type args: CoverageConfig DCNL :rtype: coverage'
def ansible_environment(args): DCNL ':type args: CommonConfig DCNL :rtype: dict[str, str]'
def find_target_completion(target_func, prefix): DCNL ':type target_func: () -> collections.Iterable[CompletionTarget] DCNL :type prefix: unicode DCNL :rtype: list[str]'
def walk_completion_targets(targets, prefix, short=False): DCNL ':type targets: collections.Iterable[CompletionTarget] DCNL :type prefix: str DCNL :type short: bool DCNL :rtype: tuple[str]'
def walk_internal_targets(targets, includes=None, excludes=None, requires=None): DCNL ':type targets: collections.Iterable[T <= CompletionTarget] DCNL :type includes: list[str] DCNL :type excludes: list[str] DCNL :type requires: list[str] DCNL :rtype: tuple[T <= CompletionTarget]'
def walk_external_targets(targets, includes=None, excludes=None, requires=None): DCNL ':type targets: collections.Iterable[CompletionTarget] DCNL :type includes: list[str] DCNL :type excludes: list[str] DCNL :type requires: list[str] DCNL :rtype: tuple[CompletionTarget], tuple[CompletionTarget]'
def filter_targets(targets, patterns, include=True, directories=True, errors=True): DCNL ':type targets: collections.Iterable[CompletionTarget] DCNL :type patterns: list[str] DCNL :type include: bool DCNL :type directories: bool DCNL :type errors: bool DCNL :rtype: collections.Iterable[CompletionTarget]'
def walk_module_targets(): DCNL ':rtype: collections.Iterable[TestTarget]'
def walk_units_targets(): DCNL ':rtype: collections.Iterable[TestTarget]'
def walk_compile_targets(): DCNL ':rtype: collections.Iterable[TestTarget]'
def walk_sanity_targets(): DCNL ':rtype: collections.Iterable[TestTarget]'
def walk_posix_integration_targets(): DCNL ':rtype: collections.Iterable[IntegrationTarget]'
def walk_network_integration_targets(): DCNL ':rtype: collections.Iterable[IntegrationTarget]'
def walk_windows_integration_targets(): DCNL ':rtype: collections.Iterable[IntegrationTarget]'
def walk_integration_targets(): DCNL ':rtype: collections.Iterable[IntegrationTarget]'
def load_integration_prefixes(): DCNL ':rtype: dict[str, str]'
def walk_test_targets(path=None, module_path=None, extensions=None, prefix=None): DCNL ':type path: str | None DCNL :type module_path: str | None DCNL :type extensions: tuple[str] | None DCNL :type prefix: str | None DCNL :rtype: collections.Iterable[TestTarget]'
def categorize_changes(paths, verbose_command=None): DCNL ':type paths: list[str] DCNL :type verbose_command: str DCNL :rtype paths: dict[str, list[str]]'
def all_tests(): DCNL ':rtype: dict[str, str]'
def ignore(item): DCNL ':type item: tarfile.TarInfo DCNL :rtype: tarfile.TarInfo | None'
def create_tarfile(dst_path, src_path, tar_filter): DCNL ':type dst_path: str DCNL :type src_path: str DCNL :type tar_filter: (tarfile.TarInfo) -> tarfile.TarInfo | None'
def create_shell_command(command): DCNL ':type command: list[str] DCNL :rtype: list[str]'
def install_command_requirements(args): DCNL ':type args: EnvironmentConfig'
def generate_egg_info(args): DCNL ':type args: EnvironmentConfig'
def generate_pip_install(command): DCNL ':type command: str DCNL :return: list[str] | None'
def command_shell(args): DCNL ':type args: ShellConfig'
def command_posix_integration(args): DCNL ':type args: PosixIntegrationConfig'
def command_network_integration(args): DCNL ':type args: NetworkIntegrationConfig'
def network_run(args, platform, version): DCNL ':type args: NetworkIntegrationConfig DCNL :type platform: str DCNL :type version: str DCNL :rtype: AnsibleCoreCI'
def network_inventory(remotes): DCNL ':type remotes: list[AnsibleCoreCI] DCNL :rtype: str'
def command_windows_integration(args): DCNL ':type args: WindowsIntegrationConfig'
def windows_run(args, version): DCNL ':type args: WindowsIntegrationConfig DCNL :type version: str DCNL :rtype: AnsibleCoreCI'
def windows_inventory(remotes): DCNL ':type remotes: list[AnsibleCoreCI] DCNL :rtype: str'
def command_integration_filter(args, targets): DCNL ':type args: IntegrationConfig DCNL :type targets: collections.Iterable[IntegrationTarget] DCNL :rtype: tuple[IntegrationTarget]'
def command_integration_filtered(args, targets): DCNL ':type args: IntegrationConfig DCNL :type targets: tuple[IntegrationTarget]'
def integration_environment(args): DCNL ':type args: IntegrationConfig DCNL :rtype: dict[str, str]'
def command_integration_script(args, target): DCNL ':type args: IntegrationConfig DCNL :type target: IntegrationTarget'
def command_integration_role(args, target, start_at_task): DCNL ':type args: IntegrationConfig DCNL :type target: IntegrationTarget DCNL :type start_at_task: str'
def command_units(args): DCNL ':type args: UnitsConfig'
def command_compile(args): DCNL ':type args: CompileConfig'
def command_sanity(args): DCNL ':type args: SanityConfig'
def command_sanity_code_smell(args, _): DCNL ':type args: SanityConfig DCNL :type _: SanityTargets'
def command_sanity_validate_modules(args, targets): DCNL ':type args: SanityConfig DCNL :type targets: SanityTargets'
def command_sanity_shellcheck(args, targets): DCNL ':type args: SanityConfig DCNL :type targets: SanityTargets'
def command_sanity_yamllint(args, targets): DCNL ':type args: SanityConfig DCNL :type targets: SanityTargets'
def command_sanity_ansible_doc(args, targets, python_version): DCNL ':type args: SanityConfig DCNL :type targets: SanityTargets DCNL :type python_version: str'
def intercept_command(args, cmd, capture=False, env=None, data=None, cwd=None, python_version=None): DCNL ':type args: TestConfig DCNL :type cmd: collections.Iterable[str] DCNL :type capture: bool DCNL :type env: dict[str, str] | None DCNL :type data: str | None DCNL :type cwd: str | None DCNL :type python_version: str | None DCNL :rtype: str | None, str | None'
def get_coverage_path(args): DCNL ':type args: TestConfig DCNL :rtype: str'
def cleanup_coverage_dir(): DCNL 'Copy over coverage data from temporary directory and purge temporary directory.'
def get_changes_filter(args): DCNL ':type args: TestConfig DCNL :rtype: list[str]'
def detect_changes(args): DCNL ':type args: TestConfig DCNL :rtype: list[str] | None'
def detect_changes_shippable(args): DCNL 'Initialize change detection on Shippable. DCNL :type args: CommonConfig DCNL :rtype: list[str]'
def detect_changes_local(args): DCNL ':type args: TestConfig DCNL :rtype: list[str]'
def get_integration_filter(args, targets): DCNL ':type args: IntegrationConfig DCNL :type targets: tuple[IntegrationTarget] DCNL :rtype: list[str]'
def get_integration_local_filter(args, targets): DCNL ':type args: IntegrationConfig DCNL :type targets: tuple[IntegrationTarget] DCNL :rtype: list[str]'
def get_integration_docker_filter(args, targets): DCNL ':type args: IntegrationConfig DCNL :type targets: tuple[IntegrationTarget] DCNL :rtype: list[str]'
def get_integration_remote_filter(args, targets): DCNL ':type args: IntegrationConfig DCNL :type targets: tuple[IntegrationTarget] DCNL :rtype: list[str]'
def delegate(args, exclude, require): DCNL ':type args: EnvironmentConfig DCNL :type exclude: list[str] DCNL :type require: list[str]'
def delegate_tox(args, exclude, require): DCNL ':type args: EnvironmentConfig DCNL :type exclude: list[str] DCNL :type require: list[str]'
def delegate_docker(args, exclude, require): DCNL ':type args: EnvironmentConfig DCNL :type exclude: list[str] DCNL :type require: list[str]'
def docker_pull(args, image): DCNL ':type args: EnvironmentConfig DCNL :type image: str'
def docker_put(args, container_id, src, dst): DCNL ':type args: EnvironmentConfig DCNL :type container_id: str DCNL :type src: str DCNL :type dst: str'
def docker_get(args, container_id, src, dst): DCNL ':type args: EnvironmentConfig DCNL :type container_id: str DCNL :type src: str DCNL :type dst: str'
def docker_run(args, image, options): DCNL ':type args: EnvironmentConfig DCNL :type image: str DCNL :type options: list[str] | None DCNL :rtype: str | None, str | None'
def docker_rm(args, container_id): DCNL ':type args: EnvironmentConfig DCNL :type container_id: str'
def docker_exec(args, container_id, cmd, options=None, capture=False, stdin=None, stdout=None): DCNL ':type args: EnvironmentConfig DCNL :type container_id: str DCNL :type cmd: list[str] DCNL :type options: list[str] | None DCNL :type capture: bool DCNL :type stdin: file | None DCNL :type stdout: file | None DCNL :rtype: str | None, str | None'
def docker_command(args, cmd, capture=False, stdin=None, stdout=None): DCNL ':type args: EnvironmentConfig DCNL :type cmd: list[str] DCNL :type capture: bool DCNL :type stdin: file | None DCNL :type stdout: file | None DCNL :rtype: str | None, str | None'
def docker_environment(): DCNL ':rtype: dict[str, str]'
def delegate_remote(args, exclude, require): DCNL ':type args: EnvironmentConfig DCNL :type exclude: list[str] DCNL :type require: list[str]'
def generate_command(args, path, options, exclude, require): DCNL ':type args: EnvironmentConfig DCNL :type path: str DCNL :type options: dict[str, int] DCNL :type exclude: list[str] DCNL :type require: list[str] DCNL :return: list[str]'
def filter_options(args, argv, options, exclude, require): DCNL ':type args: EnvironmentConfig DCNL :type argv: list[str] DCNL :type options: dict[str, int] DCNL :type exclude: list[str] DCNL :type require: list[str] DCNL :rtype: collections.Iterable[str]'
def is_shippable(): DCNL ':rtype: bool'
def remove_file(path): DCNL ':type path: str'
def find_executable(executable, cwd=None, path=None, required=True): DCNL ':type executable: str DCNL :type cwd: str DCNL :type path: str DCNL :type required: bool | str DCNL :rtype: str | None'
def run_command(args, cmd, capture=False, env=None, data=None, cwd=None, always=False, stdin=None, stdout=None): DCNL ':type args: CommonConfig DCNL :type cmd: collections.Iterable[str] DCNL :type capture: bool DCNL :type env: dict[str, str] | None DCNL :type data: str | None DCNL :type cwd: str | None DCNL :type always: bool DCNL :type stdin: file | None DCNL :type stdout: file | None DCNL :rtype: str | None, str | None'
def raw_command(cmd, capture=False, env=None, data=None, cwd=None, explain=False, stdin=None, stdout=None): DCNL ':type cmd: collections.Iterable[str] DCNL :type capture: bool DCNL :type env: dict[str, str] | None DCNL :type data: str | None DCNL :type cwd: str | None DCNL :type explain: bool DCNL :type stdin: file | None DCNL :type stdout: file | None DCNL :rtype: str | None, str | None'
def common_environment(): DCNL 'Common environment used for executing all programs.'
def pass_vars(required=None, optional=None): DCNL ':type required: collections.Iterable[str] DCNL :type optional: collections.Iterable[str] DCNL :rtype: dict[str, str]'
def deepest_path(path_a, path_b): DCNL 'Return the deepest of two paths, or None if the paths are unrelated. DCNL :type path_a: str DCNL :type path_b: str DCNL :return: str | None'
def remove_tree(path): DCNL ':type path: str'
def make_dirs(path): DCNL ':type path: str'
def docker_qualify_image(name): DCNL ':type name: str DCNL :rtype: str'
def main(): DCNL 'Main program function.'
def parse_args(): DCNL 'Parse command line arguments.'
def add_changes(parser, argparse): DCNL ':type parser: argparse.ArgumentParser DCNL :type argparse: argparse'
def add_environments(parser, tox_version=False, tox_only=False): DCNL ':type parser: argparse.ArgumentParser DCNL :type tox_version: bool DCNL :type tox_only: bool'
def add_extra_docker_options(parser, integration=True): DCNL ':type parser: argparse.ArgumentParser DCNL :type integration: bool'
def complete_target(prefix, parsed_args, **_): DCNL ':type prefix: unicode DCNL :type parsed_args: any DCNL :rtype: list[str]'
def complete_remote(prefix, parsed_args, **_): DCNL ':type prefix: unicode DCNL :type parsed_args: any DCNL :rtype: list[str]'
def complete_docker(prefix, parsed_args, **_): DCNL ':type prefix: unicode DCNL :type parsed_args: any DCNL :rtype: list[str]'
def complete_windows(prefix, parsed_args, **_): DCNL ':type prefix: unicode DCNL :type parsed_args: any DCNL :rtype: list[str]'
def complete_network_platform(prefix, parsed_args, **_): DCNL ':type prefix: unicode DCNL :type parsed_args: any DCNL :rtype: list[str]'
def _check_to_text(self, in_string, encoding, expected): DCNL 'test happy path of decoding to text'
def _check_to_bytes(self, in_string, encoding, expected): DCNL 'test happy path of encoding to bytes'
def _check_to_native(self, in_string, encoding, py2_expected, py3_expected): DCNL 'test happy path of encoding to native strings'
def test_distribution_version(): DCNL 'tests the distribution parsing code of the Facts class DCNL testsets have DCNL * a name (for output/debugging only) DCNL * input files that are faked DCNL * those should be complete and also include "irrelevant" files that might be mistaken as coming from other distributions DCNL * all files that are not listed here are assumed to not exist at all DCNL * the output of pythons platform.dist() DCNL * results for the ansible variables distribution* and os_family'
def _test_one_distribution(facts, module, testcase): DCNL 'run the test on one distribution testcase DCNL * prepare some mock functions to get the testdata in DCNL * run Facts() DCNL * compare with the expected output'
def params_from_doc(func): DCNL 'This function extracts the docstring from the specified function, DCNL parses it as a YAML document, and returns parameters for the os_server DCNL module.'
def mock_unfrackpath_noop(path): DCNL 'Do not expand the path'
def add_method(func, *combined_args): DCNL 'Add a test case via a class decorator. DCNL nose uses generators for this but doesn\'t work with unittest.TestCase DCNL subclasses.  So we have to write our own. DCNL The first argument to this decorator is a test function.  All subsequent DCNL arguments are the arguments to create each generated test function with in DCNL the following format: DCNL Each set of arguments is a two-tuple.  The first element is an iterable of DCNL positional arguments.  the second is a dict representing the kwargs.'
@contextmanager DCNL def swap_stdin_and_argv(stdin_data='', argv_data=tuple()): DCNL 'context manager that temporarily masks the test runner\'s values for stdin and argv'
@contextmanager DCNL def swap_stdout(): DCNL 'context manager that temporarily replaces stdout for tests that need to verify output'
def delete_rax(args): DCNL 'Function for deleting CloudServers'
def delete_rax_clb(args): DCNL 'Function for deleting Cloud Load Balancers'
def delete_rax_keypair(args): DCNL 'Function for deleting Rackspace Key pairs'
def delete_rax_network(args): DCNL 'Function for deleting Cloud Networks'
def delete_rax_cbs(args): DCNL 'Function for deleting Cloud Networks'
def delete_rax_cdb(args): DCNL 'Function for deleting Cloud Databases'
def delete_rax_scaling_group(args): DCNL 'Function for deleting Autoscale Groups'
def find_globals(g, tree): DCNL 'Uses AST to find globals in an ast tree'
def get_fallback(config, value, section='openstack'): DCNL 'Get value from config object and return the value DCNL or false'
def push(data, key, element): DCNL 'Assist in items to a dictionary of lists'
def to_safe(word): DCNL 'Converts \'bad\' characters in a string to underscores so they can DCNL be used as Ansible groups'
def get_ips(server, access_ip=True): DCNL 'Returns a list of the server\'s IPs, or the preferred DCNL access IP'
def get_metadata(server): DCNL 'Returns dictionary of all host metadata'
def is_cache_stale(cache_file, cache_expiration_time, refresh=False): DCNL 'Determines if cache file has expired, or if it is still valid'
def save_cache(data, config): DCNL 'saves item to cache'
def get_cache(cache_item, config): DCNL 'returns cached item'
def cache_available(config): DCNL 'checks if we have a \'fresh\' cache available for item requested'
def get_inventory(enterprise, config): DCNL 'Reads the inventory from cache or Abiquo api'
def spacewalk_report(name): DCNL 'Yield a dictionary form of each CSV output produced by the specified DCNL spacewalk-report'
def main(): DCNL 'Set up argument handling and callback routing'
def get_a_ssh_config(box_name): DCNL 'Gives back a map of all the machine\'s ssh configurations'
def parse_args(): DCNL 'Create command line parser for oVirt dynamic inventory script.'
def create_connection(): DCNL 'Create a connection to oVirt engine API.'
def get_dict_of_struct(connection, vm): DCNL 'Transform SDK Vm Struct type to Python dictionary.'
def get_data(connection, vm_name=None): DCNL 'Obtain data of `vm_name` if specified, otherwise obtain data of all vms.'
def initialize(): DCNL 'This function initializes the FreeIPA/IPA API. This function requires DCNL no arguments. A kerberos key must be present in the users keyring in DCNL order for this to work.'
def list_groups(api): DCNL 'This function prints a list of all host groups. This function requires DCNL one argument, the FreeIPA/IPA API object.'
def parse_args(): DCNL 'This function parses the arguments that were passed in via the command line. DCNL This function expects no arguments.'
def print_host(host): DCNL 'This function is really a stub, it could return variables to be used in DCNL a playbook. However, at this point there are no variables stored in DCNL FreeIPA/IPA. DCNL This function expects one string, this hostname to lookup variables for.'
def build_dict(): DCNL 'Returns a dictionary keyed to the defined LXC groups. All DCNL containers, including the ones not in any group, are included in the DCNL "all" group.'
def main(argv): DCNL 'Returns a JSON dictionary as expected by Ansible'
def get_html_theme_path(): DCNL 'Return list of HTML theme paths.'
def _escape_backslashes(data, jinja_env): DCNL 'Double backslashes within jinja2 expressions DCNL A user may enter something like this in a playbook:: DCNL debug: DCNL msg: "Test Case 1\3; {{ test1_name | regex_replace(\'^(.*)_name$\', \'\1\')}}" DCNL The string inside of the {{ gets interpreted multiple times First by yaml. DCNL Then by python.  And finally by jinja2 as part of it\'s variable.  Because DCNL it is processed by both python and jinja2, the backslash escaped DCNL characters get unescaped twice.  This means that we\'d normally have to use DCNL four backslashes to escape that.  This is painful for playbook authors as DCNL they have to remember different rules for inside vs outside of a jinja2 DCNL expression (The backslashes outside of the "{{ }}" only get processed by DCNL yaml and python.  So they only need to be escaped once).  The following DCNL code fixes this by automatically performing the extra quoting of DCNL backslashes inside of a jinja2 expression.'
def _count_newlines_from_end(in_str): DCNL 'Counts the number of newlines at the end of a string. This is used during DCNL the jinja2 templating to ensure the count matches the input, since some newlines DCNL may be thrown away during the templating.'
def safe_eval(expr, locals={}, include_exceptions=False): DCNL 'This is intended for allowing things like: DCNL with_items: a_list_variable DCNL Where Jinja2 would return a string but we do not want to allow it to DCNL call functions (outside of Jinja2, where the env is constrained). DCNL Based on: DCNL http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe'
def _get_shebang(interpreter, task_vars, args=tuple()): DCNL 'Note not stellar API: DCNL Returns None instead of always returning a shebang line.  Doing it this DCNL way allows the caller to decide to use the shebang it read from the DCNL file rather than trust that we reformatted what they already have DCNL correctly.'
def recursive_finder(name, data, py_module_names, py_module_cache, zf): DCNL 'Using ModuleDepFinder, make sure we have all of the module_utils files that DCNL the module its module_utils files needs.'
def _find_snippet_imports(module_name, module_data, module_path, module_args, task_vars, module_compression): DCNL 'Given the source of the module, convert it to a Jinja2 template to insert DCNL module code and return whether it\'s a new or old style module.'
def modify_module(module_name, module_path, module_args, task_vars=dict(), module_compression='ZIP_STORED'): DCNL 'Used to insert chunks of code into modules before transfer rather than DCNL doing regular python imports.  This allows for more efficient transfer in DCNL a non-bootstrapping scenario by not moving extra files over the wire and DCNL also takes care of embedding arguments in the transferred modules. DCNL This version is done in such a way that local imports can still be DCNL used in the module code, so IDEs don\'t have to be aware of what is going on. DCNL Example: DCNL from ansible.module_utils.basic import * DCNL ... will result in the insertion of basic.py into the module DCNL from the module_utils/ directory in the source tree. DCNL For powershell, there\'s equivalent conventions like this: DCNL # POWERSHELL_COMMON DCNL which results in the inclusion of the common code from powershell.ps1'
def g_connect(method): DCNL 'wrapper to lazily initialize connection info to galaxy'
def detect_range(line=None): DCNL 'A helper function that checks a given host line to see if it contains DCNL a range pattern described in the docstring above. DCNL Returnes True if the given line contains a pattern, else False.'
def expand_hostname_range(line=None): DCNL 'A helper function that expands a given line that contains a pattern DCNL specified in top docstring, and returns a list that consists of the DCNL expanded version. DCNL The \'[\' and \']\' characters are used to maintain the pseudo-code DCNL appearance. They are replaced in this function with \'|\' to ease DCNL string splitting. DCNL References: http://ansible.github.com/patterns.html#hosts-and-groups'
def _add_doc(func, doc): DCNL 'Add documentation to a function.'
def _import_module(name): DCNL 'Import module, returning the module after the last dot.'
def add_move(move): DCNL 'Add an item to six.moves.'
def remove_move(name): DCNL 'Remove item from six.moves.'
def with_metaclass(meta, *bases): DCNL 'Create a base class with a metaclass.'
def add_metaclass(metaclass): DCNL 'Class decorator for creating a class with a metaclass.'
def python_2_unicode_compatible(klass): DCNL 'A decorator that defines __unicode__ and __str__ methods under Python 2. DCNL Under Python 3 it does nothing. DCNL To support Python 2 and 3 with a single code base, define a __str__ method DCNL returning text and apply this decorator to the class.'
def gcdns_connect(module, provider=None): DCNL 'Return a GCP connection for Google Cloud DNS.'
def unexpected_error_msg(error): DCNL 'Create an error string based on passed in error.'
def uldap(): DCNL 'Return a configured univention uldap object'
def ldap_search(filter, base=None, attr=None): DCNL 'Replaces uldaps search and uses a generator. DCNL !! Arguments are not the same.'
def module_by_name(module_name_): DCNL 'Returns an initialized UMC module, identified by the given name. DCNL The module is a module specification according to the udm commandline. DCNL Example values are: DCNL * users/user DCNL * shares/share DCNL * groups/group DCNL If the module does not exist, a KeyError is raised. DCNL The modules are cached, so they won\'t be re-initialized DCNL in subsequent calls.'
def get_umc_admin_objects(): DCNL 'Convenience accessor for getting univention.admin.objects. DCNL This implements delayed importing, so the univention.* modules DCNL are not loaded until this function is called.'
def umc_module_for_add(module, container_dn, superordinate=None): DCNL 'Returns an UMC module object prepared for creating a new entry. DCNL The module is a module specification according to the udm commandline. DCNL Example values are: DCNL * users/user DCNL * shares/share DCNL * groups/group DCNL The container_dn MUST be the dn of the container (not of the object to DCNL be created itself!).'
def umc_module_for_edit(module, object_dn, superordinate=None): DCNL 'Returns an UMC module object prepared for editing an existing entry. DCNL The module is a module specification according to the udm commandline. DCNL Example values are: DCNL * users/user DCNL * shares/share DCNL * groups/group DCNL The object_dn MUST be the dn of the object itself, not the container!'
def create_containers_and_parents(container_dn): DCNL 'Create a container and if needed the parents containers'
def find_vm_by_id(content, vm_id, vm_id_type='vm_name', datacenter=None, cluster=None): DCNL 'UUID is unique to a VM, every other id returns the first match.'
def fetch_file_from_guest(content, vm, username, password, src, dest): DCNL 'Use VMWare\'s filemanager api to fetch a file over http'
def push_file_to_guest(content, vm, username, password, src, dest, overwrite=True): DCNL 'Use VMWare\'s filemanager api to fetch a file over http'
def to_bytes(obj, encoding='utf-8', errors=None, nonstring='simplerepr'): DCNL 'Make sure that a string is a byte string DCNL :arg obj: An object to make sure is a byte string.  In most cases this DCNL will be either a text string or a byte string.  However, with DCNL ``nonstring=\'simplerepr\'``, this can be used as a traceback-free DCNL version of ``str(obj)``. DCNL :kwarg encoding: The encoding to use to transform from a text string to DCNL a byte string.  Defaults to using \'utf-8\'. DCNL :kwarg errors: The error handler to use if the text string is not DCNL encodable using the specified encoding.  Any valid `codecs error DCNL handler <https://docs.python.org/2/library/codecs.html#codec-base-classes>`_ DCNL may be specified. There are two additional error strategies DCNL specifically aimed at helping people to port code: DCNL :surrogate_or_strict: Will use surrogateescape if it is a valid DCNL handler, otherwise it will use strict DCNL :surrogate_or_replace: Will use surrogateescape if it is a valid DCNL handler, otherwise it will use replace. DCNL Because surrogateescape was added in Python3 this usually means that DCNL Python3 will use surrogateescape and Python2 will use the fallback DCNL error handler. Note that the code checks for surrogateescape when the DCNL module is imported.  If you have a backport of surrogateescape for DCNL python2, be sure to register the error handler prior to importing this DCNL module. DCNL The default is `surrogate_or_replace` DCNL :kwarg nonstring: The strategy to use if a nonstring is specified in DCNL ``obj``.  Default is \'simplerepr\'.  Valid values are: DCNL :simplerepr: The default.  This takes the ``str`` of the object and DCNL then returns the bytes version of that string. DCNL :empty: Return an empty byte string DCNL :passthru: Return the object passed in DCNL :strict: Raise a :exc:`TypeError` DCNL :returns: Typically this returns a byte string.  If a nonstring object is DCNL passed in this may be a different type depending on the strategy DCNL specified by nonstring.  This will never return a text string. DCNL .. note:: If passed a byte string, this function does not check that the DCNL string is valid in the specified encoding.  If it\'s important that the DCNL byte string is in the specified encoding do:: DCNL encoded_string = to_bytes(to_text(input_string, \'latin-1\'), \'utf-8\')'
def to_text(obj, encoding='utf-8', errors=None, nonstring='simplerepr'): DCNL 'Make sure that a string is a text string DCNL :arg obj: An object to make sure is a text string.  In most cases this DCNL will be either a text string or a byte string.  However, with DCNL ``nonstring=\'simplerepr\'``, this can be used as a traceback-free DCNL version of ``str(obj)``. DCNL :kwarg encoding: The encoding to use to transform from a byte string to DCNL a text string.  Defaults to using \'utf-8\'. DCNL :kwarg errors: The error handler to use if the byte string is not DCNL decodable using the specified encoding.  Any valid `codecs error DCNL handler <https://docs.python.org/2/library/codecs.html#codec-base-classes>`_ DCNL may be specified. On Python3 this defaults to \'surrogateescape\'.  On DCNL Python2, this defaults to \'replace\'. DCNL :kwarg nonstring: The strategy to use if a nonstring is specified in DCNL ``obj``.  Default is \'simplerepr\'.  Valid values are: DCNL :simplerepr: The default.  This takes the ``str`` of the object and DCNL then returns the text version of that string. DCNL :empty: Return an empty text string DCNL :passthru: Return the object passed in DCNL :strict: Raise a :exc:`TypeError` DCNL :returns: Typically this returns a text string.  If a nonstring object is DCNL passed in this may be a different type depending on the strategy DCNL specified by nonstring.  This will never return a byte string.'
def _get_quote_state(token, quote_char): DCNL 'the goal of this block is to determine if the quoted string DCNL is unterminated in which case it needs to be put back together'
def _count_jinja2_blocks(token, cur_depth, open_token, close_token): DCNL 'this function counts the number of opening/closing blocks for a DCNL given opening/closing type and adjusts the current depth for that DCNL block based on the difference'
def split_args(args): DCNL 'Splits args on whitespace, but intelligently reassembles DCNL those that may have been split over a jinja2 block or quotes. DCNL When used in a remote module, we won\'t ever have to be concerned about DCNL jinja2 blocks, however this function is/will be used in the DCNL core portions as well before the args are templated. DCNL example input: a=b c="foo bar" DCNL example output: [\'a=b\', \'c="foo bar"\'] DCNL Basically this is a variation shlex that has some more intelligence for DCNL how Ansible needs to use it.'
def unquote(data): DCNL 'removes first and last quotes from a string, if the string starts and ends with the same quotes'
def _botocore_exception_maybe(): DCNL 'Allow for boto3 not being installed when using these utils by wrapping DCNL botocore.exceptions instead of assigning from it directly.'
def get_ec2_creds(module): DCNL 'for compatibility mode with old modules that don\'t/can\'t yet DCNL use ec2_connect method'
def boto_fix_security_token_in_profile(conn, profile_name): DCNL 'monkey patch for boto issue boto/boto#2100'
def ec2_connect(module): DCNL 'Return an ec2 connection'
def paging(pause=0, marker_property='marker'): DCNL 'Adds paging to boto retrieval functions that support a \'marker\' DCNL this is configurable as not all boto functions seem to use the DCNL same name.'
def ansible_dict_to_boto3_filter_list(filters_dict): DCNL 'Convert an Ansible dict of filters to list of dicts that boto3 can use DCNL Args: DCNL filters_dict (dict): Dict of AWS filters. DCNL Basic Usage: DCNL >>> filters = {\'some-aws-id\', \'i-01234567\'} DCNL >>> ansible_dict_to_boto3_filter_list(filters) DCNL \'some-aws-id\': \'i-01234567\' DCNL Returns: DCNL List: List of AWS filters and their values DCNL \'Name\': \'some-aws-id\', DCNL \'Values\': [ DCNL \'i-01234567\','
def boto3_tag_list_to_ansible_dict(tags_list): DCNL 'Convert a boto3 list of resource tags to a flat dict of key:value pairs DCNL Args: DCNL tags_list (list): List of dicts representing AWS tags. DCNL Basic Usage: DCNL >>> tags_list = [{\'Key\': \'MyTagKey\', \'Value\': \'MyTagValue\'}] DCNL >>> boto3_tag_list_to_ansible_dict(tags_list) DCNL \'Key\': \'MyTagKey\', DCNL \'Value\': \'MyTagValue\' DCNL Returns: DCNL Dict: Dict of key:value pairs representing AWS tags DCNL \'MyTagKey\': \'MyTagValue\','
def ansible_dict_to_boto3_tag_list(tags_dict): DCNL 'Convert a flat dict of key:value pairs representing AWS resource tags to a boto3 list of dicts DCNL Args: DCNL tags_dict (dict): Dict representing AWS resource tags. DCNL Basic Usage: DCNL >>> tags_dict = {\'MyTagKey\': \'MyTagValue\'} DCNL >>> ansible_dict_to_boto3_tag_list(tags_dict) DCNL \'MyTagKey\': \'MyTagValue\' DCNL Returns: DCNL List: List of dicts containing tag keys and values DCNL \'Key\': \'MyTagKey\', DCNL \'Value\': \'MyTagValue\''
def get_ec2_security_group_ids_from_names(sec_group_list, ec2_connection, vpc_id=None, boto3=True): DCNL 'Return list of security group IDs from security group names. Note that security group names are not unique DCNL across VPCs.  If a name exists across multiple VPCs and no VPC ID is supplied, all matching IDs will be returned. This DCNL will probably lead to a boto exception if you attempt to assign both IDs to a resource so ensure you wrap the call in DCNL a try block'
def sort_json_policy_dict(policy_dict): DCNL 'Sort any lists in an IAM JSON policy so that comparison of two policies with identical values but DCNL different orders will return true DCNL Args: DCNL policy_dict (dict): Dict representing IAM JSON policy. DCNL Basic Usage: DCNL >>> my_iam_policy = {\'Principle\': {\'AWS\':["31","7","14","101"]} DCNL >>> sort_json_policy_dict(my_iam_policy) DCNL Returns: DCNL Dict: Will return a copy of the policy as a Dict but any List will be sorted DCNL \'Principle\': { DCNL \'AWS\': [ \'7\', \'14\', \'31\', \'101\' ]'
def ismount(path): DCNL 'Test whether a path is a mount point DCNL clone of os.path.ismount (from cpython Lib/posixpath.py) DCNL fixed to solve https://github.com/ansible/ansible-modules-core/issues/2186 DCNL and workaround non-fixed http://bugs.python.org/issue2466 DCNL this should be rewritten as soon as python issue 2466 is fixed DCNL probably check for python version and use os.path.ismount if fixed DCNL to remove replace in this file ismount( -> os.path.ismount( and remove this DCNL function'
def rax_slugify(value): DCNL 'Prepend a key with rax_ and normalize the key name'
def rax_clb_node_to_dict(obj): DCNL 'Function to convert a CLB Node object to a dict'
def rax_to_dict(obj, obj_type='standard'): DCNL 'Generic function to convert a pyrax object to a dict DCNL obj_type values: DCNL standard DCNL clb DCNL server'
def rax_find_bootable_volume(module, rax_module, server, exit=True): DCNL 'Find a servers bootable volume'
def rax_find_image(module, rax_module, image, exit=True): DCNL 'Find a server image by ID or Name'
def rax_find_volume(module, rax_module, name): DCNL 'Find a Block storage volume by ID or name'
def rax_find_network(module, rax_module, network): DCNL 'Find a cloud network by ID or name'
def rax_find_server(module, rax_module, server): DCNL 'Find a Cloud Server by ID or name'
def rax_find_loadbalancer(module, rax_module, loadbalancer): DCNL 'Find a Cloud Load Balancer by ID or name'
def rax_argument_spec(): DCNL 'Return standard base dictionary used for the argument_spec DCNL argument in AnsibleModule'
def rax_required_together(): DCNL 'Return the default list used for the required_together argument to DCNL AnsibleModule'
def setup_rax_module(module, rax_module, region_required=True): DCNL 'Set up pyrax in a standard way for all modules'
def ce_unknown_host_cb(host, fingerprint): DCNL 'ce_unknown_host_cb'
def get_netconf(**kwargs): DCNL 'get_netconf'
def prepare_config(commands): DCNL 'prepare_config'
def prepare_commands(commands): DCNL 'prepare_commands'
def axapi_call(module, url, post=None): DCNL 'Returns a datastructure based on the result of the API call'
def axapi_call_v3(module, url, method=None, body=None, signature=None): DCNL 'Returns a datastructure based on the result of the API call'
def axapi_enabled_disabled(flag): DCNL 'The axapi uses 0/1 integer values for flags, rather than strings DCNL or booleans, so convert the given flag to a 0 or 1. For now, params DCNL are specified as strings only so thats what we check.'
def _filter_non_json_lines(data): DCNL 'Used to filter unrelated output around module JSON output, like messages from DCNL tcagetattr, or where dropbear spews MOTD on every single command (which is nuts). DCNL Filters leading lines before first line-starting occurrence of \'{\' or \'[\', and filter all DCNL trailing lines after matching close character (working from the bottom of output).'
def add_git_host_key(module, url, accept_hostkey=True, create_dir=True): DCNL 'idempotently add a git url hostkey'
def is_ssh_url(url): DCNL 'check if url is ssh'
def get_fqdn(repo_url): DCNL 'chop the hostname out of a url'
def add_host_key(module, fqdn, key_type='rsa', create_dir=False): DCNL 'use ssh-keyscan to add the hostkey'
def get_file_lines(path): DCNL 'get list of lines from file'
def api_wrapper(func): DCNL 'Catch API Errors Decorator'
@api_wrapper DCNL def get_system(module): DCNL 'Return System Object or Fail'
def infinibox_argument_spec(): DCNL 'Return standard base dictionary used for the argument_spec argument in AnsibleModule'
def infinibox_required_together(): DCNL 'Return the default list used for the required_together argument to AnsibleModule'
def check_libcloud_or_fail(): DCNL 'Checks if libcloud is installed and fails if not'
def get_credentials(module): DCNL 'Get user_id and key from module configuration, environment, or dotfile. DCNL Order of priority is module, environment, dotfile. DCNL To set in environment: DCNL export MCP_USER=\'myusername\' DCNL export MCP_PASSWORD=\'mypassword\' DCNL To set in dot file place a file at ~/.dimensiondata with DCNL the following contents: DCNL [dimensiondatacloud] DCNL MCP_USER: myusername DCNL MCP_PASSWORD: mypassword'
def get_dd_regions(): DCNL 'Get the list of available regions whose vendor is Dimension Data.'
def get_network_domain_by_name(driver, name, location): DCNL 'Get a network domain object by its name'
def get_network_domain(driver, locator, location): DCNL 'Get a network domain object by its name or id'
def get_vlan(driver, locator, location, network_domain): DCNL 'Get a VLAN object by its name or id'
def get_mcp_version(driver, location): DCNL 'Get a locations MCP version'
def is_uuid(u, version=4): DCNL 'Test if valid v4 UUID'
def expand_ip_block(block): DCNL 'Expand public IP block to show all addresses'
def get_public_ip_block(module, driver, network_domain, block_id=False, base_ip=False): DCNL 'Get public IP block details'
def list_nat_rules(module, driver, network_domain): DCNL 'Get list of NAT rules for domain'
def list_public_ip_blocks(module, driver, network_domain): DCNL 'Get list of public IP blocks for a domain'
def get_block_allocation(module, cp_driver, lb_driver, network_domain, block): DCNL 'Get public IP block allocation details. Shows all ips in block and if DCNL they are allocated. Example: DCNL {\'id\': \'eb8b16ca-3c91-45fb-b04b-5d7d387a9f4a\', DCNL \'addresses\': [{\'address\': \'162.2.100.100\', DCNL \'allocated\': True DCNL {\'address\': \'162.2.100.101\', DCNL \'allocated\': False'
def get_blocks_with_unallocated(module, cp_driver, lb_driver, network_domain): DCNL 'Gets ip blocks with one or more unallocated IPs. DCNL ex: DCNL {\'unallocated_count\': <total count of unallocated ips>, DCNL \'ip_blocks\': [<list of expanded blocks with details DCNL (see get_block_allocation())>], DCNL \'unallocated_addresses\': [<list of unallocated ip addresses>]'
def get_unallocated_public_ips(module, cp_driver, lb_driver, network_domain, reuse_free, count=0): DCNL 'Get and/or provision unallocated public IPs'
def is_ipv4_addr(ip): DCNL 'Simple way to check if IPv4 address'
def get_node_by_name_and_ip(module, lb_driver, name, ip): DCNL 'Nodes do not have unique names, we need to match name and IP to be DCNL sure we get the correct one'
def generic_urlparse(parts): DCNL 'Returns a dictionary of url parts as parsed by urlparse, DCNL but accounts for the fact that older versions of that DCNL library do not support named attributes (ie. .netloc)'
def RedirectHandlerFactory(follow_redirects=None, validate_certs=True): DCNL 'This is a class factory that closes over the value of DCNL ``follow_redirects`` so that the RedirectHandler class has access to DCNL that value without having to use globals, and potentially cause problems DCNL where ``open_url`` or ``fetch_url`` are used multiple times in a module.'
def build_ssl_validation_error(hostname, port, paths, exc=None): DCNL 'Inteligently build out the SSLValidationError based on what support DCNL you have installed'
def open_url(url, data=None, headers=None, method=None, use_proxy=True, force=False, last_mod_time=None, timeout=10, validate_certs=True, url_username=None, url_password=None, http_agent=None, force_basic_auth=False, follow_redirects='urllib2'): DCNL 'Sends a request via HTTP(S) or FTP using urllib2 (Python2) or urllib (Python3) DCNL Does not require the module environment'
def basic_auth_header(username, password): DCNL 'Takes a username and password and returns a byte string suitable for DCNL using as value of an Authorization header to do basic auth.'
def url_argument_spec(): DCNL 'Creates an argument spec that can be used with any module DCNL that will be requesting content via urllib/urllib2'
def fetch_url(module, url, data=None, headers=None, method=None, use_proxy=True, force=False, last_mod_time=None, timeout=10): DCNL 'Sends a request via HTTP(S) or FTP (needs the module as parameter) DCNL :arg module: The AnsibleModule (used to get username, password etc. (s.b.). DCNL :arg url:             The url to use. DCNL :kwarg data:          The data to be sent (in case of POST/PUT). DCNL :kwarg headers:       A dict with the request headers. DCNL :kwarg method:        "POST", "PUT", etc. DCNL :kwarg boolean use_proxy:     Default: True DCNL :kwarg boolean force: If True: Do not get a cached copy (Default: False) DCNL :kwarg last_mod_time: Default: None DCNL :kwarg int timeout:   Default: 10 DCNL :returns: A tuple of (**response**, **info**). Use ``response.body()`` to read the data. DCNL The **info** contains the \'status\' and other meta data. When a HttpError (status > 400) DCNL occurred then ``info[\'body\']`` contains the error response data:: DCNL Example:: DCNL data={...} DCNL resp, info = fetch_url("http://example.com", DCNL data=module.jsonify(data) DCNL header={Content-type\': \'application/json\'}, DCNL method="POST") DCNL status_code = info["status"] DCNL body = resp.read() DCNL if status_code >= 400 : DCNL body = info[\'body\']'
def get_platform(): DCNL 'what\'s the platform?  example: Linux is a platform.'
def get_distribution(): DCNL 'return the distribution name'
def get_distribution_version(): DCNL 'return the distribution version'
def get_all_subclasses(cls): DCNL 'used by modules like Hardware or Network fact classes to retrieve all subclasses of a given class. DCNL __subclasses__ return only direct sub classes. This one go down into the class tree.'
def load_platform_subclass(cls, *args, **kwargs): DCNL 'used by modules like User to have different implementations based on detected platform.  See User DCNL module for an example.'
def json_dict_unicode_to_bytes(d, encoding='utf-8', errors='surrogate_or_strict'): DCNL 'Recursively convert dict keys and values to byte str DCNL Specialized for json return because this only handles, lists, tuples, DCNL and dict container types (the containers that the json module returns)'
def json_dict_bytes_to_unicode(d, encoding='utf-8', errors='surrogate_or_strict'): DCNL 'Recursively convert dict keys and values to byte str DCNL Specialized for json return because this only handles, lists, tuples, DCNL and dict container types (the containers that the json module returns)'
def return_values(obj): DCNL 'Return native stringified values from datastructures. DCNL For use with removing sensitive values pre-jsonification.'
def remove_values(value, no_log_strings): DCNL 'Remove strings in no_log_strings from value.  If value is a container DCNL type, then remove a lot more'
def heuristic_log_sanitize(data, no_log_values=None): DCNL 'Remove strings that look like passwords from log messages'
def human_to_bytes(number, default_unit=None, isbits=False): DCNL 'Convert number in string format into bytes (ex: \'2K\' => 2048) or using unit argument DCNL ex: DCNL human_to_bytes(\'10M\') <=> human_to_bytes(10, \'M\')'
def is_executable(path): DCNL 'is the given path executable? DCNL Limitations: DCNL * Does not account for FSACLs. DCNL * Most times we really want to know "Can the current user execute this DCNL file"  This function does not tell us that, only if an execute bit is set.'
def _load_params(): DCNL 'read the modules parameters and store them globally. DCNL This function may be needed for certain very dynamic custom modules which DCNL want to process the parameters that are being handed the module.  Since DCNL this is so closely tied to the implementation of modules we cannot DCNL guarantee API stability for it (it may change between versions) however we DCNL will try not to break it gratuitously.  It is certainly more future-proof DCNL to call this function and consume its outputs than to implement the logic DCNL inside it as a copy in your own code.'
def env_fallback(*args, **kwargs): DCNL 'Load value from environment'
def _lenient_lowercase(lst): DCNL 'Lowercase elements of a list. DCNL If an element is not a string, pass it through untouched.'
def get_dict_of_struct(struct, connection=None, fetch_nested=False, attributes=None): DCNL 'Convert SDK Struct type into dictionary.'
def create_connection(auth): DCNL 'Create a connection to Python SDK, from task `auth` parameter. DCNL If user doesnt\'t have SSO token the `auth` dictionary has following parameters mandatory: DCNL url, username, password DCNL If user has SSO token the `auth` dictionary has following parameters mandatory: DCNL url, token DCNL The `ca_file` parameter is mandatory in case user want to use secure connection, DCNL in case user want to use insecure connection, it\'s mandatory to send insecure=True. DCNL :param auth: dictionary which contains needed values for connection creation DCNL :return: Python SDK connection'
def convert_to_bytes(param): DCNL 'This method convert units to bytes, which follow IEC standard. DCNL :param param: value to be converted'
def follow_link(connection, link): DCNL 'This method returns the entity of the element which link points to. DCNL :param connection: connection to the Python SDK DCNL :param link: link of the entity DCNL :return: entity which link points to'
def get_link_name(connection, link): DCNL 'This method returns the name of the element which link points to. DCNL :param connection: connection to the Python SDK DCNL :param link: link of the entity DCNL :return: name of the entity, which link points to'
def equal(param1, param2): DCNL 'Compare two parameters and return if they are equal. DCNL This parameter doesn\'t run equal operation if first parameter is None. DCNL With this approach we don\'t run equal operation in case user don\'t DCNL specify parameter in their task. DCNL :param param1: user inputted parameter DCNL :param param2: value of entity parameter DCNL :return: True if parameters are equal or first parameter is None, otherwise False'
def search_by_attributes(service, **kwargs): DCNL 'Search for the entity by attributes. Nested entities don\'t support search DCNL via REST, so in case using search for nested entity we return all entities DCNL and filter them by specified attributes.'
def search_by_name(service, name, **kwargs): DCNL 'Search for the entity by its name. Nested entities don\'t support search DCNL via REST, so in case using search for nested entity we return all entities DCNL and filter them by name. DCNL :param service: service of the entity DCNL :param name: name of the entity DCNL :return: Entity object returned by Python SDK'
def get_entity(service): DCNL 'Ignore SDK Error in case of getting an entity from service.'
def wait(service, condition, fail_condition=(lambda e: False), timeout=180, wait=True, poll_interval=3): DCNL 'Wait until entity fulfill expected condition. DCNL :param service: service of the entity DCNL :param condition: condition to be fulfilled DCNL :param fail_condition: if this condition is true, raise Exception DCNL :param timeout: max time to wait in seconds DCNL :param wait: if True wait for condition, if False don\'t wait DCNL :param poll_interval: Number of seconds we should wait until next condition check'
def ovirt_facts_full_argument_spec(**kwargs): DCNL 'Extend parameters of facts module with parameters which are common to all DCNL oVirt facts modules. DCNL :param kwargs: kwargs to be extended DCNL :return: extended dictionary with common parameters'
def ovirt_full_argument_spec(**kwargs): DCNL 'Extend parameters of module with parameters which are common to all oVirt modules. DCNL :param kwargs: kwargs to be extended DCNL :return: extended dictionary with common parameters'
def check_params(module): DCNL 'Most modules must have either `name` or `id` specified.'
def _get_gcp_ansible_credentials(module): DCNL 'Helper to fetch creds from AnsibleModule object.'
def _get_gcp_environ_var(var_name, default_value): DCNL 'Wrapper around os.environ.get call.'
def _get_gcp_environment_credentials(service_account_email, credentials_file, project_id): DCNL 'Helper to look in environment variables for credentials.'
def _get_gcp_libcloud_credentials(service_account_email=None, credentials_file=None, project_id=None): DCNL 'Helper to look for libcloud secrets.py file. DCNL Note: This has an \'additive\' effect right now, filling in DCNL vars not specified elsewhere, in order to keep legacy functionality. DCNL This method of specifying credentials will be deprecated, otherwise DCNL we\'d look to make it more restrictive with an all-vars-or-nothing approach. DCNL :param service_account: GCP service account email used to make requests DCNL :type service_account: ``str`` or None DCNL :param credentials_file: Path on disk to credentials file DCNL :type credentials_file: ``str`` or None DCNL :param project_id: GCP project ID. DCNL :type project_id: ``str`` or None DCNL :return: tuple of (service_account, credentials_file, project_id) DCNL :rtype: ``tuple`` of ``str``'
def _get_gcp_credentials(module, require_valid_json=True, check_libcloud=False): DCNL 'Obtain GCP credentials by trying various methods. DCNL There are 3 ways to specify GCP credentials: DCNL 1. Specify via Ansible module parameters (recommended). DCNL 2. Specify via environment variables.  Two sets of env vars are available: DCNL a) GOOGLE_CLOUD_PROJECT, GOOGLE_CREDENTIALS_APPLICATION (preferred) DCNL b) GCE_PROJECT, GCE_CREDENTIAL_FILE_PATH, GCE_EMAIL (legacy, not recommended; req\'d if DCNL using p12 key) DCNL 3. Specify via libcloud secrets.py file (deprecated). DCNL There are 3 helper functions to assist in the above. DCNL Regardless of method, the user also has the option of specifying a JSON DCNL file or a p12 file as the credentials file.  JSON is strongly recommended and DCNL p12 will be removed in the future. DCNL Additionally, flags may be set to require valid json and check the libcloud DCNL version. DCNL :param module: initialized Ansible module object DCNL :type module: `class AnsibleModule` DCNL :param require_valid_json: If true, require credentials to be valid JSON.  Default is True. DCNL :type require_valid_json: ``bool`` DCNL :params check_libcloud: If true, check the libcloud version available to see if DCNL JSON creds are supported. DCNL :type check_libcloud: ``bool`` DCNL :return:  {\'service_account_email\': service_account_email, DCNL \'credentials_file\': credentials_file, DCNL \'project_id\': project_id} DCNL :rtype: ``dict``'
def _validate_credentials_file(module, credentials_file, require_valid_json=True, check_libcloud=False): DCNL 'Check for valid credentials file. DCNL Optionally check for JSON format and if libcloud supports JSON. DCNL :param module: initialized Ansible module object DCNL :type module: `class AnsibleModule` DCNL :param credentials_file: path to file on disk DCNL :type credentials_file: ``str``.  Complete path to file on disk. DCNL :param require_valid_json: If true, require credentials to be valid JSON.  Default is True. DCNL :type require_valid_json: ``bool`` DCNL :params check_libcloud: If true, check the libcloud version available to see if DCNL JSON creds are supported. DCNL :type check_libcloud: ``bool`` DCNL :returns: True DCNL :rtype: ``bool``'
def gcp_connect(module, provider, get_driver, user_agent_product, user_agent_version): DCNL 'Return a Google libcloud driver connection.'
def get_google_cloud_credentials(module, scopes=[]): DCNL 'Get credentials object for use with Google Cloud client. DCNL To connect via libcloud, don\'t use this function, use gcp_connect instead.  For DCNL Google Python API Client, see get_google_api_auth for how to connect. DCNL For more information on Google\'s client library options for Python, see: DCNL U(https://cloud.google.com/apis/docs/client-libraries-explained#google_api_client_libraries) DCNL Google Cloud example: DCNL creds, params = get_google_cloud_credentials(module, scopes, user_agent_product, user_agent_version) DCNL pubsub_client = pubsub.Client(project=params[\'project_id\'], credentials=creds) DCNL pubsub_client.user_agent = \'ansible-pubsub-0.1\' DCNL :param module: initialized Ansible module object DCNL :type module: `class AnsibleModule` DCNL :param scopes: list of scopes DCNL :type module: ``list`` of URIs DCNL :returns: A tuple containing (google authorized) credentials object and DCNL params dict {\'service_account_email\': \'...\', \'credentials_file\': \'...\', \'project_id\': ...} DCNL :rtype: ``tuple``'
def get_google_api_auth(module, scopes=[], user_agent_product='ansible-python-api', user_agent_version='NA'): DCNL 'Authentication for use with google-python-api-client. DCNL Function calls _get_gcp_credentials, which attempts to assemble the credentials from various locations. DCNL Next it attempts to authenticate with Google. DCNL This function returns an httplib2 object that can be provided to the Google Python API client. DCNL For libcloud, don\'t use this function, use gcp_connect instead.  For Google Cloud, See DCNL get_google_cloud_credentials for how to connect. DCNL For more information on Google\'s client library options for Python, see: DCNL U(https://cloud.google.com/apis/docs/client-libraries-explained#google_api_client_libraries) DCNL Google API example: DCNL http_auth, conn_params = gcp_api_auth(module, scopes, user_agent_product, user_agent_version) DCNL service = build(\'myservice\', \'v1\', http=http_auth) DCNL :param module: initialized Ansible module object DCNL :type module: `class AnsibleModule` DCNL :param scopes: list of scopes DCNL :type scopes: ``list`` of URIs DCNL :param user_agent_product: User agent product.  eg: \'ansible-python-api\' DCNL :type user_agent_product: ``str`` DCNL :param user_agent_version: Version string to append to product.  eg: \'NA\' or \'0.1\' DCNL :type user_agent_version: ``str`` DCNL :returns: A tuple containing (google authorized) httplib2 request object and a DCNL params dict {\'service_account_email\': \'...\', \'credentials_file\': \'...\', \'project_id\': ...} DCNL :rtype: ``tuple``'
def unexpected_error_msg(error): DCNL 'Create an error string based on passed in error.'
def get_exception(): DCNL 'Get the current exception. DCNL This code needs to work on Python 2.4 through 3.x, so we cannot use DCNL "except Exception, e:" (SyntaxError on Python 3.x) nor DCNL "except Exception as e:" (SyntaxError on Python 2.4-2.5). DCNL Instead we must use :: DCNL except Exception: DCNL e = get_exception()'
def gce_connect(module, provider=None): DCNL 'Return a GCP connection for Google Compute Engine.'
def unexpected_error_msg(error): DCNL 'Create an error string based on passed in error.'
def _add_doc(func, doc): DCNL 'Add documentation to a function.'
def _import_module(name): DCNL 'Import module, returning the module after the last dot.'
def add_move(move): DCNL 'Add an item to six.moves.'
def remove_move(name): DCNL 'Remove item from six.moves.'
def iterkeys(d, **kw): DCNL 'Return an iterator over the keys of a dictionary.'
def itervalues(d, **kw): DCNL 'Return an iterator over the values of a dictionary.'
def iteritems(d, **kw): DCNL 'Return an iterator over the (key, value) pairs of a dictionary.'
def iterlists(d, **kw): DCNL 'Return an iterator over the (key, [values]) pairs of a dictionary.'
def with_metaclass(meta, *bases): DCNL 'Create a base class with a metaclass.'
def add_metaclass(metaclass): DCNL 'Class decorator for creating a class with a metaclass.'
def rate_limit_argument_spec(spec=None): DCNL 'Creates an argument spec for working with rate limiting'
def retry_argument_spec(spec=None): DCNL 'Creates an argument spec for working with retrying'
def rate_limit(rate=None, rate_limit=None): DCNL 'rate limiting decorator'
def retry(retries=None, retry_pause=1): DCNL 'Retry decorator'
def lang_exists(cursor, lang): DCNL 'Checks if language exists for db'
def lang_istrusted(cursor, lang): DCNL 'Checks if language is trusted for db'
def lang_altertrust(cursor, lang, trust): DCNL 'Changes if language is trusted for db'
def lang_add(cursor, lang, trust): DCNL 'Adds language for db'
def lang_drop(cursor, lang, cascade): DCNL 'Drops language for db'
def user_add(cursor, user, password, role_attr_flags, encrypted, expires): DCNL 'Create a new database user (role).'
def user_alter(cursor, module, user, password, role_attr_flags, encrypted, expires, no_password_changes): DCNL 'Change user password and/or attributes. Return True if changed, False otherwise.'
def user_delete(cursor, user): DCNL 'Try to remove a user. Returns True if successful otherwise False'
def has_table_privileges(cursor, user, table, privs): DCNL 'Return the difference between the privileges that a user already has and DCNL the privileges that they desire to have. DCNL :returns: tuple of: DCNL * privileges that they have and were requested DCNL * privileges they currently hold but were not requested DCNL * privileges requested that they do not hold'
def has_database_privileges(cursor, user, db, privs): DCNL 'Return the difference between the privileges that a user already has and DCNL the privileges that they desire to have. DCNL :returns: tuple of: DCNL * privileges that they have and were requested DCNL * privileges they currently hold but were not requested DCNL * privileges requested that they do not hold'
def parse_role_attrs(role_attr_flags): DCNL 'Parse role attributes string for user creation. DCNL Format: DCNL attributes[,attributes,...] DCNL Where: DCNL attributes := CREATEDB,CREATEROLE,NOSUPERUSER,... DCNL [ "[NO]SUPERUSER","[NO]CREATEROLE", "[NO]CREATEUSER", "[NO]CREATEDB", DCNL "[NO]INHERIT", "[NO]LOGIN", "[NO]REPLICATION" ]'
def parse_privs(privs, db): DCNL 'Parse privilege string to determine permissions for database db. DCNL Format: DCNL privileges[/privileges/...] DCNL Where: DCNL privileges := DATABASE_PRIVILEGES[,DATABASE_PRIVILEGES,...] | DCNL TABLE_NAME:TABLE_PRIVILEGES[,TABLE_PRIVILEGES,...]'
def partial(f, *args, **kwargs): DCNL 'Partial function application'
def typedvalue(value): DCNL 'Convert value to number whenever possible, return same value DCNL otherwise. DCNL >>> typedvalue(\'3\') DCNL 3 DCNL >>> typedvalue(\'3.0\') DCNL 3.0 DCNL >>> typedvalue(\'foobar\') DCNL \'foobar\''
def setvariable(cursor, mysqlvar, value): DCNL 'Set a global mysql variable to a given value DCNL The DB driver will handle quoting of the given value based on its DCNL type, thus numeric strings like \'3.0\' or \'8\' are illegal, they DCNL should be passed as numeric literals.'
def privileges_get(cursor, user, host): DCNL 'MySQL doesn\'t have a better method of getting privileges aside from the DCNL SHOW GRANTS query syntax, which requires us to then parse the returned string. DCNL Here\'s an example of the string that is returned from MySQL: DCNL GRANT USAGE ON *.* TO \'user\'@\'localhost\' IDENTIFIED BY \'pass\'; DCNL This function makes the query and returns a dictionary containing the results. DCNL The dictionary format is the same as that returned by privileges_unpack() below.'
def privileges_unpack(priv, mode): DCNL 'Take a privileges string, typically passed as a parameter, and unserialize DCNL it into a dictionary, the same format as privileges_get() above. We have this DCNL custom format to avoid using YAML/JSON strings inside YAML playbooks. Example DCNL of a privileges string: DCNL mydb.*:INSERT,UPDATE/anotherdb.*:SELECT/yetanother.*:ALL DCNL The privilege USAGE stands for no privileges, so we add that in on *.* if it\'s DCNL not specified in the string, as MySQL will always provide this by default.'
def check_compatibility(module, client): DCNL 'Check the compatibility between the driver and the database. DCNL See: https://docs.mongodb.com/ecosystem/drivers/driver-compatibility-reference/#python-driver-compatibility DCNL Args: DCNL module: Ansible module. DCNL client (cursor): Mongodb cursor on admin database.'
def user_find(client, user, db_name): DCNL 'Check if the user exists. DCNL Args: DCNL client (cursor): Mongodb cursor on admin database. DCNL user (str): User to check. DCNL db_name (str): User\'s database. DCNL Returns: DCNL dict: when user exists, False otherwise.'
def normalize_image(image): DCNL 'Normalize a Docker image name to include the implied :latest tag.'
def is_running(container): DCNL 'Return True if an inspected container is in a state we consider "running."'
def check_dependencies(module): DCNL 'Ensure `docker-py` >= 0.3.0 is installed, and call module.fail_json with a DCNL helpful error message if it isn\'t.'
def present(manager, containers, count, name): DCNL 'Ensure that exactly `count` matching containers exist in any state.'
def started(manager, containers, count, name): DCNL 'Ensure that exactly `count` matching containers exist and are running.'
def reloaded(manager, containers, count, name): DCNL 'Ensure that exactly `count` matching containers exist and are DCNL running. If any associated settings have been changed (volumes, DCNL ports or so on), restart those containers.'
def restarted(manager, containers, count, name): DCNL 'Ensure that exactly `count` matching containers exist and are DCNL running. Unconditionally restart any that were already running.'
def stopped(manager, containers, count, name): DCNL 'Stop any matching containers that are running.'
def killed(manager, containers, count, name): DCNL 'Kill any matching containers that are running.'
def absent(manager, containers, count, name): DCNL 'Stop and remove any matching containers.'
def rax_dns_record(module, comment=None, data=None, domain=None, name=None, overwrite=True, priority=None, record_type='A', state='present', ttl=7200): DCNL 'Function for manipulating record types other than PTR'
def cloudfiles(module, container_, state, meta_, clear_meta, typ, ttl, public, private, web_index, web_error): DCNL 'Dispatch from here to work with metadata or file objects'
def _get_node(lb, node_id=None, address=None, port=None): DCNL 'Return a matching node'
def _upload_folder(cf, folder, container, ttl=None, headers=None): DCNL 'Uploads a folder to Cloud Files.'
def upload(module, cf, container, src, dest, meta, expires): DCNL 'Uploads a single object or a folder to Cloud Files Optionally sets an DCNL metadata, TTL value (expires), or Content-Disposition and Content-Encoding DCNL headers.'
def download(module, cf, container, src, dest, structure): DCNL 'Download objects from Cloud Files to a local path specified by "dest". DCNL Optionally disable maintaining a directory structure by by passing a DCNL false value to "structure".'
def delete(module, cf, container, src, dest): DCNL 'Delete specific objects by proving a single file name or a DCNL comma-separated list to src OR dest (but not both).  Omitting file name(s) DCNL assumes the entire container is to be deleted.'
def get_meta(module, cf, container, src, dest): DCNL 'Get metadata for a single file, comma-separated list, or entire DCNL container'
def put_meta(module, cf, container, src, dest, meta, clear_meta): DCNL 'Set metadata on a container, single file, or comma-separated list. DCNL Passing a true value to clear_meta clears the metadata stored in Cloud DCNL Files before setting the new metadata to the value of "meta".'
def delete_meta(module, cf, container, src, dest, meta): DCNL 'Removes metadata keys and values specified in meta, if any.  Deletes on DCNL all objects specified by src or dest (but not both), if any; otherwise it DCNL deletes keys on all objects in the container'
def cloudfiles(module, container, src, dest, method, typ, meta, clear_meta, structure, expires): DCNL 'Dispatch from here to work with metadata or file objects'
def get_ssh_certificate_tokens(module, ssh_cert_path): DCNL 'Returns the sha1 fingerprint and a base64-encoded PKCS12 version of the certificate.'
def create_virtual_machine(module, azure): DCNL 'Create new virtual machine DCNL module : AnsibleModule object DCNL azure: authenticated azure ServiceManagementService object DCNL Returns: DCNL True if a new virtual machine and/or cloud service was created, false otherwise'
def terminate_virtual_machine(module, azure): DCNL 'Terminates a virtual machine DCNL module : AnsibleModule object DCNL azure: authenticated azure ServiceManagementService object DCNL Returns: DCNL True if a new virtual machine was deleted, false otherwise'
def virtual_network_to_dict(vnet): DCNL 'Convert a virtual network object to a dict. DCNL :param vnet: VirtualNet object DCNL :return: dict'
def validate_rule(rule, rule_type=None): DCNL 'Apply defaults to a rule dictionary and check that all values are valid. DCNL :param rule: rule dict DCNL :param rule_type: Set to \'default\' if the rule is part of the default set of rules. DCNL :return: None'
def create_rule_instance(rule): DCNL 'Create an instance of SecurityRule from a dict. DCNL :param rule: dict DCNL :return: SecurityRule'
def create_rule_dict_from_obj(rule): DCNL 'Create a dict from an instance of a SecurityRule. DCNL :param rule: SecurityRule DCNL :return: dict'
def migrate_vm(vm_object, host_object): DCNL 'Migrate virtual machine and return the task.'
def power_state(vm, state, force): DCNL 'Correctly set the power status for a VM determined by the current and DCNL requested states. force is forceful'
def gather_facts(vm): DCNL 'Gather facts for VM directly from vsphere.'
def config_check(name, passed, default, module): DCNL 'Checks that the dict passed for VM configuration matches the required DCNL interface declared at the top of __main__'
def vmware_path(datastore, datacenter, path): DCNL 'Constructs a URL path that VSphere accepts reliably'
def get_obj(content, vimtype, name): DCNL 'Return an object by name, if name is None the DCNL first found object is returned'
def _needs_update(module, port, cloud): DCNL 'Check for differences in the updatable values. DCNL NOTE: We don\'t currently allow name updates.'
def _needs_update(module, secgroup): DCNL 'Check for differences in the updatable values. DCNL NOTE: We don\'t currently allow name updates.'
def _system_state_change(state, device): DCNL 'Check if system state would change.'
def _can_update(subnet, module, cloud): DCNL 'Check for differences in non-updatable values'
def _needs_update(subnet, module, cloud): DCNL 'Check for differences in the updatable values.'
def _system_state_change(module, project_quota_output): DCNL 'Determine if changes are required to the current project quota. DCNL This is done by comparing the current project_quota_output against DCNL the desired quota settings set on the module params.'
def _ports_match(protocol, module_min, module_max, rule_min, rule_max): DCNL 'Capture the complex port matching logic. DCNL The port values coming in for the module might be -1 (for ICMP), DCNL which will work only for Nova, but this is handled by shade. Likewise, DCNL they might be None, which works for Neutron, but not Nova. This too is DCNL handled by shade. Since shade will consistently return these port DCNL values as None, we need to convert any -1 values input to the module DCNL to None here for comparison. DCNL For TCP and UDP protocols, None values for both min and max are DCNL represented as the range 1-65535 for Nova, but remain None for DCNL Neutron. Shade returns the full range when Nova is the backend (since DCNL that is how Nova stores them), and None values for Neutron. If None DCNL values are input to the module for both values, then we need to adjust DCNL for comparison.'
def _find_matching_rule(module, secgroup, remotegroup): DCNL 'Find a rule in the group that matches the module parameters. DCNL :returns: The matching rule dict, or None if no matches.'
def _wait(timeout, cloud, server, action): DCNL 'Wait for the server to reach the desired state for the given action.'
def _system_state_change(action, status): DCNL 'Check if system state would change.'
def _needs_update(cloud, module, router, network, internal_subnet_ids): DCNL 'Decide if the given router needs an update.'
def _system_state_change(cloud, module, router, network, internal_ids): DCNL 'Check if the system state would be changed.'
def authenticate(endpoint, token, login_user, login_password, login_tenant_name): DCNL 'Return a keystone client object'
def tenant_exists(keystone, tenant): DCNL 'Return True if tenant already exists'
def user_exists(keystone, user): DCNL '" Return True if user already exists'
def get_tenant(keystone, name): DCNL 'Retrieve a tenant by name'
def get_user(keystone, name): DCNL 'Retrieve a user by name'
def get_role(keystone, name): DCNL 'Retrieve a role by name'
def ensure_tenant_exists(keystone, tenant_name, tenant_description, check_mode): DCNL 'Ensure that a tenant exists. DCNL Return (True, id) if a new tenant was created, (False, None) if it DCNL already existed.'
def ensure_tenant_absent(keystone, tenant, check_mode): DCNL 'Ensure that a tenant does not exist DCNL Return True if the tenant was removed, False if it didn\'t exist DCNL in the first place'
def ensure_user_exists(keystone, user_name, password, email, tenant_name, check_mode): DCNL 'Check if user exists DCNL Return (True, id) if a new user was created, (False, id) user already DCNL exists'
def ensure_user_role_exists(keystone, user_name, tenant_name, role_name, check_mode): DCNL 'Check if role exists DCNL Return (True, id) if a new role was created or if the role was newly DCNL assigned to the user for the tenant. (False, id) if the role already DCNL exists and was already assigned to the user for the tenant.'
def dispatch(keystone, user=None, password=None, tenant=None, tenant_description=None, email=None, role=None, state='present', endpoint=None, token=None, login_user=None, login_password=None, check_mode=False): DCNL 'Dispatch to the appropriate method. DCNL Returns a dict that will be passed to exit_json DCNL tenant  user  role   state DCNL X                  present     ensure_tenant_exists DCNL X                  absent      ensure_tenant_absent DCNL X      X           present     ensure_user_exists DCNL X      X           absent      ensure_user_absent DCNL X      X     X     present     ensure_user_role_exists DCNL X      X     X     absent      ensure_user_role_absent DCNL X     present     ensure_role_exists DCNL X     absent      ensure_role_absent'
def _search_by_lun(disks_service, lun_id): DCNL 'Find disk by LUN ID.'
def create_nic(module, profitbricks): DCNL 'Creates a NIC. DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Returns: DCNL True if the nic creates, false otherwise'
def delete_nic(module, profitbricks): DCNL 'Removes a NIC DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Returns: DCNL True if the NIC was removed, false otherwise'
def attach_volume(module, profitbricks): DCNL 'Attaches a volume. DCNL This will attach a volume to the server. DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Returns: DCNL True if the volume was attached, false otherwise'
def detach_volume(module, profitbricks): DCNL 'Detaches a volume. DCNL This will remove a volume from the server. DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Returns: DCNL True if the volume was detached, false otherwise'
def create_virtual_machine(module, profitbricks): DCNL 'Create new virtual machine DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object DCNL Returns: DCNL True if a new virtual machine was created, false otherwise'
def remove_virtual_machine(module, profitbricks): DCNL 'Removes a virtual machine. DCNL This will remove the virtual machine along with the bootVolume. DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Not yet supported: handle deletion of attached data disks. DCNL Returns: DCNL True if a new virtual server was deleted, false otherwise'
def _remove_boot_volume(module, profitbricks, datacenter_id, server_id): DCNL 'Remove the boot volume from the server'
def startstop_machine(module, profitbricks, state): DCNL 'Starts or Stops a virtual machine. DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Returns: DCNL True when the servers process the action successfully, false otherwise.'
def _get_datacenter_id(datacenters, identity): DCNL 'Fetch and return datacenter UUID by datacenter name if found.'
def _get_server_id(servers, identity): DCNL 'Fetch and return server UUID by server name if found.'
def create_datacenter(module, profitbricks): DCNL 'Creates a Datacenter DCNL This will create a new Datacenter in the specified location. DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Returns: DCNL True if a new datacenter was created, false otherwise'
def remove_datacenter(module, profitbricks): DCNL 'Removes a Datacenter. DCNL This will remove a datacenter. DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Returns: DCNL True if the datacenter was deleted, false otherwise'
def create_volume(module, profitbricks): DCNL 'Creates a volume. DCNL This will create a volume in a datacenter. DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Returns: DCNL True if the volume was created, false otherwise'
def delete_volume(module, profitbricks): DCNL 'Removes a volume. DCNL This will create a volume in a datacenter. DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Returns: DCNL True if the volume was removed, false otherwise'
def _attach_volume(module, profitbricks, datacenter, volume): DCNL 'Attaches a volume. DCNL This will attach a volume to the server. DCNL module : AnsibleModule object DCNL profitbricks: authenticated profitbricks object. DCNL Returns: DCNL True if the volume was attached, false otherwise'
def create_script(command): DCNL 'Write out a script onto a target. DCNL This method should be backward compatible with Python 2.4+ when executing DCNL from within the container. DCNL :param command: command to run, this can be a script and can use spacing DCNL with newlines as separation. DCNL :type command: ``str``'
def main(): DCNL 'Ansible Main module.'
def serialize_device(device): DCNL 'Standard represenation for a device as returned by various tasks:: DCNL \'id\': \'device_id\' DCNL \'hostname\': \'device_hostname\', DCNL \'tags\': [], DCNL \'locked\': false, DCNL \'ip_addresses\': [ DCNL "address": "147.75.194.227", DCNL "address_family": 4, DCNL "public": true DCNL "address": "2604:1380:2:5200::3", DCNL "address_family": 6, DCNL "public": true DCNL "address": "10.100.11.129", DCNL "address_family": 4, DCNL "public": false DCNL "private_ipv4": "10.100.11.129", DCNL "public_ipv4": "147.75.194.227", DCNL "public_ipv6": "2604:1380:2:5200::3",'
def boto_exception(err): DCNL 'generic error message handler'
def boto_exception(err): DCNL 'generic error message handler'
def assert_policy_shape(policy): DCNL 'Since the policy seems a little, uh, fragile, make sure we know approximately what we\'re looking at.'
def make_rule_key(prefix, rule, group_id, cidr_ip): DCNL 'Creates a unique key for an individual group rule'
def get_target_from_rule(module, ec2, rule, name, group, groups, vpc_id): DCNL 'Returns tuple of (group_id, ip) after validating rule params. DCNL rule: Dict describing a rule. DCNL name: Name of the security group being managed. DCNL groups: Dict of all available security groups. DCNL AWS accepts an ip range or a security group as target of a rule. This DCNL function validate the rule specification and return either a non-None DCNL group_id or a non-None ip range.'
def is_fakes3(s3_url): DCNL 'Return True if s3_url has scheme fakes3://'
def is_walrus(s3_url): DCNL 'Return True if it\'s Walrus endpoint, not S3 DCNL We assume anything other than *.amazonaws.com is Walrus'
def boto_supports_volume_encryption(): DCNL 'Check if Boto library supports encryption of EBS volumes (added in 2.29.0) DCNL Returns: DCNL True if boto library has the named param as an argument on the request_spot_instances method, else False'
def boto_supports_kms_key_id(): DCNL 'Check if Boto library supports kms_key_ids (added in 2.39.0) DCNL Returns: DCNL True if version is equal to or higher then the version needed, else False'
def modify_dot_attribute(module, ec2, instance, device_name): DCNL 'Modify delete_on_termination attribute'
def iterate_all(attr, map_method, **kwargs): DCNL 'Method creates iterator from boto result set'
def prefix_to_attr(attr_id): DCNL 'Helper method to convert ID prefix to mount target attribute'
def first_or_default(items, default=None): DCNL 'Helper method to fetch first element of list (if exists)'
def has_tags(available, required): DCNL 'Helper method to determine if tag requested already exists'
def has_targets(available, required): DCNL 'Helper method to determine if mount tager requested already exists'
def group_list_of_dict(array): DCNL 'Helper method to group list of dict to dict with all possible values'
def main(): DCNL 'Module action handler'
def get_cloudwatchevents_client(module): DCNL 'Returns a boto3 client for accessing CloudWatch Events'
def get_url(module, url): DCNL 'Get url and return response'
def ubuntu(module): DCNL 'Get the ami for ubuntu'
def lookup_ubuntu_ami(table, release, stream, store, arch, region, virt): DCNL 'Look up the Ubuntu AMI that matches query given a table of AMIs DCNL table: an iterable that returns a row of DCNL (release, stream, tag, serial, region, ami, aki, ari, virt) DCNL release: ubuntu release name DCNL stream: \'server\' or \'desktop\' DCNL store: \'ebs\', \'ebs-io1\', \'ebs-ssd\' or \'instance-store\' DCNL arch: \'i386\' or \'amd64\' DCNL region: EC2 region DCNL virt: \'paravirtual\' or \'hvm\' DCNL Returns (ami, aki, ari, tag, serial)'
def is_fakes3(s3_url): DCNL 'Return True if s3_url has scheme fakes3://'
def is_walrus(s3_url): DCNL 'Return True if it\'s Walrus endpoint, not S3 DCNL We assume anything other than *.amazonaws.com is Walrus'
def get_instance_info(inst): DCNL 'Retrieves instance information from an instance DCNL ID and returns it as a dictionary'
def boto_supports_associate_public_ip_address(ec2): DCNL 'Check if Boto library has associate_public_ip_address in the NetworkInterfaceSpecification DCNL class. Added in Boto 2.13.0 DCNL ec2: authenticated ec2 connection object DCNL Returns: DCNL True if Boto library accepts associate_public_ip_address argument, else false'
def boto_supports_profile_name_arg(ec2): DCNL 'Check if Boto library has instance_profile_name argument. instance_profile_name has been added in Boto 2.5.0 DCNL ec2: authenticated ec2 connection object DCNL Returns: DCNL True if Boto library accept instance_profile_name argument, else false'
def boto_supports_volume_encryption(): DCNL 'Check if Boto library supports encryption of EBS volumes (added in 2.29.0) DCNL Returns: DCNL True if boto library has the named param as an argument on the request_spot_instances method, else False'
def boto_supports_param_in_spot_request(ec2, param): DCNL 'Check if Boto library has a <param> in its request_spot_instances() method. For example, the placement_group parameter wasn\'t added until 2.3.0. DCNL ec2: authenticated ec2 connection object DCNL Returns: DCNL True if boto library has the named param as an argument on the request_spot_instances method, else False'
def await_spot_requests(module, ec2, spot_requests, count): DCNL 'Wait for a group of spot requests to be fulfilled, or fail. DCNL module: Ansible module object DCNL ec2: authenticated ec2 connection object DCNL spot_requests: boto.ec2.spotinstancerequest.SpotInstanceRequest object returned by ec2.request_spot_instances DCNL count: Total number of instances to be created by the spot requests DCNL Returns: DCNL list of instance ID\'s created by the spot request(s)'
def create_instances(module, ec2, vpc, override_count=None): DCNL 'Creates new instances DCNL module : AnsibleModule object DCNL ec2: authenticated ec2 connection object DCNL Returns: DCNL A list of dictionaries with instance information DCNL about the instances that were launched'
def terminate_instances(module, ec2, instance_ids): DCNL 'Terminates a list of instances DCNL module: Ansible module object DCNL ec2: authenticated ec2 connection object DCNL termination_list: a list of instances to terminate in the form of DCNL [ {id: <inst-id>}, ..] DCNL Returns a dictionary of instance information DCNL about the instances terminated. DCNL If the instance to be terminated is running DCNL "changed" will be set to False.'
def startstop_instances(module, ec2, instance_ids, state, instance_tags): DCNL 'Starts or stops a list of existing instances DCNL module: Ansible module object DCNL ec2: authenticated ec2 connection object DCNL instance_ids: The list of instances to start in the form of DCNL [ {id: <inst-id>}, ..] DCNL instance_tags: A dict of tag keys and values in the form of DCNL {key: value, ... } DCNL state: Intended state ("running" or "stopped") DCNL Returns a dictionary of instance information DCNL about the instances started/stopped. DCNL If the instance was not able to change state, DCNL "changed" will be set to False. DCNL Note that if instance_ids and instance_tags are both non-empty, DCNL this method will process the intersection of the two'
def restart_instances(module, ec2, instance_ids, state, instance_tags): DCNL 'Restarts a list of existing instances DCNL module: Ansible module object DCNL ec2: authenticated ec2 connection object DCNL instance_ids: The list of instances to start in the form of DCNL [ {id: <inst-id>}, ..] DCNL instance_tags: A dict of tag keys and values in the form of DCNL {key: value, ... } DCNL state: Intended state ("restarted") DCNL Returns a dictionary of instance information DCNL about the instances. DCNL If the instance was not able to change state, DCNL "changed" will be set to False. DCNL Wait will not apply here as this is a OS level operation. DCNL Note that if instance_ids and instance_tags are both non-empty, DCNL this method will process the intersection of the two.'
def copy_image(module, ec2): DCNL 'Copies an AMI DCNL module : AnsibleModule object DCNL ec2: ec2 connection object'
def set_parameter(param, value, immediate): DCNL 'Allows setting parameters with 10M = 10* 1024 * 1024 and so on.'
def modify_group(group, params, immediate=False): DCNL 'Set all of the params in a group to the provided new params. Raises NotModifiableError if any of the DCNL params to be changed are read only.'
def boto_exception(err): DCNL 'generic error message handler'
def _collect_facts(resource): DCNL 'Transfrom cluster information to dict.'
def create_cluster(module, redshift): DCNL 'Create a new cluster DCNL module: AnsibleModule object DCNL redshift: authenticated redshift connection object DCNL Returns:'
def describe_cluster(module, redshift): DCNL 'Collect data about the cluster. DCNL module: Ansible module object DCNL redshift: authenticated redshift connection object'
def delete_cluster(module, redshift): DCNL 'Delete a cluster. DCNL module: Ansible module object DCNL redshift: authenticated redshift connection object'
def modify_cluster(module, redshift): DCNL 'Modify an existing cluster. DCNL module: Ansible module object DCNL redshift: authenticated redshift connection object'
def enforce_required_arguments(module): DCNL 'As many arguments are not required for autoscale group deletion DCNL they cannot be mandatory arguments for the module, so we enforce DCNL them here'
def _get_most_recent_snapshot(snapshots, max_snapshot_age_secs=None, now=None): DCNL 'Gets the most recently created snapshot and optionally filters the result DCNL if the snapshot is too old DCNL :param snapshots: list of snapshots to search DCNL :param max_snapshot_age_secs: filter the result if its older than this DCNL :param now: simulate time -- used for unit testing DCNL :return:'
def _create_with_wait(snapshot, wait_timeout_secs, sleep_func=time.sleep): DCNL 'Wait for the snapshot to be created DCNL :param snapshot: DCNL :param wait_timeout_secs: fail this step after this many seconds DCNL :param sleep_func: DCNL :return:'
def fetch_dhcp_options_for_vpc(vpc_conn, vpc_id): DCNL 'Returns the DHCP options object currently associated with the requested VPC ID using the VPC DCNL connection variable.'
def match_dhcp_options(vpc_conn, tags=None, options=None): DCNL 'Finds a DHCP Options object that optionally matches the tags and options provided'
def to_dict(items, key, value): DCNL 'Transforms a list of items to a Key/Value dictionary'
def pc(key): DCNL 'Changes python key into Pascale case equivalent. For example, \'this_function_name\' becomes \'ThisFunctionName\'. DCNL :param key: DCNL :return:'
def set_api_params(module, module_params): DCNL 'Sets module parameters to those expected by the boto3 API. DCNL :param module: DCNL :param module_params: DCNL :return:'
def validate_params(module, aws): DCNL 'Performs basic parameter validation. DCNL :param module: Ansible module reference DCNL :param aws: AWS client connection DCNL :return:'
def get_lambda_alias(module, aws): DCNL 'Returns the lambda function alias if it exists. DCNL :param module: Ansible module reference DCNL :param aws: AWS client connection DCNL :return:'
def lambda_alias(module, aws): DCNL 'Adds, updates or deletes lambda function aliases. DCNL :param module: Ansible module reference DCNL :param aws: AWS client connection DCNL :return dict:'
def main(): DCNL 'Main entry point. DCNL :return dict: ansible facts'
def boto_exception(err): DCNL 'generic error message handler'
def calculate_multipart_etag(source_path, chunk_size=DEFAULT_CHUNK_SIZE): DCNL 'calculates a multipart upload etag for amazon s3 DCNL Arguments: DCNL source_path -- The file to calculate the etag for DCNL chunk_size -- The chunk size to calculate for.'
def calculate_local_etag(filelist, key_prefix=''): DCNL 'Really, "calculate md5", but since AWS uses their own format, we\'ll just call DCNL it a "local etag". TODO optimization: only calculate if remote key exists.'
def find_health_check(conn, wanted): DCNL 'Searches for health checks that have the exact same set of immutable values'
def get_zone_by_name(conn, module, zone_name, want_private, zone_id, want_vpc_id): DCNL 'Finds a zone by name or zone_id'
def commit(changes, retry_interval, wait, wait_timeout): DCNL 'Commit changes, but retry PriorRequestNotComplete errors.'
def boto_exception(err): DCNL 'generic error message handler'
def get_stack_events(cfn, stack_name): DCNL 'This event data was never correct, it worked as a side effect. So the v2.3 format is different.'
def stack_operation(cfn, stack_name, operation): DCNL 'gets the status of a stack while it is created/updated/deleted'
def boto_exception(err): DCNL 'generic error message handler'
def _paginate(func, attr): DCNL 'paginates the results from func by continuously passing in DCNL the returned marker if the results were truncated. this returns DCNL an iterator over the items in the returned response. `attr` is DCNL the name of the attribute to iterate over in the response.'
def set_users_groups(module, iam, name, groups, updated=None, new_name=None): DCNL 'Sets groups for a user, will purge groups not explicitly passed, while DCNL retaining pre-existing groups that also are in the new list.'
def get_vpc_info(vpc): DCNL 'Retrieves vpc information from an instance DCNL ID and returns it as a dictionary'
def find_vpc(module, vpc_conn, vpc_id=None, cidr=None): DCNL 'Finds a VPC that matches a specific id or cidr + tags DCNL module : AnsibleModule object DCNL vpc_conn: authenticated VPCConnection connection object DCNL Returns: DCNL A VPC object that matches either an ID or CIDR and one or more tag values'
def routes_match(rt_list=None, rt=None, igw=None): DCNL 'Check if the route table has all routes as in given list DCNL rt_list      : A list if routes provided in the module DCNL rt           : The Remote route table object DCNL igw          : The internet gateway object for this vpc DCNL Returns: DCNL True when there provided routes and remote routes are the same. DCNL False when provided routes and remote routes are different.'
def rtb_changed(route_tables=None, vpc_conn=None, module=None, vpc=None, igw=None): DCNL 'Checks if the remote routes match the local routes. DCNL route_tables : Route_tables parameter in the module DCNL vpc_conn     : The VPC connection object DCNL module       : The module object DCNL vpc          : The vpc object for this route table DCNL igw          : The internet gateway object for this vpc DCNL Returns: DCNL True when there is difference between the provided routes and remote routes and if subnet associations are different. DCNL False when both routes and subnet associations matched.'
def create_vpc(module, vpc_conn): DCNL 'Creates a new or modifies an existing VPC. DCNL module : AnsibleModule object DCNL vpc_conn: authenticated VPCConnection connection object DCNL Returns: DCNL A dictionary with information DCNL about the VPC and subnets that were launched'
def terminate_vpc(module, vpc_conn, vpc_id=None, cidr=None): DCNL 'Terminates a VPC DCNL module: Ansible module object DCNL vpc_conn: authenticated VPCConnection connection object DCNL vpc_id: a vpc id to terminate DCNL cidr: The cidr block of the VPC - can be used in lieu of an ID DCNL Returns a dictionary of VPC information DCNL about the VPC terminated. DCNL If the VPC to be terminated is available DCNL "changed" will be set to True.'
def boto_exception(err): DCNL 'generic error message handler'
def vpc_exists(module, vpc, name, cidr_block, multi): DCNL 'Returns True or False in regards to the existence of a VPC. When supplied DCNL with a CIDR, it will check for matching tags to determine if it is a match DCNL otherwise it will assume the VPC does not exist and thus return false.'
def iterate_all(attr, map_method, **kwargs): DCNL 'Method creates iterator from boto result set'
def targets_equal(keys, a, b): DCNL 'Method compare two mount targets by specified attributes'
def dict_diff(dict1, dict2, by_key=False): DCNL 'Helper method to calculate difference of two dictionaries'
def first_or_default(items, default=None): DCNL 'Helper method to fetch first element of list (if exists)'
def wait_for(callback, value, timeout=EFSConnection.DEFAULT_WAIT_TIMEOUT_SECONDS): DCNL 'Helper method to wait for desired value returned by callback method'
def main(): DCNL 'Module action handler'
def get_server_certs(iam, name=None): DCNL 'Retrieve the attributes of a server certificate if it exists or all certs. DCNL Args: DCNL iam (botocore.client.IAM): The boto3 iam instance. DCNL Kwargs: DCNL name (str): The name of the server certificate. DCNL Basic Usage: DCNL >>> import boto3 DCNL >>> iam = boto3.client(\'iam\') DCNL >>> name = "server-cert-name" DCNL >>> results = get_server_certs(iam, name) DCNL "upload_date": "2015-04-25T00:36:40+00:00", DCNL "server_certificate_id": "ADWAJXWTZAXIPIMQHMJPO", DCNL "certificate_body": "-----BEGIN CERTIFICATE----- DCNL bunch of random data DCNL -----END CERTIFICATE-----", DCNL "server_certificate_name": "server-cert-name", DCNL "expiration": "2017-06-15T12:00:00+00:00", DCNL "path": "/", DCNL "arn": "arn:aws:iam::911277865346:server-certificate/server-cert-name"'
def convert_to_lower(data): DCNL 'Convert all uppercase keys in dict with lowercase_ DCNL Args: DCNL data (dict): Dictionary with keys that have upper cases in them DCNL Example.. FooBar == foo_bar DCNL if a val is of type datetime.datetime, it will be converted to DCNL the ISO 8601 DCNL Basic Usage: DCNL >>> test = {\'FooBar\': []} DCNL >>> test = convert_to_lower(test) DCNL \'foo_bar\': [] DCNL Returns: DCNL Dictionary'
def make_tags_in_proper_format(tags): DCNL 'Take a dictionary of tags and convert them into the AWS Tags format. DCNL Args: DCNL tags (list): The tags you want applied. DCNL Basic Usage: DCNL >>> tags = [{\'Key\': \'env\', \'Value\': \'development\'}] DCNL >>> make_tags_in_proper_format(tags) DCNL "env": "development", DCNL Returns: DCNL Dict'
def make_tags_in_aws_format(tags): DCNL 'Take a dictionary of tags and convert them into the AWS Tags format. DCNL Args: DCNL tags (dict): The tags you want applied. DCNL Basic Usage: DCNL >>> tags = {\'env\': \'development\', \'service\': \'web\'} DCNL >>> make_tags_in_proper_format(tags) DCNL "Value": "web", DCNL "Key": "service" DCNL "Value": "development", DCNL "key": "env" DCNL Returns: DCNL List'
def get_tags(client, stream_name, check_mode=False): DCNL 'Retrieve the tags for a Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): Name of the Kinesis stream. DCNL Kwargs: DCNL check_mode (bool): This will pass DryRun as one of the parameters to the aws api. DCNL default=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >> get_tags(client, stream_name) DCNL Returns: DCNL Tuple (bool, str, dict)'
def find_stream(client, stream_name, check_mode=False): DCNL 'Retrieve a Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): Name of the Kinesis stream. DCNL Kwargs: DCNL check_mode (bool): This will pass DryRun as one of the parameters to the aws api. DCNL default=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL Returns: DCNL Tuple (bool, str, dict)'
def wait_for_status(client, stream_name, status, wait_timeout=300, check_mode=False): DCNL 'Wait for the the status to change for a Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL stream_name (str): The name of the kinesis stream. DCNL status (str): The status to wait for. DCNL examples. status=available, status=deleted DCNL Kwargs: DCNL wait_timeout (int): Number of seconds to wait, until this timeout is reached. DCNL check_mode (bool): This will pass DryRun as one of the parameters to the aws api. DCNL default=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> wait_for_status(client, stream_name, \'ACTIVE\', 300) DCNL Returns: DCNL Tuple (bool, str, dict)'
def tags_action(client, stream_name, tags, action='create', check_mode=False): DCNL 'Create or delete multiple tags from a Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL resource_id (str): The Amazon resource id. DCNL tags (list): List of dictionaries. DCNL examples.. [{Name: "", Values: [""]}] DCNL Kwargs: DCNL action (str): The action to perform. DCNL valid actions == create and delete DCNL default=create DCNL check_mode (bool): This will pass DryRun as one of the parameters to the aws api. DCNL default=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> resource_id = \'pcx-123345678\' DCNL >>> tags = {\'env\': \'development\'} DCNL >>> update_tags(client, resource_id, tags) DCNL [True, \'\'] DCNL Returns: DCNL List (bool, str)'
def recreate_tags_from_list(list_of_tags): DCNL 'Recreate tags from a list of tuples into the Amazon Tag format. DCNL Args: DCNL list_of_tags (list): List of tuples. DCNL Basic Usage: DCNL >>> list_of_tags = [(\'Env\', \'Development\')] DCNL >>> recreate_tags_from_list(list_of_tags) DCNL "Value": "Development", DCNL "Key": "Env" DCNL Returns: DCNL List'
def update_tags(client, stream_name, tags, check_mode=False): DCNL 'Update tags for an amazon resource. DCNL Args: DCNL resource_id (str): The Amazon resource id. DCNL tags (dict): Dictionary of tags you want applied to the Kinesis stream. DCNL Kwargs: DCNL check_mode (bool): This will pass DryRun as one of the parameters to the aws api. DCNL default=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> stream_name = \'test-stream\' DCNL >>> tags = {\'env\': \'development\'} DCNL >>> update_tags(client, stream_name, tags) DCNL [True, \'\'] DCNL Return: DCNL Tuple (bool, str)'
def stream_action(client, stream_name, shard_count=1, action='create', timeout=300, check_mode=False): DCNL 'Create or Delete an Amazon Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The name of the kinesis stream. DCNL Kwargs: DCNL shard_count (int): Number of shards this stream will use. DCNL action (str): The action to perform. DCNL valid actions == create and delete DCNL default=create DCNL check_mode (bool): This will pass DryRun as one of the parameters to the aws api. DCNL default=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> shard_count = 20 DCNL >>> stream_action(client, stream_name, shard_count, action=\'create\') DCNL Returns: DCNL List (bool, str)'
def retention_action(client, stream_name, retention_period=24, action='increase', check_mode=False): DCNL 'Increase or Decreaste the retention of messages in the Kinesis stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The DCNL Kwargs: DCNL retention_period (int): This is how long messages will be kept before DCNL they are discarded. This can not be less than 24 hours. DCNL action (str): The action to perform. DCNL valid actions == create and delete DCNL default=create DCNL check_mode (bool): This will pass DryRun as one of the parameters to the aws api. DCNL default=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> retention_period = 48 DCNL >>> stream_action(client, stream_name, retention_period, action=\'create\') DCNL Returns: DCNL Tuple (bool, str)'
def update(client, current_stream, stream_name, retention_period=None, tags=None, wait=False, wait_timeout=300, check_mode=False): DCNL 'Update an Amazon Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The name of the kinesis stream. DCNL Kwargs: DCNL retention_period (int): This is how long messages will be kept before DCNL they are discarded. This can not be less than 24 hours. DCNL tags (dict): The tags you want applied. DCNL wait (bool): Wait until Stream is ACTIVE. DCNL default=False DCNL wait_timeout (int): How long to wait until this operation is considered failed. DCNL default=300 DCNL check_mode (bool): This will pass DryRun as one of the parameters to the aws api. DCNL default=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> current_stream = { DCNL \'HasMoreShards\': True, DCNL \'RetentionPeriodHours\': 24, DCNL \'StreamName\': \'test-stream\', DCNL \'StreamARN\': \'arn:aws:kinesis:us-west-2:123456789:stream/test-stream\', DCNL \'StreamStatus\': "ACTIVE\' DCNL >>> stream_name = \'test-stream\' DCNL >>> retention_period = 48 DCNL >>> stream_action(client, current_stream, stream_name, DCNL retention_period, action=\'create\' ) DCNL Returns: DCNL Tuple (bool, bool, str)'
def create_stream(client, stream_name, number_of_shards=1, retention_period=None, tags=None, wait=False, wait_timeout=300, check_mode=False): DCNL 'Create an Amazon Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The name of the kinesis stream. DCNL Kwargs: DCNL number_of_shards (int): Number of shards this stream will use. DCNL default=1 DCNL retention_period (int): Can not be less than 24 hours DCNL default=None DCNL tags (dict): The tags you want applied. DCNL default=None DCNL wait (bool): Wait until Stream is ACTIVE. DCNL default=False DCNL wait_timeout (int): How long to wait until this operation is considered failed. DCNL default=300 DCNL check_mode (bool): This will pass DryRun as one of the parameters to the aws api. DCNL default=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> number_of_shards = 10 DCNL >>> tags = {\'env\': \'test\'} DCNL >>> create_stream(client, stream_name, number_of_shards, tags=tags) DCNL Returns: DCNL Tuple (bool, bool, str, dict)'
def delete_stream(client, stream_name, wait=False, wait_timeout=300, check_mode=False): DCNL 'Delete an Amazon Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The name of the kinesis stream. DCNL Kwargs: DCNL wait (bool): Wait until Stream is ACTIVE. DCNL default=False DCNL wait_timeout (int): How long to wait until this operation is considered failed. DCNL default=300 DCNL check_mode (bool): This will pass DryRun as one of the parameters to the aws api. DCNL default=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> delete_stream(client, stream_name) DCNL Returns: DCNL Tuple (bool, bool, str, dict)'
def find_subnets(vpc_conn, vpc_id, identified_subnets): DCNL 'Finds a list of subnets, each identified either by a raw ID, a unique DCNL \'Name\' tag, or a CIDR such as 10.0.0.0/8. DCNL Note that this function is duplicated in other ec2 modules, and should DCNL potentially be moved into potentially be moved into a shared module_utils'
def find_igw(vpc_conn, vpc_id): DCNL 'Finds the Internet gateway for the given VPC ID. DCNL Raises an AnsibleIgwSearchException if either no IGW can be found, or more DCNL than one found for the given VPC. DCNL Note that this function is duplicated in other ec2 modules, and should DCNL potentially be moved into potentially be moved into a shared module_utils'
def get_block_device_mapping(image): DCNL 'Retrieves block device mapping from AMI'
def boto_exception(err): DCNL 'boto error message handler'
def build_kwargs(registry_id): DCNL 'Builds a kwargs dict which may contain the optional registryId. DCNL :param registry_id: Optional string containing the registryId. DCNL :return: kwargs dict with registryId, if given'
def convert_to_lower(data): DCNL 'Convert all uppercase keys in dict with lowercase_ DCNL Args: DCNL data (dict): Dictionary with keys that have upper cases in them DCNL Example.. FooBar == foo_bar DCNL if a val is of type datetime.datetime, it will be converted to DCNL the ISO 8601 DCNL Basic Usage: DCNL >>> test = {\'FooBar\': []} DCNL >>> test = convert_to_lower(test) DCNL \'foo_bar\': [] DCNL Returns: DCNL Dictionary'
def get_nat_gateways(client, subnet_id=None, nat_gateway_id=None, states=None, check_mode=False): DCNL 'Retrieve a list of NAT Gateways DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL Kwargs: DCNL subnet_id (str): The subnet_id the nat resides in. DCNL nat_gateway_id (str): The Amazon nat id. DCNL states (list): States available (pending, failed, available, deleting, and deleted) DCNL default=None DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> subnet_id = \'subnet-12345678\' DCNL >>> get_nat_gateways(client, subnet_id) DCNL true, DCNL "nat_gateway_id": "nat-123456789", DCNL "subnet_id": "subnet-123456789", DCNL "nat_gateway_addresses": [ DCNL "public_ip": "55.55.55.55", DCNL "network_interface_id": "eni-1234567", DCNL "private_ip": "10.0.0.102", DCNL "allocation_id": "eipalloc-1234567" DCNL "state": "deleted", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "delete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_id": "vpc-12345678" DCNL Returns: DCNL Tuple (bool, str, list)'
def wait_for_status(client, wait_timeout, nat_gateway_id, status, check_mode=False): DCNL 'Wait for the NAT Gateway to reach a status DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL wait_timeout (int): Number of seconds to wait, until this timeout is reached. DCNL nat_gateway_id (str): The Amazon nat id. DCNL status (str): The status to wait for. DCNL examples. status=available, status=deleted DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> subnet_id = \'subnet-12345678\' DCNL >>> allocation_id = \'eipalloc-12345678\' DCNL >>> wait_for_status(client, subnet_id, allocation_id) DCNL true, DCNL "nat_gateway_id": "nat-123456789", DCNL "subnet_id": "subnet-1234567", DCNL "nat_gateway_addresses": [ DCNL "public_ip": "55.55.55.55", DCNL "network_interface_id": "eni-1234567", DCNL "private_ip": "10.0.0.102", DCNL "allocation_id": "eipalloc-12345678" DCNL "state": "deleted", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "delete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_id": "vpc-12345677" DCNL Returns: DCNL Tuple (bool, str, dict)'
def gateway_in_subnet_exists(client, subnet_id, allocation_id=None, check_mode=False): DCNL 'Retrieve all NAT Gateways for a subnet. DCNL Args: DCNL subnet_id (str): The subnet_id the nat resides in. DCNL Kwargs: DCNL allocation_id (str): The EIP Amazon identifier. DCNL default = None DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> subnet_id = \'subnet-1234567\' DCNL >>> allocation_id = \'eipalloc-1234567\' DCNL >>> gateway_in_subnet_exists(client, subnet_id, allocation_id) DCNL "nat_gateway_id": "nat-123456789", DCNL "subnet_id": "subnet-123456789", DCNL "nat_gateway_addresses": [ DCNL "public_ip": "55.55.55.55", DCNL "network_interface_id": "eni-1234567", DCNL "private_ip": "10.0.0.102", DCNL "allocation_id": "eipalloc-1234567" DCNL "state": "deleted", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "delete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_id": "vpc-1234567" DCNL False DCNL Returns: DCNL Tuple (list, bool)'
def get_eip_allocation_id_by_address(client, eip_address, check_mode=False): DCNL 'Release an EIP from your EIP Pool DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL eip_address (str): The Elastic IP Address of the EIP. DCNL Kwargs: DCNL check_mode (bool): if set to true, do not run anything and DCNL falsify the results. DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> eip_address = \'52.87.29.36\' DCNL >>> get_eip_allocation_id_by_address(client, eip_address) DCNL \'eipalloc-36014da3\' DCNL Returns: DCNL Tuple (str, str)'
def allocate_eip_address(client, check_mode=False): DCNL 'Release an EIP from your EIP Pool DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL Kwargs: DCNL check_mode (bool): if set to true, do not run anything and DCNL falsify the results. DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> allocate_eip_address(client) DCNL True DCNL Returns: DCNL Tuple (bool, str)'
def release_address(client, allocation_id, check_mode=False): DCNL 'Release an EIP from your EIP Pool DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL allocation_id (str): The eip Amazon identifier. DCNL Kwargs: DCNL check_mode (bool): if set to true, do not run anything and DCNL falsify the results. DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> allocation_id = "eipalloc-123456" DCNL >>> release_address(client, allocation_id) DCNL True DCNL Returns: DCNL Boolean, string'
def create(client, subnet_id, allocation_id, client_token=None, wait=False, wait_timeout=0, if_exist_do_not_create=False, check_mode=False): DCNL 'Create an Amazon NAT Gateway. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL subnet_id (str): The subnet_id the nat resides in. DCNL allocation_id (str): The eip Amazon identifier. DCNL Kwargs: DCNL if_exist_do_not_create (bool): if a nat gateway already exists in this DCNL subnet, than do not create another one. DCNL default = False DCNL wait (bool): Wait for the nat to be in the deleted state before returning. DCNL default = False DCNL wait_timeout (int): Number of seconds to wait, until this timeout is reached. DCNL default = 0 DCNL client_token (str): DCNL default = None DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> subnet_id = \'subnet-1234567\' DCNL >>> allocation_id = \'eipalloc-1234567\' DCNL >>> create(client, subnet_id, allocation_id, if_exist_do_not_create=True, wait=True, wait_timeout=500) DCNL true, DCNL "nat_gateway_id": "nat-123456789", DCNL "subnet_id": "subnet-1234567", DCNL "nat_gateway_addresses": [ DCNL "public_ip": "55.55.55.55", DCNL "network_interface_id": "eni-1234567", DCNL "private_ip": "10.0.0.102", DCNL "allocation_id": "eipalloc-1234567" DCNL "state": "deleted", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "delete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_id": "vpc-1234567" DCNL Returns: DCNL Tuple (bool, str, list)'
def pre_create(client, subnet_id, allocation_id=None, eip_address=None, if_exist_do_not_create=False, wait=False, wait_timeout=0, client_token=None, check_mode=False): DCNL 'Create an Amazon NAT Gateway. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL subnet_id (str): The subnet_id the nat resides in. DCNL Kwargs: DCNL allocation_id (str): The EIP Amazon identifier. DCNL default = None DCNL eip_address (str): The Elastic IP Address of the EIP. DCNL default = None DCNL if_exist_do_not_create (bool): if a nat gateway already exists in this DCNL subnet, than do not create another one. DCNL default = False DCNL wait (bool): Wait for the nat to be in the deleted state before returning. DCNL default = False DCNL wait_timeout (int): Number of seconds to wait, until this timeout is reached. DCNL default = 0 DCNL client_token (str): DCNL default = None DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> subnet_id = \'subnet-w4t12897\' DCNL >>> allocation_id = \'eipalloc-36014da3\' DCNL >>> pre_create(client, subnet_id, allocation_id, if_exist_do_not_create=True, wait=True, wait_timeout=500) DCNL true, DCNL "nat_gateway_id": "nat-03835afb6e31df79b", DCNL "subnet_id": "subnet-w4t12897", DCNL "nat_gateway_addresses": [ DCNL "public_ip": "52.87.29.36", DCNL "network_interface_id": "eni-5579742d", DCNL "private_ip": "10.0.0.102", DCNL "allocation_id": "eipalloc-36014da3" DCNL "state": "deleted", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "delete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_id": "vpc-w68571b5" DCNL Returns: DCNL Tuple (bool, bool, str, list)'
def remove(client, nat_gateway_id, wait=False, wait_timeout=0, release_eip=False, check_mode=False): DCNL 'Delete an Amazon NAT Gateway. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL nat_gateway_id (str): The Amazon nat id. DCNL Kwargs: DCNL wait (bool): Wait for the nat to be in the deleted state before returning. DCNL wait_timeout (int): Number of seconds to wait, until this timeout is reached. DCNL release_eip (bool): Once the nat has been deleted, you can deallocate the eip from the vpc. DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> nat_gw_id = \'nat-03835afb6e31df79b\' DCNL >>> remove(client, nat_gw_id, wait=True, wait_timeout=500, release_eip=True) DCNL true, DCNL "nat_gateway_id": "nat-03835afb6e31df79b", DCNL "subnet_id": "subnet-w4t12897", DCNL "nat_gateway_addresses": [ DCNL "public_ip": "52.87.29.36", DCNL "network_interface_id": "eni-5579742d", DCNL "private_ip": "10.0.0.102", DCNL "allocation_id": "eipalloc-36014da3" DCNL "state": "deleted", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "delete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_id": "vpc-w68571b5" DCNL Returns: DCNL Tuple (bool, str, list)'
def fix_return(node): DCNL 'fixup returned dictionary DCNL :param node: DCNL :return:'
def alias_details(client, module): DCNL 'Returns list of aliases for a specified function. DCNL :param client: AWS API client reference (boto3) DCNL :param module: Ansible module reference DCNL :return dict:'
def all_details(client, module): DCNL 'Returns all lambda related facts. DCNL :param client: AWS API client reference (boto3) DCNL :param module: Ansible module reference DCNL :return dict:'
def config_details(client, module): DCNL 'Returns configuration details for one or all lambda functions. DCNL :param client: AWS API client reference (boto3) DCNL :param module: Ansible module reference DCNL :return dict:'
def mapping_details(client, module): DCNL 'Returns all lambda event source mappings. DCNL :param client: AWS API client reference (boto3) DCNL :param module: Ansible module reference DCNL :return dict:'
def policy_details(client, module): DCNL 'Returns policy attached to a lambda function. DCNL :param client: AWS API client reference (boto3) DCNL :param module: Ansible module reference DCNL :return dict:'
def version_details(client, module): DCNL 'Returns all lambda function versions. DCNL :param client: AWS API client reference (boto3) DCNL :param module: Ansible module reference DCNL :return dict:'
def main(): DCNL 'Main entry point. DCNL :return dict: ansible facts'
def get_block_device_mapping(image): DCNL 'Retrieves block device mapping from AMI'
def create_image(module, ec2): DCNL 'Creates new AMI DCNL module : AnsibleModule object DCNL ec2: authenticated ec2 connection object'
def deregister_image(module, ec2): DCNL 'Deregisters AMI'
def update_image(module, ec2, image_id): DCNL 'Updates AMI'
def pc(key): DCNL 'Changes python key into Pascale case equivalent. For example, \'this_function_name\' becomes \'ThisFunctionName\'. DCNL :param key: DCNL :return:'
def ordered_obj(obj): DCNL 'Order object for comparison purposes DCNL :param obj: DCNL :return:'
def set_api_sub_params(params): DCNL 'Sets module sub-parameters to those expected by the boto3 API. DCNL :param params: DCNL :return:'
def validate_params(module, aws): DCNL 'Performs basic parameter validation. DCNL :param module: DCNL :param aws: DCNL :return:'
def get_qualifier(module): DCNL 'Returns the function qualifier as a version or alias or None. DCNL :param module: DCNL :return:'
def lambda_event_stream(module, aws): DCNL 'Adds, updates or deletes lambda stream (DynamoDb, Kinesis) event notifications. DCNL :param module: DCNL :param aws: DCNL :return:'
def main(): DCNL 'Produce a list of function suffixes which handle lambda events.'
def find_address(ec2, public_ip, device_id, isinstance=True): DCNL 'Find an existing Elastic IP address'
def address_is_associated_with_device(ec2, address, device_id, isinstance=True): DCNL 'Check if the elastic IP is currently associated with the device'
def allocate_address(ec2, domain, reuse_existing_ip_allowed): DCNL 'Allocate a new elastic IP address (when needed) and return it'
def release_address(ec2, address, check_mode): DCNL 'Release a previously allocated elastic IP address'
def find_device(ec2, module, device_id, isinstance=True): DCNL 'Attempt to find the EC2 instance and return it'
def find_asgs(conn, module, name=None, tags=None): DCNL 'Args: DCNL conn (boto3.AutoScaling.Client): Valid Boto3 ASG client. DCNL name (str): Optional name of the ASG you are looking for. DCNL tags (dict): Optional dictionary of tags and values to search for. DCNL Basic Usage: DCNL >>> name = \'public-webapp-production\' DCNL >>> tags = { \'env\': \'production\' } DCNL >>> conn = boto3.client(\'autoscaling\', region_name=\'us-west-2\') DCNL >>> results = find_asgs(name, conn) DCNL Returns: DCNL List DCNL "auto_scaling_group_arn": "arn:aws:autoscaling:us-west-2:275977225706:autoScalingGroup:58abc686-9783-4528-b338-3ad6f1cbbbaf:autoScalingGroupName/public-webapp-production", DCNL "auto_scaling_group_name": "public-webapp-production", DCNL "availability_zones": ["us-west-2c", "us-west-2b", "us-west-2a"], DCNL "created_time": "2016-02-02T23:28:42.481000+00:00", DCNL "default_cooldown": 300, DCNL "desired_capacity": 2, DCNL "enabled_metrics": [], DCNL "health_check_grace_period": 300, DCNL "health_check_type": "ELB", DCNL "instances": DCNL "availability_zone": "us-west-2c", DCNL "health_status": "Healthy", DCNL "instance_id": "i-047a12cb", DCNL "launch_configuration_name": "public-webapp-production-1", DCNL "lifecycle_state": "InService", DCNL "protected_from_scale_in": false DCNL "availability_zone": "us-west-2a", DCNL "health_status": "Healthy", DCNL "instance_id": "i-7a29df2c", DCNL "launch_configuration_name": "public-webapp-production-1", DCNL "lifecycle_state": "InService", DCNL "protected_from_scale_in": false DCNL "launch_configuration_name": "public-webapp-production-1", DCNL "load_balancer_names": ["public-webapp-production-lb"], DCNL "max_size": 4, DCNL "min_size": 2, DCNL "new_instances_protected_from_scale_in": false, DCNL "placement_group": None, DCNL "status": None, DCNL "suspended_processes": [], DCNL "tags": DCNL "key": "Name", DCNL "propagate_at_launch": true, DCNL "resource_id": "public-webapp-production", DCNL "resource_type": "auto-scaling-group", DCNL "value": "public-webapp-production" DCNL "key": "env", DCNL "propagate_at_launch": true, DCNL "resource_id": "public-webapp-production", DCNL "resource_type": "auto-scaling-group", DCNL "value": "production" DCNL "termination_policies": DCNL "Default" DCNL "vpc_zone_identifier": DCNL "subnet-a1b1c1d1", DCNL "subnet-a2b2c2d2", DCNL "subnet-a3b3c3d3"'
def change_keys(recs, key='uuid', filter_func=None): DCNL 'Take a xapi dict, and make the keys the value of recs[ref][key]. DCNL Preserves the ref in rec[\'ref\']'
def get_host(session): DCNL 'Get the host'
def convert_time(time): DCNL 'Convert a time in seconds into the biggest unit'
def main(): DCNL 'Main function DCNL :return: None'
def main(): DCNL 'Main function DCNL :return: None'
def main(): DCNL 'The main function.  Instantiates the module and calls process_request. DCNL :return: none'
def main(): DCNL 'The main function.  Instantiates the module and calls process_request. DCNL :return: none'
def main(): DCNL 'The main function.  Instantiates the module and calls process_request. DCNL :return: none'
def main(): DCNL 'The main function.  Instantiates the module and calls process_request. DCNL :return: none'
def main(): DCNL 'The main function.  Instantiates the module and calls process_request. DCNL :return: none'
def main(): DCNL 'The main function.  Instantiates the module and calls process_request. DCNL :return: none'
def main(): DCNL 'The main function.  Instantiates the module and calls process_request. DCNL :return: none'
def main(): DCNL 'The main function.  Instantiates the module and calls process_request. DCNL :return: none'
def main(): DCNL 'Ansible Main module.'
def main(): DCNL 'Ansible Main module.'
def _check_params(params, field_list): DCNL 'Helper to validate params. DCNL Use this in function definitions if they require specific fields DCNL to be present. DCNL :param params: structure that contains the fields DCNL :type params: ``dict`` DCNL :param field_list: list of dict representing the fields DCNL [{\'name\': str, \'required\': True/False\', \'type\': cls}] DCNL :type field_list: ``list`` of ``dict`` DCNL :return True, exits otherwise DCNL :rtype: ``bool``'
def _validate_autoscaling_params(params): DCNL 'Validate that the minimum configuration is present for autoscaling. DCNL :param params: Ansible dictionary containing autoscaling configuration DCNL It is expected that autoscaling config will be found at the DCNL key \'autoscaling\'. DCNL :type  params: ``dict`` DCNL :return: Tuple containing a boolean and a string.  True if autoscaler DCNL is valid, False otherwise, plus str for message. DCNL :rtype: ``(``bool``, ``str``)``'
def _validate_named_port_params(params): DCNL 'Validate the named ports parameters DCNL :param params: Ansible dictionary containing named_ports configuration DCNL It is expected that autoscaling config will be found at the DCNL key \'named_ports\'.  That key should contain a list of DCNL {name : port} dictionaries. DCNL :type  params: ``dict`` DCNL :return: Tuple containing a boolean and a string.  True if params DCNL are valid, False otherwise, plus str for message. DCNL :rtype: ``(``bool``, ``str``)``'
def _get_instance_list(mig, field='name', filter_list=['NONE']): DCNL 'Helper to grab field from instances response. DCNL :param mig: Managed Instance Group Object from libcloud. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :param field: Field name in list_managed_instances response.  Defaults DCNL to \'name\'. DCNL :type  field: ``str`` DCNL :param filter_list: list of \'currentAction\' strings to filter on.  Only DCNL items that match a currentAction in this list will DCNL be returned.  Default is "[\'NONE\']". DCNL :type  filter_list: ``list`` of ``str`` DCNL :return: List of strings from list_managed_instances response. DCNL :rtype: ``list``'
def _gen_gce_as_policy(as_params): DCNL 'Take Autoscaler params and generate GCE-compatible policy. DCNL :param as_params: Dictionary in Ansible-playbook format DCNL containing policy arguments. DCNL :type as_params: ``dict`` DCNL :return: GCE-compatible policy dictionary DCNL :rtype: ``dict``'
def create_autoscaler(gce, mig, params): DCNL 'Create a new Autoscaler for a MIG. DCNL :param gce: An initialized GCE driver object. DCNL :type gce:  :class: `GCENodeDriver` DCNL :param mig: An initialized GCEInstanceGroupManager. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :param params: Dictionary of autoscaling parameters. DCNL :type params:  ``dict`` DCNL :return: Tuple with changed stats. DCNL :rtype: tuple in the format of (bool, list)'
def update_autoscaler(gce, autoscaler, params): DCNL 'Update an Autoscaler. DCNL Takes an existing Autoscaler object, and updates it with DCNL the supplied params before calling libcloud\'s update method. DCNL :param gce: An initialized GCE driver object. DCNL :type gce:  :class: `GCENodeDriver` DCNL :param autoscaler: An initialized GCEAutoscaler. DCNL :type  autoscaler:  :class: `GCEAutoscaler` DCNL :param params: Dictionary of autoscaling parameters. DCNL :type params:  ``dict`` DCNL :return: True if changes, False otherwise. DCNL :rtype: ``bool``'
def delete_autoscaler(autoscaler): DCNL 'Delete an Autoscaler.  Does not affect MIG. DCNL :param mig: Managed Instance Group Object from Libcloud. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :return: Tuple with changed stats and a list of affected instances. DCNL :rtype: tuple in the format of (bool, list)'
def get_autoscaler(gce, name, zone): DCNL 'Get an Autoscaler from GCE. DCNL If the Autoscaler is not found, None is found. DCNL :param gce: An initialized GCE driver object. DCNL :type gce:  :class: `GCENodeDriver` DCNL :param name: Name of the Autoscaler. DCNL :type name:  ``str`` DCNL :param zone: Zone that the Autoscaler is located in. DCNL :type zone:  ``str`` DCNL :return: A GCEAutoscaler object or None. DCNL :rtype: :class: `GCEAutoscaler` or None'
def create_mig(gce, params): DCNL 'Create a new Managed Instance Group. DCNL :param gce: An initialized GCE driver object. DCNL :type gce:  :class: `GCENodeDriver` DCNL :param params: Dictionary of parameters needed by the module. DCNL :type params:  ``dict`` DCNL :return: Tuple with changed stats and a list of affected instances. DCNL :rtype: tuple in the format of (bool, list)'
def delete_mig(mig): DCNL 'Delete a Managed Instance Group.  All VMs in that MIG are also deleted." DCNL :param mig: Managed Instance Group Object from Libcloud. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :return: Tuple with changed stats and a list of affected instances. DCNL :rtype: tuple in the format of (bool, list)'
def recreate_instances_in_mig(mig): DCNL 'Recreate the instances for a Managed Instance Group. DCNL :param mig: Managed Instance Group Object from libcloud. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :return: Tuple with changed stats and a list of affected instances. DCNL :rtype: tuple in the format of (bool, list)'
def resize_mig(mig, size): DCNL 'Resize a Managed Instance Group. DCNL Based on the size provided, GCE will automatically create and delete DCNL VMs as needed. DCNL :param mig: Managed Instance Group Object from libcloud. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :return: Tuple with changed stats and a list of affected instances. DCNL :rtype: tuple in the format of (bool, list)'
def get_mig(gce, name, zone): DCNL 'Get a Managed Instance Group from GCE. DCNL If the MIG is not found, None is found. DCNL :param gce: An initialized GCE driver object. DCNL :type gce:  :class: `GCENodeDriver` DCNL :param name: Name of the Managed Instance Group. DCNL :type name:  ``str`` DCNL :param zone: Zone that the Managed Instance Group is located in. DCNL :type zone:  ``str`` DCNL :return: A GCEInstanceGroupManager object or None. DCNL :rtype: :class: `GCEInstanceGroupManager` or None'
def update_named_ports(mig, named_ports): DCNL 'Set the named ports on a Managed Instance Group. DCNL Sort the existing named ports and new.  If different, update. DCNL This also implicitly allows for the removal of named_por DCNL :param mig: Managed Instance Group Object from libcloud. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :param named_ports: list of dictionaries in the format of {\'name\': port} DCNL :type named_ports: ``list`` of ``dict`` DCNL :return: True if successful DCNL :rtype: ``bool``'
def transform_headers(headers): DCNL 'Boto url-encodes values unless we convert the value to `str`, so doing DCNL this prevents \'max-age=100000\' from being converted to "max-age%3D100000". DCNL :param headers: Headers to convert DCNL :type  headers: dict DCNL :rtype: dict'
def _union_items(baselist, comparelist): DCNL 'Combine two lists, removing duplicates.'
def _intersect_items(baselist, comparelist): DCNL 'Return matching items in both lists.'
def _get_changed_items(baselist, comparelist): DCNL 'Return changed items as they relate to baselist.'
def modify_tags(gce, module, node, tags, state='present'): DCNL 'Modify tags on an instance.'
def create_zone(module, gcdns, zone): DCNL 'Creates a new Google Cloud DNS zone.'
def remove_zone(module, gcdns, zone): DCNL 'Removes an existing Google Cloud DNS zone.'
def _get_zone(gcdns, zone_name): DCNL 'Gets the zone object for a given domain name.'
def _sanity_check(module): DCNL 'Run module sanity checks.'
def main(): DCNL 'Main function'
def format_allowed_section(allowed): DCNL 'Format each section of the allowed list'
def format_allowed(allowed): DCNL 'Format the \'allowed\' value so that it is GCE compatible.'
def sorted_allowed_list(allowed_list): DCNL 'Sort allowed_list (output of format_allowed) by protocol and port.'
def get_instance_info(inst): DCNL 'Retrieves instance information from an instance object and returns it DCNL as a dictionary.'
def create_instances(module, gce, instance_names, number): DCNL 'Creates new instances. Attributes other than instance_names are picked DCNL up from \'module\' DCNL module : AnsibleModule object DCNL gce: authenticated GCE libcloud driver DCNL instance_names: python list of instance names to create DCNL Returns: DCNL A list of dictionaries with instance information DCNL about the instances that were launched.'
def change_instance_state(module, gce, instance_names, number, zone_name, state): DCNL 'Changes the state of a list of instances. For example, DCNL change from started to stopped, or started to absent. DCNL module: Ansible module object DCNL gce: authenticated GCE connection object DCNL instance_names: a list of instance names to terminate DCNL zone_name: the zone where the instances reside prior to termination DCNL state: \'state\' parameter passed into module as argument DCNL Returns a dictionary of instance names that were changed.'
def create_record(module, gcdns, zone, record): DCNL 'Creates or overwrites a resource record.'
def remove_record(module, gcdns, record): DCNL 'Remove a resource record.'
def _get_record(gcdns, zone, record_type, record_name): DCNL 'Gets the record object for a given FQDN.'
def _get_zone(gcdns, zone_name, zone_id): DCNL 'Gets the zone object for a given domain name.'
def _records_match(old_ttl, old_record_data, new_ttl, new_record_data): DCNL 'Checks to see if original and new TTL and values match.'
def _sanity_check(module): DCNL 'Run sanity checks that don\'t depend on info from the zone/record.'
def _additional_sanity_checks(module, zone): DCNL 'Run input sanity checks that depend on info from the zone/record.'
def main(): DCNL 'Main function'
def create_image(gce, name, module): DCNL 'Create an image with the specified name.'
def delete_image(gce, name, module): DCNL 'Delete a specific image resource by name.'
def randompass(): DCNL 'Generate a long random password that comply to Linode requirements'
def getInstanceDetails(api, server): DCNL 'Return the details of an instance, populating IPs, etc.'
def get_pid_location(module): DCNL 'Try to find a pid directory in the common locations, falling DCNL back to the user\'s home directory if no others exist'
def _convert_host_to_ip(host): DCNL 'Perform forward DNS resolution on host, IP will give the same IP DCNL Args: DCNL host: String with either hostname, IPv4, or IPv6 address DCNL Returns: DCNL List of tuples containing address family and IP'
def _convert_host_to_hex(host): DCNL 'Convert the provided host to the format in /proc/net/tcp* DCNL /proc/net/tcp uses little-endian four byte hex for ipv4 DCNL /proc/net/tcp6 uses little-endian per 4B word for ipv6 DCNL Args: DCNL host: String with either hostname, IPv4, or IPv6 address DCNL Returns: DCNL List of tuples containing address family and the DCNL little-endian converted host'
def _create_connection(host, port, connect_timeout): DCNL 'Connect to a 2-tuple (host, port) and return DCNL the socket object. DCNL Args: DCNL 2-tuple (host, port) and connection timeout DCNL Returns: DCNL Socket object'
def _filter_non_json_lines(data): DCNL 'Used to filter unrelated output around module JSON output, like messages from DCNL tcagetattr, or where dropbear spews MOTD on every single command (which is nuts). DCNL Filters leading lines before first line-starting occurrence of \'{\' or \'[\', and filter all DCNL trailing lines after matching close character (working from the bottom of output).'
def query_log_status(module, le_path, path, state='present'): DCNL 'Returns whether a log is followed or not.'
def follow_log(module, le_path, logs, name=None, logtype=None): DCNL 'Follows one or more logs if not already followed.'
def unfollow_log(module, le_path, logs): DCNL 'Unfollows one or more logs if followed.'
def send_deploy_event(module, key, revision_id, deployed_by='Ansible', deployed_to=None, repository=None): DCNL 'Send a deploy event to Stackdriver'
def send_annotation_event(module, key, msg, annotated_by='Ansible', level=None, instance_id=None, event_epoch=None): DCNL 'Send an annotation event to Stackdriver'
def selector(module): DCNL 'Figure out which object and which actions DCNL to take given the right parameters'
def post_annotation(annotation, api_key): DCNL 'Takes annotation dict and api_key string'
def create_annotation(module): DCNL 'Takes ansible module object'
def build_headers(api_token): DCNL 'Takes api token, returns headers with it included.'
def main(): DCNL 'Main function, dispatches logic'
def selector(module): DCNL 'Figure out which object and which actions DCNL to take given the right parameters'
def get_state(b_path): DCNL 'Find out current state'
def assemble_from_fragments(src_path, delimiter=None, compiled_regexp=None, ignore_hidden=False): DCNL 'assemble a file from a directory of fragments'
def split_pre_existing_dir(dirname): DCNL 'Return the first pre-existing directory and a list of the new directories that will be created.'
def adjust_recursive_directory_permissions(pre_existing_dir, new_directory_list, module, directory_args, changed): DCNL 'Walk the new directories list and make sure that permissions are as we would expect'
def crc32(path): DCNL 'Return a CRC32 checksum of a file'
def shell_escape(string): DCNL 'Quote meta-characters in the args for the unix shell'
def split_entry(entry): DCNL 'splits entry and ensures normalized return'
def build_entry(etype, entity, permissions=None, use_nfsv4_acls=False): DCNL 'Builds and returns an entry string. Does not include the permissions bit if they are not provided.'
def build_command(module, mode, path, follow, default, recursive, entry=''): DCNL 'Builds and returns a getfacl/setfacl command.'
def acl_changed(module, cmd): DCNL 'Returns true if the provided command affects the existing ACLs, false otherwise.'
def pfilter(f, patterns=None, use_regex=False): DCNL 'filter using glob patterns'
def agefilter(st, now, age, timestamp): DCNL 'filter files older than age'
def sizefilter(st, size): DCNL 'filter files greater than size'
def contentfilter(fsname, pattern): DCNL 'filter files which contain the given expression'
def get_user_diff(ipa_user, module_user): DCNL 'Return the keys of each dict whereas values are different. Unfortunately the IPA DCNL API returns everything as a list even if only a single value is possible. DCNL Therefore some more complexity is needed. DCNL The method will check if the value type of module_user.attr is not a list and DCNL create a list with that element if the same attribute in ipa_user is list. In this way I hope that the method DCNL must not be changed if the returned API dict is changed. DCNL :param ipa_user: DCNL :param module_user: DCNL :return:'
def get_ssh_key_fingerprint(ssh_key): DCNL 'Return the public key fingerprint of a given public SSH key DCNL in format "FB:0C:AC:0A:07:94:5B:CE:75:6E:63:32:13:AD:AD:D7 [user@host] (ssh-rsa)" DCNL :param ssh_key: DCNL :return:'
def _load_dist_subclass(cls, *args, **kwargs): DCNL 'Used for derivative implementations'
def action_handler(action_func, action_func_args): DCNL 'Function to wrap calls to make actions on firewalld in try/except DCNL logic and emit (hopefully) useful error messages'
def _escape_fstab(v): DCNL 'Escape invalid characters in fstab fields. DCNL space (040) DCNL ampersand (046) DCNL backslash (134)'
def set_mount(module, args): DCNL 'Set/change a mount point location in fstab.'
def unset_mount(module, args): DCNL 'Remove a mount point from fstab.'
def mount(module, args): DCNL 'Mount up a path or remount if needed.'
def umount(module, path): DCNL 'Unmount a path.'
def remount(module, mount_bin, args): DCNL 'will try to use -o remount first and fallback to unmount/mount if unsupported'
def is_bind_mounted(module, linux_mounts, dest, src=None, fstype=None): DCNL 'Return whether the dest is bind mounted DCNL :arg module: The AnsibleModule (used for helper functions) DCNL :arg dest: The directory to be mounted under. This is the primary means DCNL of identifying whether the destination is mounted. DCNL :kwarg src: The source directory. If specified, this is used to help DCNL ensure that we are detecting that the correct source is mounted there. DCNL :kwarg fstype: The filesystem type. If specified this is also used to DCNL help ensure that we are detecting the right mount. DCNL :kwarg linux_mounts: Cached list of mounts for Linux. DCNL :returns: True if the dest is mounted with src otherwise False.'
def get_linux_mounts(module): DCNL 'Gather mount information'
def keyfile(module, user, write=False, path=None, manage_dir=True): DCNL 'Calculate name of authorized keys file, optionally creating the DCNL directories and file, properly setting permissions. DCNL :param str user: name of user in passwd file DCNL :param bool write: if True, write changes to authorized_keys file (creating directories if needed) DCNL :param str path: if not None, use provided path rather than default of \'~user/.ssh/authorized_keys\' DCNL :param bool manage_dir: if True, create and set ownership of the parent dir of the authorized_keys file DCNL :return: full path string to authorized_keys for user'
def parseoptions(module, options): DCNL 'reads a string containing ssh-key options DCNL and returns a dictionary of those options'
def parsekey(module, raw_key, rank=None): DCNL 'parses a key, which may or may not contain a list DCNL of ssh-key options at the beginning DCNL rank indicates the keys original ordering, so that DCNL it can be written out in the same order.'
def enforce_state(module, params): DCNL 'Add or remove key.'
def _get_dev_size(dev, module): DCNL 'Return size in bytes of device. Returns int'
def _get_fs_size(fssize_cmd, dev, module): DCNL 'Return size in bytes of filesystem on device. Returns int'
def is_available(name, ubuntuMode): DCNL 'Check if the given locale is available on the system. This is done by DCNL checking either : DCNL * if the locale is present in /etc/locales.gen DCNL * or if the locale is present in /usr/share/i18n/SUPPORTED'
def is_present(name): DCNL 'Checks if the given locale is currently installed.'
def fix_case(name): DCNL 'locale -a might return the encoding in either lower or upper case. DCNL Passing through this function makes them uniform for comparisons.'
def replace_line(existing_line, new_line): DCNL 'Replaces lines in /etc/locale.gen'
def set_locale(name, enabled=True): DCNL 'Sets the state of the locale. Defaults to enabled.'
def apply_change(targetState, name): DCNL 'Create or remove locale. DCNL Keyword arguments: DCNL targetState -- Desired state, either present or absent. DCNL name -- Name including encoding such as de_CH.UTF-8.'
def apply_change_ubuntu(targetState, name): DCNL 'Create or remove locale. DCNL Keyword arguments: DCNL targetState -- Desired state, either present or absent. DCNL name -- Name including encoding such as de_CH.UTF-8.'
def run_command(command, module, check_rc=True): DCNL 'Run a command using the module, return DCNL the result code and std{err,out} content. DCNL :param command: list of command arguments DCNL :param module: Ansible make module instance DCNL :return: return code, stdout content, stderr content'
def sanitize_output(output): DCNL 'Sanitize the output string before we DCNL pass it to module.fail_json. Defaults DCNL the string to empty if it is None, else DCNL strips trailing newlines. DCNL :param output: output to sanitize DCNL :return: sanitized output'
def enforce_state(module, params): DCNL 'Add or remove key.'
def sanity_check(module, host, key, sshkeygen): DCNL 'Check supplied key is sensible DCNL host and key are parameters provided by the user; If the host DCNL provided is inconsistent with the key supplied, then this function DCNL quits, providing an error to the user. DCNL sshkeygen is the path to ssh-keygen, found earlier with get_bin_path'
def search_for_host_key(module, host, key, hash_host, path, sshkeygen): DCNL 'search_for_host_key(module,host,key,path,sshkeygen) -> (found,replace_or_add,found_line) DCNL Looks up host and keytype in the known_hosts file path; if it\'s there, looks to see DCNL if one of those entries matches key. Returns: DCNL found (Boolean): is host found in path? DCNL replace_or_add (Boolean): is the key in path different to that supplied by user? DCNL found_line (int or None): the line where a key of the same type was found DCNL if found=False, then replace is always False. DCNL sshkeygen is the path to ssh-keygen, found earlier with get_bin_path'
def normalize_known_hosts_key(key): DCNL 'Transform a key, either taken from a known_host file or provided by the DCNL user, into a normalized form. DCNL The host part (which might include multiple hostnames or be hashed) gets DCNL replaced by the provided host. Also, any spurious information gets removed DCNL from the end (like the username@host tag usually present in hostkeys, but DCNL absent in known_hosts files)'
def semanage_fcontext_exists(sefcontext, target, ftype): DCNL 'Get the SELinux file context mapping definition from policy. Return None if it does not exist.'
def semanage_fcontext_modify(module, result, target, ftype, setype, do_reload, serange, seuser, sestore=''): DCNL 'Add or modify SELinux file context mapping definition to the policy.'
def semanage_fcontext_delete(module, result, target, ftype, do_reload, sestore=''): DCNL 'Delete SELinux file context mapping definition from the policy.'
def semanage_port_get_ports(seport, setype, proto): DCNL 'Get the list of ports that have the specified type definition. DCNL :param seport: Instance of seobject.portRecords DCNL :type setype: str DCNL :param setype: SELinux type. DCNL :type proto: str DCNL :param proto: Protocol (\'tcp\' or \'udp\') DCNL :rtype: list DCNL :return: List of ports that have the specified SELinux type.'
def semanage_port_get_type(seport, port, proto): DCNL 'Get the SELinux type of the specified port. DCNL :param seport: Instance of seobject.portRecords DCNL :type port: str DCNL :param port: Port or port range (example: "8080", "8080-9090") DCNL :type proto: str DCNL :param proto: Protocol (\'tcp\' or \'udp\') DCNL :rtype: tuple DCNL :return: Tuple containing the SELinux type and MLS/MCS level, or None if not found.'
def semanage_port_add(module, ports, proto, setype, do_reload, serange='s0', sestore=''): DCNL 'Add SELinux port type definition to the policy. DCNL :type module: AnsibleModule DCNL :param module: Ansible module DCNL :type ports: list DCNL :param ports: List of ports and port ranges to add (e.g. ["8080", "8080-9090"]) DCNL :type proto: str DCNL :param proto: Protocol (\'tcp\' or \'udp\') DCNL :type setype: str DCNL :param setype: SELinux type DCNL :type do_reload: bool DCNL :param do_reload: Whether to reload SELinux policy after commit DCNL :type serange: str DCNL :param serange: SELinux MLS/MCS range (defaults to \'s0\') DCNL :type sestore: str DCNL :param sestore: SELinux store DCNL :rtype: bool DCNL :return: True if the policy was changed, otherwise False'
def semanage_port_del(module, ports, proto, setype, do_reload, sestore=''): DCNL 'Delete SELinux port type definition from the policy. DCNL :type module: AnsibleModule DCNL :param module: Ansible module DCNL :type ports: list DCNL :param ports: List of ports and port ranges to delete (e.g. ["8080", "8080-9090"]) DCNL :type proto: str DCNL :param proto: Protocol (\'tcp\' or \'udp\') DCNL :type setype: str DCNL :param setype: SELinux type. DCNL :type do_reload: bool DCNL :param do_reload: Whether to reload SELinux policy after commit DCNL :type sestore: str DCNL :param sestore: SELinux store DCNL :rtype: bool DCNL :return: True if the policy was changed, otherwise False'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'main entry point for module execution'
def wakeonlan(module, mac, broadcast, port): DCNL 'Send a magic Wake-on-LAN packet.'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'main entry point for module execution'
def get_cli_body_ssh_vrf(module, command, response): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when using multiple |.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet.'
def validate_feature(module, mode='show'): DCNL 'Some features may need to be mapped due to inconsistency DCNL between how they appear from "show feature" output and DCNL how they are configured'
def get_boot_options(module): DCNL 'Get current boot variables DCNL like system image and kickstart image. DCNL Returns: DCNL A dictionary, e.g. { \'kick\': router_kick.img, \'sys\': \'router_sys.img\'}'
def set_boot_options(module, image_name, kickstart=None): DCNL 'Set boot variables DCNL like system image and kickstart image. DCNL Args: DCNL The main system image file name. DCNL Keyword Args: many implementors may choose DCNL to supply a kickstart parameter to specify a kickstart image.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh_vrf_interface(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API. As such, DCNL we assume if \'^\' is found in response, it is an invalid command. Instead, DCNL the output will be a raw string when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module, text=False): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.'
def get_cli_body_ssh_vrrp(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def is_default_interface(interface, module): DCNL 'Checks to see if interface exists and if it is a default config DCNL Args: DCNL interface (str): full name of interface, i.e. vlan10, DCNL Ethernet1/1, loopback10 DCNL Returns: DCNL True: if interface has default config DCNL False: if it does not have a default config DCNL DNE (str): if the interface does not exist - loopbacks, SVIs, etc.'
def get_interface_type(interface): DCNL 'Gets the type of interface DCNL Args: DCNL interface (str): full name of interface, i.e. Ethernet1/1, loopback10, DCNL port-channel20, vlan20 DCNL Returns: DCNL type of interface: ethernet, svi, loopback, management, portchannel, DCNL or unknown'
def get_manual_interface_attributes(interface, module): DCNL 'Gets admin state and description of a SVI interface. Hack due to API. DCNL Args: DCNL interface (str): full name of SVI interface, i.e. vlan10 DCNL Returns: DCNL dictionary that has two k/v pairs: admin_state & description DCNL if not an svi, returns None'
def get_interface(intf, module): DCNL 'Gets current config/state of interface DCNL Args: DCNL intf (string): full name of interface, i.e. Ethernet1/1, loopback10, DCNL port-channel20, vlan20 DCNL Returns: DCNL dictionary that has relevant config/state data about the given DCNL interface based on the type of interface it is'
def get_interfaces_dict(module): DCNL 'Gets all active interfaces on a given switch DCNL Returns: DCNL dictionary with interface type (ethernet,svi,loop,portchannel) as the DCNL keys.  Each value is a list of interfaces of given interface (key) DCNL type.'
def normalize_interface(if_name): DCNL 'Return the normalized interface name'
def get_interface_config_commands(interface, intf, existing): DCNL 'Generates list of commands to configure on device DCNL Args: DCNL interface (str): k/v pairs in the form of a set that should DCNL be configured on the device DCNL intf (str): full name of interface, i.e. Ethernet1/1 DCNL Returns: DCNL list: ordered list of commands to be sent to device'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet.'
def main(): DCNL 'main entry point for module execution'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, we assume if \'^\' is found in response, DCNL it is an invalid command.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def main(): DCNL 'main entry point for module execution'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def numerical_sort(string_int_list): DCNL 'Sort list of strings (VLAN IDs) that are digits in numerical order.'
def get_vlan_config_commands(vlan, vid): DCNL 'Build command list required for VLAN configuration'
def get_vlan(vlanid, module): DCNL 'Get instance of VLAN as a dictionary'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet.'
def main(): DCNL 'main entry point for module execution'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, we assume if \'^\' is found in response, DCNL it is an invalid command.'
def get_cli_body_ssh(command, response, module, text=False): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, we assume if \'^\' is found in response, DCNL it is an invalid command.'
def get_interface_type(interface): DCNL 'Gets the type of interface DCNL Args: DCNL interface (str): full name of interface, i.e. Ethernet1/1, loopback10, DCNL port-channel20, vlan20 DCNL Returns: DCNL type of interface: ethernet, svi, loopback, management, portchannel, DCNL or unknown'
def get_interface_mode(interface, module): DCNL 'Gets current mode of interface: layer2 or layer3 DCNL Args: DCNL device (Device): This is the device object of an NX-API enabled device DCNL using the Device class within device.py DCNL interface (string): full name of interface, i.e. Ethernet1/1, DCNL loopback10, port-channel20, vlan20 DCNL Returns: DCNL str: \'layer2\' or \'layer3\''
def interface_is_portchannel(interface, module): DCNL 'Checks to see if an interface is part of portchannel bundle DCNL Args: DCNL interface (str): full name of interface, i.e. Ethernet1/1 DCNL Returns: DCNL True/False based on if interface is a member of a portchannel bundle'
def get_switchport(port, module): DCNL 'Gets current config of L2 switchport DCNL Args: DCNL device (Device): This is the device object of an NX-API enabled device DCNL using the Device class within device.py DCNL port (str): full name of interface, i.e. Ethernet1/1 DCNL Returns: DCNL dictionary with k/v pairs for L2 vlan config'
def get_switchport_config_commands(interface, existing, proposed, module): DCNL 'Gets commands required to config a given switchport interface'
def is_switchport_default(existing): DCNL 'Determines if switchport has a default config based on mode DCNL Args: DCNL existing (dict): existing switchport configuration from Ansible mod DCNL Returns: DCNL boolean: True if switchport has OOB Layer 2 config, i.e. DCNL vlan 1 and trunk all and mode is access'
def numerical_sort(string_int_list): DCNL 'Sorts list of strings/integers that are digits in numerical order.'
def get_cli_body_ssh(command, response, module): DCNL 'Get response for when transport=cli.  This is kind of a hack and mainly DCNL needed because these modules were originally written for NX-API.  And DCNL not every command supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valid command, but that the DCNL resource doesn\'t exist yet. Instead, the output will be a raw string DCNL when issuing commands containing \'show run\'.'
def build_desired_iface_config(module): DCNL 'take parameters defined and build ifupdown2 compatible hash'
def config_dict_changed(module): DCNL 'return true if \'config\' dict in hash is different DCNL between desired and current config'
def config_changed(module): DCNL 'returns true if config has changed'
def add_glob_to_array(_bondmems): DCNL 'goes through each bond member if it sees a dash add glob DCNL before it'
def build_desired_iface_config(module): DCNL 'take parameters defined and build ifupdown2 compatible hash'
def config_dict_changed(module): DCNL 'return true if \'config\' dict in hash is different DCNL between desired and current config'
def config_changed(module): DCNL 'returns true if config has changed'
def add_glob_to_array(_bridgemems): DCNL 'goes through each bridge member if it sees a dash add glob DCNL before it'
def build_desired_iface_config(module): DCNL 'take parameters defined and build ifupdown2 compatible hash'
def config_dict_changed(module): DCNL 'return true if \'config\' dict in hash is different DCNL between desired and current config'
def config_changed(module): DCNL 'returns true if config has changed'
def write_to_ports_conf(module): DCNL 'use tempfile to first write out config in temp file DCNL then write to actual location. may help prevent file DCNL corruption. Ports.conf is a critical file for Cumulus. DCNL Don\'t want to corrupt this file under any circumstance.'
def main(): DCNL 'Main entry point for AnsibleModule'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'main entry point for Ansible module'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'Main entry point for Ansible module execution'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'main entry point for module execution'
def main(): DCNL 'Main entry point for Ansible module execution'
def cmd_run(module, cmd, check_rc=True): DCNL 'Log and run ovs-vsctl command.'
def params_set(module): DCNL 'Implement the ovs-vsctl set commands.'
def main(): DCNL 'Entry point for ansible module.'
def truncate_before(value, srch): DCNL 'Return content of str before the srch parameters.'
def _set_to_get(set_cmd, module): DCNL 'Convert set command to get command and set value. DCNL return tuple (get command, set value)'
def main(): DCNL 'Entry point.'
def truncate_before(value, srch): DCNL 'Return content of str before the srch parameters.'
def _set_to_get(set_cmd, module): DCNL 'Convert set command to get command and set value. DCNL return tuple (get command, set value)'
def main(): DCNL 'Entry point.'
def pn_cli(module): DCNL 'This method is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, password, switch parameters from module. DCNL :param module: The Ansible module to fetch username, password and switch DCNL :return: returns the cli string for further processing'
def run_cli(module, cli): DCNL 'This method executes the cli command on the target node(s) and returns the DCNL output. The module then exits based on the output. DCNL :param cli: the complete cli string to be executed on the target node(s). DCNL :param module: The Ansible module to fetch command'
def main(): DCNL 'This section is for arguments parsing'
def pn_cli(module): DCNL 'This method is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, password, switch parameters from module. DCNL :param module: The Ansible module to fetch username, password and switch DCNL :return: returns the cli string for further processing'
def check_cli(module, cli): DCNL 'This method checks if vRouter exists on the target node. DCNL This method also checks for idempotency using the DCNL vrouter-loopback-interface-show command. DCNL If the given vRouter exists, return VROUTER_EXISTS as True else False. DCNL If a loopback interface with the given ip exists on the given vRouter, DCNL return LB_INTERFACE_EXISTS as True else False. DCNL :param module: The Ansible module to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VROUTER_EXISTS, LB_INTERFACE_EXISTS'
def run_cli(module, cli): DCNL 'This method executes the cli command on the target node(s) and returns the DCNL output. The module then exits based on the output. DCNL :param cli: the complete cli string to be executed on the target node(s). DCNL :param module: The Ansible module to fetch command'
def get_command_from_state(state): DCNL 'This method gets appropriate command name for the state specified. It DCNL returns the command name for the specified state. DCNL :param state: The state for which the respective command name is required.'
def main(): DCNL 'This portion is for arguments parsing'
def pn_cli(module): DCNL 'This method is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, password, switch parameters from module. DCNL :param module: The Ansible module to fetch username, password and switch DCNL :return: returns the cli string for further processing'
def check_cli(module, cli): DCNL 'This method checks for idempotency using the vlan-show command. DCNL A switch can have only one vRouter configuration. DCNL If a vRouter already exists on the given switch, return VROUTER_EXISTS as DCNL True else False. DCNL If a vRouter with the given name exists(on a different switch), return DCNL VROUTER_NAME_EXISTS as True else False. DCNL :param module: The Ansible module to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VROUTER_EXISTS, VROUTER_NAME_EXISTS'
def run_cli(module, cli): DCNL 'This method executes the cli command on the target node(s) and returns the DCNL output. The module then exits based on the output. DCNL :param cli: the complete cli string to be executed on the target node(s). DCNL :param module: The Ansible module to fetch command'
def get_command_from_state(state): DCNL 'This method gets appropriate command name for the state specified. It DCNL returns the command name for the specified state. DCNL :param state: The state for which the respective command name is required.'
def main(): DCNL 'This section is for arguments parsing'
def pn_cli(module): DCNL 'This method is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, password, switch parameters from module. DCNL :param module: The Ansible module to fetch username, password and switch DCNL :return: returns the cli string for further processing'
def check_cli(module, cli): DCNL 'This method checks if vRouter exists on the target node. DCNL This method also checks for idempotency using the vrouter-interface-show DCNL command. DCNL If the given vRouter exists, return VROUTER_EXISTS as True else False. DCNL If an interface with the given ip exists on the given vRouter, DCNL return INTERFACE_EXISTS as True else False. This is required for DCNL vrouter-interface-add. DCNL If nic_str exists on the given vRouter, return NIC_EXISTS as True else DCNL False. This is required for vrouter-interface-remove. DCNL :param module: The Ansible module to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VROUTER_EXISTS, INTERFACE_EXISTS, NIC_EXISTS'
def get_nic(module, cli): DCNL 'This module checks if VRRP interface can be added. If No, return VRRP_EXISTS DCNL as True. DCNL If Yes, fetch the nic string from the primary interface and return nic and DCNL VRRP_EXISTS as False. DCNL :param module: DCNL :param cli: DCNL :return: nic, Global Boolean: VRRP_EXISTS'
def run_cli(module, cli): DCNL 'This method executes the cli command on the target node(s) and returns the DCNL output. The module then exits based on the output. DCNL :param cli: the complete cli string to be executed on the target node(s). DCNL :param module: The Ansible module to fetch command'
def get_command_from_state(state): DCNL 'This method gets appropriate command name for the state specified. It DCNL returns the command name for the specified state. DCNL :param state: The state for which the respective command name is required.'
def main(): DCNL 'This portion is for arguments parsing'
def pn_cli(module): DCNL 'This method is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, password, switch parameters from module. DCNL :param module: The Ansible module to fetch username, password and switch DCNL :return: returns the cli string for further processing'
def check_cli(module, cli): DCNL 'This method checks if vRouter exists on the target node. DCNL This method also checks for idempotency using the vrouter-bgp-show command. DCNL If the given vRouter exists, return VROUTER_EXISTS as True else False. DCNL If a BGP neighbor with the given ip exists on the given vRouter, DCNL return NEIGHBOR_EXISTS as True else False. DCNL :param module: The Ansible module to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VROUTER_EXISTS, NEIGHBOR_EXISTS'
def run_cli(module, cli): DCNL 'This method executes the cli command on the target node(s) and returns the DCNL output. The module then exits based on the output. DCNL :param cli: the complete cli string to be executed on the target node(s). DCNL :param module: The Ansible module to fetch command'
def get_command_from_state(state): DCNL 'This method gets appropriate command name for the state specified. It DCNL returns the command name for the specified state. DCNL :param state: The state for which the respective command name is required.'
def main(): DCNL 'This portion is for arguments parsing'
def pn_cli(module): DCNL 'This method is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, password, switch parameters from module. DCNL :param module: The Ansible module to fetch username, password and switch DCNL :return: returns the cli string for further processing'
def check_cli(module, cli): DCNL 'This method checks for idempotency using the cluster-show command. DCNL If a cluster with given name exists, return NAME_EXISTS as True else False. DCNL If the given cluster-node-1 is already a part of another cluster, return DCNL NODE1_EXISTS as True else False. DCNL If the given cluster-node-2 is already a part of another cluster, return DCNL NODE2_EXISTS as True else False. DCNL :param module: The Ansible module to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: NAME_EXISTS, NODE1_EXISTS, NODE2_EXISTS'
def run_cli(module, cli): DCNL 'This method executes the cli command on the target node(s) and returns the DCNL output. The module then exits based on the output. DCNL :param cli: the complete cli string to be executed on the target node(s). DCNL :param module: The Ansible module to fetch command'
def get_command_from_state(state): DCNL 'This method gets appropriate command name for the state specified. It DCNL returns the command name for the specified state. DCNL :param state: The state for which the respective command name is required.'
def main(): DCNL 'This section is for arguments parsing'
def pn_cli(module): DCNL 'This method is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, password, switch parameters from module. DCNL :param module: The Ansible module to fetch username, password and switch DCNL :return: returns the cli string for further processing'
def check_cli(module, cli): DCNL 'This method checks for idempotency using the trunk-show command. DCNL If a trunk with given name exists, return TRUNK_EXISTS as True else False. DCNL :param module: The Ansible module to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: TRUNK_EXISTS'
def run_cli(module, cli): DCNL 'This method executes the cli command on the target node(s) and returns the DCNL output. The module then exits based on the output. DCNL :param cli: the complete cli string to be executed on the target node(s). DCNL :param module: The Ansible module to fetch command'
def get_command_from_state(state): DCNL 'This method gets appropriate command name for the state specified. It DCNL returns the command name for the specified state. DCNL :param state: The state for which the respective command name is required.'
def main(): DCNL 'This portion is for arguments parsing'
def pn_cli(module): DCNL 'This method is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, password, switch parameters from module. DCNL :param module: The Ansible module to fetch username, password and switch DCNL :return: returns the cli string for further processing'
def check_cli(module, cli): DCNL 'This method checks if vRouter exists on the target node. DCNL This method also checks for idempotency using the vrouter-ospf-show command. DCNL If the given vRouter exists, return VROUTER_EXISTS as True else False. DCNL If an OSPF network with the given ip exists on the given vRouter, DCNL return NETWORK_EXISTS as True else False. DCNL :param module: The Ansible module to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VROUTER_EXISTS, NETWORK_EXISTS'
def run_cli(module, cli): DCNL 'This method executes the cli command on the target node(s) and returns the DCNL output. The module then exits based on the output. DCNL :param cli: the complete cli string to be executed on the target node(s). DCNL :param module: The Ansible module to fetch command'
def get_command_from_state(state): DCNL 'This method gets appropriate command name for the state specified. It DCNL returns the command name for the specified state. DCNL :param state: The state for which the respective command name is required.'
def main(): DCNL 'This section is for arguments parsing'
def pn_cli(module): DCNL 'This method is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, password, switch parameters from module. DCNL :param module: The Ansible module to fetch username, password and switch DCNL :return: returns the cli string for further processing'
def check_cli(module, cli): DCNL 'This method checks for idempotency using the vlag-show command. DCNL If a vlag with given vlag exists, return VLAG_EXISTS as True else False. DCNL :param module: The Ansible module to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VLAG_EXISTS'
def run_cli(module, cli): DCNL 'This method executes the cli command on the target node(s) and returns the DCNL output. The module then exits based on the output. DCNL :param cli: the complete cli string to be executed on the target node(s). DCNL :param module: The Ansible module to fetch command'
def get_command_from_state(state): DCNL 'This method gets appropriate command name for the state specified. It DCNL returns the command name for the specified state. DCNL :param state: The state for which the respective command name is required.'
def main(): DCNL 'This section is for argument parsing'
def pn_cli(module): DCNL 'This method is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, password, switch parameters from module. DCNL :param module: The Ansible module to fetch username, password and switch DCNL :return: returns the cli string for further processing'
def check_cli(module, cli): DCNL 'This method checks for idempotency using the vlan-show command. DCNL If a vlan with given vlan id exists, return VLAN_EXISTS as True else False. DCNL :param module: The Ansible module to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VLAN_EXISTS'
def run_cli(module, cli): DCNL 'This method executes the cli command on the target node(s) and returns the DCNL output. The module then exits based on the output. DCNL :param cli: the complete cli string to be executed on the target node(s). DCNL :param module: The Ansible module to fetch command'
def get_command_from_state(state): DCNL 'This method gets appropriate command name for the state specified. It DCNL returns the command name for the specified state. DCNL :param state: The state for which the respective command name is required.'
def main(): DCNL 'This section is for arguments parsing'
def get_command_from_state(state): DCNL 'This method gets appropriate command name for the state specified. It DCNL returns the command name for the specified state. DCNL :param state: The state for which the respective command name is required.'
def main(): DCNL 'This section is for arguments parsing'
def url_get(module, url, dest, use_proxy, last_mod_time, force, timeout=10, headers=None, tmp_dest=''): DCNL 'Download data from the url and store in a temporary file. DCNL Return (tempfile, info about the request)'
def extract_filename_from_headers(headers): DCNL 'Extracts a filename from the given dict of HTTP headers. DCNL Looks for the content-disposition header and applies a regex. DCNL Returns the filename if successful, else None.'
def absolute_location(url, location): DCNL 'Attempts to create an absolute URL based on initial URL, and DCNL next URL, specifically in the case of a ``Location`` header.'
def main(): DCNL 'main entry point for module execution'
def to_lines(stdout): DCNL 'to lines'
def parse_commands(module): DCNL 'parse commands'
def main(): DCNL 'main'
def send_msg(msg, server='localhost', port='6667', channel=None, nick_to=[], key=None, topic=None, nick='ansible', color='none', passwd=False, timeout=30, use_ssl=False, part=True, style=None): DCNL 'send message to IRC'
def send_message(module, client_id, client_secret, topic, msg): DCNL 'send message to typetalk'
def escape_quotes(text): DCNL 'Backslash any quotes within text.'
def send_msg_v1(module, token, room, msg_from, msg, msg_format='text', color='yellow', notify=False, api=MSG_URI_V1): DCNL 'sending message to hipchat v1 server'
def send_msg_v2(module, token, room, msg_from, msg, msg_format='text', color='yellow', notify=False, api=NOTIFY_URI_V2): DCNL 'sending message to hipchat v2 server'
def get_cert_days(module, cert_file): DCNL 'Return the days the certificate in cert_file remains valid and -1 DCNL if the file was not found.'
def write_file(module, dest, content): DCNL 'Write content to destination file dest, only if the content DCNL has changed.'
def regexp_extraction(string, _regexp, groups=1): DCNL 'Returns the capture group (default=1) specified in the regexp, applied to the string'
def main(): DCNL 'Initiates module.'
def present(dest, username, password, crypt_scheme, create, check_mode): DCNL 'Ensures user is present DCNL Returns (msg, changed)'
def absent(dest, username, check_mode): DCNL 'Ensures user is absent DCNL Returns (msg, changed)'
def manage_issue(module, taiga_host, project_name, issue_subject, issue_priority, issue_status, issue_type, issue_severity, issue_description, issue_attachment, issue_attachment_description, issue_tags, state, check_mode=False): DCNL 'Method that creates/deletes issues depending whether they exist and the state desired DCNL The credentials should be passed via environment variables: DCNL - TAIGA_TOKEN DCNL - TAIGA_USERNAME and TAIGA_PASSWORD DCNL Returns a tuple with these elements: DCNL - A boolean representing the success of the operation DCNL - A descriptive message DCNL - A dict with the issue attributes, in case of issue creation, otherwise empty dict'
def remove_value(module): DCNL 'remove the value associated with the given key. if the recurse parameter DCNL is set then any key prefixed with the given key will be removed.'
def add(module): DCNL 'adds a service or a check depending on supplied configuration'
def remove(module): DCNL 'removes a service or a check'
def add_check(module, check): DCNL 'registers a check with the given agent. currently there is no way DCNL retrieve the full metadata of an existing check  through the consul api. DCNL Without this we can\'t compare to the supplied check and so we must assume DCNL a change.'
def remove_check(module, check_id): DCNL 'removes a check using its id'
def add_service(module, service): DCNL 'registers a service with the the current agent'
def remove_service(module, service_id): DCNL 'deregister a service from the given agent using its service id'
def get_service_by_id_or_name(consul_api, service_id_or_name): DCNL 'iterate the registered services and find one with the given id'
@api_wrapper DCNL def get_pool(module, system): DCNL 'Return Pool or None'
@api_wrapper DCNL def get_volume(module, system): DCNL 'Return Volume or None'
@api_wrapper DCNL def create_volume(module, system): DCNL 'Create Volume'
@api_wrapper DCNL def update_volume(module, volume): DCNL 'Update Volume'
@api_wrapper DCNL def delete_volume(module, volume): DCNL 'Delete Volume'
@api_wrapper DCNL def get_pool(module, system): DCNL 'Return Pool or None'
@api_wrapper DCNL def get_filesystem(module, system): DCNL 'Return Filesystem or None'
@api_wrapper DCNL def create_filesystem(module, system): DCNL 'Create Filesystem'
@api_wrapper DCNL def update_filesystem(module, filesystem): DCNL 'Update Filesystem'
@api_wrapper DCNL def delete_filesystem(module, filesystem): DCNL 'Delete Filesystem'
@api_wrapper DCNL def get_filesystem(module, system): DCNL 'Return Filesystem or None'
@api_wrapper DCNL def get_export(module, filesystem, system): DCNL 'Retrun export if found. When not found return None'
@api_wrapper DCNL def update_export(module, export, filesystem, system): DCNL 'Create new filesystem or update existing one'
@api_wrapper DCNL def delete_export(module, export): DCNL 'Delete file system'
@api_wrapper DCNL def get_pool(module, system): DCNL 'Return Pool on None'
@api_wrapper DCNL def create_pool(module, system): DCNL 'Create Pool'
@api_wrapper DCNL def update_pool(module, system, pool): DCNL 'Update Pool'
@api_wrapper DCNL def delete_pool(module, pool): DCNL 'Delete Pool'
@api_wrapper DCNL def get_export(module, system): DCNL 'Retrun export if found. Fail module if not found'
@api_wrapper DCNL def update_client(module, export): DCNL 'Update export client list'
@api_wrapper DCNL def delete_client(module, export): DCNL 'Update export client list'
def head_splitter(headfile, remote, module=None, fail_on_error=False): DCNL 'Extract the head reference'
def get_version(module, git_path, dest, ref='HEAD'): DCNL 'samples the version of the git repo'
def clone(git_path, module, repo, dest, remote, depth, version, bare, reference, refspec, verify_commit): DCNL 'makes a new git repo if it does not already exist'
def reset(git_path, module, dest): DCNL 'Resets the index and working tree to HEAD. DCNL Discards any changes to tracked files in working DCNL tree since that commit.'
def get_diff(module, git_path, dest, repo, remote, depth, bare, before, after): DCNL 'Return the difference between 2 versions'
def get_head_branch(git_path, module, dest, remote, bare=False): DCNL 'Determine what branch HEAD is associated with.  This is partly DCNL taken from lib/ansible/utils/__init__.py.  It finds the correct DCNL path to .git/HEAD and reads from that file the branch that HEAD is DCNL associated with.  In the case of a detached HEAD, this will look DCNL up the branch in .git/refs/remotes/<remote>/HEAD.'
def get_remote_url(git_path, module, dest, remote): DCNL 'Return URL of remote source for repo.'
def set_remote_url(git_path, module, repo, dest, remote): DCNL 'updates repo from remote sources'
def fetch(git_path, module, repo, dest, version, remote, depth, bare, refspec, git_version_used): DCNL 'updates repo from remote sources'
def submodule_update(git_path, module, dest, track_submodules, force=False): DCNL 'init and update any submodules'
def set_remote_branch(git_path, module, dest, remote, version, depth): DCNL 'set refs for the remote branch version DCNL This assumes the branch does not yet exist locally and is therefore also not checked out. DCNL Can\'t use git remote set-branches, as it is not available in git 1.7.1 (centos6)'
def git_version(git_path, module): DCNL 'return the installed version of git'
def query_package(module, name): DCNL 'Search for the package by name. DCNL Possible return values: DCNL * "present"  - installed, no upgrade needed DCNL * "outdated" - installed, but can be upgraded DCNL * False      - not installed or not found'
def is_pubkey(string): DCNL 'Verifies if string is a pubkey'
def get_cache_mtime(): DCNL 'Return mtime of a valid apt cache file. DCNL Stat the apt cache file and if no cache file is found return 0 DCNL :returns: ``int``'
def get_updated_cache_time(): DCNL 'Return the mtime time stamp and the updated cache time. DCNL Always retrieve the mtime of the apt cache or set the `cache_mtime` DCNL variable to 0 DCNL :returns: ``tuple``'
def get_cache(module): DCNL 'Attempt to get the cache object and update till it works'
def split_name_version(name): DCNL 'splits of the package name and desired version DCNL example formats: DCNL - docker>=1.10 DCNL - apache=2.4 DCNL Allowed version specifiers: <, >, <=, >=, = DCNL Allowed version format: [0-9.-]* DCNL Also allows a prefix indicating remove "-", "~" or install "+"'
def get_installed_state(m, packages): DCNL 'get installed state of packages'
def get_cmd(m, subcommand): DCNL 'puts together the basic zypper command arguments with those passed to the module'
def package_present(m, name, want_latest): DCNL 'install and update (if want_latest) the packages in name_install, while removing the packages in name_remove'
def package_update_all(m): DCNL 'run update or patch on all available packages'
def package_absent(m, name): DCNL 'remove the packages in name'
def repo_refresh(m): DCNL 'update the repositories'
def update_package_db(module, opkg_path): DCNL 'Updates packages list.'
def query_package(module, opkg_path, name, state='present'): DCNL 'Returns whether a package is installed or not.'
def remove_packages(module, opkg_path, packages): DCNL 'Uninstalls one or more packages if installed.'
def install_packages(module, opkg_path, packages): DCNL 'Installs one or more packages if not already installed.'
def is_installed(xbps_output): DCNL 'Returns package install state'
def query_package(module, xbps_path, name, state='present'): DCNL 'Returns Package info'
def update_package_db(module, xbps_path): DCNL 'Returns True if update_package_db changed'
def upgrade(module, xbps_path): DCNL 'Returns true is full upgrade succeeds'
def remove_packages(module, xbps_path, packages): DCNL 'Returns true if package removal succeeds'
def install_packages(module, xbps_path, state, packages): DCNL 'Returns true if package install succeeds.'
def check_packages(module, xbps_path, packages, state): DCNL 'Returns change status of command'
def main(): DCNL 'Returns, calling appropriate command'
def _configure_base(module, base, conf_file, disable_gpg_check, installroot='/'): DCNL 'Configure the dnf Base object.'
def _specify_repositories(base, disablerepo, enablerepo): DCNL 'Enable and disable repositories matching the provided patterns.'
def _base(module, conf_file, disable_gpg_check, disablerepo, enablerepo, installroot): DCNL 'Return a fully configured dnf Base object.'
def _package_dict(package): DCNL 'Return a dictionary of information for the package.'
def list_items(module, base, command): DCNL 'List package info based on the command.'
def _mark_package_install(module, base, pkg_spec): DCNL 'Mark the package for install.'
def main(): DCNL 'The main function.'
def parse_key_id(key_id): DCNL 'validate the key_id and break it into segments DCNL :arg key_id: The key_id as supplied by the user.  A valid key_id will be DCNL 8, 16, or more hexadecimal chars with an optional leading ``0x``. DCNL :returns: The portion of key_id suitable for apt-key del, the portion DCNL suitable for comparisons with --list-public-keys, and the portion that DCNL can be used with --recv-key.  If key_id is long enough, these will be DCNL the last 8 characters of key_id, the last 16 characters, and all of DCNL key_id.  If key_id is not long enough, some of the values will be the DCNL same. DCNL * apt-key del <= 1.10 has a bug with key_id != 8 chars DCNL * apt-key adv --list-public-keys prints 16 chars DCNL * apt-key adv --recv-key can take more chars'
def shorten_key_ids(key_id_list): DCNL 'Takes a list of key ids, and converts them to the \'short\' format, DCNL by reducing them to their last 8 characters.'
def get_sorcery_ver(module): DCNL 'Get Sorcery version.'
def codex_fresh(codex, module): DCNL 'Check if grimoire collection is fresh enough.'
def codex_list(module): DCNL 'List valid grimoire collection.'
def update_sorcery(module): DCNL 'Update sorcery scripts. DCNL This runs \'sorcery update\' (\'sorcery -u\'). Check mode always returns a DCNL positive change value.'
def update_codex(module): DCNL 'Update grimoire collections. DCNL This runs \'scribe update\'. Check mode always returns a positive change DCNL value when \'cache_valid_time\' is used.'
def match_depends(module): DCNL 'Check for matching dependencies. DCNL This inspects spell\'s dependencies with the desired states and returns DCNL \'False\' if a recast is needed to match them. It also adds required lines DCNL to the system-wide depends file for proper recast procedure.'
def manage_spells(module): DCNL 'Cast or dispel spells. DCNL This manages the whole system (\'*\'), list or a single spell. Command \'cast\' DCNL is used to install or rebuild spells, while \'dispel\' takes care of theirs DCNL removal from the system.'
def _get_cmd(*args): DCNL 'Combines the non-interactive zypper command with arguments/subcommands'
def _parse_repos(module): DCNL 'parses the output of zypper --xmlout repos and return a parse repo dictionary'
def _repo_changes(realrepo, repocmp): DCNL 'Check whether the 2 given repos have different settings.'
def repo_exists(module, repodata, overwrite_multiple): DCNL 'Check whether the repository already exists. DCNL returns (exists, mod, old_repos) DCNL exists: whether a matching (name, URL) repo exists DCNL mod: whether there are changes compared to the existing repo DCNL old_repos: list of matching repos'
def addmodify_repo(module, repodata, old_repos, zypper_version, warnings): DCNL 'Adds the repo, removes old repos before, that would conflict.'
def remove_repo(module, repo): DCNL 'Removes the repo.'
def runrefreshrepo(module, auto_import_keys=False, shortname=None): DCNL 'Forces zypper to refresh repo metadata.'
def compare_package(version1, version2): DCNL 'Compare version packages. DCNL Return values: DCNL -1 first minor DCNL 0 equal DCNL 1 first greater'
def query_package(module, name, depot=None): DCNL 'Returns whether a package is installed or not and version.'
def remove_package(module, name): DCNL 'Uninstall package if installed.'
def install_package(module, depot, name): DCNL 'Install package if not already installed'
def a_valid_tap(tap): DCNL 'Returns True if the tap is valid.'
def already_tapped(module, brew_path, tap): DCNL 'Returns True if already tapped.'
def add_tap(module, brew_path, tap, url=None): DCNL 'Adds a single tap.'
def add_taps(module, brew_path, taps): DCNL 'Adds one or more taps.'
def remove_tap(module, brew_path, tap): DCNL 'Removes a single tap.'
def remove_taps(module, brew_path, taps): DCNL 'Removes one or more taps.'
def transaction_exists(pkglist): DCNL 'checks the package list to see if any packages are DCNL involved in an incomplete transaction'
def local_nvra(module, path): DCNL 'return nvra of a local rpm passed in'
def update_package_db(module, port_path): DCNL 'Updates packages list.'
def query_package(module, port_path, name, state='present'): DCNL 'Returns whether a package is installed or not.'
def remove_packages(module, port_path, packages): DCNL 'Uninstalls one or more packages if installed.'
def install_packages(module, port_path, packages): DCNL 'Installs one or more packages if not already installed.'
def activate_packages(module, port_path, packages): DCNL 'Activate a package if it\'s inactive.'
def deactivate_packages(module, port_path, packages): DCNL 'Deactivate a package if it\'s active.'
def init_layman(config=None): DCNL 'Returns the initialized ``LaymanAPI``. DCNL :param config: the layman\'s configuration to use (optional)'
def download_url(module, url, dest): DCNL ':param url: the URL to download DCNL :param dest: the absolute path of where to save the downloaded content to; DCNL it must be writable and not a directory DCNL :raises ModuleError'
def install_overlay(module, name, list_url=None): DCNL 'Installs the overlay repository. If not on the central overlays list, DCNL then :list_url of an alternative list must be provided. The list will be DCNL fetched and saved under ``%(overlay_defs)/%(name.xml)`` (location of the DCNL ``overlay_defs`` is read from the Layman\'s configuration). DCNL :param name: the overlay id DCNL :param list_url: the URL of the remote repositories list to look for the overlay DCNL definition (optional, default: None) DCNL :returns: True if the overlay was installed, or False if already exists DCNL (i.e. nothing has changed) DCNL :raises ModuleError'
def uninstall_overlay(module, name): DCNL 'Uninstalls the given overlay repository from the system. DCNL :param name: the overlay id to uninstall DCNL :returns: True if the overlay was uninstalled, or False if doesn\'t exist DCNL (i.e. nothing has changed) DCNL :raises ModuleError'
def sync_overlay(name): DCNL 'Synchronizes the specified overlay repository. DCNL :param name: the overlay repository id to sync DCNL :raises ModuleError'
def sync_overlays(): DCNL 'Synchronize all of the installed overlays. DCNL :raises ModuleError'
def get_version(pacman_output): DCNL 'Take pacman -Qi or pacman -Si output and get the Version'
def query_package(module, pacman_path, name, state='present'): DCNL 'Query the package status in both the local system and the repository. Returns a boolean to indicate if the package is installed, a second boolean to indicate if the package is up-to-date and a third boolean to indicate whether online information were available'
def get_local_version(pear_output): DCNL 'Take pear remoteinfo output and get the installed version'
def get_repository_version(pear_output): DCNL 'Take pear remote-info output and get the latest version'
def query_package(module, name, state='present'): DCNL 'Query the package status in both the local system and the repository. DCNL Returns a boolean to indicate if the package is installed, DCNL and a second boolean to indicate if the package is up-to-date.'
def _get_packages(module, pip, chdir): DCNL 'Return results of pip command to get packages.'
def _is_present(name, version, installed_pkgs, pkg_command): DCNL 'Return whether or not package is installed.'
def _get_package_info(module, package, env=None): DCNL 'This is only needed for special packages which do not show up in pip freeze DCNL pip and setuptools fall into this category. DCNL :returns: a string containing the version number if the package is DCNL installed.  None if the package is not installed.'
def is_encrypted(data): DCNL 'Test if this is vault encrypted data blob DCNL :arg data: a byte or text string to test whether it is recognized as vault DCNL encrypted data DCNL :returns: True if it is recognized.  Otherwise, False.'
def is_encrypted_file(file_obj, start_pos=0, count=(-1)): DCNL 'Test if the contents of a file obj are a vault encrypted data blob. DCNL :arg file_obj: A file object that will be read from. DCNL :kwarg start_pos: A byte offset in the file to start reading the header DCNL from.  Defaults to 0, the beginning of the file. DCNL :kwarg count: Read up to this number of bytes from the file to determine DCNL if it looks like encrypted vault data.  The default is -1, read to the DCNL end of file. DCNL :returns: True if the file looks like a vault file. Otherwise, False.'
def parse_kv(args, check_raw=False): DCNL 'Convert a string of key/value items to a dict. If any free-form params DCNL are found and the check_raw option is set to True, they will be added DCNL to a new parameter called \'_raw_params\'. If check_raw is not enabled, DCNL they will simply be ignored.'
def _get_quote_state(token, quote_char): DCNL 'the goal of this block is to determine if the quoted string DCNL is unterminated in which case it needs to be put back together'
def _count_jinja2_blocks(token, cur_depth, open_token, close_token): DCNL 'this function counts the number of opening/closing blocks for a DCNL given opening/closing type and adjusts the current depth for that DCNL block based on the difference'
def split_args(args): DCNL 'Splits args on whitespace, but intelligently reassembles DCNL those that may have been split over a jinja2 block or quotes. DCNL When used in a remote module, we won\'t ever have to be concerned about DCNL jinja2 blocks, however this function is/will be used in the DCNL core portions as well before the args are templated. DCNL example input: a=b c="foo bar" DCNL example output: [\'a=b\', \'c="foo bar"\'] DCNL Basically this is a variation shlex that has some more intelligence for DCNL how Ansible needs to use it.'
def unquote(data): DCNL 'removes first and last quotes from a string, if the string starts and ends with the same quotes'
def jsonify(result, format=False): DCNL 'format JSON output (uncompressed or uncompressed)'
def parse_address(address, allow_ranges=False): DCNL 'Takes a string and returns a (host, port) tuple. If the host is None, then DCNL the string could not be parsed as a host identifier with an optional port DCNL specification. If the port is None, then no port was specified. DCNL The host identifier may be a hostname (qualified or not), an IPv4 address, DCNL or an IPv6 address. If allow_ranges is True, then any of those may contain DCNL [x:y] range specifications, e.g. foo[1:3] or foo[0:5]-bar[x-z]. DCNL The port number is an optional :NN suffix on an IPv4 address or host name, DCNL or a mandatory :NN suffix on any square-bracketed expression: IPv6 address, DCNL IPv4 address, or host name. (This means the only way to specify a port for DCNL an IPv6 address is to enclose it in square brackets.)'
def _parse_params(term): DCNL 'Safely split parameter term to preserve spaces'
def make_rdata_dict(rdata): DCNL 'While the \'dig\' lookup plugin supports anything which dnspython supports DCNL out of the box, the following supported_types list describes which DCNL DNS query types we can convert to a dict. DCNL Note: adding support for RRSIG is hard work. :)'
def file_props(root, path): DCNL 'Returns dictionary with file properties, or return None on failure'
def _parse_parameters(term): DCNL 'Hacky parsing of params DCNL See https://github.com/ansible/ansible-modules-core/issues/1968#issuecomment-136842156 DCNL and the first_found lookup For how we want to fix this later'
def _read_password_file(b_path): DCNL 'Read the contents of a password file and return it DCNL :arg b_path: A byte string containing the path to the password file DCNL :returns: a text string containing the contents of the password file or DCNL None if no password file was present.'
def _gen_candidate_chars(characters): DCNL 'Generate a string containing all valid chars as defined by ``characters`` DCNL :arg characters: A list of character specs. The character specs are DCNL shorthand names for sets of characters like \'digits\', \'ascii_letters\', DCNL or \'punctuation\' or a string to be included verbatim. DCNL The values of each char spec can be: DCNL * a name of an attribute in the \'strings\' module (\'digits\' for example). DCNL The value of the attribute will be added to the candidate chars. DCNL * a string of characters. If the string isn\'t an attribute in \'string\' DCNL module, the string will be directly added to the candidate chars. DCNL For example:: DCNL characters=[\'digits\', \'?|\']`` DCNL will match ``string.digits`` and add all ascii digits.  ``\'?|\'`` will add DCNL the question mark and pipe characters directly. Return will be the string:: DCNL u\'0123456789?|\''
def _random_password(length=DEFAULT_LENGTH, chars=C.DEFAULT_PASSWORD_CHARS): DCNL 'Return a random password string of length containing only chars DCNL :kwarg length: The number of characters in the new password.  Defaults to 20. DCNL :kwarg chars: The characters to choose from.  The default is all ascii DCNL letters, ascii digits, and these symbols ``.,:-_`` DCNL .. note: this was moved from the old ansible utils code, as nothing DCNL else appeared to use it.'
def _random_salt(): DCNL 'Return a text string suitable for use as a salt for the hash functions we use to encrypt passwords.'
def _parse_content(content): DCNL 'parse our password data format into password and salt DCNL :arg content: The data read from the file DCNL :returns: password and salt'
def _format_content(password, salt, encrypt=True): DCNL 'Format the password and salt for saving DCNL :arg password: the plaintext password to save DCNL :arg salt: the salt to use when encrypting a password DCNL :arg encrypt: Whether the user requests that this password is encrypted. DCNL Note that the password is saved in clear.  Encrypt just tells us if we DCNL must save the salt value for idempotence.  Defaults to True. DCNL :returns: a text string containing the formatted information DCNL .. warning:: Passwords are saved in clear.  This is because the playbooks DCNL expect to get cleartext passwords from this lookup.'
def failed(*a, **kw): DCNL 'Test if task result yields failed'
def success(*a, **kw): DCNL 'Test if task result yields success'
def changed(*a, **kw): DCNL 'Test if task result yields changed'
def skipped(*a, **kw): DCNL 'Test if task result yields skipped'
def regex(value='', pattern='', ignorecase=False, multiline=False, match_type='search'): DCNL 'Expose `re` as a boolean filter using the `search` method by default. DCNL This is likely only useful for `search` and `match` which already DCNL have their own filters.'
def match(value, pattern='', ignorecase=False, multiline=False): DCNL 'Perform a `re.match` returning a boolean'
def search(value, pattern='', ignorecase=False, multiline=False): DCNL 'Perform a `re.search` returning a boolean'
def version_compare(value, version, operator='eq', strict=False): DCNL 'Perform a version comparison on a value'
def dict_diff(prv, nxt): DCNL 'Return a dict of keys that differ with another config object.'
def colorize(msg, color): DCNL 'Given a string add necessary codes to format the string.'
def to_yaml(a, *args, **kw): DCNL 'Make verbose, human readable yaml'
def to_nice_yaml(a, indent=4, *args, **kw): DCNL 'Make verbose, human readable yaml'
def to_json(a, *args, **kw): DCNL 'Convert the value to JSON'
def to_nice_json(a, indent=4, *args, **kw): DCNL 'Make verbose, human readable JSON'
def to_bool(a): DCNL 'return a bool for the arg'
def quote(a): DCNL 'return its argument quoted for shell usage'
def fileglob(pathname): DCNL 'return list of matched regular files for glob'
def regex_replace(value='', pattern='', replacement='', ignorecase=False): DCNL 'Perform a `re.sub` returning a string'
def regex_findall(value, regex, multiline=False, ignorecase=False): DCNL 'Perform re.findall and return the list of matches'
def regex_search(value, regex, *args, **kwargs): DCNL 'Perform re.search and return the list of matches or a backref'
def ternary(value, true_val, false_val): DCNL 'value ? true_val : false_val'
def regex_escape(string): DCNL 'Escape all regular expressions special characters from STRING.'
def failed(*a, **kw): DCNL 'Test if task result yields failed'
def success(*a, **kw): DCNL 'Test if task result yields success'
def changed(*a, **kw): DCNL 'Test if task result yields changed'
def skipped(*a, **kw): DCNL 'Test if task result yields skipped'
@environmentfilter DCNL def do_groupby(environment, value, attribute): DCNL 'Overridden groupby filter for jinja2, to address an issue with DCNL jinja2>=2.9.0,<2.9.5 where a namedtuple was returned which DCNL has repr that prevents ansible.template.safe_eval.safe_eval from being DCNL able to parse and eval the data. DCNL jinja2<2.9.0,>=2.9.5 is not affected, as <2.9.0 uses a tuple, and DCNL >=2.9.5 uses a standard tuple repr on the namedtuple. DCNL The adaptation here, is to run the jinja2 `do_groupby` function, and DCNL cast all of the namedtuples to a regular tuple. DCNL See https://github.com/ansible/ansible/issues/20098 DCNL We may be able to remove this in the future.'
def ipaddr(value, query='', version=False, alias='ipaddr'): DCNL 'Check if string is an IP address or network and filter it'
def ipsubnet(value, query='', index='x'): DCNL 'Manipulate IPv4/IPv6 subnets'
def nthhost(value, query=''): DCNL 'Get the nth host within a given network'
def slaac(value, query=''): DCNL 'Get the SLAAC address within given network'
def hwaddr(value, query='', alias='hwaddr'): DCNL 'Check if string is a HW/MAC address and filter it'
def ip4_hex(arg): DCNL 'Convert an IPv4 address to Hexadecimal notation'
def json_query(data, expr): DCNL 'Query data using jmespath query language ( http://jmespath.org ). Example: DCNL - debug: msg="{{ instance | json_query(tagged_instances[*].block_device_mapping.*.volume_id\') }}"'
def human_readable(size, isbits=False, unit=None): DCNL 'Return a human readable string'
def human_to_bytes(size, default_unit=None, isbits=False): DCNL 'Return bytes count from a human readable string'
def secure_hash_s(data, hash_func=sha1): DCNL 'Return a secure hash hex digest of data.'
def secure_hash(filename, hash_func=sha1): DCNL 'Return a secure hash hex digest of local file, None if file is not present or a directory.'
def unicode_wrap(func, *args, **kwargs): DCNL 'If a function returns a string, force it to be a text string. DCNL Use with partial to ensure that filter plugins will return text values.'
def get_docstring(filename, verbose=False): DCNL 'Search for assignment of the DOCUMENTATION and EXAMPLES variables DCNL in the given file. DCNL Parse DOCUMENTATION from YAML and return the YAML doc or None DCNL together with EXAMPLES, as plain text. DCNL DOCUMENTATION can be extended using documentation fragments DCNL loaded by the PluginLoader from the module_docs_fragments DCNL directory.'
def unfrackpath(path, follow=True): DCNL 'Returns a path that is free of symlinks (if follow=True), environment variables, relative path traversals and symbols (~) DCNL :arg path: A byte or text string representing a path to be canonicalized DCNL :arg follow: A boolean to indicate of symlinks should be resolved or not DCNL :raises UnicodeDecodeError: If the canonicalized version of the path DCNL contains non-utf8 byte sequences. DCNL :rtype: A text string (unicode on pyyhon2, str on python3). DCNL :returns: An absolute path with symlinks, environment variables, and tilde DCNL expanded.  Note that this does not check whether a path exists. DCNL example:: DCNL \'$HOME/../../var/mail\' becomes \'/var/spool/mail\''
def makedirs_safe(path, mode=None): DCNL 'Safe way to create dirs in muliprocess/thread environments. DCNL :arg path: A byte or text string representing a directory to be created DCNL :kwarg mode: If given, the mode to set the directory to DCNL :raises AnsibleError: If the directory cannot be created and does not already exists. DCNL :raises UnicodeDecodeError: if the path is not decodable in the utf-8 encoding.'
def stringc(text, color): DCNL 'String in color.'
def colorize(lead, num, color): DCNL 'Print \'lead\' = \'num\' in \'color\''
def _validate_mutable_mappings(a, b): DCNL 'Internal convenience function to ensure arguments are MutableMappings DCNL This checks that all arguments are MutableMappings or raises an error DCNL :raises AnsibleError: if one of the arguments is not a MutableMapping'
def combine_vars(a, b): DCNL 'Return a copy of dictionaries of variables based on configured hash behavior'
def merge_hash(a, b): DCNL 'Recursively merges hash b into a so that keys from b take precedence over keys from a'
def isidentifier(ident): DCNL 'Determines, if string is valid Python identifier using the ast module. DCNL Orignally posted at: http://stackoverflow.com/a/29586366'
def pct_to_int(value, num_items, min_value=1): DCNL 'Converts a given value to a percentage if specified as "x%", DCNL otherwise converts the given value to an integer.'
def shell_expand(path, expand_relative_paths=False): DCNL 'shell_expand is needed as os.path.expanduser does not work DCNL when path is None, which is the default for ANSIBLE_PRIVATE_KEY_FILE'
def get_config(p, section, key, env_var, default, value_type=None, expand_relative_paths=False): DCNL 'return a configuration variable with casting DCNL :arg p: A ConfigParser object to look for the configuration in DCNL :arg section: A section of the ini config that should be examined for this section. DCNL :arg key: The config key to get this config from DCNL :arg env_var: An Environment variable to check for the config var.  If DCNL this is set to None then no environment variable will be used. DCNL :arg default: A default value to assign to the config var if nothing else sets it. DCNL :kwarg value_type: The type of the value.  This can be any of the following strings: DCNL :boolean: sets the value to a True or False value DCNL :integer: Sets the value to an integer or raises a ValueType error DCNL :float: Sets the value to a float or raises a ValueType error DCNL :list: Treats the value as a comma separated list.  Split the value DCNL and return it as a python list. DCNL :none: Sets the value to None DCNL :path: Expands any environment variables and tilde\'s in the value. DCNL :tmp_path: Create a unique temporary directory inside of the directory DCNL specified by value and return its path. DCNL :pathlist: Treat the value as a typical PATH string.  (On POSIX, this DCNL means colon separated strings.)  Split the value and then expand DCNL each part for environment variables and tildes. DCNL :kwarg expand_relative_paths: for pathlist and path types, if this is set DCNL to True then also change any relative paths into absolute paths.  The DCNL default is False.'
def _get_config(p, section, key, env_var, default): DCNL 'helper function for get_config'
def load_config_file(): DCNL 'Load Config File order(first found is used): ENV, CWD, HOME, /etc/ansible'
def preprocess_vars(a): DCNL 'Ensures that vars contained in the parameter passed in are DCNL returned as a list of dictionaries, to ensure for instance DCNL that vars loaded from a file conform to an expected state.'
def strip_internal_keys(dirty): DCNL 'All keys stating with _ansible_ are internal, so create a copy of the \'dirty\' dict DCNL and remove them from the clean one before returning it'
def hash_params(params): DCNL 'Construct a data structure of parameters that is hashable. DCNL This requires changing any mutable data structures into immutable ones. DCNL We chose a frozenset because role parameters have to be unique. DCNL .. warning::  this does not handle unhashable scalars.  Two things DCNL mitigate that limitation: DCNL 1) There shouldn\'t be any unhashable scalars specified in the yaml DCNL 2) Our only choice would be to return an error anyway.'
def load_list_of_blocks(ds, play, parent_block=None, role=None, task_include=None, use_handlers=False, variable_manager=None, loader=None): DCNL 'Given a list of mixed task/block data (parsed from YAML), DCNL return a list of Block() objects, where implicit blocks DCNL are created for each bare Task.'
def load_list_of_tasks(ds, play, block=None, role=None, task_include=None, use_handlers=False, variable_manager=None, loader=None): DCNL 'Given a list of task datastructures (parsed from YAML), DCNL return a list of Task() or TaskInclude() objects.'
def load_list_of_roles(ds, play, current_role_path=None, variable_manager=None, loader=None): DCNL 'Loads and returns a list of RoleInclude objects from the datastructure DCNL list of role definitions'
def parseDatetime(value): DCNL 'Year and date: DCNL >>> parseDatetime("2000") DCNL (datetime.date(2000, 1, 1), u\'2000\') DCNL >>> parseDatetime("2004-01-02") DCNL datetime.date(2004, 1, 2) DCNL Timestamp: DCNL >>> parseDatetime("2004-01-02 18:10:45") DCNL datetime.datetime(2004, 1, 2, 18, 10, 45) DCNL >>> parseDatetime("2004-01-02 18:10:45") DCNL datetime.datetime(2004, 1, 2, 18, 10, 45) DCNL Timestamp with timezone: DCNL >>> parseDatetime(u\'Thu, 19 Jul 2007 09:03:57 +0000\') DCNL datetime.datetime(2007, 7, 19, 9, 3, 57, tzinfo=<TimezoneUTC delta=0, name=u\'UTC\'>) DCNL >>> parseDatetime(u\'Thu, 19 Jul 2007 09:03:57 +0200\') DCNL datetime.datetime(2007, 7, 19, 9, 3, 57, tzinfo=<Timezone delta=2:00:00, name=\'+0200\'>)'
def setLanguage(meta, key, value): DCNL '>>> setLanguage(None, None, "fre") DCNL <Language \'French\', code=\'fre\'> DCNL >>> setLanguage(None, None, u"ger") DCNL <Language \'German\', code=\'ger\'>'
def setTrackTotal(meta, key, total): DCNL '>>> setTrackTotal(None, None, "10") DCNL 10'
def extractMetadata(parser, quality=QUALITY_NORMAL): DCNL 'Create a Metadata class from a parser. Returns None if no metadata DCNL extractor does exist for the parser class.'
def computeCompressionRate(meta): DCNL 'Compute compression rate, sizes have to be in byte.'
def computeComprRate(meta, compr_size): DCNL 'Compute image compression rate. Skip size of color palette, focus on DCNL image pixels. Original size is width x height x bpp. Compressed size DCNL is an argument (in bits). DCNL Set "compr_data" with a string like "1.52x".'
def getBacktrace(empty='Empty DCSP backtrace.'): DCNL 'Try to get backtrace as string. DCNL Returns "Error while trying to get backtrace" on failure.'
def _getTerminalCharset(): DCNL 'Function used by getTerminalCharset() to get terminal charset. DCNL @see getTerminalCharset()'
def getTerminalCharset(): DCNL 'Guess terminal charset using differents tests: DCNL 1. Try locale.getpreferredencoding() DCNL 2. Try locale.nl_langinfo(CODESET) DCNL 3. Try sys.stdout.encoding DCNL 4. Otherwise, returns "ASCII" DCNL WARNING: Call initLocale() before calling this function.'
def guessBytesCharset(bytes, default=None): DCNL '>>> guessBytesCharset("abc") DCNL \'ASCII\' DCNL >>> guessBytesCharset("\xEF\xBB\xBFabc") DCNL \'UTF-8\' DCNL >>> guessBytesCharset("abc\xC3\xA9") DCNL \'UTF-8\' DCNL >>> guessBytesCharset("File written by Adobe Photoshop\xA8 4.0\0") DCNL \'MacRoman\' DCNL >>> guessBytesCharset("\xE9l\xE9phant") DCNL \'ISO-8859-1\' DCNL >>> guessBytesCharset("100 \xA4") DCNL \'ISO-8859-15\' DCNL >>> guessBytesCharset(\'Word \xb8\xea\xe4\xef\xf3\xe7 - Microsoft Outlook 97 - \xd1\xf5\xe8\xec\xdf\xf3\xe5\xe9\xf2 e-mail\') DCNL \'ISO-8859-7\''
def getMemoryLimit(): DCNL 'Get current memory limit in bytes. DCNL Return None on error.'
def setMemoryLimit(max_mem): DCNL 'Set memory limit in bytes. DCNL Use value \'None\' to disable memory limit. DCNL Return True if limit is set, False on error.'
def getMemorySize(): DCNL 'Read currenet process memory size: size of available virtual memory. DCNL This value is NOT the real memory usage. DCNL This function only works on Linux (use /proc/self/statm file).'
def clearCaches(): DCNL 'Try to clear all caches: call gc.collect() (Python garbage collector).'
def limitedMemory(limit, func, *args, **kw): DCNL 'Limit memory grow when calling func(*args, **kw): DCNL restrict memory grow to \'limit\' bytes. DCNL Use try/except MemoryError to catch the error.'
def getgaps(start, length, blocks): DCNL 'Example: DCNL >>> list(getgaps(0, 20, [(15,3), (6,2), (6,2), (1,2), (2,3), (11,2), (9,5)])) DCNL [(0, 1), (5, 1), (8, 1), (14, 1), (18, 2)]'
def createOrphanField(fieldset, address, field_cls, *args, **kw): DCNL 'Create an orphan field at specified address: DCNL field_cls(fieldset, *args, **kw) DCNL The field uses the fieldset properties but it isn\'t added to the DCNL field set.'
def Enum(field, enum, key_func=None): DCNL 'Enum is an adapter to another field: it will just change its display DCNL attribute. It uses a dictionnary to associate a value to another. DCNL key_func is an optional function with prototype "def func(key)->key" DCNL which is called to transform key.'
def deprecated(comment=None): DCNL 'This is a decorator which can be used to mark functions DCNL as deprecated. It will result in a warning being emmitted DCNL when the function is used. DCNL Examples: :: DCNL @deprecated DCNL def oldfunc(): ... DCNL @deprecated("use newfunc()!") DCNL def oldfunc2(): ... DCNL Code from: http://code.activestate.com/recipes/391367/'
def paddingSize(value, align): DCNL 'Compute size of a padding field. DCNL >>> paddingSize(31, 4) DCNL 1 DCNL >>> paddingSize(32, 4) DCNL 0 DCNL >>> paddingSize(33, 4) DCNL 3 DCNL Note: (value + paddingSize(value, align)) == alignValue(value, align)'
def alignValue(value, align): DCNL 'Align a value to next \'align\' multiple. DCNL >>> alignValue(31, 4) DCNL 32 DCNL >>> alignValue(32, 4) DCNL 32 DCNL >>> alignValue(33, 4) DCNL 36 DCNL Note: alignValue(value, align) == (value + paddingSize(value, align))'
def timedelta2seconds(delta): DCNL 'Convert a datetime.timedelta() objet to a number of second DCNL (floatting point number). DCNL >>> timedelta2seconds(timedelta(seconds=2, microseconds=40000)) DCNL 2.04 DCNL >>> timedelta2seconds(timedelta(minutes=1, milliseconds=250)) DCNL 60.25'
def humanDurationNanosec(nsec): DCNL 'Convert a duration in nanosecond to human natural representation. DCNL Returns an unicode string. DCNL >>> humanDurationNanosec(60417893) DCNL u\'60.42 ms\''
def humanDuration(delta): DCNL 'Convert a duration in millisecond to human natural representation. DCNL Returns an unicode string. DCNL >>> humanDuration(0) DCNL u\'0 ms\' DCNL >>> humanDuration(213) DCNL u\'213 ms\' DCNL >>> humanDuration(4213) DCNL u\'4 sec 213 ms\' DCNL >>> humanDuration(6402309) DCNL u\'1 hour 46 min 42 sec\''
def humanFilesize(size): DCNL 'Convert a file size in byte to human natural representation. DCNL It uses the values: 1 KB is 1024 bytes, 1 MB is 1024 KB, etc. DCNL The result is an unicode string. DCNL >>> humanFilesize(1) DCNL u\'1 byte\' DCNL >>> humanFilesize(790) DCNL u\'790 bytes\' DCNL >>> humanFilesize(256960) DCNL u\'250.9 KB\''
def humanBitSize(size): DCNL 'Convert a size in bit to human classic representation. DCNL It uses the values: 1 Kbit is 1000 bits, 1 Mbit is 1000 Kbit, etc. DCNL The result is an unicode string. DCNL >>> humanBitSize(1) DCNL u\'1 bit\' DCNL >>> humanBitSize(790) DCNL u\'790 bits\' DCNL >>> humanBitSize(256960) DCNL u\'257.0 Kbit\''
def humanBitRate(size): DCNL 'Convert a bit rate to human classic representation. It uses humanBitSize() DCNL to convert size into human reprensation. The result is an unicode string. DCNL >>> humanBitRate(790) DCNL u\'790 bits/sec\' DCNL >>> humanBitRate(256960) DCNL u\'257.0 Kbit/sec\''
def humanFrequency(hertz): DCNL 'Convert a frequency in hertz to human classic representation. DCNL It uses the values: 1 KHz is 1000 Hz, 1 MHz is 1000 KMhz, etc. DCNL The result is an unicode string. DCNL >>> humanFrequency(790) DCNL u\'790 Hz\' DCNL >>> humanFrequency(629469) DCNL u\'629.5 kHz\''
def makePrintable(data, charset, quote=None, to_unicode=False, smart=True): DCNL 'Prepare a string to make it printable in the specified charset. DCNL It escapes control characters. Characters with code bigger than 127 DCNL are escaped if data type is \'str\' or if charset is "ASCII". DCNL Examples with Unicode: DCNL >>> aged = unicode("g", "UTF-8") DCNL >>> repr(aged)  # text type is \'unicode\' DCNL "u\'\\xe2g\\xe9\'" DCNL >>> makePrintable("abc\0", "UTF-8") DCNL \'abc\\0\' DCNL >>> makePrintable(aged, "latin1") DCNL \'\xe2g\xe9\' DCNL >>> makePrintable(aged, "latin1", quote=\'"\') DCNL \'"\xe2g\xe9"\' DCNL Examples with string encoded in latin1: DCNL >>> aged_latin = unicode("g", "UTF-8").encode("latin1") DCNL >>> repr(aged_latin)  # text type is \'str\' DCNL "\'\\xe2g\\xe9\'" DCNL >>> makePrintable(aged_latin, "latin1") DCNL \'\\xe2g\\xe9\' DCNL >>> makePrintable("", "latin1") DCNL >>> makePrintable("a", "latin1", quote=\'"\') DCNL \'"a"\' DCNL >>> makePrintable("", "latin1", quote=\'"\') DCNL \'(empty)\' DCNL >>> makePrintable("abc", "latin1", quote="\'") DCNL "\'abc\'" DCNL Control codes: DCNL >>> makePrintable("\0\x03\x0a\x10 \x7f", "latin1") DCNL \'\\0\\3\\n\\x10 \\x7f\' DCNL Quote character may also be escaped (only \' and "): DCNL >>> print makePrintable("a\"b", "latin-1", quote=\'"\') DCNL "a\"b" DCNL >>> print makePrintable("a\"b", "latin-1", quote="\'") DCNL \'a"b\' DCNL >>> print makePrintable("a\'b", "latin-1", quote="\'") DCNL \'a\\'b\''
def makeUnicode(text): DCNL 'Convert text to printable Unicode string. For byte string (type \'str\'), DCNL use charset ISO-8859-1 for the conversion to Unicode DCNL >>> makeUnicode(u\'abc\0d\') DCNL u\'abc\\0d\' DCNL >>> makeUnicode(\'a\xe9\') DCNL u\'a\xe9\''
def binarySearch(seq, cmp_func): DCNL 'Search a value in a sequence using binary search. Returns index of the DCNL value, or None if the value doesn\'t exist. DCNL \'seq\' have to be sorted in ascending order according to the DCNL comparaison function ; DCNL \'cmp_func\', prototype func(x), is the compare function: DCNL - Return strictly positive value if we have to search forward ; DCNL - Return strictly negative value if we have to search backward ; DCNL - Otherwise (zero) we got the value. DCNL >>> # Search number 5 (search forward) DCNL ... binarySearch([0, 4, 5, 10], lambda x: 5-x) DCNL 2 DCNL >>> # Backward search DCNL ... binarySearch([10, 5, 4, 0], lambda x: x-5) DCNL 1'
def humanUnixAttributes(mode): DCNL 'Convert a Unix file attributes (or "file mode") to an unicode string. DCNL Original source code: DCNL http://cvs.savannah.gnu.org/viewcvs/coreutils/lib/filemode.c?root=coreutils DCNL >>> humanUnixAttributes(0644) DCNL u\'-rw-r--r-- (644)\' DCNL >>> humanUnixAttributes(02755) DCNL u\'-rwxr-sr-x (2755)\''
def createDict(data, index): DCNL 'Create a new dictionnay from dictionnary key=>values: DCNL just keep value number \'index\' from all values. DCNL >>> data={10: ("dix", 100, "a"), 20: ("vingt", 200, "b")} DCNL >>> createDict(data, 0) DCNL {10: \'dix\', 20: \'vingt\'} DCNL >>> createDict(data, 2) DCNL {10: \'a\', 20: \'b\'}'
def timestampUNIX(value): DCNL 'Convert an UNIX (32-bit) timestamp to datetime object. Timestamp value DCNL is the number of seconds since the 1st January 1970 at 00:00. Maximum DCNL value is 2147483647: 19 january 2038 at 03:14:07. DCNL May raise ValueError for invalid value: value have to be in 0..2147483647. DCNL >>> timestampUNIX(0) DCNL datetime.datetime(1970, 1, 1, 0, 0) DCNL >>> timestampUNIX(1154175644) DCNL datetime.datetime(2006, 7, 29, 12, 20, 44) DCNL >>> timestampUNIX(1154175644.37) DCNL datetime.datetime(2006, 7, 29, 12, 20, 44, 370000) DCNL >>> timestampUNIX(2147483647) DCNL datetime.datetime(2038, 1, 19, 3, 14, 7)'
def timestampMac32(value): DCNL 'Convert an Mac (32-bit) timestamp to string. The format is the number DCNL of seconds since the 1st January 1904 (to 2040). Returns unicode string. DCNL >>> timestampMac32(0) DCNL datetime.datetime(1904, 1, 1, 0, 0) DCNL >>> timestampMac32(2843043290) DCNL datetime.datetime(1994, 2, 2, 14, 14, 50)'
def durationWin64(value): DCNL 'Convert Windows 64-bit duration to string. The timestamp format is DCNL a 64-bit number: number of 100ns. See also timestampWin64(). DCNL >>> str(durationWin64(1072580000)) DCNL \'0:01:47.258000\' DCNL >>> str(durationWin64(2146280000)) DCNL \'0:03:34.628000\''
def timestampWin64(value): DCNL 'Convert Windows 64-bit timestamp to string. The timestamp format is DCNL a 64-bit number which represents number of 100ns since the DCNL 1st January 1601 at 00:00. Result is an unicode string. DCNL See also durationWin64(). Maximum date is 28 may 60056. DCNL >>> timestampWin64(0) DCNL datetime.datetime(1601, 1, 1, 0, 0) DCNL >>> timestampWin64(127840491566710000) DCNL datetime.datetime(2006, 2, 10, 12, 45, 56, 671000)'
def timestampUUID60(value): DCNL 'Convert UUID 60-bit timestamp to string. The timestamp format is DCNL a 60-bit number which represents number of 100ns since the DCNL the 15 October 1582 at 00:00. Result is an unicode string. DCNL >>> timestampUUID60(0) DCNL datetime.datetime(1582, 10, 15, 0, 0) DCNL >>> timestampUUID60(130435676263032368) DCNL datetime.datetime(1996, 2, 14, 5, 13, 46, 303236)'
def humanDatetime(value, strip_microsecond=True): DCNL 'Convert a timestamp to Unicode string: use ISO format with space separator. DCNL >>> humanDatetime( datetime(2006, 7, 29, 12, 20, 44) ) DCNL u\'2006-07-29 12:20:44\' DCNL >>> humanDatetime( datetime(2003, 6, 30, 16, 0, 5, 370000) ) DCNL u\'2003-06-30 16:00:05\' DCNL >>> humanDatetime( datetime(2003, 6, 30, 16, 0, 5, 370000), False ) DCNL u\'2003-06-30 16:00:05.370000\''
def normalizeNewline(text): DCNL 'Replace Windows and Mac newlines with Unix newlines. DCNL Replace multiple consecutive newlines with one newline. DCNL >>> normalizeNewline(\'a\r\nb\') DCNL \'a\nb\' DCNL >>> normalizeNewline(\'a\r\rb\') DCNL \'a\nb\' DCNL >>> normalizeNewline(\'a\n\nb\') DCNL \'a\nb\''
@deprecated('Use DCSP TimedeltaWin64 DCSP field DCSP type') DCNL def durationWin64(field): DCNL 'Convert Windows 64-bit duration to string. The timestamp format is DCNL a 64-bit number: number of 100ns. See also timestampWin64(). DCNL >>> durationWin64(type("", (), dict(value=2146280000, size=64))) DCNL u\'3 min 34 sec 628 ms\' DCNL >>> durationWin64(type("", (), dict(value=(1 << 64)-1, size=64))) DCNL u\'58494 years 88 days 5 hours\''
def filesizeHandler(field): DCNL 'Format field value using humanFilesize()'
def hexadecimal(field): DCNL 'Convert an integer to hexadecimal in lower case. Returns unicode string. DCNL >>> hexadecimal(type("", (), dict(value=412, size=16))) DCNL u\'0x019c\' DCNL >>> hexadecimal(type("", (), dict(value=0, size=32))) DCNL u\'0x00000000\''
def getHachoirOptions(parser): DCNL 'Create an option group (type optparse.OptionGroup) of Hachoir DCNL library options.'
def swap16(value): DCNL 'Swap byte between big and little endian of a 16 bits integer. DCNL >>> "%x" % swap16(0x1234) DCNL \'3412\''
def swap32(value): DCNL 'Swap byte between big and little endian of a 32 bits integer. DCNL >>> "%x" % swap32(0x12345678) DCNL \'78563412\''
def bin2long(text, endian): DCNL 'Convert binary number written in a string into an integer. DCNL Skip characters differents than "0" and "1". DCNL >>> bin2long("110", BIG_ENDIAN) DCNL 6 DCNL >>> bin2long("110", LITTLE_ENDIAN) DCNL 3 DCNL >>> bin2long("11 00", LITTLE_ENDIAN) DCNL 3'
def str2hex(value, prefix='', glue=u'', format='%02X'): DCNL 'Convert binary string in hexadecimal (base 16). DCNL >>> str2hex("ABC") DCNL u\'414243\' DCNL >>> str2hex("\xF0\xAF", glue=" ") DCNL u\'F0 AF\' DCNL >>> str2hex("ABC", prefix="0x") DCNL u\'0x414243\' DCNL >>> str2hex("ABC", format=r"\x%02X") DCNL u\'\\x41\\x42\\x43\''
def countBits(value): DCNL 'Count number of bits needed to store a (positive) integer number. DCNL >>> countBits(0) DCNL 1 DCNL >>> countBits(1000) DCNL 10 DCNL >>> countBits(44100) DCNL 16 DCNL >>> countBits(18446744073709551615) DCNL 64'
def byte2bin(number, classic_mode=True): DCNL 'Convert a byte (integer in 0..255 range) to a binary string. DCNL If classic_mode is true (default value), reverse bits. DCNL >>> byte2bin(10) DCNL \'00001010\' DCNL >>> byte2bin(10, False) DCNL \'01010000\''
def long2raw(value, endian, size=None): DCNL 'Convert a number (positive and not nul) to a raw string. DCNL If size is given, add nul bytes to fill to size bytes. DCNL >>> long2raw(0x1219, BIG_ENDIAN) DCNL \'\x12\x19\' DCNL >>> long2raw(0x1219, BIG_ENDIAN, 4)   # 32 bits DCNL \'\x00\x00\x12\x19\' DCNL >>> long2raw(0x1219, LITTLE_ENDIAN, 4)   # 32 bits DCNL \'\x19\x12\x00\x00\''
def long2bin(size, value, endian, classic_mode=False): DCNL 'Convert a number into bits (in a string): DCNL - size: size in bits of the number DCNL - value: positive (or nul) number DCNL - endian: BIG_ENDIAN (most important bit first) DCNL or LITTLE_ENDIAN (least important bit first) DCNL - classic_mode (default: False): reverse each packet of 8 bits DCNL >>> long2bin(16, 1+4 + (1+8)*256, BIG_ENDIAN) DCNL \'10100000 10010000\' DCNL >>> long2bin(16, 1+4 + (1+8)*256, BIG_ENDIAN, True) DCNL \'00000101 00001001\' DCNL >>> long2bin(16, 1+4 + (1+8)*256, LITTLE_ENDIAN) DCNL \'00001001 00000101\' DCNL >>> long2bin(16, 1+4 + (1+8)*256, LITTLE_ENDIAN, True) DCNL \'10010000 10100000\''
def str2bin(value, classic_mode=True): DCNL 'Convert binary string to binary numbers. DCNL If classic_mode  is true (default value), reverse bits. DCNL >>> str2bin("\x03\xFF") DCNL \'00000011 11111111\' DCNL >>> str2bin("\x03\xFF", False) DCNL \'11000000 11111111\''
def _createStructFormat(): DCNL 'Create a dictionnary (endian, size_byte) => struct format used DCNL by str2long() to convert raw data to positive integer.'
def str2long(data, endian): DCNL 'Convert a raw data (type \'str\') into a long integer. DCNL >>> chr(str2long(\'*\', BIG_ENDIAN)) DCNL >>> str2long("\x00\x01\x02\x03", BIG_ENDIAN) == 0x10203 DCNL True DCNL >>> str2long("\x2a\x10", LITTLE_ENDIAN) == 0x102a DCNL True DCNL >>> str2long("\xff\x14\x2a\x10", BIG_ENDIAN) == 0xff142a10 DCNL True DCNL >>> str2long("\x00\x01\x02\x03", LITTLE_ENDIAN) == 0x3020100 DCNL True DCNL >>> str2long("\xff\x14\x2a\x10\xab\x00\xd9\x0e", BIG_ENDIAN) == 0xff142a10ab00d90e DCNL True DCNL >>> str2long("\xff\xff\xff\xff\xff\xff\xff\xff", BIG_ENDIAN) == (2**64-1) DCNL True'
def signalHandler(signum, frame): DCNL 'Signal handler to catch timeout signal: raise Timeout exception.'
def limitedTime(second, func, *args, **kw): DCNL 'Call func(*args, **kw) with a timeout of second seconds.'
def fixTimeout(second): DCNL 'Fix timeout value: convert to integer with a minimum of 1 second'
def StringOutputStream(): DCNL 'Create an output stream into a string.'
def FileOutputStream(filename, real_filename=None): DCNL 'Create an output stream into file with given name. DCNL Filename have to be unicode, whereas (optional) real_filename can be str.'
def FileInputStream(filename, real_filename=None, **args): DCNL 'Create an input stream of a file. filename must be unicode. DCNL real_filename is an optional argument used to specify the real filename, DCNL its type can be \'str\' or \'unicode\'. Use real_filename when you are DCNL not able to convert filename to real unicode string (ie. you have to DCNL use unicode(name, \'replace\') or unicode(name, \'ignore\')).'
def locked_function(origfunc): DCNL 'Decorator to execute function under lock'
def calculate_cache_path(cache_location, url): DCNL 'Checks if [cache_location]/[hash_of_url].headers and .body exist'
def check_cache_time(path, max_age): DCNL 'Checks if a file has been created/modified in the [last max_age] seconds. DCNL False means the file is too old (or doesn\'t exist), True means it is DCNL up-to-date and valid'
@locked_function DCNL def exists_in_cache(cache_location, url, max_age): DCNL 'Returns if header AND body cache file exist (and are up-to-date)'
@locked_function DCNL def store_in_cache(cache_location, url, response): DCNL 'Tries to store response in cache.'
@locked_function DCNL def delete_from_cache(cache_location, url): DCNL 'Deletes a response in cache.'
def main(): DCNL 'Simple example of using tvdb_api - it just DCNL grabs an episode name interactively.'
def createKeyPair(type, bits): DCNL 'Create a public/private key pair. DCNL Arguments: type - Key type, must be one of TYPE_RSA and TYPE_DSA DCNL bits - Number of bits to use in the key DCNL Returns:   The public/private key pair in a PKey object'
def createCertRequest(pkey, digest='md5', **name): DCNL 'Create a certificate request. DCNL Arguments: pkey   - The key to associate with the request DCNL digest - Digestion method to use for signing, default is md5 DCNL **name - The name of the subject of the request, possible DCNL arguments are: DCNL C     - Country name DCNL ST    - State or province name DCNL L     - Locality name DCNL O     - Organization name DCNL OU    - Organizational unit name DCNL CN    - Common name DCNL emailAddress - E-mail address DCNL Returns:   The certificate request in an X509Req object'
def createCertificate(req, (issuerCert, issuerKey), serial, (notBefore, notAfter), digest='md5'): DCNL 'Generate a certificate given a certificate request. DCNL Arguments: req        - Certificate reqeust to use DCNL issuerCert - The certificate of the issuer DCNL issuerKey  - The private key of the issuer DCNL serial     - Serial number for the certificate DCNL notBefore  - Timestamp (relative to now) when the certificate DCNL starts being valid DCNL notAfter   - Timestamp (relative to now) when the certificate DCNL stops being valid DCNL digest     - Digest method to use for signing, default is md5 DCNL Returns:   The signed certificate in an X509 object'
def _parsems(value): DCNL 'Parse a I[.F] seconds value into (seconds, microseconds).'
def picknthweekday(year, month, dayofweek, hour, minute, whichweek): DCNL 'dayofweek == 0 means Sunday, whichweek 5 means last instance'
def valuestodict(key): DCNL 'Convert a registry key\'s values to a dictionary.'
def easter(year, method=EASTER_WESTERN): DCNL 'This method was ported from the work done by GM Arts, DCNL on top of the algorithm by Claus Tondering, which was DCNL based in part on the algorithm of Ouding (1940), as DCNL quoted in "Explanatory Supplement to the Astronomical DCNL Almanac", P.  Kenneth Seidelmann, editor. DCNL This algorithm implements three different easter DCNL calculation methods: DCNL 1 - Original calculation in Julian calendar, valid in DCNL dates after 326 AD DCNL 2 - Original method, with date converted to Gregorian DCNL calendar, valid in years 1583 to 4099 DCNL 3 - Revised method, in Gregorian calendar, valid in DCNL years 1583 to 4099 as well DCNL These methods are represented by the constants: DCNL EASTER_JULIAN   = 1 DCNL EASTER_ORTHODOX = 2 DCNL EASTER_WESTERN  = 3 DCNL The default method is method 3. DCNL More about the algorithm may be found at: DCNL http://users.chariot.net.au/~gmarts/eastalg.htm DCNL and DCNL http://www.tondering.dk/claus/calendar.html'
def iri2uri(uri): DCNL 'Convert an IRI to a URI. Note that IRIs must be DCNL passed in a unicode strings. That is, do not utf-8 encode DCNL the IRI before passing it into the function.'
def HTTPResponse__getheaders(self): DCNL 'Return list of (header, value) tuples.'
def parse_uri(uri): DCNL 'Parses a URI using the regex given in Appendix B of RFC 3986. DCNL (scheme, authority, path, query, fragment) = parse_uri(uri)'
def safename(filename): DCNL 'Return a filename suitable for the cache. DCNL Strips dangerous and common characters to create a filename we DCNL can use to store the cache in.'
def _parse_www_authenticate(headers, headername='www-authenticate'): DCNL 'Returns a dictionary of dictionaries, one dict DCNL per auth_scheme.'
def _entry_disposition(response_headers, request_headers): DCNL 'Determine freshness from the Date, Expires and Cache-Control headers. DCNL We don\'t handle the following: DCNL 1. Cache-Control: max-stale DCNL 2. Age: headers are not used in the calculations. DCNL Not that this algorithm is simpler than you might think DCNL because we are operating as a private (non-shared) cache. DCNL This lets us ignore \'s-maxage\'. We can also ignore DCNL \'proxy-invalidate\' since we aren\'t a proxy. DCNL We will never return a stale document as DCNL fresh as a design decision, and thus the non-implementation DCNL of \'max-stale\'. This also lets us safely ignore \'must-revalidate\' DCNL since we operate as if every server has sent \'must-revalidate\'. DCNL Since we are private we get to ignore both \'public\' and DCNL \'private\' parameters. We also ignore \'no-transform\' since DCNL we don\'t do any transformations. DCNL The \'no-store\' parameter is handled at a higher level. DCNL So the only Cache-Control parameters we look at are: DCNL no-cache DCNL only-if-cached DCNL max-age DCNL min-fresh'
def parseproxyuri(proxyurl): DCNL 'Parses a http proxy uri in the format x://a.b.c.d:port DCNL (protocol, addr, port) = parseproxyuri(uri)'
def setdefaultproxy(proxytype=None, addr=None, port=None, rdns=True, username=None, password=None): DCNL 'setdefaultproxy(proxytype, addr[, port[, rdns[, username[, password]]]]) DCNL Sets a default proxy which all further socksocket objects will use, DCNL unless explicitly changed.'
def wrapmodule(module): DCNL 'wrapmodule(module) DCNL Attempts to replace a module\'s socket library with a SOCKS socket. Must set DCNL a default proxy using setdefaultproxy(...) first. DCNL This will only work on modules that import socket directly into the namespace; DCNL most of the Python Standard Library falls into this category.'
def register_send(self): DCNL 'Resend a GNTP Register message to Growl running on a local OSX Machine'
def notice_send(self): DCNL 'Resend a GNTP Notify message to Growl running on a local OSX Machine'
def parse_gntp(data, password=None, debug=False): DCNL 'Attempt to parse a message as a GNTP message DCNL @param data: Message to be parsed DCNL @param password: Optional password to be used to verify the message DCNL @param debug: Print out extra debugging information'
def dumps(params=[], methodname=None, methodresponse=None, encoding=None, rpcid=None, version=None, notify=None): DCNL 'This differs from the Python implementation in that it implements DCNL the rpcid argument since the 2.0 spec requires it for responses.'
def loads(data): DCNL 'This differs from the Python implementation, in that it returns DCNL the request structure in Dict format instead of the method, params. DCNL It will return a list in the case of a batch request / response.'
def flatten_errors(cfg, res, levels=None, results=None): DCNL 'An example function that will turn a nested dictionary of results DCNL (as returned by ``ConfigObj.validate``) into a flat list. DCNL ``cfg`` is the ConfigObj instance being checked, ``res`` is the results DCNL dictionary returned by ``validate``. DCNL (This is a recursive function, so you shouldn\'t use the ``levels`` or DCNL ``results`` arguments - they are used by the function.) DCNL Returns a list of keys that failed. Each member of the list is a tuple : DCNL ([list of sections...], key, result) DCNL If ``validate`` was called with ``preserve_errors=False`` (the default) DCNL then ``result`` will always be ``False``. DCNL *list of sections* is a flattened list of sections that the key was found DCNL in. DCNL If the section was missing (or a section was expected and a scalar provided DCNL - or vice-versa) then key will be ``None``. DCNL If the value (or section) was missing then ``result`` will be ``False``. DCNL If ``validate`` was called with ``preserve_errors=True`` and a value DCNL was present, but failed the check, then ``result`` will be the exception DCNL object returned. You can use this as a string that describes the failure. DCNL For example *The value "3" is of the wrong type*. DCNL >>> import validate DCNL >>> vtor = validate.Validator() DCNL >>> my_ini = \'\'\' DCNL ...     option1 = True DCNL ...     [section1] DCNL ...     option1 = True DCNL ...     [section2] DCNL ...     another_option = Probably DCNL ...     [section3] DCNL ...     another_option = True DCNL ...     [[section3b]] DCNL ...     value = 3 DCNL ...     value2 = a DCNL ...     value3 = 11 DCNL >>> my_cfg = \'\'\' DCNL ...     option1 = boolean() DCNL ...     option2 = boolean() DCNL ...     option3 = boolean(default=Bad_value) DCNL ...     [section1] DCNL ...     option1 = boolean() DCNL ...     option2 = boolean() DCNL ...     option3 = boolean(default=Bad_value) DCNL ...     [section2] DCNL ...     another_option = boolean() DCNL ...     [section3] DCNL ...     another_option = boolean() DCNL ...     [[section3b]] DCNL ...     value = integer DCNL ...     value2 = integer DCNL ...     value3 = integer(0, 10) DCNL ...         [[[section3b-sub]]] DCNL ...         value = string DCNL ...     [section4] DCNL ...     another_option = boolean() DCNL >>> cs = my_cfg.split(\'\n\') DCNL >>> ini = my_ini.split(\'\n\') DCNL >>> cfg = ConfigObj(ini, configspec=cs) DCNL >>> res = cfg.validate(vtor, preserve_errors=True) DCNL >>> errors = [] DCNL >>> for entry in flatten_errors(cfg, res): DCNL ...     section_list, key, error = entry DCNL ...     section_list.insert(0, \'[root]\') DCNL ...     if key is not None: DCNL ...        section_list.append(key) DCNL ...     else: DCNL ...         section_list.append(\'[missing]\') DCNL ...     section_string = \', \'.join(section_list) DCNL ...     errors.append((section_string, \' = \', error)) DCNL >>> errors.sort() DCNL >>> for entry in errors: DCNL ...     print entry[0], entry[1], (entry[2] or 0) DCNL [root], option2  =  0 DCNL [root], option3  =  the value "Bad_value" is of the wrong type. DCNL [root], section1, option2  =  0 DCNL [root], section1, option3  =  the value "Bad_value" is of the wrong type. DCNL [root], section2, another_option  =  the value "Probably" is of the wrong type. DCNL [root], section3, section3b, section3b-sub, [missing]  =  0 DCNL [root], section3, section3b, value2  =  the value "a" is of the wrong type. DCNL [root], section3, section3b, value3  =  the value "11" is too big. DCNL [root], section4, [missing]  =  0'
def newRecoveryHeader(self): DCNL 'This header is described nowhere'
def formatRARVersion(field): DCNL 'Decodes the RAR version stored on 1 byte'
def formatSerialNumber(field): DCNL 'Format an disc serial number. DCNL Eg. 0x00085C48 => "0008-5C48"'
def parseCDDA(self): DCNL 'HSG address format: number of 1/75 second DCNL HSG offset = (minute*60 + second)*75 + frame + 150 (from RB offset) DCNL HSG length = (minute*60 + second)*75 + frame (from RB length)'
def createParser(filename, real_filename=None, tags=None): DCNL 'Create a parser from a file or returns None on error. DCNL Options: DCNL - filename (unicode): Input file name ; DCNL - real_filename (str|unicode): Real file name.'
def findSynchronizeBits(parser, start, max_size): DCNL 'Find synchronisation bits (11 bits set to 1) DCNL Returns None on error, or number of bytes before the synchronization.'
def interp_avg(data_low, data_high, n): DCNL 'Interpolated averages. For example, DCNL >>> list(interp_avg(1, 10, 3)) DCNL [4, 7]'
def color_name(data, bits): DCNL 'Color names in #RRGGBB format, given the number of bits for each component.'
def parseDict(parent): DCNL 'Format is: (key1, value1, key2, value2, ..., keyn, valuen, NULL) DCNL where each keyi and valuei is an object.'
def parse_flags(flags, flags_dict, show_unknown_flags=True, separator=' DCSP '): DCNL 'Parses an integer representing a set of flags.  The known flags are DCNL stored with their bit-mask in a dictionnary.  Returns a string.'
def eat_descriptor(descr): DCNL 'Read head of a field/method descriptor.  Returns a pair of strings, where DCNL the first one is a human-readable string representation of the first found DCNL type, and the second one is the tail of the parameter.'
def parse_field_descriptor(descr, name=None): DCNL 'Parse a field descriptor (single type), and returns it as human-readable DCNL string representation.'
def parse_method_descriptor(descr, name=None): DCNL 'Parse a method descriptor (params type and return type), and returns it DCNL as human-readable string representation.'
def parse_any_descriptor(descr, name=None): DCNL 'Parse either a field or method descriptor, and returns it as human- DCNL readable string representation.'
def build_authenticate_header(realm=''): DCNL 'Optional WWW-Authenticate header (401 error)'
def escape(s): DCNL 'Escape a URL including any /.'
def generate_timestamp(): DCNL 'Get seconds since epoch (UTC).'
def generate_nonce(length=8): DCNL 'Generate pseudorandom number.'
def generate_verifier(length=8): DCNL 'Generate pseudorandom number.'
def profile(fn=None, skip=0, filename=None, immediate=False, dirs=False, sort=None, entries=40, profiler=('cProfile', 'profile', 'hotshot')): DCNL 'Mark `fn` for profiling. DCNL If `skip` is > 0, first `skip` calls to `fn` will not be profiled. DCNL If `immediate` is False, profiling results will be printed to DCNL sys.stdout on program termination.  Otherwise results will be printed DCNL after each call. DCNL If `dirs` is False only the name of the file will be printed. DCNL Otherwise the full path is used. DCNL `sort` can be a list of sort keys (defaulting to [\'cumulative\', DCNL \'time\', \'calls\']).  The following ones are recognized:: DCNL \'calls\'      -- call count DCNL \'cumulative\' -- cumulative time DCNL \'file\'       -- file name DCNL \'line\'       -- line number DCNL \'module\'     -- file name DCNL \'name\'       -- function name DCNL \'nfl\'        -- name/file/line DCNL \'pcalls\'     -- call count DCNL \'stdname\'    -- standard name DCNL \'time\'       -- internal time DCNL `entries` limits the output to the first N entries. DCNL `profiler` can be used to select the preferred profiler, or specify a DCNL sequence of them, in order of preference.  The default is (\'cProfile\'. DCNL \'profile\', \'hotshot\'). DCNL If `filename` is specified, the profile stats will be stored in the DCNL named file.  You can load them pstats.Stats(filename). DCNL Usage:: DCNL def fn(...): DCNL fn = profile(fn, skip=1) DCNL If you are using Python 2.4, you should be able to use the decorator DCNL syntax:: DCNL @profile(skip=3) DCNL def fn(...): DCNL or just :: DCNL @profile DCNL def fn(...):'
def coverage(fn): DCNL 'Mark `fn` for line coverage analysis. DCNL Results will be printed to sys.stdout on program termination. DCNL Usage:: DCNL def fn(...): DCNL fn = coverage(fn) DCNL If you are using Python 2.4, you should be able to use the decorator DCNL syntax:: DCNL @coverage DCNL def fn(...):'
def coverage_with_hotshot(fn): DCNL 'Mark `fn` for line coverage analysis. DCNL Uses the \'hotshot\' module for fast coverage analysis. DCNL BUG: Produces inaccurate results. DCNL See the docstring of `coverage` for usage examples.'
def timecall(fn=None, immediate=True, timer=time.time): DCNL 'Wrap `fn` and print its execution time. DCNL Example:: DCNL @timecall DCNL def somefunc(x, y): DCNL time.sleep(x * y) DCNL somefunc(2, 3) DCNL will print the time taken by somefunc on every call.  If you want just DCNL a summary at program termination, use DCNL @timecall(immediate=False) DCNL You can also choose a timing method other than the default ``time.time()``, DCNL e.g.: DCNL @timecall(timer=time.clock)'
def py_scanstring(s, end, encoding=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match): DCNL 'Scan the string s for a JSON string. End is the index of the DCNL character in s after the quote that started the JSON string. DCNL Unescapes all valid JSON string escape sequences and raises ValueError DCNL on attempt to decode an invalid string. If strict is False then literal DCNL control characters are allowed in the string. DCNL Returns a tuple of the decoded string and the index of the character in s DCNL after the end quote.'
def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, **kw): DCNL 'Serialize ``obj`` as a JSON formatted stream to ``fp`` (a DCNL ``.write()``-supporting file-like object). DCNL If ``skipkeys`` is true then ``dict`` keys that are not basic types DCNL (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``) DCNL will be skipped instead of raising a ``TypeError``. DCNL If ``ensure_ascii`` is false, then the some chunks written to ``fp`` DCNL may be ``unicode`` instances, subject to normal Python ``str`` to DCNL ``unicode`` coercion rules. Unless ``fp.write()`` explicitly DCNL understands ``unicode`` (as in ``codecs.getwriter()``) this is likely DCNL to cause an error. DCNL If ``check_circular`` is false, then the circular reference check DCNL for container types will be skipped and a circular reference will DCNL result in an ``OverflowError`` (or worse). DCNL If ``allow_nan`` is false, then it will be a ``ValueError`` to DCNL serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) DCNL in strict compliance of the JSON specification, instead of using the DCNL JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``). DCNL If ``indent`` is a non-negative integer, then JSON array elements and object DCNL members will be pretty-printed with that indent level. An indent level DCNL of 0 will only insert newlines. ``None`` is the most compact representation. DCNL If ``separators`` is an ``(item_separator, dict_separator)`` tuple DCNL then it will be used instead of the default ``(\', \', \': \')`` separators. DCNL ``(\',\', \':\')`` is the most compact JSON representation. DCNL ``encoding`` is the character encoding for str instances, default is UTF-8. DCNL ``default(obj)`` is a function that should return a serializable version DCNL of obj or raise TypeError. The default simply raises TypeError. DCNL To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the DCNL ``.default()`` method to serialize additional types), specify it with DCNL the ``cls`` kwarg.'
def dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, **kw): DCNL 'Serialize ``obj`` to a JSON formatted ``str``. DCNL If ``skipkeys`` is false then ``dict`` keys that are not basic types DCNL (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``) DCNL will be skipped instead of raising a ``TypeError``. DCNL If ``ensure_ascii`` is false, then the return value will be a DCNL ``unicode`` instance subject to normal Python ``str`` to ``unicode`` DCNL coercion rules instead of being escaped to an ASCII ``str``. DCNL If ``check_circular`` is false, then the circular reference check DCNL for container types will be skipped and a circular reference will DCNL result in an ``OverflowError`` (or worse). DCNL If ``allow_nan`` is false, then it will be a ``ValueError`` to DCNL serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in DCNL strict compliance of the JSON specification, instead of using the DCNL JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``). DCNL If ``indent`` is a non-negative integer, then JSON array elements and DCNL object members will be pretty-printed with that indent level. An indent DCNL level of 0 will only insert newlines. ``None`` is the most compact DCNL representation. DCNL If ``separators`` is an ``(item_separator, dict_separator)`` tuple DCNL then it will be used instead of the default ``(\', \', \': \')`` separators. DCNL ``(\',\', \':\')`` is the most compact JSON representation. DCNL ``encoding`` is the character encoding for str instances, default is UTF-8. DCNL ``default(obj)`` is a function that should return a serializable version DCNL of obj or raise TypeError. The default simply raises TypeError. DCNL To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the DCNL ``.default()`` method to serialize additional types), specify it with DCNL the ``cls`` kwarg.'
def load(fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, **kw): DCNL 'Deserialize ``fp`` (a ``.read()``-supporting file-like object containing DCNL a JSON document) to a Python object. DCNL If the contents of ``fp`` is encoded with an ASCII based encoding other DCNL than utf-8 (e.g. latin-1), then an appropriate ``encoding`` name must DCNL be specified. Encodings that are not ASCII based (such as UCS-2) are DCNL not allowed, and should be wrapped with DCNL ``codecs.getreader(fp)(encoding)``, or simply decoded to a ``unicode`` DCNL object and passed to ``loads()`` DCNL ``object_hook`` is an optional function that will be called with the DCNL result of any object literal decode (a ``dict``). The return value of DCNL ``object_hook`` will be used instead of the ``dict``. This feature DCNL can be used to implement custom decoders (e.g. JSON-RPC class hinting). DCNL To use a custom ``JSONDecoder`` subclass, specify it with the ``cls`` DCNL kwarg.'
def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, **kw): DCNL 'Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON DCNL document) to a Python object. DCNL If ``s`` is a ``str`` instance and is encoded with an ASCII based encoding DCNL other than utf-8 (e.g. latin-1) then an appropriate ``encoding`` name DCNL must be specified. Encodings that are not ASCII based (such as UCS-2) DCNL are not allowed and should be decoded to ``unicode`` first. DCNL ``object_hook`` is an optional function that will be called with the DCNL result of any object literal decode (a ``dict``). The return value of DCNL ``object_hook`` will be used instead of the ``dict``. This feature DCNL can be used to implement custom decoders (e.g. JSON-RPC class hinting). DCNL ``parse_float``, if specified, will be called with the string DCNL of every JSON float to be decoded. By default this is equivalent to DCNL float(num_str). This can be used to use another datatype or parser DCNL for JSON floats (e.g. decimal.Decimal). DCNL ``parse_int``, if specified, will be called with the string DCNL of every JSON int to be decoded. By default this is equivalent to DCNL int(num_str). This can be used to use another datatype or parser DCNL for JSON integers (e.g. float). DCNL ``parse_constant``, if specified, will be called with one of the DCNL following strings: -Infinity, Infinity, NaN, null, true, false. DCNL This can be used to raise an exception if invalid JSON numbers DCNL are encountered. DCNL To use a custom ``JSONDecoder`` subclass, specify it with the ``cls`` DCNL kwarg.'
def encode_basestring(s): DCNL 'Return a JSON representation of a Python string'
def py_encode_basestring_ascii(s): DCNL 'Return an ASCII-only JSON representation of a Python string'
def loadShowsFromDB(): DCNL 'Populates the showList with shows from the database'
def daemonize(): DCNL 'Fork off as a daemon'
def help_message(): DCNL 'print help message for commandline options'
def main(): DCNL 'TV for me'
def _downloadResult(result): DCNL 'Downloads a result to the appropriate black hole folder. DCNL Returns a bool representing success. DCNL result: SearchResult instance to download.'
def snatchEpisode(result, endStatus=SNATCHED): DCNL 'Contains the internal logic necessary to actually "snatch" a result that DCNL has been found. DCNL Returns a bool representing success. DCNL result: SearchResult instance to be snatched. DCNL endStatus: the episode status that should be used for the episode object once it\'s snatched.'
def filter_release_name(name, filter_words): DCNL 'Filters out results based on filter_words DCNL name: name to check DCNL filter_words : Words to filter on, separated by comma DCNL Returns: False if the release name is OK, True if it contains one of the filter_words'
def isFinalResult(result): DCNL 'Checks if the given result is good enough quality that we can stop searching for other ones. DCNL If the result is the highest quality in both the any/best quality lists then this function DCNL returns True, if not then it\'s False'
def addNameToCache(name, tvdb_id): DCNL 'Adds the show & tvdb id to the scene_names table in cache.db. DCNL name: The show name to cache DCNL tvdb_id: The tvdb id that this show should be cached with (can be None/0 for unknown)'
def retrieveNameFromCache(name): DCNL 'Looks up the given name in the scene_names table in cache.db. DCNL name: The show name to look up. DCNL Returns: the tvdb id that resulted from the cache lookup or None if the show wasn\'t found in the cache'
def clearCache(): DCNL 'Deletes all "unknown" entries from the cache (names with tvdb_id of 0).'
def call_dispatcher(args, kwargs): DCNL 'calls the appropriate CMD class DCNL looks for a cmd in args and kwargs DCNL or calls the TVDBShorthandWrapper when the first args element is a number DCNL or returns an error that there is no such cmd'
def filter_params(cmd, args, kwargs): DCNL 'return only params kwargs that are for cmd DCNL and rename them to a clean version (remove "<cmd>_") DCNL args are shared across all cmds DCNL all args and kwarks are lowerd DCNL cmd are separated by "|" e.g. &cmd=shows|future DCNL kwargs are namespaced with "." e.g. show.tvdbid=101501 DCNL if a karg has no namespace asing it anyways (global) DCNL full e.g. DCNL /api?apikey=1234&cmd=show.seasonlist_asd|show.seasonlist_2&show.seasonlist_asd.tvdbid=101501&show.seasonlist_2.tvdbid=79488&sort=asc DCNL two calls of show.seasonlist DCNL one has the index "asd" the other one "2" DCNL the "tvdbid" kwargs / params have the indexed cmd as a namspace DCNL and the kwarg / param "sort" is a used as a global'
def _responds(result_type, data=None, msg=''): DCNL 'result is a string of given "type" (success/failure/timeout/error) DCNL message is a human readable string, can be empty DCNL data is either a dict or a array, can be a empty dict or empty array'
def check_force_season_folders(pattern=None, multi=None): DCNL 'Checks if the name can still be parsed if you strip off the folders to determine if we need to force season folders DCNL to be enabled or not. DCNL Returns true if season folders need to be forced on or false otherwise.'
def check_valid_naming(pattern=None, multi=None): DCNL 'Checks if the name is can be parsed back to its original form for both single and multi episodes. DCNL Returns true if the naming is valid, false if not.'
def check_valid_abd_naming(pattern=None): DCNL 'Checks if the name is can be parsed back to its original form for an air-by-date format. DCNL Returns true if the naming is valid, false if not.'
def getWinDrives(): DCNL 'Return list of detected drives'
def foldersAtPath(path, includeParent=False): DCNL 'Returns a list of dictionaries with the folders contained at the given path DCNL Give the empty string as the path to list the contents of the root path DCNL under Unix this means "/", on Windows this will be a list of drive letters)'
def filterBadReleases(name): DCNL 'Filters out non-english and just all-around stupid releases by comparing them DCNL to the resultFilters contents. DCNL name: the release name to check DCNL Returns: True if the release name is OK, False if it\'s bad.'
def sceneToNormalShowNames(name): DCNL 'Takes a show name from a scene dirname and converts it to a more "human-readable" format. DCNL name: The show name to convert DCNL Returns: a list of all the possible "normal" names'
def isGoodResult(name, show, log=True): DCNL 'Use an automatically-created regex to make sure the result actually is the show it claims to be'
def allPossibleShowNames(show): DCNL 'Figures out every possible variation of the name for a particular show. Includes TVDB name, TVRage name, DCNL country codes on the end, eg. "Show Name (AU)", and any scene exception names. DCNL show: a TVShow object that we should get the names of DCNL Returns: a list of all the possible show names'
def diagnose(): DCNL 'Check the environment for reasons libnotify isn\'t working.  Return a DCNL user-readable message indicating possible issues.'
def sendNZB(nzb): DCNL 'Sends an NZB to SABnzbd via the API. DCNL nzb: The NZBSearchResult object to send to SAB'
def testAuthentication(host=None, username=None, password=None, apikey=None): DCNL 'Sends a simple API request to SAB to determine if the given connection information is connect DCNL host: The host where SAB is running (incl port) DCNL username: The username to use for the HTTP request DCNL password: The password to use for the HTTP request DCNL apikey: The API key to provide to SAB DCNL Returns: A tuple containing the success boolean and a message'
def indentXML(elem, level=0): DCNL 'Does our pretty printing, makes Matt very happy'
def remove_extension(name): DCNL 'Remove download or media extension from name (if any)'
def remove_non_release_groups(name): DCNL 'Remove non release groups from name'
def replaceExtension(filename, newExt): DCNL '>>> replaceExtension(\'foo.avi\', \'mkv\') DCNL \'foo.mkv\' DCNL >>> replaceExtension(\'.vimrc\', \'arglebargle\') DCNL \'.vimrc\' DCNL >>> replaceExtension(\'a.b.c\', \'d\') DCNL \'a.b.d\' DCNL >>> replaceExtension(\'\', \'a\') DCNL >>> replaceExtension(\'foo.bar\', \'\') DCNL \'foo.\''
def sanitizeFileName(name): DCNL '>>> sanitizeFileName(\'a/b/c\') DCNL \'a-b-c\' DCNL >>> sanitizeFileName(\'abc\') DCNL \'abc\' DCNL >>> sanitizeFileName(\'a"b\') DCNL \'ab\' DCNL >>> sanitizeFileName(\'.a.b..\') DCNL \'a.b\''
def getURL(url, validate=False, cookies=cookielib.CookieJar(), password_mgr=None, throw_exc=False): DCNL 'Convenience method to directly retrieve the contents of a url'
def getURLFileLike(url, validate=False, cookies=cookielib.CookieJar(), password_mgr=None, throw_exc=False): DCNL 'Returns a file-like object same as returned by urllib2.urlopen but with Handlers configured for sickbeard. DCNL It allows for the use of cookies, multipart/form-data, https without certificate validation and both basic DCNL and digest HTTP authentication. In addition, the user-agent is set to the sickbeard default and accepts DCNL gzip and deflate encoding (which can be automatically handled when using readURL() to retrieve the contents) DCNL @param url: can be either a string or a Request object. DCNL @param validate: defines if SSL certificates should be validated on HTTPS connections DCNL @param cookies: is the cookielib.CookieJar in which cookies are stored. DCNL @param password_mgr: if given, should be something that is compatible with HTTPPasswordMgr DCNL @param throw_exc: throw the exception that was caught instead of None DCNL @return: the file-like object retrieved from the URL or None (or the exception) if it could not be retrieved'
def readURLFileLike(urlFileLike): DCNL 'Return the contents of the file like objects as string, performing decompression if necessary. DCNL @param urlFileLike: is a file like objects same as returned by urllib2.urlopen() and getURL()'
def is_hidden_folder(folder): DCNL 'Returns True if folder is hidden. DCNL On Linux based systems hidden folders start with . (dot) DCNL folder: Full path of folder to check'
def list_associated_files(file_path, base_name_only=False, filter_ext=''): DCNL 'For a given file path searches for files with the same name but different extension and returns their absolute paths DCNL file_path: The file to check for associated files DCNL base_name_only: False add extra \'.\' (conservative search) to file_path minus extension DCNL filter_ext: A comma separated string with extensions to include or empty string to include all matches DCNL Returns: A list containing all files which are associated to the given file'
def sizeof_fmt(num): DCNL '>>> sizeof_fmt(2) DCNL \'2.0 bytes\' DCNL >>> sizeof_fmt(1024) DCNL \'1.0 KB\' DCNL >>> sizeof_fmt(2048) DCNL \'2.0 KB\' DCNL >>> sizeof_fmt(2**20) DCNL \'1.0 MB\' DCNL >>> sizeof_fmt(1234567) DCNL \'1.2 MB\''
def make_dirs(path): DCNL 'Creates any folders that are missing and assigns them the permissions of their DCNL parents'
def rename_ep_file(cur_path, new_path, old_path_length=0): DCNL 'Creates all folders needed to move a file to its new location, renames it, then cleans up any folders DCNL left that are now empty. DCNL cur_path: The absolute path to the file you want to move/rename DCNL new_path: The absolute path to the destination for the file WITHOUT THE EXTENSION DCNL old_path_length: The length of media file path (old name) WITHOUT THE EXTENSION'
def delete_empty_folders(check_empty_dir, keep_dir=None): DCNL 'Walks backwards up the path and deletes any empty folders found. DCNL check_empty_dir: The path to clean (absolute path to a folder) DCNL keep_dir: Clean until this path is reached'
def real_path(path): DCNL 'Returns: the canonicalized absolute pathname. The resulting path will have no symbolic link, \'/./\' or \'/../\' components.'
def sanitizeSceneName(name, ezrss=False): DCNL 'Takes a show name and returns the "scenified" version of it. DCNL ezrss: If true the scenified version will follow EZRSS\'s cracksmoker rules as best as possible DCNL Returns: A string containing the scene version of the show name given.'
def create_https_certificates(ssl_cert, ssl_key): DCNL 'Create self-signed HTTPS certificares and store in paths \'ssl_cert\' and \'ssl_key\''
def parse_json(data): DCNL 'Parse json data into a python object DCNL data: data string containing json DCNL Returns: parsed data as json or None'
def parse_xml(data, del_xmlns=False): DCNL 'Parse data into an xml elementtree.ElementTree DCNL data: data string containing xml DCNL del_xmlns: if True, removes xmlns namesspace from data before parsing DCNL Returns: parsed data as elementtree or None'
def get_xml_text(element, mini_dom=False): DCNL 'Get all text inside a xml element DCNL element: A xml element either created with elementtree.ElementTree or xml.dom.minidom DCNL mini_dom: Default False use elementtree, True use minidom DCNL Returns: text'
def processDir(dirName, nzbName=None, method=None, recurse=False, pp_options={}): DCNL 'Scans through the files in dirName and processes whatever media files it finds DCNL dirName: The folder name to look in DCNL nzbName: The NZB name which resulted in this folder being downloaded DCNL method:  The method of postprocessing: Automatic, Script, Manual DCNL recurse: Boolean for whether we should descend into subfolders or not'
def dbFilename(filename='sickbeard.db', suffix=None): DCNL '@param filename: The sqlite database filename to use. If not specified, DCNL will be made to be sickbeard.db DCNL @param suffix: The suffix to append to the filename. A \'.\' will be added DCNL automatically, i.e. suffix=\'v0\' will make dbfile.db.v0 DCNL @return: the correct location of the database file.'
def CheckSection(CFG, sec): DCNL 'Check if INI section exists, if not create it'
def checkbox_to_value(option, value_on=1, value_off=0): DCNL 'Turns checkbox option \'on\' or \'true\' to value_on (1) DCNL any other value returns value_off (0)'
def clean_host(host, default_port=None): DCNL 'Returns host or host:port or empty string from a given url or host DCNL If no port is found and default_port is given use host:default_port'
def clean_url(url): DCNL 'Returns an cleaned url starting with a scheme and folder with trailing / DCNL or an empty string'
def to_int(val, default=0): DCNL 'Return int value of val or default on error'
def minimax(val, default, low, high): DCNL 'Return value forced within range'
def get_scene_exceptions(tvdb_id): DCNL 'Given a tvdb_id, return a list of all the scene exceptions.'
def get_scene_exception_by_name(show_name): DCNL 'Given a show name, return the tvdbid of the exception, None if no exception DCNL is present.'
def retrieve_exceptions(): DCNL 'Looks up the exceptions on github, parses them into a dict, and inserts them into the DCNL scene_exceptions table in cache.db. Also clears the scene name cache.'
def ex(e): DCNL 'Returns a unicode string from the exception text if it exists.'
def setUp_test_db(): DCNL 'upgrades the db to the latest version'
def tearDown_test_db(): DCNL 'Deletes the test db DCNL although this seams not to work on my system it leaves me with an zero kb file'
def test_callable_spec(callable, callable_args, callable_kwargs): DCNL 'Inspect callable and test to see if the given args are suitable for it. DCNL When an error occurs during the handler\'s invoking stage there are 2 DCNL erroneous cases: DCNL 1.  Too many parameters passed to a function which doesn\'t define DCNL one of *args or **kwargs. DCNL 2.  Too little parameters are passed to the function. DCNL There are 3 sources of parameters to a cherrypy handler. DCNL 1.  query string parameters are passed as keyword parameters to the handler. DCNL 2.  body parameters are also passed as keyword parameters. DCNL 3.  when partial matching occurs, the final path atoms are passed as DCNL positional args. DCNL Both the query string and path atoms are part of the URI.  If they are DCNL incorrect, then a 404 Not Found should be raised. Conversely the body DCNL parameters are part of the request; if they are invalid a 400 Bad Request.'
def VirtualHost(next_dispatcher=Dispatcher(), use_x_forwarded_host=True, **domains): DCNL 'Select a different handler based on the Host header. DCNL This can be useful when running multiple sites within one CP server. DCNL It allows several domains to point to different parts of a single DCNL website structure. For example: DCNL http://www.domain.example  ->  root DCNL http://www.domain2.example  ->  root/domain2/ DCNL http://www.domain2.example:443  ->  root/secure DCNL can be accomplished via the following config: DCNL request.dispatch = cherrypy.dispatch.VirtualHost( DCNL **{\'www.domain2.example\': \'/domain2\', DCNL \'www.domain2.example:443\': \'/secure\', DCNL next_dispatcher: the next dispatcher object in the dispatch chain. DCNL The VirtualHost dispatcher adds a prefix to the URL and calls DCNL another dispatcher. Defaults to cherrypy.dispatch.Dispatcher(). DCNL use_x_forwarded_host: if True (the default), any "X-Forwarded-Host" DCNL request header will be used instead of the "Host" header. This DCNL is commonly added by HTTP servers (such as Apache) when proxying. DCNL **domains: a dict of {host header value: virtual prefix} pairs. DCNL The incoming "Host" request header is looked up in this dict, DCNL and, if a match is found, the corresponding "virtual prefix" DCNL value will be prepended to the URL path before calling the DCNL next dispatcher. Note that you often need separate entries DCNL for "example.com" and "www.example.com". In addition, "Host" DCNL headers may contain the port number.'
def clean_headers(status): DCNL 'Remove any headers which should not apply to an error response.'
def get_error_page(status, **kwargs): DCNL 'Return an HTML page, containing a pretty error response. DCNL status should be an int or a str. DCNL kwargs will be interpolated into the page template.'
def format_exc(exc=None): DCNL 'Return exc (or sys.exc_info if None), formatted.'
def bare_error(extrabody=None): DCNL 'Produce status, headers, body for a critical error. DCNL Returns a triple without calling any other questionable functions, DCNL so it should be as error-free as possible. Call it from an HTTP server DCNL if you get errors outside of the request. DCNL If extrabody is None, a friendly but rather unhelpful error message DCNL is set in the body. If extrabody is a string, it will be appended DCNL as-is to the body.'
def client_host(server_host): DCNL 'Return the host on which a client can connect to the given listener.'
def check_port(host, port, timeout=1.0): DCNL 'Raise an error if the given port is not free on the given host.'
def wait_for_free_port(host, port): DCNL 'Wait for the specified port to become free (drop requests).'
def wait_for_occupied_port(host, port): DCNL 'Wait for the specified port to become active (receive requests).'
def hooks_namespace(k, v): DCNL 'Attach bare hooks declared in config.'
def request_namespace(k, v): DCNL 'Attach request attributes declared in config.'
def response_namespace(k, v): DCNL 'Attach response attributes declared in config.'
def error_page_namespace(k, v): DCNL 'Attach error pages declared in config.'
def plat_specific_errors(*errnames): DCNL 'Return error numbers for all errors in errnames on this platform. DCNL The \'errno\' module contains different global constants depending on DCNL the specific platform (OS). This function will return the list of DCNL numeric values for a given list of potential names.'
def read_headers(rfile, hdict=None): DCNL 'Read headers from the given stream into the given header dict. DCNL If hdict is None, a new header dict is created. Returns the populated DCNL header dict. DCNL Headers which are repeated are folded together using a comma if their DCNL specification so dictates. DCNL This function raises ValueError when the read bytes violate the HTTP spec. DCNL You should probably return "400 Bad Request" if this happens.'
def format_exc(limit=None): DCNL 'Like print_exc() but return a string. Backport for Python 2.3.'
def process_urlencoded(entity): DCNL 'Read application/x-www-form-urlencoded data into entity.params.'
def process_multipart(entity): DCNL 'Read all multipart parts into entity.parts.'
def process_multipart_form_data(entity): DCNL 'Read all multipart/form-data parts into entity.parts or entity.params.'
def _old_process_multipart(entity): DCNL 'The behavior of 3.2 and lower. Deprecated and will be changed in 3.3.'
def as_dict(config): DCNL 'Return a dict from \'config\' whether it is a dict, file, or filename.'
def _astnode(s): DCNL 'Return a Python ast Node compiled from a string.'
def unrepr(s): DCNL 'Return a Python object compiled from a string.'
def modules(modulePath): DCNL 'Load a module and retrieve a reference to that module.'
def attributes(full_attribute_name): DCNL 'Load a module and retrieve an attribute of that module.'
def get(invalid_methods=('POST', 'PUT', 'DELETE'), debug=False, **kwargs): DCNL 'Try to obtain cached output. If fresh enough, raise HTTPError(304). DCNL If POST, PUT, or DELETE: DCNL * invalidates (deletes) any cached response for this resource DCNL * sets request.cached = False DCNL * sets request.cacheable = False DCNL else if a cached copy exists: DCNL * sets request.cached = True DCNL * sets request.cacheable = False DCNL * sets response.headers to the cached values DCNL * checks the cached Last-Modified response header against the DCNL current If-(Un)Modified-Since request headers; raises 304 DCNL if necessary. DCNL * sets response.status and response.body to the cached values DCNL * returns True DCNL otherwise: DCNL * sets request.cached = False DCNL * sets request.cacheable = True DCNL * returns False'
def expires(secs=0, force=False, debug=False): DCNL 'Tool for influencing cache mechanisms using the \'Expires\' header. DCNL \'secs\' must be either an int or a datetime.timedelta, and indicates the DCNL number of seconds between response.time and when the response should DCNL expire. The \'Expires\' header will be set to (response.time + secs). DCNL If \'secs\' is zero, the \'Expires\' header is set one year in the past, and DCNL the following "cache prevention" headers are also set: DCNL \'Pragma\': \'no-cache\' DCNL \'Cache-Control\': \'no-cache, must-revalidate\' DCNL If \'force\' is False (the default), the following headers are checked: DCNL \'Etag\', \'Last-Modified\', \'Age\', \'Expires\'. If any are already present, DCNL none of the above response headers are set.'
def decode(encoding=None, default_encoding='utf-8'): DCNL 'Replace or extend the list of charsets used to decode a request entity. DCNL Either argument may be a single string or a list of strings. DCNL encoding: If not None, restricts the set of charsets attempted while decoding DCNL a request entity to the given set (even if a different charset is given in DCNL the Content-Type request header). DCNL default_encoding: Only in effect if the \'encoding\' argument is not given. DCNL If given, the set of charsets attempted while decoding a request entity is DCNL *extended* with the given value(s).'
def compress(body, compress_level): DCNL 'Compress \'body\' at the given compress_level.'
def gzip(compress_level=5, mime_types=['text/html', 'text/plain'], debug=False): DCNL 'Try to gzip the response body if Content-Type in mime_types. DCNL cherrypy.response.headers[\'Content-Type\'] must be set to one of the DCNL values in the mime_types arg before calling this function. DCNL No compression is performed if any of the following hold: DCNL * The client sends no Accept-Encoding request header DCNL * No \'gzip\' or \'x-gzip\' is present in the Accept-Encoding header DCNL * No \'gzip\' or \'x-gzip\' with a qvalue > 0 is present DCNL * The \'identity\' value is given with a qvalue > 0.'
def calculateNonce(realm, algorithm=MD5): DCNL 'This is an auxaliary function that calculates \'nonce\' value. It is used DCNL to handle sessions.'
def digestAuth(realm, algorithm=MD5, nonce=None, qop=AUTH): DCNL 'Challenges the client for a Digest authentication.'
def basicAuth(realm): DCNL 'Challengenes the client for a Basic authentication.'
def doAuth(realm): DCNL '\'doAuth\' function returns the challenge string b giving priority over DCNL Digest and fallback to Basic authentication when the browser doesn\'t DCNL support the first one. DCNL This should be set in the HTTP header under the key \'WWW-Authenticate\'.'
def parseAuthorization(credentials): DCNL 'parseAuthorization will convert the value of the \'Authorization\' key in DCNL the HTTP header to a map itself. If the parsing fails \'None\' is returned.'
def md5SessionKey(params, password): DCNL 'If the "algorithm" directive\'s value is "MD5-sess", then A1 DCNL [the session key] is calculated only once - on the first request by the DCNL client following receipt of a WWW-Authenticate challenge from the server. DCNL This creates a \'session key\' for the authentication of subsequent DCNL requests and responses which is different for each "authentication DCNL session", thus limiting the amount of material hashed with any one DCNL key. DCNL Because the server need only use the hash of the user DCNL credentials in order to create the A1 value, this construction could DCNL be used in conjunction with a third party authentication service so DCNL that the web server would not need the actual password value.  The DCNL specification of such a protocol is beyond the scope of this DCNL specification.'
def _computeDigestResponse(auth_map, password, method='GET', A1=None, **kwargs): DCNL 'Generates a response respecting the algorithm defined in RFC 2617'
def _checkDigestResponse(auth_map, password, method='GET', A1=None, **kwargs): DCNL 'This function is used to verify the response given by the client when DCNL he tries to authenticate. DCNL Optional arguments: DCNL entity_body - when \'qop\' is set to \'auth-int\' you MUST provide the DCNL raw data you are going to send to the client (usually the DCNL HTML page. DCNL request_uri - the uri from the request line compared with the \'uri\' DCNL directive of the authorization map. They must represent DCNL the same resource (unused at this time).'
def checkResponse(auth_map, password, method='GET', encrypt=None, **kwargs): DCNL '\'checkResponse\' compares the auth_map with the password and optionally DCNL other arguments that each implementation might need. DCNL If the response is of type \'Basic\' then the function has the following DCNL signature: DCNL checkBasicResponse (auth_map, password) -> bool DCNL If the response is of type \'Digest\' then the function has the following DCNL signature: DCNL checkDigestResponse (auth_map, password, method = \'GET\', A1 = None) -> bool DCNL The \'A1\' argument is only used in MD5_SESS algorithm based responses. DCNL Check md5SessionKey() for more info.'
def get_tree(base, exclude): DCNL 'Return covered module names as a nested dict.'
def serve_file(path, content_type=None, disposition=None, name=None, debug=False): DCNL 'Set status, headers, and body in order to serve the given path. DCNL The Content-Type header will be set to the content_type arg, if provided. DCNL If not provided, the Content-Type will be guessed by the file extension DCNL of the \'path\' argument. DCNL If disposition is not None, the Content-Disposition header will be set DCNL to "<disposition>; filename=<name>". If name is None, it will be set DCNL to the basename of path. If disposition is None, no Content-Disposition DCNL header will be written.'
def serve_fileobj(fileobj, content_type=None, disposition=None, name=None, debug=False): DCNL 'Set status, headers, and body in order to serve the given file object. DCNL The Content-Type header will be set to the content_type arg, if provided. DCNL If disposition is not None, the Content-Disposition header will be set DCNL to "<disposition>; filename=<name>". If name is None, \'filename\' will DCNL not be set. If disposition is None, no Content-Disposition header will DCNL be written. DCNL CAUTION: If the request contains a \'Range\' header, one or more seek()s will DCNL be performed on the file object.  This may cause undesired behavior if DCNL the file object is not seekable.  It could also produce undesired results DCNL if the caller set the read position of the file object prior to calling DCNL serve_fileobj(), expecting that the data would be served starting from that DCNL position.'
def _serve_fileobj(fileobj, content_type, content_length, debug=False): DCNL 'Internal. Set response.body to the given file object, perhaps ranged.'
def serve_download(path, name=None): DCNL 'Serve \'path\' as an application/x-download attachment.'
def staticdir(section, dir, root='', match='', content_types=None, index='', debug=False): DCNL 'Serve a static resource from the given (root +) dir. DCNL If \'match\' is given, request.path_info will be searched for the given DCNL regular expression before attempting to serve static content. DCNL If content_types is given, it should be a Python dictionary of DCNL {file-extension: content-type} pairs, where \'file-extension\' is DCNL a string (e.g. "gif") and \'content-type\' is the value to write DCNL out in the Content-Type response header (e.g. "image/gif"). DCNL If \'index\' is provided, it should be the (relative) name of a file to DCNL serve for directory requests. For example, if the dir argument is DCNL \'/home/me\', the Request-URI is \'myapp\', and the index arg is DCNL \'index.html\', the file \'/home/me/myapp/index.html\' will be sought.'
def staticfile(filename, root=None, match='', content_types=None, debug=False): DCNL 'Serve a static resource from the given (root +) filename. DCNL If \'match\' is given, request.path_info will be searched for the given DCNL regular expression before attempting to serve static content. DCNL If content_types is given, it should be a Python dictionary of DCNL {file-extension: content-type} pairs, where \'file-extension\' is DCNL a string (e.g. "gif") and \'content-type\' is the value to write DCNL out in the Content-Type response header (e.g. "image/gif").'
def get_ha1_dict_plain(user_password_dict): DCNL 'Returns a get_ha1 function which obtains a plaintext password from a DCNL dictionary of the form: {username : password}. DCNL If you want a simple dictionary-based authentication scheme, with plaintext DCNL passwords, use get_ha1_dict_plain(my_userpass_dict) as the value for the DCNL get_ha1 argument to digest_auth().'
def get_ha1_dict(user_ha1_dict): DCNL 'Returns a get_ha1 function which obtains a HA1 password hash from a DCNL dictionary of the form: {username : HA1}. DCNL If you want a dictionary-based authentication scheme, but with DCNL pre-computed HA1 hashes instead of plain-text passwords, use DCNL get_ha1_dict(my_userha1_dict) as the value for the get_ha1 DCNL argument to digest_auth().'
def get_ha1_file_htdigest(filename): DCNL 'Returns a get_ha1 function which obtains a HA1 password hash from a DCNL flat file with lines of the same format as that produced by the Apache DCNL htdigest utility. For example, for realm \'wonderland\', username \'alice\', DCNL and password \'4x5istwelve\', the htdigest line would be: DCNL alice:wonderland:3238cdfe91a8b2ed8e39646921a02d4c DCNL If you want to use an Apache htdigest file as the credentials store, DCNL then use get_ha1_file_htdigest(my_htdigest_file) as the value for the DCNL get_ha1 argument to digest_auth().  It is recommended that the filename DCNL argument be an absolute path, to avoid problems.'
def synthesize_nonce(s, key, timestamp=None): DCNL 'Synthesize a nonce value which resists spoofing and can be checked for staleness. DCNL Returns a string suitable as the value for \'nonce\' in the www-authenticate header. DCNL Args: DCNL s: a string related to the resource, such as the hostname of the server. DCNL key: a secret string known only to the server. DCNL timestamp: an integer seconds-since-the-epoch timestamp'
def H(s): DCNL 'The hash function H'
def www_authenticate(realm, key, algorithm='MD5', nonce=None, qop=qop_auth, stale=False): DCNL 'Constructs a WWW-Authenticate header for Digest authentication.'
def digest_auth(realm, get_ha1, key, debug=False): DCNL 'digest_auth is a CherryPy tool which hooks at before_handler to perform DCNL HTTP Digest Access Authentication, as specified in RFC 2617. DCNL If the request has an \'authorization\' header with a \'Digest\' scheme, this DCNL tool authenticates the credentials supplied in that header.  If DCNL the request has no \'authorization\' header, or if it does but the scheme is DCNL not "Digest", or if authentication fails, the tool sends a 401 response with DCNL a \'WWW-Authenticate\' Digest header. DCNL Arguments: DCNL realm: a string containing the authentication realm. DCNL get_ha1: a callable which looks up a username in a credentials store DCNL and returns the HA1 string, which is defined in the RFC to be DCNL MD5(username : realm : password).  The function\'s signature is: DCNL get_ha1(realm, username) DCNL where username is obtained from the request\'s \'authorization\' header. DCNL If username is not found in the credentials store, get_ha1() returns DCNL None. DCNL key: a secret string known only to the server, used in the synthesis of nonces.'
def file_generator_limited(fileobj, count, chunk_size=65536): DCNL 'Yield the given file object in chunks, stopping after `count` DCNL bytes has been emitted.  Default chunk size is 64kB. (Core)'
def set_vary_header(response, header_name): DCNL 'Add a Vary header to a response'
def checkpassword_dict(user_password_dict): DCNL 'Returns a checkpassword function which checks credentials DCNL against a dictionary of the form: {username : password}. DCNL If you want a simple dictionary-based authentication scheme, use DCNL checkpassword_dict(my_credentials_dict) as the value for the DCNL checkpassword argument to basic_auth().'
def basic_auth(realm, checkpassword, debug=False): DCNL 'basic_auth is a CherryPy tool which hooks at before_handler to perform DCNL HTTP Basic Access Authentication, as specified in RFC 2617. DCNL If the request has an \'authorization\' header with a \'Basic\' scheme, this DCNL tool attempts to authenticate the credentials supplied in that header.  If DCNL the request has no \'authorization\' header, or if it does but the scheme is DCNL not \'Basic\', or if authentication fails, the tool sends a 401 response with DCNL a \'WWW-Authenticate\' Basic header. DCNL Arguments: DCNL realm: a string containing the authentication realm. DCNL checkpassword: a callable which checks the authentication credentials. DCNL Its signature is checkpassword(realm, username, password). where DCNL username and password are the values obtained from the request\'s DCNL \'authorization\' header.  If authentication succeeds, checkpassword DCNL returns True, else it returns False.'
def validate_etags(autotags=False, debug=False): DCNL 'Validate the current ETag against If-Match, If-None-Match headers. DCNL If autotags is True, an ETag response-header value will be provided DCNL from an MD5 hash of the response body (unless some other code has DCNL already provided an ETag header). If False (the default), the ETag DCNL will not be automatic. DCNL WARNING: the autotags feature is not designed for URL\'s which allow DCNL methods other than GET. For example, if a POST to the same URL returns DCNL no content, the automatic ETag will be incorrect, breaking a fundamental DCNL use for entity tags in a possibly destructive fashion. Likewise, if you DCNL raise 304 Not Modified, the response body will be empty, the ETag hash DCNL will be incorrect, and your application will break. DCNL See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.24'
def validate_since(): DCNL 'Validate the current Last-Modified against If-Modified-Since headers. DCNL If no code has set the Last-Modified response header, then no validation DCNL will be performed.'
def proxy(base=None, local='X-Forwarded-Host', remote='X-Forwarded-For', scheme='X-Forwarded-Proto', debug=False): DCNL 'Change the base URL (scheme://host[:port][/path]). DCNL For running a CP server behind Apache, lighttpd, or other HTTP server. DCNL If you want the new request.base to include path info (not just the host), DCNL you must explicitly set base to the full base path, and ALSO set \'local\' DCNL to \'\', so that the X-Forwarded-Host request header (which never includes DCNL path info) does not override it. Regardless, the value for \'base\' MUST DCNL NOT end in a slash. DCNL cherrypy.request.remote.ip (the IP address of the client) will be DCNL rewritten if the header specified by the \'remote\' arg is valid. DCNL By default, \'remote\' is set to \'X-Forwarded-For\'. If you do not DCNL want to rewrite remote.ip, set the \'remote\' arg to an empty string.'
def ignore_headers(headers=('Range',), debug=False): DCNL 'Delete request headers whose field names are included in \'headers\'. DCNL This is a useful tool for working behind certain HTTP servers; DCNL for example, Apache duplicates the work that CP does for \'Range\' DCNL headers, and will doubly-truncate the response.'
def response_headers(headers=None, debug=False): DCNL 'Set headers on the response.'
def referer(pattern, accept=True, accept_missing=False, error=403, message='Forbidden DCSP Referer DCSP header.', debug=False): DCNL 'Raise HTTPError if Referer header does/does not match the given pattern. DCNL pattern: a regular expression pattern to test against the Referer. DCNL accept: if True, the Referer must match the pattern; if False, DCNL the Referer must NOT match the pattern. DCNL accept_missing: if True, permit requests with no Referer header. DCNL error: the HTTP error code to return to the client on failure. DCNL message: a string to include in the response body on failure.'
def log_traceback(severity=logging.ERROR, debug=False): DCNL 'Write the last error\'s traceback to the cherrypy error log.'
def log_request_headers(debug=False): DCNL 'Write request headers to the cherrypy error log.'
def log_hooks(debug=False): DCNL 'Write request.hooks to the cherrypy error log.'
def redirect(url='', internal=True, debug=False): DCNL 'Raise InternalRedirect or HTTPRedirect to the given url.'
def trailing_slash(missing=True, extra=False, status=None, debug=False): DCNL 'Redirect if path_info has (missing|extra) trailing slash.'
def flatten(debug=False): DCNL 'Wrap response.body in a generator that recursively iterates over body. DCNL This allows cherrypy.response.body to consist of \'nested generators\'; DCNL that is, a set of generators that yield generators.'
def accept(media=None, debug=False): DCNL 'Return the client\'s preferred media-type (from the given Content-Types). DCNL If \'media\' is None (the default), no test will be performed. DCNL If \'media\' is provided, it should be the Content-Type value (as a string) DCNL or values (as a list or tuple of strings) which the current resource DCNL can emit. The client\'s acceptable media ranges (as declared in the DCNL Accept request header) will be matched in order to these Content-Type DCNL values; the first such string is returned. That is, the return value DCNL will always be one of the strings provided in the \'media\' arg (or None DCNL if \'media\' is None). DCNL If no match is found, then HTTPError 406 (Not Acceptable) is raised. DCNL Note that most web browsers send */* as a (low-quality) acceptable DCNL media range, which should match any Content-Type. In addition, "...if DCNL no Accept header field is present, then it is assumed that the client DCNL accepts all media types." DCNL Matching types are checked in order of client preference first, DCNL and then in the order of the given \'media\' values. DCNL Note that this function does not honor accept-params (other than "q").'
def autovary(ignore=None, debug=False): DCNL 'Auto-populate the Vary response header based on request.header access.'
def urljoin(*atoms): DCNL 'Return the given path *atoms, joined into a single URL. DCNL This will correctly join a SCRIPT_NAME and PATH_INFO into the DCNL original URL, even if either atom is blank.'
def protocol_from_http(protocol_str): DCNL 'Return a protocol tuple from the given \'HTTP/x.y\' string.'
def get_ranges(headervalue, content_length): DCNL 'Return a list of (start, stop) indices from a Range header, or None. DCNL Each (start, stop) tuple will be composed of two ints, which are suitable DCNL for use in a slicing operation. That is, the header "Range: bytes=3-6", DCNL if applied against a Python string, is requesting resource[3:7]. This DCNL function will return the list [(3, 7)]. DCNL If this function returns an empty list, you should return HTTP 416.'
def header_elements(fieldname, fieldvalue): DCNL 'Return a sorted HeaderElement list from a comma-separated header str.'
def decode_TEXT(value): DCNL 'Decode RFC-2047 TEXT (e.g. "=?utf-8?q?f=C3=BCr?=" -> u"fr").'
def valid_status(status): DCNL 'Return legal HTTP status Code, Reason-phrase and Message. DCNL The status arg must be an int, or a str that begins with an int. DCNL If status is an int, or a str and no reason-phrase is supplied, DCNL a default reason-phrase will be provided.'
def _parse_qs(qs, keep_blank_values=0, strict_parsing=0, encoding='utf-8'): DCNL 'Parse a query given as a string argument. DCNL Arguments: DCNL qs: URL-encoded query string to be parsed DCNL keep_blank_values: flag indicating whether blank values in DCNL URL encoded queries should be treated as blank strings.  A DCNL true value indicates that blanks should be retained as blank DCNL strings.  The default false value indicates that blank values DCNL are to be ignored and treated as if they were  not included. DCNL strict_parsing: flag indicating what to do with parsing errors. If DCNL false (the default), errors are silently ignored. If true, DCNL errors raise a ValueError exception. DCNL Returns a dict, as G-d intended.'
def parse_query_string(query_string, keep_blank_values=True, encoding='utf-8'): DCNL 'Build a params dictionary from a query_string. DCNL Duplicate key/value pairs in the provided query_string will be DCNL returned as {\'key\': [val1, val2, ...]}. Single key/values will DCNL be returned as strings: {\'key\': \'value\'}.'
def check_auth(users, encrypt=None, realm=None): DCNL 'If an authorization header contains credentials, return True, else False.'
def basic_auth(realm, users, encrypt=None, debug=False): DCNL 'If auth fails, raise 401 with a basic authentication header. DCNL realm: a string containing the authentication realm. DCNL users: a dict of the form: {username: password} or a callable returning a dict. DCNL encrypt: callable used to encrypt the password returned from the user-agent. DCNL if None it defaults to a md5 encryption.'
def digest_auth(realm, users, debug=False): DCNL 'If auth fails, raise 401 with a digest authentication header. DCNL realm: a string containing the authentication realm. DCNL users: a dict of the form: {username: password} or a callable returning a dict.'
def save(): DCNL 'Save any changed session data.'
def close(): DCNL 'Close the session object for this request.'
def init(storage_type='ram', path=None, path_header=None, name='session_id', timeout=60, domain=None, secure=False, clean_freq=5, persistent=True, debug=False, **kwargs): DCNL 'Initialize session object (using cookies). DCNL storage_type: one of \'ram\', \'file\', \'postgresql\'. This will be used DCNL to look up the corresponding class in cherrypy.lib.sessions DCNL globals. For example, \'file\' will use the FileSession class. DCNL path: the \'path\' value to stick in the response cookie metadata. DCNL path_header: if \'path\' is None (the default), then the response DCNL cookie \'path\' will be pulled from request.headers[path_header]. DCNL name: the name of the cookie. DCNL timeout: the expiration timeout (in minutes) for the stored session data. DCNL If \'persistent\' is True (the default), this is also the timeout DCNL for the cookie. DCNL domain: the cookie domain. DCNL secure: if False (the default) the cookie \'secure\' value will not DCNL be set. If True, the cookie \'secure\' value will be set (to 1). DCNL clean_freq (minutes): the poll rate for expired session cleanup. DCNL persistent: if True (the default), the \'timeout\' argument will be used DCNL to expire the cookie. If False, the cookie will not have an expiry, DCNL and the cookie will be a "session cookie" which expires when the DCNL browser is closed. DCNL Any additional kwargs will be bound to the new Session instance, DCNL and may be specific to the storage type. See the subclass of Session DCNL you\'re using for more information.'
def set_response_cookie(path=None, path_header=None, name='session_id', timeout=60, domain=None, secure=False): DCNL 'Set a response cookie for the client. DCNL path: the \'path\' value to stick in the response cookie metadata. DCNL path_header: if \'path\' is None (the default), then the response DCNL cookie \'path\' will be pulled from request.headers[path_header]. DCNL name: the name of the cookie. DCNL timeout: the expiration timeout for the cookie. If 0 or other boolean DCNL False, no \'expires\' param will be set, and the cookie will be a DCNL "session cookie" which expires when the browser is closed. DCNL domain: the cookie domain. DCNL secure: if False (the default) the cookie \'secure\' value will not DCNL be set. If True, the cookie \'secure\' value will be set (to 1).'
def expire(): DCNL 'Expire the current session cookie.'
def process_body(): DCNL 'Return (params, method) from request body.'
def patched_path(path): DCNL 'Return \'path\', doctored for RPC.'
def downgrade_wsgi_ux_to_1x(environ): DCNL 'Return a new environ dict for WSGI 1.x from the given WSGI u.x environ.'
def quickstart(root=None, script_name='', config=None): DCNL 'Mount the given root, start the builtin server (and engine), then block. DCNL root: an instance of a "controller class" (a collection of page handler DCNL methods) which represents the root of the application. DCNL script_name: a string containing the "mount point" of the application. DCNL This should start with a slash, and be the path portion of the URL DCNL at which to mount the given root. For example, if root.index() will DCNL handle requests to "http://www.example.com:8080/dept/app1/", then DCNL the script_name argument would be "/dept/app1". DCNL It MUST NOT end in a slash. If the script_name refers to the root DCNL of the URI, it MUST be an empty string (not "/"). DCNL config: a file or dict containing application config. If this contains DCNL a [global] section, those entries will be used in the global DCNL (site-wide) config.'
def _cherrypy_pydoc_resolve(thing, forceload=0): DCNL 'Given an object or a path to an object, get the object and its name.'
def expose(func=None, alias=None): DCNL 'Expose the function, optionally providing an alias or set of aliases.'
def url(path='', qs='', script_name=None, base=None, relative=None): DCNL 'Create an absolute URL for the given path. DCNL If \'path\' starts with a slash (\'/\'), this will return DCNL (base + script_name + path + qs). DCNL If it does not start with a slash, this returns DCNL (base + script_name [+ request.path_info] + path + qs). DCNL If script_name is None, cherrypy.request will be used DCNL to find a script_name, if available. DCNL If base is None, cherrypy.request.base will be used (if available). DCNL Note that you can use cherrypy.tools.proxy to change this. DCNL Finally, note that this function can be used to obtain an absolute URL DCNL for the current request path (minus the querystring) by passing no args. DCNL If you call url(qs=cherrypy.request.query_string), you should get the DCNL original browser URL (assuming no internal redirections). DCNL If relative is None or not provided, request.app.relative_urls will DCNL be used (if available, else False). If False, the output will be an DCNL absolute URL (including the scheme, host, vhost, and script_name). DCNL If True, the output will instead be a URL that is relative to the DCNL current request path, perhaps including \'..\' atoms. If relative is DCNL the string \'server\', the output will instead be a URL that is DCNL relative to the server root; i.e., it will start with a slash.'
def merge(base, other): DCNL 'Merge one app config (from a dict, file, or filename) into another. DCNL If the given config is a filename, it will be appended to DCNL the list of files to monitor for "autoreload" changes.'
def _server_namespace_handler(k, v): DCNL 'Config handler for the "server" namespace.'
def _engine_namespace_handler(k, v): DCNL 'Backward compatibility handler for the "engine" namespace.'
def _tree_namespace_handler(k, v): DCNL 'Namespace handler for the \'tree\' config namespace.'
def _getargs(func): DCNL 'Return the names of all static arguments to the given function.'
def long_to_bytes(val, endianness='big'): DCNL 'Use :ref:`string formatting` and :func:`~binascii.unhexlify` to DCNL convert ``val``, a :func:`long`, to a byte :func:`str`. DCNL :param long val: The value to pack DCNL :param str endianness: The endianness of the result. ``\'big\'`` for DCNL big-endian, ``\'little\'`` for little-endian. DCNL If you want byte- and word-ordering to differ, you\'re on your own. DCNL Using :ref:`string formatting` lets us use Python\'s C innards.'
def dict_to_protobuf(pb_klass_or_instance, values, type_callable_map=REVERSE_TYPE_CALLABLE_MAP, strict=True): DCNL 'Populates a protobuf model from a dictionary. DCNL :param pb_klass_or_instance: a protobuf message class, or an protobuf instance DCNL :type pb_klass_or_instance: a type or instance of a subclass of google.protobuf.message.Message DCNL :param dict values: a dictionary of values. Repeated and nested values are DCNL fully supported. DCNL :param dict type_callable_map: a mapping of protobuf types to callables for setting DCNL values on the target instance. DCNL :param bool strict: complain if keys in the map are not fields on the message.'
def bit_size(number): DCNL 'Returns the number of bits required to hold a specific long number'
def gcd(p, q): DCNL 'Returns the greatest common divisor of p and q DCNL >>> gcd(48, 180) DCNL 12'
def bytes2int(bytes): DCNL 'Converts a list of bytes or a string to an integer DCNL >>> (((128 * 256) + 64) * 256) + 15 DCNL 8405007 DCNL >>> l = [128, 64, 15] DCNL >>> bytes2int(l)              #same as bytes2int(\'@\') DCNL 8405007'
def int2bytes(number): DCNL 'Converts a number to a string of bytes'
def to64(number): DCNL 'Converts a number in the range of 0 to 63 into base 64 digit DCNL character in the range of \'0\'-\'9\', \'A\'-\'Z\', \'a\'-\'z\',\'-\',\'_\'. DCNL >>> to64(10) DCNL \'A\''
def from64(number): DCNL 'Converts an ordinal character value in the range of DCNL 0-9,A-Z,a-z,-,_ to a number in the range of 0-63. DCNL >>> from64(49) DCNL 1'
def int2str64(number): DCNL 'Converts a number to a string of base64 encoded characters in DCNL the range of \'0\'-\'9\',\'A\'-\'Z,\'a\'-\'z\',\'-\',\'_\'. DCNL >>> int2str64(123456789) DCNL \'7MyqL\''
def str642int(string): DCNL 'Converts a base64 encoded string into an integer. DCNL The chars of this string in in the range \'0\'-\'9\',\'A\'-\'Z\',\'a\'-\'z\',\'-\',\'_\' DCNL >>> str642int(\'7MyqL\') DCNL 123456789'
def read_random_int(nbits): DCNL 'Reads a random integer of approximately nbits bits rounded up DCNL to whole bytes'
def randint(minvalue, maxvalue): DCNL 'Returns a random integer x with minvalue <= x <= maxvalue'
def jacobi(a, b): DCNL 'Calculates the value of the Jacobi symbol (a/b) DCNL where both a and b are positive integers, and b is odd'
def jacobi_witness(x, n): DCNL 'Returns False if n is an Euler pseudo-prime with base x, and DCNL True otherwise.'
def randomized_primality_testing(n, k): DCNL 'Calculates whether n is composite (which is always correct) or DCNL prime (which is incorrect with error probability 2**-k) DCNL Returns False if the number is composite, and True if it\'s DCNL probably prime.'
def is_prime(number): DCNL 'Returns True if the number is prime, and False otherwise. DCNL >>> is_prime(42) DCNL 0 DCNL >>> is_prime(41) DCNL 1'
def getprime(nbits): DCNL 'Returns a prime number of max. \'math.ceil(nbits/8)*8\' bits. In DCNL other words: nbits is rounded up to whole bytes. DCNL >>> p = getprime(8) DCNL >>> is_prime(p-1) DCNL 0 DCNL >>> is_prime(p) DCNL 1 DCNL >>> is_prime(p+1) DCNL 0'
def are_relatively_prime(a, b): DCNL 'Returns True if a and b are relatively prime, and False if they DCNL are not. DCNL >>> are_relatively_prime(2, 3) DCNL 1 DCNL >>> are_relatively_prime(2, 4) DCNL 0'
def find_p_q(nbits): DCNL 'Returns a tuple of two different primes of nbits bits'
def extended_gcd(a, b): DCNL 'Returns a tuple (r, i, j) such that r = gcd(a, b) = ia + jb'
def calculate_keys(p, q, nbits): DCNL 'Calculates an encryption and a decryption key for p and q, and DCNL returns them as a tuple (e, d)'
def gen_keys(nbits): DCNL 'Generate RSA keys of nbits bits. Returns (p, q, e, d). DCNL Note: this can take a long time, depending on the key size.'
def newkeys(nbits): DCNL 'Generates public and private keys, and returns them as (pub, DCNL priv). DCNL The public key consists of a dict {e: ..., , n: ....). The private DCNL key consists of a dict {d: ...., p: ...., q: ....).'
def encrypt_int(message, ekey, n): DCNL 'Encrypts a message using encryption key \'ekey\', working modulo n'
def decrypt_int(cyphertext, dkey, n): DCNL 'Decrypts a cypher text using the decryption key \'dkey\', working DCNL modulo n'
def encode64chops(chops): DCNL 'base64encodes chops and combines them into a \',\' delimited string'
def decode64chops(string): DCNL 'base64decodes and makes a \',\' delimited string into chops'
def chopstring(message, key, n, funcref): DCNL 'Chops the \'message\' into integers that fit into n, DCNL leaving room for a safebit to be added to ensure that all DCNL messages fold during exponentiation.  The MSB of the number n DCNL is not independant modulo n (setting it could cause overflow), so DCNL use the next lower bit for the safebit.  Therefore reserve 2-bits DCNL in the number n for non-data bits.  Calls specified encryption DCNL function for each chop. DCNL Used by \'encrypt\' and \'sign\'.'
def gluechops(string, key, n, funcref): DCNL 'Glues chops back together into a string.  calls DCNL funcref(integer, key, n) for each chop. DCNL Used by \'decrypt\' and \'verify\'.'
def encrypt(message, key): DCNL 'Encrypts a string \'message\' with the public key \'key\''
def sign(message, key): DCNL 'Signs a string \'message\' with the private key \'key\''
def decrypt(cypher, key): DCNL 'Decrypts a string \'cypher\' with the private key \'key\''
def verify(cypher, key): DCNL 'Verifies a string \'cypher\' with the public key \'key\''
def encrypt_int(message, ekey, n): DCNL 'Encrypts a message using encryption key \'ekey\', working modulo n'
def decrypt_int(cyphertext, dkey, n): DCNL 'Decrypts a cypher text using the decryption key \'dkey\', working DCNL modulo n'
def read_varint(infile): DCNL 'Reads a varint from the file. DCNL When the first byte to be read indicates EOF, (0, 0) is returned. When an DCNL EOF occurs when at least one byte has been read, an EOFError exception is DCNL raised. DCNL @param infile: the file-like object to read from. It should have a read() DCNL method. DCNL @returns (varint, length), the read varint and the number of read bytes.'
def write_varint(outfile, value): DCNL 'Writes a varint to a file. DCNL @param outfile: the file-like object to write to. It should have a write() DCNL method. DCNL @returns the number of written bytes.'
def yield_varblocks(infile): DCNL 'Generator, yields each block in the input file. DCNL @param infile: file to read, is expected to have the VARBLOCK format as DCNL described in the module\'s docstring. DCNL @yields the contents of each block.'
def yield_fixedblocks(infile, blocksize): DCNL 'Generator, yields each block of ``blocksize`` bytes in the input file. DCNL :param infile: file to read and separate in blocks. DCNL :returns: a generator that yields the contents of each block'
def _pad_for_encryption(message, target_length): DCNL 'Pads the message for encryption, returning the padded message. DCNL :return: 00 02 RANDOM_DATA 00 MESSAGE DCNL >>> block = _pad_for_encryption(\'hello\', 16) DCNL >>> len(block) DCNL 16 DCNL >>> block[0:2] DCNL \'\x00\x02\' DCNL >>> block[-6:] DCNL \'\x00hello\''
def _pad_for_signing(message, target_length): DCNL 'Pads the message for signing, returning the padded message. DCNL The padding is always a repetition of FF bytes. DCNL :return: 00 01 PADDING 00 MESSAGE DCNL >>> block = _pad_for_signing(\'hello\', 16) DCNL >>> len(block) DCNL 16 DCNL >>> block[0:2] DCNL \'\x00\x01\' DCNL >>> block[-6:] DCNL \'\x00hello\' DCNL >>> block[2:-6] DCNL \'\xff\xff\xff\xff\xff\xff\xff\xff\''
def encrypt(message, pub_key): DCNL 'Encrypts the given message using PKCS#1 v1.5 DCNL :param message: the message to encrypt. Must be a byte string no longer than DCNL ``k-11`` bytes, where ``k`` is the number of bytes needed to encode DCNL the ``n`` component of the public key. DCNL :param pub_key: the :py:class:`rsa.PublicKey` to encrypt with. DCNL :raise OverflowError: when the message is too large to fit in the padded DCNL block. DCNL >>> from rsa import key, common DCNL >>> (pub_key, priv_key) = key.newkeys(256) DCNL >>> message = \'hello\' DCNL >>> crypto = encrypt(message, pub_key) DCNL The crypto text should be just as long as the public key \'n\' component: DCNL >>> len(crypto) == common.byte_size(pub_key.n) DCNL True'
def decrypt(crypto, priv_key): DCNL 'Decrypts the given message using PKCS#1 v1.5 DCNL The decryption is considered \'failed\' when the resulting cleartext doesn\'t DCNL start with the bytes 00 02, or when the 00 byte between the padding and DCNL the message cannot be found. DCNL :param crypto: the crypto text as returned by :py:func:`rsa.encrypt` DCNL :param priv_key: the :py:class:`rsa.PrivateKey` to decrypt with. DCNL :raise DecryptionError: when the decryption fails. No details are given as DCNL to why the code thinks the decryption fails, as this would leak DCNL information about the private key. DCNL >>> import rsa DCNL >>> (pub_key, priv_key) = rsa.newkeys(256) DCNL It works with strings: DCNL >>> crypto = encrypt(\'hello\', pub_key) DCNL >>> decrypt(crypto, priv_key) DCNL \'hello\' DCNL And with binary data: DCNL >>> crypto = encrypt(\'\x00\x00\x00\x00\x01\', pub_key) DCNL >>> decrypt(crypto, priv_key) DCNL \'\x00\x00\x00\x00\x01\' DCNL Altering the encrypted information will *likely* cause a DCNL :py:class:`rsa.pkcs1.DecryptionError`. If you want to be *sure*, use DCNL :py:func:`rsa.sign`. DCNL .. warning:: DCNL Never display the stack trace of a DCNL :py:class:`rsa.pkcs1.DecryptionError` exception. It shows where in the DCNL code the exception occurred, and thus leaks information about the key. DCNL It\'s only a tiny bit of information, but every bit makes cracking the DCNL keys easier. DCNL >>> crypto = encrypt(\'hello\', pub_key) DCNL >>> crypto = crypto[0:5] + \'X\' + crypto[6:] # change a byte DCNL >>> decrypt(crypto, priv_key) DCNL Traceback (most recent call last): DCNL DecryptionError: Decryption failed'
def sign(message, priv_key, hash): DCNL 'Signs the message with the private key. DCNL Hashes the message, then signs the hash with the given key. This is known DCNL as a "detached signature", because the message itself isn\'t altered. DCNL :param message: the message to sign. Can be an 8-bit string or a file-like DCNL object. If ``message`` has a ``read()`` method, it is assumed to be a DCNL file-like object. DCNL :param priv_key: the :py:class:`rsa.PrivateKey` to sign with DCNL :param hash: the hash method used on the message. Use \'MD5\', \'SHA-1\', DCNL \'SHA-256\', \'SHA-384\' or \'SHA-512\'. DCNL :return: a message signature block. DCNL :raise OverflowError: if the private key is too small to contain the DCNL requested hash.'
def verify(message, signature, pub_key): DCNL 'Verifies that the signature matches the message. DCNL The hash method is detected automatically from the signature. DCNL :param message: the signed message. Can be an 8-bit string or a file-like DCNL object. If ``message`` has a ``read()`` method, it is assumed to be a DCNL file-like object. DCNL :param signature: the signature block, as created with :py:func:`rsa.sign`. DCNL :param pub_key: the :py:class:`rsa.PublicKey` of the person signing the message. DCNL :raise VerificationError: when the signature doesn\'t match the message. DCNL .. warning:: DCNL Never display the stack trace of a DCNL :py:class:`rsa.pkcs1.VerificationError` exception. It shows where in DCNL the code the exception occurred, and thus leaks information about the DCNL key. It\'s only a tiny bit of information, but every bit makes cracking DCNL the keys easier.'
def _hash(message, method_name): DCNL 'Returns the message digest. DCNL :param message: the signed message. Can be an 8-bit string or a file-like DCNL object. If ``message`` has a ``read()`` method, it is assumed to be a DCNL file-like object. DCNL :param method_name: the hash method, must be a key of DCNL :py:const:`HASH_METHODS`.'
def _find_method_hash(method_hash): DCNL 'Finds the hash method and the hash itself. DCNL :param method_hash: ASN1 code for the hash method concatenated with the DCNL hash itself. DCNL :return: tuple (method, hash) where ``method`` is the used hash method, and DCNL ``hash`` is the hash itself. DCNL :raise VerificationFailed: when the hash method cannot be found'
def _markers(pem_marker): DCNL 'Returns the start and end PEM markers'
def load_pem(contents, pem_marker): DCNL 'Loads a PEM file. DCNL @param contents: the contents of the file to interpret DCNL @param pem_marker: the marker of the PEM content, such as \'RSA PRIVATE KEY\' DCNL when your file has \'-----BEGIN RSA PRIVATE KEY-----\' and DCNL \'-----END RSA PRIVATE KEY-----\' markers. DCNL @return the base64-decoded content between the start and end markers. DCNL @raise ValueError: when the content is invalid, for example when the start DCNL marker cannot be found.'
def save_pem(contents, pem_marker): DCNL 'Saves a PEM file. DCNL @param contents: the contents to encode in PEM format DCNL @param pem_marker: the marker of the PEM content, such as \'RSA PRIVATE KEY\' DCNL when your file has \'-----BEGIN RSA PRIVATE KEY-----\' and DCNL \'-----END RSA PRIVATE KEY-----\' markers. DCNL @return the base64-encoded content between the start and end markers.'
def keygen(): DCNL 'Key generator.'
def is_bytes(obj): DCNL 'Determines whether the given value is a byte string. DCNL :param obj: DCNL The value to test. DCNL :returns: DCNL ``True`` if ``value`` is a byte string; ``False`` otherwise.'
def is_integer(obj): DCNL 'Determines whether the given value is an integer. DCNL :param obj: DCNL The value to test. DCNL :returns: DCNL ``True`` if ``value`` is an integer; ``False`` otherwise.'
def byte(num): DCNL 'Converts a number between 0 and 255 (both inclusive) to a base-256 (byte) DCNL representation. DCNL Use it as a replacement for ``chr`` where you are expecting a byte DCNL because this will work on all current versions of Python:: DCNL :param num: DCNL An unsigned integer between 0 and 255 (both inclusive). DCNL :returns: DCNL A single byte.'
def get_word_alignment(num, force_arch=64, _machine_word_size=MACHINE_WORD_SIZE): DCNL 'Returns alignment details for the given number based on the platform DCNL Python is running on. DCNL :param num: DCNL Unsigned integral number. DCNL :param force_arch: DCNL If you don\'t want to use 64-bit unsigned chunks, set this to DCNL anything other than 64. 32-bit chunks will be preferred then. DCNL Default 64 will be used when on a 64-bit machine. DCNL :param _machine_word_size: DCNL (Internal) The machine word size used for alignment. DCNL :returns: DCNL 4-tuple:: DCNL (word_bits, word_bytes, DCNL max_uint, packing_format_type)'
def bytes2int(raw_bytes): DCNL 'Converts a list of bytes or an 8-bit string to an integer. DCNL When using unicode strings, encode it to some encoding like UTF8 first. DCNL >>> (((128 * 256) + 64) * 256) + 15 DCNL 8405007 DCNL >>> bytes2int(\'\x80@\x0f\') DCNL 8405007'
def _int2bytes(number, block_size=None): DCNL 'Converts a number to a string of bytes. DCNL Usage:: DCNL >>> _int2bytes(123456789) DCNL \'\x07[\xcd\x15\' DCNL >>> bytes2int(_int2bytes(123456789)) DCNL 123456789 DCNL >>> _int2bytes(123456789, 6) DCNL \'\x00\x00\x07[\xcd\x15\' DCNL >>> bytes2int(_int2bytes(123456789, 128)) DCNL 123456789 DCNL >>> _int2bytes(123456789, 3) DCNL Traceback (most recent call last): DCNL OverflowError: Needed 4 bytes for number, but block size is 3 DCNL @param number: the number to convert DCNL @param block_size: the number of bytes to output. If the number encoded to DCNL bytes is less than this, the block will be zero-padded. When not given, DCNL the returned block is not padded. DCNL @throws OverflowError when block_size is given and the number takes up more DCNL bytes than fit into the block.'
def bytes_leading(raw_bytes, needle=ZERO_BYTE): DCNL 'Finds the number of prefixed byte occurrences in the haystack. DCNL Useful when you want to deal with padding. DCNL :param raw_bytes: DCNL Raw bytes. DCNL :param needle: DCNL The byte to count. Default  . DCNL :returns: DCNL The number of leading needle bytes.'
def int2bytes(number, fill_size=None, chunk_size=None, overflow=False): DCNL 'Convert an unsigned integer to bytes (base-256 representation):: DCNL Does not preserve leading zeros if you don\'t specify a chunk size or DCNL fill size. DCNL .. NOTE: DCNL You must not specify both fill_size and chunk_size. Only one DCNL of them is allowed. DCNL :param number: DCNL Integer value DCNL :param fill_size: DCNL If the optional fill size is given the length of the resulting DCNL byte string is expected to be the fill size and will be padded DCNL with prefix zero bytes to satisfy that length. DCNL :param chunk_size: DCNL If optional chunk size is given and greater than zero, pad the front of DCNL the byte string with binary zeros so that the length is a multiple of DCNL ``chunk_size``. DCNL :param overflow: DCNL ``False`` (default). If this is ``True``, no ``OverflowError`` DCNL will be raised when the fill_size is shorter than the length DCNL of the generated byte sequence. Instead the byte sequence will DCNL be returned as is. DCNL :returns: DCNL Raw bytes (base-256 representation). DCNL :raises: DCNL ``OverflowError`` when fill_size is given and the number takes up more DCNL bytes than fit into the block. This requires the ``overflow`` DCNL argument to this function to be set to ``False`` otherwise, no DCNL error will be raised.'
def getprime(nbits, poolsize): DCNL 'Returns a prime number that can be stored in \'nbits\' bits. DCNL Works in multiple threads at the same time. DCNL >>> p = getprime(128, 3) DCNL >>> rsa.prime.is_prime(p-1) DCNL False DCNL >>> rsa.prime.is_prime(p) DCNL True DCNL >>> rsa.prime.is_prime(p+1) DCNL False DCNL >>> from rsa import common DCNL >>> common.bit_size(p) == 128 DCNL True'
def encrypt_bigfile(infile, outfile, pub_key): DCNL 'Encrypts a file, writing it to \'outfile\' in VARBLOCK format. DCNL :param infile: file-like object to read the cleartext from DCNL :param outfile: file-like object to write the crypto in VARBLOCK format to DCNL :param pub_key: :py:class:`rsa.PublicKey` to encrypt with'
def decrypt_bigfile(infile, outfile, priv_key): DCNL 'Decrypts an encrypted VARBLOCK file, writing it to \'outfile\' DCNL :param infile: file-like object to read the crypto in VARBLOCK format from DCNL :param outfile: file-like object to write the cleartext to DCNL :param priv_key: :py:class:`rsa.PrivateKey` to decrypt with'
def read_random_bits(nbits): DCNL 'Reads \'nbits\' random bits. DCNL If nbits isn\'t a whole number of bytes, an extra byte will be appended with DCNL only the lower bits set.'
def read_random_int(nbits): DCNL 'Reads a random integer of approximately nbits bits.'
def randint(maxvalue): DCNL 'Returns a random integer x with 1 <= x <= maxvalue DCNL May take a very long time in specific situations. If maxvalue needs N bits DCNL to store, the closer maxvalue is to (2 ** N) - 1, the faster this function DCNL is.'
def bit_size(num): DCNL 'Number of bits needed to represent a integer excluding any prefix DCNL 0 bits. DCNL As per definition from http://wiki.python.org/moin/BitManipulation and DCNL to match the behavior of the Python 3 API. DCNL Usage:: DCNL >>> bit_size(1023) DCNL 10 DCNL >>> bit_size(1024) DCNL 11 DCNL >>> bit_size(1025) DCNL 11 DCNL :param num: DCNL Integer value. If num is 0, returns 0. Only the absolute value of the DCNL number is considered. Therefore, signed integers will be abs(num) DCNL before the number\'s bit length is determined. DCNL :returns: DCNL Returns the number of bits in the integer.'
def _bit_size(number): DCNL 'Returns the number of bits required to hold a specific long number.'
def byte_size(number): DCNL 'Returns the number of bytes required to hold a specific long number. DCNL The number of bytes is rounded up. DCNL Usage:: DCNL >>> byte_size(1 << 1023) DCNL 128 DCNL >>> byte_size((1 << 1024) - 1) DCNL 128 DCNL >>> byte_size(1 << 1024) DCNL 129 DCNL :param number: DCNL An unsigned integer DCNL :returns: DCNL The number of bytes required to hold a specific long number.'
def extended_gcd(a, b): DCNL 'Returns a tuple (r, i, j) such that r = gcd(a, b) = ia + jb'
def inverse(x, n): DCNL 'Returns x^-1 (mod n) DCNL >>> inverse(7, 4) DCNL 3 DCNL >>> (inverse(143, 4) * 143) % 4 DCNL 1'
def crt(a_values, modulo_values): DCNL 'Chinese Remainder Theorem. DCNL Calculates x such that x = a[i] (mod m[i]) for each i. DCNL :param a_values: the a-values of the above equation DCNL :param modulo_values: the m-values of the above equation DCNL :returns: x such that x = a[i] (mod m[i]) for each i DCNL >>> crt([2, 3], [3, 5]) DCNL 8 DCNL >>> crt([2, 3, 2], [3, 5, 7]) DCNL 23 DCNL >>> crt([2, 3, 0], [7, 11, 15]) DCNL 135'
def gcd(p, q): DCNL 'Returns the greatest common divisor of p and q DCNL >>> gcd(48, 180) DCNL 12'
def jacobi(a, b): DCNL 'Calculates the value of the Jacobi symbol (a/b) where both a and b are DCNL positive integers, and b is odd DCNL :returns: -1, 0 or 1'
def jacobi_witness(x, n): DCNL 'Returns False if n is an Euler pseudo-prime with base x, and DCNL True otherwise.'
def randomized_primality_testing(n, k): DCNL 'Calculates whether n is composite (which is always correct) or DCNL prime (which is incorrect with error probability 2**-k) DCNL Returns False if the number is composite, and True if it\'s DCNL probably prime.'
def is_prime(number): DCNL 'Returns True if the number is prime, and False otherwise. DCNL >>> is_prime(42) DCNL False DCNL >>> is_prime(41) DCNL True'
def getprime(nbits): DCNL 'Returns a prime number that can be stored in \'nbits\' bits. DCNL >>> p = getprime(128) DCNL >>> is_prime(p-1) DCNL False DCNL >>> is_prime(p) DCNL True DCNL >>> is_prime(p+1) DCNL False DCNL >>> from rsa import common DCNL >>> common.bit_size(p) == 128 DCNL True'
def are_relatively_prime(a, b): DCNL 'Returns True if a and b are relatively prime, and False if they DCNL are not. DCNL >>> are_relatively_prime(2, 3) DCNL 1 DCNL >>> are_relatively_prime(2, 4) DCNL 0'
def find_p_q(nbits, getprime_func=rsa.prime.getprime, accurate=True): DCNL '\'Returns a tuple of two different primes of nbits bits each. DCNL The resulting p * q has exacty 2 * nbits bits, and the returned p and q DCNL will not be equal. DCNL :param nbits: the number of bits in each of p and q. DCNL :param getprime_func: the getprime function, defaults to DCNL :py:func:`rsa.prime.getprime`. DCNL *Introduced in Python-RSA 3.1* DCNL :param accurate: whether to enable accurate mode or not. DCNL :returns: (p, q), where p > q DCNL >>> (p, q) = find_p_q(128) DCNL >>> from rsa import common DCNL >>> common.bit_size(p * q) DCNL 256 DCNL When not in accurate mode, the number of bits can be slightly less DCNL >>> (p, q) = find_p_q(128, accurate=False) DCNL >>> from rsa import common DCNL >>> common.bit_size(p * q) <= 256 DCNL True DCNL >>> common.bit_size(p * q) > 240 DCNL True'
def calculate_keys(p, q, nbits): DCNL 'Calculates an encryption and a decryption key given p and q, and DCNL returns them as a tuple (e, d)'
def gen_keys(nbits, getprime_func, accurate=True): DCNL 'Generate RSA keys of nbits bits. Returns (p, q, e, d). DCNL Note: this can take a long time, depending on the key size. DCNL :param nbits: the total number of bits in ``p`` and ``q``. Both ``p`` and DCNL ``q`` will use ``nbits/2`` bits. DCNL :param getprime_func: either :py:func:`rsa.prime.getprime` or a function DCNL with similar signature.'
def newkeys(nbits, accurate=True, poolsize=1): DCNL 'Generates public and private keys, and returns them as (pub, priv). DCNL The public key is also known as the \'encryption key\', and is a DCNL :py:class:`rsa.PublicKey` object. The private key is also known as the DCNL \'decryption key\' and is a :py:class:`rsa.PrivateKey` object. DCNL :param nbits: the number of bits required to store ``n = p*q``. DCNL :param accurate: when True, ``n`` will have exactly the number of bits you DCNL asked for. However, this makes key generation much slower. When False, DCNL `n`` may have slightly less bits. DCNL :param poolsize: the number of processes to use to generate the prime DCNL numbers. If set to a number > 1, a parallel algorithm will be used. DCNL This requires Python 2.6 or newer. DCNL :returns: a tuple (:py:class:`rsa.PublicKey`, :py:class:`rsa.PrivateKey`) DCNL The ``poolsize`` parameter was added in *Python-RSA 3.1* and requires DCNL Python 2.6 or newer.'
def gcd(p, q): DCNL 'Returns the greatest common divisor of p and q DCNL >>> gcd(42, 6) DCNL 6'
def bytes2int(bytes): DCNL 'Converts a list of bytes or a string to an integer DCNL >>> (128*256 + 64)*256 + + 15 DCNL 8405007 DCNL >>> l = [128, 64, 15] DCNL >>> bytes2int(l) DCNL 8405007'
def int2bytes(number): DCNL 'Converts a number to a string of bytes DCNL >>> bytes2int(int2bytes(123456789)) DCNL 123456789'
def fast_exponentiation(a, p, n): DCNL 'Calculates r = a^p mod n'
def read_random_int(nbits): DCNL 'Reads a random integer of approximately nbits bits rounded up DCNL to whole bytes'
def ceil(x): DCNL 'ceil(x) -> int(math.ceil(x))'
def randint(minvalue, maxvalue): DCNL 'Returns a random integer x with minvalue <= x <= maxvalue'
def fermat_little_theorem(p): DCNL 'Returns 1 if p may be prime, and something else if p definitely DCNL is not prime'
def jacobi(a, b): DCNL 'Calculates the value of the Jacobi symbol (a/b)'
def jacobi_witness(x, n): DCNL 'Returns False if n is an Euler pseudo-prime with base x, and DCNL True otherwise.'
def randomized_primality_testing(n, k): DCNL 'Calculates whether n is composite (which is always correct) or DCNL prime (which is incorrect with error probability 2**-k) DCNL Returns False if the number if composite, and True if it\'s DCNL probably prime.'
def is_prime(number): DCNL 'Returns True if the number is prime, and False otherwise. DCNL >>> is_prime(42) DCNL 0 DCNL >>> is_prime(41) DCNL 1'
def getprime(nbits): DCNL 'Returns a prime number of max. \'math.ceil(nbits/8)*8\' bits. In DCNL other words: nbits is rounded up to whole bytes. DCNL >>> p = getprime(8) DCNL >>> is_prime(p-1) DCNL 0 DCNL >>> is_prime(p) DCNL 1 DCNL >>> is_prime(p+1) DCNL 0'
def are_relatively_prime(a, b): DCNL 'Returns True if a and b are relatively prime, and False if they DCNL are not. DCNL >>> are_relatively_prime(2, 3) DCNL 1 DCNL >>> are_relatively_prime(2, 4) DCNL 0'
def find_p_q(nbits): DCNL 'Returns a tuple of two different primes of nbits bits'
def extended_euclid_gcd(a, b): DCNL 'Returns a tuple (d, i, j) such that d = gcd(a, b) = ia + jb'
def calculate_keys(p, q, nbits): DCNL 'Calculates an encryption and a decryption key for p and q, and DCNL returns them as a tuple (e, d)'
def gen_keys(nbits): DCNL 'Generate RSA keys of nbits bits. Returns (p, q, e, d). DCNL Note: this can take a long time, depending on the key size.'
def gen_pubpriv_keys(nbits): DCNL 'Generates public and private keys, and returns them as (pub, DCNL priv). DCNL The public key consists of a dict {e: ..., , n: ....). The private DCNL key consists of a dict {d: ...., p: ...., q: ....).'
def encrypt_int(message, ekey, n): DCNL 'Encrypts a message using encryption key \'ekey\', working modulo DCNL n'
def decrypt_int(cyphertext, dkey, n): DCNL 'Decrypts a cypher text using the decryption key \'dkey\', working DCNL modulo n'
def sign_int(message, dkey, n): DCNL 'Signs \'message\' using key \'dkey\', working modulo n'
def verify_int(signed, ekey, n): DCNL 'verifies \'signed\' using key \'ekey\', working modulo n'
def picklechops(chops): DCNL 'Pickles and base64encodes it\'s argument chops'
def unpicklechops(string): DCNL 'base64decodes and unpickes it\'s argument string into chops'
def chopstring(message, key, n, funcref): DCNL 'Splits \'message\' into chops that are at most as long as n, DCNL converts these into integers, and calls funcref(integer, key, n) DCNL for each chop. DCNL Used by \'encrypt\' and \'sign\'.'
def gluechops(chops, key, n, funcref): DCNL 'Glues chops back together into a string.  calls DCNL funcref(integer, key, n) for each chop. DCNL Used by \'decrypt\' and \'verify\'.'
def encrypt(message, key): DCNL 'Encrypts a string \'message\' with the public key \'key\''
def sign(message, key): DCNL 'Signs a string \'message\' with the private key \'key\''
def decrypt(cypher, key): DCNL 'Decrypts a cypher with the private key \'key\''
def verify(cypher, key): DCNL 'Verifies a cypher with the public key \'key\''
def private_to_public(): DCNL 'Reads a private key and outputs the corresponding public key.'
def smart_truncate(string, max_length=0, word_boundaries=False, separator=' DCSP '): DCNL 'Truncate a string'
def slugify(text, entities=True, decimal=True, hexadecimal=True, max_length=0, word_boundary=False, separator='-'): DCNL 'Make a slug from the given text'
def central_server_down_or_error(error_msg): DCNL 'If the central server is down, return a context that says so. DCNL Otherwise, pass along the actual error returned by the central server. DCNL error_msg: a string'
@allow_jsonp DCNL def register_public_key_server_auto(request): DCNL 'This function allows an anonymous client to request a device key DCNL to be associated with a new zone. DCNL This allows registration to occur without a single login; the device DCNL will be associated with a headless zone.'
@csrf_exempt DCNL def register_device(request): DCNL 'Receives the client device info from the distributed server. DCNL Tries to register either because the device has been pre-registered, DCNL or because it has a valid INSTALL_CERTIFICATE.'
@allow_jsonp DCNL def get_server_info(request): DCNL 'This function is used to check connection to central or local server and also to get specific data from server. DCNL Args: DCNL The http request. DCNL Returns: DCNL A json object containing general data from the server.'
def require_registration(resource_name): DCNL 'Gets ID of requested user (not necessarily the user logged in)'
@transaction.commit_on_success DCNL def load_data_for_offline_install(in_file): DCNL 'Receives a serialized file for import. DCNL Import the file--nothing more! DCNL File should contain: DCNL * Central server object DCNL and, optionally DCNL * Zone object DCNL * Device and DeviceZone / ZoneInvitation objects (chain of trust) DCNL Essentially duplicates code from securesync.device.api_client:RegistrationClient'
def _get_own_device(): DCNL 'To allow imports to resolve... the only ugly thing of this code separation.'
def add_syncing_models(models, dependency_check=False): DCNL 'When sync is run, these models will be sync\'d'
def get_device_counters(**kwargs): DCNL 'Get device counters, filtered by zone'
def get_models(device_counters=None, limit=None, zone=None, dest_version=None, **kwargs): DCNL 'Serialize models for some intended version (dest_version) DCNL Default is our own version--i.e. include all known fields. DCNL If serializing for a device of a lower version, pass in that device\'s version!'
def save_serialized_models(data, increment_counters=True, src_version=None, verbose=False): DCNL 'Unserializes models (from a device of version=src_version) in data and saves them to the django database. DCNL If src_version is None, all unrecognized fields are (silently) stripped off. DCNL If it is set to some value, then only fields of versions higher than ours are stripped off. DCNL By defaulting to src_version=None, we\'re expecting a perfect match when we come in DCNL (i.e. that wherever we got this data from, they were smart enough to "dumb it down" for us, DCNL or they were old enough to have nothing unexpected) DCNL So, care must be taken in calling this function DCNL Returns a dictionary of the # of saved models, # unsaved, and any exceptions during saving'
def serialize(models, sign=True, increment_counters=True, dest_version=VERSION, *args, **kwargs): DCNL 'This function encapsulates serialization, and ensures that any final steps needed before syncing DCNL (e.g. signing, incrementing counters, etc) are done.'
def deserialize(data, src_version=VERSION, dest_version=VERSION, *args, **kwargs): DCNL 'Similar to serialize, except for deserialization.'
@csrf_exempt DCNL @gzip_page DCNL @require_sync_session DCNL @api_handle_error_with_json DCNL def device_download(data, session): DCNL 'This device is having its own devices downloaded'
@csrf_exempt DCNL @require_sync_session DCNL @api_handle_error_with_json DCNL def device_upload(data, session): DCNL 'This device is getting device-related objects from another device'
@csrf_exempt DCNL @require_sync_session DCNL @api_handle_error_with_json DCNL def model_upload(data, session): DCNL 'This device is getting data-related objects from another device.'
@csrf_exempt DCNL @gzip_page DCNL @require_sync_session DCNL @api_handle_error_with_json DCNL def model_download(data, session): DCNL 'This device is having its own data downloaded'
@require_admin DCNL @api_handle_error_with_json DCNL def force_sync(request): DCNL ''
def x_server_test(f, cond, msg): DCNL 'Decorator to label test classes or instance methods as x_only, DCNL x = "main" or "central"'
def distributed_server_test(f): DCNL 'Run the test only on the distributed server'
def central_server_test(f): DCNL 'Run the test only on the central server'
def contextmanager(func): DCNL '@contextmanager decorator. DCNL Typical usage: DCNL @contextmanager DCNL def some_generator(<arguments>): DCNL <setup> DCNL try: DCNL yield <value> DCNL finally: DCNL <cleanup> DCNL This makes this: DCNL with some_generator(<arguments>) as <variable>: DCNL <body> DCNL equivalent to this: DCNL <setup> DCNL try: DCNL <variable> = <value> DCNL <body> DCNL finally: DCNL <cleanup>'
def memory_usage(proc=(-1), interval=0.1, timeout=None): DCNL 'Return the memory usage of a process or piece of code DCNL Parameters DCNL proc : {int, string, tuple, subprocess.Popen}, optional DCNL The process to monitor. Can be given by an integer/string DCNL representing a PID, by a Popen object or by a tuple DCNL representing a Python function. The tuple contains three DCNL values (f, args, kw) and specifies to run the function DCNL f(*args, **kw). DCNL Set to -1 (default) for current process. DCNL interval : float, optional DCNL Interval at which measurements are collected. DCNL timeout : float, optional DCNL Maximum amount of time (in seconds) to wait before returning. DCNL Returns DCNL mem_usage : list of floating-poing values DCNL memory usage, in MB. It\'s length is always < timeout / interval'
def _find_script(script_name): DCNL 'Find the script. DCNL If the input is not a file, then $PATH will be searched.'
def magic_mprun(self, parameter_s=''): DCNL 'Execute a statement under the line-by-line memory profiler from the DCNL memory_profilser module. DCNL Usage: DCNL %mprun -f func1 -f func2 <statement> DCNL The given statement (which doesn\'t require quote marks) is run via the DCNL LineProfiler. Profiling is enabled for the functions specified by the -f DCNL options. The statistics will be shown side-by-side with the code through DCNL the pager once the statement has completed. DCNL Options: DCNL -f <function>: LineProfiler only profiles functions and methods it is told DCNL to profile.  This option tells the profiler about these functions. Multiple DCNL -f options may be used. The argument may be any expression that gives DCNL a Python function or method object. However, one must be careful to avoid DCNL spaces that may confuse the option parser. Additionally, functions defined DCNL in the interpreter at the In[] prompt or via %run currently cannot be DCNL displayed.  Write these functions out to a separate file and import them. DCNL One or more -f options are required to get any useful results. DCNL -T <filename>: dump the text-formatted statistics with the code DCNL side-by-side out to a text file. DCNL -r: return the LineProfiler object after it has completed profiling.'
def magic_memit(self, line=''): DCNL 'Measure memory usage of a Python statement DCNL Usage, in line mode: DCNL %memit [-r<R>t<T>] statement DCNL Options: DCNL -r<R>: repeat the loop iteration <R> times and take the best result. DCNL Default: 1 DCNL -t<T>: timeout after <T> seconds. Default: None DCNL Examples DCNL In [1]: import numpy as np DCNL In [2]: %memit np.zeros(1e7) DCNL maximum of 1: 76.402344 MB per loop DCNL In [3]: %memit np.ones(1e6) DCNL maximum of 1: 7.820312 MB per loop DCNL In [4]: %memit -r 10 np.empty(1e8) DCNL maximum of 10: 0.101562 MB per loop'
def load_ipython_extension(ip): DCNL 'This is called to load the module as an IPython extension.'
def profile(func, stream=None): DCNL 'Decorator that will run the function and print a line-by-line profile'
def iri2uri(uri): DCNL 'Convert an IRI to a URI. Note that IRIs must be DCNL passed in a unicode strings. That is, do not utf-8 encode DCNL the IRI before passing it into the function.'
def HTTPResponse__getheaders(self): DCNL 'Return list of (header, value) tuples.'
def parse_uri(uri): DCNL 'Parses a URI using the regex given in Appendix B of RFC 3986. DCNL (scheme, authority, path, query, fragment) = parse_uri(uri)'
def safename(filename): DCNL 'Return a filename suitable for the cache. DCNL Strips dangerous and common characters to create a filename we DCNL can use to store the cache in.'
def _parse_www_authenticate(headers, headername='www-authenticate'): DCNL 'Returns a dictionary of dictionaries, one dict DCNL per auth_scheme.'
def _entry_disposition(response_headers, request_headers): DCNL 'Determine freshness from the Date, Expires and Cache-Control headers. DCNL We don\'t handle the following: DCNL 1. Cache-Control: max-stale DCNL 2. Age: headers are not used in the calculations. DCNL Not that this algorithm is simpler than you might think DCNL because we are operating as a private (non-shared) cache. DCNL This lets us ignore \'s-maxage\'. We can also ignore DCNL \'proxy-invalidate\' since we aren\'t a proxy. DCNL We will never return a stale document as DCNL fresh as a design decision, and thus the non-implementation DCNL of \'max-stale\'. This also lets us safely ignore \'must-revalidate\' DCNL since we operate as if every server has sent \'must-revalidate\'. DCNL Since we are private we get to ignore both \'public\' and DCNL \'private\' parameters. We also ignore \'no-transform\' since DCNL we don\'t do any transformations. DCNL The \'no-store\' parameter is handled at a higher level. DCNL So the only Cache-Control parameters we look at are: DCNL no-cache DCNL only-if-cached DCNL max-age DCNL min-fresh'
def proxy_info_from_environment(method='http'): DCNL 'Read proxy info from the environment variables.'
def proxy_info_from_url(url, method='http'): DCNL 'Construct a ProxyInfo from a URL (such as http_proxy env var)'
def setdefaultproxy(proxytype=None, addr=None, port=None, rdns=True, username=None, password=None): DCNL 'setdefaultproxy(proxytype, addr[, port[, rdns[, username[, password]]]]) DCNL Sets a default proxy which all further socksocket objects will use, DCNL unless explicitly changed.'
def wrapmodule(module): DCNL 'wrapmodule(module) DCNL Attempts to replace a module\'s socket library with a SOCKS socket. Must set DCNL a default proxy using setdefaultproxy(...) first. DCNL This will only work on modules that import socket directly into the namespace; DCNL most of the Python Standard Library falls into this category.'
def get_object_or_None(klass, *args, **kwargs): DCNL 'Uses get() to return an object or None if the object does not exist. DCNL klass may be a Model, Manager, or QuerySet object. All other passed DCNL arguments and keyword arguments are used in the get() query. DCNL Note: Like with get(), a MultipleObjectsReturned will be raised if more than one DCNL object is found.'
def get_config(key, default): DCNL 'Get settings from django.conf if exists, DCNL return default value otherwise DCNL example: DCNL ADMIN_EMAIL = get_config(\'ADMIN_EMAIL\', \'default@email.com\')'
def render_to(template=None, mimetype=None): DCNL 'Decorator for Django views that sends returned dict to render_to_response DCNL function. DCNL Template name can be decorator parameter or TEMPLATE item in returned DCNL dictionary.  RequestContext always added as context instance. DCNL If view doesn\'t return dict then decorator simply returns output. DCNL Parameters: DCNL - template: template name to use DCNL - mimetype: content type to send in response headers DCNL Examples: DCNL # 1. Template name in decorator parameters DCNL @render_to(\'template.html\') DCNL def foo(request): DCNL bar = Bar.object.all() DCNL return {\'bar\': bar} DCNL # equals to DCNL def foo(request): DCNL bar = Bar.object.all() DCNL return render_to_response(\'template.html\', DCNL {\'bar\': bar}, DCNL context_instance=RequestContext(request)) DCNL # 2. Template name as TEMPLATE item value in return dictionary. DCNL if TEMPLATE is given then its value will have higher priority DCNL than render_to argument. DCNL @render_to() DCNL def foo(request, category): DCNL template_name = \'%s.html\' % category DCNL return {\'bar\': bar, \'TEMPLATE\': template_name} DCNL #equals to DCNL def foo(request, category): DCNL template_name = \'%s.html\' % category DCNL return render_to_response(template_name, DCNL {\'bar\': bar}, DCNL context_instance=RequestContext(request))'
def ajax_request(func): DCNL 'If view returned serializable dict, returns JsonResponse with this dict as content. DCNL example: DCNL @ajax_request DCNL def my_view(request): DCNL news = News.objects.all() DCNL news_titles = [entry.title for entry in news] DCNL return {\'news_titles\': news_titles}'
def autostrip(cls): DCNL 'strip text fields before validation DCNL example: DCNL class PersonForm(forms.Form): DCNL name = forms.CharField(min_length=2, max_length=10) DCNL email = forms.EmailField() DCNL PersonForm = autostrip(PersonForm) DCNL #or you can use @autostrip in python >= 2.6 DCNL Author: nail.xx'
def smart_if(parser, token): DCNL 'A smarter {% if %} tag for django templates. DCNL While retaining current Django functionality, it also handles equality, DCNL greater than and less than operators. Some common case examples:: DCNL {% if articles|length >= 5 %}...{% endif %} DCNL {% if "ifnotequal tag" != "beautiful" %}...{% endif %} DCNL Arguments and operators _must_ have a space between them, so DCNL ``{% if 1>2 %}`` is not a valid smart if tag. DCNL All supported operators are: ``or``, ``and``, ``in``, ``=`` (or ``==``), DCNL ``!=``, ``>``, ``>=``, ``<`` and ``<=``.'
def align_to_mmap(num, round_up): DCNL 'Align the given integer number to the closest page offset, which usually is 4096 bytes. DCNL :param round_up: if True, the next higher multiple of page size is used, otherwise DCNL the lower page_size will be used (i.e. if True, 1 becomes 4096, otherwise it becomes 0) DCNL :return: num rounded to closest page'
def is_64_bit(): DCNL ':return: True if the system is 64 bit. Otherwise it can be assumed to be 32 bit'
def xldate_as_datetime(xldate, datemode): DCNL 'Convert an Excel date/time number into a datetime.datetime object.'
def xldate_from_date_tuple(date_tuple, datemode): DCNL 'Create an excel date from a tuple of (year, month, day)'
def xldate_from_time_tuple(time_tuple): DCNL 'Create an excel date from a tuple of (hour, minute, second)'
def unpack_SST_table(datatab, nstrings): DCNL 'Return list of strings'
def unpack_unicode(data, pos, lenlen=2): DCNL 'Return unicode_strg'
def unpack_unicode_update_pos(data, pos, lenlen=2, known_len=None): DCNL 'Return (unicode_strg, updated value of pos)'
def get_text_from_si_or_is(self, elem, r_tag=(U_SSML12 + u'r'), t_tag=(U_SSML12 + u't')): DCNL 'Returns unescaped unicode'
def num2strg(num): DCNL 'Attempt to emulate Excel\'s default conversion DCNL from number to string.'
def cellname(rowx, colx): DCNL '(5, 7) => \'H6\''
def cellnameabs(rowx, colx, r1c1=0): DCNL '(5, 7) => \'$H$6\' or \'R8C6\''
def colname(colx): DCNL '7 => \'H\', 27 => \'AB\''
def rangename2d(rlo, rhi, clo, chi, r1c1=0): DCNL '(5, 20, 7, 10) => \'$H$6:$J$20\''
def rangename3d(book, ref3d): DCNL 'Ref3D(1, 4, 5, 20, 7, 10) => \'Sheet2:Sheet3!$H$6:$J$20\' DCNL (assuming Excel\'s default sheetnames)'
def parse_mime_type(mime_type): DCNL 'Parses a mime-type into its component parts. DCNL Carves up a mime-type and returns a tuple of the (type, subtype, params) DCNL where \'params\' is a dictionary of all the parameters for the media range. DCNL For example, the media range \'application/xhtml;q=0.5\' would get parsed DCNL into: DCNL (\'application\', \'xhtml\', {\'q\', \'0.5\'})'
def parse_media_range(range): DCNL 'Parse a media-range into its component parts. DCNL Carves up a media range and returns a tuple of the (type, subtype, DCNL params) where \'params\' is a dictionary of all the parameters for the media DCNL range.  For example, the media range \'application/*;q=0.5\' would get parsed DCNL into: DCNL (\'application\', \'*\', {\'q\', \'0.5\'}) DCNL In addition this function also guarantees that there is a value for \'q\' DCNL in the params dictionary, filling it in with a proper default if DCNL necessary.'
def fitness_and_quality_parsed(mime_type, parsed_ranges): DCNL 'Find the best match for a mime-type amongst parsed media-ranges. DCNL Find the best match for a given mime-type against a list of media_ranges DCNL that have already been parsed by parse_media_range(). Returns a tuple of DCNL the fitness value and the value of the \'q\' quality parameter of the best DCNL match, or (-1, 0) if no match was found. Just as for quality_parsed(), DCNL \'parsed_ranges\' must be a list of parsed media ranges.'
def quality_parsed(mime_type, parsed_ranges): DCNL 'Find the best match for a mime-type amongst parsed media-ranges. DCNL Find the best match for a given mime-type against a list of media_ranges DCNL that have already been parsed by parse_media_range(). Returns the \'q\' DCNL quality parameter of the best match, 0 if no match was found. This function DCNL bahaves the same as quality() except that \'parsed_ranges\' must be a list of DCNL parsed media ranges.'
def quality(mime_type, ranges): DCNL 'Return the quality (\'q\') of a mime-type against a list of media-ranges. DCNL Returns the quality \'q\' of a mime-type when compared against the DCNL media-ranges in ranges. For example: DCNL >>> quality(\'text/html\',\'text/*;q=0.3, text/html;q=0.7, DCNL text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5\') DCNL 0.7'
def best_match(supported, header): DCNL 'Return mime-type with the highest quality (\'q\') from list of candidates. DCNL Takes a list of supported mime-types and finds the best match for all the DCNL media-ranges listed in header. The value of header must be a string that DCNL conforms to the format of the HTTP Accept: header. The value of \'supported\' DCNL is a list of mime-types. The list of supported mime-types should be sorted DCNL in order of increasing desirability, in case of a situation where there is DCNL a tie. DCNL >>> best_match([\'application/xbel+xml\', \'text/xml\'], DCNL \'text/*;q=0.5,*/*; q=0.1\') DCNL \'text/xml\''
def start_replay(replay_file_name, **kwargs): DCNL 'Start using the ``httreplay`` library. DCNL Patches the various supported HTTP-requesting libraries DCNL (httplib, requests, urllib3) and starts reading from/writing DCNL to the replay file on disk. DCNL Because HTTP requests and responses may contain sensitive data, DCNL and because they may vary in inconsequential ways that you may DCNL wish to ignore, the ``httreplay`` provides several hooks to "filter" DCNL the request contents to generate a stable key suitable for your DCNL needs. Some example "filters" may be found in the ``utils.py`` file, DCNL which is currently a grab-bag of things the ``httreplay`` author DCNL has found useful, no matter how silly. DCNL :param replay_file_name: The file from which to load and save replays. DCNL :type replay_file_name: string DCNL :param url_key: Function that generates a stable key from a URL. DCNL :type url_key: function DCNL :param body_key: Function that generates a stable key from a DCNL request body. DCNL :type body_key: function DCNL :param headers_key: Function that generates a stable key from a DCNL dictionary of headers. DCNL :type headers_key: function'
def stop_replay(): DCNL 'Remove all patches installed by the ``httreplay`` library and end replay.'
@contextmanager DCNL def replay(recording_file_name, url_key=None, body_key=None, headers_key=None): DCNL 'A simple context manager for using the ``httreplay`` library. DCNL On entry, patches the various supported HTTP-requesting libraries DCNL (httplib, requests, urllib3) and starts reading from/writing DCNL to the replay file on disk. DCNL On exit, undoes all patches and ends replay. DCNL Example: DCNL with replay(\'/tmp/my_recording.json\'): DCNL ... perform http requests ... DCNL Because HTTP requests and responses may contain sensitive data, DCNL and because they may vary in inconsequential ways that you may DCNL wish to ignore, the ``httreplay`` provides several hooks to "filter" DCNL the request contents to generate a stable key suitable for your DCNL needs. Some example "filters" may be found in the ``utils.py`` file, DCNL which is currently a grab-bag of things the ``httreplay`` author DCNL has found useful, no matter how silly. DCNL :param replay_file_name: The file from which to load and save replays. DCNL :type replay_file_name: string DCNL :param url_key: Function that generates a stable key from a URL. DCNL :type url_key: function DCNL :param body_key: Function that generates a stable key from a DCNL request body. DCNL :type body_key: function DCNL :param headers_key: Function that generates a stable key from a DCNL dictionary of headers. DCNL :type headers_key: function'
def sort_string(s): DCNL 'A simple little toy to sort a string.'
def sort_string_key(): DCNL 'Returns a key function that produces a key by sorting a string.'
def filter_query_params(url, remove_params): DCNL 'Remove all provided parameters from the query section of the ``url``. DCNL :param remove_params: A list of (param, newvalue) to scrub from the URL. DCNL :type remove_params: list'
def filter_query_params_key(remove_params): DCNL 'Returns a key function that produces a key by removing params from a URL. DCNL :param remove_params: A list of query params to scrub from provided URLs. DCNL :type remove_params: list'
def filter_headers(headers, remove_headers): DCNL 'Remove undesired headers from the provided ``headers`` dict. DCNL The header keys are case-insensitive. DCNL :param remove_headers: A list of header names to remove or redact. DCNL :type remove_headers: list'
def filter_headers_key(remove_headers): DCNL 'Returns a key function that produces a key by removing headers from a dict. DCNL :param remove_headers: A list of header names to remove. DCNL :type remove_headers: list'
def _dthandler(obj): DCNL 'Handler for object types that are not Json-serializable'
def am_i_online(url, expected_val=None, search_string=None, timeout=5, allow_redirects=True): DCNL 'Test whether we are online or not. DCNL returns True or False. DCNL Eats all exceptions!'
def set_query_params(url, param_dict): DCNL 'Given a URL, set or replace a query parameter and return the DCNL modified URL. DCNL >>> set_query_params(\'http://example.com?foo=bar&biz=baz\',  {\'foo\': \'stuff\'}) DCNL \'http://example.com?foo=stuff&biz=baz\' DCNL modified from http://stackoverflow.com/questions/4293460/how-to-add-custom-parameters-to-an-url-query-string-with-python'
def get_ip_addresses(include_loopback=True): DCNL 'Get a list of all the IP addresses for adapters on the local system. DCNL You can specify to either include the loopback device (127.0.0.1) or not.'
def calc_last_modified(request, *args, **kwargs): DCNL 'Returns the file\'s modified time as the last-modified date'
def backend_cache_page(handler, cache_time=None, cache_name=None): DCNL 'Applies all logic for getting a page to cache in our backend, DCNL and never in the browser, so we can control things from Django/Python. DCNL This function does this all with the settings we want, specified in settings.'
def get_cache_key(path=None, url_name=None, cache=None, failure_ok=False): DCNL 'Call into Django to retrieve a cache key for the given url, or given url name DCNL NOTE: ONLY RETURNS CACHE_KEY IF THE CACHE_ITEM HAS BEEN CREATED ELSEWHERE!!!'
def create_cache(path=None, url_name=None, cache=None, force=False): DCNL 'Create a cache entry'
def api_handle_error_with_json(handler): DCNL 'All API requests should return JSON objects, even when unexpected errors occur. DCNL This decorator makes sure that all uncaught errors are not returned as HTML to the user, but instead JSON errors.'
def allow_jsonp(handler): DCNL 'A general wrapper for API views that should be permitted to return JSONP. DCNL Note: do not use this on views that return sensitive user-specific data, as it DCNL could allow a 3rd-party attacker site to retrieve and store a user\'s information. DCNL Args: DCNL The api view, which must return a JsonResponse object, under normal circumstances.'
def render_to_csv(context_keys, delimiter=',', key_label='key', order='stacked'): DCNL '"context_keys" are dictionary keys into the context object. DCNL We can have multiple keys, assuming that: DCNL * Each key returns a dict DCNL * Each dict has exactly the same keys (order doesn\'t matter) DCNL TODO(bcipolli): This won\'t work properly for unicode names.'
def all_classes_in_module(module_name): DCNL 'Returns all classes defined in the given module'
def allow_api_profiling(handler): DCNL 'For API requests decorated with this decorator, DCNL if \'debug\' is passed in with DEBUG=True, DCNL it will add a BODY tag to the json response--allowing DCNL the debug_toolbar to be used.'
def force_job(command, name='', frequency='YEARLY', stop=False, **kwargs): DCNL 'Mark a job as to run immediately (or to stop). DCNL By default, call cron directly, to resolve.'
def call_command_with_output(cmd, *args, **kwargs): DCNL 'Run call_command while capturing stdout/stderr and calls to sys.exit'
def call_command_async(cmd, *args, **kwargs): DCNL 'Runs a manage.py command asynchronously, by calling into DCNL the subprocess module. DCNL This may be finicky, as it requires stringifying kwargs, but DCNL it works well for the current needs and should be safe for types DCNL that stringify in a way that commands can parse DCNL (which will work for str, bool, int, etc).'
def call_outside_command_with_output(command, *args, **kwargs): DCNL 'Runs call_command for a KA Lite installation at the given location, DCNL and returns the output.'
def paginate_data(request, data_list, data_type='cur', per_page=25, page=1): DCNL 'Create pagination for list'
def pages_to_show(paginator, page, pages_wanted=None, max_pages_wanted=9): DCNL 'Function to select first two pages, last two pages and pages around currently selected page DCNL to show in pagination bar.'
def get_request_ip(request): DCNL 'Return the IP address from a HTTP request object.'
def is_loopback_connection(request): DCNL 'Test whether the IP making the request is the same as the IP serving the request.'
def Deserializer(object_list, **options): DCNL 'Deserialize simple Python objects back into Django ORM instances. DCNL It\'s expected that you pass the Python objects themselves (instead of a DCNL stream or a string) to the constructor'
def Deserializer(stream_or_string, **options): DCNL 'Deserialize a stream or string of JSON data. DCNL Note: no change from Django version, DCNL but needed to import here to use the versioned python deserializer DCNL (see the import at the top for PythonDeserializer)'
def validate_via_booleans(handler): DCNL ''
@register.tag DCNL def mkrange(parser, token): DCNL 'Accepts the same arguments as the \'range\' builtin and creates DCNL a list containing the result of \'range\'. DCNL Syntax: DCNL {% mkrange [start,] stop[, step] as context_name %} DCNL For example: DCNL {% mkrange 5 10 2 as some_range %} DCNL {% for i in some_range %} DCNL {{ i }}: Something I want to repeat DCNL {% endfor %} DCNL Produces: DCNL 5: Something I want to repeat DCNL 7: Something I want to repeat DCNL 9: Something I want to repeat'
@register.filter DCNL def format_name(user, format='first_last'): DCNL 'Can be used for objects or dictionaries.'
def mailchimp_subscribe(email, mc_url): DCNL 'Do the post request to mailchimp, return the MailChimp HTML result'
def download_video(youtube_id, download_path='../content/', download_url=OUTSIDE_DOWNLOAD_URL, format='mp4', callback=None): DCNL 'Downloads the video file to disk (note: this does NOT invalidate any of the cached html files in KA Lite)'
def break_into_chunks(bigiterator, chunksize=500): DCNL 'Given an iterator, separates the iterator into a list of iterators, DCNL each broken into a discrete size.'
def isnumeric(obj): DCNL 'Returns whether an object is itself numeric, or can be converted to numeric'
def datediff(*args, **kwargs): DCNL 'Given two datetime.datetimes, returns the total difference between them (in the units specified). DCNL Given a single timedelta, returns the delta in the units specified. DCNL This is akin to the timedelta.total_seconds() function, with two differences: DCNL (a) That function is only available in Python 2.7+ DCNL (b) That function has units of seconds available only.'
def get_host_name(): DCNL 'Cross-platform way to get the current computer name.'
def version_diff(v1, v2): DCNL 'Diff is the integer difference between the most leftward part of the versions that differ. DCNL If the versions are identical, the method returns zero. DCNL If v1 is earlier than v2, the method returns negative. DCNL If v1 is later than v2, the method returns positive. DCNL If EITHER IS NONE, then we return none. DCNL Examples: DCNL version_diff(None, "0.9.4") returns None DCNL version_diff("0.9.2", "0.9.4") returns -2 DCNL version_diff("0.9.4", "0.9.4") returns 0 DCNL version_diff("0.9.4", "0.9.2") returns 2 DCNL version_diff("0.9", "1.0") returns -1 (0-1) DCNL version_diff("0.3", "0.7") returns -4 (3-7)'
def ensure_dir(path): DCNL 'Create the entire directory path, if it doesn\'t exist already.'
def convert_date_input(date_to_convert): DCNL 'Convert from MM/DD/YYYY to Unix timestamp'
def get_module_source_file(module_name): DCNL 'http://stackoverflow.com/questions/247770/retrieving-python-module-path DCNL http://stackoverflow.com/questions/8718885/import-module-from-string-variable'
def max_none(data): DCNL 'Given a list of data, returns the max... removing None elements first, for comparison "safety".'
def json_ascii_decoder(data): DCNL 'TODO: Delete, it doesn\'t seem to be used anymore DCNL benjaoming: I don\'t see how this is more efficient. Letting the JSON DCNL library load files and parse them with a built-in decoder, probably even DCNL implemented in C would be much faster. DCNL A custom JSON decoder that can be passed to json.load/s.  This DCNL parses strings into str instead of unicode. To use this, pass this DCNL function to the object_hook keyword param in json.load/s. DCNL Mainly used to help in encoding issues and memory efficiency.'
def sort_version_list(version_list, reverse): DCNL 'Returns sorted version list - assumes strict version number'
def resolve_model(model_path): DCNL 'Resolve a full model path into the appropriate import and carry out the import.'
def low(logging=logging): DCNL 'Process will execute with lower CPU priority'
def lowest(logging=logging): DCNL 'Process will only execute when system is idle'
def normal(logging=logging): DCNL 'Process will try to reset to normal priority'
def system_script_extension(system=None): DCNL 'The extension for the one script that could be considered "the os script" for the given system..'
def system_specific_scripts(system=None): DCNL 'All scripting types for that platform, that wouldn\'t be recognized DCNL on ALL other platforms.'
def not_system_specific_scripts(system=None): DCNL 'Returns a list of all platform-specific scripts DCNL that are on OTHER systems and not on this one. DCNL (useful for removing unnecessary files from lists)'
def _default_callback_zip(src_path, fi, nfiles): DCNL 'Default callback function for system_specific_zipping'
def system_specific_zipping(files_dict, zip_file=None, compression=ZIP_DEFLATED, callback=_default_callback_zip): DCNL 'Zip up files, adding permissions when appropriate.'
def _default_callback_unzip(afile, fi, nfiles): DCNL 'Private (default) callback function for system_specific_unzipping'
def system_specific_unzipping(zip_file, dest_dir, callback=_default_callback_unzip): DCNL '# unpack the inner zip to the destination'
def crypt(word, salt=None, iterations=None): DCNL 'PBKDF2-based unix crypt(3) replacement. DCNL The number of iterations specified in the salt overrides the \'iterations\' DCNL parameter. DCNL The effective hash length is 192 bits.'
def _makesalt(): DCNL 'Return a 48-bit pseudorandom salt for crypt(). DCNL This function is not suitable for generating cryptographic secrets.'
@register.tag DCNL def announcements(parser, token): DCNL 'Usage:: DCNL {% announcements as var %} DCNL Returns a list of announcements'
def get_template(template_name): DCNL 'Returns a compiled Template object for the given template name, DCNL handling template inheritance recursively.'
def get_template_from_string(source, origin=None, name=None): DCNL 'Returns a compiled Template object for the given template code, DCNL handling template inheritance recursively.'
def render_to_string(template_name, dictionary=None, context_instance=None): DCNL 'Loads the given template_name and renders it with the given dictionary as DCNL context. The template_name may be a string to load a single template using DCNL get_template, or it may be a tuple to use select_template to find one of DCNL the templates in the list. Returns a string.'
def select_template(template_name_list): DCNL 'Given a list of template names, returns the first that can be loaded.'
@register.tag DCNL def autoescape(parser, token): DCNL 'Force autoescape behavior for this block.'
@register.tag DCNL def comment(parser, token): DCNL 'Ignores everything between ``{% comment %}`` and ``{% endcomment %}``.'
@register.tag DCNL def cycle(parser, token): DCNL 'Cycles among the given strings each time this tag is encountered. DCNL Within a loop, cycles among the given strings each time through DCNL the loop:: DCNL {% for o in some_list %} DCNL <tr class="{% cycle \'row1\' \'row2\' %}"> DCNL </tr> DCNL {% endfor %} DCNL Outside of a loop, give the values a unique name the first time you call DCNL it, then use that name each sucessive time through:: DCNL <tr class="{% cycle \'row1\' \'row2\' \'row3\' as rowcolors %}">...</tr> DCNL <tr class="{% cycle rowcolors %}">...</tr> DCNL <tr class="{% cycle rowcolors %}">...</tr> DCNL You can use any number of values, separated by spaces. Commas can also DCNL be used to separate values; if a comma is used, the cycle values are DCNL interpreted as literal strings. DCNL The optional flag "silent" can be used to prevent the cycle declaration DCNL from returning any value:: DCNL {% for o in some_list %} DCNL {% cycle \'row1\' \'row2\' as rowcolors silent %} DCNL <tr class="{{ rowcolors }}">{% include "subtemplate.html " %}</tr> DCNL {% endfor %}'
@register.tag DCNL def debug(parser, token): DCNL 'Outputs a whole load of debugging information, including the current DCNL context and imported modules. DCNL Sample usage:: DCNL <pre> DCNL {% debug %} DCNL </pre>'
@register.tag(u'filter') DCNL def do_filter(parser, token): DCNL 'Filters the contents of the block through variable filters. DCNL Filters can also be piped through each other, and they can have DCNL arguments -- just like in variable syntax. DCNL Sample usage:: DCNL {% filter force_escape|lower %} DCNL This text will be HTML-escaped, and will appear in lowercase. DCNL {% endfilter %} DCNL Note that the ``escape`` and ``safe`` filters are not acceptable arguments. DCNL Instead, use the ``autoescape`` tag to manage autoescaping for blocks of DCNL template code.'
@register.tag DCNL def firstof(parser, token): DCNL 'Outputs the first variable passed that is not False, without escaping. DCNL Outputs nothing if all the passed variables are False. DCNL Sample usage:: DCNL {% firstof var1 var2 var3 %} DCNL This is equivalent to:: DCNL {% if var1 %} DCNL {{ var1|safe }} DCNL {% else %}{% if var2 %} DCNL {{ var2|safe }} DCNL {% else %}{% if var3 %} DCNL {{ var3|safe }} DCNL {% endif %}{% endif %}{% endif %} DCNL but obviously much cleaner! DCNL You can also use a literal string as a fallback value in case all DCNL passed variables are False:: DCNL {% firstof var1 var2 var3 "fallback value" %} DCNL If you want to escape the output, use a filter tag:: DCNL {% filter force_escape %} DCNL {% firstof var1 var2 var3 "fallback value" %} DCNL {% endfilter %}'
@register.tag(u'for') DCNL def do_for(parser, token): DCNL 'Loops over each item in an array. DCNL For example, to display a list of athletes given ``athlete_list``:: DCNL <ul> DCNL {% for athlete in athlete_list %} DCNL <li>{{ athlete.name }}</li> DCNL {% endfor %} DCNL </ul> DCNL You can loop over a list in reverse by using DCNL ``{% for obj in list reversed %}``. DCNL You can also unpack multiple values from a two-dimensional array:: DCNL {% for key,value in dict.items %} DCNL {{ key }}: {{ value }} DCNL {% endfor %} DCNL The ``for`` tag can take an optional ``{% empty %}`` clause that will DCNL be displayed if the given array is empty or could not be found:: DCNL <ul> DCNL {% for athlete in athlete_list %} DCNL <li>{{ athlete.name }}</li> DCNL {% empty %} DCNL <li>Sorry, no athletes in this list.</li> DCNL {% endfor %} DCNL <ul> DCNL The above is equivalent to -- but shorter, cleaner, and possibly faster DCNL than -- the following:: DCNL <ul> DCNL {% if althete_list %} DCNL {% for athlete in athlete_list %} DCNL <li>{{ athlete.name }}</li> DCNL {% endfor %} DCNL {% else %} DCNL <li>Sorry, no athletes in this list.</li> DCNL {% endif %} DCNL </ul> DCNL The for loop sets a number of variables available within the loop: DCNL Variable                    Description DCNL ``forloop.counter``         The current iteration of the loop (1-indexed) DCNL ``forloop.counter0``        The current iteration of the loop (0-indexed) DCNL ``forloop.revcounter``      The number of iterations from the end of the DCNL loop (1-indexed) DCNL ``forloop.revcounter0``     The number of iterations from the end of the DCNL loop (0-indexed) DCNL ``forloop.first``           True if this is the first time through the loop DCNL ``forloop.last``            True if this is the last time through the loop DCNL ``forloop.parentloop``      For nested loops, this is the loop "above" the DCNL current one'
@register.tag DCNL def ifequal(parser, token): DCNL 'Outputs the contents of the block if the two arguments equal each other. DCNL Examples:: DCNL {% ifequal user.id comment.user_id %} DCNL {% endifequal %} DCNL {% ifnotequal user.id comment.user_id %} DCNL {% else %} DCNL {% endifnotequal %}'
@register.tag DCNL def ifnotequal(parser, token): DCNL 'Outputs the contents of the block if the two arguments are not equal. DCNL See ifequal.'
@register.tag(u'if') DCNL def do_if(parser, token): DCNL 'The ``{% if %}`` tag evaluates a variable, and if that variable is "true" DCNL (i.e., exists, is not empty, and is not a false boolean value), the DCNL contents of the block are output: DCNL {% if athlete_list %} DCNL Number of athletes: {{ athlete_list|count }} DCNL {% elif athlete_in_locker_room_list %} DCNL Athletes should be out of the locker room soon! DCNL {% else %} DCNL No athletes. DCNL {% endif %} DCNL In the above, if ``athlete_list`` is not empty, the number of athletes will DCNL be displayed by the ``{{ athlete_list|count }}`` variable. DCNL As you can see, the ``if`` tag may take one or several `` {% elif %}`` DCNL clauses, as well as an ``{% else %}`` clause that will be displayed if all DCNL previous conditions fail. These clauses are optional. DCNL ``if`` tags may use ``or``, ``and`` or ``not`` to test a number of DCNL variables or to negate a given variable:: DCNL {% if not athlete_list %} DCNL There are no athletes. DCNL {% endif %} DCNL {% if athlete_list or coach_list %} DCNL There are some athletes or some coaches. DCNL {% endif %} DCNL {% if athlete_list and coach_list %} DCNL Both atheletes and coaches are available. DCNL {% endif %} DCNL {% if not athlete_list or coach_list %} DCNL There are no athletes, or there are some coaches. DCNL {% endif %} DCNL {% if athlete_list and not coach_list %} DCNL There are some athletes and absolutely no coaches. DCNL {% endif %} DCNL Comparison operators are also available, and the use of filters is also DCNL allowed, for example:: DCNL {% if articles|length >= 5 %}...{% endif %} DCNL Arguments and operators _must_ have a space between them, so DCNL ``{% if 1>2 %}`` is not a valid if tag. DCNL All supported operators are: ``or``, ``and``, ``in``, ``not in`` DCNL ``==`` (or ``=``), ``!=``, ``>``, ``>=``, ``<`` and ``<=``. DCNL Operator precedence follows Python.'
@register.tag DCNL def ifchanged(parser, token): DCNL 'Checks if a value has changed from the last iteration of a loop. DCNL The ``{% ifchanged %}`` block tag is used within a loop. It has two DCNL possible uses. DCNL 1. Checks its own rendered contents against its previous state and only DCNL displays the content if it has changed. For example, this displays a DCNL list of days, only displaying the month if it changes:: DCNL <h1>Archive for {{ year }}</h1> DCNL {% for date in days %} DCNL {% ifchanged %}<h3>{{ date|date:"F" }}</h3>{% endifchanged %} DCNL <a href="{{ date|date:"M/d"|lower }}/">{{ date|date:"j" }}</a> DCNL {% endfor %} DCNL 2. If given one or more variables, check whether any variable has changed. DCNL For example, the following shows the date every time it changes, while DCNL showing the hour if either the hour or the date has changed:: DCNL {% for date in days %} DCNL {% ifchanged date.date %} {{ date.date }} {% endifchanged %} DCNL {% ifchanged date.hour date.date %} DCNL {{ date.hour }} DCNL {% endifchanged %} DCNL {% endfor %}'
@register.tag DCNL def ssi(parser, token): DCNL 'Outputs the contents of a given file into the page. DCNL Like a simple "include" tag, the ``ssi`` tag includes the contents DCNL of another file -- which must be specified using an absolute path -- DCNL in the current page:: DCNL {% ssi "/home/html/ljworld.com/includes/right_generic.html" %} DCNL If the optional "parsed" parameter is given, the contents of the included DCNL file are evaluated as template code, with the current context:: DCNL {% ssi "/home/html/ljworld.com/includes/right_generic.html" parsed %}'
@register.tag DCNL def load(parser, token): DCNL 'Loads a custom template tag set. DCNL For example, to load the template tags in DCNL ``django/templatetags/news/photos.py``:: DCNL {% load news.photos %} DCNL Can also be used to load an individual tag/filter from DCNL a library:: DCNL {% load byline from news %}'
@register.tag DCNL def now(parser, token): DCNL 'Displays the date, formatted according to the given string. DCNL Uses the same format as PHP\'s ``date()`` function; see http://php.net/date DCNL for all the possible values. DCNL Sample usage:: DCNL It is {% now "jS F Y H:i" %}'
@register.tag DCNL def regroup(parser, token): DCNL 'Regroups a list of alike objects by a common attribute. DCNL This complex tag is best illustrated by use of an example:  say that DCNL ``people`` is a list of ``Person`` objects that have ``first_name``, DCNL ``last_name``, and ``gender`` attributes, and you\'d like to display a list DCNL that looks like: DCNL * Male: DCNL * George Bush DCNL * Bill Clinton DCNL * Female: DCNL * Margaret Thatcher DCNL * Colendeeza Rice DCNL * Unknown: DCNL * Pat Smith DCNL The following snippet of template code would accomplish this dubious task:: DCNL {% regroup people by gender as grouped %} DCNL <ul> DCNL {% for group in grouped %} DCNL <li>{{ group.grouper }} DCNL <ul> DCNL {% for item in group.list %} DCNL <li>{{ item }}</li> DCNL {% endfor %} DCNL </ul> DCNL {% endfor %} DCNL </ul> DCNL As you can see, ``{% regroup %}`` populates a variable with a list of DCNL objects with ``grouper`` and ``list`` attributes.  ``grouper`` contains the DCNL item that was grouped by; ``list`` contains the list of objects that share DCNL that ``grouper``.  In this case, ``grouper`` would be ``Male``, ``Female`` DCNL and ``Unknown``, and ``list`` is the list of people with those genders. DCNL Note that ``{% regroup %}`` does not work when the list to be grouped is not DCNL sorted by the key you are grouping by!  This means that if your list of DCNL people was not sorted by gender, you\'d need to make sure it is sorted DCNL before using it, i.e.:: DCNL {% regroup people|dictsort:"gender" by gender as grouped %}'
@register.tag DCNL def spaceless(parser, token): DCNL 'Removes whitespace between HTML tags, including tab and newline characters. DCNL Example usage:: DCNL {% spaceless %} DCNL <p> DCNL <a href="foo/">Foo</a> DCNL </p> DCNL {% endspaceless %} DCNL This example would return this HTML:: DCNL <p><a href="foo/">Foo</a></p> DCNL Only space between *tags* is normalized -- not space between tags and text. DCNL In this example, the space around ``Hello`` won\'t be stripped:: DCNL {% spaceless %} DCNL <strong> DCNL Hello DCNL </strong> DCNL {% endspaceless %}'
@register.tag DCNL def templatetag(parser, token): DCNL 'Outputs one of the bits used to compose template tags. DCNL Since the template system has no concept of "escaping", to display one of DCNL the bits used in template tags, you must use the ``{% templatetag %}`` tag. DCNL The argument tells which template bit to output: DCNL Argument            Outputs DCNL ``openblock``       ``{%`` DCNL ``closeblock``      ``%}`` DCNL ``openvariable``    ``{{`` DCNL ``closevariable``   ``}}`` DCNL ``openbrace``       ``{`` DCNL ``closebrace``      ``}`` DCNL ``opencomment``     ``{#`` DCNL ``closecomment``    ``#}``'
@register.tag DCNL def url(parser, token): DCNL 'Returns an absolute URL matching given view with its parameters. DCNL This is a way to define links that aren\'t tied to a particular URL DCNL configuration:: DCNL {% url "path.to.some_view" arg1 arg2 %} DCNL or DCNL {% url "path.to.some_view" name1=value1 name2=value2 %} DCNL The first argument is a path to a view. It can be an absolute Python path DCNL or just ``app_name.view_name`` without the project name if the view is DCNL located inside the project. DCNL Other arguments are space-separated values that will be filled in place of DCNL positional and keyword arguments in the URL. Don\'t mix positional and DCNL keyword arguments. DCNL All arguments for the URL should be present. DCNL For example if you have a view ``app_name.client`` taking client\'s id and DCNL the corresponding line in a URLconf looks like this:: DCNL (\'^client/(\d+)/$\', \'app_name.client\') DCNL and this app\'s URLconf is included into the project\'s URLconf under some DCNL path:: DCNL (\'^clients/\', include(\'project_name.app_name.urls\')) DCNL then in a template you can create a link for a certain client like this:: DCNL {% url "app_name.client" client.id %} DCNL The URL will look like ``/clients/client/123/``. DCNL The first argument can also be a named URL instead of the Python path to DCNL the view callable. For example if the URLconf entry looks like this:: DCNL url(\'^client/(\d+)/$\', name=\'client-detail-view\') DCNL then in the template you can use:: DCNL {% url "client-detail-view" client.id %} DCNL There is even another possible value type for the first argument. It can be DCNL the name of a template variable that will be evaluated to obtain the view DCNL name or the URL name, e.g.:: DCNL {% with view_path="app_name.client" %} DCNL {% url view_path client.id %} DCNL {% endwith %} DCNL or, DCNL {% with url_name="client-detail-view" %} DCNL {% url url_name client.id %} DCNL {% endwith %}'
@register.tag DCNL def verbatim(parser, token): DCNL 'Stops the template engine from rendering the contents of this block tag. DCNL Usage:: DCNL {% verbatim %} DCNL {% don\'t process this %} DCNL {% endverbatim %} DCNL You can also designate a specific closing tag block (allowing the DCNL unrendered use of ``{% endverbatim %}``):: DCNL {% verbatim myblock %} DCNL {% endverbatim myblock %}'
@register.tag DCNL def widthratio(parser, token): DCNL 'For creating bar charts and such, this tag calculates the ratio of a given DCNL value to a maximum value, and then applies that ratio to a constant. DCNL For example:: DCNL <img src=\'bar.gif\' height=\'10\' width=\'{% widthratio this_value max_value max_width %}\' /> DCNL If ``this_value`` is 175, ``max_value`` is 200, and ``max_width`` is 100, DCNL the image in the above example will be 88 pixels wide DCNL (because 175/200 = .875; .875 * 100 = 87.5 which is rounded up to 88).'
@register.tag(u'with') DCNL def do_with(parser, token): DCNL 'Adds one or more values to the context (inside of this block) for caching DCNL and easy access. DCNL For example:: DCNL {% with total=person.some_sql_method %} DCNL {{ total }} object{{ total|pluralize }} DCNL {% endwith %} DCNL Multiple values can be added to the context:: DCNL {% with foo=1 bar=2 %} DCNL {% endwith %} DCNL The legacy format of ``{% with person.some_sql_method as total %}`` is DCNL still accepted.'
def infix(bp, func): DCNL 'Creates an infix operator, given a binding power and a function that DCNL evaluates the node'
def prefix(bp, func): DCNL 'Creates a prefix operator, given a binding power and a function that DCNL evaluates the node.'
def stringfilter(func): DCNL 'Decorator for filters which should only receive unicode objects. The object DCNL passed as the first positional argument will be converted to a unicode DCNL object.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def addslashes(value): DCNL 'Adds slashes before quotes. Useful for escaping strings in CSV, for DCNL example. Less useful for escaping JavaScript; use the ``escapejs`` DCNL filter instead.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def capfirst(value): DCNL 'Capitalizes the first character of the value.'
@register.filter(u'escapejs') DCNL @stringfilter DCNL def escapejs_filter(value): DCNL 'Hex encodes characters for use in JavaScript strings.'
@register.filter(u'fix_ampersands', is_safe=True) DCNL @stringfilter DCNL def fix_ampersands_filter(value): DCNL 'Replaces ampersands with ``&amp;`` entities.'
@register.filter(is_safe=True) DCNL def floatformat(text, arg=(-1)): DCNL 'Displays a float to a specified number of decimal places. DCNL If called without an argument, it displays the floating point number with DCNL one decimal place -- but only if there\'s a decimal place to be displayed: DCNL * num1 = 34.23234 DCNL * num2 = 34.00000 DCNL * num3 = 34.26000 DCNL * {{ num1|floatformat }} displays "34.2" DCNL * {{ num2|floatformat }} displays "34" DCNL * {{ num3|floatformat }} displays "34.3" DCNL If arg is positive, it will always display exactly arg number of decimal DCNL places: DCNL * {{ num1|floatformat:3 }} displays "34.232" DCNL * {{ num2|floatformat:3 }} displays "34.000" DCNL * {{ num3|floatformat:3 }} displays "34.260" DCNL If arg is negative, it will display arg number of decimal places -- but DCNL only if there are places to be displayed: DCNL * {{ num1|floatformat:"-3" }} displays "34.232" DCNL * {{ num2|floatformat:"-3" }} displays "34" DCNL * {{ num3|floatformat:"-3" }} displays "34.260" DCNL If the input float is infinity or NaN, the (platform-dependent) string DCNL representation of that value will be displayed.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def iriencode(value): DCNL 'Escapes an IRI value for use in a URL.'
@register.filter(is_safe=True, needs_autoescape=True) DCNL @stringfilter DCNL def linenumbers(value, autoescape=None): DCNL 'Displays text with line numbers.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def lower(value): DCNL 'Converts a string into all lowercase.'
@register.filter(is_safe=False) DCNL @stringfilter DCNL def make_list(value): DCNL 'Returns the value turned into a list. DCNL For an integer, it\'s a list of digits. DCNL For a string, it\'s a list of characters.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def slugify(value): DCNL 'Converts to lowercase, removes non-word characters (alphanumerics and DCNL underscores) and converts spaces to hyphens. Also strips leading and DCNL trailing whitespace.'
@register.filter(is_safe=True) DCNL def stringformat(value, arg): DCNL 'Formats the variable according to the arg, a string formatting specifier. DCNL This specifier uses Python string formating syntax, with the exception that DCNL the leading "%" is dropped. DCNL See http://docs.python.org/lib/typesseq-strings.html for documentation DCNL of Python string formatting'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def title(value): DCNL 'Converts a string into titlecase.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def truncatechars(value, arg): DCNL 'Truncates a string after a certain number of characters. DCNL Argument: Number of characters to truncate after.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def truncatewords(value, arg): DCNL 'Truncates a string after a certain number of words. DCNL Argument: Number of words to truncate after. DCNL Newlines within the string are removed.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def truncatewords_html(value, arg): DCNL 'Truncates HTML after a certain number of words. DCNL Argument: Number of words to truncate after. DCNL Newlines in the HTML are preserved.'
@register.filter(is_safe=False) DCNL @stringfilter DCNL def upper(value): DCNL 'Converts a string into all uppercase.'
@register.filter(is_safe=False) DCNL @stringfilter DCNL def urlencode(value, safe=None): DCNL 'Escapes a value for use in a URL. DCNL Takes an optional ``safe`` parameter used to determine the characters which DCNL should not be escaped by Django\'s ``urlquote`` method. If not provided, the DCNL default safe characters will be used (but an empty string can be provided DCNL when *all* characters should be escaped).'
@register.filter(is_safe=True, needs_autoescape=True) DCNL @stringfilter DCNL def urlize(value, autoescape=None): DCNL 'Converts URLs in plain text into clickable links.'
@register.filter(is_safe=True, needs_autoescape=True) DCNL @stringfilter DCNL def urlizetrunc(value, limit, autoescape=None): DCNL 'Converts URLs into clickable links, truncating URLs to the given character DCNL limit, and adding \'rel=nofollow\' attribute to discourage spamming. DCNL Argument: Length to truncate URLs to.'
@register.filter(is_safe=False) DCNL @stringfilter DCNL def wordcount(value): DCNL 'Returns the number of words.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def wordwrap(value, arg): DCNL 'Wraps words at specified line length. DCNL Argument: number of characters to wrap the text at.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def ljust(value, arg): DCNL 'Left-aligns the value in a field of a given width. DCNL Argument: field size.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def rjust(value, arg): DCNL 'Right-aligns the value in a field of a given width. DCNL Argument: field size.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def center(value, arg): DCNL 'Centers the value in a field of a given width.'
@register.filter DCNL @stringfilter DCNL def cut(value, arg): DCNL 'Removes all values of arg from the given string.'
@register.filter(u'escape', is_safe=True) DCNL @stringfilter DCNL def escape_filter(value): DCNL 'Marks the value as a string that should not be auto-escaped.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def force_escape(value): DCNL 'Escapes a string\'s HTML. This returns a new string containing the escaped DCNL characters (as opposed to "escape", which marks the content for later DCNL possible escaping).'
@register.filter(u'linebreaks', is_safe=True, needs_autoescape=True) DCNL @stringfilter DCNL def linebreaks_filter(value, autoescape=None): DCNL 'Replaces line breaks in plain text with appropriate HTML; a single DCNL newline becomes an HTML line break (``<br />``) and a new line DCNL followed by a blank line becomes a paragraph break (``</p>``).'
@register.filter(is_safe=True, needs_autoescape=True) DCNL @stringfilter DCNL def linebreaksbr(value, autoescape=None): DCNL 'Converts all newlines in a piece of plain text to HTML line breaks DCNL (``<br />``).'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def safe(value): DCNL 'Marks the value as a string that should not be auto-escaped.'
@register.filter(is_safe=True) DCNL def safeseq(value): DCNL 'A "safe" filter for sequences. Marks each element in the sequence, DCNL individually, as safe, after converting them to unicode. Returns a list DCNL with the results.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def removetags(value, tags): DCNL 'Removes a space separated list of [X]HTML tags from the output.'
@register.filter(is_safe=True) DCNL @stringfilter DCNL def striptags(value): DCNL 'Strips all [X]HTML tags.'
@register.filter(is_safe=False) DCNL def dictsort(value, arg): DCNL 'Takes a list of dicts, returns that list sorted by the property given in DCNL the argument.'
@register.filter(is_safe=False) DCNL def dictsortreversed(value, arg): DCNL 'Takes a list of dicts, returns that list sorted in reverse order by the DCNL property given in the argument.'
@register.filter(is_safe=False) DCNL def first(value): DCNL 'Returns the first item in a list.'
@register.filter(is_safe=True, needs_autoescape=True) DCNL def join(value, arg, autoescape=None): DCNL 'Joins a list with a string, like Python\'s ``str.join(list)``.'
@register.filter(is_safe=True) DCNL def last(value): DCNL 'Returns the last item in a list'
@register.filter(is_safe=True) DCNL def length(value): DCNL 'Returns the length of the value - useful for lists.'
@register.filter(is_safe=False) DCNL def length_is(value, arg): DCNL 'Returns a boolean of whether the value\'s length is the argument.'
@register.filter(is_safe=True) DCNL def random(value): DCNL 'Returns a random item from the list.'
@register.filter(u'slice', is_safe=True) DCNL def slice_filter(value, arg): DCNL 'Returns a slice of the list. DCNL Uses the same syntax as Python\'s list slicing; see DCNL http://diveintopython.org/native_data_types/lists.html#odbchelper.list.slice DCNL for an introduction.'
@register.filter(is_safe=True, needs_autoescape=True) DCNL def unordered_list(value, autoescape=None): DCNL 'Recursively takes a self-nested list and returns an HTML unordered list -- DCNL WITHOUT opening and closing <ul> tags. DCNL The list is assumed to be in the proper format. For example, if ``var`` DCNL contains: ``[\'States\', [\'Kansas\', [\'Lawrence\', \'Topeka\'], \'Illinois\']]``, DCNL then ``{{ var|unordered_list }}`` would return:: DCNL <li>States DCNL <ul> DCNL <li>Kansas DCNL <ul> DCNL <li>Lawrence</li> DCNL <li>Topeka</li> DCNL </ul> DCNL </li> DCNL <li>Illinois</li> DCNL </ul> DCNL </li>'
@register.filter(is_safe=False) DCNL def add(value, arg): DCNL 'Adds the arg to the value.'
@register.filter(is_safe=False) DCNL def get_digit(value, arg): DCNL 'Given a whole number, returns the requested digit of it, where 1 is the DCNL right-most digit, 2 is the second-right-most digit, etc. Returns the DCNL original value for invalid input (if input or argument is not an integer, DCNL or if argument is less than 1). Otherwise, output is always an integer.'
@register.filter(expects_localtime=True, is_safe=False) DCNL def date(value, arg=None): DCNL 'Formats a date according to the given format.'
@register.filter(expects_localtime=True, is_safe=False) DCNL def time(value, arg=None): DCNL 'Formats a time according to the given format.'
@register.filter(u'timesince', is_safe=False) DCNL def timesince_filter(value, arg=None): DCNL 'Formats a date as the time since that date (i.e. "4 days, 6 hours").'
@register.filter(u'timeuntil', is_safe=False) DCNL def timeuntil_filter(value, arg=None): DCNL 'Formats a date as the time until that date (i.e. "4 days, 6 hours").'
@register.filter(is_safe=False) DCNL def default(value, arg): DCNL 'If value is unavailable, use given default.'
@register.filter(is_safe=False) DCNL def default_if_none(value, arg): DCNL 'If value is None, use given default.'
@register.filter(is_safe=False) DCNL def divisibleby(value, arg): DCNL 'Returns True if the value is devisible by the argument.'
@register.filter(is_safe=False) DCNL def yesno(value, arg=None): DCNL 'Given a string mapping values for true, false and (optionally) None, DCNL returns one of those strings according to the value: DCNL Value       Argument                Outputs DCNL ``True``    ``"yeah,no,maybe"``     ``yeah`` DCNL ``False``   ``"yeah,no,maybe"``     ``no`` DCNL ``None``    ``"yeah,no,maybe"``     ``maybe`` DCNL ``None``    ``"yeah,no"``           ``"no"`` (converts None to False DCNL if no mapping for None is given.'
@register.filter(is_safe=True) DCNL def filesizeformat(bytes): DCNL 'Formats the value like a \'human-readable\' file size (i.e. 13 KB, 4.1 MB, DCNL 102 bytes, etc).'
@register.filter(is_safe=False) DCNL def pluralize(value, arg=u's'): DCNL 'Returns a plural suffix if the value is not 1. By default, \'s\' is used as DCNL the suffix: DCNL * If value is 0, vote{{ value|pluralize }} displays "0 votes". DCNL * If value is 1, vote{{ value|pluralize }} displays "1 vote". DCNL * If value is 2, vote{{ value|pluralize }} displays "2 votes". DCNL If an argument is provided, that string is used instead: DCNL * If value is 0, class{{ value|pluralize:"es" }} displays "0 classes". DCNL * If value is 1, class{{ value|pluralize:"es" }} displays "1 class". DCNL * If value is 2, class{{ value|pluralize:"es" }} displays "2 classes". DCNL If the provided argument contains a comma, the text before the comma is DCNL used for the singular case and the text after the comma is used for the DCNL plural case: DCNL * If value is 0, cand{{ value|pluralize:"y,ies" }} displays "0 candies". DCNL * If value is 1, cand{{ value|pluralize:"y,ies" }} displays "1 candy". DCNL * If value is 2, cand{{ value|pluralize:"y,ies" }} displays "2 candies".'
@register.filter(u'phone2numeric', is_safe=True) DCNL def phone2numeric_filter(value): DCNL 'Takes a phone number and converts it in to its numerical equivalent.'
@register.filter(is_safe=True) DCNL def pprint(value): DCNL 'A wrapper around pprint.pprint -- for debugging, really.'
def compile_string(template_string, origin): DCNL 'Compiles template_string into NodeList ready for rendering'
def resolve_variable(path, context): DCNL 'Returns the resolved variable, which may contain attribute syntax, within DCNL the given context. DCNL Deprecated; use the Variable class instead.'
def _render_value_in_context(value, context): DCNL 'Converts any value to a string to become part of a rendered template. This DCNL means escaping, if required, and conversion to a unicode object. If value DCNL is a string, it is expected to have already been translated.'
def token_kwargs(bits, parser, support_legacy=False): DCNL 'A utility method for parsing token keyword arguments. DCNL :param bits: A list containing remainder of the token (split by spaces) DCNL that is to be checked for arguments. Valid arguments will be removed DCNL from this list. DCNL :param support_legacy: If set to true ``True``, the legacy format DCNL ``1 as foo`` will be accepted. Otherwise, only the standard ``foo=1`` DCNL format is allowed. DCNL :returns: A dictionary of the arguments retrieved from the ``bits`` token DCNL list. DCNL There is no requirement for all remaining token ``bits`` to be keyword DCNL arguments, so the dictionary will be returned as soon as an invalid DCNL argument format is reached.'
def parse_bits(parser, bits, params, varargs, varkw, defaults, takes_context, name): DCNL 'Parses bits for template tag helpers (simple_tag, include_tag and DCNL assignment_tag), in particular by detecting syntax errors and by DCNL extracting positional and keyword arguments.'
def generic_tag_compiler(parser, token, params, varargs, varkw, defaults, name, takes_context, node_class): DCNL 'Returns a template.Node subclass.'
def is_library_missing(name): DCNL 'Check if library that failed to load cannot be found under any DCNL templatetags directory or does exist but fails to import. DCNL Non-existing condition is checked recursively for each subpackage in cases DCNL like <appdir>/templatetags/subpackage/package/module.py.'
def import_library(taglib_module): DCNL 'Load a template tag library module. DCNL Verifies that the library contains a \'register\' attribute, and DCNL returns that attribute as the representation of the library'
def get_templatetags_modules(): DCNL 'Return the list of all available template tag modules. DCNL Caches the result for faster access.'
def get_library(library_name): DCNL 'Load the template library module with the given name. DCNL If library is not already loaded loop over all templatetags modules DCNL to locate it. DCNL {% load somelib %} and {% load someotherlib %} loops twice. DCNL Subsequent loads eg. {% load somelib %} in the same process will grab DCNL the cached module from libraries.'
@register.tag('block') DCNL def do_block(parser, token): DCNL 'Define a block that can be overridden by child templates.'
@register.tag('extends') DCNL def do_extends(parser, token): DCNL 'Signal that this template extends a parent template. DCNL This tag may be used in two ways: ``{% extends "base" %}`` (with quotes) DCNL uses the literal value "base" as the name of the parent template to extend, DCNL or ``{% extends variable %}`` uses the value of ``variable`` as either the DCNL name of the parent template to extend (if it evaluates to a string) or as DCNL the parent tempate itelf (if it evaluates to a Template object).'
@register.tag('include') DCNL def do_include(parser, token): DCNL 'Loads a template and renders it with the current context. You can pass DCNL additional context using keyword arguments. DCNL Example:: DCNL {% include "foo/some_include" %} DCNL {% include "foo/some_include" with bar="BAZZ!" baz="BING!" %} DCNL Use the ``only`` argument to exclude the current context when rendering DCNL the included template:: DCNL {% include "foo/some_include" only %} DCNL {% include "foo/some_include" with bar="1" only %}'
def populate_xheaders(request, response, model, object_id): DCNL 'Adds the "X-Object-Type" and "X-Object-Id" headers to the given DCNL HttpResponse according to the given model and object_id -- but only if the DCNL given HttpRequest object has an IP address within the INTERNAL_IPS setting DCNL or if the request is from a logged in staff member.'
def make_msgid(idstring=None): DCNL 'Returns a string suitable for RFC 2822 compliant Message-ID, e.g: DCNL <20020201195627.33539.96671@nightshade.la.mastaler.com> DCNL Optional idstring if given is a string used to strengthen the DCNL uniqueness of the message id.'
def forbid_multi_line_headers(name, val, encoding): DCNL 'Forbids multi-line headers, to prevent header injection.'
def get_connection(backend=None, fail_silently=False, **kwds): DCNL 'Load an email backend and return an instance of it. DCNL If backend is None (default) settings.EMAIL_BACKEND is used. DCNL Both fail_silently and other keyword arguments are used in the DCNL constructor of the backend.'
def send_mail(subject, message, from_email, recipient_list, fail_silently=False, auth_user=None, auth_password=None, connection=None): DCNL 'Easy wrapper for sending a single message to a recipient list. All members DCNL of the recipient list will see the other recipients in the \'To\' field. DCNL If auth_user is None, the EMAIL_HOST_USER setting is used. DCNL If auth_password is None, the EMAIL_HOST_PASSWORD setting is used. DCNL Note: The API for this method is frozen. New code wanting to extend the DCNL functionality should use the EmailMessage class directly.'
def send_mass_mail(datatuple, fail_silently=False, auth_user=None, auth_password=None, connection=None): DCNL 'Given a datatuple of (subject, message, from_email, recipient_list), sends DCNL each message to each recipient list. Returns the number of emails sent. DCNL If from_email is None, the DEFAULT_FROM_EMAIL setting is used. DCNL If auth_user and auth_password are set, they\'re used to log in. DCNL If auth_user is None, the EMAIL_HOST_USER setting is used. DCNL If auth_password is None, the EMAIL_HOST_PASSWORD setting is used. DCNL Note: The API for this method is frozen. New code wanting to extend the DCNL functionality should use the EmailMessage class directly.'
def mail_admins(subject, message, fail_silently=False, connection=None, html_message=None): DCNL 'Sends a message to the admins, as defined by the ADMINS setting.'
def mail_managers(subject, message, fail_silently=False, connection=None, html_message=None): DCNL 'Sends a message to the managers, as defined by the MANAGERS setting.'
def get_wsgi_application(): DCNL 'The public interface to Django\'s WSGI support. Should return a WSGI DCNL callable. DCNL Allows us to avoid making django.core.handlers.WSGIHandler public API, in DCNL case the internal WSGI implementation changes or moves in the future.'
def dumps(obj, key=None, salt=u'django.core.signing', serializer=JSONSerializer, compress=False): DCNL 'Returns URL-safe, sha1 signed base64 compressed JSON string. If key is DCNL None, settings.SECRET_KEY is used instead. DCNL If compress is True (not the default) checks if compressing using zlib can DCNL save some space. Prepends a \'.\' to signify compression. This is included DCNL in the signature, to protect against zip bombs. DCNL Salt can be used to namespace the hash, so that a signed string is DCNL only valid for a given namespace. Leaving this at the default DCNL value or re-using a salt value across different parts of your DCNL application without good cause is a security risk. DCNL The serializer is expected to return a bytestring.'
def loads(s, key=None, salt=u'django.core.signing', serializer=JSONSerializer, max_age=None): DCNL 'Reverse of dumps(), raises BadSignature if signature fails. DCNL The serializer is expected to accept a bytestring.'
def get_image_dimensions(file_or_path, close=False): DCNL 'Returns the (width, height) of an image, given an open file or a path.  Set DCNL \'close\' to True to close the file at the end if it is initially in an open DCNL state.'
def file_move_safe(old_file_name, new_file_name, chunk_size=(1024 * 64), allow_overwrite=False): DCNL 'Moves a file from one location to another in the safest way possible. DCNL First, tries ``os.rename``, which is simple but will break across filesystems. DCNL If that fails, streams manually from one file to another in pure Python. DCNL If the destination file exists and ``allow_overwrite`` is ``False``, this DCNL function will throw an ``IOError``.'
def load_handler(path, *args, **kwargs): DCNL 'Given a path to a handler, return an instance of that handler. DCNL E.g.:: DCNL >>> load_handler(\'django.core.files.uploadhandler.TemporaryFileUploadHandler\', request) DCNL <TemporaryFileUploadHandler object at 0x...>'
def fd(f): DCNL 'Get a filedescriptor from something which could be a file or an fd.'
def csrf(request): DCNL 'Context processor that provides a CSRF token, or the string \'NOTPROVIDED\' if DCNL it has not been provided by either a view decorator or the middleware'
def debug(request): DCNL 'Returns context variables helpful for debugging.'
def static(request): DCNL 'Adds static-related context variables to the context.'
def media(request): DCNL 'Adds media-related context variables to the context.'
def Deserializer(stream_or_string, **options): DCNL 'Deserialize a stream or string of JSON data.'
def Deserializer(stream_or_string, **options): DCNL 'Deserialize a stream or string of YAML data.'
def register_serializer(format, serializer_module, serializers=None): DCNL 'Register a new serializer. DCNL ``serializer_module`` should be the fully qualified module name DCNL for the serializer. DCNL If ``serializers`` is provided, the registration will be added DCNL to the provided dictionary. DCNL If ``serializers`` is not provided, the registration will be made DCNL directly into the global register of serializers. Adding serializers DCNL directly is not a thread-safe operation.'
def unregister_serializer(format): DCNL 'Unregister a given serializer. This is not a thread-safe operation.'
def serialize(format, queryset, **options): DCNL 'Serialize a queryset (or any iterator that returns database objects) using DCNL a certain serializer.'
def deserialize(format, stream_or_string, **options): DCNL 'Deserialize a stream or a string. Returns an iterator that yields ``(obj, DCNL m2m_relation_dict)``, where ``obj`` is a instantiated -- but *unsaved* -- DCNL object, and ``m2m_relation_dict`` is a dictionary of ``{m2m_field_name : DCNL list_of_related_objects}``.'
def _load_serializers(): DCNL 'Register built-in and settings-defined serializers. This is done lazily so DCNL that user code has a chance to (e.g.) set up custom settings without DCNL needing to be careful of import order.'
def getInnerText(node): DCNL 'Get all the inner text of a DOM node (recursively).'
def Deserializer(object_list, **options): DCNL 'Deserialize simple Python objects back into Django ORM instances. DCNL It\'s expected that you pass the Python objects themselves (instead of a DCNL stream or a string) to the constructor'
def _get_model(model_identifier): DCNL 'Helper to look up a model from an "app_label.module_name" string.'
def ip_address_validators(protocol, unpack_ipv4): DCNL 'Depending on the given parameters returns the appropriate validators for DCNL the GenericIPAddressField. DCNL This code is here, because it is exactly the same for the model and the form field.'
def get_callable(lookup_view, can_fail=False): DCNL 'Convert a string version of a function name to the callable object. DCNL If the lookup_view is not an import path, it is assumed to be a URL pattern DCNL label and the original string is returned. DCNL If can_fail is True, lookup_view might be a URL pattern label, so errors DCNL during the import fail and the string is returned.'
def set_script_prefix(prefix): DCNL 'Sets the script prefix for the current thread.'
def get_script_prefix(): DCNL 'Returns the currently active script prefix. Useful for client code that DCNL wishes to construct their own URLs manually (although accessing the request DCNL instance is normally going to be a lot cleaner).'
def set_urlconf(urlconf_name): DCNL 'Sets the URLconf for the current thread (overriding the default one in DCNL settings). Set to None to revert back to the default.'
def get_urlconf(default=None): DCNL 'Returns the root URLconf to use for the current thread if it has been DCNL changed from the default one.'
def is_valid_path(path, urlconf=None): DCNL 'Returns True if the given path resolves against the default URL resolver, DCNL False otherwise. DCNL This is a convenience method to make working with "is this a match?" cases DCNL easier, avoiding unnecessarily indented try...except blocks.'
def parse_backend_uri(backend_uri): DCNL 'Converts the "backend_uri" into a cache scheme (\'db\', \'memcached\', etc), a DCNL host and any extra params that are required for the backend. Returns a DCNL (scheme, host, params) tuple.'
def parse_backend_conf(backend, **kwargs): DCNL 'Helper function to parse the backend configuration DCNL that doesn\'t use the URI notation.'
def get_cache(backend, **kwargs): DCNL 'Function to load a cache backend dynamically. This is flexible by design DCNL to allow different use cases: DCNL To load a backend with the old URI-based notation:: DCNL cache = get_cache(\'locmem://\') DCNL To load a backend that is pre-defined in the settings:: DCNL cache = get_cache(\'default\') DCNL To load a backend with its dotted import path, DCNL including arbitrary options:: DCNL cache = get_cache(\'django.core.cache.backends.memcached.MemcachedCache\', **{ DCNL \'LOCATION\': \'127.0.0.1:11211\', \'TIMEOUT\': 30,'
def default_key_func(key, key_prefix, version): DCNL 'Default function to generate keys. DCNL Constructs the key used by all other methods. By default it prepends DCNL the `key_prefix\'. KEY_FUNCTION can be used to specify an alternate DCNL function with custom key making behavior.'
def get_key_func(key_func): DCNL 'Function to decide which key function to use. DCNL Defaults to ``default_key_func``.'
def get_validation_errors(outfile, app=None): DCNL 'Validates all models that are part of the specified app. If no app name is provided, DCNL validates all models of all installed apps. Writes errors, if any, to outfile. DCNL Returns number of errors.'
def sql_create(app, style, connection): DCNL 'Returns a list of the CREATE TABLE SQL statements for the given app.'
def sql_delete(app, style, connection): DCNL 'Returns a list of the DROP TABLE SQL statements for the given app.'
def sql_flush(style, connection, only_django=False, reset_sequences=True): DCNL 'Returns a list of the SQL statements used to flush the database. DCNL If only_django is True, then only table names that have associated Django DCNL models and are in INSTALLED_APPS will be included.'
def sql_custom(app, style, connection): DCNL 'Returns a list of the custom table modifying SQL statements for the given app.'
def sql_indexes(app, style, connection): DCNL 'Returns a list of the CREATE INDEX SQL statements for all models in the given app.'
def sql_all(app, style, connection): DCNL 'Returns a list of CREATE TABLE SQL, initial-data inserts, and CREATE INDEX SQL for the given module.'
def module_to_dict(module, omittable=(lambda k: k.startswith('_'))): DCNL 'Converts a module namespace to a Python dictionary. Used by get_settings_diff.'
def handle_extensions(extensions=('html',), ignored=('py',)): DCNL 'Organizes multiple extensions that are separated with commas or passed by DCNL using --extension/-e multiple times. Note that the .py extension is ignored DCNL here because of the way non-*.py files are handled in make_messages() (they DCNL are copied to file.ext.py files to trick xgettext to parse them as Python DCNL files). DCNL For example: running \'django-admin makemessages -e js,txt -e xhtml -a\' DCNL would result in an extension list: [\'.js\', \'.txt\', \'.xhtml\'] DCNL >>> handle_extensions([\'.html\', \'html,js,py,py,py,.py\', \'py,.py\']) DCNL set([\'.html\', \'.js\']) DCNL >>> handle_extensions([\'.html, txt,.tpl\']) DCNL set([\'.html\', \'.tpl\', \'.txt\'])'
def _popen(cmd): DCNL 'Friendly wrapper around Popen for Windows'
def find_files(root, ignore_patterns, verbosity, stdout=sys.stdout, symlinks=False): DCNL 'Helper function to get all files in the given root.'
def is_ignored(path, ignore_patterns): DCNL 'Helper function to check if the given path should be ignored or not.'
def copy_plural_forms(msgs, locale, domain, verbosity, stdout=sys.stdout): DCNL 'Copies plural forms header contents from a Django catalog of locale to DCNL the msgs string, inserting it at the right place. msgs should be the DCNL contents of a newly created .po file.'
def write_pot_file(potfile, msgs, file, work_file, is_templatized): DCNL 'Write the :param potfile: POT file with the :param msgs: contents, DCNL previously making sure its format is valid.'
def process_file(file, dirpath, potfile, domain, verbosity, extensions, wrap, location, stdout=sys.stdout): DCNL 'Extract translatable literals from :param file: for :param domain: DCNL creating or updating the :param potfile: POT file. DCNL Uses the xgettext GNU gettext utility.'
def write_po_file(pofile, potfile, domain, locale, verbosity, stdout, copy_pforms, wrap, location, no_obsolete): DCNL 'Creates of updates the :param pofile: PO file for :param domain: and :param DCNL locale:.  Uses contents of the existing :param potfile:. DCNL Uses mguniq, msgmerge, and msgattrib GNU gettext utilities.'
def make_messages(locale=None, domain='django', verbosity=1, all=False, extensions=None, symlinks=False, ignore_patterns=None, no_wrap=False, no_location=False, no_obsolete=False, stdout=sys.stdout): DCNL 'Uses the ``locale/`` directory from the Django Git tree or an DCNL application/project to process all files with translatable literals for DCNL the :param domain: domain and :param locale: locale.'
def sort_dependencies(app_list): DCNL 'Sort a list of app,modellist pairs into a single list of models. DCNL The single list of models is sorted so that any model with a natural key DCNL is serialized before a normal model, and any model with a natural key DCNL dependency has it\'s dependencies serialized first.'
def supports_color(): DCNL 'Returns True if the running system\'s terminal supports color, and False DCNL otherwise.'
def color_style(): DCNL 'Returns a Style object with the Django color scheme.'
def no_style(): DCNL 'Returns a Style object that has no colors.'
def find_commands(management_dir): DCNL 'Given a path to a management directory, returns a list of all the command DCNL names that are available. DCNL Returns an empty list if no commands are defined.'
def find_management_module(app_name): DCNL 'Determines the path to the management module for the given app_name, DCNL without actually importing the application or the management module. DCNL Raises ImportError if the management module cannot be found for any reason.'
def load_command_class(app_name, name): DCNL 'Given a command name and an application name, returns the Command DCNL class instance. All errors raised by the import process DCNL (ImportError, AttributeError) are allowed to propagate.'
def get_commands(): DCNL 'Returns a dictionary mapping command names to their callback applications. DCNL This works by looking for a management.commands package in django.core, and DCNL in each installed application -- if a commands package exists, all commands DCNL in that package are registered. DCNL Core commands are always included. If a settings module has been DCNL specified, user-defined commands will also be included. DCNL The dictionary is in the format {command_name: app_name}. Key-value DCNL pairs from this dictionary can then be used in calls to DCNL load_command_class(app_name, command_name) DCNL If a specific version of a command must be loaded (e.g., with the DCNL startapp command), the instantiated module can be placed in the DCNL dictionary in place of the application name. DCNL The dictionary is cached on the first call and reused on subsequent DCNL calls.'
def call_command(name, *args, **options): DCNL 'Calls the given command, with the given options and args/kwargs. DCNL This is the primary API you should use for calling specific commands. DCNL Some examples: DCNL call_command(\'syncdb\') DCNL call_command(\'shell\', plain=True) DCNL call_command(\'sqlall\', \'myapp\')'
def setup_environ(settings_mod, original_settings_path=None): DCNL 'Configures the runtime environment. This can also be used by external DCNL scripts wanting to set up a similar environment to manage.py. DCNL Returns the project directory (assuming the passed settings module is DCNL directly in the project directory). DCNL The "original_settings_path" parameter is optional, but recommended, since DCNL trying to work out the original path from the module can be problematic.'
def execute_from_command_line(argv=None): DCNL 'A simple method that runs a ManagementUtility.'
def execute_manager(settings_mod, argv=None): DCNL 'Like execute_from_command_line(), but for use by manage.py, a DCNL project-specific django-admin.py utility.'
def handle_default_options(options): DCNL 'Include any default options that all commands should accept here DCNL so that ManagementUtility can handle them before searching for DCNL user commands.'
def get_path_info(environ): DCNL 'Returns the HTTP request\'s PATH_INFO as a unicode string.'
def get_script_name(environ): DCNL 'Returns the equivalent of the HTTP request\'s SCRIPT_NAME environment DCNL variable. If Apache mod_rewrite has been used, returns what would have been DCNL the script name prior to any rewriting (so it\'s the script name as seen DCNL from the client\'s perspective), unless the FORCE_SCRIPT_NAME setting is DCNL set (to anything).'
def get_internal_wsgi_application(): DCNL 'Loads and returns the WSGI application as configured by the user in DCNL ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout, DCNL this will be the ``application`` object in ``projectname/wsgi.py``. DCNL This function, and the ``WSGI_APPLICATION`` setting itself, are only useful DCNL for Django\'s internal servers (runserver, runfcgi); external WSGI servers DCNL should just be configured to point to the correct application object DCNL directly. DCNL If settings.WSGI_APPLICATION is not set (is ``None``), we just return DCNL whatever ``django.core.wsgi.get_wsgi_application`` returns.'
def set_language(request): DCNL 'Redirect to a given url while setting the chosen language in the DCNL session or cookie. The url and the language code need to be DCNL specified in the request parameters. DCNL Since this view changes how the user will see the rest of the site, it must DCNL only be accessed as a POST request. If called as a GET request, it will DCNL redirect to the page in the request (the \'next\' parameter) without changing DCNL any state.'
def get_formats(): DCNL 'Returns all formats strings required for i18n to work'
def null_javascript_catalog(request, domain=None, packages=None): DCNL 'Returns "identity" versions of the JavaScript i18n functions -- i.e., DCNL versions that don\'t actually do anything.'
def javascript_catalog(request, domain='djangojs', packages=None): DCNL 'Returns the selected language catalog as a javascript library. DCNL Receives the list of packages to check for translations in the DCNL packages parameter either from an infodict or as a +-delimited DCNL string from the request. Default is \'django.conf\'. DCNL Additionally you can override the gettext domain for this view, DCNL but usually you don\'t want to do that, as JavaScript messages DCNL go to the djangojs domain. But this might be needed if you DCNL deliver your JavaScript source from Django templates.'
def serve(request, path, document_root=None, show_indexes=False): DCNL 'Serve static files below a given point in the directory structure. DCNL To use, put a URL pattern such as:: DCNL (r\'^(?P<path>.*)$\', \'django.views.static.serve\', {\'document_root\' : \'/path/to/my/files/\'}) DCNL in your URLconf. You must provide the ``document_root`` param. You may DCNL also set ``show_indexes`` to ``True`` if you\'d like to serve a basic index DCNL of the directory.  This index view will use the template hardcoded below, DCNL but if you\'d like to override it, you can create a template called DCNL ``static/directory_index.html``.'
def was_modified_since(header=None, mtime=0, size=0): DCNL 'Was something modified since the user last downloaded it? DCNL header DCNL This is the value of the If-Modified-Since header.  If this is None, DCNL I\'ll just return True. DCNL mtime DCNL This is the modification time of the item we\'re talking about. DCNL size DCNL This is the size of the item we\'re talking about.'
def _date_from_string(year, year_format, month=u'', month_format=u'', day=u'', day_format=u'', delim=u'__'): DCNL 'Helper: get a datetime.date object given a format string and a year, DCNL month, and day (only year is mandatory). Raise a 404 for an invalid date.'
def _get_next_prev(generic_view, date, is_previous, period): DCNL 'Helper: Get the next or the previous valid date. The idea is to allow DCNL links on month/day views to never be 404s by never providing a date DCNL that\'ll be invalid for the given view. DCNL This is a bit complicated since it handles different intervals of time, DCNL hence the coupling to generic_view. DCNL However in essence the logic comes down to: DCNL * If allow_empty and allow_future are both true, this is easy: just DCNL return the naive result (just the next/previous day/week/month, DCNL reguardless of object existence.) DCNL * If allow_empty is true, allow_future is false, and the naive result DCNL isn\'t in the future, then return it; otherwise return None. DCNL * If allow_empty is false and allow_future is true, return the next DCNL date *that contains a valid object*, even if it\'s in the future. If DCNL there are no next objects, return None. DCNL * If allow_empty is false and allow_future is false, return the next DCNL date that contains a valid object. If that date is in the future, or DCNL if there are no next objects, return None.'
def timezone_today(): DCNL 'Return the current date in the current time zone.'
def cleanse_setting(key, value): DCNL 'Cleanse an individual setting key/value of sensitive content. DCNL If the value is a dictionary, recursively cleanse the keys in DCNL that dictionary.'
def get_safe_settings(): DCNL 'Returns a dictionary of the settings module, with sensitive settings blurred out.'
def technical_500_response(request, exc_type, exc_value, tb): DCNL 'Create a technical server error response. The last three arguments are DCNL the values returned from sys.exc_info() and friends.'
def technical_404_response(request, exception): DCNL 'Create a technical 404 error response. The exception should be the Http404.'
def empty_urlconf(request): DCNL 'Create an empty URLconf 404 error response.'
def require_http_methods(request_method_list): DCNL 'Decorator to make a view only accept particular request methods.  Usage:: DCNL @require_http_methods(["GET", "POST"]) DCNL def my_view(request): DCNL # I can assume now that only GET or POST requests make it this far DCNL Note that request methods should be in uppercase.'
def condition(etag_func=None, last_modified_func=None): DCNL 'Decorator to support conditional retrieval (or change) for a view DCNL function. DCNL The parameters are callables to compute the ETag and last modified time for DCNL the requested resource, respectively. The callables are passed the same DCNL parameters as the view itself. The Etag function should return a string (or DCNL None if the resource doesn\'t exist), whilst the last_modified function DCNL should return a datetime object (or None if the resource doesn\'t exist). DCNL If both parameters are provided, all the preconditions must be met before DCNL the view is processed. DCNL This decorator will either pass control to the wrapped view function or DCNL return an HTTP 304 response (unmodified) or 412 response (preconditions DCNL failed), depending upon the request method. DCNL Any behavior marked as "undefined" in the HTTP spec (e.g. If-none-match DCNL plus If-modified-since headers) will result in the view function being DCNL called.'
def xframe_options_deny(view_func): DCNL 'Modifies a view function so its response has the X-Frame-Options HTTP DCNL header set to \'DENY\' as long as the response doesn\'t already have that DCNL header set. DCNL e.g. DCNL @xframe_options_deny DCNL def some_view(request):'
def xframe_options_sameorigin(view_func): DCNL 'Modifies a view function so its response has the X-Frame-Options HTTP DCNL header set to \'SAMEORIGIN\' as long as the response doesn\'t already have DCNL that header set. DCNL e.g. DCNL @xframe_options_sameorigin DCNL def some_view(request):'
def xframe_options_exempt(view_func): DCNL 'Modifies a view function by setting a response variable that instructs DCNL XFrameOptionsMiddleware to NOT set the X-Frame-Options HTTP header. DCNL e.g. DCNL @xframe_options_exempt DCNL def some_view(request):'
def cache_page(*args, **kwargs): DCNL 'Decorator for views that tries getting the page from the cache and DCNL populates the cache if the page isn\'t in the cache yet. DCNL The cache is keyed by the URL and some data from the headers. DCNL Additionally there is the key prefix that is used to distinguish different DCNL cache areas in a multi-site setup. You could use the DCNL sites.get_current_site().domain, for example, as that is unique across a Django DCNL project. DCNL Additionally, all headers from the response\'s Vary header will be taken DCNL into account on caching -- just like the middleware does.'
def never_cache(view_func): DCNL 'Decorator that adds headers to a response so that it will DCNL never be cached.'
def vary_on_headers(*headers): DCNL 'A view decorator that adds the specified headers to the Vary header of the DCNL response. Usage: DCNL @vary_on_headers(\'Cookie\', \'Accept-language\') DCNL def index(request): DCNL Note that the header names are not case-sensitive.'
def vary_on_cookie(func): DCNL 'A view decorator that adds "Cookie" to the Vary header of a response. This DCNL indicates that a page\'s contents depends on cookies. Usage: DCNL @vary_on_cookie DCNL def index(request):'
def sensitive_variables(*variables): DCNL 'Indicates which variables used in the decorated function are sensitive, so DCNL that those variables can later be treated in a special way, for example DCNL by hiding them when logging unhandled exceptions. DCNL Two forms are accepted: DCNL * with specified variable names: DCNL @sensitive_variables(\'user\', \'password\', \'credit_card\') DCNL def my_function(user): DCNL password = user.pass_word DCNL credit_card = user.credit_card_number DCNL * without any specified variable names, in which case it is assumed that DCNL all variables are considered sensitive: DCNL @sensitive_variables() DCNL def my_function()'
def sensitive_post_parameters(*parameters): DCNL 'Indicates which POST parameters used in the decorated view are sensitive, DCNL so that those parameters can later be treated in a special way, for example DCNL by hiding them when logging unhandled exceptions. DCNL Two forms are accepted: DCNL * with specified parameters: DCNL @sensitive_post_parameters(\'password\', \'credit_card\') DCNL def my_view(request): DCNL pw = request.POST[\'password\'] DCNL cc = request.POST[\'credit_card\'] DCNL * without any specified parameters, in which case it is assumed that DCNL all parameters are considered sensitive: DCNL @sensitive_post_parameters() DCNL def my_view(request)'
def csrf_response_exempt(view_func): DCNL 'Modifies a view function so that its response is exempt DCNL from the post-processing of the CSRF middleware.'
def csrf_view_exempt(view_func): DCNL 'Marks a view function as being exempt from CSRF view protection.'
def csrf_exempt(view_func): DCNL 'Marks a view function as being exempt from the CSRF view protection.'
def csrf_failure(request, reason=''): DCNL 'Default view used when request fails CSRF protection'
@requires_csrf_token DCNL def page_not_found(request, template_name='404.html'): DCNL 'Default 404 handler. DCNL Templates: :template:`404.html` DCNL Context: DCNL request_path DCNL The path of the requested URL (e.g., \'/app/pages/bad_page/\')'
@requires_csrf_token DCNL def server_error(request, template_name='500.html'): DCNL '500 error handler. DCNL Templates: :template:`500.html` DCNL Context: None'
@requires_csrf_token DCNL def permission_denied(request, template_name='403.html'): DCNL 'Permission denied (403) handler. DCNL Templates: :template:`403.html` DCNL Context: None DCNL If the template does not exist, an Http403 response containing the text DCNL "403 Forbidden" (as per RFC 2616) will be returned.'
def to_list(value): DCNL 'Puts value into a list if it\'s not already one. DCNL Returns an empty list if value is None.'
def connections_support_transactions(): DCNL 'Returns True if all connections support transactions.'
def skipIfDBFeature(feature): DCNL 'Skip a test if a database has the named feature'
def skipUnlessDBFeature(feature): DCNL 'Skip a test unless a database has the named feature'
def store_rendered_templates(store, signal, sender, template, context, **kwargs): DCNL 'Stores templates and contexts that are rendered. DCNL The context is copied so that it is an accurate representation at the time DCNL of rendering.'
def encode_multipart(boundary, data): DCNL 'Encodes multipart POST data from a dictionary of form values. DCNL The key will be used as the form data name; the value will be transmitted DCNL as content. If the value is a file, the contents of the file will be sent DCNL as an application/octet-stream; otherwise, str(value) will be sent.'
def build_suite(app_module): DCNL 'Create a complete Django test suite for the provided application module.'
def build_test(label): DCNL 'Construct a test case with the specified label. Label should be of the DCNL form model.TestClass or model.TestClass.test_method. Returns an DCNL instantiated test or test suite corresponding to the label provided.'
def partition_suite(suite, classes, bins): DCNL 'Partitions a test suite by test type. DCNL classes is a sequence of types DCNL bins is a sequence of TestSuites, one more than classes DCNL Tests of type classes[i] are added to bins[i], DCNL tests with no match found in classes are place in bins[-1]'
def reorder_suite(suite, classes): DCNL 'Reorders a test suite by test type. DCNL `classes` is a sequence of types DCNL All tests of type classes[0] are placed first, then tests of type DCNL classes[1], etc. Tests with no match in classes are placed last.'
def dependency_ordered(test_databases, dependencies): DCNL 'Reorder test_databases into an order that honors the dependencies DCNL described in TEST_DEPENDENCIES.'
def instrumented_test_render(self, context): DCNL 'An instrumented Template render method, providing a signal DCNL that can be intercepted by the test system Client'
def setup_test_environment(): DCNL 'Perform any global pre-test setup. This involves: DCNL - Installing the instrumented test renderer DCNL - Set the email backend to the locmem email backend. DCNL - Setting the active locale to match the LANGUAGE_CODE setting.'
def teardown_test_environment(): DCNL 'Perform any global post-test teardown. This involves: DCNL - Restoring the original test renderer DCNL - Restoring the email sending functions'
def get_warnings_state(): DCNL 'Returns an object containing the state of the warnings module'
def restore_warnings_state(state): DCNL 'Restores the state of the warnings module when passed an object that was DCNL returned by get_warnings_state()'
def setup_test_template_loader(templates_dict, use_cached_loader=False): DCNL 'Changes Django to only find templates from within a dictionary (where each DCNL key is the template name and each value is the corresponding template DCNL content to return). DCNL Use meth:`restore_template_loaders` to restore the original loaders.'
def restore_template_loaders(): DCNL 'Restores the original template loaders after DCNL :meth:`setup_test_template_loader` has been run.'
def compare_xml(want, got): DCNL 'Tries to do a \'xml-comparison\' of want and got.  Plain string DCNL comparison doesn\'t always work because, for example, attribute DCNL ordering should not be important. Comment nodes are not considered in the DCNL comparison. DCNL Based on http://codespeak.net/svn/lxml/trunk/src/lxml/doctestcompare.py'
def strip_quotes(want, got): DCNL 'Strip quotes of doctests output values: DCNL >>> strip_quotes("\'foo\'") DCNL "foo" DCNL >>> strip_quotes(\'"foo"\') DCNL "foo"'
def parse_html(html): DCNL 'Takes a string that contains *valid* HTML and turns it into a Python object DCNL structure that can be easily compared against other HTML on semantic DCNL equivilance. Syntactical differences like which quotation is used on DCNL arguments will be ignored.'
def _extract_future_flags(globs): DCNL 'Return the compiler-flags associated with the future features that DCNL have been imported into the given namespace (globs).'
def _normalize_module(module, depth=2): DCNL 'Return the module specified by `module`.  In particular: DCNL - If `module` is a module, then return module. DCNL - If `module` is a string, then import and return the DCNL module with that name. DCNL - If `module` is None, then return the calling module. DCNL The calling module is assumed to be the module of DCNL the stack frame at the given depth in the call stack.'
def _indent(s, indent=4): DCNL 'Add the given number of space characters to the beginning every DCNL non-blank line in `s`, and return the result.'
def _exception_traceback(exc_info): DCNL 'Return a string containing a traceback message for the given DCNL exc_info tuple (as returned by sys.exc_info()).'
def _ellipsis_match(want, got): DCNL 'Essentially the only subtle case: DCNL >>> _ellipsis_match(\'aa...aa\', \'aaa\') DCNL False'
def _comment_line(line): DCNL 'Return a commented form of the given line'
def testmod(m=None, name=None, globs=None, verbose=None, report=True, optionflags=0, extraglobs=None, raise_on_error=False, exclude_empty=False): DCNL 'm=None, name=None, globs=None, verbose=None, report=True, DCNL optionflags=0, extraglobs=None, raise_on_error=False, DCNL exclude_empty=False DCNL Test examples in docstrings in functions and classes reachable DCNL from module m (or the current module if m is not supplied), starting DCNL with m.__doc__. DCNL Also test examples reachable from dict m.__test__ if it exists and is DCNL not None.  m.__test__ maps names to functions, classes and strings; DCNL function and class docstrings are tested even if the name is private; DCNL strings are tested directly, as if they were docstrings. DCNL Return (#failures, #tests). DCNL See doctest.__doc__ for an overview. DCNL Optional keyword arg "name" gives the name of the module; by default DCNL use m.__name__. DCNL Optional keyword arg "globs" gives a dict to be used as the globals DCNL when executing examples; by default, use m.__dict__.  A copy of this DCNL dict is actually used for each docstring, so that each docstring\'s DCNL examples start with a clean slate. DCNL Optional keyword arg "extraglobs" gives a dictionary that should be DCNL merged into the globals that are used to execute examples.  By DCNL default, no extra globals are used.  This is new in 2.4. DCNL Optional keyword arg "verbose" prints lots of stuff if true, prints DCNL only failures if false; by default, it\'s true iff "-v" is in sys.argv. DCNL Optional keyword arg "report" prints a summary at the end when true, DCNL else prints nothing at the end.  In verbose mode, the summary is DCNL detailed, else very brief (in fact, empty if all tests passed). DCNL Optional keyword arg "optionflags" or\'s together module constants, DCNL and defaults to 0.  This is new in 2.3.  Possible values (see the DCNL docs for details): DCNL DONT_ACCEPT_TRUE_FOR_1 DCNL DONT_ACCEPT_BLANKLINE DCNL NORMALIZE_WHITESPACE DCNL ELLIPSIS DCNL SKIP DCNL IGNORE_EXCEPTION_DETAIL DCNL REPORT_UDIFF DCNL REPORT_CDIFF DCNL REPORT_NDIFF DCNL REPORT_ONLY_FIRST_FAILURE DCNL Optional keyword arg "raise_on_error" raises an exception on the DCNL first unexpected exception or failure. This allows failures to be DCNL post-mortem debugged. DCNL Advanced tomfoolery:  testmod runs methods of a local instance of DCNL class doctest.Tester, then merges the results into (or creates) DCNL global Tester instance doctest.master.  Methods of doctest.master DCNL can be called directly too, if you want to do something unusual. DCNL Passing report=0 to testmod is especially useful then, to delay DCNL displaying a summary.  Invoke doctest.master.summarize(verbose) DCNL when you\'re done fiddling.'
def testfile(filename, module_relative=True, name=None, package=None, globs=None, verbose=None, report=True, optionflags=0, extraglobs=None, raise_on_error=False, parser=DocTestParser(), encoding=None): DCNL 'Test examples in the given file.  Return (#failures, #tests). DCNL Optional keyword arg "module_relative" specifies how filenames DCNL should be interpreted: DCNL - If "module_relative" is True (the default), then "filename" DCNL specifies a module-relative path.  By default, this path is DCNL relative to the calling module\'s directory; but if the DCNL "package" argument is specified, then it is relative to that DCNL package.  To ensure os-independence, "filename" should use DCNL "/" characters to separate path segments, and should not DCNL be an absolute path (i.e., it may not begin with "/"). DCNL - If "module_relative" is False, then "filename" specifies an DCNL os-specific path.  The path may be absolute or relative (to DCNL the current working directory). DCNL Optional keyword arg "name" gives the name of the test; by default DCNL use the file\'s basename. DCNL Optional keyword argument "package" is a Python package or the DCNL name of a Python package whose directory should be used as the DCNL base directory for a module relative filename.  If no package is DCNL specified, then the calling module\'s directory is used as the base DCNL directory for module relative filenames.  It is an error to DCNL specify "package" if "module_relative" is False. DCNL Optional keyword arg "globs" gives a dict to be used as the globals DCNL when executing examples; by default, use {}.  A copy of this dict DCNL is actually used for each docstring, so that each docstring\'s DCNL examples start with a clean slate. DCNL Optional keyword arg "extraglobs" gives a dictionary that should be DCNL merged into the globals that are used to execute examples.  By DCNL default, no extra globals are used. DCNL Optional keyword arg "verbose" prints lots of stuff if true, prints DCNL only failures if false; by default, it\'s true iff "-v" is in sys.argv. DCNL Optional keyword arg "report" prints a summary at the end when true, DCNL else prints nothing at the end.  In verbose mode, the summary is DCNL detailed, else very brief (in fact, empty if all tests passed). DCNL Optional keyword arg "optionflags" or\'s together module constants, DCNL and defaults to 0.  Possible values (see the docs for details): DCNL DONT_ACCEPT_TRUE_FOR_1 DCNL DONT_ACCEPT_BLANKLINE DCNL NORMALIZE_WHITESPACE DCNL ELLIPSIS DCNL SKIP DCNL IGNORE_EXCEPTION_DETAIL DCNL REPORT_UDIFF DCNL REPORT_CDIFF DCNL REPORT_NDIFF DCNL REPORT_ONLY_FIRST_FAILURE DCNL Optional keyword arg "raise_on_error" raises an exception on the DCNL first unexpected exception or failure. This allows failures to be DCNL post-mortem debugged. DCNL Optional keyword arg "parser" specifies a DocTestParser (or DCNL subclass) that should be used to extract tests from the files. DCNL Optional keyword arg "encoding" specifies an encoding that should DCNL be used to convert the file to unicode. DCNL Advanced tomfoolery:  testmod runs methods of a local instance of DCNL class doctest.Tester, then merges the results into (or creates) DCNL global Tester instance doctest.master.  Methods of doctest.master DCNL can be called directly too, if you want to do something unusual. DCNL Passing report=0 to testmod is especially useful then, to delay DCNL displaying a summary.  Invoke doctest.master.summarize(verbose) DCNL when you\'re done fiddling.'
def run_docstring_examples(f, globs, verbose=False, name='NoName', compileflags=None, optionflags=0): DCNL 'Test examples in the given object\'s docstring (`f`), using `globs` DCNL as globals.  Optional argument `name` is used in failure messages. DCNL If the optional argument `verbose` is true, then generate output DCNL even if there are no failures. DCNL `compileflags` gives the set of flags that should be used by the DCNL Python compiler when running the examples.  If not specified, then DCNL it will default to the set of future-import flags that apply to DCNL `globs`. DCNL Optional keyword arg `optionflags` specifies options for the DCNL testing and output.  See the documentation for `testmod` for more DCNL information.'
def set_unittest_reportflags(flags): DCNL 'Sets the unittest option flags. DCNL The old flag is returned so that a runner could restore the old DCNL value if it wished to: DCNL >>> old = _unittest_reportflags DCNL >>> set_unittest_reportflags(REPORT_NDIFF | DCNL ...                          REPORT_ONLY_FIRST_FAILURE) == old DCNL True DCNL >>> import doctest DCNL >>> doctest._unittest_reportflags == (REPORT_NDIFF | DCNL ...                                   REPORT_ONLY_FIRST_FAILURE) DCNL True DCNL Only reporting flags can be set: DCNL >>> set_unittest_reportflags(ELLIPSIS) DCNL Traceback (most recent call last): DCNL ValueError: (\'Only reporting flags allowed\', 8) DCNL >>> set_unittest_reportflags(old) == (REPORT_NDIFF | DCNL ...                                   REPORT_ONLY_FIRST_FAILURE) DCNL True'
def DocTestSuite(module=None, globs=None, extraglobs=None, test_finder=None, test_class=DocTestCase, **options): DCNL 'Convert doctest tests for a module to a unittest test suite. DCNL This converts each documentation string in a module that DCNL contains doctest tests to a unittest test case.  If any of the DCNL tests in a doc string fail, then the test case fails.  An exception DCNL is raised showing the name of the file containing the test and a DCNL (sometimes approximate) line number. DCNL The `module` argument provides the module to be tested.  The argument DCNL can be either a module or a module name. DCNL If no argument is given, the calling module is used. DCNL A number of options may be provided as keyword arguments: DCNL setUp DCNL A set-up function.  This is called before running the DCNL tests in each file. The setUp function will be passed a DocTest DCNL object.  The setUp function can access the test globals as the DCNL globs attribute of the test passed. DCNL tearDown DCNL A tear-down function.  This is called after running the DCNL tests in each file.  The tearDown function will be passed a DocTest DCNL object.  The tearDown function can access the test globals as the DCNL globs attribute of the test passed. DCNL globs DCNL A dictionary containing initial global variables for the tests. DCNL optionflags DCNL A set of doctest option flags expressed as an integer.'
def DocFileSuite(*paths, **kw): DCNL 'A unittest suite for one or more doctest files. DCNL The path to each doctest file is given as a string; the DCNL interpretation of that string depends on the keyword argument DCNL "module_relative". DCNL A number of options may be provided as keyword arguments: DCNL module_relative DCNL If "module_relative" is True, then the given file paths are DCNL interpreted as os-independent module-relative paths.  By DCNL default, these paths are relative to the calling module\'s DCNL directory; but if the "package" argument is specified, then DCNL they are relative to that package.  To ensure os-independence, DCNL "filename" should use "/" characters to separate path DCNL segments, and may not be an absolute path (i.e., it may not DCNL begin with "/"). DCNL If "module_relative" is False, then the given file paths are DCNL interpreted as os-specific paths.  These paths may be absolute DCNL or relative (to the current working directory). DCNL package DCNL A Python package or the name of a Python package whose directory DCNL should be used as the base directory for module relative paths. DCNL If "package" is not specified, then the calling module\'s DCNL directory is used as the base directory for module relative DCNL filenames.  It is an error to specify "package" if DCNL "module_relative" is False. DCNL setUp DCNL A set-up function.  This is called before running the DCNL tests in each file. The setUp function will be passed a DocTest DCNL object.  The setUp function can access the test globals as the DCNL globs attribute of the test passed. DCNL tearDown DCNL A tear-down function.  This is called after running the DCNL tests in each file.  The tearDown function will be passed a DocTest DCNL object.  The tearDown function can access the test globals as the DCNL globs attribute of the test passed. DCNL globs DCNL A dictionary containing initial global variables for the tests. DCNL optionflags DCNL A set of doctest option flags expressed as an integer. DCNL parser DCNL A DocTestParser (or subclass) that should be used to extract DCNL tests from the files. DCNL encoding DCNL An encoding that will be used to convert the files to unicode.'
def script_from_examples(s): DCNL 'Extract script from text with examples. DCNL Converts text with examples to a Python script.  Example input is DCNL converted to regular code.  Example output and all other words DCNL are converted to comments: DCNL >>> text = \'\'\' DCNL ...       Here are examples of simple math. DCNL ...           Python has super accurate integer addition DCNL ...           >>> 2 + 2 DCNL ...           5 DCNL ...           And very friendly error messages: DCNL ...           >>> 1/0 DCNL ...           To Infinity DCNL ...           And DCNL ...           Beyond DCNL ...           You can use logic if you want: DCNL ...           >>> if 0: DCNL ...           ...    blah DCNL ...           ...    blah DCNL ...           Ho hum DCNL >>> print(script_from_examples(text)) DCNL # Here are examples of simple math. DCNL #     Python has super accurate integer addition DCNL 2 + 2 DCNL # Expected: DCNL ## 5 DCNL #     And very friendly error messages: DCNL 1/0 DCNL # Expected: DCNL ## To Infinity DCNL ## And DCNL ## Beyond DCNL #     You can use logic if you want: DCNL if 0: DCNL blah DCNL blah DCNL #     Ho hum'
def testsource(module, name): DCNL 'Extract the test sources from a doctest docstring as a script. DCNL Provide the module (or dotted name of the module) containing the DCNL test to be debugged and the name (within the module) of the object DCNL with the doc string with tests to be debugged.'
def debug_src(src, pm=False, globs=None): DCNL 'Debug a single doctest docstring, in argument `src`\''
def debug_script(src, pm=False, globs=None): DCNL 'Debug a test script.  `src` is the script, as a string.'
def debug(module, name, pm=False): DCNL 'Debug a single doctest docstring. DCNL Provide the module (or dotted name of the module) containing the DCNL test to be debugged and the name (within the module) of the object DCNL with the docstring with tests to be debugged.'
def shortcut(request, content_type_id, object_id): DCNL 'Redirect to an object\'s page based on a content-type ID and an object ID.'
def create_generic_related_manager(superclass): DCNL 'Factory function for a manager that subclasses \'superclass\' (which is a DCNL Manager) and adds behavior for generic related objects.'
def generic_inlineformset_factory(model, form=ModelForm, formset=BaseGenericInlineFormSet, ct_field=u'content_type', fk_field=u'object_id', fields=None, exclude=None, extra=3, can_order=False, can_delete=True, max_num=None, formfield_callback=None): DCNL 'Returns a ``GenericInlineFormSet`` for the given kwargs. DCNL You must provide ``ct_field`` and ``object_id`` if they different from the DCNL defaults ``content_type`` and ``object_id`` respectively.'
def update_contenttypes(app, created_models, verbosity=2, db=DEFAULT_DB_ALIAS, **kwargs): DCNL 'Creates content types for models in the given app, removing any model DCNL entries that no longer have a matching model class.'
def get_current_site(request): DCNL 'Checks if contrib.sites is installed and returns either the current DCNL ``Site`` object or a ``RequestSite`` object based on the request.'
def update_last_login(sender, user, **kwargs): DCNL 'A signal receiver which updates the last_login date for DCNL the user logging in.'
@sensitive_post_parameters() DCNL @csrf_protect DCNL @never_cache DCNL def login(request, template_name='registration/login.html', redirect_field_name=REDIRECT_FIELD_NAME, authentication_form=AuthenticationForm, current_app=None, extra_context=None): DCNL 'Displays the login form and handles the login action.'
def logout(request, next_page=None, template_name='registration/logged_out.html', redirect_field_name=REDIRECT_FIELD_NAME, current_app=None, extra_context=None): DCNL 'Logs out the user and displays \'You are logged out\' message.'
def logout_then_login(request, login_url=None, current_app=None, extra_context=None): DCNL 'Logs out the user if he is logged in. Then redirects to the log-in page.'
def redirect_to_login(next, login_url=None, redirect_field_name=REDIRECT_FIELD_NAME): DCNL 'Redirects the user to the login page, passing the given \'next\' page'
@sensitive_post_parameters() DCNL @never_cache DCNL def password_reset_confirm(request, uidb36=None, token=None, template_name='registration/password_reset_confirm.html', token_generator=default_token_generator, set_password_form=SetPasswordForm, post_reset_redirect=None, current_app=None, extra_context=None): DCNL 'View that checks the hash in a password reset link and presents a DCNL form for entering a new password.'
def _clean_credentials(credentials): DCNL 'Cleans a dictionary of credentials of potentially sensitive info before DCNL sending to less secure functions. DCNL Not comprehensive - intended for user_login_failed signal'
def authenticate(**credentials): DCNL 'If the given credentials are valid, return a User object.'
def login(request, user): DCNL 'Persist a user id and a backend in the request. This way a user doesn\'t DCNL have to reauthenticate on every request. Note that data set during DCNL the anonymous session is retained when the user logs in.'
def logout(request): DCNL 'Removes the authenticated user\'s ID from the request and flushes their DCNL session data.'
def get_user_model(): DCNL 'Return the User model that is active in this project'
def auth(request): DCNL 'Returns context variables required by apps that use Django\'s authentication DCNL system. DCNL If there is no \'user\' attribute in the request, uses AnonymousUser (from DCNL django.contrib.auth).'
def check_password(password, encoded, setter=None, preferred=u'default'): DCNL 'Returns a boolean of whether the raw password matches the three DCNL part encoded digest. DCNL If setter is specified, it\'ll be called when you need to DCNL regenerate the password.'
def make_password(password, salt=None, hasher=u'default'): DCNL 'Turn a plain-text password into a hash for database storage DCNL Same as encode() but generates a new random salt.  If DCNL password is None or blank then UNUSABLE_PASSWORD will be DCNL returned which disallows logins.'
def get_hasher(algorithm=u'default'): DCNL 'Returns an instance of a loaded password hasher. DCNL If algorithm is \'default\', the default hasher will be returned. DCNL This function will also lazy import hashers specified in your DCNL settings file if needed.'
def identify_hasher(encoded): DCNL 'Returns an instance of a loaded password hasher. DCNL Identifies hasher algorithm by examining encoded hash, and calls DCNL get_hasher() to return hasher. Raises ValueError if DCNL algorithm cannot be identified, or if hasher is not loaded.'
def mask_hash(hash, show=6, char=u'*'): DCNL 'Returns the given hash, with only the first ``show`` number shown. The DCNL rest are masked with ``char`` for security reasons.'
def _get_all_permissions(opts, ctype): DCNL 'Returns (codename, name) for all permissions in the given opts.'
def _get_builtin_permissions(opts): DCNL 'Returns (codename, name) for all autogenerated permissions.'
def _check_permission_clashing(custom, builtin, ctype): DCNL 'Check that permissions for a model do not clash. Raises CommandError if DCNL there are duplicate permissions.'
def get_system_username(): DCNL 'Try to determine the current system user\'s username. DCNL :returns: The username as a unicode string, or an empty string if the DCNL username could not be determined.'
def get_default_username(check_db=True): DCNL 'Try to determine the current system user\'s username to use as a default. DCNL :param check_db: If ``True``, requires that the username does not match an DCNL existing ``auth.User`` (otherwise returns an empty string). DCNL :returns: The username, or an empty string if no username can be DCNL determined.'
def skipIfCustomUser(test_func): DCNL 'Skip a test if a custom user model is in use.'
@never_cache DCNL def remote_user_auth_view(request): DCNL 'Dummy view for remote user tests'
def mock_inputs(inputs): DCNL 'Decorator to temporarily replace input/getpass to allow interactive DCNL createsuperuser.'
def check_password(environ, username, password): DCNL 'Authenticates against Django\'s auth database DCNL mod_wsgi docs specify None, True, False as return value depending DCNL on whether the user exists and authenticates.'
def groups_for_user(environ, username): DCNL 'Authorizes a user based on groups'
def user_passes_test(test_func, login_url=None, redirect_field_name=REDIRECT_FIELD_NAME): DCNL 'Decorator for views that checks that the user passes the given test, DCNL redirecting to the log-in page if necessary. The test should be a callable DCNL that takes the user object and returns True if the user passes.'
def login_required(function=None, redirect_field_name=REDIRECT_FIELD_NAME, login_url=None): DCNL 'Decorator for views that checks that the user is logged in, redirecting DCNL to the log-in page if necessary.'
def permission_required(perm, login_url=None, raise_exception=False): DCNL 'Decorator for views that checks whether a user has a particular permission DCNL enabled, redirecting to the log-in page if neccesary. DCNL If the raise_exception parameter is given the PermissionDenied exception DCNL is raised.'
@register.filter(is_safe=True) DCNL def ordinal(value): DCNL 'Converts an integer to its ordinal as a string. 1 is \'1st\', 2 is \'2nd\', DCNL 3 is \'3rd\', etc. Works for any integer.'
@register.filter(is_safe=True) DCNL def intcomma(value, use_l10n=True): DCNL 'Converts an integer to a string containing commas every three digits. DCNL For example, 3000 becomes \'3,000\' and 45000 becomes \'45,000\'.'
@register.filter(is_safe=False) DCNL def intword(value): DCNL 'Converts a large integer to a friendly text representation. Works best DCNL for numbers over 1 million. For example, 1000000 becomes \'1.0 million\', DCNL 1200000 becomes \'1.2 million\' and \'1200000000\' becomes \'1.2 billion\'.'
@register.filter(is_safe=True) DCNL def apnumber(value): DCNL 'For numbers 1-9, returns the number spelled out. Otherwise, returns the DCNL number. This follows Associated Press style.'
@register.filter(expects_localtime=True) DCNL def naturalday(value, arg=None): DCNL 'For date values that are tomorrow, today or yesterday compared to DCNL present day returns representing string. Otherwise, returns a string DCNL formatted according to settings.DATE_FORMAT.'
@register.filter DCNL def naturaltime(value): DCNL 'For date and time values shows how many seconds, minutes or hours ago DCNL compared to current timestamp returns representing string.'
def sentence(): DCNL 'Returns a randomly generated sentence of lorem ipsum text. DCNL The first word is capitalized, and the sentence ends in either a period or DCNL question mark. Commas are added at random.'
def paragraph(): DCNL 'Returns a randomly generated paragraph of lorem ipsum text. DCNL The paragraph consists of between 1 and 4 sentences, inclusive.'
def paragraphs(count, common=True): DCNL 'Returns a list of paragraphs as returned by paragraph(). DCNL If `common` is True, then the first paragraph will be the standard DCNL \'lorem ipsum\' paragraph. Otherwise, the first paragraph will be random DCNL Latin text. Either way, subsequent paragraphs will be random Latin text.'
def words(count, common=True): DCNL 'Returns a string of `count` lorem ipsum words separated by a single space. DCNL If `common` is True, then the first 19 words will be the standard DCNL \'lorem ipsum\' words. Otherwise, all words will be selected randomly.'
@register.tag DCNL def lorem(parser, token): DCNL 'Creates random Latin text useful for providing test data in templates. DCNL Usage format:: DCNL {% lorem [count] [method] [random] %} DCNL ``count`` is a number (or variable) containing the number of paragraphs or DCNL words to generate (default is 1). DCNL ``method`` is either ``w`` for words, ``p`` for HTML paragraphs, ``b`` for DCNL plain-text paragraph blocks (default is ``b``). DCNL ``random`` is the word ``random``, which if given, does not use the common DCNL paragraph (starting "Lorem ipsum dolor sit amet, consectetuer..."). DCNL Examples: DCNL * ``{% lorem %}`` will output the common "lorem ipsum" paragraph DCNL * ``{% lorem 3 p %}`` will output the common "lorem ipsum" paragraph DCNL and two random paragraphs each wrapped in HTML ``<p>`` tags DCNL * ``{% lorem 2 w random %}`` will output two random latin words'
@register.filter(is_safe=True) DCNL def markdown(value, arg=''): DCNL 'Runs Markdown over a given value, optionally using various DCNL extensions python-markdown supports. DCNL Syntax:: DCNL {{ value|markdown:"extension1_name,extension2_name..." }} DCNL To enable safe mode, which strips raw HTML and only returns HTML DCNL generated by actual Markdown syntax, pass "safe" as the first DCNL extension in the list. DCNL If the version of Markdown in use does not support extensions, DCNL they will be silently ignored.'
def serve(request, path, document_root=None, insecure=False, **kwargs): DCNL 'Serve static files below a given point in the directory structure or DCNL from locations inferred from the staticfiles finders. DCNL To use, put a URL pattern such as:: DCNL (r\'^(?P<path>.*)$\', \'django.contrib.staticfiles.views.serve\') DCNL in your URLconf. DCNL It uses the django.views.static view to serve the found files.'
def matches_patterns(path, patterns=None): DCNL 'Return True or False depending on whether the ``path`` should be DCNL ignored (if it matches any pattern in ``ignore_patterns``).'
def get_files(storage, ignore_patterns=None, location=''): DCNL 'Recursively walk the storage directories yielding the paths DCNL of all files that should be copied.'
def check_settings(base_url=None): DCNL 'Checks if the staticfiles settings have sane values.'
def staticfiles_urlpatterns(prefix=None): DCNL 'Helper function to return a URL pattern for serving static files.'
def find(path, all=False): DCNL 'Find a static file with the given path using all enabled finders. DCNL If ``all`` is ``False`` (default), return the first matching DCNL absolute path (or ``None`` if no match). Otherwise return a list.'
def _get_finder(import_path): DCNL 'Imports the staticfiles finder class described by import_path, where DCNL import_path is the full Python path to the class.'
@register.tag('static') DCNL def do_static(parser, token): DCNL 'A template tag that returns the URL to a file DCNL using staticfiles\' storage backend DCNL Usage:: DCNL {% static path [as varname] %} DCNL Examples:: DCNL {% static "myapp/css/base.css" %} DCNL {% static variable_with_path %} DCNL {% static "myapp/css/base.css" as admin_base_css %} DCNL {% static variable_with_path as varname %}'
def next_redirect(request, fallback, **get_kwargs): DCNL 'Handle the "where should I go next?" part of comment views. DCNL The next value could be a DCNL ``?next=...`` GET arg or the URL of a given view (``fallback``). See DCNL the view modules for examples. DCNL Returns an ``HttpResponseRedirect``.'
def confirmation_view(template, doc='Display DCSP a DCSP confirmation DCSP view.'): DCNL 'Confirmation view generator for the "comment was DCNL posted/flagged/deleted/approved" views.'
@csrf_protect DCNL @login_required DCNL def flag(request, comment_id, next=None): DCNL 'Flags a comment. Confirmation on GET, action on POST. DCNL Templates: :template:`comments/flag.html`, DCNL Context: DCNL comment DCNL the flagged `comments.comment` object'
@csrf_protect DCNL @permission_required('comments.can_moderate') DCNL def delete(request, comment_id, next=None): DCNL 'Deletes a comment. Confirmation on GET, action on POST. Requires the "can DCNL moderate comments" permission. DCNL Templates: :template:`comments/delete.html`, DCNL Context: DCNL comment DCNL the flagged `comments.comment` object'
@csrf_protect DCNL @permission_required('comments.can_moderate') DCNL def approve(request, comment_id, next=None): DCNL 'Approve a comment (that is, mark it as public and non-removed). Confirmation DCNL on GET, action on POST. Requires the "can moderate comments" permission. DCNL Templates: :template:`comments/approve.html`, DCNL Context: DCNL comment DCNL the `comments.comment` object for approval'
def perform_flag(request, comment): DCNL 'Actually perform the flagging of a comment from a request.'
@csrf_protect DCNL @require_POST DCNL def post_comment(request, next=None, using=None): DCNL 'Post a comment. DCNL HTTP POST is required. If ``POST[\'submit\'] == "preview"`` or if there are DCNL errors a preview template, ``comments/preview.html``, will be rendered.'
def get_comment_app(): DCNL 'Get the comment app (i.e. "django.contrib.comments") as defined in the settings'
def get_comment_app_name(): DCNL 'Returns the name of the comment app (either the setting value, if it DCNL exists, or the default).'
def get_model(): DCNL 'Returns the comment model class.'
def get_form(): DCNL 'Returns the comment ModelForm class.'
def get_form_target(): DCNL 'Returns the target URL for the comment form submission view.'
def get_flag_url(comment): DCNL 'Get the URL for the "flag this comment" view.'
def get_delete_url(comment): DCNL 'Get the URL for the "delete this comment" view.'
def get_approve_url(comment): DCNL 'Get the URL for the "approve this comment from moderation" view.'
@register.tag DCNL def get_comment_count(parser, token): DCNL 'Gets the comment count for the given params and populates the template DCNL context with a variable containing that value, whose name is defined by the DCNL \'as\' clause. DCNL Syntax:: DCNL {% get_comment_count for [object] as [varname]  %} DCNL {% get_comment_count for [app].[model] [object_id] as [varname]  %} DCNL Example usage:: DCNL {% get_comment_count for event as comment_count %} DCNL {% get_comment_count for calendar.event event.id as comment_count %} DCNL {% get_comment_count for calendar.event 17 as comment_count %}'
@register.tag DCNL def get_comment_list(parser, token): DCNL 'Gets the list of comments for the given params and populates the template DCNL context with a variable containing that value, whose name is defined by the DCNL \'as\' clause. DCNL Syntax:: DCNL {% get_comment_list for [object] as [varname]  %} DCNL {% get_comment_list for [app].[model] [object_id] as [varname]  %} DCNL Example usage:: DCNL {% get_comment_list for event as comment_list %} DCNL {% for comment in comment_list %} DCNL {% endfor %}'
@register.tag DCNL def render_comment_list(parser, token): DCNL 'Render the comment list (as returned by ``{% get_comment_list %}``) DCNL through the ``comments/list.html`` template DCNL Syntax:: DCNL {% render_comment_list for [object] %} DCNL {% render_comment_list for [app].[model] [object_id] %} DCNL Example usage:: DCNL {% render_comment_list for event %}'
@register.tag DCNL def get_comment_form(parser, token): DCNL 'Get a (new) form object to post a new comment. DCNL Syntax:: DCNL {% get_comment_form for [object] as [varname] %} DCNL {% get_comment_form for [app].[model] [object_id] as [varname] %}'
@register.tag DCNL def render_comment_form(parser, token): DCNL 'Render the comment form (as returned by ``{% render_comment_form %}``) through DCNL the ``comments/form.html`` template. DCNL Syntax:: DCNL {% render_comment_form for [object] %} DCNL {% render_comment_form for [app].[model] [object_id] %}'
@register.simple_tag DCNL def comment_form_target(): DCNL 'Get the target URL for the comment form. DCNL Example:: DCNL <form action="{% comment_form_target %}" method="post">'
@register.simple_tag DCNL def get_comment_permalink(comment, anchor_pattern=None): DCNL 'Get the permalink for a comment, optionally specifying the format of the DCNL named anchor to be appended to the end of the URL. DCNL Example:: DCNL {% get_comment_permalink comment "#c%(id)s-by-%(user_name)s" %}'
def get_level_tags(): DCNL 'Returns the message level tags.'
def messages(request): DCNL 'Returns a lazy \'messages\' context variable.'
def get_storage(import_path): DCNL 'Imports the message storage class described by import_path, where DCNL import_path is the full Python path to the class.'
def set_session_data(storage, messages): DCNL 'Sets the messages into the backend request\'s session and remove the DCNL backend\'s loaded data cache.'
def set_cookie_data(storage, messages, invalid=False, encode_empty=False): DCNL 'Sets ``request.COOKIES`` with the encoded data and removes the storage DCNL backend\'s loaded data cache.'
def stored_cookie_messages_count(storage, response): DCNL 'Returns an integer containing the number of messages stored.'
def add_level_messages(storage): DCNL 'Adds 6 messages from different levels (including a custom one) to a storage DCNL instance.'
def add_message(request, level, message, extra_tags='', fail_silently=False): DCNL 'Attempts to add a message to the request using the \'messages\' app.'
def get_messages(request): DCNL 'Returns the message storage on the request if it exists, otherwise returns DCNL an empty list.'
def get_level(request): DCNL 'Returns the minimum level of messages to be recorded. DCNL The default level is the ``MESSAGE_LEVEL`` setting. If this is not found, DCNL the ``INFO`` level is used.'
def set_level(request, level): DCNL 'Sets the minimum level of messages to be recorded, returning ``True`` if DCNL the level was recorded successfully. DCNL If set to ``None``, the default level will be used (see the ``get_level`` DCNL method).'
def debug(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``DEBUG`` level.'
def info(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``INFO`` level.'
def success(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``SUCCESS`` level.'
def warning(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``WARNING`` level.'
def error(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``ERROR`` level.'
def normalize_name(name): DCNL 'Converts camel-case style names into underscore seperated words. Example:: DCNL >>> normalize_name(\'oneTwoThree\') DCNL \'one_two_three\' DCNL >>> normalize_name(\'FourFiveSix\') DCNL \'four_five_six\''
def form_hmac(form): DCNL 'Calculates a security hash for the given Form instance.'
def fromfile(file_h): DCNL 'Given a string file name, returns a GEOSGeometry. The file may contain WKB, DCNL WKT, or HEX.'
def fromstr(string, **kwargs): DCNL 'Given a string value, returns a GEOSGeometry object.'
def suite(): DCNL 'Builds a test suite for the GEOS tests.'
def run(verbosity=1): DCNL 'Runs the GEOS tests.'
def check_cs_ptr(result, func, cargs): DCNL 'Error checking on routines that return Geometries.'
def check_cs_op(result, func, cargs): DCNL 'Checks the status code of a coordinate sequence operation.'
def check_cs_get(result, func, cargs): DCNL 'Checking the coordinate sequence retrieval.'
def cs_int(func): DCNL 'For coordinate sequence routines that return an integer.'
def cs_operation(func, ordinate=False, get=False): DCNL 'For coordinate sequence operations.'
def cs_output(func, argtypes): DCNL 'For routines that return a coordinate sequence.'
def binary_predicate(func, *args): DCNL 'For GEOS binary predicate functions.'
def unary_predicate(func): DCNL 'For GEOS unary predicate functions.'
def last_arg_byref(args): DCNL 'Returns the last C argument\'s value by reference.'
def check_dbl(result, func, cargs): DCNL 'Checks the status code and returns the double value passed in by reference.'
def check_geom(result, func, cargs): DCNL 'Error checking on routines that return Geometries.'
def check_minus_one(result, func, cargs): DCNL 'Error checking on routines that should not return -1.'
def check_predicate(result, func, cargs): DCNL 'Error checking for unary/binary predicate functions.'
def check_sized_string(result, func, cargs): DCNL 'Error checking for routines that return explicitly sized strings. DCNL This frees the memory allocated by GEOS at the result pointer.'
def check_string(result, func, cargs): DCNL 'Error checking for routines that return strings. DCNL This frees the memory allocated by GEOS at the result pointer.'
def check_zero(result, func, cargs): DCNL 'Error checking on routines that should not return 0.'
def topology(func, *args, **kwargs): DCNL 'For GEOS unary topology functions.'
def bin_constructor(func): DCNL 'Generates a prototype for binary construction (HEX, WKB) GEOS routines.'
def bin_output(func): DCNL 'Generates a prototype for the routines that return a sized string.'
def geom_output(func, argtypes): DCNL 'For GEOS routines that return a geometry.'
def geom_index(func): DCNL 'For GEOS routines that return geometries from an index.'
def int_from_geom(func, zero=False): DCNL 'Argument is a geometry, return type is an integer.'
def string_from_geom(func): DCNL 'Argument is a Geometry, return type is a string.'
def dbl_from_geom(func, num_geom=1): DCNL 'Argument is a Geometry, return type is double that is passed DCNL in by reference as the last argument.'
def get_pointer_arr(n): DCNL 'Gets a ctypes pointer array (of length `n`) for GEOSGeom_t opaque pointer.'
def geos_version_info(): DCNL 'Returns a dictionary containing the various version metadata parsed from DCNL the GEOS version string, including the version number, whether the version DCNL is a release candidate (and what number release candidate), and the C API DCNL version.'
def feed(request, url, feed_dict=None): DCNL 'Provided for backwards compatibility.'
def add_srs_entry(srs, auth_name='EPSG', auth_srid=None, ref_sys_name=None, database=None): DCNL 'This function takes a GDAL SpatialReference system and adds its information DCNL to the `spatial_ref_sys` table of the spatial backend.  Doing this enables DCNL database-level spatial transformations for the backend.  Thus, this utility DCNL is useful for adding spatial reference systems not included by default with DCNL the backend -- for example, the so-called "Google Maps Mercator Projection" DCNL is excluded in PostGIS 1.3 and below, and the following adds it to the DCNL `spatial_ref_sys` table: DCNL >>> from django.contrib.gis.utils import add_srs_entry DCNL >>> add_srs_entry(900913) DCNL Keyword Arguments: DCNL auth_name: DCNL This keyword may be customized with the value of the `auth_name` field. DCNL Defaults to \'EPSG\'. DCNL auth_srid: DCNL This keyword may be customized with the value of the `auth_srid` field. DCNL Defaults to the SRID determined by GDAL. DCNL ref_sys_name: DCNL For SpatiaLite users only, sets the value of the `ref_sys_name` field. DCNL Defaults to the name determined by GDAL. DCNL database: DCNL The name of the database connection to use; the default is the value DCNL of `django.db.DEFAULT_DB_ALIAS` (at the time of this writing, it\'s value DCNL is \'default\').'
def precision_wkt(geom, prec): DCNL 'Returns WKT text of the geometry according to the given precision (an DCNL integer or a string).  If the precision is an integer, then the decimal DCNL places of coordinates WKT will be truncated to that number: DCNL >>> pnt = Point(5, 23) DCNL >>> pnt.wkt DCNL \'POINT (5.0000000000000000 23.0000000000000000)\' DCNL >>> precision(geom, 1) DCNL \'POINT (5.0 23.0)\' DCNL If the precision is a string, it must be valid Python format string DCNL (e.g., \'%20.7f\') -- thus, you should know what you\'re doing.'
def ogrinfo(data_source, num_features=10): DCNL 'Walks the available layers in the supplied `data_source`, displaying DCNL the fields for the first `num_features` features.'
def mapping(data_source, geom_name='geom', layer_key=0, multi_geom=False): DCNL 'Given a DataSource, generates a dictionary that may be used DCNL for invoking the LayerMapping utility. DCNL Keyword Arguments: DCNL `geom_name` => The name of the geometry field to use for the model. DCNL `layer_key` => The key for specifying which layer in the DataSource to use; DCNL defaults to 0 (the first layer).  May be an integer index or a string DCNL identifier for the layer. DCNL `multi_geom` => Boolean (default: False) - specify as multigeometry.'
def ogrinspect(*args, **kwargs): DCNL 'Given a data source (either a string or a DataSource object) and a string DCNL model name this function will generate a GeoDjango model. DCNL Usage: DCNL >>> from django.contrib.gis.utils import ogrinspect DCNL >>> ogrinspect(\'/path/to/shapefile.shp\',\'NewModel\') DCNL ...will print model definition to stout DCNL or put this in a python script and use to redirect the output to a new DCNL model like: DCNL $ python generate_model.py > myapp/models.py DCNL # generate_model.py DCNL from django.contrib.gis.utils import ogrinspect DCNL shp_file = \'data/mapping_hacks/world_borders.shp\' DCNL model_name = \'WorldBorders\' DCNL print(ogrinspect(shp_file, model_name, multi_geom=True, srid=4326, DCNL geom_name=\'shapes\', blank=True)) DCNL Required Arguments DCNL `datasource` => string or DataSource object to file pointer DCNL `model name` => string of name of new model class to create DCNL Optional Keyword Arguments DCNL `geom_name` => For specifying the model name for the Geometry Field. DCNL Otherwise will default to `geom` DCNL `layer_key` => The key for specifying which layer in the DataSource to use; DCNL defaults to 0 (the first layer).  May be an integer index or a string DCNL identifier for the layer. DCNL `srid` => The SRID to use for the Geometry Field.  If it can be determined, DCNL the SRID of the datasource is used. DCNL `multi_geom` => Boolean (default: False) - specify as multigeometry. DCNL `name_field` => String - specifies a field name to return for the DCNL `__unicode__` function (which will be generated if specified). DCNL `imports` => Boolean (default: True) - set to False to omit the DCNL `from django.contrib.gis.db import models` code from the DCNL autogenerated models thus avoiding duplicated imports when building DCNL more than one model by batching ogrinspect() DCNL `decimal` => Boolean or sequence (default: False).  When set to True DCNL all generated model fields corresponding to the `OFTReal` type will DCNL be `DecimalField` instead of `FloatField`.  A sequence of specific DCNL field names to generate as `DecimalField` may also be used. DCNL `blank` => Boolean or sequence (default: False).  When set to True all DCNL generated model fields will have `blank=True`.  If the user wants to DCNL give specific fields to have blank, then a list/tuple of OGR field DCNL names may be used. DCNL `null` => Boolean (default: False) - When set to True all generated DCNL model fields will have `null=True`.  If the user wants to specify DCNL give specific fields to have null, then a list/tuple of OGR field DCNL names may be used. DCNL Note: This routine calls the _ogrinspect() helper to do the heavy lifting.'
def _ogrinspect(data_source, model_name, geom_name='geom', layer_key=0, srid=None, multi_geom=False, name_field=None, imports=True, decimal=False, blank=False, null=False): DCNL 'Helper routine for `ogrinspect` that generates GeoDjango models corresponding DCNL to the given data source.  See the `ogrinspect` docstring for more details.'
def get_srid_info(srid, connection): DCNL 'Returns the units, unit name, and spheroid WKT associated with the DCNL given SRID from the `spatial_ref_sys` (or equivalent) spatial database DCNL table for the given database connection.  These results are cached.'
def get_dist_ops(operator): DCNL 'Returns operations for regular distances; spherical distances are not currently supported.'
def check_err(code): DCNL 'Checks the given OGRERR, and raises an exception where appropriate.'
def std_call(func): DCNL 'Returns the correct STDCALL function for certain OSR routines on Win32 DCNL platforms.'
def gdal_version(): DCNL 'Returns only the GDAL version number information.'
def gdal_full_version(): DCNL 'Returns the full GDAL version information.'
def suite(): DCNL 'Builds a test suite for the GDAL tests.'
def run(verbosity=1): DCNL 'Runs the GDAL tests.'
def srs_double(f): DCNL 'Creates a function prototype for the OSR routines that take DCNL the OSRSpatialReference object and'
def units_func(f): DCNL 'Creates a ctypes function prototype for OSR units functions, e.g., DCNL OSRGetAngularUnits, OSRGetLinearUnits.'
def arg_byref(args, offset=(-1)): DCNL 'Returns the pointer argument\'s by-refernece value.'
def ptr_byref(args, offset=(-1)): DCNL 'Returns the pointer argument passed in by-reference.'
def check_bool(result, func, cargs): DCNL 'Returns the boolean evaluation of the value.'
def check_const_string(result, func, cargs, offset=None): DCNL 'Similar functionality to `check_string`, but does not free the pointer.'
def check_string(result, func, cargs, offset=(-1), str_result=False): DCNL 'Checks the string output returned from the given function, and frees DCNL the string pointer allocated by OGR.  The `str_result` keyword DCNL may be used when the result is the string pointer, otherwise DCNL the OGR error code is assumed.  The `offset` keyword may be used DCNL to extract the string pointer passed in by-reference at the given DCNL slice offset in the function arguments.'
def check_envelope(result, func, cargs, offset=(-1)): DCNL 'Checks a function that returns an OGR Envelope by reference.'
def check_geom(result, func, cargs): DCNL 'Checks a function that returns a geometry.'
def check_geom_offset(result, func, cargs, offset=(-1)): DCNL 'Chcks the geometry at the given offset in the C parameter list.'
def check_arg_errcode(result, func, cargs): DCNL 'The error code is returned in the last argument, by reference. DCNL Check its value with `check_err` before returning the result.'
def check_errcode(result, func, cargs): DCNL 'Check the error code returned (c_int).'
def check_pointer(result, func, cargs): DCNL 'Makes sure the result pointer is valid.'
def check_str_arg(result, func, cargs): DCNL 'This is for the OSRGet[Angular|Linear]Units functions, which DCNL require that the returned string pointer not be freed.  This DCNL returns both the double and tring values.'
def double_output(func, argtypes, errcheck=False, strarg=False): DCNL 'Generates a ctypes function that returns a double value.'
def geom_output(func, argtypes, offset=None): DCNL 'Generates a function that returns a Geometry either by reference DCNL or directly (if the return_geom keyword is set to True).'
def int_output(func, argtypes): DCNL 'Generates a ctypes function that returns an integer value.'
def srs_output(func, argtypes): DCNL 'Generates a ctypes prototype for the given function with DCNL the given C arguments that returns a pointer to an OGR DCNL Spatial Reference System.'
def string_output(func, argtypes, offset=(-1), str_result=False, decoding=None): DCNL 'Generates a ctypes prototype for the given function with the DCNL given argument types that returns a string from a GDAL pointer. DCNL The `const` flag indicates whether the allocated pointer should DCNL be freed via the GDAL library routine VSIFree -- but only applies DCNL only when `str_result` is True.'
def void_output(func, argtypes, errcheck=True): DCNL 'For functions that don\'t only return an error code that needs to DCNL be examined.'
def voidptr_output(func, argtypes): DCNL 'For functions that return c_void_p.'
def env_func(f, argtypes): DCNL 'For getting OGREnvelopes.'
def pnt_func(f): DCNL 'For accessing point information.'
def tuplize(seq): DCNL 'Turn all nested sequences to tuples in given sequence.'
def strconvert(d): DCNL 'Converts all keys in dictionary to str type.'
def compress_kml(kml): DCNL 'Returns compressed KMZ from the given KML string.'
def render_to_kml(*args, **kwargs): DCNL 'Renders the response as KML (using the correct MIME type).'
def render_to_kmz(*args, **kwargs): DCNL 'Compresses the KML content and returns as KMZ (using the correct DCNL MIME type).'
def render_to_text(*args, **kwargs): DCNL 'Renders the response using the MIME type for plain text.'
def layer_option(option, opt, value, parser): DCNL 'Callback for `make_option` for the `ogrinspect` `layer_key` DCNL keyword option which may be an integer or a string.'
def list_option(option, opt, value, parser): DCNL 'Callback for `make_option` for `ogrinspect` keywords that require DCNL a string list.  If the string is \'True\'/\'true\' then the option DCNL value will be a boolean instead.'
def no_backend(test_func, backend): DCNL 'Use this decorator to disable test on specified backend.'
def geo_apps(namespace=True, runtests=False): DCNL 'Returns a list of GeoDjango test applications that reside in DCNL `django.contrib.gis.tests` that can be used with the current DCNL database and the spatial libraries that are installed.'
def geodjango_suite(apps=True): DCNL 'Returns a TestSuite consisting only of GeoDjango tests that can be run.'
def index(request, sitemaps): DCNL 'This view generates a sitemap index that uses the proper view DCNL for resolving geographic section sitemap URLs.'
def sitemap(request, sitemaps, section=None): DCNL 'This view generates a sitemap with additional geographic DCNL elements defined by Google.'
def kml(request, label, model, field_name=None, compress=False, using=DEFAULT_DB_ALIAS): DCNL 'This view generates KML for the given app label, model, and field name. DCNL The model\'s default manager must be GeoManager, and the field name DCNL must be that of a geographic field.'
def kmz(request, label, model, field_name=None, using=DEFAULT_DB_ALIAS): DCNL 'This view returns KMZ for the given app label, model, and field name.'
def validate(cls, model): DCNL 'Does basic ModelAdmin option validation. Calls custom validation DCNL classmethod in the end if it is provided in cls. The signature of the DCNL custom validation classmethod should be: def validate(cls, model).'
def validate_fields_spec(cls, model, opts, flds, label): DCNL 'Validate the fields specification in `flds` from a ModelAdmin subclass DCNL `cls` for the `model` model. `opts` is `model`\'s Meta inner class. DCNL Use `label` for reporting problems to the user. DCNL The fields specification can be a ``fields`` option or a ``fields`` DCNL sub-option from a ``fieldsets`` option component.'
def staff_member_required(view_func): DCNL 'Decorator for views that checks that the user is logged in and is a staff DCNL member, displaying the login page if necessary.'
def autodiscover(): DCNL 'Auto-discover INSTALLED_APPS admin.py modules and fail silently when DCNL not present. This forces an import on them to register any admin bits they DCNL may want.'
def normalize_fieldsets(fieldsets): DCNL 'Make sure the keys in fieldset dictionaries are strings. Returns the DCNL normalized data.'
def normalize_dictionary(data_dict): DCNL 'Converts all the keys in "data_dict" to strings. The keys must be DCNL convertible using str().'
def delete_selected(modeladmin, request, queryset): DCNL 'Default action which deletes the selected objects. DCNL This action first displays a confirmation page whichs shows all the DCNL deleteable objects, or, if the user has no permission one of the related DCNL childs (foreignkeys), a "permission denied" message. DCNL Next, it delets all selected objects and redirects back to the change list.'
def lookup_needs_distinct(opts, lookup_path): DCNL 'Returns True if \'distinct()\' should be used to query the given lookup path.'
def prepare_lookup_value(key, value): DCNL 'Returns a lookup value prepared to be used in queryset filtering.'
def quote(s): DCNL 'Ensure that primary key values do not confuse the admin URLs by escaping DCNL any \'/\', \'_\' and \':\' and similarly problematic characters. DCNL Similar to urllib.quote, except that the quoting is slightly different so DCNL that it doesn\'t get automatically unquoted by the Web browser.'
def unquote(s): DCNL 'Undo the effects of quote(). Based heavily on urllib.unquote().'
def flatten_fieldsets(fieldsets): DCNL 'Returns a list of field names from an admin fieldsets structure.'
def get_deleted_objects(objs, opts, user, admin_site, using): DCNL 'Find all objects related to ``objs`` that should also be deleted. ``objs`` DCNL must be a homogenous iterable of objects (e.g. a QuerySet). DCNL Returns a nested list of strings suitable for display in the DCNL template with the ``unordered_list`` filter.'
def model_format_dict(obj): DCNL 'Return a `dict` with keys \'verbose_name\' and \'verbose_name_plural\', DCNL typically for use with string formatting. DCNL `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.'
def model_ngettext(obj, n=None): DCNL 'Return the appropriate `verbose_name` or `verbose_name_plural` value for DCNL `obj` depending on the count `n`. DCNL `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance. DCNL If `obj` is a `QuerySet` instance, `n` is optional and the length of the DCNL `QuerySet` is used.'
def label_for_field(name, model, model_admin=None, return_attr=False): DCNL 'Returns a sensible label for a field name. The name can be a callable or the DCNL name of an object attributes, as well as a genuine fields. If return_attr is DCNL True, the resolved attribute (which could be a callable) is also returned. DCNL This will be None if (and only if) the name refers to a field.'
def reverse_field_path(model, path): DCNL 'Create a reversed field path. DCNL E.g. Given (Order, "user__groups"), DCNL return (Group, "user__order"). DCNL Final field must be a related model, not a data field.'
def get_fields_from_path(model, path): DCNL 'Return list of Fields given path relative to model. DCNL e.g. (ModelX, "user__groups__name") -> [ DCNL <django.db.models.fields.related.ForeignKey object at 0x...>, DCNL <django.db.models.fields.related.ManyToManyField object at 0x...>, DCNL <django.db.models.fields.CharField object at 0x...>,'
def remove_trailing_data_field(fields): DCNL 'Discard trailing non-relation field if extant.'
def get_limit_choices_to_from_path(model, path): DCNL 'Return Q object for limiting choices if applicable. DCNL If final model in path is linked via a ForeignKey or ManyToManyField which DCNL has a `limit_choices_to` attribute, return it as a Q object.'
def url_params_from_lookup_dict(lookups): DCNL 'Converts the type of lookups specified in a ForeignKey limit_choices_to DCNL attribute to a dictionary of query parameters'
@register.tag DCNL def get_admin_log(parser, token): DCNL 'Populates a template variable with the admin log for the given criteria. DCNL Usage:: DCNL {% get_admin_log [limit] as [varname] for_user [context_var_containing_user_obj] %} DCNL Examples:: DCNL {% get_admin_log 10 as admin_log for_user 23 %} DCNL {% get_admin_log 10 as admin_log for_user user %} DCNL {% get_admin_log 10 as admin_log %} DCNL Note that ``context_var_containing_user_obj`` can be a hard-coded integer DCNL (user ID) or the name of a template context variable containing the user DCNL object whose ID you want.'
@register.simple_tag DCNL def paginator_number(cl, i): DCNL 'Generates an individual page index link in a paginated list.'
@register.inclusion_tag(u'admin/pagination.html') DCNL def pagination(cl): DCNL 'Generates the series of links to the pages in a paginated list.'
def result_headers(cl): DCNL 'Generates the list column headers.'
def items_for_result(cl, result, form): DCNL 'Generates the actual list of data.'
@register.inclusion_tag(u'admin/change_list_results.html') DCNL def result_list(cl): DCNL 'Displays the headers and data list together'
@register.inclusion_tag(u'admin/date_hierarchy.html') DCNL def date_hierarchy(cl): DCNL 'Displays the date hierarchy for date drill-down functionality.'
@register.inclusion_tag(u'admin/search_form.html') DCNL def search_form(cl): DCNL 'Displays a search form for searching the list.'
@register.inclusion_tag(u'admin/actions.html', takes_context=True) DCNL def admin_actions(context): DCNL 'Track the number of times the action field has been rendered on the page, DCNL so we know which value to use.'
@register.inclusion_tag('admin/prepopulated_fields_js.html', takes_context=True) DCNL def prepopulated_fields_js(context): DCNL 'Creates a list of prepopulated_fields that should render Javascript for DCNL the prepopulated fields for both the admin form and inlines.'
@register.inclusion_tag('admin/submit_line.html', takes_context=True) DCNL def submit_row(context): DCNL 'Displays the row of buttons for delete and save.'
@register.filter DCNL def cell_count(inline_admin_form): DCNL 'Returns the number of cells used in a tabular inline'
def get_validation_digit(number): DCNL 'Calculates the validation digit for the given number.'
def id_number_checksum(gd): DCNL 'Calculates a Swedish ID number checksum, using the DCNL "Luhn"-algoritm'
def validate_id_birthday(gd, fix_coordination_number_day=True): DCNL 'Validates the birth_day and returns the datetime.date object for DCNL the birth_day. DCNL If the date is an invalid birth day, a ValueError will be raised.'
def ssn_check_digit(value): DCNL 'Calculate Italian social security number check digit.'
def vat_number_check_digit(vat_number): DCNL 'Calculate Italian VAT number check digit.'
def missing_docutils_page(request): DCNL 'Display an error message for people without docutils'
def get_return_data_type(func_name): DCNL 'Return a somewhat-helpful data type given a function name'
def get_readable_field_data_type(field): DCNL 'Returns the description for a given field type, if it exists, DCNL Fields\' descriptions can contain format strings, which will be interpolated DCNL against the values of field.__dict__ before being output.'
def extract_views_from_urlpatterns(urlpatterns, base=''): DCNL 'Return a list of views from a list of urlpatterns. DCNL Each object in the returned list is a two-tuple: (view_func, regex)'
def simplify_regex(pattern): DCNL 'Clean up urlpattern regexes into something somewhat readable by Mere Humans: DCNL turns something like "^(?P<sport_slug>\w+)/athletes/(?P<athlete_slug>\w+)/$" DCNL into "<sport_slug>/athletes/<athlete_slug>/"'
def trim_docstring(docstring): DCNL 'Uniformly trims leading/trailing whitespace from docstrings. DCNL Based on http://www.python.org/peps/pep-0257.html#handling-docstring-indentation'
def parse_docstring(docstring): DCNL 'Parse out the parts of a docstring.  Returns (title, body, metadata).'
def parse_rst(text, default_reference_context, thing_being_parsed=None): DCNL 'Convert the string from reST to an XHTML fragment.'
def flatpage(request, url): DCNL 'Public interface to the flat page view. DCNL Models: `flatpages.flatpages` DCNL Templates: Uses the template defined by the ``template_name`` field, DCNL or :template:`flatpages/default.html` if template_name is not defined. DCNL Context: DCNL flatpage DCNL `flatpages.flatpages` object'
@csrf_protect DCNL def render_flatpage(request, f): DCNL 'Internal interface to the flat page view.'
@register.tag DCNL def get_flatpages(parser, token): DCNL 'Retrieves all flatpage objects available for the current site and DCNL visible to the specific user (or visible to all users if no user is DCNL specified). Populates the template context with them in a variable DCNL whose name is defined by the ``as`` clause. DCNL An optional ``for`` clause can be used to control the user whose DCNL permissions are to be used in determining which flatpages are visible. DCNL An optional argument, ``starts_with``, can be applied to limit the DCNL returned flatpages to those beginning with a particular base URL. DCNL This argument can be passed as a variable or a string, as it resolves DCNL from the template context. DCNL Syntax:: DCNL {% get_flatpages [\'url_starts_with\'] [for user] as context_name %} DCNL Example usage:: DCNL {% get_flatpages as flatpages %} DCNL {% get_flatpages for someuser as flatpages %} DCNL {% get_flatpages \'/about/\' as about_pages %} DCNL {% get_flatpages prefix as about_pages %} DCNL {% get_flatpages \'/about/\' for someuser as about_pages %}'
def ping_google(sitemap_url=None, ping_url=PING_URL): DCNL 'Alerts Google that the sitemap for the current site has been updated. DCNL If sitemap_url is provided, it should be an absolute path to the sitemap DCNL for this site -- e.g., \'/sitemap.xml\'. If sitemap_url is not provided, this DCNL function will attempt to deduce it by using urlresolvers.reverse().'
def render_to_response(*args, **kwargs): DCNL 'Returns a HttpResponse whose content is filled with the result of calling DCNL django.template.loader.render_to_string() with the passed arguments.'
def render(request, *args, **kwargs): DCNL 'Returns a HttpResponse whose content is filled with the result of calling DCNL django.template.loader.render_to_string() with the passed arguments. DCNL Uses a RequestContext by default.'
def redirect(to, *args, **kwargs): DCNL 'Returns an HttpResponseRedirect to the apropriate URL for the arguments DCNL passed. DCNL The arguments could be: DCNL * A model: the model\'s `get_absolute_url()` function will be called. DCNL * A view name, possibly with arguments: `urlresolvers.reverse()` will DCNL be used to reverse-resolve the name. DCNL * A URL, which will be used as-is for the redirect location. DCNL By default issues a temporary redirect; pass permanent=True to issue a DCNL permanent redirect'
def _get_queryset(klass): DCNL 'Returns a QuerySet from a Model, Manager, or QuerySet. Created to make DCNL get_object_or_404 and get_list_or_404 more DRY. DCNL Raises a ValueError if klass is not a Model, Manager, or QuerySet.'
def get_object_or_404(klass, *args, **kwargs): DCNL 'Uses get() to return an object, or raises a Http404 exception if the object DCNL does not exist. DCNL klass may be a Model, Manager, or QuerySet object. All other passed DCNL arguments and keyword arguments are used in the get() query. DCNL Note: Like with get(), an MultipleObjectsReturned will be raised if more than one DCNL object is found.'
def get_list_or_404(klass, *args, **kwargs): DCNL 'Uses filter() to return a list of objects, or raise a Http404 exception if DCNL the list is empty. DCNL klass may be a Model, Manager, or QuerySet object. All other passed DCNL arguments and keyword arguments are used in the filter() query.'
def resolve_url(to, *args, **kwargs): DCNL 'Return a URL appropriate for the arguments passed. DCNL The arguments could be: DCNL * A model: the model\'s `get_absolute_url()` function will be called. DCNL * A view name, possibly with arguments: `urlresolvers.reverse()` will DCNL be used to reverse-resolve the name. DCNL * A URL, which will be returned as-is.'
def _is_ignorable_404(uri): DCNL 'Returns True if a 404 at the given URL *shouldn\'t* notify the site managers.'
def _is_internal_request(domain, referer): DCNL 'Returns true if the referring URL is the same domain as the current request.'
def _get_failure_view(): DCNL 'Returns the view to be used for CSRF rejections'
def get_token(request): DCNL 'Returns the CSRF token required for a POST form. The token is an DCNL alphanumeric value. DCNL A side effect of calling this function is to make the csrf_protect DCNL decorator and the CsrfViewMiddleware add a CSRF cookie and a \'Vary: Cookie\' DCNL header to the outgoing response.  For this reason, you may need to use this DCNL function lazily, as is done by the csrf context processor.'
def urlquote(url, safe=u'/'): DCNL 'A version of Python\'s urllib.quote() function that can operate on unicode DCNL strings. The url is first UTF-8 encoded before quoting. The returned string DCNL can safely be used as part of an argument to a subsequent iri_to_uri() call DCNL without double-quoting occurring.'
def urlquote_plus(url, safe=u''): DCNL 'A version of Python\'s urllib.quote_plus() function that can operate on DCNL unicode strings. The url is first UTF-8 encoded before quoting. The DCNL returned string can safely be used as part of an argument to a subsequent DCNL iri_to_uri() call without double-quoting occurring.'
def urlunquote(quoted_url): DCNL 'A wrapper for Python\'s urllib.unquote() function that can operate on DCNL the result of django.utils.http.urlquote().'
def urlunquote_plus(quoted_url): DCNL 'A wrapper for Python\'s urllib.unquote_plus() function that can operate on DCNL the result of django.utils.http.urlquote_plus().'
def urlencode(query, doseq=0): DCNL 'A version of Python\'s urllib.urlencode() function that can operate on DCNL unicode strings. The parameters are first case to UTF-8 encoded strings and DCNL then encoded as per normal.'
def cookie_date(epoch_seconds=None): DCNL 'Formats the time to ensure compatibility with Netscape\'s cookie standard. DCNL Accepts a floating point number expressed in seconds since the epoch, in DCNL UTC - such as that outputted by time.time(). If set to None, defaults to DCNL the current time. DCNL Outputs a string in the format \'Wdy, DD-Mon-YYYY HH:MM:SS GMT\'.'
def http_date(epoch_seconds=None): DCNL 'Formats the time to match the RFC1123 date format as specified by HTTP DCNL RFC2616 section 3.3.1. DCNL Accepts a floating point number expressed in seconds since the epoch, in DCNL UTC - such as that outputted by time.time(). If set to None, defaults to DCNL the current time. DCNL Outputs a string in the format \'Wdy, DD Mon YYYY HH:MM:SS GMT\'.'
def parse_http_date(date): DCNL 'Parses a date format as specified by HTTP RFC2616 section 3.3.1. DCNL The three formats allowed by the RFC are accepted, even if only the first DCNL one is still in widespread use. DCNL Returns an integer expressed in seconds since the epoch, in UTC.'
def parse_http_date_safe(date): DCNL 'Same as parse_http_date, but returns None if the input is invalid.'
def base36_to_int(s): DCNL 'Converts a base 36 string to an ``int``. Raises ``ValueError` if the DCNL input won\'t fit into an int.'
def int_to_base36(i): DCNL 'Converts an integer to a base36 string'
def parse_etags(etag_str): DCNL 'Parses a string with one or several etags passed in If-None-Match and DCNL If-Match headers by the rules in RFC 2616. Returns a list of etags DCNL without surrounding double quotes (") and unescaped from \<CHAR>.'
def quote_etag(etag): DCNL 'Wraps a string in double quotes escaping contents as necesary.'
def same_origin(url1, url2): DCNL 'Checks if two URLs are \'same-origin\''
def is_safe_url(url, host=None): DCNL 'Return ``True`` if the url is a safe redirection (i.e. it doesn\'t point to DCNL a different host). DCNL Always returns ``False`` on an empty url.'
def normalize(pattern): DCNL 'Given a reg-exp pattern, normalizes it to an iterable of forms that DCNL suffice for reverse matching. This does the following: DCNL (1) For any repeating sections, keeps the minimum number of occurrences DCNL permitted (this means zero for optional groups). DCNL (2) If an optional group includes parameters, include one occurrence of DCNL that group (along with the zero occurrence case from step (1)). DCNL (3) Select the first (essentially an arbitrary) element from any character DCNL class. Select an arbitrary character for any unordered class (e.g. \'.\' DCNL or \'\w\') in the pattern. DCNL (5) Ignore comments and any of the reg-exp flags that won\'t change DCNL what we construct ("iLmsu"). "(?x)" is an error, however. DCNL (6) Raise an error on all other non-capturing (?...) forms (e.g. DCNL look-ahead and look-behind matches) and any disjunctive (\'|\') DCNL constructs. DCNL Django\'s URLs for forward resolving are either all positional arguments or DCNL all keyword arguments. That is assumed here, as well. Although reverse DCNL resolving can be done using positional args when keyword args are DCNL specified, the two cannot be mixed in the same reverse() call.'
def next_char(input_iter): DCNL 'An iterator that yields the next character from "pattern_iter", respecting DCNL escape sequences. An escaped character is replaced by a representative of DCNL its class (e.g. \w -> "x"). If the escaped character is one that is DCNL skipped, it is not returned (the next character is returned instead). DCNL Yields the next character, along with a boolean indicating whether it is a DCNL raw (unescaped) character or not.'
def walk_to_end(ch, input_iter): DCNL 'The iterator is currently inside a capturing group. We want to walk to the DCNL close of this group, skipping over any nested groups and handling escaped DCNL parentheses correctly.'
def get_quantifier(ch, input_iter): DCNL 'Parse a quantifier from the input, where "ch" is the first character in the DCNL quantifier. DCNL Returns the minimum number of occurences permitted by the quantifier and DCNL either None or the next character from the input_iter if the next character DCNL is not part of the quantifier.'
def contains(source, inst): DCNL 'Returns True if the "source" contains an instance of "inst". False, DCNL otherwise.'
def flatten_result(source): DCNL 'Turns the given source sequence into a list of reg-exp possibilities and DCNL their arguments. Returns a list of strings and a list of argument lists. DCNL Each of the two lists will be of the same length.'
def dictConfig(config): DCNL 'Configure logging using a dictionary.'
def is_iterable(x): DCNL 'A implementation independent way of checking for iterables'
def is_iterator(x): DCNL 'An implementation independent way of checking for iterators DCNL Python 2.6 has a different implementation of collections.Iterator which DCNL accepts anything with a `next` method. 2.7+ requires and `__iter__` method DCNL as well.'
def colorize(text='', opts=(), **kwargs): DCNL 'Returns your text, enclosed in ANSI graphics codes. DCNL Depends on the keyword arguments \'fg\' and \'bg\', and the contents of DCNL the opts tuple/list. DCNL Returns the RESET code if no parameters are given. DCNL Valid colors: DCNL \'black\', \'red\', \'green\', \'yellow\', \'blue\', \'magenta\', \'cyan\', \'white\' DCNL Valid options: DCNL \'bold\' DCNL \'underscore\' DCNL \'blink\' DCNL \'reverse\' DCNL \'conceal\' DCNL \'noreset\' - string will not be auto-terminated with the RESET code DCNL Examples: DCNL colorize(\'hello\', fg=\'red\', bg=\'blue\', opts=(\'blink\',)) DCNL colorize() DCNL colorize(\'goodbye\', opts=(\'underscore\',)) DCNL print(colorize(\'first line\', fg=\'red\', opts=(\'noreset\',))) DCNL print(\'this should be red too\') DCNL print(colorize(\'and so should this\')) DCNL print(\'this should not be red\')'
def make_style(opts=(), **kwargs): DCNL 'Returns a function with default parameters for colorize() DCNL Example: DCNL bold_red = make_style(opts=(\'bold\',), fg=\'red\') DCNL print(bold_red(\'hello\')) DCNL KEYWORD = make_style(fg=\'yellow\') DCNL COMMENT = make_style(fg=\'blue\', opts=(\'bold\',))'
def parse_color_setting(config_string): DCNL 'Parse a DJANGO_COLORS environment variable to produce the system palette DCNL The general form of a pallete definition is: DCNL "palette;role=fg;role=fg/bg;role=fg,option,option;role=fg/bg,option,option" DCNL where: DCNL palette is a named palette; one of \'light\', \'dark\', or \'nocolor\'. DCNL role is a named style used by Django DCNL fg is a background color. DCNL bg is a background color. DCNL option is a display options. DCNL Specifying a named palette is the same as manually specifying the individual DCNL definitions for each role. Any individual definitions following the pallete DCNL definition will augment the base palette definition. DCNL Valid roles: DCNL \'error\', \'notice\', \'sql_field\', \'sql_coltype\', \'sql_keyword\', \'sql_table\', DCNL \'http_info\', \'http_success\', \'http_redirect\', \'http_bad_request\', DCNL \'http_not_found\', \'http_server_error\' DCNL Valid colors: DCNL \'black\', \'red\', \'green\', \'yellow\', \'blue\', \'magenta\', \'cyan\', \'white\' DCNL Valid options: DCNL \'bold\', \'underscore\', \'blink\', \'reverse\', \'conceal\''
def timesince(d, now=None, reversed=False): DCNL 'Takes two datetime objects and returns the time between d and now DCNL as a nicely formatted string, e.g. "10 minutes".  If d occurs after now, DCNL then "0 minutes" is returned. DCNL Units used are years, months, weeks, days, hours, and minutes. DCNL Seconds and microseconds are ignored.  Up to two adjacent units will be DCNL displayed.  For example, "2 weeks, 3 days" and "1 year, 3 months" are DCNL possible outputs, but "2 weeks, 3 hours" and "1 year, 5 days" are not. DCNL Adapted from http://blog.natbat.co.uk/archive/2003/Jun/14/time_since'
def timeuntil(d, now=None): DCNL 'Like timesince, but returns a string measuring the time until DCNL the given time.'
def get_default_timezone(): DCNL 'Returns the default time zone as a tzinfo instance. DCNL This is the time zone defined by settings.TIME_ZONE. DCNL See also :func:`get_current_timezone`.'
def get_default_timezone_name(): DCNL 'Returns the name of the default time zone.'
def get_current_timezone(): DCNL 'Returns the currently active time zone as a tzinfo instance.'
def get_current_timezone_name(): DCNL 'Returns the name of the currently active time zone.'
def _get_timezone_name(timezone): DCNL 'Returns the name of ``timezone``.'
def activate(timezone): DCNL 'Sets the time zone for the current thread. DCNL The ``timezone`` argument must be an instance of a tzinfo subclass or a DCNL time zone name. If it is a time zone name, pytz is required.'
def deactivate(): DCNL 'Unsets the time zone for the current thread. DCNL Django will then use the time zone defined by settings.TIME_ZONE.'
def template_localtime(value, use_tz=None): DCNL 'Checks if value is a datetime and converts it to local time if necessary. DCNL If use_tz is provided and is not None, that will force the value to DCNL be converted (or not), overriding the value of settings.USE_TZ. DCNL This function is designed for use by the template engine.'
def localtime(value, timezone=None): DCNL 'Converts an aware datetime.datetime to local time. DCNL Local time is defined by the current time zone, unless another time zone DCNL is specified.'
def now(): DCNL 'Returns an aware or naive datetime.datetime, depending on settings.USE_TZ.'
def is_aware(value): DCNL 'Determines if a given datetime.datetime is aware. DCNL The logic is described in Python\'s docs: DCNL http://docs.python.org/library/datetime.html#datetime.tzinfo'
def is_naive(value): DCNL 'Determines if a given datetime.datetime is naive. DCNL The logic is described in Python\'s docs: DCNL http://docs.python.org/library/datetime.html#datetime.tzinfo'
def make_aware(value, timezone): DCNL 'Makes a naive datetime.datetime in a given time zone aware.'
def make_naive(value, timezone): DCNL 'Makes an aware datetime.datetime naive in a given time zone.'
def upath(path): DCNL 'Always return a unicode path.'
def npath(path): DCNL 'Always return a native path, that is unicode on Python 3 and bytestring on DCNL Python 2.'
def safe_join(base, *paths): DCNL 'Joins one or more path components to the base path component intelligently. DCNL Returns a normalized, absolute version of the final path. DCNL The final path must be located inside of the base path component (otherwise DCNL a ValueError is raised).'
def rmtree_errorhandler(func, path, exc_info): DCNL 'On Windows, some files are read-only (e.g. in in .svn dirs), so when DCNL rmtree() tries to remove them, an exception is thrown. DCNL We catch that here, remove the read-only attribute, and hopefully DCNL continue without problems.'
def wrap(text, width): DCNL 'A word-wrap function that preserves existing line breaks and most spaces in DCNL the text. Expects that existing line breaks are posix newlines.'
def get_valid_filename(s): DCNL 'Returns the given string converted to a string that can be used for a clean DCNL filename. Specifically, leading and trailing spaces are removed; other DCNL spaces are converted to underscores; and anything that is not a unicode DCNL alphanumeric, dash, underscore, or dot, is removed. DCNL >>> get_valid_filename("john\'s portrait in 2004.jpg") DCNL \'johns_portrait_in_2004.jpg\''
def get_text_list(list_, last_word=ugettext_lazy(u'or')): DCNL '>>> get_text_list([\'a\', \'b\', \'c\', \'d\']) DCNL \'a, b, c or d\' DCNL >>> get_text_list([\'a\', \'b\', \'c\'], \'and\') DCNL \'a, b and c\' DCNL >>> get_text_list([\'a\', \'b\'], \'and\') DCNL \'a and b\' DCNL >>> get_text_list([\'a\']) DCNL \'a\' DCNL >>> get_text_list([])'
def recapitalize(text): DCNL 'Recapitalizes text, placing caps after end-of-sentence punctuation.'
def phone2numeric(phone): DCNL 'Converts a phone number with letters into its numeric equivalent.'
def smart_split(text): DCNL 'Generator that splits a string by spaces, leaving quoted phrases together. DCNL Supports both single and double quotes, and supports escaping quotes with DCNL backslashes. In the output, strings will keep their initial and trailing DCNL quote marks and escaped quotes will remain escaped (the results can then DCNL be further processed with unescape_string_literal()). DCNL >>> list(smart_split(r\'This is "a person\\'s" test.\')) DCNL [\'This\', \'is\', \'"a person\\\\'s"\', \'test.\'] DCNL >>> list(smart_split(r"Another \'person\\'s\' test.")) DCNL [\'Another\', "\'person\\\'s\'", \'test.\'] DCNL >>> list(smart_split(r\'A "\"funky\" style" test.\')) DCNL [\'A\', \'"\\"funky\\" style"\', \'test.\']'
def unescape_string_literal(s): DCNL 'Convert quoted string literals to unquoted strings with escaped quotes and DCNL backslashes unquoted:: DCNL >>> unescape_string_literal(\'"abc"\') DCNL \'abc\' DCNL >>> unescape_string_literal("\'abc\'") DCNL \'abc\' DCNL >>> unescape_string_literal(\'"a \"bc\""\') DCNL \'a "bc"\' DCNL >>> unescape_string_literal("\'\\'ab\\' c\'") DCNL "\'ab\' c"'
def slugify(value): DCNL 'Converts to lowercase, removes non-word characters (alphanumerics and DCNL underscores) and converts spaces to hyphens. Also strips leading and DCNL trailing whitespace.'
def python_2_unicode_compatible(klass): DCNL 'A decorator that defines __unicode__ and __str__ methods under Python 2. DCNL Under Python 3 it does nothing. DCNL To support Python 2 and 3 with a single code base, define a __str__ method DCNL returning text and apply this decorator to the class.'
def smart_text(s, encoding=u'utf-8', strings_only=False, errors=u'strict'): DCNL 'Returns a text object representing \'s\' -- unicode on Python 2 and str on DCNL Python 3. Treats bytestrings using the \'encoding\' codec. DCNL If strings_only is True, don\'t convert (some) non-string-like objects.'
def is_protected_type(obj): DCNL 'Determine if the object instance is of a protected type. DCNL Objects of protected types are preserved as-is when passed to DCNL force_text(strings_only=True).'
def force_text(s, encoding=u'utf-8', strings_only=False, errors=u'strict'): DCNL 'Similar to smart_text, except that lazy instances are resolved to DCNL strings, rather than kept as lazy objects. DCNL If strings_only is True, don\'t convert (some) non-string-like objects.'
def smart_bytes(s, encoding=u'utf-8', strings_only=False, errors=u'strict'): DCNL 'Returns a bytestring version of \'s\', encoded as specified in \'encoding\'. DCNL If strings_only is True, don\'t convert (some) non-string-like objects.'
def force_bytes(s, encoding=u'utf-8', strings_only=False, errors=u'strict'): DCNL 'Similar to smart_bytes, except that lazy instances are resolved to DCNL strings, rather than kept as lazy objects. DCNL If strings_only is True, don\'t convert (some) non-string-like objects.'
def iri_to_uri(iri): DCNL 'Convert an Internationalized Resource Identifier (IRI) portion to a URI DCNL portion that is suitable for inclusion in a URL. DCNL This is the algorithm from section 3.1 of RFC 3987.  However, since we are DCNL assuming input is either UTF-8 or unicode already, we can simplify things a DCNL little from the full method. DCNL Returns an ASCII string containing the encoded result.'
def filepath_to_uri(path): DCNL 'Convert a file system path to a URI portion that is suitable for DCNL inclusion in a URL. DCNL We are assuming input is either UTF-8 or unicode already. DCNL This method will encode certain chars that would normally be recognized as DCNL special chars for URIs.  Note that this method does not encode the \' DCNL character, as it is a valid character within URIs.  See DCNL encodeURIComponent() JavaScript function for more details. DCNL Returns an ASCII string containing the encoded result.'
def module_has_submodule(package, module_name): DCNL 'See if \'module\' is in \'package\'.'
def patch_cache_control(response, **kwargs): DCNL 'This function patches the Cache-Control header by adding all DCNL keyword arguments to it. The transformation is as follows: DCNL * All keyword parameter names are turned to lowercase, and underscores DCNL are converted to hyphens. DCNL * If the value of a parameter is True (exactly True, not just a DCNL true value), only the parameter name is added to the header. DCNL * All other parameters are added with their value, after applying DCNL str() to it.'
def get_max_age(response): DCNL 'Returns the max-age from the response Cache-Control header as an integer DCNL (or ``None`` if it wasn\'t found or wasn\'t an integer.'
def patch_response_headers(response, cache_timeout=None): DCNL 'Adds some useful headers to the given HttpResponse object: DCNL ETag, Last-Modified, Expires and Cache-Control DCNL Each header is only added if it isn\'t already set. DCNL cache_timeout is in seconds. The CACHE_MIDDLEWARE_SECONDS setting is used DCNL by default.'
def add_never_cache_headers(response): DCNL 'Adds headers to a response to indicate that a page should never be cached.'
def patch_vary_headers(response, newheaders): DCNL 'Adds (or updates) the "Vary" header in the given HttpResponse object. DCNL newheaders is a list of header names that should be in "Vary". Existing DCNL headers in "Vary" aren\'t removed.'
def has_vary_header(response, header_query): DCNL 'Checks to see if the response has a given header name in its Vary header.'
def _i18n_cache_key_suffix(request, cache_key): DCNL 'If necessary, adds the current locale or time zone to the cache key.'
def _generate_cache_key(request, method, headerlist, key_prefix): DCNL 'Returns a cache key from the headers given in the header list.'
def _generate_cache_header_key(key_prefix, request): DCNL 'Returns a cache key for the header cache.'
def get_cache_key(request, key_prefix=None, method=u'GET', cache=None): DCNL 'Returns a cache key based on the request path and query. It can be used DCNL in the request phase because it pulls the list of headers to take into DCNL account from the global path registry and uses those to build a cache key DCNL to check against. DCNL If there is no headerlist stored, the page needs to be rebuilt, so this DCNL function returns None.'
def learn_cache_key(request, response, cache_timeout=None, key_prefix=None, cache=None): DCNL 'Learns what headers to take into account for some request path from the DCNL response object. It stores those headers in a global path registry so that DCNL later access to that path will know what headers to take into account DCNL without building the response object itself. The headers are named in the DCNL Vary header of the response, but we want to prevent response generation. DCNL The list of headers to use for cache key generation is stored in the same DCNL cache as the pages themselves. If the cache ages some data out of the DCNL cache, this just means that we have to build the response once to get at DCNL the Vary header and so at the list of headers to use for the cache key.'
def clean_ipv6_address(ip_str, unpack_ipv4=False, error_message='This DCSP is DCSP not DCSP a DCSP valid DCSP IPv6 DCSP address'): DCNL 'Cleans a IPv6 address string. DCNL Validity is checked by calling is_valid_ipv6_address() - if an DCNL invalid address is passed, ValidationError is raised. DCNL Replaces the longest continious zero-sequence with "::" and DCNL removes leading zeroes and makes sure all hextets are lowercase. DCNL Args: DCNL ip_str: A valid IPv6 address. DCNL unpack_ipv4: if an IPv4-mapped address is found, DCNL return the plain IPv4 address (default=False). DCNL error_message: A error message for in the ValidationError. DCNL Returns: DCNL A compressed IPv6 address, or the same value'
def _sanitize_ipv4_mapping(ip_str): DCNL 'Sanitize IPv4 mapping in a expanded IPv6 address. DCNL This converts ::ffff:0a0a:0a0a to ::ffff:10.10.10.10. DCNL If there is nothing to sanitize, returns an unchanged DCNL string. DCNL Args: DCNL ip_str: A string, the expanded IPv6 address. DCNL Returns: DCNL The sanitized output string, if applicable.'
def _unpack_ipv4(ip_str): DCNL 'Unpack an IPv4 address that was mapped in a compressed IPv6 address. DCNL This converts 0000:0000:0000:0000:0000:ffff:10.10.10.10 to 10.10.10.10. DCNL If there is nothing to sanitize, returns None. DCNL Args: DCNL ip_str: A string, the expanded IPv6 address. DCNL Returns: DCNL The unpacked IPv4 address, or None if there was nothing to unpack.'
def is_valid_ipv6_address(ip_str): DCNL 'Ensure we have a valid IPv6 address. DCNL Args: DCNL ip_str: A string, the IPv6 address. DCNL Returns: DCNL A boolean, True if this is a valid IPv6 address.'
def _explode_shorthand_ip_string(ip_str): DCNL 'Expand a shortened IPv6 address. DCNL Args: DCNL ip_str: A string, the IPv6 address. DCNL Returns: DCNL A string, the expanded IPv6 address.'
def _is_shorthand_ip(ip_str): DCNL 'Determine if the address is shortened. DCNL Args: DCNL ip_str: A string, the IPv6 address. DCNL Returns: DCNL A boolean, True if the address is shortened.'
def reset_format_cache(): DCNL 'Clear any cached formats. DCNL This method is provided primarily for testing purposes, DCNL so that the effects of cached formats can be removed.'
def iter_format_modules(lang): DCNL 'Does the heavy lifting of finding format modules.'
def get_format_modules(lang=None, reverse=False): DCNL 'Returns a list of the format modules found'
def get_format(format_type, lang=None, use_l10n=None): DCNL 'For a specific format type, returns the format for the current DCNL language (locale), defaults to the format in the settings. DCNL format_type is the name of the format, e.g. \'DATE_FORMAT\' DCNL If use_l10n is provided and is not None, that will force the value to DCNL be localized (or not), overriding the value of settings.USE_L10N.'
def date_format(value, format=None, use_l10n=None): DCNL 'Formats a datetime.date or datetime.datetime object using a DCNL localizable format DCNL If use_l10n is provided and is not None, that will force the value to DCNL be localized (or not), overriding the value of settings.USE_L10N.'
def time_format(value, format=None, use_l10n=None): DCNL 'Formats a datetime.time object using a localizable format DCNL If use_l10n is provided and is not None, that will force the value to DCNL be localized (or not), overriding the value of settings.USE_L10N.'
def number_format(value, decimal_pos=None, use_l10n=None, force_grouping=False): DCNL 'Formats a numeric value using localization settings DCNL If use_l10n is provided and is not None, that will force the value to DCNL be localized (or not), overriding the value of settings.USE_L10N.'
def localize(value, use_l10n=None): DCNL 'Checks if value is a localizable type (date, number...) and returns it DCNL formatted as a string using current locale format. DCNL If use_l10n is provided and is not None, that will force the value to DCNL be localized (or not), overriding the value of settings.USE_L10N.'
def localize_input(value, default=None): DCNL 'Checks if an input value is a localizable type and returns it DCNL formatted with the appropriate formatting string of the current locale.'
def sanitize_separators(value): DCNL 'Sanitizes a value according to the current decimal and DCNL thousand separator setting. Used with form field input.'
def salted_hmac(key_salt, value, secret=None): DCNL 'Returns the HMAC-SHA1 of \'value\', using a key generated from key_salt and a DCNL secret (which defaults to settings.SECRET_KEY). DCNL A different key_salt should be passed in for every application of HMAC.'
def get_random_string(length=12, allowed_chars=u'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'): DCNL 'Returns a securely generated random string. DCNL The default length of 12 with the a-z, A-Z, 0-9 character set returns DCNL a 71-bit value. log_2((26+26+10)^12) =~ 71 bits'
def constant_time_compare(val1, val2): DCNL 'Returns True if the two strings are equal, False otherwise. DCNL The time taken is independent of the number of characters that match.'
def _bin_to_long(x): DCNL 'Convert a binary string into a long integer DCNL This is a clever optimization for fast xor vector math'
def _long_to_bin(x, hex_format_string): DCNL 'Convert a long integer into a binary string. DCNL hex_format_string is like "%020x" for padding 10 characters.'
def _fast_hmac(key, msg, digest): DCNL 'A trimmed down version of Python\'s HMAC implementation. DCNL This function operates on bytes.'
def pbkdf2(password, salt, iterations, dklen=0, digest=None): DCNL 'Implements PBKDF2 as defined in RFC 2898, section 5.2 DCNL HMAC+SHA256 is used as the default pseudo random function. DCNL Right now 10,000 iterations is the recommended default which takes DCNL 100ms on a 2.2Ghz Core 2 Duo.  This is probably the bare minimum DCNL for security given 1000 iterations was recommended in 2001. This DCNL code is very well optimized for CPython and is only four times DCNL slower than openssl\'s implementation.'
def luhn(candidate): DCNL 'Checks a candidate number for validity according to the Luhn DCNL algorithm (used in validation of, for example, credit cards). DCNL Both numeric and string candidates are accepted.'
def _resolve_name(name, package, level): DCNL 'Return the absolute name of the module to be imported.'
def import_module(name, package=None): DCNL 'Import a module. DCNL The \'package\' argument is required when performing a relative import. It DCNL specifies the package to use as the anchor point from which to resolve the DCNL relative import to an absolute import.'
def escape(text): DCNL 'Returns the given text with ampersands, quotes and angle brackets encoded for use in HTML.'
def escapejs(value): DCNL 'Hex encodes characters for use in JavaScript strings.'
def conditional_escape(text): DCNL 'Similar to escape(), except that it doesn\'t operate on pre-escaped strings.'
def format_html(format_string, *args, **kwargs): DCNL 'Similar to str.format, but passes all arguments through conditional_escape, DCNL and calls \'mark_safe\' on the result. This function should be used instead DCNL of str.format or % interpolation to build up small HTML fragments.'
def format_html_join(sep, format_string, args_generator): DCNL 'A wrapper of format_html, for the common case of a group of arguments that DCNL need to be formatted using the same format string, and then joined using DCNL \'sep\'. \'sep\' is also passed through conditional_escape. DCNL \'args_generator\' should be an iterator that returns the sequence of \'args\' DCNL that will be passed to format_html. DCNL Example: DCNL format_html_join(\' DCNL \', "<li>{0} {1}</li>", ((u.first_name, u.last_name) DCNL for u in users))'
def linebreaks(value, autoescape=False): DCNL 'Converts newlines into <p> and <br />s.'
def strip_tags(value): DCNL 'Returns the given HTML with all tags stripped.'
def remove_tags(html, tags): DCNL 'Returns the given HTML with given tags removed.'
def strip_spaces_between_tags(value): DCNL 'Returns the given HTML with spaces between tags removed.'
def strip_entities(value): DCNL 'Returns the given HTML with all entities (&something;) stripped.'
def fix_ampersands(value): DCNL 'Returns the given HTML with all unencoded ampersands encoded correctly.'
def smart_urlquote(url): DCNL 'Quotes a URL if it isn\'t already quoted.'
def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False): DCNL 'Converts any URLs in text into clickable links. DCNL Works on http://, https://, www. links, and also on links ending in one of DCNL the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org). DCNL Links can have trailing punctuation (periods, commas, close-parens) and DCNL leading punctuation (opening parens) and it\'ll still do the right thing. DCNL If trim_url_limit is not None, the URLs in link text longer than this limit DCNL will truncated to trim_url_limit-3 characters and appended with an elipsis. DCNL If nofollow is True, the URLs in link text will get a rel="nofollow" DCNL attribute. DCNL If autoescape is True, the link text and URLs will get autoescaped.'
def clean_html(text): DCNL 'Clean the given HTML.  Specifically, do the following: DCNL * Convert <b> and <i> to <strong> and <em>. DCNL * Encode all ampersands correctly. DCNL * Remove all "target" attributes from <a> tags. DCNL * Remove extraneous HTML, such as presentational tags that open and DCNL immediately close and <br clear="all">. DCNL * Convert hard-coded bullets into HTML unordered lists. DCNL * Remove stuff like "<p>&nbsp;&nbsp;</p>", but only if it\'s at the DCNL bottom of the text.'
def _CmpToKey(mycmp): DCNL 'Convert a cmp= function into a key= function'
def _relpath_nt(path, start=os.path.curdir): DCNL 'Return a relative version of a path'
def _relpath_posix(path, start=os.path.curdir): DCNL 'Return a relative version of a path'
def skip(reason): DCNL 'Unconditionally skip a test.'
def skipIf(condition, reason): DCNL 'Skip a test if the condition is true.'
def skipUnless(condition, reason): DCNL 'Skip a test unless the condition is true.'
def _isnotsuite(test): DCNL 'A crude way to tell apart testcases and suites with duck-typing'
def sorted_list_difference(expected, actual): DCNL 'Finds elements in only one or the other of two, sorted input lists. DCNL Returns a two-element tuple of lists.    The first list contains those DCNL elements in the "expected" list but not in the "actual" list, and the DCNL second contains those elements in the "actual" list but not in the DCNL "expected" list.    Duplicate elements in either input list are ignored.'
def unorderable_list_difference(expected, actual, ignore_duplicate=False): DCNL 'Same behavior as sorted_list_difference but DCNL for lists of unorderable items (like dicts). DCNL As it does a linear search per item (remove) it DCNL has O(n*n) performance.'
def parse_date(value): DCNL 'Parses a string and return a datetime.date. DCNL Raises ValueError if the input is well formatted but not a valid date. DCNL Returns None if the input isn\'t well formatted.'
def parse_time(value): DCNL 'Parses a string and return a datetime.time. DCNL This function doesn\'t support time zone offsets. DCNL Raises ValueError if the input is well formatted but not a valid time. DCNL Returns None if the input isn\'t well formatted, in particular if it DCNL contains an offset.'
def parse_datetime(value): DCNL 'Parses a string and return a datetime.datetime. DCNL This function supports time zone offsets. When the input contains one, DCNL the output uses an instance of FixedOffset as tzinfo. DCNL Raises ValueError if the input is well formatted but not a valid datetime. DCNL Returns None if the input isn\'t well formatted.'
def extract(path, to_path=''): DCNL 'Unpack the tar or zip file at the specified path to the directory DCNL specified by to_path.'
def format(number, decimal_sep, decimal_pos=None, grouping=0, thousand_sep='', force_grouping=False): DCNL 'Gets a number (as a number or string), and returns it as a string, DCNL using formats defined as arguments: DCNL * decimal_sep: Decimal separator symbol (for example ".") DCNL * decimal_pos: Number of decimal positions DCNL * grouping: Number of digits in every group limited by thousand separator DCNL * thousand_sep: Thousand separator symbol (for example ",")'
def get_version(version=None): DCNL 'Returns a PEP 386-compliant version number from VERSION.'
def get_git_changeset(): DCNL 'Returns a numeric identifier of the latest git changeset. DCNL The result is the UTC timestamp of the changeset in YYYYMMDDHHMMSS format. DCNL This value isn\'t guaranteed to be unique, but collisions are very unlikely, DCNL so it\'s sufficient for generating the development version numbers.'
def to_locale(language, to_lower=False): DCNL 'Turns a language name (en-us) into a locale name (en_US). If \'to_lower\' is DCNL True, the last component is lower-cased (en_us).'
def to_language(locale): DCNL 'Turns a locale name (en_US) into a language name (en-us).'
def translation(language): DCNL 'Returns a translation object. DCNL This translation object will be constructed out of multiple GNUTranslations DCNL objects by merging their catalogs. It will construct a object for the DCNL requested language and add a fallback to the default language, if it\'s DCNL different from the requested language.'
def activate(language): DCNL 'Fetches the translation object for a given tuple of application name and DCNL language and installs it as the current translation object for the current DCNL thread.'
def deactivate(): DCNL 'Deinstalls the currently active translation object so that further _ calls DCNL will resolve against the default translation object, again.'
def deactivate_all(): DCNL 'Makes the active translation object a NullTranslations() instance. This is DCNL useful when we want delayed translations to appear as the original string DCNL for some reason.'
def get_language(): DCNL 'Returns the currently selected language.'
def get_language_bidi(): DCNL 'Returns selected language\'s BiDi layout. DCNL * False = left-to-right layout DCNL * True = right-to-left layout'
def catalog(): DCNL 'Returns the current active catalog for further processing. DCNL This can be used if you need to modify the catalog or want to access the DCNL whole message catalog instead of just translating one string.'
def do_translate(message, translation_function): DCNL 'Translates \'message\' using the given \'translation_function\' name -- which DCNL will be either gettext or ugettext. It uses the current thread to find the DCNL translation object to use. If no current translation is activated, the DCNL message will be run through the default translation object.'
def gettext(message): DCNL 'Returns a string of the translation of the message. DCNL Returns a string on Python 3 and an UTF-8-encoded bytestring on Python 2.'
def gettext_noop(message): DCNL 'Marks strings for translation but doesn\'t translate them now. This can be DCNL used to store strings in global variables that should stay in the base DCNL language (because they might be used externally) and will be translated DCNL later.'
def ngettext(singular, plural, number): DCNL 'Returns a string of the translation of either the singular or plural, DCNL based on the number. DCNL Returns a string on Python 3 and an UTF-8-encoded bytestring on Python 2.'
def all_locale_paths(): DCNL 'Returns a list of paths to user-provides languages files.'
def check_for_language(lang_code): DCNL 'Checks whether there is a global language file for the given language DCNL code. This is used to decide whether a user-provided language is DCNL available. This is only used for language codes from either the cookies DCNL or session and during format localization.'
def get_language_from_path(path, supported=None): DCNL 'Returns the language-code if there is a valid language-code DCNL found in the `path`.'
def get_language_from_request(request, check_path=False): DCNL 'Analyzes the request to find what language the user wants the system to DCNL show. Only languages listed in settings.LANGUAGES are taken into account. DCNL If the user requests a sublanguage where we have a main language, we send DCNL out the main language. DCNL If check_path is True, the URL path prefix will be checked for a language DCNL code, otherwise this is skipped for backwards compatibility.'
def blankout(src, char): DCNL 'Changes every non-whitespace character to the given char. DCNL Used in the templatize function.'
def templatize(src, origin=None): DCNL 'Turns a Django template into something that is understood by xgettext. It DCNL does so by translating the Django translation tags into standard gettext DCNL function invocations.'
def parse_accept_lang_header(lang_string): DCNL 'Parses the lang_string, which is the body of an HTTP Accept-Language DCNL header, and returns a list of (lang, q-value), ordered by \'q\' values. DCNL Any format errors in lang_string results in an empty list being returned.'
def _string_concat(*strings): DCNL 'Lazy variant of string concatenation, needed for translations that are DCNL constructed from multiple parts.'
def memoize(func, cache, num_args): DCNL 'Wrap a function so that results for any argument tuple are stored in DCNL \'cache\'. Note that the args to the function must be usable as dictionary DCNL keys. DCNL Only the first num_args are considered when creating the key.'
def lazy(func, *resultclasses): DCNL 'Turns any callable into a lazy evaluated callable. You need to give result DCNL classes or types -- at least one is needed so that the automatic forcing of DCNL the lazy evaluation code is triggered. Results are not memoized; the DCNL function is evaluated on every access.'
def allow_lazy(func, *resultclasses): DCNL 'A decorator that allows a function to be called with one or more lazy DCNL arguments. If none of the args are lazy, the function is evaluated DCNL immediately, otherwise a __proxy__ is returned that will evaluate the DCNL function when needed.'
def partition(predicate, values): DCNL 'Splits the values into two sets, based on the return value of the function DCNL (True/False). e.g.: DCNL >>> partition(lambda x: x > 3, range(5)) DCNL [0, 1, 2, 3], [4]'
def literals(choices, prefix='', suffix=''): DCNL 'Create a regex from a space-separated list of literal `choices`. DCNL If provided, `prefix` and `suffix` will be attached to each choice DCNL individually.'
def prepare_js_for_gettext(js): DCNL 'Convert the Javascript source `js` into something resembling C for DCNL xgettext. DCNL What actually happens is that all the regex literals are replaced with DCNL "REGEX".'
def _add_doc(func, doc): DCNL 'Add documentation to a function.'
def _import_module(name): DCNL 'Import module, returning the module after the last dot.'
def add_move(move): DCNL 'Add an item to six.moves.'
def remove_move(name): DCNL 'Remove item from six.moves.'
def iterkeys(d, **kw): DCNL 'Return an iterator over the keys of a dictionary.'
def itervalues(d, **kw): DCNL 'Return an iterator over the values of a dictionary.'
def iteritems(d, **kw): DCNL 'Return an iterator over the (key, value) pairs of a dictionary.'
def iterlists(d, **kw): DCNL 'Return an iterator over the (key, [values]) pairs of a dictionary.'
def with_metaclass(meta, base=object): DCNL 'Create a base class with a metaclass.'
def format(value, format_string): DCNL 'Convenience function'
def time_format(value, format_string): DCNL 'Convenience function'
def method_decorator(decorator): DCNL 'Converts a function decorator into a method decorator'
def decorator_from_middleware_with_args(middleware_class): DCNL 'Like decorator_from_middleware, but returns a function DCNL that accepts the arguments to be passed to the middleware_class. DCNL Use like:: DCNL cache_page = decorator_from_middleware_with_args(CacheMiddleware) DCNL @cache_page(3600) DCNL def my_view(request):'
def decorator_from_middleware(middleware_class): DCNL 'Given a middleware class (not an instance), returns a view decorator. This DCNL lets you use middleware functionality on a per-view basis. The middleware DCNL is created with no params passed.'
def available_attrs(fn): DCNL 'Return the list of functools-wrappable attributes on a callable. DCNL This is required as a workaround for http://bugs.python.org/issue3445.'
def mark_safe(s): DCNL 'Explicitly mark a string as safe for (HTML) output purposes. The returned DCNL object can be used everywhere a string or unicode object is appropriate. DCNL Can be called multiple times on a single string.'
def mark_for_escaping(s): DCNL 'Explicitly mark a string as requiring HTML escaping upon output. Has no DCNL effect on SafeData subclasses. DCNL Can be called multiple times on a single string (the resulting escaping is DCNL only applied once).'
def new_date(d): DCNL 'Generate a safe date from a datetime.date object.'
def new_datetime(d): DCNL 'Generate a safe datetime from a datetime.date or datetime.datetime object.'
def get_tag_uri(url, date): DCNL 'Creates a TagURI. DCNL See http://web.archive.org/web/20110514113830/http://diveintomark.org/archives/2004/05/28/howto-atom-id'
def abort(using=None): DCNL 'Roll back any ongoing transactions and clean the transaction management DCNL state of the connection. DCNL This method is to be used only in cases where using balanced DCNL leave_transaction_management() calls isn\'t possible. For example after a DCNL request has finished, the transaction state isn\'t known, yet the connection DCNL must be cleaned up for the next request.'
def enter_transaction_management(managed=True, using=None): DCNL 'Enters transaction management for a running thread. It must be balanced with DCNL the appropriate leave_transaction_management call, since the actual state is DCNL managed as a stack. DCNL The state and dirty flag are carried over from the surrounding block or DCNL from the settings, if there is no surrounding block (dirty is always false DCNL when no current block is running).'
def leave_transaction_management(using=None): DCNL 'Leaves transaction management for a running thread. A dirty flag is carried DCNL over to the surrounding block, as a commit will commit all changes, even DCNL those from outside. (Commits are on connection level.)'
def is_dirty(using=None): DCNL 'Returns True if the current transaction requires a commit for changes to DCNL happen.'
def set_dirty(using=None): DCNL 'Sets a dirty flag for the current thread and code streak. This can be used DCNL to decide in a managed block of code to decide whether there are open DCNL changes waiting for commit.'
def set_clean(using=None): DCNL 'Resets a dirty flag for the current thread and code streak. This can be used DCNL to decide in a managed block of code to decide whether a commit or rollback DCNL should happen.'
def is_managed(using=None): DCNL 'Checks whether the transaction manager is in manual or in auto state.'
def managed(flag=True, using=None): DCNL 'Puts the transaction manager into a manual state: managed transactions have DCNL to be committed explicitly by the user. If you switch off transaction DCNL management and there is a pending commit/rollback, the data will be DCNL commited.'
def commit_unless_managed(using=None): DCNL 'Commits changes if the system is not in managed transaction mode.'
def rollback_unless_managed(using=None): DCNL 'Rolls back changes if the system is not in managed transaction mode.'
def commit(using=None): DCNL 'Does the commit itself and resets the dirty flag.'
def rollback(using=None): DCNL 'This function does the rollback itself and resets the dirty flag.'
def savepoint(using=None): DCNL 'Creates a savepoint (if supported and required by the backend) inside the DCNL current transaction. Returns an identifier for the savepoint that will be DCNL used for the subsequent rollback or commit.'
def savepoint_rollback(sid, using=None): DCNL 'Rolls back the most recent savepoint (if one exists). Does nothing if DCNL savepoints are not supported.'
def savepoint_commit(sid, using=None): DCNL 'Commits the most recent savepoint (if one exists). Does nothing if DCNL savepoints are not supported.'
def _transaction_func(entering, exiting, using): DCNL 'Takes 3 things, an entering function (what to do to start this block of DCNL transaction management), an exiting function (what to do to end it, on both DCNL success and failure, and using which can be: None, indiciating using is DCNL DEFAULT_DB_ALIAS, a callable, indicating that using is DEFAULT_DB_ALIAS and DCNL to return the function already wrapped. DCNL Returns either a Transaction objects, which is both a decorator and a DCNL context manager, or a wrapped function, if using is a callable.'
def autocommit(using=None): DCNL 'Decorator that activates commit on save. This is Django\'s default behavior; DCNL this decorator is useful if you globally activated transaction management in DCNL your settings file and want the default behavior in some view functions.'
def commit_on_success(using=None): DCNL 'This decorator activates commit on response. This way, if the view function DCNL runs successfully, a commit is made; if the viewfunc produces an exception, DCNL a rollback is made. This is one of the most common ways to do transaction DCNL control in Web apps.'
def commit_manually(using=None): DCNL 'Decorator that activates manual transaction control. It just disables DCNL automatic transaction control and doesn\'t do any commit/rollback of its DCNL own -- it\'s up to the user to call the commit and rollback functions DCNL themselves.'
def get_order_dir(field, default='ASC'): DCNL 'Returns the field name and direction for an order specification. For DCNL example, \'-foo\' is returned as (\'foo\', \'DESC\'). DCNL The \'default\' param is used to indicate which way no prefix (or a \'+\' DCNL prefix) should sort. The \'-\' prefix always sorts the opposite way.'
def setup_join_cache(sender, **kwargs): DCNL 'The information needed to join between model fields is something that is DCNL invariant over the life of the model, so we cache it in the model\'s Options DCNL class, rather than recomputing it all the time. DCNL This method initialises the (empty) cache when the model is created.'
def add_to_dict(data, key, value): DCNL 'A helper function to add "value" to the set of values for "key", whether or DCNL not "key" already exists.'
def is_reverse_o2o(field): DCNL 'A little helper to check if the given field is reverse-o2o. The field is DCNL expected to be some sort of relation field or related object.'
def order_modified_iter(cursor, trim, sentinel): DCNL 'Yields blocks of rows from a cursor. We use this iterator in the special DCNL case when extra output columns have been added to support ordering DCNL requirements. We must trim those extra columns before anything else can use DCNL the results, since they\'re only needed to make the SQL valid.'
def make_contrib(superclass, func=None): DCNL 'Returns a suitable contribute_to_class() method for the Field subclass. DCNL If \'func\' is passed in, it is the existing contribute_to_class() method on DCNL the subclass and it is called before anything else. It is assumed in this DCNL case that the existing contribute_to_class() calls all the necessary DCNL superclass methods.'
def add_lazy_relation(cls, field, relation, operation): DCNL 'Adds a lookup on ``cls`` when a related field is defined using a string, DCNL i.e.:: DCNL class MyModel(Model): DCNL fk = ForeignKey("AnotherModel") DCNL This string can be: DCNL * RECURSIVE_RELATIONSHIP_CONSTANT (i.e. "self") to indicate a recursive DCNL relation. DCNL * The name of a model (i.e "AnotherModel") to indicate another model in DCNL the same app. DCNL * An app-label and model name (i.e. "someapp.AnotherModel") to indicate DCNL another model in a different app. DCNL If the other model hasn\'t yet been loaded -- almost a given if you\'re using DCNL lazy relationships -- then the relation won\'t be set up until the DCNL class_prepared signal fires at the end of model initialization. DCNL operation is the work that must be performed once the relation can be resolved.'
def do_pending_lookups(sender, **kwargs): DCNL 'Handle any pending relations to the sending model. Sent from class_prepared.'
def create_many_related_manager(superclass, rel): DCNL 'Creates a manager that subclasses \'superclass\' (which is a Manager) DCNL and adds behavior for many-to-many related objects.'
def ensure_default_manager(sender, **kwargs): DCNL 'Ensures that a Model subclass contains a default manager  and sets the DCNL _default_manager attribute on the class. Also sets up the _base_manager DCNL points to a plain Manager instance (which could be the same as DCNL _default_manager if it\'s not a subclass of Manager).'
def get_klass_info(klass, max_depth=0, cur_depth=0, requested=None, only_load=None, local_only=False): DCNL 'Helper function that recursively returns an information for a klass, to be DCNL used in get_cached_row.  It exists just to compute this information only DCNL once for entire queryset. Otherwise it would be computed for each row, which DCNL leads to poor perfomance on large querysets. DCNL Arguments: DCNL * klass - the class to retrieve (and instantiate) DCNL * max_depth - the maximum depth to which a select_related() DCNL relationship should be explored. DCNL * cur_depth - the current depth in the select_related() tree. DCNL Used in recursive calls to determin if we should dig deeper. DCNL * requested - A dictionary describing the select_related() tree DCNL that is to be retrieved. keys are field names; values are DCNL dictionaries describing the keys on that related object that DCNL are themselves to be select_related(). DCNL * only_load - if the query has had only() or defer() applied, DCNL this is the list of field names that will be returned. If None, DCNL the full field list for `klass` can be assumed. DCNL * local_only - Only populate local fields. This is used when DCNL following reverse select-related relations'
def get_cached_row(row, index_start, using, klass_info, offset=0): DCNL 'Helper function that recursively returns an object with the specified DCNL related attributes already populated. DCNL This method may be called recursively to populate deep select_related() DCNL clauses. DCNL Arguments: DCNL * row - the row of data returned by the database cursor DCNL * index_start - the index of the row at which data for this DCNL object is known to start DCNL * offset - the number of additional fields that are known to DCNL exist in row for `klass`. This usually means the number of DCNL annotated results on `klass`. DCNL * using - the database alias on which the query is being executed. DCNL * klass_info - result of the get_klass_info function'
def insert_query(model, objs, fields, return_id=False, raw=False, using=None): DCNL 'Inserts a new record for the given model. This provides an interface to DCNL the InsertQuery class and is how Model.save() is implemented. It is not DCNL part of the public API.'
def prefetch_related_objects(result_cache, related_lookups): DCNL 'Helper function for prefetch_related functionality DCNL Populates prefetched objects caches for a list of results DCNL from a QuerySet'
def get_prefetcher(instance, attr): DCNL 'For the attribute \'attr\' on the given instance, finds DCNL an object that has a get_prefetch_query_set(). DCNL Returns a 4 tuple containing: DCNL (the object with get_prefetch_query_set (or None), DCNL the descriptor object representing this relationship (or None), DCNL a boolean that is False if the attribute was not found at all, DCNL a boolean that is True if the attribute has already been fetched)'
def prefetch_one_level(instances, prefetcher, attname): DCNL 'Helper function for prefetch_related_objects DCNL Runs prefetches on all instances using the prefetcher object, DCNL assigning results to relevant caches in instance. DCNL The prefetched objects are returned, along with any additional DCNL prefetches that must be done due to prefetch_related lookups DCNL found from default managers.'
def permalink(func): DCNL 'Decorator that calls urlresolvers.reverse() to return a URL using DCNL parameters returned by the decorated function "func". DCNL "func" should be a function that returns a tuple in one of the DCNL following formats: DCNL (viewname, viewargs) DCNL (viewname, viewargs, viewkwargs)'
def subclass_exception(name, parents, module, attached_to=None): DCNL 'Create exception subclass. Used by ModelBase below. DCNL If \'attached_to\' is supplied, the exception will be created in a way that DCNL allows it to be pickled, assuming the returned exception class will be added DCNL as an attribute to the \'attached_to\' class.'
def model_unpickle(model, attrs): DCNL 'Used to unpickle Model subclasses with deferred fields.'
def select_related_descend(field, restricted, requested, load_fields, reverse=False): DCNL 'Returns True if this field should be used to descend deeper for DCNL select_related() purposes. Used by both the query construction code DCNL (sql.query.fill_related_selections()) and the model instance creation code DCNL (query.get_klass_info()). DCNL Arguments: DCNL * field - the field to be checked DCNL * restricted - a boolean field, indicating if the field list has been DCNL manually restricted using a requested clause) DCNL * requested - The select_related() dictionary. DCNL * load_fields - the set of fields to be loaded on this model DCNL * reverse - boolean, True if we are checking a reverse select related'
def deferred_class_factory(model, attrs): DCNL 'Returns a class object that is a copy of "model" with the specified "attrs" DCNL being replaced with DeferredAttribute objects. The "pk_value" ties the DCNL deferred attributes to a particular instance of the model.'
def to_unicode(s): DCNL 'Convert strings to Unicode objects (and return all other data types DCNL unchanged).'
def get_field_size(name): DCNL 'Extract the size number from a "varchar(11)" type name'
def decoder(conv_func): DCNL 'The Python sqlite3 interface returns always byte strings. DCNL This function converts the received value to a regular string before DCNL passing it to the receiver function.'
def _parse_version(text): DCNL 'Internal parsing method. Factored out for testing purposes.'
def get_version(connection): DCNL 'Returns an integer representing the major, minor and revision number of the DCNL server. Format is the one used for the return value of libpq DCNL PQServerVersion()/``server_version`` connection attribute (available in DCNL newer psycopg2 versions.) DCNL For example, 80304 for 8.3.4. The last two digits will be 00 in the case of DCNL releases (e.g., 80400 for \'PostgreSQL 8.4\') or in the case of beta and DCNL prereleases (e.g. 90100 for \'PostgreSQL 9.1beta2\'). DCNL PQServerVersion()/``server_version`` doesn\'t execute a query so try that DCNL first, then fallback to a ``SELECT version()`` query.'
def truncate_name(name, length=None, hash_len=4): DCNL 'Shortens a string to a repeatable mangled version with the given length.'
def format_number(value, max_digits, decimal_places): DCNL 'Formats a number into a string with the requisite number of digits and DCNL decimal places.'
def receiver(signal, **kwargs): DCNL 'A decorator for connecting receivers to signals. Used by passing in the DCNL signal (or list of signals) and keyword arguments to connect:: DCNL @receiver(post_save, sender=MyModel) DCNL def signal_receiver(sender, **kwargs): DCNL @receiver([post_save, post_delete], sender=MyModel) DCNL def signals_receiver(sender, **kwargs):'
def safeRef(target, onDelete=None): DCNL 'Return a *safe* weak reference to a callable target DCNL target -- the object to be weakly referenced, if it\'s a DCNL bound method reference, will create a BoundMethodWeakref, DCNL otherwise creates a simple weakref. DCNL onDelete -- if provided, will have a hard reference stored DCNL to the callable to be called after the safe reference DCNL goes out of scope with the reference object, (either a DCNL weakref or a BoundMethodWeakref) as argument.'
def get_bound_method_weakref(target, onDelete): DCNL 'Instantiates the appropiate BoundMethodWeakRef, depending on the details of DCNL the underlying class method implementation'
def construct_instance(form, instance, fields=None, exclude=None): DCNL 'Constructs and returns a model instance from the bound ``form``\'s DCNL ``cleaned_data``, but does not save the returned instance to the DCNL database.'
def save_instance(form, instance, fields=None, fail_message=u'saved', commit=True, exclude=None, construct=True): DCNL 'Saves bound Form ``form``\'s cleaned_data into model instance ``instance``. DCNL If commit=True, then the changes to ``instance`` will be saved to the DCNL database. Returns ``instance``. DCNL If construct=False, assume ``instance`` has already been constructed and DCNL just needs to be saved.'
def model_to_dict(instance, fields=None, exclude=None): DCNL 'Returns a dict containing the data in ``instance`` suitable for passing as DCNL a Form\'s ``initial`` keyword argument. DCNL ``fields`` is an optional list of field names. If provided, only the named DCNL fields will be included in the returned dict. DCNL ``exclude`` is an optional list of field names. If provided, the named DCNL fields will be excluded from the returned dict, even if they are listed in DCNL the ``fields`` argument.'
def fields_for_model(model, fields=None, exclude=None, widgets=None, formfield_callback=None): DCNL 'Returns a ``SortedDict`` containing form fields for the given model. DCNL ``fields`` is an optional list of field names. If provided, only the named DCNL fields will be included in the returned fields. DCNL ``exclude`` is an optional list of field names. If provided, the named DCNL fields will be excluded from the returned fields, even if they are listed DCNL in the ``fields`` argument. DCNL ``widgets`` is a dictionary of model field names mapped to a widget DCNL ``formfield_callback`` is a callable that takes a model field and returns DCNL a form field.'
def modelform_factory(model, form=ModelForm, fields=None, exclude=None, formfield_callback=None, widgets=None): DCNL 'Returns a ModelForm containing form fields for the given model. DCNL ``fields`` is an optional list of field names. If provided, only the named DCNL fields will be included in the returned fields. DCNL ``exclude`` is an optional list of field names. If provided, the named DCNL fields will be excluded from the returned fields, even if they are listed DCNL in the ``fields`` argument. DCNL ``widgets`` is a dictionary of model field names mapped to a widget. DCNL ``formfield_callback`` is a callable that takes a model field and returns DCNL a form field.'
def modelformset_factory(model, form=ModelForm, formfield_callback=None, formset=BaseModelFormSet, extra=1, can_delete=False, can_order=False, max_num=None, fields=None, exclude=None): DCNL 'Returns a FormSet class for the given Django model class.'
def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False): DCNL 'Finds and returns the ForeignKey from model to parent if there is one DCNL (returns None if can_fail is True and no such field exists). If fk_name is DCNL provided, assume it is the name of the ForeignKey field. Unles can_fail is DCNL True, an exception is raised if there is no ForeignKey from model to DCNL parent_model.'
def inlineformset_factory(parent_model, model, form=ModelForm, formset=BaseInlineFormSet, fk_name=None, fields=None, exclude=None, extra=3, can_order=False, can_delete=True, max_num=None, formfield_callback=None): DCNL 'Returns an ``InlineFormSet`` for the given kwargs. DCNL You must provide ``fk_name`` if ``model`` has more than one ``ForeignKey`` DCNL to ``parent_model``.'
def pretty_name(name): DCNL 'Converts \'first_name\' to \'First name\''
def get_declared_fields(bases, attrs, with_base_fields=True): DCNL 'Create a list of form field instances from the passed in \'attrs\', plus any DCNL similar fields on the base classes (in \'bases\'). This is used by both the DCNL Form and ModelForm metclasses. DCNL If \'with_base_fields\' is True, all fields from the bases are used. DCNL Otherwise, only fields in the \'declared_fields\' attribute on the bases are DCNL used. The distinction is useful in ModelForm subclassing. DCNL Also integrates any additional media definitions'
def formset_factory(form, formset=BaseFormSet, extra=1, can_order=False, can_delete=False, max_num=None): DCNL 'Return a FormSet for the given form class.'
def all_valid(formsets): DCNL 'Returns true if every formset in formsets is valid.'
def flatatt(attrs): DCNL 'Convert a dictionary of attributes to a single string. DCNL The returned string will contain a leading space followed by key="value", DCNL XML-style pairs.  It is assumed that the keys do not need to be XML-escaped. DCNL If the passed dictionary is empty, then return an empty string. DCNL The result is passed through \'mark_safe\'.'
def from_current_timezone(value): DCNL 'When time zone support is enabled, convert naive datetimes DCNL entered in the current time zone to aware datetimes.'
def to_current_timezone(value): DCNL 'When time zone support is enabled, convert aware datetimes DCNL to naive dateimes in the current time zone for display.'
def exhaust(stream_or_iterable): DCNL 'Completely exhausts an iterator or stream. DCNL Raise a MultiPartParserError if the argument is not a stream or an iterable.'
def parse_boundary_stream(stream, max_header_size): DCNL 'Parses one and exactly one stream that encapsulates a boundary.'
def parse_header(line): DCNL 'Parse the header into a key-value. DCNL Input (line): bytes, output: unicode for key/name, bytes for value which DCNL will be decoded later'
def fix_location_header(request, response): DCNL 'Ensures that we always use an absolute URI in any location header in the DCNL response. This is required by RFC 2616, section 14.30. DCNL Code constructing response objects is free to insert relative paths, as DCNL this function converts them to absolute paths.'
def conditional_content_removal(request, response): DCNL 'Removes the content of responses for HEAD requests, 1xx, 204 and 304 DCNL responses. Ensures compliance with RFC 2616, section 4.3.'
def fix_IE_for_attach(request, response): DCNL 'This function will prevent Django from serving a Content-Disposition header DCNL while expecting the browser to cache it (only when the browser is IE). This DCNL leads to IE not allowing the client to download.'
def fix_IE_for_vary(request, response): DCNL 'This function will fix the bug reported at DCNL http://support.microsoft.com/kb/824847/en-us?spid=8722&sid=global DCNL by clearing the Vary header whenever the mime-type is not safe DCNL enough for Internet Explorer to handle.  Poor thing.'
def build_request_repr(request, path_override=None, GET_override=None, POST_override=None, COOKIES_override=None, META_override=None): DCNL 'Builds and returns the request\'s representation string. The request\'s DCNL attributes may be overridden by pre-processed values.'
def bytes_to_text(s, encoding): DCNL 'Converts basestring objects to unicode, using the given encoding. Illegally DCNL encoded input characters are replaced with Unicode "unknown" codepoint DCNL Returns any non-basestring objects without change.'
def validate_host(host, allowed_hosts): DCNL 'Validate the given host header value for this site. DCNL Check that the host looks valid and matches a host or host pattern in the DCNL given list of ``allowed_hosts``. Any pattern beginning with a period DCNL matches a domain and all its subdomains (e.g. ``.example.com`` matches DCNL ``example.com`` and any subdomain), ``*`` matches anything, and anything DCNL else must match exactly. DCNL Return ``True`` for a valid host, ``False`` otherwise.'
def i18n_patterns(prefix, *args): DCNL 'Adds the language code prefix to every URL pattern within this DCNL function. This may only be used in the root URLconf, not in an included DCNL URLconf.'
def static(prefix, view='django.views.static.serve', **kwargs): DCNL 'Helper function to return a URL pattern for serving files in debug mode. DCNL from django.conf import settings DCNL from django.conf.urls.static import static DCNL urlpatterns = patterns(\'\', DCNL # ... the rest of your URLconf goes here ... DCNL ) + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)'
def compat_patch_logging_config(logging_config): DCNL 'Backwards-compatibility shim for #16288 fix. Takes initial value of DCNL ``LOGGING`` setting and patches it in-place (issuing deprecation warning) DCNL if "mail_admins" logging handler is configured but has no filters.'
@register.tag(u'get_available_languages') DCNL def do_get_available_languages(parser, token): DCNL 'This will store a list of available languages DCNL in the context. DCNL Usage:: DCNL {% get_available_languages as languages %} DCNL {% for language in languages %} DCNL {% endfor %} DCNL This will just pull the LANGUAGES setting from DCNL your setting file (or the default settings) and DCNL put it into the named variable.'
@register.tag(u'get_language_info') DCNL def do_get_language_info(parser, token): DCNL 'This will store the language information dictionary for the given language DCNL code in a context variable. DCNL Usage:: DCNL {% get_language_info for LANGUAGE_CODE as l %} DCNL {{ l.code }} DCNL {{ l.name }} DCNL {{ l.name_local }} DCNL {{ l.bidi|yesno:"bi-directional,uni-directional" }}'
@register.tag(u'get_language_info_list') DCNL def do_get_language_info_list(parser, token): DCNL 'This will store a list of language information dictionaries for the given DCNL language codes in a context variable. The language codes can be specified DCNL either as a list of strings or a settings.LANGUAGES style tuple (or any DCNL sequence of sequences whose first items are language codes). DCNL Usage:: DCNL {% get_language_info_list for LANGUAGES as langs %} DCNL {% for l in langs %} DCNL {{ l.code }} DCNL {{ l.name }} DCNL {{ l.name_local }} DCNL {{ l.bidi|yesno:"bi-directional,uni-directional" }} DCNL {% endfor %}'
@register.tag(u'get_current_language') DCNL def do_get_current_language(parser, token): DCNL 'This will store the current language in the context. DCNL Usage:: DCNL {% get_current_language as language %} DCNL This will fetch the currently active language and DCNL put it\'s value into the ``language`` context DCNL variable.'
@register.tag(u'get_current_language_bidi') DCNL def do_get_current_language_bidi(parser, token): DCNL 'This will store the current language layout in the context. DCNL Usage:: DCNL {% get_current_language_bidi as bidi %} DCNL This will fetch the currently active language\'s layout and DCNL put it\'s value into the ``bidi`` context variable. DCNL True indicates right-to-left layout, otherwise left-to-right'
@register.tag(u'trans') DCNL def do_translate(parser, token): DCNL 'This will mark a string for translation and will DCNL translate the string for the current language. DCNL Usage:: DCNL {% trans "this is a test" %} DCNL This will mark the string for translation so it will DCNL be pulled out by mark-messages.py into the .po files DCNL and will run the string through the translation engine. DCNL There is a second form:: DCNL {% trans "this is a test" noop %} DCNL This will only mark for translation, but will return DCNL the string unchanged. Use it when you need to store DCNL values into forms that should be translated later on. DCNL You can use variables instead of constant strings DCNL to translate stuff you marked somewhere else:: DCNL {% trans variable %} DCNL This will just try to translate the contents of DCNL the variable ``variable``. Make sure that the string DCNL in there is something that is in the .po file. DCNL It is possible to store the translated string into a variable:: DCNL {% trans "this is a test" as var %} DCNL {{ var }} DCNL Contextual translations are also supported:: DCNL {% trans "this is a test" context "greeting" %} DCNL This is equivalent to calling pgettext instead of (u)gettext.'
@register.tag(u'blocktrans') DCNL def do_block_translate(parser, token): DCNL 'This will translate a block of text with parameters. DCNL Usage:: DCNL {% blocktrans with bar=foo|filter boo=baz|filter %} DCNL This is {{ bar }} and {{ boo }}. DCNL {% endblocktrans %} DCNL Additionally, this supports pluralization:: DCNL {% blocktrans count count=var|length %} DCNL There is {{ count }} object. DCNL {% plural %} DCNL There are {{ count }} objects. DCNL {% endblocktrans %} DCNL This is much like ngettext, only in template syntax. DCNL The "var as value" legacy format is still supported:: DCNL {% blocktrans with foo|filter as bar and baz|filter as boo %} DCNL {% blocktrans count var|length as count %} DCNL Contextual translations are supported:: DCNL {% blocktrans with bar=foo|filter context "greeting" %} DCNL This is {{ bar }}. DCNL {% endblocktrans %} DCNL This is equivalent to calling pgettext/npgettext instead of DCNL (u)gettext/(u)ngettext.'
@register.tag DCNL def language(parser, token): DCNL 'This will enable the given language just for this block. DCNL Usage:: DCNL {% language "de" %} DCNL This is {{ bar }} and {{ boo }}. DCNL {% endlanguage %}'
@register.tag(u'cache') DCNL def do_cache(parser, token): DCNL 'This will cache the contents of a template fragment for a given amount DCNL of time. DCNL Usage:: DCNL {% load cache %} DCNL {% cache [expire_time] [fragment_name] %} DCNL .. some expensive processing .. DCNL {% endcache %} DCNL This tag also supports varying by a list of arguments:: DCNL {% load cache %} DCNL {% cache [expire_time] [fragment_name] [var1] [var2] .. %} DCNL .. some expensive processing .. DCNL {% endcache %} DCNL Each unique set of arguments will result in a unique cache entry.'
@register.tag DCNL def get_static_prefix(parser, token): DCNL 'Populates a template variable with the static prefix, DCNL ``settings.STATIC_URL``. DCNL Usage:: DCNL {% get_static_prefix [as varname] %} DCNL Examples:: DCNL {% get_static_prefix %} DCNL {% get_static_prefix as static_prefix %}'
@register.tag DCNL def get_media_prefix(parser, token): DCNL 'Populates a template variable with the media prefix, DCNL ``settings.MEDIA_URL``. DCNL Usage:: DCNL {% get_media_prefix [as varname] %} DCNL Examples:: DCNL {% get_media_prefix %} DCNL {% get_media_prefix as media_prefix %}'
@register.tag('static') DCNL def do_static(parser, token): DCNL 'Joins the given path with the STATIC_URL setting. DCNL Usage:: DCNL {% static path [as varname] %} DCNL Examples:: DCNL {% static "myapp/css/base.css" %} DCNL {% static variable_with_path %} DCNL {% static "myapp/css/base.css" as admin_base_css %} DCNL {% static variable_with_path as varname %}'
@register.filter(is_safe=False) DCNL def localize(value): DCNL 'Forces a value to be rendered as a localized value, DCNL regardless of the value of ``settings.USE_L10N``.'
@register.filter(is_safe=False) DCNL def unlocalize(value): DCNL 'Forces a value to be rendered as a non-localized value, DCNL regardless of the value of ``settings.USE_L10N``.'
@register.tag('localize') DCNL def localize_tag(parser, token): DCNL 'Forces or prevents localization of values, regardless of the value of DCNL `settings.USE_L10N`. DCNL Sample usage:: DCNL {% localize off %} DCNL var pi = {{ 3.1415 }}; DCNL {% endlocalize %}'
@register.filter DCNL def localtime(value): DCNL 'Converts a datetime to local time in the active time zone. DCNL This only makes sense within a {% localtime off %} block.'
@register.filter DCNL def utc(value): DCNL 'Converts a datetime to UTC.'
@register.filter('timezone') DCNL def do_timezone(value, arg): DCNL 'Converts a datetime to local time in a given time zone. DCNL The argument must be an instance of a tzinfo subclass or a time zone name. DCNL If it is a time zone name, pytz is required. DCNL Naive datetimes are assumed to be in local time in the default time zone.'
@register.tag('localtime') DCNL def localtime_tag(parser, token): DCNL 'Forces or prevents conversion of datetime objects to local time, DCNL regardless of the value of ``settings.USE_TZ``. DCNL Sample usage:: DCNL {% localtime off %}{{ value_in_utc }}{% endlocaltime %}'
@register.tag('timezone') DCNL def timezone_tag(parser, token): DCNL 'Enables a given time zone just for this block. DCNL The ``timezone`` argument must be an instance of a ``tzinfo`` subclass, a DCNL time zone name, or ``None``. If is it a time zone name, pytz is required. DCNL If it is ``None``, the default time zone is used within the block. DCNL Sample usage:: DCNL {% timezone "Europe/Paris" %} DCNL It is {{ now }} in Paris. DCNL {% endtimezone %}'
@register.tag('get_current_timezone') DCNL def get_current_timezone_tag(parser, token): DCNL 'Stores the name of the current time zone in the context. DCNL Usage:: DCNL {% get_current_timezone as TIME_ZONE %} DCNL This will fetch the currently active time zone and put its name DCNL into the ``TIME_ZONE`` context variable.'
def prepare_suites_from_test_cases(case_class_list): DCNL 'This function prepares a list of suites to be tested.'
def create_callback_server(session): DCNL 'Adapted from https://github.com/Khan/khan-api/blob/master/examples/test_client/test.py DCNL Simple server to handle callbacks from OAuth request to browser.'
def api_call(target_version, target_api_url, session, debug=False, authenticate=True): DCNL 'Generic API call function, that will try to use an authenticated request if available, DCNL otherwise will fall back to non-authenticated request.'
def n_deep(obj, names): DCNL 'A function to descend len(names) levels in an object and retrieve the attribute there.'
def build_authenticate_header(realm=''): DCNL 'Optional WWW-Authenticate header (401 error)'
def escape(s): DCNL 'Escape a URL including any /.'
def _utf8_str(s): DCNL 'Convert unicode to utf-8.'
def generate_timestamp(): DCNL 'Get seconds since epoch (UTC).'
def generate_nonce(length=8): DCNL 'Generate pseudorandom number.'
def generate_verifier(length=8): DCNL 'Generate pseudorandom number.'
def _resolve_name(name, package, level): DCNL 'Return the absolute name of the module to be imported.'
def import_module(name, package=None): DCNL 'Import a module. DCNL The \'package\' argument is required when performing a relative import. It DCNL specifies the package to use as the anchor point from which to resolve the DCNL relative import to an absolute import.'
def do_terminate_threads(whitelist=list()): DCNL 'Simple function which terminates all of our threads DCNL :param whitelist: If whitelist is given, only the given threads will be terminated'
def terminate_threads(func): DCNL 'Kills all worker threads the method has created by sending the quit signal. DCNL This takes over in case of an error in the main function'
def _init_atexit(): DCNL 'Setup an at-exit job to be sure our workers are shutdown correctly before DCNL the interpreter quits'
def _init_signals(): DCNL 'Assure we shutdown our threads correctly when being interrupted'
def mkchannel(ctype=Channel, wtype=ChannelWriter, rtype=ChannelReader): DCNL 'Create a channel, with a reader and a writer DCNL :return: tuple(reader, writer) DCNL :param ctype: Channel to instantiate DCNL :param wctype: The type of the write channel to instantiate DCNL :param rctype: The type of the read channel to instantiate'
def cpu_count(): DCNL ':return:number of CPUs in the system DCNL :note: inspired by multiprocessing'
def _mkdir(newdir): DCNL 'works the way a good mkdir should :) DCNL - already exists, silently complete DCNL - regular file in the way, raise an exception DCNL - parent directory(ies) does not exist, make them as well'
def _pofile_or_mofile(f, type, **kwargs): DCNL 'Internal function used by :func:`polib.pofile` and :func:`polib.mofile` to DCNL honor the DRY concept.'
def pofile(pofile, **kwargs): DCNL 'Convenience function that parses the po or pot file ``pofile`` and returns DCNL a :class:`~polib.POFile` instance. DCNL Arguments: DCNL ``pofile`` DCNL string, full or relative path to the po/pot file or its content (data). DCNL ``wrapwidth`` DCNL integer, the wrap width, only useful when the ``-w`` option was passed DCNL to xgettext (optional, default: ``78``). DCNL ``encoding`` DCNL string, the encoding to use (e.g. "utf-8") (default: ``None``, the DCNL encoding will be auto-detected). DCNL ``check_for_duplicates`` DCNL whether to check for duplicate entries when adding entries to the DCNL file (optional, default: ``False``). DCNL ``klass`` DCNL class which is used to instantiate the return value (optional, DCNL default: ``None``, the return value with be a :class:`~polib.POFile` DCNL instance).'
def mofile(mofile, **kwargs): DCNL 'Convenience function that parses the mo file ``mofile`` and returns a DCNL :class:`~polib.MOFile` instance. DCNL Arguments: DCNL ``mofile`` DCNL string, full or relative path to the mo file or its content (data). DCNL ``wrapwidth`` DCNL integer, the wrap width, only useful when the ``-w`` option was passed DCNL to xgettext to generate the po file that was used to format the mo file DCNL (optional, default: ``78``). DCNL ``encoding`` DCNL string, the encoding to use (e.g. "utf-8") (default: ``None``, the DCNL encoding will be auto-detected). DCNL ``check_for_duplicates`` DCNL whether to check for duplicate entries when adding entries to the DCNL file (optional, default: ``False``). DCNL ``klass`` DCNL class which is used to instantiate the return value (optional, DCNL default: ``None``, the return value with be a :class:`~polib.POFile` DCNL instance).'
def detect_encoding(file, binary_mode=False): DCNL 'Try to detect the encoding used by the ``file``. The ``file`` argument can DCNL be a PO or MO file path or a string containing the contents of the file. DCNL If the encoding cannot be detected, the function will return the value of DCNL ``default_encoding``. DCNL Arguments: DCNL ``file`` DCNL string, full or relative path to the po/mo file or its content. DCNL ``binary_mode`` DCNL boolean, set this to True if ``file`` is a mo file.'
def escape(st): DCNL 'Escapes the characters ``\\``, ``\t``, ``\n``, ``\r`` and ``"`` in DCNL the given string ``st`` and returns it.'
def unescape(st): DCNL 'Unescapes the characters ``\\``, ``\t``, ``\n``, ``\r`` and ``"`` in DCNL the given string ``st`` and returns it.'
def wrap(text, width=70, **kwargs): DCNL 'Wrap a single paragraph of text, returning a list of wrapped lines.'
def update_self(to_screen, verbose): DCNL 'Update the program file with the latest version from the repository'
def preferredencoding(): DCNL 'Get preferred encoding. DCNL Returns the best encoding scheme for the system, based on DCNL locale.getpreferredencoding() and some further tweaks.'
def write_json_file(obj, fn): DCNL 'Encode obj as JSON and write it to fn, atomically if possible'
def get_element_by_id(id, html): DCNL 'Return the content of the tag with the specified ID in the passed HTML document'
def get_element_by_attribute(attribute, value, html): DCNL 'Return the content of the tag with the specified attribute in the passed HTML document'
def clean_html(html): DCNL 'Clean an HTML snippet into a readable string'
def sanitize_open(filename, open_mode): DCNL 'Try to open the given filename, and slightly tweak it if this fails. DCNL Attempts to open the given filename. If this fails, it tries to change DCNL the filename slightly, step by step, until it\'s either able to open it DCNL or it fails and raises a final exception, like the standard open() DCNL function. DCNL It returns the tuple (stream, definitive_file_name).'
def timeconvert(timestr): DCNL 'Convert RFC 2822 defined time string into system timestamp'
def sanitize_filename(s, restricted=False, is_id=False): DCNL 'Sanitizes a string so it could be used as part of a filename. DCNL If restricted is set, use a stricter subset of allowed characters. DCNL Set is_id if this is not an arbitrary string, but an ID that should be kept if possible'
def orderedSet(iterable): DCNL 'Remove all duplicates from the input iterable'
def _htmlentity_transform(entity): DCNL 'Transforms an HTML entity to a character.'
def encodeFilename(s, for_subprocess=False): DCNL '@param s The name of the file'
def parse_iso8601(date_str, delimiter=u'T'): DCNL 'Return a UNIX timestamp from the given date'
def unified_strdate(date_str): DCNL 'Return a string with the date in the format YYYYMMDD'
def date_from_str(date_str): DCNL 'Return a datetime object from a string in the format YYYYMMDD or DCNL (now|today)[+-][0-9](day|week|month|year)(s)?'
def hyphenate_date(date_str): DCNL 'Convert a date in \'YYYYMMDD\' format to \'YYYY-MM-DD\' format'
def platform_name(): DCNL 'Returns the platform name as a compat_str'
def _windows_write_string(s, out): DCNL 'Returns True if the string was written using special methods, DCNL False if it has yet to be written out.'
def takewhile_inclusive(pred, seq): DCNL 'Like itertools.takewhile, but include the latest evaluated element DCNL (the first element so that Not pred(e))'
def smuggle_url(url, data): DCNL 'Pass additional data in a URL for internal use.'
def month_by_name(name): DCNL 'Return the number of a month by (locale-independently) English name'
def fix_xml_ampersands(xml_str): DCNL 'Replace all the \'&\' by \'&amp;\' in XML'
def str_to_int(int_str): DCNL 'A more relaxed version of int_or_none'
def check_executable(exe, args=[]): DCNL 'Checks if the given binary is installed somewhere in PATH, and returns its name. DCNL args can be a list of arguments for a short output (like -version)'
def get_exe_version(exe, args=[u'--version'], version_re=u'version\\s+([0-9._-a-zA-Z]+)', unrecognized=u'present'): DCNL 'Returns the version of the specified executable, DCNL or False if the executable is not present'
def escape_rfc3986(s): DCNL 'Escape non-ASCII characters as suggested by RFC 3986'
def escape_url(url): DCNL 'Escape URL as suggested by RFC 3986'
def qualities(quality_ids): DCNL 'Get a numeric quality value out of a list of possible values'
def limit_length(s, length): DCNL 'Add ellipses to overly long strings'
def ytdl_is_updateable(): DCNL 'Returns if youtube-dl can be updated with -U'
def aes_ctr_decrypt(data, key, counter): DCNL 'Decrypt with aes in counter mode DCNL @param {int[]} data        cipher DCNL @param {int[]} key         16/24/32-Byte cipher key DCNL @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block) DCNL returns the next counter block DCNL @returns {int[]}           decrypted data'
def aes_cbc_decrypt(data, key, iv): DCNL 'Decrypt with aes in CBC mode DCNL @param {int[]} data        cipher DCNL @param {int[]} key         16/24/32-Byte cipher key DCNL @param {int[]} iv          16-Byte IV DCNL @returns {int[]}           decrypted data'
def key_expansion(data): DCNL 'Generate key schedule DCNL @param {int[]} data  16/24/32-Byte cipher key DCNL @returns {int[]}     176/208/240-Byte expanded key'
def aes_encrypt(data, expanded_key): DCNL 'Encrypt one block with aes DCNL @param {int[]} data          16-Byte state DCNL @param {int[]} expanded_key  176/208/240-Byte expanded key DCNL @returns {int[]}             16-Byte cipher'
def aes_decrypt(data, expanded_key): DCNL 'Decrypt one block with aes DCNL @param {int[]} data          16-Byte cipher DCNL @param {int[]} expanded_key  176/208/240-Byte expanded key DCNL @returns {int[]}             16-Byte state'
def aes_decrypt_text(data, password, key_size_bytes): DCNL 'Decrypt text DCNL - The first 8 Bytes of decoded \'data\' are the 8 high Bytes of the counter DCNL - The cipher key is retrieved by encrypting the first 16 Byte of \'password\' DCNL with the first \'key_size_bytes\' Bytes from \'password\' (if necessary filled with 0\'s) DCNL - Mode of operation is \'counter\' DCNL @param {str} data                    Base64 encoded string DCNL @param {str,unicode} password        Password (will be encoded with utf-8) DCNL @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit DCNL @returns {str}                       Decrypted data'
def gen_extractors(): DCNL 'Return a list of an instance of every supported extractor. DCNL The order does matter; the first extractor matched is the one handling the URL.'
def get_info_extractor(ie_name): DCNL 'Returns the info extractor class with the given ie_name'
def build_fragments_list(boot_info): DCNL 'Return a list of (segment, fragment) for each fragment in the video'
def write_flv_header(stream, metadata): DCNL 'Writes the FLV header and the metadata to stream'
def get_suitable_downloader(info_dict): DCNL 'Get the downloader class that can handle the info dict.'
def get_type_string(data): DCNL 'Translates a Python data type into a string format.'
def dict_strip_unicode_keys(uni_dict): DCNL 'Converts a dict of unicode keys into a dict of ascii keys. DCNL Useful for converting a dict to a kwarg-able format.'
def is_valid_javascript_identifier(identifier, escape=u'\\\\u', ucd_cat=category): DCNL 'Return whether the given ``id`` is a valid Javascript identifier.'
def is_valid_jsonp_callback_value(value): DCNL 'Return whether the given ``value`` can be used as a JSON-P callback.'
def determine_format(request, serializer, default_format=u'application/json'): DCNL 'Tries to "smartly" determine which output format is desired. DCNL First attempts to find a ``format`` override from the request and supplies DCNL that if found. DCNL If no request format was demanded, it falls back to ``mimeparse`` and the DCNL ``Accepts`` header, allowing specification that way. DCNL If still no format is found, returns the ``default_format`` (which defaults DCNL to ``application/json`` if not provided). DCNL NOTE: callers *must* be prepared to handle BadRequest exceptions due to DCNL malformed HTTP request headers!'
def build_content_type(format, encoding=u'utf-8'): DCNL 'Appends character encoding to the provided format if not already present.'
def format_datetime(dt): DCNL 'RFC 2822 datetime formatter'
def format_date(d): DCNL 'RFC 2822 date formatter'
def format_time(t): DCNL 'RFC 2822 time formatter'
def convert_post_to_VERB(request, verb): DCNL 'Force Django to process the VERB.'
def build_authenticate_header(realm=''): DCNL 'Optional WWW-Authenticate header (401 error)'
def escape(s): DCNL 'Escape a URL including any /.'
def _utf8_str(s): DCNL 'Convert unicode to utf-8.'
def generate_timestamp(): DCNL 'Get seconds since epoch (UTC).'
def generate_nonce(length=8): DCNL 'Generate pseudorandom number.'
def generate_verifier(length=8): DCNL 'Generate pseudorandom number.'
def test_parse_date_fraction_2(): DCNL 'From bug 6'
def test_parse_no_timezone(): DCNL 'issue 4 - Handle datetime string without timezone DCNL This tests what happens when you parse a date with no timezone. While not DCNL strictly correct this is quite common. I\'ll assume UTC for the time zone DCNL in this case.'
def test_space_separator(): DCNL 'Handle a separator other than T'
def parse_timezone(tzstring, default_timezone=UTC): DCNL 'Parses ISO 8601 time zone specs into tzinfo offsets'
def parse_date(datestring, default_timezone=UTC): DCNL 'Parses ISO 8601 dates into datetime objects DCNL The timezone is parsed from the date string. However it is quite common to DCNL have dates without a timezone (not strictly correct). In this case the DCNL default timezone specified in default_timezone is used. This is UTC by DCNL default.'
def test_callable_spec(callable, callable_args, callable_kwargs): DCNL 'Inspect callable and test to see if the given args are suitable for it. DCNL When an error occurs during the handler\'s invoking stage there are 2 DCNL erroneous cases: DCNL 1.  Too many parameters passed to a function which doesn\'t define DCNL one of *args or **kwargs. DCNL 2.  Too little parameters are passed to the function. DCNL There are 3 sources of parameters to a cherrypy handler. DCNL 1.  query string parameters are passed as keyword parameters to the handler. DCNL 2.  body parameters are also passed as keyword parameters. DCNL 3.  when partial matching occurs, the final path atoms are passed as DCNL positional args. DCNL Both the query string and path atoms are part of the URI.  If they are DCNL incorrect, then a 404 Not Found should be raised. Conversely the body DCNL parameters are part of the request; if they are invalid a 400 Bad Request.'
def VirtualHost(next_dispatcher=Dispatcher(), use_x_forwarded_host=True, **domains): DCNL 'Select a different handler based on the Host header. DCNL This can be useful when running multiple sites within one CP server. DCNL It allows several domains to point to different parts of a single DCNL website structure. For example:: DCNL http://www.domain.example  ->  root DCNL http://www.domain2.example  ->  root/domain2/ DCNL http://www.domain2.example:443  ->  root/secure DCNL can be accomplished via the following config:: DCNL request.dispatch = cherrypy.dispatch.VirtualHost( DCNL **{\'www.domain2.example\': \'/domain2\', DCNL \'www.domain2.example:443\': \'/secure\', DCNL next_dispatcher DCNL The next dispatcher object in the dispatch chain. DCNL The VirtualHost dispatcher adds a prefix to the URL and calls DCNL another dispatcher. Defaults to cherrypy.dispatch.Dispatcher(). DCNL use_x_forwarded_host DCNL If True (the default), any "X-Forwarded-Host" DCNL request header will be used instead of the "Host" header. This DCNL is commonly added by HTTP servers (such as Apache) when proxying. DCNL ``**domains`` DCNL A dict of {host header value: virtual prefix} pairs. DCNL The incoming "Host" request header is looked up in this dict, DCNL and, if a match is found, the corresponding "virtual prefix" DCNL value will be prepended to the URL path before calling the DCNL next dispatcher. Note that you often need separate entries DCNL for "example.com" and "www.example.com". In addition, "Host" DCNL headers may contain the port number.'
def clean_headers(status): DCNL 'Remove any headers which should not apply to an error response.'
def get_error_page(status, **kwargs): DCNL 'Return an HTML page, containing a pretty error response. DCNL status should be an int or a str. DCNL kwargs will be interpolated into the page template.'
def format_exc(exc=None): DCNL 'Return exc (or sys.exc_info if None), formatted.'
def bare_error(extrabody=None): DCNL 'Produce status, headers, body for a critical error. DCNL Returns a triple without calling any other questionable functions, DCNL so it should be as error-free as possible. Call it from an HTTP server DCNL if you get errors outside of the request. DCNL If extrabody is None, a friendly but rather unhelpful error message DCNL is set in the body. If extrabody is a string, it will be appended DCNL as-is to the body.'
def client_host(server_host): DCNL 'Return the host on which a client can connect to the given listener.'
def check_port(host, port, timeout=1.0): DCNL 'Raise an error if the given port is not free on the given host.'
def wait_for_free_port(host, port, timeout=None): DCNL 'Wait for the specified port to become free (drop requests).'
def wait_for_occupied_port(host, port, timeout=None): DCNL 'Wait for the specified port to become active (receive requests).'
def hooks_namespace(k, v): DCNL 'Attach bare hooks declared in config.'
def request_namespace(k, v): DCNL 'Attach request attributes declared in config.'
def response_namespace(k, v): DCNL 'Attach response attributes declared in config.'
def error_page_namespace(k, v): DCNL 'Attach error pages declared in config.'
def format_exc(limit=None): DCNL 'Like print_exc() but return a string. Backport for Python 2.3.'
def plat_specific_errors(*errnames): DCNL 'Return error numbers for all errors in errnames on this platform. DCNL The \'errno\' module contains different global constants depending on DCNL the specific platform (OS). This function will return the list of DCNL numeric values for a given list of potential names.'
def read_headers(rfile, hdict=None): DCNL 'Read headers from the given stream into the given header dict. DCNL If hdict is None, a new header dict is created. Returns the populated DCNL header dict. DCNL Headers which are repeated are folded together using a comma if their DCNL specification so dictates. DCNL This function raises ValueError when the read bytes violate the HTTP spec. DCNL You should probably return "400 Bad Request" if this happens.'
def get_ssl_adapter_class(name='pyopenssl'): DCNL 'Return an SSL adapter class for the given name.'
def plat_specific_errors(*errnames): DCNL 'Return error numbers for all errors in errnames on this platform. DCNL The \'errno\' module contains different global constants depending on DCNL the specific platform (OS). This function will return the list of DCNL numeric values for a given list of potential names.'
def read_headers(rfile, hdict=None): DCNL 'Read headers from the given stream into the given header dict. DCNL If hdict is None, a new header dict is created. Returns the populated DCNL header dict. DCNL Headers which are repeated are folded together using a comma if their DCNL specification so dictates. DCNL This function raises ValueError when the read bytes violate the HTTP spec. DCNL You should probably return "400 Bad Request" if this happens.'
def get_ssl_adapter_class(name='builtin'): DCNL 'Return an SSL adapter class for the given name.'
def process_urlencoded(entity): DCNL 'Read application/x-www-form-urlencoded data into entity.params.'
def process_multipart(entity): DCNL 'Read all multipart parts into entity.parts.'
def process_multipart_form_data(entity): DCNL 'Read all multipart/form-data parts into entity.parts or entity.params.'
def _old_process_multipart(entity): DCNL 'The behavior of 3.2 and lower. Deprecated and will be changed in 3.3.'
def as_dict(config): DCNL 'Return a dict from \'config\' whether it is a dict, file, or filename.'
def unrepr(s): DCNL 'Return a Python object compiled from a string.'
def modules(modulePath): DCNL 'Load a module and retrieve a reference to that module.'
def attributes(full_attribute_name): DCNL 'Load a module and retrieve an attribute of that module.'
def get(invalid_methods=('POST', 'PUT', 'DELETE'), debug=False, **kwargs): DCNL 'Try to obtain cached output. If fresh enough, raise HTTPError(304). DCNL If POST, PUT, or DELETE: DCNL * invalidates (deletes) any cached response for this resource DCNL * sets request.cached = False DCNL * sets request.cacheable = False DCNL else if a cached copy exists: DCNL * sets request.cached = True DCNL * sets request.cacheable = False DCNL * sets response.headers to the cached values DCNL * checks the cached Last-Modified response header against the DCNL current If-(Un)Modified-Since request headers; raises 304 DCNL if necessary. DCNL * sets response.status and response.body to the cached values DCNL * returns True DCNL otherwise: DCNL * sets request.cached = False DCNL * sets request.cacheable = True DCNL * returns False'
def tee_output(): DCNL 'Tee response output to cache storage. Internal.'
def expires(secs=0, force=False, debug=False): DCNL 'Tool for influencing cache mechanisms using the \'Expires\' header. DCNL secs DCNL Must be either an int or a datetime.timedelta, and indicates the DCNL number of seconds between response.time and when the response should DCNL expire. The \'Expires\' header will be set to response.time + secs. DCNL If secs is zero, the \'Expires\' header is set one year in the past, and DCNL the following "cache prevention" headers are also set: DCNL * Pragma: no-cache DCNL * Cache-Control\': no-cache, must-revalidate DCNL force DCNL If False, the following headers are checked: DCNL * Etag DCNL * Last-Modified DCNL * Age DCNL * Expires DCNL If any are already present, none of the above response headers are set.'
def extrapolate_statistics(scope): DCNL 'Return an extrapolated copy of the given scope.'
def decode(encoding=None, default_encoding='utf-8'): DCNL 'Replace or extend the list of charsets used to decode a request entity. DCNL Either argument may be a single string or a list of strings. DCNL encoding DCNL If not None, restricts the set of charsets attempted while decoding DCNL a request entity to the given set (even if a different charset is given in DCNL the Content-Type request header). DCNL default_encoding DCNL Only in effect if the \'encoding\' argument is not given. DCNL If given, the set of charsets attempted while decoding a request entity is DCNL *extended* with the given value(s).'
def compress(body, compress_level): DCNL 'Compress \'body\' at the given compress_level.'
def gzip(compress_level=5, mime_types=['text/html', 'text/plain'], debug=False): DCNL 'Try to gzip the response body if Content-Type in mime_types. DCNL cherrypy.response.headers[\'Content-Type\'] must be set to one of the DCNL values in the mime_types arg before calling this function. DCNL The provided list of mime-types must be of one of the following form: DCNL * type/subtype DCNL * type/* DCNL * type/*+subtype DCNL No compression is performed if any of the following hold: DCNL * The client sends no Accept-Encoding request header DCNL * No \'gzip\' or \'x-gzip\' is present in the Accept-Encoding header DCNL * No \'gzip\' or \'x-gzip\' with a qvalue > 0 is present DCNL * The \'identity\' value is given with a qvalue > 0.'
def process_body(): DCNL 'Return (params, method) from request body.'
def patched_path(path): DCNL 'Return \'path\', doctored for RPC.'
def calculateNonce(realm, algorithm=MD5): DCNL 'This is an auxaliary function that calculates \'nonce\' value. It is used DCNL to handle sessions.'
def digestAuth(realm, algorithm=MD5, nonce=None, qop=AUTH): DCNL 'Challenges the client for a Digest authentication.'
def basicAuth(realm): DCNL 'Challengenes the client for a Basic authentication.'
def doAuth(realm): DCNL '\'doAuth\' function returns the challenge string b giving priority over DCNL Digest and fallback to Basic authentication when the browser doesn\'t DCNL support the first one. DCNL This should be set in the HTTP header under the key \'WWW-Authenticate\'.'
def parseAuthorization(credentials): DCNL 'parseAuthorization will convert the value of the \'Authorization\' key in DCNL the HTTP header to a map itself. If the parsing fails \'None\' is returned.'
def md5SessionKey(params, password): DCNL 'If the "algorithm" directive\'s value is "MD5-sess", then A1 DCNL [the session key] is calculated only once - on the first request by the DCNL client following receipt of a WWW-Authenticate challenge from the server. DCNL This creates a \'session key\' for the authentication of subsequent DCNL requests and responses which is different for each "authentication DCNL session", thus limiting the amount of material hashed with any one DCNL key. DCNL Because the server need only use the hash of the user DCNL credentials in order to create the A1 value, this construction could DCNL be used in conjunction with a third party authentication service so DCNL that the web server would not need the actual password value.  The DCNL specification of such a protocol is beyond the scope of this DCNL specification.'
def _computeDigestResponse(auth_map, password, method='GET', A1=None, **kwargs): DCNL 'Generates a response respecting the algorithm defined in RFC 2617'
def _checkDigestResponse(auth_map, password, method='GET', A1=None, **kwargs): DCNL 'This function is used to verify the response given by the client when DCNL he tries to authenticate. DCNL Optional arguments: DCNL entity_body - when \'qop\' is set to \'auth-int\' you MUST provide the DCNL raw data you are going to send to the client (usually the DCNL HTML page. DCNL request_uri - the uri from the request line compared with the \'uri\' DCNL directive of the authorization map. They must represent DCNL the same resource (unused at this time).'
def checkResponse(auth_map, password, method='GET', encrypt=None, **kwargs): DCNL '\'checkResponse\' compares the auth_map with the password and optionally DCNL other arguments that each implementation might need. DCNL If the response is of type \'Basic\' then the function has the following DCNL signature:: DCNL checkBasicResponse (auth_map, password) -> bool DCNL If the response is of type \'Digest\' then the function has the following DCNL signature:: DCNL checkDigestResponse (auth_map, password, method = \'GET\', A1 = None) -> bool DCNL The \'A1\' argument is only used in MD5_SESS algorithm based responses. DCNL Check md5SessionKey() for more info.'
def new_func_strip_path(func_name): DCNL 'Make profiler output more readable by adding ``__init__`` modules\' parents'
def get_tree(base, exclude, coverage=the_coverage): DCNL 'Return covered module names as a nested dict.'
def serve_file(path, content_type=None, disposition=None, name=None, debug=False): DCNL 'Set status, headers, and body in order to serve the given path. DCNL The Content-Type header will be set to the content_type arg, if provided. DCNL If not provided, the Content-Type will be guessed by the file extension DCNL of the \'path\' argument. DCNL If disposition is not None, the Content-Disposition header will be set DCNL to "<disposition>; filename=<name>". If name is None, it will be set DCNL to the basename of path. If disposition is None, no Content-Disposition DCNL header will be written.'
def serve_fileobj(fileobj, content_type=None, disposition=None, name=None, debug=False): DCNL 'Set status, headers, and body in order to serve the given file object. DCNL The Content-Type header will be set to the content_type arg, if provided. DCNL If disposition is not None, the Content-Disposition header will be set DCNL to "<disposition>; filename=<name>". If name is None, \'filename\' will DCNL not be set. If disposition is None, no Content-Disposition header will DCNL be written. DCNL CAUTION: If the request contains a \'Range\' header, one or more seek()s will DCNL be performed on the file object.  This may cause undesired behavior if DCNL the file object is not seekable.  It could also produce undesired results DCNL if the caller set the read position of the file object prior to calling DCNL serve_fileobj(), expecting that the data would be served starting from that DCNL position.'
def _serve_fileobj(fileobj, content_type, content_length, debug=False): DCNL 'Internal. Set response.body to the given file object, perhaps ranged.'
def serve_download(path, name=None): DCNL 'Serve \'path\' as an application/x-download attachment.'
def staticdir(section, dir, root='', match='', content_types=None, index='', debug=False): DCNL 'Serve a static resource from the given (root +) dir. DCNL match DCNL If given, request.path_info will be searched for the given DCNL regular expression before attempting to serve static content. DCNL content_types DCNL If given, it should be a Python dictionary of DCNL {file-extension: content-type} pairs, where \'file-extension\' is DCNL a string (e.g. "gif") and \'content-type\' is the value to write DCNL out in the Content-Type response header (e.g. "image/gif"). DCNL index DCNL If provided, it should be the (relative) name of a file to DCNL serve for directory requests. For example, if the dir argument is DCNL \'/home/me\', the Request-URI is \'myapp\', and the index arg is DCNL \'index.html\', the file \'/home/me/myapp/index.html\' will be sought.'
def staticfile(filename, root=None, match='', content_types=None, debug=False): DCNL 'Serve a static resource from the given (root +) filename. DCNL match DCNL If given, request.path_info will be searched for the given DCNL regular expression before attempting to serve static content. DCNL content_types DCNL If given, it should be a Python dictionary of DCNL {file-extension: content-type} pairs, where \'file-extension\' is DCNL a string (e.g. "gif") and \'content-type\' is the value to write DCNL out in the Content-Type response header (e.g. "image/gif").'
def get_ha1_dict_plain(user_password_dict): DCNL 'Returns a get_ha1 function which obtains a plaintext password from a DCNL dictionary of the form: {username : password}. DCNL If you want a simple dictionary-based authentication scheme, with plaintext DCNL passwords, use get_ha1_dict_plain(my_userpass_dict) as the value for the DCNL get_ha1 argument to digest_auth().'
def get_ha1_dict(user_ha1_dict): DCNL 'Returns a get_ha1 function which obtains a HA1 password hash from a DCNL dictionary of the form: {username : HA1}. DCNL If you want a dictionary-based authentication scheme, but with DCNL pre-computed HA1 hashes instead of plain-text passwords, use DCNL get_ha1_dict(my_userha1_dict) as the value for the get_ha1 DCNL argument to digest_auth().'
def get_ha1_file_htdigest(filename): DCNL 'Returns a get_ha1 function which obtains a HA1 password hash from a DCNL flat file with lines of the same format as that produced by the Apache DCNL htdigest utility. For example, for realm \'wonderland\', username \'alice\', DCNL and password \'4x5istwelve\', the htdigest line would be:: DCNL alice:wonderland:3238cdfe91a8b2ed8e39646921a02d4c DCNL If you want to use an Apache htdigest file as the credentials store, DCNL then use get_ha1_file_htdigest(my_htdigest_file) as the value for the DCNL get_ha1 argument to digest_auth().  It is recommended that the filename DCNL argument be an absolute path, to avoid problems.'
def synthesize_nonce(s, key, timestamp=None): DCNL 'Synthesize a nonce value which resists spoofing and can be checked for staleness. DCNL Returns a string suitable as the value for \'nonce\' in the www-authenticate header. DCNL s DCNL A string related to the resource, such as the hostname of the server. DCNL key DCNL A secret string known only to the server. DCNL timestamp DCNL An integer seconds-since-the-epoch timestamp'
def H(s): DCNL 'The hash function H'
def www_authenticate(realm, key, algorithm='MD5', nonce=None, qop=qop_auth, stale=False): DCNL 'Constructs a WWW-Authenticate header for Digest authentication.'
def digest_auth(realm, get_ha1, key, debug=False): DCNL 'A CherryPy tool which hooks at before_handler to perform DCNL HTTP Digest Access Authentication, as specified in :rfc:`2617`. DCNL If the request has an \'authorization\' header with a \'Digest\' scheme, this DCNL tool authenticates the credentials supplied in that header.  If DCNL the request has no \'authorization\' header, or if it does but the scheme is DCNL not "Digest", or if authentication fails, the tool sends a 401 response with DCNL a \'WWW-Authenticate\' Digest header. DCNL realm DCNL A string containing the authentication realm. DCNL get_ha1 DCNL A callable which looks up a username in a credentials store DCNL and returns the HA1 string, which is defined in the RFC to be DCNL MD5(username : realm : password).  The function\'s signature is: DCNL ``get_ha1(realm, username)`` DCNL where username is obtained from the request\'s \'authorization\' header. DCNL If username is not found in the credentials store, get_ha1() returns DCNL None. DCNL key DCNL A secret string known only to the server, used in the synthesis of nonces.'
def file_generator_limited(fileobj, count, chunk_size=65536): DCNL 'Yield the given file object in chunks, stopping after `count` DCNL bytes has been emitted.  Default chunk size is 64kB. (Core)'
def set_vary_header(response, header_name): DCNL 'Add a Vary header to a response'
def checkpassword_dict(user_password_dict): DCNL 'Returns a checkpassword function which checks credentials DCNL against a dictionary of the form: {username : password}. DCNL If you want a simple dictionary-based authentication scheme, use DCNL checkpassword_dict(my_credentials_dict) as the value for the DCNL checkpassword argument to basic_auth().'
def basic_auth(realm, checkpassword, debug=False): DCNL 'A CherryPy tool which hooks at before_handler to perform DCNL HTTP Basic Access Authentication, as specified in :rfc:`2617`. DCNL If the request has an \'authorization\' header with a \'Basic\' scheme, this DCNL tool attempts to authenticate the credentials supplied in that header.  If DCNL the request has no \'authorization\' header, or if it does but the scheme is DCNL not \'Basic\', or if authentication fails, the tool sends a 401 response with DCNL a \'WWW-Authenticate\' Basic header. DCNL realm DCNL A string containing the authentication realm. DCNL checkpassword DCNL A callable which checks the authentication credentials. DCNL Its signature is checkpassword(realm, username, password). where DCNL username and password are the values obtained from the request\'s DCNL \'authorization\' header.  If authentication succeeds, checkpassword DCNL returns True, else it returns False.'
def validate_etags(autotags=False, debug=False): DCNL 'Validate the current ETag against If-Match, If-None-Match headers. DCNL If autotags is True, an ETag response-header value will be provided DCNL from an MD5 hash of the response body (unless some other code has DCNL already provided an ETag header). If False (the default), the ETag DCNL will not be automatic. DCNL WARNING: the autotags feature is not designed for URL\'s which allow DCNL methods other than GET. For example, if a POST to the same URL returns DCNL no content, the automatic ETag will be incorrect, breaking a fundamental DCNL use for entity tags in a possibly destructive fashion. Likewise, if you DCNL raise 304 Not Modified, the response body will be empty, the ETag hash DCNL will be incorrect, and your application will break. DCNL See :rfc:`2616` Section 14.24.'
def validate_since(): DCNL 'Validate the current Last-Modified against If-Modified-Since headers. DCNL If no code has set the Last-Modified response header, then no validation DCNL will be performed.'
def allow(methods=None, debug=False): DCNL 'Raise 405 if request.method not in methods (default [\'GET\', \'HEAD\']). DCNL The given methods are case-insensitive, and may be in any order. DCNL If only one method is allowed, you may supply a single string; DCNL if more than one, supply a list of strings. DCNL Regardless of whether the current method is allowed or not, this DCNL also emits an \'Allow\' response header, containing the given methods.'
def proxy(base=None, local='X-Forwarded-Host', remote='X-Forwarded-For', scheme='X-Forwarded-Proto', debug=False): DCNL 'Change the base URL (scheme://host[:port][/path]). DCNL For running a CP server behind Apache, lighttpd, or other HTTP server. DCNL For Apache and lighttpd, you should leave the \'local\' argument at the DCNL default value of \'X-Forwarded-Host\'. For Squid, you probably want to set DCNL tools.proxy.local = \'Origin\'. DCNL If you want the new request.base to include path info (not just the host), DCNL you must explicitly set base to the full base path, and ALSO set \'local\' DCNL to \'\', so that the X-Forwarded-Host request header (which never includes DCNL path info) does not override it. Regardless, the value for \'base\' MUST DCNL NOT end in a slash. DCNL cherrypy.request.remote.ip (the IP address of the client) will be DCNL rewritten if the header specified by the \'remote\' arg is valid. DCNL By default, \'remote\' is set to \'X-Forwarded-For\'. If you do not DCNL want to rewrite remote.ip, set the \'remote\' arg to an empty string.'
def ignore_headers(headers=('Range',), debug=False): DCNL 'Delete request headers whose field names are included in \'headers\'. DCNL This is a useful tool for working behind certain HTTP servers; DCNL for example, Apache duplicates the work that CP does for \'Range\' DCNL headers, and will doubly-truncate the response.'
def response_headers(headers=None, debug=False): DCNL 'Set headers on the response.'
def referer(pattern, accept=True, accept_missing=False, error=403, message='Forbidden DCSP Referer DCSP header.', debug=False): DCNL 'Raise HTTPError if Referer header does/does not match the given pattern. DCNL pattern DCNL A regular expression pattern to test against the Referer. DCNL accept DCNL If True, the Referer must match the pattern; if False, DCNL the Referer must NOT match the pattern. DCNL accept_missing DCNL If True, permit requests with no Referer header. DCNL error DCNL The HTTP error code to return to the client on failure. DCNL message DCNL A string to include in the response body on failure.'
def log_traceback(severity=logging.ERROR, debug=False): DCNL 'Write the last error\'s traceback to the cherrypy error log.'
def log_request_headers(debug=False): DCNL 'Write request headers to the cherrypy error log.'
def log_hooks(debug=False): DCNL 'Write request.hooks to the cherrypy error log.'
def redirect(url='', internal=True, debug=False): DCNL 'Raise InternalRedirect or HTTPRedirect to the given url.'
def trailing_slash(missing=True, extra=False, status=None, debug=False): DCNL 'Redirect if path_info has (missing|extra) trailing slash.'
def flatten(debug=False): DCNL 'Wrap response.body in a generator that recursively iterates over body. DCNL This allows cherrypy.response.body to consist of \'nested generators\'; DCNL that is, a set of generators that yield generators.'
def accept(media=None, debug=False): DCNL 'Return the client\'s preferred media-type (from the given Content-Types). DCNL If \'media\' is None (the default), no test will be performed. DCNL If \'media\' is provided, it should be the Content-Type value (as a string) DCNL or values (as a list or tuple of strings) which the current resource DCNL can emit. The client\'s acceptable media ranges (as declared in the DCNL Accept request header) will be matched in order to these Content-Type DCNL values; the first such string is returned. That is, the return value DCNL will always be one of the strings provided in the \'media\' arg (or None DCNL if \'media\' is None). DCNL If no match is found, then HTTPError 406 (Not Acceptable) is raised. DCNL Note that most web browsers send */* as a (low-quality) acceptable DCNL media range, which should match any Content-Type. In addition, "...if DCNL no Accept header field is present, then it is assumed that the client DCNL accepts all media types." DCNL Matching types are checked in order of client preference first, DCNL and then in the order of the given \'media\' values. DCNL Note that this function does not honor accept-params (other than "q").'
def autovary(ignore=None, debug=False): DCNL 'Auto-populate the Vary response header based on request.header access.'
def urljoin(*atoms): DCNL 'Return the given path \*atoms, joined into a single URL. DCNL This will correctly join a SCRIPT_NAME and PATH_INFO into the DCNL original URL, even if either atom is blank.'
def urljoin_bytes(*atoms): DCNL 'Return the given path *atoms, joined into a single URL. DCNL This will correctly join a SCRIPT_NAME and PATH_INFO into the DCNL original URL, even if either atom is blank.'
def protocol_from_http(protocol_str): DCNL 'Return a protocol tuple from the given \'HTTP/x.y\' string.'
def get_ranges(headervalue, content_length): DCNL 'Return a list of (start, stop) indices from a Range header, or None. DCNL Each (start, stop) tuple will be composed of two ints, which are suitable DCNL for use in a slicing operation. That is, the header "Range: bytes=3-6", DCNL if applied against a Python string, is requesting resource[3:7]. This DCNL function will return the list [(3, 7)]. DCNL If this function returns an empty list, you should return HTTP 416.'
def header_elements(fieldname, fieldvalue): DCNL 'Return a sorted HeaderElement list from a comma-separated header string.'
def decode_TEXT(value): DCNL 'Decode :rfc:`2047` TEXT (e.g. "=?utf-8?q?f=C3=BCr?=" -> "f\xfcr").'
def valid_status(status): DCNL 'Return legal HTTP status Code, Reason-phrase and Message. DCNL The status arg must be an int, or a str that begins with an int. DCNL If status is an int, or a str and no reason-phrase is supplied, DCNL a default reason-phrase will be provided.'
def _parse_qs(qs, keep_blank_values=0, strict_parsing=0, encoding='utf-8'): DCNL 'Parse a query given as a string argument. DCNL Arguments: DCNL qs: URL-encoded query string to be parsed DCNL keep_blank_values: flag indicating whether blank values in DCNL URL encoded queries should be treated as blank strings.  A DCNL true value indicates that blanks should be retained as blank DCNL strings.  The default false value indicates that blank values DCNL are to be ignored and treated as if they were  not included. DCNL strict_parsing: flag indicating what to do with parsing errors. If DCNL false (the default), errors are silently ignored. If true, DCNL errors raise a ValueError exception. DCNL Returns a dict, as G-d intended.'
def parse_query_string(query_string, keep_blank_values=True, encoding='utf-8'): DCNL 'Build a params dictionary from a query_string. DCNL Duplicate key/value pairs in the provided query_string will be DCNL returned as {\'key\': [val1, val2, ...]}. Single key/values will DCNL be returned as strings: {\'key\': \'value\'}.'
def check_auth(users, encrypt=None, realm=None): DCNL 'If an authorization header contains credentials, return True, else False.'
def basic_auth(realm, users, encrypt=None, debug=False): DCNL 'If auth fails, raise 401 with a basic authentication header. DCNL realm DCNL A string containing the authentication realm. DCNL users DCNL A dict of the form: {username: password} or a callable returning a dict. DCNL encrypt DCNL callable used to encrypt the password returned from the user-agent. DCNL if None it defaults to a md5 encryption.'
def digest_auth(realm, users, debug=False): DCNL 'If auth fails, raise 401 with a digest authentication header. DCNL realm DCNL A string containing the authentication realm. DCNL users DCNL A dict of the form: {username: password} or a callable returning a dict.'
def json_processor(entity): DCNL 'Read application/json data into request.json.'
def json_in(content_type=[ntou('application/json'), ntou('text/javascript')], force=True, debug=False, processor=json_processor): DCNL 'Add a processor to parse JSON request entities: DCNL The default processor places the parsed data into request.json. DCNL Incoming request entities which match the given content_type(s) will DCNL be deserialized from JSON to the Python equivalent, and the result DCNL stored at cherrypy.request.json. The \'content_type\' argument may DCNL be a Content-Type string or a list of allowable Content-Type strings. DCNL If the \'force\' argument is True (the default), then entities of other DCNL content types will not be allowed; "415 Unsupported Media Type" is DCNL raised instead. DCNL Supply your own processor to use a custom decoder, or to handle the parsed DCNL data differently.  The processor can be configured via DCNL tools.json_in.processor or via the decorator method. DCNL Note that the deserializer requires the client send a Content-Length DCNL request header, or it will raise "411 Length Required". If for any DCNL other reason the request entity cannot be deserialized from JSON, DCNL it will raise "400 Bad Request: Invalid JSON document". DCNL You must be using Python 2.6 or greater, or have the \'simplejson\' DCNL package importable; otherwise, ValueError is raised during processing.'
def json_out(content_type='application/json', debug=False, handler=json_handler): DCNL 'Wrap request.handler to serialize its output to JSON. Sets Content-Type. DCNL If the given content_type is None, the Content-Type response header DCNL is not set. DCNL Provide your own handler to use a custom encoder.  For example DCNL cherrypy.config[\'tools.json_out.handler\'] = <function>, or DCNL @json_out(handler=function). DCNL You must be using Python 2.6 or greater, or have the \'simplejson\' DCNL package importable; otherwise, ValueError is raised during processing.'
def save(): DCNL 'Save any changed session data.'
def close(): DCNL 'Close the session object for this request.'
def init(storage_type='ram', path=None, path_header=None, name='session_id', timeout=60, domain=None, secure=False, clean_freq=5, persistent=True, httponly=False, debug=False, **kwargs): DCNL 'Initialize session object (using cookies). DCNL storage_type DCNL One of \'ram\', \'file\', \'postgresql\', \'memcached\'. This will be DCNL used to look up the corresponding class in cherrypy.lib.sessions DCNL globals. For example, \'file\' will use the FileSession class. DCNL path DCNL The \'path\' value to stick in the response cookie metadata. DCNL path_header DCNL If \'path\' is None (the default), then the response DCNL cookie \'path\' will be pulled from request.headers[path_header]. DCNL name DCNL The name of the cookie. DCNL timeout DCNL The expiration timeout (in minutes) for the stored session data. DCNL If \'persistent\' is True (the default), this is also the timeout DCNL for the cookie. DCNL domain DCNL The cookie domain. DCNL secure DCNL If False (the default) the cookie \'secure\' value will not DCNL be set. If True, the cookie \'secure\' value will be set (to 1). DCNL clean_freq (minutes) DCNL The poll rate for expired session cleanup. DCNL persistent DCNL If True (the default), the \'timeout\' argument will be used DCNL to expire the cookie. If False, the cookie will not have an expiry, DCNL and the cookie will be a "session cookie" which expires when the DCNL browser is closed. DCNL httponly DCNL If False (the default) the cookie \'httponly\' value will not be set. DCNL If True, the cookie \'httponly\' value will be set (to 1). DCNL Any additional kwargs will be bound to the new Session instance, DCNL and may be specific to the storage type. See the subclass of Session DCNL you\'re using for more information.'
def set_response_cookie(path=None, path_header=None, name='session_id', timeout=60, domain=None, secure=False, httponly=False): DCNL 'Set a response cookie for the client. DCNL path DCNL the \'path\' value to stick in the response cookie metadata. DCNL path_header DCNL if \'path\' is None (the default), then the response DCNL cookie \'path\' will be pulled from request.headers[path_header]. DCNL name DCNL the name of the cookie. DCNL timeout DCNL the expiration timeout for the cookie. If 0 or other boolean DCNL False, no \'expires\' param will be set, and the cookie will be a DCNL "session cookie" which expires when the browser is closed. DCNL domain DCNL the cookie domain. DCNL secure DCNL if False (the default) the cookie \'secure\' value will not DCNL be set. If True, the cookie \'secure\' value will be set (to 1). DCNL httponly DCNL If False (the default) the cookie \'httponly\' value will not be set. DCNL If True, the cookie \'httponly\' value will be set (to 1).'
def expire(): DCNL 'Expire the current session cookie.'
def downgrade_wsgi_ux_to_1x(environ): DCNL 'Return a new environ dict for WSGI 1.x from the given WSGI u.x environ.'
def quickstart(root=None, script_name='', config=None): DCNL 'Mount the given root, start the builtin server (and engine), then block. DCNL root: an instance of a "controller class" (a collection of page handler DCNL methods) which represents the root of the application. DCNL script_name: a string containing the "mount point" of the application. DCNL This should start with a slash, and be the path portion of the URL DCNL at which to mount the given root. For example, if root.index() will DCNL handle requests to "http://www.example.com:8080/dept/app1/", then DCNL the script_name argument would be "/dept/app1". DCNL It MUST NOT end in a slash. If the script_name refers to the root DCNL of the URI, it MUST be an empty string (not "/"). DCNL config: a file or dict containing application config. If this contains DCNL a [global] section, those entries will be used in the global DCNL (site-wide) config.'
def _cherrypy_pydoc_resolve(thing, forceload=0): DCNL 'Given an object or a path to an object, get the object and its name.'
def expose(func=None, alias=None): DCNL 'Expose the function, optionally providing an alias or set of aliases.'
def popargs(*args, **kwargs): DCNL 'A decorator for _cp_dispatch DCNL (cherrypy.dispatch.Dispatcher.dispatch_method_name). DCNL Optional keyword argument: handler=(Object or Function) DCNL Provides a _cp_dispatch function that pops off path segments into DCNL cherrypy.request.params under the names specified.  The dispatch DCNL is then forwarded on to the next vpath element. DCNL Note that any existing (and exposed) member function of the class that DCNL popargs is applied to will override that value of the argument.  For DCNL instance, if you have a method named "list" on the class decorated with DCNL popargs, then accessing "/list" will call that function instead of popping DCNL it off as the requested parameter.  This restriction applies to all DCNL _cp_dispatch functions.  The only way around this restriction is to create DCNL a "blank class" whose only function is to provide _cp_dispatch. DCNL If there are path elements after the arguments, or more arguments DCNL are requested than are available in the vpath, then the \'handler\' DCNL keyword argument specifies the next object to handle the parameterized DCNL request.  If handler is not specified or is None, then self is used. DCNL If handler is a function rather than an instance, then that function DCNL will be called with the args specified and the return value from that DCNL function used as the next object INSTEAD of adding the parameters to DCNL cherrypy.request.args. DCNL This decorator may be used in one of two ways: DCNL As a class decorator: DCNL @cherrypy.popargs(\'year\', \'month\', \'day\') DCNL class Blog: DCNL def index(self, year=None, month=None, day=None): DCNL #Process the parameters here; any url like DCNL #/, /2009, /2009/12, or /2009/12/31 DCNL #will fill in the appropriate parameters. DCNL def create(self): DCNL #This link will still be available at /create.  Defined functions DCNL #take precedence over arguments. DCNL Or as a member of a class: DCNL class Blog: DCNL _cp_dispatch = cherrypy.popargs(\'year\', \'month\', \'day\') DCNL The handler argument may be used to mix arguments with built in functions. DCNL For instance, the following setup allows different activities at the DCNL day, month, and year level: DCNL class DayHandler: DCNL def index(self, year, month, day): DCNL #Do something with this day; probably list entries DCNL def delete(self, year, month, day): DCNL #Delete all entries for this day DCNL @cherrypy.popargs(\'day\', handler=DayHandler()) DCNL class MonthHandler: DCNL def index(self, year, month): DCNL #Do something with this month; probably list entries DCNL def delete(self, year, month): DCNL #Delete all entries for this month DCNL @cherrypy.popargs(\'month\', handler=MonthHandler()) DCNL class YearHandler: DCNL def index(self, year): DCNL #Do something with this year DCNL @cherrypy.popargs(\'year\', handler=YearHandler()) DCNL class Root: DCNL def index(self):'
def url(path='', qs='', script_name=None, base=None, relative=None): DCNL 'Create an absolute URL for the given path. DCNL If \'path\' starts with a slash (\'/\'), this will return DCNL (base + script_name + path + qs). DCNL If it does not start with a slash, this returns DCNL (base + script_name [+ request.path_info] + path + qs). DCNL If script_name is None, cherrypy.request will be used DCNL to find a script_name, if available. DCNL If base is None, cherrypy.request.base will be used (if available). DCNL Note that you can use cherrypy.tools.proxy to change this. DCNL Finally, note that this function can be used to obtain an absolute URL DCNL for the current request path (minus the querystring) by passing no args. DCNL If you call url(qs=cherrypy.request.query_string), you should get the DCNL original browser URL (assuming no internal redirections). DCNL If relative is None or not provided, request.app.relative_urls will DCNL be used (if available, else False). If False, the output will be an DCNL absolute URL (including the scheme, host, vhost, and script_name). DCNL If True, the output will instead be a URL that is relative to the DCNL current request path, perhaps including \'..\' atoms. If relative is DCNL the string \'server\', the output will instead be a URL that is DCNL relative to the server root; i.e., it will start with a slash.'
def base64_decode(n, encoding='ISO-8859-1'): DCNL 'Return the native string base64-decoded (as a native string).'
def merge(base, other): DCNL 'Merge one app config (from a dict, file, or filename) into another. DCNL If the given config is a filename, it will be appended to DCNL the list of files to monitor for "autoreload" changes.'
def _server_namespace_handler(k, v): DCNL 'Config handler for the "server" namespace.'
def _engine_namespace_handler(k, v): DCNL 'Backward compatibility handler for the "engine" namespace.'
def _tree_namespace_handler(k, v): DCNL 'Namespace handler for the \'tree\' config namespace.'
def _getargs(func): DCNL 'Return the names of all static arguments to the given function.'
def namedtuple(typename, field_names, verbose=False, rename=False): DCNL 'Returns a new subclass of tuple with named fields. DCNL >>> Point = namedtuple(\'Point\', [\'x\', \'y\']) DCNL >>> Point.__doc__                   # docstring for the new class DCNL \'Point(x, y)\' DCNL >>> p = Point(11, y=22)             # instantiate with positional args or keywords DCNL >>> p[0] + p[1]                     # indexable like a plain tuple DCNL 33 DCNL >>> x, y = p                        # unpack like a regular tuple DCNL >>> x, y DCNL (11, 22) DCNL >>> p.x + p.y                       # fields also accessable by name DCNL 33 DCNL >>> d = p._asdict()                 # convert to a dictionary DCNL >>> d[\'x\'] DCNL 11 DCNL >>> Point(**d)                      # convert from a dictionary DCNL Point(x=11, y=22) DCNL >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields DCNL Point(x=100, y=22)'
def update_default_args(defaults, updates): DCNL 'Takes a list of default arguments and overwrites the defaults with DCNL contents of updates. DCNL e.g.: DCNL update_default_args(["--somearg=default"], ["--somearg=overwritten"]) DCNL => ["--somearg=overwritten"] DCNL This is done to avoid defining all known django command line arguments, DCNL we just want to proxy things and update with our own default values without DCNL looking into django.'
def get_size(start_path): DCNL 'Utility function, returns the size (bytes) of a folder'
def read_pid_file(filename): DCNL 'Reads a pid file and returns the contents. Pid files have 1 or 2 lines; the first line is always the pid, and the DCNL optional second line is the port the server is listening on. DCNL :param filename: Filename to read DCNL :return: the tuple (pid, port) with the pid in the file and the port number if it exists. If the port number doesn\'t DCNL exist, then port is None.'
def get_pid(): DCNL 'Tries to get the PID of a server. DCNL TODO: This function has for historical reasons maintained to try to get DCNL the PID of a KA Lite server without a PID file running on the same port. DCNL The behavior is to make an HTTP request for the PID on a certain port. DCNL This behavior is stupid, because a KA lite process may just be part of a DCNL process pool, so it won\'t be able to tell the correct PID for sure, DCNL anyways. DCNL The behavior is also quite redundant given that `kalite start` should always DCNL create a PID file, and if its been started directly with the runserver DCNL command, then its up to the developer to know what\'s happening. DCNL :returns: (PID of running server, address, port) DCNL :raises: NotRunning'
def manage(command, args=None, as_thread=False): DCNL 'Run a django command on the kalite project DCNL :param command: The django command string identifier, e.g. \'runserver\' DCNL :param args: List of options to parse to the django management command DCNL :param as_thread: Runs command in thread and returns immediately'
def start(debug=False, watch=False, daemonize=True, args=[], skip_job_scheduler=False, port=None): DCNL 'Start the kalite server as a daemon DCNL :param args: List of options to parse to the django management command DCNL :param port: Non-default port to bind to. You cannot run kalite on DCNL multiple ports at the same time. DCNL :param daemonize: Default True, will run in foreground if False DCNL :param skip_job_scheduler: Skips running the job scheduler in a separate thread'
def stop(args=[], sys_exit=True): DCNL 'Stops the kalite server, either from PID or through a management command DCNL :param args: List of options to parse to the django management command DCNL :raises: NotRunning'
def get_urls(): DCNL 'Fetch a list of urls DCNL :returns: STATUS_CODE, [\'http://abcd:1234\', ...]'
def get_urls_proxy(output_pipe=sys.stderr): DCNL 'Get addresses of the server if we\'re using settings.PROXY_PORT DCNL :raises: Exception for sure if django.conf.settings isn\'t loaded'
def status(): DCNL 'Check the server\'s status. For possible statuses, see the status dictionary DCNL status.codes DCNL Status *always* outputs the current status in the first line if stderr. DCNL The following lines contain optional information such as the addresses where DCNL the server is listening. DCNL :returns: status_code, key has description in status.codes'
def diagnose(): DCNL 'This command diagnoses an installation of KA Lite DCNL It has to be able to work with instances of KA Lite that users do not DCNL actually own, however it\'s assumed that the path and the \'kalite\' commands DCNL are configured and work. DCNL The function is currently non-robust, meaning that not all aspects of DCNL diagnose data collection is guaranteed to succeed, thus the command could DCNL potentially fail :( DCNL Example: KALITE_HOME=/home/otheruser/.kalite kalite diagnose --port=7007'
def url(): DCNL 'Check the server\'s status. For possible statuses, see the status dictionary DCNL status.codes DCNL :returns: status_code, key has description in status.codes'
def docopt(doc, argv=None, help=True, version=None, options_first=False): DCNL 'Re-implementation of docopt.docopt() function to parse ANYTHING at DCNL the end (for proxying django options).'
def _parse_focus(arg_str): DCNL 'Returns id and annotation after splitting input string. DCNL First argument should be the jQuery-style selector. An optional DCNL annotation can follow if separated by a separator \'|\'. Initial DCNL whitespace after the \'|\' will be ignored. DCNL Example inputs: DCNL #an_id DCNL #another_id | With an annotation DCNL form.foo input.radio | The quick brown fox'
def _parse_command(command): DCNL '" Parses a command into action and options. DCNL Returns a dictionary with following keys: DCNL selector (string): the selector to identify the element DCNL action (string): the action type (if it\'s recognized) DCNL options (list): a list of options DCNL Raises an error if action type is not recognized or if options are invalid. DCNL Example inputs: DCNL #sync_button click DCNL NEXT send_keys some keys DCNL NEXT send_keys special characters like TAB and ENTER can be used like this DCNL Note that \'TAB\', \'ENTER\', and \'BACKSPACE\' all have special meaning for send_keys'
def _parse_login(username, password, submit=''): DCNL '" Parses a LOGIN command. DCNL Returns a dictionary with following keys: DCNL runhandler (string):  "_login_handler". DCNL args (dict) : A dictionary of arguments with following keys: DCNL username (string):  the username. DCNL password (string): password. DCNL submit (bool): True if login form is to be submitted, false otherwise.'
def _parse_nav_steps(arg_str): DCNL 'Here\'s how to specify the navigation steps: DCNL 1. selector action [options] ["|" selector action [options]] ... DCNL 2. aliased_action_sequence [options] DCNL An explanation of navigation steps follows. Some examples can be found DCNL in ss_examples.rst in this directory. DCNL Selector is a single selector (no whitespace allowed). DCNL If it starts with \'#\', we\'ll attempt to find the given id. DCNL If it starts with \'.\', we\'ll attempt to find the given class. DCNL If it starts with \'//\', we\'ll attempt to find by xpath. Avoid absolute xpaths. DCNL "NEXT", which just sends a tab keystroke DCNL "SAME", which just stays focused on the element from the last action DCNL Where action could be one of "click", "send_keys", or "submit": DCNL click has no options and just clicks the element DCNL send_keys sends a sequence of keystrokes specified as a string by options DCNL submit submits a form and has no options DCNL Multiple actions on a page can be specified by putting a | separator, DCNL and specifying the action using the same syntax. DCNL aliased_action_sequence is one of a reserved keyword which aliases a common DCNL sequence of actions as above (or performs special actions unavailable by DCNL the regular syntax) potentially with options. Available aliases: DCNL LOGIN username password [submit], which just navigates to the login page DCNL and inputs the given username and password. Submits the form is submit DCNL is present, otherwise not. DCNL Returns a dictionary with: DCNL runhandler: reference to function invoked in the run method DCNL args:       a dictionary of arguments passed to the runhandler function'
def test_parse_focus(): DCNL 'Test screenshot._parse_focus() function.'
def test_parse_command(): DCNL 'Test screenshot._parse_command() function. DCNL Tests cases where the command completes successfully. Cases in which DCNL exceptions are raised are handled separately.'
@raises(ActionError) DCNL def test_parse_command_action_error(): DCNL 'Test ActionError(s) raised by screenshot._parse_command() function.'
@raises(OptionError) DCNL def test_parse_command_option_error(): DCNL 'Test OptionError(s) raised by screenshot._parse_command() function.'
def test_parse_login(): DCNL 'Test screenshot._parse_login() function.'
def test_parse_nav_steps(): DCNL 'Test screenshot._parse_nav_steps() function.'
def filter_requirement_statements(req): DCNL 'Filter comments and blank lines from a requirements.txt like file DCNL content to feed pip'
def enable_log_to_stdout(logname): DCNL 'Given a log name, outputs > INFO to stdout.'
def get_installed_packages(): DCNL 'Avoid depending on pip for this task'
def gen_data_files(*dirs, **kwargs): DCNL 'We can only link files, not directories. Therefore, we use an approach DCNL that scans all files to pass them to the data_files kwarg for setup(). DCNL Thanks: http://stackoverflow.com/a/7288382/405682'
def narrative_view(request, narrative_id): DCNL ':param request: the request DCNL :param narrative_id: the narrative id, a url to be matched DCNL :return: a serialized JSON blob of the narrative dict'
@given("I've DCSP started DCSP the DCSP intro") DCNL def step_impl(context): DCNL 'Start the intro and add some elements to the context.'
@set_database DCNL def setup_content_paths(context, db): DCNL 'Creaters available content items and adds their urls to the context object. DCNL :param context: A behave context, to which the attributes "available_content_path" and "unavailable_content_path" DCNL will be added. DCNL :return: None'
@set_database DCNL def teardown_content_paths(context, db): DCNL 'The opposite of ``setup_content_urls``. Removes content items created there. DCNL :param context: A behave context, which keeps a reference to the Items so we can clean them up. DCNL :return: None.'
def setup_sauce_browser(context): DCNL 'Use saucelabs remote webdriver. Has side effects on the passed in behave context. DCNL :param context: the behave context DCNL :return: none, but has side effects. Adds properties "sauce" and "browser" to context.'
def setup_local_browser(context): DCNL 'Use local webdriver. Has side effects on the passed in behave context. DCNL :param context: the behave context DCNL :return: none, but has side effects. Adds property "browser" to context.'
def database_setup(context): DCNL 'Behave features are analogous to test suites, and behave scenarios are analogous to TestCases, but due to DCNL implementation details each _feature_ is wrapped in a TestCase. This and database_teardown should simulate the DCNL setup/teardown done by TestCases in order to achieve consistent isolation.'
def database_teardown(context): DCNL 'Behave features are analogous to test suites, and behave scenarios are analogous to TestCases, but due to DCNL implementation details each _feature_ is wrapped in a TestCase. This and database_setup should simulate the DCNL setup/teardown done by TestCases in order to achieve consistent isolation.'
def do_fake_registration(): DCNL 'Register the device, in case some feature being tested depends on it. Will be undone by the database teardown.'
@render_to('distributed/loadtesting/load_test.html') DCNL def load_test(request, nusers=None): DCNL 'The principal purpose of this view is to allow the automated testing of multiple clients DCNL connected to the server at once, interacting in a way that is at least somewhat representative DCNL of normal user behaviour. DCNL As such, navigating to the loadtesting page on a client device will load an iframe which will DCNL then use Javascript to automate user interaction with the site. It will try to watch videos and DCNL do exercises in rapid succession in order to put strain on the server and associated network DCNL connections. DCNL So far the principal use for this has been testing with 30+ tablets connected over WiFi to a DCNL server and seeing if the server and wireless connection can handle the strain.'
def rgba_to_hex(rgba_string): DCNL 'Returns an uppercase HEX representation of an rgba(xxx, yyy, zzz, a) string'
def _assert_no_element_by(context, by, value, wait_time=MAX_WAIT_FOR_UNEXPECTED_ELEMENT): DCNL 'Raises a TimeoutException if the element is *still* found after wait_time seconds. DCNL :param context: A behave context DCNL :param by: selenium.webdriver.common.by.By constant DCNL :param value: A value to go with by, to build a locator DCNL :param wait_time: The wait time in seconds. DCNL :return: Nothing, or raises a TimeoutException.'
def assert_no_element_by_id(context, _id, wait_time=MAX_WAIT_FOR_UNEXPECTED_ELEMENT): DCNL 'Assert that no element is found. Use a wait in case the element currently exists DCNL on the page, and we want to wait for it to disappear before doing the assert. DCNL Finds the element using an id.'
def assert_no_element_by_css_selector(context, css_value, wait_time=MAX_WAIT_FOR_UNEXPECTED_ELEMENT): DCNL 'Assert that no element is found. Use a wait in case the element currently exists DCNL on the page, and we want to wait for it to disappear before doing the assert. DCNL Finds the element using a CSS Selector.'
def assert_no_element_by_xpath_selector(context, xpath, wait_time=MAX_WAIT_FOR_UNEXPECTED_ELEMENT): DCNL 'Assert that no element is found. Use a wait in case the element currently exists DCNL on the page, and we want to wait for it to disappear before doing the assert. DCNL Finds the element using XPATH.'
def click_and_wait_for_page_load(context, elem, wait_time=MAX_PAGE_LOAD_TIME): DCNL 'Click an element and then wait for the page to load. Does this by DCNL first getting an element on the page, clicking, and then waiting for the DCNL reference to become stale. If the element doesn\'t become stale then it throws DCNL a TimeoutException. (So if you pass an element to click that doesn\'t cause a DCNL page load, then you\'ll probably get a TimeoutException.) DCNL context: a behave context DCNL elem: a WebElement to click. DCNL wait_time: Optional. Max wait time for the page to load. Has a default value.'
def click_and_wait_for_id_to_appear(context, elem_click, elem_wait, wait_time=MAX_WAIT_TIME): DCNL 'Click an element and then wait for another element to appear. DCNL context: a behave context DCNL elem_click: a WebElement to click. DCNL elem_wait: an ID selector to wait for. DCNL wait_time: Optional. Has a default value.'
def elem_is_invisible_with_wait(context, elem, wait_time=MAX_WAIT_TIME): DCNL 'Waits for the element to become invisible DCNL context: a behave context DCNL elem: a WebDriver element DCNL wait_time: sets the max wait time. Optional, but has a default value. DCNL Returns True if the element is invisible or stale, otherwise waits and returns False'
def elem_is_visible_with_wait(context, elem, wait_time=MAX_WAIT_TIME): DCNL 'Waits for the element to become visible. Will try to scroll the element DCNL into view. DCNL context: a behave context DCNL elem: a WebDriver element DCNL wait_time: sets the max wait time. Optional, but has a default value. DCNL Returns True if the element is visible, otherwise waits and returns False'
def find_css_class_with_wait(context, css_class, **kwargs): DCNL 'Tries to find an element with given css class with an explicit timeout. DCNL context: a behave context DCNL css_class: A string with the css class (no leading .) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconds. Default is defined by behave_helpers.py DCNL Returns the element if found or raises TimeoutException'
def find_clickable_id_with_wait(context, id_str, **kwargs): DCNL 'Tries to find an element with given id with an explicit timeout. DCNL context: a behave context DCNL id_str: A string with the id (no leading #) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconds. Default is defined by behave_helpers.py DCNL Returns the element if found or raises TimeoutException'
def find_id_with_wait(context, id_str, **kwargs): DCNL 'Tries to find an element with given id with an explicit timeout. DCNL context: a behave context DCNL id_str: A string with the id (no leading #) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconds. Default is defined by behave_helpers.py DCNL Returns the element if found or raises TimeoutException'
def id_shown_with_wait(context, id_str, **kwargs): DCNL 'Tries to find an element with given id with an explicit timeout. DCNL context: a behave context DCNL id_str: A string with the id (no leading #) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconds. Default is defined by behave_helpers.py DCNL Returns the element if found or None'
def find_xpath_with_wait(context, id_str, **kwargs): DCNL 'Tries to find an element with given XPATH with an explicit timeout. DCNL context: a behave context DCNL id_str: A string with the XPATH (no leading #) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconds. Default is defined by behave_helpers.py DCNL Returns the element if found or raises TimeoutException'
def find_css_with_wait(context, id_str, **kwargs): DCNL 'Tries to find an element with given css selector with an explicit timeout. DCNL context: a behave context DCNL id_str: A string with the CSS Selector DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconds. Default is defined by behave_helpers.py DCNL Returns the element if found or raises TimeoutException'
def _find_elem_with_wait(context, by, wait_time=MAX_WAIT_TIME): DCNL 'Tries to find an element with an explicit timeout. DCNL "Private" function to hide Selenium details. DCNL context: a behave context DCNL by: A tuple selector used by Selenium DCNL wait_time: The max time to wait in seconds DCNL Returns the element if found or raises TimeoutException'
def _find_clickable_elem_with_wait(context, by, wait_time=MAX_WAIT_TIME): DCNL 'Tries to find an enabled element with an explicit timeout. DCNL "Private" function to hide Selenium details. DCNL context: a behave context DCNL by: A tuple selector used by Selenium DCNL wait_time: The max time to wait in seconds DCNL Returns the element if found or raises TimeoutException'
def _shown_elem_with_wait(context, by, wait_time=MAX_WAIT_TIME): DCNL 'Tries to find an element with an explicit timeout. DCNL Tries to scroll to an element and uses WebElement.is_displayed() DCNL "Private" function to hide Selenium details. DCNL context: a behave context DCNL by: A tuple selector used by Selenium DCNL wait_time: The max time to wait in seconds DCNL Returns the element if found or None'
def build_url(context, url, params=None): DCNL 'Build a full url given a relative url, using the test server\'s address & port DCNL :param context: behave context DCNL :param url: a relative url, like "/learn" or "/my/cool/page" to append to the test server\'s address DCNL :param params: a dictionary of GET parameters, which will be appended to the url. If empty, nothing changes. DCNL :return: The full url'
def _login_user(context, username, password, facility=None): DCNL 'Logs a user in (either User of FacilityUser) with an api endpoint. DCNL "Private" function to hide details, use login_as_* functions instead.'
def login_as_learner(context, learner_name='mrpibb', learner_pass='abc123'): DCNL 'Log in as a learner specified by the optional arguments, or create DCNL such a user and log in if it doesn\'t exist. DCNL :context: a behave context, used for its browser DCNL :learner_name: optional. username of the learner. DCNL :learner_pass: optional. password of the learner.'
def login_as_coach(context, coach_name='mrpibb', coach_pass='abc123'): DCNL 'Log in as a coach specified by the optional arguments, or create DCNL such a user and log in if it doesn\'t exist. DCNL :context: a behave context, used for its browser DCNL :coach_name: optional. username of the coach. DCNL :coach_pass: optional. password of the coach.'
def login_as_admin(context, admin_name='admin', admin_pass='abc123'): DCNL 'Log in as an admin specified by the optional arguments, or create DCNL such a user and log in if it doesn\'t exist. DCNL :context: a behave context, used for its browser DCNL :admin_name: optional. username of the admin. DCNL :admin_pass: optional. password of the admin.'
def post(context, url, data=''): DCNL 'Sends a POST request to the testing server associated with context DCNL context: A `behave` context DCNL url: A relative url, i.e. "/zone/management/None" or "/securesync/logout" DCNL data: A string containing the body of the request DCNL Returns the response.'
def get(context, url, data=''): DCNL 'Sends a GET request to the testing server associated with context DCNL context: A `behave` context DCNL url: A relative url, i.e. "/zone/management/None" or "/securesync/logout" DCNL data: A string containing the body of the request DCNL Returns the response.'
def request(context, url, method='GET', data=''): DCNL 'Make a request to the testing server associated with context DCNL context: A `behave` context DCNL url: A relative url, i.e. "/zone/management/None" or "/securesync/logout" DCNL method: The HTTP method to use, i.e. GET, POST DCNL data: A string containing the serialized JSON body of the request DCNL Returns the response.'
def wait_for_video_player_ready(context, wait_time=MAX_WAIT_TIME): DCNL 'If you\'re on the "Learn" page with video content, wait until the video player is "ready". DCNL Specifically, wait until the VideoPlayerView has been initialized, so we can safely trigger events on it. DCNL :return: Nothing DCNL :raises: A TimeoutException if the video player never loads'
def setup_browser(browser_type='Firefox'): DCNL 'Setup the browser. `browser_type` sets up the type of browser loaded by selenium.'
def hacks_for_phantomjs(browser): DCNL 'HACK: If using PhantomJS, override the window.alert()/confirm()/prompt() functions to return true because DCNL the GhostDriver does not support modal dialogs (alert, confirm, prompt). DCNL What we do is override the alert/confirm/prompt functions so any call that expects the dialog with return true. DCNL REF: http://stackoverflow.com/questions/15708518/how-can-i-handle-an-alert-with-ghostdriver-via-python DCNL REF: https://groups.google.com/forum/#!topic/phantomjs/w_rKkFJ0g8w DCNL REF: http://stackoverflow.com/questions/13536752/phantomjs-click-a-link-on-a-page?rq=1'
def browse_to(browser, dest_url, wait_time=0.1, max_retries=50): DCNL 'Browse to the given url, or do nothing if browser.current_url == dest_url DCNL :param browser: a WebDriver instance. DCNL :param dest_url: a string. the destination url. DCNL :param wait_time: unused. kept for compatibility. DCNL :param max_retries: unused. kept for compatibility. DCNL :return: true, always. Used to return the value of wait_for_page_change, but WebDriver.get DCNL _already_ waits for the page to finish loading.'
def wait_for_page_change(browser, source_url=None, page_source=None, wait_time=0.1, max_retries=50): DCNL 'Given a selenium browser, wait until the browser has completed. DCNL Code taken from: https://github.com/dragoon/django-selenium/blob/master/django_selenium/testcases.py'
def central_server_only(handler): DCNL 'Assert-like decorator that marks a function for use only on the central server.'
def distributed_server_only(handler): DCNL 'Assert-like decorator that marks a function for use only on a distributed server.'
def get_features(app_module): DCNL 'Used to find feature directories for behave tests.'
def check_feature_file(features_dir, feature_name): DCNL 'Used to check if a feature_name is in the specified features_dir'
def check_setup_status(handler): DCNL 'Decorator for validating that KA Lite post-install setup has completed. DCNL NOTE that this decorator must appear before  the backend_cache_page decorator, DCNL so that it is run even when there is a cache hit.'
@render_to('distributed/learn.html') DCNL def learn(request): DCNL 'Render the all-in-one sidebar navigation/content-viewing app.'
@check_setup_status DCNL @render_to('distributed/homepage.html') DCNL def homepage(request): DCNL 'Homepage.'
@require_admin DCNL def zone_redirect(request): DCNL 'Dummy view to generate a helpful dynamic redirect to interface with \'control_panel\' app'
@require_admin DCNL def device_redirect(request): DCNL 'Dummy view to generate a helpful dynamic redirect to interface with \'control_panel\' app'
def crypto_login(request): DCNL 'Remote admin endpoint, for login to a distributed server (given its IP address; see central/views.py:crypto_login) DCNL An admin login is negotiated using the nonce system inside SyncSession'
def get_messages_for_api_calls(request): DCNL 'Re-usable function that returns a list of messages to be used by API calls.'
def main(): DCNL 'Handle running this program from the command-line.'
def _slurp(filename): DCNL 'Read in the entire contents of a file, return as a string.'
def close_issue(issue, github_auth): DCNL 'Attempt to close an issue and return whether it succeeded.'
def post_issue_comment(issue, comment_text, github_auth): DCNL 'Attempt to post an issue comment and return whether it succeeded.'
def main(): DCNL 'Handle running this program from the command-line.'
def lint_file(filename, apply_fix, verbose): DCNL 'Fix a single HTML exercise repairing invalid nodes. DCNL Returns an array of node tuples which cannot be fixed automatically and DCNL must be fixed by hand. Nodes that can be fixed automatically are fixed DCNL and the file is updated, if apply_fix is set to True. DCNL Arguments: DCNL - filename: A string filename to parse DCNL - apply_fix: If True, then filename is replaced with new contents, DCNL which is the fixed version of the old contents. DCNL - verbose: If there should be any output DCNL Returns: DCNL - A tuple (errors, num_nodes_changed) which contains `errors`, DCNL which is a list holding strings describing errors found in the file DCNL and `num_nodes_changed` which is a number counting how many nodes DCNL were changed by the script (or could\'ve been changed, if the DCNL apply_fix flag is set to False).'
def get_plural_form(word): DCNL 'Prompt the user for help getting the correct plural form for a word. DCNL Plain strings are frequently pluralized in exercises (even though the DCNL result can easily be hardcoded). This function helps with that process DCNL by taking a singular form of a string and prompting the user to help DCNL provide the correct plural form of that string. DCNL By default the user is given a prompt for the plural form of a word DCNL in the format: word + "s" (since that\'s the most common pluralization DCNL form). A user can just hit enter to accept that format or enter another DCNL pluralization form. DCNL Returns the plural form of the input word.'
def get_plural_num_pos(match): DCNL 'Prompt to user for help in determining which argument to plural() DCNL is the one that holds the number. DCNL For example a call such as: `plural(VAR_A,VAR_B)` is ambiguous. It\'s DCNL not clear which argument is the one which holds the string and which holds DCNL the number so we need user input to determine that. DCNL Returns a number: 1 if the number is in the first position, 2 if it\'s in DCNL the second position.'
def get_is_plural_num(match): DCNL 'Prompt to user for help in determining if the argument to plural() DCNL is a number. DCNL For example a call such as: `plural(VAR_A)` is ambiguous. It\'s not clear DCNL if the input is a number or a string so we need user input to determine DCNL that. DCNL Returns True if the argument is a number.'
def _check_plural_arg_is_num(plural_arg): DCNL 'Check to see if a string matches the known ways in which a plural DCNL argument can be a number. DCNL Returns True if the argument is a number, returns False if the argument DCNL is a string. Returns None if the case is ambiguous.'
def _check_plural_is_ambiguous(plural_arg): DCNL 'Check to see if a string is ambiguously named. DCNL We do this so that we can mark up the string with a large warning function DCNL call like AMBIGUOUS_PLURAL and report an error to the user. DCNL This case of ambiguity is knowing if the text contents of a text argument DCNL is able to be pluralized, or not. Right now the only case where this is DCNL true is for the built-in string functions, like item(1). Pretty much DCNL anything else fails this case. I should mention that it\'s totally possible DCNL that the dev has marked the string up to be pluralizable but we just can\'t DCNL determine that from our analysis here. The only way we can determine this DCNL is to explicitly require the dev to rewrite the function signature to DCNL something else. This is why the function call is mutated into the obvious DCNL AMBIGUOUS_PLURAL and requires that the user manually convert it into the DCNL form plural_form(TEXT_VAR, NUM_VAR). It\'s assumed that anything using the DCNL plural_form() function is in fact pluralizable (if it\'s not that call is DCNL going to generate an error to the console). DCNL For example given the expression: DCNL <var>plural(ITEM, NUM)</var> DCNL We\'ve already determined that the first argument, ITEM, holds a string via DCNL _check_plural_arg_is_num. However we DON\'T know if the argument has been DCNL properly marked up using the new `new Plural()` utility. Because of this DCNL we want to return False for any any string arguments that we don\'t care DCNL about marking up (namely string literals and the built-in functions, which DCNL are already marked up) and return True for everything else (which will DCNL likely be variables or user-defined function calls that hold strings). DCNL This will allow us to convert the above expression into the following at a DCNL later time: DCNL <var>AMBIGUOUS_PLURAL(ITEM, NUM)</var> DCNL Some of this logic has been copied, and adapted, from DCNL _check_plural_arg_is_num.'
def _extract_nodes(html_tree, filename): DCNL 'Extract all the i18n-able nodes out of a file.'
def _replace_node(node, replace_node): DCNL 'A utility method for replacing a node with another node. DCNL The other node can optionally be a text string.'
def _parse_single_node(text): DCNL 'Parse a single html node from a string into a tree'
def _get_outerhtml(html_node): DCNL 'Get a string representation of an HTML node. DCNL (lxml doesn\'t provide an easy way to get the \'innerHTML\'.) DCNL Note: lxml also includes the trailing text for a node when you DCNL call tostring on it, we need to snip that off too.'
def _get_innerhtml(html_node): DCNL 'Get a string representation of the contents of an HTML Node DCNL This takes the outerhtml and pulls the two tags surrounding it off'
def get_page_html(html_tree): DCNL 'Return an HTML string representing an lxml tree.'
def _clean_data_if(match): DCNL 'Clean up entities in data-if attributes. DCNL This is done purely to aid in readability. In an attribute it\'s possible to DCNL have < > and & exist un-escaped so we covert them to be as such. Helps to DCNL make the contents easier to understand. DCNL lxml will do the encoding automatically so we actually revert that using DCNL this method.'
def prompt_user(prompt, default=''): DCNL 'Utilty for displaying a prompt and getting the results from a user. DCNL Uses the global SHOW_PROMPT to determine if the prompt should be shown DCNL to the user or if it should fall back to the specified default. DCNL Arguments: DCNL - prompt: A string to display as the user prompt. DCNL - default: The result string to fall back to if no response is given. DCNL Returns: DCNL - A string containing the response from the user.'
def enter_star_ratings(context, val=3): DCNL 'Enters a value for all three star rating forms, on a new form DCNL :param context: behave context DCNL :return: nothing'
def rate_id(context, id_, val=3): DCNL 'Enter a star rating given the id of the container DCNL :param context: behave context DCNL :param id: id of the container element'
def enter_text_feedback(context, text_feedback): DCNL 'Enter text feedback into feedback form DCNL :param context: behave context DCNL :param text_feedback: str, the feedback to be entered DCNL :return: nothing'
def get_text_feedback(context): DCNL 'Get the text feedback displayed after the feedback form is filled out DCNL :param context: behave context DCNL :return: a str with the text feedback displayed.'
def unregister_distributed_server(): DCNL 'All local steps necessary for unregistering a server with a central server. DCNL Note that the remote steps (central-server-side) are NOT done. DCNL * Login as Django admin, go to admin page, select "devices", find your device and delete.'
def clean_db(): DCNL 'Delete kalite data associated with Zone, Facility and Device DCNL Does not remove the django admin accounts etc.'
def clean_pyc(path): DCNL 'Delete all *pyc files recursively in a path'
def reset_sqlite_database(username=None, email=None, password=None, router=None, verbosity='1'): DCNL 'Resets the currently used sqlite database.  Creates the user if admin_username is passed. DCNL :param username: If present, creates a superuser with this username. DCNL :param email: If present, creates a superuser with this email. DCNL :param password: If present, creates a superuser with this password. DCNL :param router: The database router to use. DCNL :return: Returns the superuser created or None if no arguments are provided.'
def delete_sqlite_database(database=None, verbosity='1'): DCNL 'Delete the specified sqlite database or if None, the one on `settings.py` of the app or project. DCNL :param database: The database filename with full path.'
def yml_to_json(filename): DCNL 'Convert a .yml file into a json file and save it to the same DCNL directory.'
@require_login DCNL def update_all_distributed(request): DCNL ''
@csrf_exempt DCNL def update_all_distributed_callback(request): DCNL ''
def whitewash_node_data(node, path='', channel_data=None): DCNL 'Utility function to convert nodes into the format used by KA Lite. DCNL Extracted from other functions so as to be reused by both the denormed DCNL and fully inflated exercise and video nodes.'
def rebuild_topictree(remove_unknown_exercises=False, remove_disabled_topics=True, whitewash_node_data=whitewash_node_data, retrieve_API_data=retrieve_API_data, channel_data={}, channel=None): DCNL 'Downloads topictree (and supporting) data and uses it to DCNL rebuild the KA Lite topictree cache (topics.json). DCNL Does this by collecting all relevant topic_tree and content data from data source. DCNL Recurses over the entire topic tree to remove extraneous data. DCNL Denorms content data to reduce the bulk of the topic tree. DCNL Adds position data to every node in the topic tree.'
def build_full_cache(items, id_key='id', ids=None): DCNL 'Uses list of items retrieved from building the topic tree DCNL to create an item cache with look up keys.'
def construct_node(location, parent_path, node_cache, channel): DCNL 'Return list of dictionaries of subdirectories and/or files in the location'
def channel_data_files(dest=None): DCNL 'Copies all remaining files to appropriate channel data directory'
def set_language_data_from_request(request): DCNL 'Process requests to set language, redirect to the same URL to continue processing DCNL without leaving the "set" in the browser history.'
def get_locale_path(lang_code=None): DCNL 'returns the location of the given language code, or the default locale root DCNL if none is provided.'
def get_po_filepath(lang_code, filename=None): DCNL 'Return the LC_MESSAGES directory for the language code, with an optional filename appended.'
def get_langcode_map(lang_name=None, force=False): DCNL ''
def get_subtitle_file_path(lang_code=None, youtube_id=None): DCNL 'Both central and distributed servers must make these available DCNL at a web-accessible location. DCNL Now, they share that location, which was published in 0.10.2, and so cannot be changed DCNL (at least, not from the central-server side) DCNL Note also that it must use the django-version language code.'
def get_code2lang_map(lang_code=None, force=False): DCNL 'Given a language code, returns metadata about that language.'
def get_language_name(lang_code, native=None, error_on_missing=False): DCNL 'Return full English or native language name from ISO 639-1 language code; raise exception if it isn\'t hardcoded yet'
def convert_language_code_format(lang_code, for_django=True): DCNL 'Return language code for lookup in local dictionary. DCNL Note: For language codes with localizations, Django requires the format xx_XX (e.g. Spanish from Spain = es_ES) DCNL not: xx-xx, xx-XX, xx_xx.'
def outdated_langpacks(): DCNL 'Function that returns a list of languages (full metadata) that needs to be DCNL upgraded to the latest version. Returns an empty list if all languages are DCNL upgraded to this release\'s version.'
def _get_installed_language_packs(): DCNL 'On-disk method to show currently installed languages and meta data.'
def get_default_language(): DCNL 'Returns: the default language (ietf-formatted language code)'
def set_default_language(lang_code): DCNL 'Sets the default language'
def update_jsi18n_file(code='en'): DCNL 'For efficieny\'s sake, we want to cache Django\'s DCNL js18n file.  So, generate that file here, then DCNL save to disk--it won\'t change until the next language pack update!'
def select_best_available_language(target_code, available_codes=None): DCNL 'Critical function for choosing the best available language for a resource, DCNL given a target language code. DCNL This is used by video and exercise pages, for example, DCNL to determine what file to serve, based on available resources DCNL and the current requested language.'
def download_content_pack(fobj, lang, minimal=False): DCNL 'Given a file object where the content pack lang will be stored, return a DCNL zipfile object pointing to the content pack. DCNL If minimal is set to True, append the "-minimal" flag when downloading the DCNL contentpack.'
def extract_content_db(zf, lang, is_template=False): DCNL ':param: as_template: Extracts the result to the template destination, DCNL intended for source distribution'
def i18nize_parser(parse_dir, extensions, parse_file, ignores): DCNL 'Call the `i18nize-templates` script which will parse the DCNL files with the extensions specified.'
def is_ignored(filepath, ignores): DCNL 'Check to see if one of the elements in ignores is part of the filepath.'
def _is_central_object_admin(object_list, bundle): DCNL 'Return true if the central server user is allowed to access the objects'
def _user_is_admin(object_list, bundle): DCNL 'Returns True if and only if the currently logged in user is an admin/teacher.'
def open_json_or_yml(file_name): DCNL 'Try to load either the JSON or YAML version of a file. DCNL If DEBUG is True, try to load the file with a yml prefix. If DCNL DEBUG = False, try to load the json version first. DCNL Args: DCNL file_name: The name of the file to be loaded. DCNL Returns: DCNL A dictionary structure that reflects the yaml structure.'
def get_user_from_request(handler=None, request=None, *args, **kwargs): DCNL 'Gets ID of requested user (not necessarily the user logged in)'
def require_login(handler): DCNL '(Level 1) Make sure that a user is logged in to the distributed server.'
def require_admin(handler): DCNL 'Level 2: Require an admin: DCNL * Central server: any user with an account DCNL * Distributed server: any Django admin or teacher. DCNL Note: different behavior for api_request or not DCNL Note2: we allow users to \'access themselves\''
def require_authorized_access_to_student_data(handler): DCNL 'WARNING: this is a crappy function with a crappy name. DCNL This should only be used for limiting data access to single-student data. DCNL Students requesting their own data (either implicitly, without querystring params) DCNL or explicitly (specifying their own user ID) get through. DCNL Admins and teachers also get through.'
def require_authorized_admin(handler): DCNL 'Level 1.5 or 2.5 :) : require an admin user that has access to all requested objects. DCNL Central server: this is by organization permissions. DCNL Distributed server: you have to be an admin (Django admin/teacher), or requesting only your own user data. DCNL For testing purposes: DCNL * distributed server: superuser, teacher, student DCNL * central server: device not on zone/org, facility not on zone/org, zone not in org, zone with one org, zone with multi orgs, etc'
def require_superuser(handler): DCNL 'Level 4: require a Django admin (superuser) DCNL *** Note: Not yet used, nor tested. ***'
def deprecated(func): DCNL 'Signals in stdout if we\'re using a deprecated function.'
@contextmanager DCNL def inside_transaction(): DCNL 'Perform the database operations inside a transaction.  This is a DCNL basic reimplementation of django.db.transactions.atomic, which isn\'t DCNL present in django 1.5.'
def get_resume_recommendations(user, request): DCNL 'Get the recommendation for the Resume section. DCNL Logic: DCNL Find the most recent incomplete item (video or exercise) and DCNL return that as the recommendation. DCNL Args: DCNL user -- The current user as a facility user model object.'
def get_completed_exercises(user): DCNL 'Return a list of all completed exercises (ids) by user.'
def get_next_recommendations(user, request): DCNL 'Get the recommendations for the Next section, and return them as a list. DCNL Logic: DCNL Next recommendations are currently comprised of 3 main subgroups: group recommendations, DCNL struggling exercises, and topic tree based data. Group recommendations consist of DCNL finding the most common item tackled immediately after the most recent item, struggling DCNL is determined by the "struggling" model attribute, and topic tree data is based off DCNL the graphical distance between neighboring exercise/topic nodes. DCNL Args: DCNL user -- The current user as a facility user model object.'
def get_group_recommendations(user): DCNL 'Returns a list of exercises immediately tackled by other individuals in the same group.'
def get_struggling_exercises(user): DCNL 'Return a list of all exercises (ids) that the user is currently struggling on.'
def get_exercise_prereqs(exercises): DCNL 'Return a list of prequisites (if applicable) for each specified exercise. DCNL :param exercise_ids: A list of exercise ids. DCNL :return: A list of prerequisite exercises (as dicts), if any are known.'
def get_explore_recommendations(user, request): DCNL 'Get the recommendations for the Explore section, and return them as a list. DCNL Logic: DCNL Looks at a preset distance away, beginning at 2 to exclude self recommendations, to DCNL recommend a topic for exploration. Currently, the cap is a distance of 6 so that all DCNL recommendations will still be of moderate relatedness. This number is not permanent, and DCNL can be tweaked as needed. DCNL Args: DCNL user -- The current user as a facility user model object.'
def get_exercise_parents_lookup_table(): DCNL 'Return a dictionary with exercise ids as keys and topic_ids as values.'
def get_exercises_from_topics(topicId_list): DCNL 'Return an ordered list of the first 5 exercise ids under a given subtopic/topic.'
def get_most_recent_incomplete_item(user): DCNL 'Return the most recently accessed item (video/exer) that has yet to be completed by user.'
def get_most_recent_exercises(user): DCNL 'Return a list of the most recent exercises (ids) accessed by the user.'
def generate_recommendation_data(): DCNL 'Traverses topic tree to generate a dictionary with related subtopics per subtopic.'
def get_recommendation_tree(data): DCNL 'Returns a dictionary of related exercises for each subtopic. DCNL Args: DCNL data -- a dictionary with each subtopic and its related_subtopics (from generate_recommendation_data())'
def get_recommended_exercises(subtopic_id): DCNL 'Return a list of recommended exercises (ids) based on the given subtopic.'
def get_neighbors_at_dist_1(topic_index, subtopic_index, topic): DCNL 'Return a list of the neighbors at distance 1 from the specified subtopic.'
def get_subsequent_neighbors(nearest_neighbors, data, curr): DCNL 'BFS algorithm. Returns a list of the other neighbors (dist > 1) for the given subtopic. DCNL Args: DCNL nearest_neighbors -- list of neighbors at dist 1 from subtopic. DCNL data -- the dictionary of subtopics and their neighbors at distance 1 DCNL curr -- the current subtopic'
def set_database(function): DCNL 'Sets the appropriate database for the ensuing model interactions.'
def parse_data(function): DCNL 'Parses the output of functions to be dicts (and expanded extra_fields if needed)'
@parse_data DCNL @set_database DCNL def get_random_content(kinds=None, limit=1, available=None, **kwargs): DCNL 'Convenience function for returning random content nodes for use in testing DCNL :param kinds: A list of node kinds to select from. DCNL :param limit: The maximum number of items to return. DCNL :return: A list of randomly selected content dictionaries.'
@set_database DCNL def get_content_item(content_id=None, topic=False, **kwargs): DCNL 'Convenience function for returning a fully fleshed out content node for use in rendering content DCNL To save server processing, the extra_fields are fleshed out on the client side. DCNL By default, don\'t return topic nodes to avoid id collisions. DCNL :param content_id: The content_id to select by - caution, this is a non-unique field. DCNL :param topic: Return non-topic or topic nodes - default to non-topics. DCNL :return: A single content dictionary.'
@parse_data DCNL @set_database DCNL def get_content_items(ids=None, **kwargs): DCNL 'Convenience function for returning multiple topic tree nodes for use in rendering content DCNL :param ids: A list of node ids to select - as ids are non-unique a single id may return multiple content items. DCNL :return: A list of content dictionaries.'
@parse_data DCNL @set_database DCNL def get_topic_nodes(parent=None, ids=None, **kwargs): DCNL 'Convenience function for returning a set of topic nodes with limited fields for rendering the topic tree DCNL Can either pass in the parent id to return all the immediate children of a node, DCNL or a list of ids to return an arbitrary set of nodes with limited fields. DCNL :param parent: id of a parent node (always a topic). DCNL :param ids: A list of ids to return. DCNL :return: A list of content dictionaries with limited fields.'
@parse_data DCNL @set_database DCNL def get_topic_update_nodes(parent=None, **kwargs): DCNL 'Convenience function for returning a set of topic nodes with limited fields for rendering the update topic tree DCNL :param parent: id of a parent node (always a topic). DCNL :return: A list of content dictionaries with limited fields.'
@set_database DCNL def get_topic_node(content_id=None, topic=True, **kwargs): DCNL 'Convenience function for returning a topic/content node with limited fields DCNL :param content_id: A list of ids to return. DCNL :return: A list of content dictionaries with limited fields.'
@set_database DCNL def get_topic_nodes_with_children(parent=None, **kwargs): DCNL 'Convenience function for returning a set of topic nodes with children listed as ids. DCNL Used for parsing and traversing the topic tree in content recommendation. DCNL :param parent: id of a parent node (always a topic). DCNL :return: A list of content dictionaries with the specified parent, with a children field as a list of ids.'
@parse_data DCNL @set_database DCNL def get_content_parents(ids=None, **kwargs): DCNL 'Convenience function for returning all parent nodes of a set of content as specified by ids. DCNL :param ids: A list of topic ids. DCNL :return: A list of content dictionaries.'
@parse_data DCNL @set_database DCNL def get_leafed_topics(kinds=None, db=None, **kwargs): DCNL 'Convenience function for returning a set of topic nodes that contain content'
@parse_data DCNL @set_database DCNL def get_topic_contents(kinds=None, topic_id=None, **kwargs): DCNL 'Convenience function for returning a set of content/leaf nodes contained within a topic DCNL :param kinds: A list of content kinds to select from. DCNL :param topic_id: The id of the topic to select within. DCNL :return: A list of content dictionaries.'
@set_database DCNL def get_download_youtube_ids(paths=None, downloaded=False, **kwargs): DCNL 'Convenience function for taking a list of content ids and returning DCNL all associated youtube_ids for downloads, regardless of whether the input DCNL paths are paths for content nodes or topic nodes DCNL :param paths: A list of paths to nodes - used to ensure uniqueness. DCNL :param downloaded: Boolean to select whether to return files that have been downloaded already or not. DCNL :return: A unique list of youtube_ids as strings.'
def get_video_from_youtube_id(youtube_id): DCNL 'This function is provided to ensure that the data migration 0029_set_video_id_for_realz DCNL in the main app is still able to be run if needed. DCNL It searches through every available content database in order to find the associated content id DCNL for a particular youtube id. DCNL :param youtube_id: String containing a youtube id. DCNL :return: A dictionary containing video metadata.'
@parse_data DCNL @set_database DCNL def _get_video_from_youtube_id(youtube_id=None, **kwargs): DCNL 'Convenience function for returning a fully fleshed out video content node from youtube_id DCNL :param youtube_id: String containing a youtube id. DCNL :return: A dictionary containing video metadata.'
@set_database DCNL def search_topic_nodes(kinds=None, query=None, page=1, items_per_page=10, exact=True, **kwargs): DCNL 'Search all nodes and return limited fields. DCNL :param kinds: A list of content kinds. DCNL :param query: Text string to search for in titles or extra fields. DCNL :param page: Which page of the paginated search to return. DCNL :param items_per_page: How many items on each page of the paginated search. DCNL :param exact: Flag to allow for an exact match, if false, always return more than one item. DCNL :return: A list of dictionaries containing content metadata.'
@set_database DCNL def bulk_insert(items, **kwargs): DCNL 'Insert many rows into the database at once. DCNL Limit to 500 items at a time for performance reasons. DCNL :param items: List of dictionaries containing content metadata.'
@set_database DCNL def create(item, **kwargs): DCNL 'Wrapper around create that allows us to specify a database DCNL and also parse the model data to compress extra fields. DCNL :param item: A dictionary containing content metadata for one node. DCNL :return Item'
@set_database DCNL def get(item, **kwargs): DCNL 'Fetch a content item, automatically choosing the correct content database (because of the set_database DCNL decorator). DCNL :param item: A dictionary containing content metadata for one node. "extra_fields" should not be inflated! DCNL :return: Item, or None if no such item is found'
@set_database DCNL def delete_instances(ids, **kwargs): DCNL 'Given a list of Item ids, deletes all instances with that id. DCNL :param item: A list of `Item.id`s DCNL :return: None'
@set_database DCNL def get_or_create(item, **kwargs): DCNL 'Wrapper around get or create that allows us to specify a database DCNL and also parse the model data to compress extra fields. DCNL :param item: A dictionary containing content metadata for one node. DCNL :return tuple of Item and Boolean for whether created or not.'
@set_database DCNL def update_item(update=None, path=None, **kwargs): DCNL 'Select an item by path, update fields and save. DCNL Updates all items that have the same id as well. DCNL Ids are not unique due to denormalization, yet items with the same id should have the same info. DCNL :param update: Dictionary of attributes to update on the model. DCNL :param path: Unique path for the content node to be updated. Also updates nodes with the same id.'
def iterator_content_items(ids=None, channel='khan', language='en', **kwargs): DCNL 'Generator to iterate over content items specified by ids, DCNL run update content availability on that item and then yield the DCNL required update. DCNL :param update: Dictionary of attributes to update on the model. DCNL :yield: Tuple of unique path to item, and the update to be carried out on that item'
def iterator_content_items_by_youtube_id(ids=None, channel='khan', language='en', **kwargs): DCNL 'Generator to iterate over content items specified by youtube ids, DCNL run update content availability on that item and then yield the DCNL required update. DCNL :param update: Dictionary of attributes to update on the model. DCNL :yield: Tuple of unique path to item, and the update to be carried out on that item'
@set_database DCNL def create_table(**kwargs): DCNL 'Create a table in the database.'
def annotate_content_models_by_youtube_id(channel='khan', language='en', youtube_ids=None): DCNL 'Annotate content models that have the youtube ids specified in a list. DCNL :param channel: Channel to update. DCNL :param language: Language of channel to update. DCNL :param youtube_ids: List of youtube_ids to find content models for annotation.'
@set_database DCNL def annotate_content_models(channel='khan', language='en', ids=None, iterator_content_items=iterator_content_items, **kwargs): DCNL 'Annotate content models that have the ids specified in a list. DCNL Our ids can be duplicated at the moment, so this may be several content items per id. DCNL When a content item has been updated, propagate availability up the topic tree. DCNL :param channel: Channel to update. DCNL :param language: Language of channel to update. DCNL :param ids: List of content ids to find content models for annotation. DCNL :param iterator_content_items: Generator function to use to yield paths and updates.'
@set_database DCNL def update_parents(parent_mapping=None, **kwargs): DCNL 'Convenience function to add parent nodes to other nodes in the database. DCNL Needs a mapping from item path to parent id. DCNL As only Topics can be parents, and we can have duplicate ids, we filter on both. DCNL :param update_mapping: A dictionary containing item paths as keys, with parent ids as values.'
@set_database DCNL def get_assessment_item_data(assessment_item_id=None, **kwargs): DCNL 'Wrapper function to return assessment_item from database as a dictionary. DCNL :param assessment_item_id: id of the assessment item to return. DCNL :return: Dictionary containing assessment item data.'
def available_content_databases(): DCNL 'Generator to return the channel and language for every content database that exists in the system. DCNL @return: iterator over (channel, language) values'
def smart_translate_item_data(item_data): DCNL 'Auto translate the content fields of a given assessment item data. DCNL An assessment item doesn\'t have the same fields; they change DCNL depending on the question. Instead of manually specifying the DCNL fields to translate, this function loops over all fields of DCNL item_data and translates only the content field.'
@require_authorized_access_to_student_data DCNL @render_to('coachreports/student_view.html') DCNL def student_view(request): DCNL 'Student view: data generated on the back-end. DCNL Student view lists a by-topic-summary of their activity logs.'
@require_authorized_access_to_student_data DCNL def student_view_context(request): DCNL 'Context done separately, to be importable for similar pages.'
@require_authorized_admin DCNL @facility_from_request DCNL @render_to('coachreports/coach.html') DCNL def coach_reports(request, facility=None, zone_id=None): DCNL 'Landing page needs plotting context in order to generate the navbar'
def log_coach_report_view(request): DCNL 'Record coach report view by teacher'
def unique_by_id_and_kind_sort(seq): DCNL 'Due to the fact that we have duplicate content items for the same content id in our topic tree, as the way that DCNL we have implemented duplication of content across the topic tree. DCNL :param seq: an iterator of content items. DCNL :return: A unique, sorted list of content items.'
def create_some_learner_data(): DCNL 'Just create a lil\' bit-o-data of each type, to populate the table.'
def generate_fake_facilities(names=('Wilson DCSP Elementary',)): DCNL 'Add the given fake facilities'
def generate_fake_facility_groups(names=('Class DCSP 4E', 'Class DCSP 5B'), facilities=None): DCNL 'Add the given fake facility groups to the given fake facilities'
def generate_fake_facility_users(nusers=20, facilities=None, facility_groups=None, password='hellothere', is_teacher=False): DCNL 'Add the given fake facility users to each of the given fake facilities. DCNL If no facilities are given, they are created.'
def probability_of(qty, user_settings): DCNL 'Share some probabilities across exercise and video logs'
def generate_fake_exercise_logs(facility_user=None, topics=topics, start_date=(datetime.datetime.now() - datetime.timedelta(days=(30 * 6)))): DCNL 'Add exercise logs for the given topics, for each of the given users. DCNL If no users are given, they are created. DCNL If no topics exist, they are taken from the list at the top of this file. DCNL By default, users start learning randomly between 6 months ago and now.'
def generate_fake_video_logs(facility_user=None, topics=topics, start_date=(datetime.datetime.now() - datetime.timedelta(days=(30 * 6)))): DCNL 'Add video logs for the given topics, for each of the given users. DCNL If no users are given, they are created. DCNL If no topics exist, they are taken from the list at the top of this file.'
@require_authorized_admin DCNL @render_to_csv(['students'], key_label='user_id', order='stacked') DCNL def facility_management_csv(request, facility, group_id=None, zone_id=None, frequency=None, period_start='', period_end='', user_type=None): DCNL 'NOTE: THIS IS NOT A VIEW FUNCTION'
def _get_date_range(frequency, period_start, period_end): DCNL 'Hack function (while CSV is in initial stages), DCNL returns dates of beginning and end of last month. DCNL Should be extended to do something more generic, based on DCNL "frequency", and moved into utils/general.py'
def _get_user_usage_data(users, groups=None, period_start=None, period_end=None, group_id=None): DCNL 'Returns facility user data, within the given date range.'
def check_meta_data(facility): DCNL 'Checks whether any metadata is missing for the specified facility. DCNL Args: DCNL facility (Facility instance): facility to check for missing metadata DCNL Returns: DCNL bool: True if one or more metadata fields are missing'
def submit_facility_form(context): DCNL 'Just do the minimum to submit the facility form.'
def get_empty_facilities_msg(browser): DCNL 'Returns a Selenium WebElement if it exists, otherwise None DCNL browser: An instance of Selenium WebDriver'
@receiver(post_save, sender=UserLog) DCNL def cull_records(sender, **kwargs): DCNL 'Listen in to see when videos become available.'
@api_handle_error_with_json DCNL def content_recommender(request): DCNL 'Populate response with recommendation(s)'
def VERSION_INFO(): DCNL 'Load a dictionary of changes between each version. The key of the DCNL dictionary is the VERSION (i.e. X.X.X), with the value being another dictionary with DCNL the following keys: DCNL release_date DCNL git_commit DCNL new_features DCNL bugs_fixed'
def user_agent(): DCNL 'HTTP User-Agent header string derived from version, used by various HTTP DCNL requests sent to learningequality.org for stats'
@require_admin DCNL @api_handle_error_with_json DCNL @process_log_from_request DCNL def check_update_progress(request, process_log): DCNL 'API endpoint for getting progress data on downloads.'
def _process_log_to_dict(process_log): DCNL 'Utility function to convert a process log to a dict'
@require_admin DCNL @api_handle_error_with_json DCNL @process_log_from_request DCNL def cancel_update_progress(request, process_log): DCNL 'API endpoint for getting progress data on downloads.'
@require_admin DCNL @api_handle_error_with_json DCNL def start_video_download(request): DCNL 'API endpoint for launching the videodownload job.'
@require_admin DCNL @api_handle_error_with_json DCNL def delete_videos(request): DCNL 'API endpoint for deleting videos.'
@require_admin DCNL @api_handle_error_with_json DCNL def delete_language_pack(request): DCNL 'API endpoint for deleting language pack which fetches the language code (in delete_id) which has to be deleted. DCNL That particular language folders are deleted and that language gets removed.'
def download_video(youtube_id, format='mp4', callback=None): DCNL 'Downloads the video file to disk (note: this does NOT invalidate any of the cached html files in KA Lite)'
def scrape_video(youtube_id, format='mp4', force=False, quiet=False, callback=None): DCNL 'Assumes it\'s in the path; if not, we try to download & install. DCNL Callback will be called back with a dictionary as the first arg with a bunch of DCNL youtube-dl info in it, as specified in the youtube-dl docs.'
@require_authorized_admin DCNL def add_facility_teacher(request): DCNL 'Admins and coaches can add teachers DCNL If central, must be an org admin DCNL If distributed, must be superuser or a coach'
@require_authorized_admin DCNL @dynamic_settings DCNL def add_facility_student(request, ds): DCNL 'Admins and coaches can add students DCNL If central, must be an org admin DCNL If distributed, must be superuser or a coach'
def facility_user_signup(request): DCNL 'Anyone can sign up, unless we have set the restricted flag'
@require_authorized_admin DCNL @dynamic_settings DCNL def edit_facility_user(request, ds, facility_user_id): DCNL 'If users have permission to add a user, they also can edit the user. Additionally, DCNL a user may edit his/her own information, like in the case of a student.'
@facility_required DCNL @render_to('facility/facility_user.html') DCNL def _facility_user(request, facility, title, is_teacher=False, new_user=False, user_being_edited=None): DCNL 'Different codepaths for the following: DCNL * Django admin/teacher creates student (add_facility_student) DCNL * Django admin creates teacher DCNL * Django admin/edits a user, self, or student edits self (edit_facility_user) DCNL * Student creates self (facility_user_signup) DCNL Each has its own message and redirect.'
def get_accessible_objects_from_logged_in_user(request, facility): DCNL 'Given a request, get all the facility/group/user objects relevant to the request, DCNL subject to the permissions of the user type. DCNL Make sure the returned `facilities` object is always a Facility queryset or an empty list.'
def facility_from_request(handler=None, request=None, *args, **kwargs): DCNL 'Goes through the request object to retrieve facility information, if possible.'
def facility_required(handler): DCNL '* Tries to get a facility from the request object. DCNL * If none exist, it tries to get the user to create one. DCNL * Otherwise, it fails, telling the user that a facility is required DCNL for whatever action hey were doing.'
def get_doc_links(): DCNL 'Returns a dictionary of function names -> upstream documentation link'
def generate_groups_markdown(): DCNL 'Generate and save markdown files for function group documentation'
def get_groups_markdown(): DCNL 'Generate markdown for function groups using the Abstract API DCNL Returns a dictionary of group_name -> documentation for group functions'
def _get_markdown_renderer(): DCNL 'Returns a function to convert a Markdown string into pygments-highlighted HTML'
def run_convert_to_html(output_dir): DCNL 'Converts markdown files into their respective html files'
def assert_np_arrays_not_equal(expected, got): DCNL 'Verifies expected and got have the same number of leading nan fields, DCNL followed by different floats.'
def get_functions(): DCNL 'Returns a list of all the functions supported by TALIB'
def get_function_groups(): DCNL 'Returns a dict with keys of function-group names and values of lists DCNL of function names ie {\'group_names\': [\'function_names\']}'
