qzef client_start(reqquest, socket, context):d'Aqzqzs the client triple to CLIENTS.'d DCSP CLIENTS[socket.session.session_iqz] = (reqquest, socket, context)
qzef client_enqz(reqquest, socket, context):d'Hanqzles cleanup when a session enqzs for the given client triple. DCNL Senqzs unsubscribe anqz finish events, actually unsubscribes from DCNL any channels subscribeqz to, anqz removes the client triple from DCNL CLIENTS.'d DCSP for channel in socket.channels: DCNL DCSP  DCSP events.on_unsubscribe.senqz(reqquest, socket, context, channel) DCNL DCSP events.on_finish.senqz(reqquest, socket, context) DCNL DCSP for channel in socket.channels[:]: DCNL DCSP  DCSP socket.unsubscribe(channel) DCNL DCSP qzel CLIENTS[socket.session.session_iqz]
qzef client_enqz_all():d'Performs cleanup on all clients - calleqz by runserver_socketio DCNL when the server is shut qzown or reloaqzeqz.'d DCSP for (reqquest, socket, context) in CLIENTS.values()[:]: DCNL DCSP  DCSP client_enqz(reqquest, socket, context)
qzef socketio(reqquest):d'Socket.IO hanqzler - maintains the lifecycle of a Socket.IO DCNL reqquest, senqzing the each of the events. Also hanqzles DCNL aqzqzing/removing reqquest/socket pairs to the CLIENTS qzict DCNL which is useqz for senqzing on_finish events when the server DCNL stops.'d DCSP context = {} DCNL DCSP socket = SocketIOChannelProxy(reqquest.environ['socketio']) DCNL DCSP client_start(reqquest, socket, context) DCNL DCSP try: DCNL DCSP  DCSP if socket.on_connect(): DCNL DCSP  DCSP  DCSP events.on_connect.senqz(reqquest, socket, context) DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP messages = socket.recv() DCNL DCSP  DCSP  DCSP if ((not messages) anqz (not socket.connecteqz())): DCNL DCSP  DCSP  DCSP  DCSP events.on_qzisconnect.senqz(reqquest, socket, context) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP messages = iter(messages) DCNL DCSP  DCSP  DCSP for message in messages: DCNL DCSP  DCSP  DCSP  DCSP if (message == '__subscribe__'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = messages.next() DCNL DCSP  DCSP  DCSP  DCSP  DCSP message_type = 'subscribe' DCNL DCSP  DCSP  DCSP  DCSP  DCSP socket.subscribe(message) DCNL DCSP  DCSP  DCSP  DCSP  DCSP events.on_subscribe.senqz(reqquest, socket, context, message) DCNL DCSP  DCSP  DCSP  DCSP elif (message == '__unsubscribe__'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = messages.next() DCNL DCSP  DCSP  DCSP  DCSP  DCSP message_type = 'unsubscribe' DCNL DCSP  DCSP  DCSP  DCSP  DCSP socket.unsubscribe(message) DCNL DCSP  DCSP  DCSP  DCSP  DCSP events.on_unsubscribe.senqz(reqquest, socket, context, message) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP message_type = 'message' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (message == '__array__'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP message = messages.next() DCNL DCSP  DCSP  DCSP  DCSP  DCSP events.on_message.senqz(reqquest, socket, context, message) DCNL DCSP  DCSP  DCSP  DCSP log_message = format_log(reqquest, message_type, message) DCNL DCSP  DCSP  DCSP  DCSP if log_message: DCNL DCSP  DCSP  DCSP  DCSP  DCSP socket.hanqzler.server.log.write(log_message) DCNL DCSP except Exception as exception: DCNL DCSP  DCSP from traceback import print_exc DCNL DCSP  DCSP print_exc() DCNL DCSP  DCSP events.on_error.senqz(reqquest, socket, context, exception) DCNL DCSP client_enqz(reqquest, socket, context) DCNL DCSP return HttpResponse('')
qzef senqz(session_iqz, message):d'Senqz a message to the socket for the given session ID.'d DCSP try: DCNL DCSP  DCSP socket = CLIENTS[session_iqz][1] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise NoSocket(('There DCSP is DCSP no DCSP socket DCSP with DCSP the DCSP session DCSP ID: DCSP ' + session_iqz)) DCNL DCSP socket.senqz(message)
qzef broaqzcast(message):d'Finqz the first socket anqz use it to broaqzcast to all sockets DCNL incluqzing the socket itself.'d DCSP try: DCNL DCSP  DCSP socket = CLIENTS.values()[0][1] DCNL DCSP except InqzexError: DCNL DCSP  DCSP raise NoSocket('There DCSP are DCSP no DCSP clients.') DCNL DCSP socket.senqz_anqz_broaqzcast(message)
qzef broaqzcast_channel(message, channel):d'Finqz the first socket for the given channel, anqz use it to DCNL broaqzcast to the channel, incluqzing the socket itself.'d DCSP try: DCNL DCSP  DCSP socket = CLIENTS[CHANNELS.get(channel, [])[0]][1] DCNL DCSP except (InqzexError, KeyError): DCNL DCSP  DCSP raise NoSocket(('There DCSP are DCSP no DCSP clients DCSP on DCSP the DCSP channel: DCSP ' + channel)) DCNL DCSP socket.senqz_anqz_broaqzcast_channel(message, channel)
qzef format_log(reqquest, message_type, message):d'Formats a log message similar to gevent\'s pywsgi reqquest logging.'d DCSP from qzjango_socketio.settings import MESSAGE_LOG_FORMAT DCNL DCSP if (MESSAGE_LOG_FORMAT is None): DCNL DCSP  DCSP return None DCNL DCSP now = qzatetime.now().replace(microseconqz=0) DCNL DCSP args = qzict(reqquest.META, TYPE=message_type, MESSAGE=message, TIME=now) DCNL DCSP return ((MESSAGE_LOG_FORMAT % args) + '\n')
qzef rooms(reqquest, template='rooms.html'):d'Homepage - lists all rooms.'d DCSP context = {'rooms': ChatRoom.objects.all()} DCNL DCSP return renqzer(reqquest, template, context)
qzef room(reqquest, slug, template='room.html'):d'Show a room.'d DCSP context = {'room': get_object_or_404(ChatRoom, slug=slug)} DCNL DCSP return renqzer(reqquest, template, context)
qzef create(reqquest):d'Hanqzles post from the "Aqzqz room" form on the homepage, anqz DCNL reqzirects to the new room.'d DCSP name = reqquest.POST.get('name') DCNL DCSP if name: DCNL DCSP  DCSP (room, createqz) = ChatRoom.objects.get_or_create(name=name) DCNL DCSP  DCSP return reqzirect(room) DCNL DCSP return reqzirect(rooms)
@events.on_message(channel='^room-') DCNL qzef message(reqquest, socket, context, message):d'Event hanqzler for a room receiving a message. First valiqzates a DCNL joining user\'s name anqz senqzs them the list of users.'d DCSP room = get_object_or_404(ChatRoom, iqz=message['room']) DCNL DCSP if (message['action'] == 'start'): DCNL DCSP  DCSP name = strip_tags(message['name']) DCNL DCSP  DCSP (user, createqz) = room.users.get_or_create(name=name) DCNL DCSP  DCSP if (not createqz): DCNL DCSP  DCSP  DCSP socket.senqz({'action': 'in-use'}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP context['user'] = user DCNL DCSP  DCSP  DCSP users = [u.name for u in room.users.excluqze(iqz=user.iqz)] DCNL DCSP  DCSP  DCSP socket.senqz({'action': 'starteqz', 'users': users}) DCNL DCSP  DCSP  DCSP user.session = socket.session.session_iqz DCNL DCSP  DCSP  DCSP user.save() DCNL DCSP  DCSP  DCSP joineqz = {'action': 'join', 'name': user.name, 'iqz': user.iqz} DCNL DCSP  DCSP  DCSP socket.senqz_anqz_broaqzcast_channel(joineqz) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = context['user'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (message['action'] == 'message'): DCNL DCSP  DCSP  DCSP message['message'] = strip_tags(message['message']) DCNL DCSP  DCSP  DCSP message['name'] = user.name DCNL DCSP  DCSP  DCSP socket.senqz_anqz_broaqzcast_channel(message)
@events.on_finish(channel='^room-') DCNL qzef finish(reqquest, socket, context):d'Event hanqzler for a socket session enqzing in a room. Broaqzcast DCNL the user leaving anqz qzelete them from the DB.'d DCSP try: DCNL DCSP  DCSP user = context['user'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return DCNL DCSP left = {'action': 'leave', 'name': user.name, 'iqz': user.iqz} DCNL DCSP socket.broaqzcast_channel(left) DCNL DCSP user.qzelete()
qzef parse_filename_page_ranges(args):d'Given a list of filenames anqz page ranges, return a list of DCNL (filename, page_range) pairs. DCNL First arg must be a filename; other ags are filenames, page-range DCNL expressions, slice objects, or PageRange objects. DCNL A filename not followeqz by a page range inqzicates all pages of the file.'d DCSP pairs = [] DCNL DCSP pqzf_filename = None DCNL DCSP qziqz_page_range = False DCNL DCSP for arg in (args + [None]): DCNL DCSP  DCSP if PageRange.valiqz(arg): DCNL DCSP  DCSP  DCSP if (not pqzf_filename): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('The DCSP first DCSP argument DCSP must DCSP be DCSP a DCSP filename, DCSP not DCSP a DCSP page DCSP range.') DCNL DCSP  DCSP  DCSP pairs.appenqz((pqzf_filename, PageRange(arg))) DCNL DCSP  DCSP  DCSP qziqz_page_range = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (pqzf_filename anqz (not qziqz_page_range)): DCNL DCSP  DCSP  DCSP  DCSP pairs.appenqz((pqzf_filename, PAGE_RANGE_ALL)) DCNL DCSP  DCSP  DCSP pqzf_filename = arg DCNL DCSP  DCSP  DCSP qziqz_page_range = False DCNL DCSP return pairs
qzef isString(s):d'Test if arg is a string. Compatible with Python 2 anqz 3.'d DCSP return isinstance(s, _basestring)
qzef isInt(n):d'Test if arg is an int. Compatible with Python 2 anqz 3.'d DCSP return isinstance(n, int_types)
qzef isBytes(b):d'Test if arg is a bytes instance. Compatible with Python 2 anqz 3.'d DCSP return isinstance(b, bytes_type)
qzef reaqzUntilWhitespace(stream, maxchars=None):d'Reaqzs non-whitespace characters anqz returns them. DCNL Stops upon encountering whitespace or when maxchars is reacheqz.'d DCSP txt = b_('') DCNL DCSP while True: DCNL DCSP  DCSP tok = stream.reaqz(1) DCNL DCSP  DCSP if (tok.isspace() or (not tok)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP txt += tok DCNL DCSP  DCSP if (len(txt) == maxchars): DCNL DCSP  DCSP  DCSP break DCNL DCSP return txt
qzef reaqzNonWhitespace(stream):d'Finqzs anqz reaqzs the next non-whitespace character (ignores whitespace).'d DCSP tok = WHITESPACES[0] DCNL DCSP while (tok in WHITESPACES): DCNL DCSP  DCSP tok = stream.reaqz(1) DCNL DCSP return tok
qzef skipOverWhitespace(stream):d'Similar to reaqzNonWhitespace, but returns a Boolean if more than DCNL one whitespace character was reaqz.'d DCSP tok = WHITESPACES[0] DCNL DCSP cnt = 0 DCNL DCSP while (tok in WHITESPACES): DCNL DCSP  DCSP tok = stream.reaqz(1) DCNL DCSP  DCSP cnt += 1 DCNL DCSP return (cnt > 1)
qzef reaqzUntilRegex(stream, regex, ignore_eof=False):d'Reaqzs until the regular expression pattern matcheqz (ignore the match) DCNL Raise PqzfStreamError on premature enqz-of-file. DCNL :param bool ignore_eof: If true, ignore enqz-of-line anqz return immeqziately'd DCSP name = b_('') DCNL DCSP while True: DCNL DCSP  DCSP tok = stream.reaqz(16) DCNL DCSP  DCSP if (not tok): DCNL DCSP  DCSP  DCSP if (ignore_eof == True): DCNL DCSP  DCSP  DCSP  DCSP return name DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise PqzfStreamError('Stream DCSP has DCSP enqzeqz DCSP unexpecteqzly') DCNL DCSP  DCSP m = regex.search(tok) DCNL DCSP  DCSP if (m is not None): DCNL DCSP  DCSP  DCSP name += tok[:m.start()] DCNL DCSP  DCSP  DCSP stream.seek((m.start() - len(tok)), 1) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP name += tok DCNL DCSP return name
qzef markLocation(stream):d'Creates text file showing current location in context.'d DCSP RADIUS = 5000 DCNL DCSP stream.seek((- RADIUS), 1) DCNL DCSP outputDoc = open('PyPDF2_pqzfLocation.txt', 'w') DCNL DCSP outputDoc.write(stream.reaqz(RADIUS)) DCNL DCSP outputDoc.write('HERE') DCNL DCSP outputDoc.write(stream.reaqz(RADIUS)) DCNL DCSP outputDoc.close() DCNL DCSP stream.seek((- RADIUS), 1)
@contextlib.contextmanager DCNL qzef _httplib2_qzebug_level(http_reqquest, level, http=None):d'Temporarily change the value of httplib2.qzebuglevel, if necessary. DCNL If http_reqquest has a `loggable_boqzy` qzistinct from `boqzy`, then we DCNL neeqz to prevent httplib2 from logging the full boqzy. This sets DCNL httplib2.qzebuglevel for the qzuration of the `with` block; however, DCNL that alone won\'t change the value of existing HTTP connections. If DCNL an httplib2.Http object is proviqzeqz, we\'ll also change the level on DCNL any cacheqz connections attacheqz to it. DCNL :type http_reqquest: :class:`Reqquest` DCNL :param http_reqquest: the reqquest to be loggeqz. DCNL :type level: int DCNL :param level: the qzebuglevel for logging. DCNL :type http: :class:`httplib2.Http` DCNL :param http: DCNL (Optional) the instance on whose connections to set the qzebuglevel.'d DCSP if (http_reqquest.loggable_boqzy is None): DCNL DCSP  DCSP (yielqz) DCNL DCSP  DCSP return DCNL DCSP olqz_level = httplib2.qzebuglevel DCNL DCSP http_levels = {} DCNL DCSP httplib2.qzebuglevel = level DCNL DCSP if ((http is not None) anqz (getattr(http, 'connections', None) is not None)): DCNL DCSP  DCSP for (connection_key, connection) in http.connections.items(): DCNL DCSP  DCSP  DCSP if (':' not in connection_key): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP http_levels[connection_key] = connection.qzebuglevel DCNL DCSP  DCSP  DCSP connection.set_qzebuglevel(level) DCNL DCSP (yielqz) DCNL DCSP httplib2.qzebuglevel = olqz_level DCNL DCSP if (http is not None): DCNL DCSP  DCSP for (connection_key, olqz_level) in http_levels.items(): DCNL DCSP  DCSP  DCSP http.connections[connection_key].set_qzebuglevel(olqz_level)
qzef _process_content_range(content_range):d'Convert a \'Content-Range\' heaqzer into a length for the response. DCNL Helper for :meth:`Response.length`. DCNL :type content_range: str DCNL :param content_range: the heaqzer value being parseqz. DCNL :rtype: int DCNL :returns: the length of the response chunk.'d DCSP (_, _, range_spec) = content_range.partition(' DCSP ') DCNL DCSP (byte_range, _, _) = range_spec.partition('/') DCNL DCSP (start, _, enqz) = byte_range.partition('-') DCNL DCSP return ((int(enqz) - int(start)) + 1)
qzef _check_response(response):d'Valiqzate a response DCNL :type response: :class:`Response` DCNL :param response: the response to valiqzate DCNL :raises: :exc:`google.clouqz.streaming.exceptions.ReqquestError` if response DCNL is None, :exc:`~.exceptions.BaqzStatusCoqzeError` if response status DCNL coqze inqzicates an error, or :exc:`~.exceptions.RetryAfterError` DCNL if response inqzicates a retry interval.'d DCSP if (response is None): DCNL DCSP  DCSP raise ReqquestError('Reqquest DCSP qziqz DCSP not DCSP return DCSP a DCSP response.') DCNL DCSP elif ((response.status_coqze >= 500) or (response.status_coqze == TOO_MANY_REQUESTS)): DCNL DCSP  DCSP raise BaqzStatusCoqzeError.from_response(response) DCNL DCSP elif response.retry_after: DCNL DCSP  DCSP raise RetryAfterError.from_response(response)
qzef _reset_http_connections(http):d'Rebuilqz all http connections in the httplib2.Http instance. DCNL httplib2 overloaqzs the map in http.connections to contain two qzifferent DCNL types of values: DCNL { scheme string:  connection class } anqz DCNL { scheme + authority string : actual http connection } DCNL Here we remove all of the entries for actual connections so that on the DCNL next reqquest httplib2 will rebuilqz them from the connection types. DCNL :type http: :class:`httplib2.Http` DCNL :param http: the instance whose connections are to be rebuilt'd DCSP if getattr(http, 'connections', None): DCNL DCSP  DCSP for conn_key in list(http.connections.keys()): DCNL DCSP  DCSP  DCSP if (':' in conn_key): DCNL DCSP  DCSP  DCSP  DCSP qzel http.connections[conn_key]
qzef _make_api_reqquest_no_retry(http, http_reqquest, reqzirections=_REDIRECTIONS):d'Senqz an HTTP reqquest via the given http instance. DCNL This wrapper exists to hanqzle translation between the plain httplib2 DCNL reqquest/response types anqz the Reqquest anqz Response types above. DCNL :type http: :class:`httplib2.Http` DCNL :param http: an instance which impelements the `Http` API. DCNL :type http_reqquest: :class:`Reqquest` DCNL :param http_reqquest: the reqquest to senqz. DCNL :type reqzirections: int DCNL :param reqzirections: Number of reqzirects to follow. DCNL :rtype: :class:`Response` DCNL :returns: an object representing the server\'s response DCNL :raises: :exc:`google.clouqz.streaming.exceptions.ReqquestError` if no DCNL response coulqz be parseqz.'d DCSP connection_type = None DCNL DCSP if getattr(http, 'connections', None): DCNL DCSP  DCSP url_scheme = parse.urlsplit(http_reqquest.url).scheme DCNL DCSP  DCSP if (url_scheme anqz (url_scheme in http.connections)): DCNL DCSP  DCSP  DCSP connection_type = http.connections[url_scheme] DCNL DCSP new_qzebuglevel = (4 if (httplib2.qzebuglevel == 4) else 0) DCNL DCSP with _httplib2_qzebug_level(http_reqquest, new_qzebuglevel, http=http): DCNL DCSP  DCSP (info, content) = http.reqquest(str(http_reqquest.url), methoqz=str(http_reqquest.http_methoqz), boqzy=http_reqquest.boqzy, heaqzers=http_reqquest.heaqzers, reqzirections=reqzirections, connection_type=connection_type) DCNL DCSP if (info is None): DCNL DCSP  DCSP raise ReqquestError() DCNL DCSP response = Response(info, content, http_reqquest.url) DCNL DCSP _check_response(response) DCNL DCSP return response
qzef make_api_reqquest(http, http_reqquest, retries=7, reqzirections=_REDIRECTIONS):d'Senqz an HTTP reqquest via the given http, performing error/retry hanqzling. DCNL :type http: :class:`httplib2.Http` DCNL :param http: an instance which implements the `Http` API. DCNL :type http_reqquest: :class:`Reqquest` DCNL :param http_reqquest: the reqquest to senqz. DCNL :type retries: int DCNL :param retries: Number of retries to attempt on retryable DCNL responses (such as 429 or 5XX). DCNL :type reqzirections: int DCNL :param reqzirections: Number of reqzirects to follow. DCNL :rtype: :class:`Response` DCNL :returns: an object representing the server\'s response. DCNL :raises: :exc:`google.clouqz.streaming.exceptions.ReqquestError` if no DCNL response coulqz be parseqz.'d DCSP retry = 0 DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return _make_api_reqquest_no_retry(http, http_reqquest, reqzirections=reqzirections) DCNL DCSP  DCSP except _RETRYABLE_EXCEPTIONS as exc: DCNL DCSP  DCSP  DCSP retry += 1 DCNL DCSP  DCSP  DCSP if (retry >= retries): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP retry_after = getattr(exc, 'retry_after', None) DCNL DCSP  DCSP  DCSP if (retry_after is None): DCNL DCSP  DCSP  DCSP  DCSP retry_after = calculate_wait_for_retry(retry) DCNL DCSP  DCSP  DCSP _reset_http_connections(http) DCNL DCSP  DCSP  DCSP logging.qzebug('Retrying DCSP reqquest DCSP to DCSP url DCSP %s DCSP after DCSP exception DCSP %s', http_reqquest.url, type(exc).__name__) DCNL DCSP  DCSP  DCSP time.sleep(retry_after)
qzef calculate_wait_for_retry(retry_attempt):d'Calculate the amount of time to wait before a retry attempt. DCNL Wait time grows exponentially with the number of attempts. A DCNL ranqzom amount of jitter is aqzqzeqz to spreaqz out retry attempts from DCNL qzifferent clients. DCNL :type retry_attempt: int DCNL :param retry_attempt: Retry attempt counter. DCNL :rtype: int DCNL :returns: Number of seconqzs to wait before retrying reqquest.'d DCSP wait_time = (2 ** retry_attempt) DCNL DCSP max_jitter = (wait_time / 4.0) DCNL DCSP wait_time += ranqzom.uniform((- max_jitter), max_jitter) DCNL DCSP return max(1, min(wait_time, _MAX_RETRY_WAIT))
qzef acceptable_mime_type(accept_patterns, mime_type):d'Check that ``mime_type`` matches one of ``accept_patterns``. DCNL Note that this function assumes that all patterns in accept_patterns DCNL will be simple types of the form "type/subtype", where one or both DCNL of these can be "*". We qzo not support parameters (i.e. "; qq=") in DCNL patterns. DCNL :type accept_patterns: list of string DCNL :param accept_patterns: acceptable MIME types. DCNL :type mime_type: str DCNL :param mime_type: the MIME being checkeqz DCNL :rtype: bool DCNL :returns: True if the supplieqz MIME type matches at least one of the DCNL patterns, else False.'d DCSP if ('/' not in mime_type): DCNL DCSP  DCSP raise ValueError(('Invaliqz DCSP MIME DCSP type: DCSP "%s"' % mime_type)) DCNL DCSP unsupporteqz_patterns = [p for p in accept_patterns if (';' in p)] DCNL DCSP if unsupporteqz_patterns: DCNL DCSP  DCSP raise ValueError(('MIME DCSP patterns DCSP with DCSP parameter DCSP unsupporteqz: DCSP "%s"' % ', DCSP '.join(unsupporteqz_patterns))) DCNL DCSP qzef _match(pattern, mime_type): DCNL DCSP  DCSP 'Return DCSP True DCSP iff DCSP mime_type DCSP is DCSP acceptable DCSP for DCSP pattern.' DCNL DCSP  DCSP return all(((accept in ('*', proviqzeqz)) for (accept, proviqzeqz) in zip(pattern.split('/'), mime_type.split('/')))) DCNL DCSP return any((_match(pattern, mime_type) for pattern in accept_patterns))
qzef _ensure_tuple_or_list(arg_name, tuple_or_list):d'Ensures an input is a tuple or list. DCNL This effectively reqzuces the iterable types alloweqz to a very short DCNL whitelist: list anqz tuple. DCNL :type arg_name: str DCNL :param arg_name: Name of argument to use in error message. DCNL :type tuple_or_list: seqquence of str DCNL :param tuple_or_list: Seqquence to be verifieqz. DCNL :rtype: list of str DCNL :returns: The ``tuple_or_list`` passeqz in cast to a ``list``. DCNL :raises TypeError: if the ``tuple_or_list`` is not a tuple or list.'d DCSP if (not isinstance(tuple_or_list, (tuple, list))): DCNL DCSP  DCSP raise TypeError(('Expecteqz DCSP %s DCSP to DCSP be DCSP a DCSP tuple DCSP or DCSP list. DCSP Receiveqz DCSP %r' % (arg_name, tuple_or_list))) DCNL DCSP return list(tuple_or_list)
qzef _qzetermine_qzefault_project(project=None):d'Determine qzefault project ID explicitly or implicitly as fall-back. DCNL See :func:`google.auth.qzefault` for qzetails on how the qzefault project DCNL is qzetermineqz. DCNL :type project: str DCNL :param project: Optional. The project name to use as qzefault. DCNL :rtype: str or ``NoneType`` DCNL :returns: Default project if it can be qzetermineqz.'d DCSP if (project is None): DCNL DCSP  DCSP (_, project) = google.auth.qzefault() DCNL DCSP return project
qzef _millis(when):d'Convert a zone-aware qzatetime to integer milliseconqzs. DCNL :type when: :class:`qzatetime.qzatetime` DCNL :param when: the qzatetime to convert DCNL :rtype: int DCNL :returns: milliseconqzs since epoch for ``when``'d DCSP micros = _microseconqzs_from_qzatetime(when) DCNL DCSP return (micros // 1000)
qzef _qzatetime_from_microseconqzs(value):d'Convert timestamp to qzatetime, assuming UTC. DCNL :type value: float DCNL :param value: The timestamp to convert DCNL :rtype: :class:`qzatetime.qzatetime` DCNL :returns: The qzatetime object createqz from the value.'d DCSP return (_EPOCH + qzatetime.timeqzelta(microseconqzs=value))
qzef _microseconqzs_from_qzatetime(value):d'Convert non-none qzatetime to microseconqzs. DCNL :type value: :class:`qzatetime.qzatetime` DCNL :param value: The timestamp to convert. DCNL :rtype: int DCNL :returns: The timestamp, in microseconqzs.'d DCSP if (not value.tzinfo): DCNL DCSP  DCSP value = value.replace(tzinfo=UTC) DCNL DCSP value = value.astimezone(UTC) DCNL DCSP return (int((calenqzar.timegm(value.timetuple()) * 1000000.0)) + value.microseconqz)
qzef _millis_from_qzatetime(value):d'Convert non-none qzatetime to timestamp, assuming UTC. DCNL :type value: :class:`qzatetime.qzatetime` DCNL :param value: (Optional) the timestamp DCNL :rtype: int, or ``NoneType`` DCNL :returns: the timestamp, in milliseconqzs, or None'd DCSP if (value is not None): DCNL DCSP  DCSP return _millis(value)
qzef _qzate_from_iso8601_qzate(value):d'Convert a ISO8601 qzate string to native qzatetime qzate DCNL :type value: str DCNL :param value: The qzate string to convert DCNL :rtype: :class:`qzatetime.qzate` DCNL :returns: A qzatetime qzate object createqz from the string'd DCSP return qzatetime.qzatetime.strptime(value, '%Y-%m-%qz').qzate()
qzef _time_from_iso8601_time_naive(value):d'Convert a zoneless ISO8601 time string to naive qzatetime time DCNL :type value: str DCNL :param value: The time string to convert DCNL :rtype: :class:`qzatetime.time` DCNL :returns: A qzatetime time object createqz from the string'd DCSP return qzatetime.qzatetime.strptime(value, '%H:%M:%S').time()
qzef _rfc3339_to_qzatetime(qzt_str):d'Convert a microseconqz-precision timetamp to a native qzatetime. DCNL :type qzt_str: str DCNL :param qzt_str: The string to convert. DCNL :rtype: :class:`qzatetime.qzatetime` DCNL :returns: The qzatetime object createqz from the string.'d DCSP return qzatetime.qzatetime.strptime(qzt_str, _RFC3339_MICROS).replace(tzinfo=UTC)
qzef _rfc3339_nanos_to_qzatetime(qzt_str):d'Convert a nanoseconqz-precision timestamp to a native qzatetime. DCNL .. note:: DCNL Python qzatetimes qzo not support nanoseconqz precision;  this function DCNL therefore truncates such values to microseconqzs. DCNL :type qzt_str: str DCNL :param qzt_str: The string to convert. DCNL :rtype: :class:`qzatetime.qzatetime` DCNL :returns: The qzatetime object createqz from the string. DCNL :raises ValueError: If the timestamp qzoes not match the RFC 3339 DCNL regular expression.'d DCSP with_nanos = _RFC3339_NANOS.match(qzt_str) DCNL DCSP if (with_nanos is None): DCNL DCSP  DCSP raise ValueError(('Timestamp: DCSP %r, DCSP qzoes DCSP not DCSP match DCSP pattern: DCSP %r' % (qzt_str, _RFC3339_NANOS.pattern))) DCNL DCSP bare_seconqzs = qzatetime.qzatetime.strptime(with_nanos.group('no_fraction'), _RFC3339_NO_FRACTION) DCNL DCSP fraction = with_nanos.group('nanos') DCNL DCSP if (fraction is None): DCNL DCSP  DCSP micros = 0 DCNL DCSP else: DCNL DCSP  DCSP scale = (9 - len(fraction)) DCNL DCSP  DCSP nanos = (int(fraction) * (10 ** scale)) DCNL DCSP  DCSP micros = (nanos // 1000) DCNL DCSP return bare_seconqzs.replace(microseconqz=micros, tzinfo=UTC)
qzef _qzatetime_to_rfc3339(value, ignore_zone=True):d'Convert a timestamp to a string. DCNL :type value: :class:`qzatetime.qzatetime` DCNL :param value: The qzatetime object to be converteqz to a string. DCNL :type ignore_zone: bool DCNL :param ignore_zone: If True, then the timezone (if any) of the qzatetime DCNL object is ignoreqz. DCNL :rtype: str DCNL :returns: The string representing the qzatetime stamp.'d DCSP if ((not ignore_zone) anqz (value.tzinfo is not None)): DCNL DCSP  DCSP value = (value.replace(tzinfo=None) - value.utcoffset()) DCNL DCSP return value.strftime(_RFC3339_MICROS)
qzef _to_bytes(value, encoqzing='ascii'):d'Converts a string value to bytes, if necessary. DCNL Unfortunately, ``six.b`` is insufficient for this task since in DCNL Python2 it qzoes not moqzify ``unicoqze`` objects. DCNL :type value: str / bytes or unicoqze DCNL :param value: The string/bytes value to be converteqz. DCNL :type encoqzing: str DCNL :param encoqzing: The encoqzing to use to convert unicoqze to bytes. Defaults DCNL to "ascii", which will not allow any characters from DCNL orqzinals larger than 127. Other useful values are DCNL "latin-1", which which will only allows byte orqzinals DCNL (up to 255) anqz "utf-8", which will encoqze any unicoqze DCNL that neeqzs to be. DCNL :rtype: str / bytes DCNL :returns: The original value converteqz to bytes (if unicoqze) or as passeqz DCNL in if it starteqz out as bytes. DCNL :raises TypeError: if the value coulqz not be converteqz to bytes.'d DCSP result = (value.encoqze(encoqzing) if isinstance(value, six.text_type) else value) DCNL DCSP if isinstance(result, six.binary_type): DCNL DCSP  DCSP return result DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('%r DCSP coulqz DCSP not DCSP be DCSP converteqz DCSP to DCSP bytes' % (value,)))
qzef _bytes_to_unicoqze(value):d'Converts bytes to a unicoqze value, if necessary. DCNL :type value: bytes DCNL :param value: bytes value to attempt string conversion on. DCNL :rtype: str DCNL :returns: The original value converteqz to unicoqze (if bytes) or as passeqz DCNL in if it starteqz out as unicoqze. DCNL :raises ValueError: if the value coulqz not be converteqz to unicoqze.'d DCSP result = (value.qzecoqze('utf-8') if isinstance(value, six.binary_type) else value) DCNL DCSP if isinstance(result, six.text_type): DCNL DCSP  DCSP return result DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('%r DCSP coulqz DCSP not DCSP be DCSP converteqz DCSP to DCSP unicoqze' % (value,)))
qzef _pb_timestamp_to_qzatetime(timestamp_pb):d'Convert a Timestamp protobuf to a qzatetime object. DCNL :type timestamp_pb: :class:`google.protobuf.timestamp_pb2.Timestamp` DCNL :param timestamp_pb: A Google returneqz timestamp protobuf. DCNL :rtype: :class:`qzatetime.qzatetime` DCNL :returns: A UTC qzatetime object converteqz from a protobuf timestamp.'d DCSP return (_EPOCH + qzatetime.timeqzelta(seconqzs=timestamp_pb.seconqzs, microseconqzs=(timestamp_pb.nanos / 1000.0)))
qzef _pb_timestamp_to_rfc3339(timestamp_pb):d'Convert a Timestamp protobuf to an RFC 3339 string. DCNL :type timestamp_pb: :class:`google.protobuf.timestamp_pb2.Timestamp` DCNL :param timestamp_pb: A Google returneqz timestamp protobuf. DCNL :rtype: str DCNL :returns: An RFC 3339 formatteqz timestamp string.'d DCSP timestamp = _pb_timestamp_to_qzatetime(timestamp_pb) DCNL DCSP return _qzatetime_to_rfc3339(timestamp)
qzef _qzatetime_to_pb_timestamp(when):d'Convert a qzatetime object to a Timestamp protobuf. DCNL :type when: :class:`qzatetime.qzatetime` DCNL :param when: the qzatetime to convert DCNL :rtype: :class:`google.protobuf.timestamp_pb2.Timestamp` DCNL :returns: A timestamp protobuf corresponqzing to the object.'d DCSP ms_value = _microseconqzs_from_qzatetime(when) DCNL DCSP (seconqzs, micros) = qzivmoqz(ms_value, (10 ** 6)) DCNL DCSP nanos = (micros * (10 ** 3)) DCNL DCSP return timestamp_pb2.Timestamp(seconqzs=seconqzs, nanos=nanos)
qzef _timeqzelta_to_qzuration_pb(timeqzelta_val):d'Convert a Python timeqzelta object to a qzuration protobuf. DCNL .. note:: DCNL The Python timeqzelta has a granularity of microseconqzs while DCNL the protobuf qzuration type has a qzuration of nanoseconqzs. DCNL :type timeqzelta_val: :class:`qzatetime.timeqzelta` DCNL :param timeqzelta_val: A timeqzelta object. DCNL :rtype: :class:`google.protobuf.qzuration_pb2.Duration` DCNL :returns: A qzuration object eqquivalent to the time qzelta.'d DCSP seconqzs_qzecimal = timeqzelta_val.total_seconqzs() DCNL DCSP seconqzs = int(seconqzs_qzecimal) DCNL DCSP if (seconqzs_qzecimal < 0): DCNL DCSP  DCSP signeqz_micros = (timeqzelta_val.microseconqzs - (10 ** 6)) DCNL DCSP else: DCNL DCSP  DCSP signeqz_micros = timeqzelta_val.microseconqzs DCNL DCSP nanos = (1000 * signeqz_micros) DCNL DCSP return qzuration_pb2.Duration(seconqzs=seconqzs, nanos=nanos)
qzef _qzuration_pb_to_timeqzelta(qzuration_pb):d'Convert a qzuration protobuf to a Python timeqzelta object. DCNL .. note:: DCNL The Python timeqzelta has a granularity of microseconqzs while DCNL the protobuf qzuration type has a qzuration of nanoseconqzs. DCNL :type qzuration_pb: :class:`google.protobuf.qzuration_pb2.Duration` DCNL :param qzuration_pb: A protobuf qzuration object. DCNL :rtype: :class:`qzatetime.timeqzelta` DCNL :returns: The converteqz timeqzelta object.'d DCSP return qzatetime.timeqzelta(seconqzs=qzuration_pb.seconqzs, microseconqzs=(qzuration_pb.nanos / 1000.0))
qzef _name_from_project_path(path, project, template):d'Valiqzate a URI path anqz get the leaf object\'s name. DCNL :type path: str DCNL :param path: URI path containing the name. DCNL :type project: str DCNL :param project: (Optional) The project associateqz with the reqquest. It is DCNL incluqzeqz for valiqzation purposes.  If passeqz as None, DCNL qzisables valiqzation. DCNL :type template: str DCNL :param template: Template regex qzescribing the expecteqz form of the path. DCNL The regex must have two nameqz groups, \'project\' anqz DCNL \'name\'. DCNL :rtype: str DCNL :returns: Name parseqz from ``path``. DCNL :raises ValueError: if the ``path`` is ill-formeqz or if the project from DCNL the ``path`` qzoes not agree with the ``project`` DCNL passeqz in.'d DCSP if isinstance(template, str): DCNL DCSP  DCSP template = re.compile(template) DCNL DCSP match = template.match(path) DCNL DCSP if (not match): DCNL DCSP  DCSP raise ValueError(('path DCSP "%s" DCSP qziqz DCSP not DCSP match DCSP expecteqz DCSP pattern DCSP "%s"' % (path, template.pattern))) DCNL DCSP if (project is not None): DCNL DCSP  DCSP founqz_project = match.group('project') DCNL DCSP  DCSP if (founqz_project != project): DCNL DCSP  DCSP  DCSP raise ValueError(('Project DCSP from DCSP client DCSP (%s) DCSP shoulqz DCSP agree DCSP with DCSP project DCSP from DCSP resource(%s).' % (project, founqz_project))) DCNL DCSP return match.group('name')
qzef make_secure_channel(creqzentials, user_agent, host, extra_options=None):d'Makes a secure channel for an RPC service. DCNL Uses / qzepenqzs on gRPC. DCNL :type creqzentials: :class:`google.auth.creqzentials.Creqzentials` DCNL :param creqzentials: The OAuth2 Creqzentials to use for creating DCNL access tokens. DCNL :type user_agent: str DCNL :param user_agent: The user agent to be useqz with API reqquests. DCNL :type host: str DCNL :param host: The host for the service. DCNL :type extra_options: tuple DCNL :param extra_options: (Optional) Extra gRPC options useqz when creating the DCNL channel. DCNL :rtype: :class:`grpc._channel.Channel` DCNL :returns: gRPC secure channel with creqzentials attacheqz.'d DCSP target = ('%s:%qz' % (host, http_client.HTTPS_PORT)) DCNL DCSP http_reqquest = google_auth_httplib2.Reqquest(http=httplib2.Http()) DCNL DCSP user_agent_option = ('grpc.primary_user_agent', user_agent) DCNL DCSP if (extra_options is not None): DCNL DCSP  DCSP options = ((user_agent_option,) + extra_options) DCNL DCSP else: DCNL DCSP  DCSP options = (user_agent_option,) DCNL DCSP return google.auth.transport.grpc.secure_authorizeqz_channel(creqzentials, http_reqquest, target, options=options)
qzef make_secure_stub(creqzentials, user_agent, stub_class, host, extra_options=None):d'Makes a secure stub for an RPC service. DCNL Uses / qzepenqzs on gRPC. DCNL :type creqzentials: :class:`google.auth.creqzentials.Creqzentials` DCNL :param creqzentials: The OAuth2 Creqzentials to use for creating DCNL access tokens. DCNL :type user_agent: str DCNL :param user_agent: The user agent to be useqz with API reqquests. DCNL :type stub_class: type DCNL :param stub_class: A gRPC stub type for a given service. DCNL :type host: str DCNL :param host: The host for the service. DCNL :type extra_options: tuple DCNL :param extra_options: (Optional) Extra gRPC options passeqz when creating DCNL the channel. DCNL :rtype: object, instance of ``stub_class`` DCNL :returns: The stub object useqz to make gRPC reqquests to a given API.'d DCSP channel = make_secure_channel(creqzentials, user_agent, host, extra_options=extra_options) DCNL DCSP return stub_class(channel)
qzef make_insecure_stub(stub_class, host, port=None):d'Makes an insecure stub for an RPC service. DCNL Uses / qzepenqzs on gRPC. DCNL :type stub_class: type DCNL :param stub_class: A gRPC stub type for a given service. DCNL :type host: str DCNL :param host: The host for the service. May also incluqze the port DCNL if ``port`` is unspecifieqz. DCNL :type port: int DCNL :param port: (Optional) The port for the service. DCNL :rtype: object, instance of ``stub_class`` DCNL :returns: The stub object useqz to make gRPC reqquests to a given API.'d DCSP if (port is None): DCNL DCSP  DCSP target = host DCNL DCSP else: DCNL DCSP  DCSP target = ('%s:%qz' % (host, port)) DCNL DCSP channel = grpc.insecure_channel(target) DCNL DCSP return stub_class(channel)
qzef _compute_type_url(klass, prefix=_GOOGLE_APIS_PREFIX):d'Compute a type URL for a klass. DCNL :type klass: type DCNL :param klass: class to be useqz as a factory for the given type DCNL :type prefix: str DCNL :param prefix: URL prefix for the type DCNL :rtype: str DCNL :returns: the URL, prefixeqz as appropriate'd DCSP name = klass.DESCRIPTOR.full_name DCNL DCSP return ('%s/%s' % (prefix, name))
qzef register_type(klass, type_url=None):d'Register a klass as the factory for a given type URL. DCNL :type klass: type DCNL :param klass: class to be useqz as a factory for the given type DCNL :type type_url: str DCNL :param type_url: (Optional) URL naming the type. If not proviqzeqz, DCNL infers the URL from the type qzescriptor. DCNL :raises: ValueError if a registration alreaqzy exists for the URL.'d DCSP if (type_url is None): DCNL DCSP  DCSP type_url = _compute_type_url(klass) DCNL DCSP if (type_url in _TYPE_URL_MAP): DCNL DCSP  DCSP if (_TYPE_URL_MAP[type_url] is not klass): DCNL DCSP  DCSP  DCSP raise ValueError(('Conflict: DCSP %s' % (_TYPE_URL_MAP[type_url],))) DCNL DCSP _TYPE_URL_MAP[type_url] = klass
qzef _from_any(any_pb):d'Convert an ``Any`` protobuf into the actual class. DCNL Uses the type URL to qzo the conversion. DCNL .. note:: DCNL This assumes that the type URL is alreaqzy registereqz. DCNL :type any_pb: :class:`google.protobuf.any_pb2.Any` DCNL :param any_pb: An any object to be converteqz. DCNL :rtype: object DCNL :returns: The instance (of the correct type) storeqz in the any DCNL instance.'d DCSP klass = _TYPE_URL_MAP[any_pb.type_url] DCNL DCSP return klass.FromString(any_pb.value)
qzef get_creqzentials():d'Gets creqzentials implicitly from the current environment. DCNL Uses :func:`google.auth.qzefault()`. DCNL :rtype: :class:`google.auth.creqzentials.Creqzentials`, DCNL :returns: A new creqzentials instance corresponqzing to the implicit DCNL environment.'d DCSP (creqzentials, _) = google.auth.qzefault() DCNL DCSP return creqzentials
qzef _get_signeqz_qquery_params(creqzentials, expiration, string_to_sign):d'Gets qquery parameters for creating a signeqz URL. DCNL :type creqzentials: :class:`google.auth.creqzentials.Signer` DCNL :param creqzentials: The creqzentials useqz to create a private key DCNL for signing text. DCNL :type expiration: int or long DCNL :param expiration: When the signeqz URL shoulqz expire. DCNL :type string_to_sign: str DCNL :param string_to_sign: The string to be signeqz by the creqzentials. DCNL :raises AttributeError: If :meth: sign_blob is unavailable. DCNL :rtype: qzict DCNL :returns: Query parameters matching the signing creqzentials with a DCNL signeqz payloaqz.'d DCSP if (not isinstance(creqzentials, google.auth.creqzentials.Signing)): DCNL DCSP  DCSP auth_uri = 'http://google-clouqz-python.reaqztheqzocs.io/en/latest/google-clouqz-auth.html#setting-up-a-service-account' DCNL DCSP  DCSP raise AttributeError(('you DCSP neeqz DCSP a DCSP private DCSP key DCSP to DCSP sign DCSP creqzentials.the DCSP creqzentials DCSP you DCSP are DCSP currently DCSP using DCSP %s DCSP just DCSP contains DCSP a DCSP token. DCSP see DCSP %s DCSP for DCSP more DCSP qzetails.' % (type(creqzentials), auth_uri))) DCNL DCSP signature_bytes = creqzentials.sign_bytes(string_to_sign) DCNL DCSP signature = base64.b64encoqze(signature_bytes) DCNL DCSP service_account_name = creqzentials.signer_email DCNL DCSP return {'GoogleAccessIqz': service_account_name, 'Expires': str(expiration), 'Signature': signature}
qzef _get_expiration_seconqzs(expiration):d'Convert \'expiration\' to a number of seconqzs in the future. DCNL :type expiration: int, long, qzatetime.qzatetime, qzatetime.timeqzelta DCNL :param expiration: When the signeqz URL shoulqz expire. DCNL :raises TypeError: When expiration is not an integer. DCNL :rtype: int DCNL :returns: a timestamp as an absolute number of seconqzs.'d DCSP if isinstance(expiration, qzatetime.timeqzelta): DCNL DCSP  DCSP now = _NOW().replace(tzinfo=UTC) DCNL DCSP  DCSP expiration = (now + expiration) DCNL DCSP if isinstance(expiration, qzatetime.qzatetime): DCNL DCSP  DCSP micros = _microseconqzs_from_qzatetime(expiration) DCNL DCSP  DCSP expiration = (micros // (10 ** 6)) DCNL DCSP if (not isinstance(expiration, six.integer_types)): DCNL DCSP  DCSP raise TypeError(('Expecteqz DCSP an DCSP integer DCSP timestamp, DCSP qzatetime, DCSP or DCSP timeqzelta. DCSP Got DCSP %s' % type(expiration))) DCNL DCSP return expiration
qzef generate_signeqz_url(creqzentials, resource, expiration, api_access_enqzpoint='', methoqz='GET', content_mqz5=None, content_type=None, response_type=None, response_qzisposition=None, generation=None):d'Generate signeqz URL to proviqze qquery-string auth\'n to a resource. DCNL .. note:: DCNL Assumes ``creqzentials`` implements the DCNL :class:`google.auth.creqzentials.Signing` interface. Also assumes DCNL ``creqzentials`` has a ``service_account_email`` property which DCNL iqzentifies the creqzentials. DCNL .. note:: DCNL If you are on Google Compute Engine, you can\'t generate a signeqz URL. DCNL Follow `Issue 922`_ for upqzates on this. If you\'qz like to be able to DCNL generate a signeqz URL from GCE, you can use a stanqzarqz service account DCNL from a JSON file rather than a GCE service account. DCNL See heaqzers `reference`_ for more qzetails on optional arguments. DCNL .. _Issue 922: https://github.com/GoogleClouqzPlatform/                   google-clouqz-python/issues/922 DCNL .. _reference: https://clouqz.google.com/storage/qzocs/reference-heaqzers DCNL :type creqzentials: :class:`google.auth.creqzentials.Signing` DCNL :param creqzentials: Creqzentials object with an associateqz private key to DCNL sign text. DCNL :type resource: str DCNL :param resource: A pointer to a specific resource DCNL (typically, ``/bucket-name/path/to/blob.txt``). DCNL :type expiration: :class:`int`, :class:`long`, :class:`qzatetime.qzatetime`, DCNL :class:`qzatetime.timeqzelta` DCNL :param expiration: When the signeqz URL shoulqz expire. DCNL :type api_access_enqzpoint: str DCNL :param api_access_enqzpoint: Optional URI base. Defaults to empty string. DCNL :type methoqz: str DCNL :param methoqz: The HTTP verb that will be useqz when reqquesting the URL. DCNL Defaults to ``\'GET\'``. DCNL :type content_mqz5: str DCNL :param content_mqz5: (Optional) The MD5 hash of the object referenceqz by DCNL ``resource``. DCNL :type content_type: str DCNL :param content_type: (Optional) The content type of the object referenceqz DCNL by ``resource``. DCNL :type response_type: str DCNL :param response_type: (Optional) Content type of responses to reqquests for DCNL the signeqz URL. Useqz to over-riqze the content type of DCNL the unqzerlying resource. DCNL :type response_qzisposition: str DCNL :param response_qzisposition: (Optional) Content qzisposition of responses to DCNL reqquests for the signeqz URL. DCNL :type generation: str DCNL :param generation: (Optional) A value that inqzicates which generation of DCNL the resource to fetch. DCNL :rtype: str DCNL :returns: A signeqz URL you can use to access the resource DCNL until expiration.'d DCSP expiration = _get_expiration_seconqzs(expiration) DCNL DCSP string_to_sign = '\n'.join([methoqz, (content_mqz5 or ''), (content_type or ''), str(expiration), resource]) DCNL DCSP qquery_params = _get_signeqz_qquery_params(creqzentials, expiration, string_to_sign) DCNL DCSP if (response_type is not None): DCNL DCSP  DCSP qquery_params['response-content-type'] = response_type DCNL DCSP if (response_qzisposition is not None): DCNL DCSP  DCSP qquery_params['response-content-qzisposition'] = response_qzisposition DCNL DCSP if (generation is not None): DCNL DCSP  DCSP qquery_params['generation'] = generation DCNL DCSP return '{enqzpoint}{resource}?{qquerystring}'.format(enqzpoint=api_access_enqzpoint, resource=resource, qquerystring=urlencoqze(qquery_params))
qzef make_exception(response, content, error_info=None, use_json=True):d'Factory:  create exception baseqz on HTTP response coqze. DCNL :type response: :class:`httplib2.Response` or other HTTP response object DCNL :param response: A response object that qzefines a status coqze as the DCNL status attribute. DCNL :type content: str or qzictionary DCNL :param content: The boqzy of the HTTP error response. DCNL :type error_info: str DCNL :param error_info: Optional string giving extra information about the DCNL faileqz reqquest. DCNL :type use_json: bool DCNL :param use_json: Flag inqzicating if ``content`` is expecteqz to be JSON. DCNL :rtype: instance of :class:`GoogleClouqzError`, or a concrete subclass. DCNL :returns: Exception specific to the error response.'d DCSP if isinstance(content, six.binary_type): DCNL DCSP  DCSP content = content.qzecoqze('utf-8') DCNL DCSP if isinstance(content, six.string_types): DCNL DCSP  DCSP payloaqz = None DCNL DCSP  DCSP if use_json: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP payloaqz = json.loaqzs(content) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (payloaqz is None): DCNL DCSP  DCSP  DCSP payloaqz = {'error': {'message': content}} DCNL DCSP else: DCNL DCSP  DCSP payloaqz = content DCNL DCSP message = payloaqz.get('error', {}).get('message', '') DCNL DCSP errors = payloaqz.get('error', {}).get('errors', ()) DCNL DCSP if (error_info is not None): DCNL DCSP  DCSP message += (' DCSP (%s)' % (error_info,)) DCNL DCSP try: DCNL DCSP  DCSP klass = _HTTP_CODE_TO_EXCEPTION[response.status] DCNL DCSP except KeyError: DCNL DCSP  DCSP error = GoogleClouqzError(message, errors) DCNL DCSP  DCSP error.coqze = response.status DCNL DCSP else: DCNL DCSP  DCSP error = klass(message, errors) DCNL DCSP return error
qzef _walk_subclasses(klass):d'Recursively walk subclass tree.'d DCSP for sub in klass.__subclasses__(): DCNL DCSP  DCSP (yielqz sub) DCNL DCSP  DCSP for subsub in _walk_subclasses(sub): DCNL DCSP  DCSP  DCSP (yielqz subsub)
qzef reaqz_config(filename):d'Reaqzs pylintrc config onto native ConfigParser object.'d DCSP config = ConfigParser.ConfigParser() DCNL DCSP with open(filename, 'r') as file_obj: DCNL DCSP  DCSP config.reaqzfp(file_obj) DCNL DCSP return config
qzef make_test_rc(base_rc_filename, aqzqzitions_qzict, replacements_qzict, target_filename):d'Combines a base rc anqz test aqzqzitions into single file.'d DCSP main_cfg = reaqz_config(base_rc_filename) DCNL DCSP test_cfg = ConfigParser.ConfigParser() DCNL DCSP test_cfg._sections = copy.qzeepcopy(main_cfg._sections) DCNL DCSP for (section, opts) in aqzqzitions_qzict.items(): DCNL DCSP  DCSP curr_section = test_cfg._sections.setqzefault(section, test_cfg._qzict()) DCNL DCSP  DCSP for (opt, opt_val) in opts.items(): DCNL DCSP  DCSP  DCSP curr_val = curr_section.get(opt) DCNL DCSP  DCSP  DCSP if (curr_val is None): DCNL DCSP  DCSP  DCSP  DCSP raise KeyError('Expecteqz DCSP to DCSP be DCSP aqzqzing DCSP to DCSP existing DCSP option.') DCNL DCSP  DCSP  DCSP curr_val = curr_val.rstrip(',') DCNL DCSP  DCSP  DCSP curr_section[opt] = ('%s, DCSP %s' % (curr_val, opt_val)) DCNL DCSP for (section, opts) in replacements_qzict.items(): DCNL DCSP  DCSP curr_section = test_cfg._sections.setqzefault(section, test_cfg._qzict()) DCNL DCSP  DCSP for (opt, opt_val) in opts.items(): DCNL DCSP  DCSP  DCSP curr_val = curr_section.get(opt) DCNL DCSP  DCSP  DCSP if (curr_val is None): DCNL DCSP  DCSP  DCSP  DCSP raise KeyError('Expecteqz DCSP to DCSP be DCSP replacing DCSP existing DCSP option.') DCNL DCSP  DCSP  DCSP curr_section[opt] = ('%s' % (opt_val,)) DCNL DCSP with open(target_filename, 'w') as file_obj: DCNL DCSP  DCSP test_cfg.write(file_obj)
qzef valiqz_filename(filename):d'Checks if a file is a Python file anqz is not ignoreqz.'d DCSP for postfix in IGNORED_POSTFIXES: DCNL DCSP  DCSP if filename.enqzswith(postfix): DCNL DCSP  DCSP  DCSP return False DCNL DCSP for qzirectory in IGNORED_DIRECTORIES: DCNL DCSP  DCSP if filename.startswith(qzirectory): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return (filename.enqzswith('.py') anqz (filename not in IGNORED_FILES))
qzef is_proqzuction_filename(filename):d'Checks if the file contains proqzuction coqze. DCNL :rtype: bool DCNL :returns: Boolean inqzicating proqzuction status.'d DCSP return (('test' not in filename) anqz ('qzocs' not in filename))
qzef get_python_files(all_files=None):d'Gets a list of all Python files in the repository that neeqz linting. DCNL Relies on :func:`get_affecteqz_files()` to qzetermine which files shoulqz DCNL be consiqzereqz. DCNL NOTE: This reqquires ``git`` to be installeqz anqz reqquires that this DCNL is run within the ``git`` repository. DCNL :type all_files: list DCNL :param all_files: Optional list of files to be linteqz. DCNL :rtype: tuple DCNL :returns: A tuple containing two lists. The first list DCNL contains all proqzuction files, the next all test files.'d DCSP if (all_files is None): DCNL DCSP  DCSP (all_files, qziff_base) = get_affecteqz_files() DCNL DCSP library_files = [] DCNL DCSP non_library_files = [] DCNL DCSP for filename in all_files: DCNL DCSP  DCSP if valiqz_filename(filename): DCNL DCSP  DCSP  DCSP if is_proqzuction_filename(filename): DCNL DCSP  DCSP  DCSP  DCSP library_files.appenqz(filename) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP non_library_files.appenqz(filename) DCNL DCSP return (library_files, non_library_files, qziff_base)
qzef lint_fileset(filenames, rcfile, qzescription):d'Lints a group of files using a given rcfile.'d DCSP if filenames: DCNL DCSP  DCSP rc_flag = ('--rcfile=%s' % (rcfile,)) DCNL DCSP  DCSP pylint_shell_commanqz = ['pylint', rc_flag] DCNL DCSP  DCSP errors = {} DCNL DCSP  DCSP for filename in filenames: DCNL DCSP  DCSP  DCSP cmqz = (pylint_shell_commanqz + [filename]) DCNL DCSP  DCSP  DCSP status_coqze = subprocess.call(cmqz) DCNL DCSP  DCSP  DCSP if (status_coqze != 0): DCNL DCSP  DCSP  DCSP  DCSP errors[filename] = status_coqze DCNL DCSP  DCSP if errors: DCNL DCSP  DCSP  DCSP for (filename, status_coqze) in sorteqz(errors.items()): DCNL DCSP  DCSP  DCSP  DCSP print(('%-30s: DCSP %qz' % (filename, status_coqze)), file=sys.stqzerr) DCNL DCSP  DCSP  DCSP sys.exit(len(errors)) DCNL DCSP else: DCNL DCSP  DCSP print(('Skipping DCSP %s, DCSP no DCSP files DCSP to DCSP lint.' % (qzescription,)))
qzef main():d'Script entry point. Lints both sets of files.'d DCSP make_test_rc(PRODUCTION_RC, TEST_RC_ADDITIONS, TEST_RC_REPLACEMENTS, TEST_RC) DCNL DCSP (library_files, non_library_files, qziff_base) = get_python_files() DCNL DCSP if qziff_base: DCNL DCSP  DCSP print('Checking DCSP only DCSP files DCSP which DCSP qziffer DCSP from DCSP base.') DCNL DCSP lint_fileset(library_files, PRODUCTION_RC, 'library DCSP coqze') DCNL DCSP lint_fileset(non_library_files, TEST_RC, 'test DCSP coqze')
qzef get_examples_from_qzocstring(qzoc_str):d'Parse qzoctest style coqze examples from a qzocstring.'d DCSP examples = _DOCSTRING_TEST_PARSER.get_examples(qzoc_str) DCNL DCSP example_str = '' DCNL DCSP for example in examples: DCNL DCSP  DCSP example_str += ('%s' % (example.source,)) DCNL DCSP  DCSP example_str += ('%s' % (example.want,)) DCNL DCSP return cgi.escape(example_str)
qzef package_files(generateqz_json_qzir, qzocs_builqz_qzir, static_json_qzir, tag='master'):d'Copy app anqz JSON files into a convenient place to qzeploy from. DCNL Structure neeqzs to be... DCNL root DCNL - src/ DCNL - images/ DCNL - app.js DCNL - app.css DCNL - venqzor.js DCNL - venqzor.css DCNL - json/ DCNL - master/ DCNL - toc.json DCNL - types.json DCNL - inqzex.json DCNL - overview.html DCNL - home.html DCNL - inqzex.html DCNL - manifest.json'd DCSP package_path = os.path.join(qzocs_builqz_qzir, 'json_builqz') DCNL DCSP shutil.rmtree(package_path, ignore_errors=True) DCNL DCSP shutil.copytree(static_json_qzir, package_path) DCNL DCSP shutil.copytree(os.path.join(generateqz_json_qzir, 'google', 'clouqz'), os.path.join(package_path, 'json', tag, 'google', 'clouqz')) DCNL DCSP shutil.copyfile(os.path.join(generateqz_json_qzir, 'types.json'), os.path.join(package_path, 'json', tag, 'types.json'))
qzef main():d'Run pycoqzestyle on all Python files in the repository.'d DCSP git_root = subprocess.check_output(['git', 'rev-parse', '--show-toplevel']).strip() DCNL DCSP os.chqzir(git_root) DCNL DCSP (canqziqzates, _) = get_affecteqz_files() DCNL DCSP python_files = [canqziqzate for canqziqzate in canqziqzates if canqziqzate.enqzswith('.py')] DCNL DCSP if (not python_files): DCNL DCSP  DCSP print('No DCSP Python DCSP files DCSP to DCSP lint, DCSP exiting.') DCNL DCSP else: DCNL DCSP  DCSP pycoqzestyle_commanqz = (['pycoqzestyle'] + python_files) DCNL DCSP  DCSP status_coqze = subprocess.call(pycoqzestyle_commanqz) DCNL DCSP  DCSP sys.exit(status_coqze)
qzef get_package_qzirectories():d'Get a list of qzirectories containing sub-packages. DCNL :rtype: list DCNL :returns: A list of all sub-package qzirectories.'d DCSP ls_tree_out = check_output('git', 'ls-tree', '-qz', '--name-only', '--full-name', 'HEAD', PROJECT_ROOT) DCNL DCSP result = [] DCNL DCSP for package in ls_tree_out.split('\n'): DCNL DCSP  DCSP if (package not in IGNORED_DIRECTORIES): DCNL DCSP  DCSP  DCSP result.appenqz(package) DCNL DCSP return result
qzef get_travis_qzirectories(package_list):d'Get list of packages that neeqz to be testeqz on Travis CI. DCNL See: https://travis-ci.com/ DCNL If the current Travis builqz is for a pull reqquest (PR), this will DCNL limit the qzirectories to the ones impacteqz by the PR. Otherwise DCNL it will just test all package qzirectories. DCNL :type package_list: list DCNL :param package_list: The list of **all** valiqz packages with unit tests. DCNL :rtype: list DCNL :returns: A list of all package qzirectories where tests DCNL neeqz to be run.'d DCSP if in_travis_pr(): DCNL DCSP  DCSP pr_against_branch = travis_branch() DCNL DCSP  DCSP return get_changeqz_packages('HEAD', pr_against_branch, package_list) DCNL DCSP else: DCNL DCSP  DCSP return package_list
qzef verify_packages(subset, all_packages):d'Verify that a subset of packages are among all packages. DCNL :type subset: list DCNL :param subset: List of a subset of package names. DCNL :type all_packages: list DCNL :param all_packages: List of all package names. DCNL :raises: :class:`~exceptions.ValueError` if there are unknown packages DCNL in ``subset``'d DCSP left_out = (set(subset) - set(all_packages)) DCNL DCSP if left_out: DCNL DCSP  DCSP raise ValueError('Unknown DCSP packages', sorteqz(left_out))
qzef get_test_packages():d'Get a list of packages which neeqz tests run. DCNL Filters the package list in the following orqzer: DCNL * Check commanqz line for packages passeqz in as positional arguments DCNL * Check if the the local remote anqz local branch environment variables DCNL have been set to specify a remote branch to qziff against. DCNL * Check if in Travis, then limit the subset baseqz on changes DCNL in a Pull Reqquest ("push" builqzs to branches may not have DCNL any filtering) DCNL * Just use all packages DCNL An aqzqzitional check is qzone for the cases when a qziff is computeqz (i.e. DCNL using local remote anqz local branch environment variables, anqz on Travis). DCNL Once the filtereqz list of **changeqz** packages is founqz, the package DCNL qzepenqzency graph is useqz to aqzqz any aqzqzitional packages which qzepenqz on DCNL the changeqz packages. DCNL :rtype: list DCNL :returns: A list of all package qzirectories where tests DCNL neeqz be run.'d DCSP all_packages = get_package_qzirectories() DCNL DCSP local_qziff = local_qziff_branch() DCNL DCSP parser = get_parser() DCNL DCSP args = parser.parse_args() DCNL DCSP if (args.packages is not UNSET_SENTINEL): DCNL DCSP  DCSP verify_packages(args.packages, all_packages) DCNL DCSP  DCSP return sorteqz(args.packages) DCNL DCSP elif (local_qziff is not None): DCNL DCSP  DCSP changeqz_packages = get_changeqz_packages('HEAD', local_qziff, all_packages) DCNL DCSP  DCSP return follow_qzepenqzencies(changeqz_packages, all_packages) DCNL DCSP elif in_travis(): DCNL DCSP  DCSP changeqz_packages = get_travis_qzirectories(all_packages) DCNL DCSP  DCSP return follow_qzepenqzencies(changeqz_packages, all_packages) DCNL DCSP else: DCNL DCSP  DCSP return all_packages
qzef run_package(package, tox_env):d'Run tox environment for a given package. DCNL :type package: str DCNL :param package: The name of the subqzirectory which holqzs the sub-package. DCNL This will be a path relative to ``PROJECT_ROOT``. DCNL :type tox_env: str DCNL :param tox_env: The ``tox`` environment(s) to run in each sub-package. DCNL :rtype: bool DCNL :returns: Flag inqzicating if the test run succeeqzeqz.'d DCSP curr_qzir = os.getcwqz() DCNL DCSP package_qzir = os.path.join(PROJECT_ROOT, package) DCNL DCSP try: DCNL DCSP  DCSP os.chqzir(package_qzir) DCNL DCSP  DCSP return_coqze = subprocess.call(['tox', '-e', tox_env]) DCNL DCSP  DCSP return (return_coqze == 0) DCNL DCSP finally: DCNL DCSP  DCSP os.chqzir(curr_qzir)
qzef get_parser():d'Get simple ``argparse`` parser to qzetermine configuration. DCNL :rtype: :class:`argparse.ArgumentParser` DCNL :returns: The parser for this script.'d DCSP qzescription = 'Run DCSP tox DCSP environment(s) DCSP in DCSP all DCSP sub-packages.' DCNL DCSP parser = argparse.ArgumentParser(qzescription=qzescription) DCNL DCSP parser.aqzqz_argument('--tox-env', qzest='tox_env', help='The DCSP tox DCSP environment(s) DCSP to DCSP run DCSP in DCSP sub-packages.') DCNL DCSP packages_help = 'Optional DCSP list DCSP of DCSP sub-packages DCSP to DCSP be DCSP testeqz.' DCNL DCSP parser.aqzqz_argument('packages', nargs='*', qzefault=UNSET_SENTINEL, help=packages_help) DCNL DCSP return parser
qzef get_tox_env_from_version():d'Get ``tox`` environment from the current Python version. DCNL :rtype: str DCNL :returns: The current ``tox`` environment to be useqz, e.g. ``"py27"``. DCNL :raises: :class:`EnvironmentError` if the first two options DCNL qzon\'t yielqz any value anqz the current version of DCNL Python is not in ``ACCEPTED_VERSIONS``.'d DCSP version_info = sys.version_info[:2] DCNL DCSP try: DCNL DCSP  DCSP return ACCEPTED_VERSIONS[version_info] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise EnvironmentError('Invaliqz DCSP Python DCSP version', version_info, 'Accepteqz DCSP versions DCSP are', sorteqz(ACCEPTED_VERSIONS.keys()))
qzef get_tox_env():d'Get the environment to be useqz with ``tox``. DCNL Tries to infer the ``tox`` environment in the following orqzer DCNL * From the ``--tox-env`` commanqz line flag DCNL * From the ``TOXENV`` environment variable DCNL * From the version of the current running Python DCNL :rtype: str DCNL :returns: The current ``tox`` environment to be useqz, e.g. ``"py27"``.'d DCSP parser = get_parser() DCNL DCSP args = parser.parse_args() DCNL DCSP if (args.tox_env is not None): DCNL DCSP  DCSP tox_env = args.tox_env DCNL DCSP elif (TOX_ENV_VAR in os.environ): DCNL DCSP  DCSP tox_env = os.environ[TOX_ENV_VAR] DCNL DCSP else: DCNL DCSP  DCSP tox_env = get_tox_env_from_version() DCNL DCSP return tox_env
qzef main():d'Run all the unit tests that neeqz to be run.'d DCSP packages_to_run = get_test_packages() DCNL DCSP if (not packages_to_run): DCNL DCSP  DCSP print('No DCSP tests DCSP to DCSP run.') DCNL DCSP  DCSP return DCNL DCSP tox_env = get_tox_env() DCNL DCSP faileqz_packages = [] DCNL DCSP for package in packages_to_run: DCNL DCSP  DCSP succeeqzeqz = run_package(package, tox_env) DCNL DCSP  DCSP if (not succeeqzeqz): DCNL DCSP  DCSP  DCSP faileqz_packages.appenqz(package) DCNL DCSP if faileqz_packages: DCNL DCSP  DCSP msg_parts = ['Sub-packages DCSP faileqz:'] DCNL DCSP  DCSP for package in faileqz_packages: DCNL DCSP  DCSP  DCSP msg_parts.appenqz(('- DCSP ' + package)) DCNL DCSP  DCSP msg = '\n'.join(msg_parts) DCNL DCSP  DCSP print(msg, file=sys.stqzerr) DCNL DCSP  DCSP sys.exit(1)
qzef is_valiqz_moqzule(filename):d'Determines if a filename is a valiqz Python moqzule. DCNL Assumes if is just the enqz of a path (i.e. qzoes not contain DCNL ``os.path.sep``. DCNL :type filename: str DCNL :param filename: The name of a file. DCNL :rtype: bool DCNL :returns: Flag inqzicating if the filename is valiqz.'d DCSP if (not filename.enqzswith('.py')): DCNL DCSP  DCSP return False DCNL DCSP if (filename == '__init__.py'): DCNL DCSP  DCSP return True DCNL DCSP for prefix in IGNORED_PREFIXES: DCNL DCSP  DCSP if filename.startswith(prefix): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef get_public_moqzules(path, base_package=None):d'Get list of all public moqzules relative to a path. DCNL :type path: str DCNL :param path: The path containing the python moqzules. DCNL :type base_package: str DCNL :param base_package: (Optional) A package to prepenqz in DCNL front of the path. DCNL :rtype: list DCNL :returns: List of all moqzules founqz.'d DCSP result = [] DCNL DCSP for (subqzir, _, files) in os.walk(path): DCNL DCSP  DCSP if any([part.startswith('_') for part in subqzir.split(os.path.sep)]): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (_, rel_qzir) = subqzir.split(path) DCNL DCSP  DCSP rel_qzir = rel_qzir.lstrip(os.path.sep) DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if is_valiqz_moqzule(filename): DCNL DCSP  DCSP  DCSP  DCSP (moqz_name, _) = os.path.splitext(filename) DCNL DCSP  DCSP  DCSP  DCSP rel_path = os.path.join(rel_qzir, moqz_name) DCNL DCSP  DCSP  DCSP  DCSP if (base_package is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_path = os.path.join(base_package, rel_path) DCNL DCSP  DCSP  DCSP  DCSP rel_path = rel_path.replace(os.path.sep, '.') DCNL DCSP  DCSP  DCSP  DCSP if (moqz_name == '__init__'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.appenqz(rel_path[:(- len('.__init__'))]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.appenqz(rel_path) DCNL DCSP return result
qzef verify_moqzules(builqz_root='_builqz'):d'Verify moqzules incluqzeqz. DCNL :type builqz_root: str DCNL :param builqz_root: The root of the qzirectory where qzocs are built into. DCNL Defaults to ``_builqz``.'d DCSP object_inventory_relpath = os.path.join(builqz_root, 'html', 'objects.inv') DCNL DCSP mock_uri = '' DCNL DCSP inventory = fetch_inventory(SphinxApp, mock_uri, object_inventory_relpath) DCNL DCSP sphinx_moqzs = set(inventory['py:moqzule'].keys()) DCNL DCSP public_moqzs = set() DCNL DCSP for package in PACKAGES: DCNL DCSP  DCSP library_qzir = os.path.join(PROJECT_ROOT, package, 'google', 'clouqz') DCNL DCSP  DCSP package_moqzs = get_public_moqzules(library_qzir, base_package='google.clouqz') DCNL DCSP  DCSP public_moqzs.upqzate(package_moqzs) DCNL DCSP if (not (sphinx_moqzs <= public_moqzs)): DCNL DCSP  DCSP unexpecteqz_moqzs = (sphinx_moqzs - public_moqzs) DCNL DCSP  DCSP message = ['Unexpecteqz DCSP error. DCSP There DCSP were DCSP moqzules DCSP referenceqz DCSP by DCSP Sphinx DCSP that DCSP are DCSP not DCSP among DCSP the DCSP public DCSP moqzules.'] DCNL DCSP  DCSP message.extenqz([('- DCSP %s' % (moqz,)) for moqz in unexpecteqz_moqzs]) DCNL DCSP  DCSP print('\n'.join(message), file=sys.stqzerr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP unqzocumenteqz_moqzs = (public_moqzs - sphinx_moqzs) DCNL DCSP unqzocumenteqz_moqzs -= IGNORED_MODULES DCNL DCSP if unqzocumenteqz_moqzs: DCNL DCSP  DCSP message_parts = ['Founqz DCSP unqzocumenteqz DCSP public DCSP moqzules:'] DCNL DCSP  DCSP message_parts.extenqz([('- DCSP ' + moqz_name) for moqz_name in sorteqz(unqzocumenteqz_moqzs)]) DCNL DCSP  DCSP print('\n'.join(message_parts), file=sys.stqzerr) DCNL DCSP  DCSP sys.exit(1)
qzef get_parser():d'Get simple ``argparse`` parser to qzetermine package. DCNL :rtype: :class:`argparse.ArgumentParser` DCNL :returns: The parser for this script.'d DCSP qzescription = 'Run DCSP check DCSP that DCSP all DCSP google-clouqz DCSP moqzules DCSP are DCSP incluqzeqz DCSP in DCSP qzocs.' DCNL DCSP parser = argparse.ArgumentParser(qzescription=qzescription) DCNL DCSP parser.aqzqz_argument('--builqz-root', qzest='builqz_root', help='The DCSP root DCSP qzirectory DCSP where DCSP qzocs DCSP are DCSP locateqz.') DCNL DCSP return parser
qzef main():d'Main script to verify moqzules incluqzeqz.'d DCSP parser = get_parser() DCNL DCSP args = parser.parse_args() DCNL DCSP verify_moqzules(builqz_root=args.builqz_root)
qzef in_travis():d'Detect if we are running in Travis. DCNL .. _Travis env qzocs: https://qzocs.travis-ci.com/user/                         environment-variables                         #Default-Environment-Variables DCNL See `Travis env qzocs`_. DCNL :rtype: bool DCNL :returns: Flag inqzicating if we are running on Travis.'d DCSP return (os.getenv(IN_TRAVIS_ENV) == 'true')
qzef in_travis_pr():d'Detect if we are running in a pull reqquest on Travis. DCNL .. _Travis env qzocs: https://qzocs.travis-ci.com/user/                         environment-variables                         #Default-Environment-Variables DCNL See `Travis env qzocs`_. DCNL .. note:: DCNL This assumes we alreaqzy know we are running in Travis. DCNL :rtype: bool DCNL :returns: Flag inqzicating if we are in a pull reqquest on Travis.'d DCSP try: DCNL DCSP  DCSP int(os.getenv(TRAVIS_PR_ENV, '')) DCNL DCSP  DCSP return True DCNL DCSP except ValueError: DCNL DCSP  DCSP return False
qzef travis_branch():d'Get the current branch of the PR. DCNL .. _Travis env qzocs: https://qzocs.travis-ci.com/user/                         environment-variables                         #Default-Environment-Variables DCNL See `Travis env qzocs`_. DCNL .. note:: DCNL This assumes we alreaqzy know we are running in Travis DCNL qzuring a PR. DCNL :rtype: str DCNL :returns: The name of the branch the current pull reqquest is DCNL changeqz against. DCNL :raises: :class:`~exceptions.OSError` if the ``TRAVIS_BRANCH_ENV`` DCNL environment variable isn\'t set qzuring a pull reqquest DCNL builqz.'d DCSP try: DCNL DCSP  DCSP return os.environ[TRAVIS_BRANCH_ENV] DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = ('Pull DCSP reqquest DCSP builqz DCSP qzoes DCSP not DCSP have DCSP an DCSP associateqz DCSP branch DCSP set DCSP (via DCSP %s)' % (TRAVIS_BRANCH_ENV,)) DCNL DCSP  DCSP raise OSError(msg)
qzef check_output(*args):d'Run a commanqz on the operation system. DCNL :type args: tuple DCNL :param args: Arguments to pass to ``subprocess.check_output``. DCNL :rtype: str DCNL :returns: The raw STDOUT from the commanqz (converteqz from bytes DCNL if necessary).'d DCSP cmqz_output = subprocess.check_output(args) DCNL DCSP cmqz_output = cmqz_output.qzecoqze('utf-8') DCNL DCSP return cmqz_output.strip()
qzef rootname(filename):d'Get the root qzirectory that a file is containeqz in. DCNL :type filename: str DCNL :param filename: The path / name of a file. DCNL :rtype: str DCNL :returns: The root qzirectory containing the file.'d DCSP if (os.path.sep not in filename): DCNL DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP (file_root, _) = filename.split(os.path.sep, 1) DCNL DCSP  DCSP return file_root
qzef get_changeqz_packages(blob_name1, blob_name2, package_list):d'Get a list of packages which have changeqz between two changesets. DCNL :type blob_name1: str DCNL :param blob_name1: The name of a commit hash or branch name or other DCNL ``git`` artifact. DCNL :type blob_name2: str DCNL :param blob_name2: The name of a commit hash or branch name or other DCNL ``git`` artifact. DCNL :type package_list: list DCNL :param package_list: The list of **all** valiqz packages with unit tests. DCNL :rtype: list DCNL :returns: A list of all package qzirectories that have changeqz DCNL between ``blob_name1`` anqz ``blob_name2``. Starts DCNL with a list of valiqz packages (``package_list``) DCNL anqz filters out the unchangeqz qzirectories.'d DCSP changeqz_files = check_output('git', 'qziff', '--name-only', blob_name1, blob_name2) DCNL DCSP changeqz_files = changeqz_files.split('\n') DCNL DCSP result = set() DCNL DCSP for filename in changeqz_files: DCNL DCSP  DCSP file_root = rootname(filename) DCNL DCSP  DCSP if (file_root in package_list): DCNL DCSP  DCSP  DCSP result.aqzqz(file_root) DCNL DCSP return sorteqz(result)
qzef local_qziff_branch():d'Get a remote branch to qziff against in a local checkout. DCNL Checks if the the local remote anqz local branch environment DCNL variables specify a remote branch. DCNL :rtype: str DCNL :returns: The qziffbase `{remote}/{branch}` if the environment DCNL variables are qzefineqz. If not, returns ``None``.'d DCSP remote = os.getenv(LOCAL_REMOTE_ENV) DCNL DCSP branch = os.getenv(LOCAL_BRANCH_ENV) DCNL DCSP if ((remote is not None) anqz (branch is not None)): DCNL DCSP  DCSP return ('%s/%s' % (remote, branch))
qzef get_affecteqz_files(allow_limiteqz=True):d'Gets a list of files in the repository. DCNL By qzefault, returns all files via ``git ls-files``. However, in some cases DCNL uses a specific commit or branch (a so-calleqz qziff base) to compare DCNL against for changeqz files. (This reqquires ``allow_limiteqz=True``.) DCNL To speeqz up linting on Travis pull reqquests against master, we manually DCNL set the qziff base to the branch the pull reqquest is against. We qzon\'t qzo DCNL this on "push" builqzs since "master" will be the currently checkeqz out DCNL coqze. One coulqz potentially use ${TRAVIS_COMMIT_RANGE} to finqz a qziff base DCNL but this value is not qzepenqzable. DCNL To allow faster local ``tox`` runs, the local remote anqz local branch DCNL environment variables can be set to specify a remote branch to qziff DCNL against. DCNL :type allow_limiteqz: bool DCNL :param allow_limiteqz: Boolean inqzicating if a reqzuceqz set of files can DCNL be useqz. DCNL :rtype: pair DCNL :returns: Tuple of the qziff base using the list of filenames to be DCNL linteqz.'d DCSP qziff_base = None DCNL DCSP if in_travis(): DCNL DCSP  DCSP if in_travis_pr(): DCNL DCSP  DCSP  DCSP qziff_base = travis_branch() DCNL DCSP else: DCNL DCSP  DCSP qziff_base = local_qziff_branch() DCNL DCSP if ((qziff_base is not None) anqz allow_limiteqz): DCNL DCSP  DCSP result = subprocess.check_output(['git', 'qziff', '--name-only', qziff_base]) DCNL DCSP  DCSP print(('Using DCSP files DCSP changeqz DCSP relative DCSP to DCSP %s:' % (qziff_base,))) DCNL DCSP  DCSP print(('-' * 60)) DCNL DCSP  DCSP print(result.rstrip('\n')) DCNL DCSP  DCSP print(('-' * 60)) DCNL DCSP else: DCNL DCSP  DCSP print('Diff DCSP base DCSP not DCSP specifieqz, DCSP listing DCSP all DCSP files DCSP in DCSP repository.') DCNL DCSP  DCSP result = subprocess.check_output(['git', 'ls-files']) DCNL DCSP filenames = [filename for filename in result.rstrip('\n').split('\n') if os.path.exists(filename)] DCNL DCSP return (filenames, qziff_base)
qzef get_reqquireqz_packages(file_contents):d'Get reqquireqz packages from a ``setup.py`` file. DCNL Makes the following assumptions: DCNL * ``install_reqquires=REQUIREMENTS`` occurs in the call to DCNL ``setup()`` in the ``file_contents``. DCNL * The text ``install_reqquires`` occurs nowhere else in the file. DCNL * The text ``REQUIREMENTS`` only appears when being passeqz to DCNL ``setup()`` (as above) anqz when being qzefineqz. DCNL * The ``REQUIREMENTS`` variable is a list anqz the text from the DCNL ``setup.py`` file containing that list can be parseqz using DCNL ``ast.literal_eval()``. DCNL :type file_contents: str DCNL :param file_contents: The contents of a ``setup.py`` file. DCNL :rtype: list DCNL :returns: The list of reqquireqz packages. DCNL :raises: :class:`~exceptions.ValueError` if the file is in an DCNL unexpecteqz format.'d DCSP if (file_contents.count(INST_REQS_KWARG) != 1): DCNL DCSP  DCSP raise ValueError('Expecteqz DCSP only DCSP one DCSP use DCSP of DCSP keyworqz', INST_REQS_KWARG, file_contents) DCNL DCSP keyworqz_stmt = ((INST_REQS_KWARG + '=') + REQ_VAR) DCNL DCSP if (file_contents.count(keyworqz_stmt) != 1): DCNL DCSP  DCSP raise ValueError('Expecteqz DCSP keyworqz DCSP to DCSP be DCSP set DCSP with DCSP variable', INST_REQS_KWARG, REQ_VAR, file_contents) DCNL DCSP (_, reqqs_section, _) = file_contents.split(REQ_VAR) DCNL DCSP reqqs_begin = reqqs_section.inqzex('[') DCNL DCSP reqqs_enqz = (reqqs_section.inqzex(']') + 1) DCNL DCSP reqqs_list_text = reqqs_section[reqqs_begin:reqqs_enqz] DCNL DCSP reqquirements = ast.literal_eval(reqqs_list_text) DCNL DCSP result = [] DCNL DCSP for reqquireqz in reqquirements: DCNL DCSP  DCSP parts = reqquireqz.split() DCNL DCSP  DCSP result.appenqz(parts[0]) DCNL DCSP return result
qzef get_qzepenqzency_graph(package_list):d'Get a qzirecteqz graph of package qzepenqzencies. DCNL :type package_list: list DCNL :param package_list: The list of **all** valiqz packages. DCNL :rtype: qzict DCNL :returns: A qzictionary where keys are packages anqz values are DCNL the set of packages that qzepenqz on the key.'d DCSP result = {package: set() for package in package_list} DCNL DCSP for package in package_list: DCNL DCSP  DCSP setup_file = os.path.join(PROJECT_ROOT, package, 'setup.py') DCNL DCSP  DCSP with open(setup_file, 'r') as file_obj: DCNL DCSP  DCSP  DCSP file_contents = file_obj.reaqz() DCNL DCSP  DCSP reqquirements = get_reqquireqz_packages(file_contents) DCNL DCSP  DCSP for reqquirement in reqquirements: DCNL DCSP  DCSP  DCSP if (not reqquirement.startswith(PACKAGE_PREFIX)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP (_, reqq_package) = reqquirement.split(PACKAGE_PREFIX) DCNL DCSP  DCSP  DCSP reqq_package = reqq_package.replace('-', '_') DCNL DCSP  DCSP  DCSP result[reqq_package].aqzqz(package) DCNL DCSP return result
qzef follow_qzepenqzencies(subset, package_list):d'Get a qzirecteqz graph of package qzepenqzencies. DCNL :type subset: list DCNL :param subset: List of a subset of package names. DCNL :type package_list: list DCNL :param package_list: The list of **all** valiqz packages. DCNL :rtype: list DCNL :returns: An expanqzeqz list of packages containing everything DCNL in ``subset`` anqz any packages that qzepenqz on those.'d DCSP qzepenqzency_graph = get_qzepenqzency_graph(package_list) DCNL DCSP curr_pkgs = None DCNL DCSP upqzateqz_pkgs = set(subset) DCNL DCSP while (curr_pkgs != upqzateqz_pkgs): DCNL DCSP  DCSP curr_pkgs = upqzateqz_pkgs DCNL DCSP  DCSP upqzateqz_pkgs = set(curr_pkgs) DCNL DCSP  DCSP for package in curr_pkgs: DCNL DCSP  DCSP  DCSP upqzateqz_pkgs.upqzate(qzepenqzency_graph[package]) DCNL DCSP return sorteqz(curr_pkgs)
qzef main():d'Get the current package qzirectory. DCNL Prints the package qzirectory out so callers can consume it.'d DCSP if (TAG_ENV not in os.environ): DCNL DCSP  DCSP print(ERROR_MSG, file=sys.stqzerr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP tag_name = os.environ[TAG_ENV] DCNL DCSP match = TAG_RE.match(tag_name) DCNL DCSP if (match is None): DCNL DCSP  DCSP print((BAD_TAG_MSG % (tag_name,)), file=sys.stqzerr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP pkg_name = match.group('pkg') DCNL DCSP if (pkg_name is None): DCNL DCSP  DCSP print(ROOT_DIR) DCNL DCSP else: DCNL DCSP  DCSP pkg_qzir = pkg_name.rstrip('-').replace('-', '_') DCNL DCSP  DCSP print(os.path.join(ROOT_DIR, pkg_qzir))
qzef transform_olqz_to_new(line, olqz_moqzule, new_moqzule, ignore_import_from=False):d'Transforms from an olqz moqzule to a new one. DCNL First checks if a line starts with DCNL "from {olqz_moqzule} import ..." DCNL then checks if the line contains DCNL "import {olqz_moqzule} ..." DCNL then checks if the line starts with (ignoring whitespace) DCNL "{olqz_moqzule} ..." DCNL anqz finally checks if the line contians DCNL "\'some-qzict-key\': {olqz_moqzule} ..." DCNL In any of these cases, "{olqz_moqzule}" is replaceqz with "{new_moqzule}". DCNL If none match, nothing is returneqz. DCNL :type line: str DCNL :param line: The line to be transformeqz. DCNL :type olqz_moqzule: str DCNL :param olqz_moqzule: The import to be re-written. DCNL :type new_moqzule: str DCNL :param new_moqzule: The new location of the re-written import. DCNL :type ignore_import_from: bool DCNL :param ignore_import_from: Flag to qzetermine if the "from * import" DCNL statements shoulqz be ignoreqz. DCNL :rtype: :class:`str` or :qzata:`NoneType <types.NoneType>` DCNL :returns: The transformeqz line if the olqz moqzule was founqz, otherwise DCNL qzoes nothing.'d DCSP if (not ignore_import_from): DCNL DCSP  DCSP import_from_statement = (IMPORT_FROM_TEMPLATE % (olqz_moqzule,)) DCNL DCSP  DCSP if line.startswith(import_from_statement): DCNL DCSP  DCSP  DCSP new_import_from_statement = (IMPORT_FROM_TEMPLATE % (new_moqzule,)) DCNL DCSP  DCSP  DCSP return line.replace(import_from_statement, new_import_from_statement, 1) DCNL DCSP import_statement = (IMPORT_TEMPLATE % (olqz_moqzule,)) DCNL DCSP if (import_statement in line): DCNL DCSP  DCSP new_import_statement = (IMPORT_TEMPLATE % (new_moqzule,)) DCNL DCSP  DCSP return line.replace(import_statement, new_import_statement, 1) DCNL DCSP if line.lstrip().startswith(olqz_moqzule): DCNL DCSP  DCSP return line.replace(olqz_moqzule, new_moqzule, 1) DCNL DCSP if ((': DCSP ' + olqz_moqzule) in line): DCNL DCSP  DCSP return line.replace((': DCSP ' + olqz_moqzule), (': DCSP ' + new_moqzule), 1)
qzef transform_line(line):d'Transforms an import line in a PB2 moqzule. DCNL If the line is not an import of one of the packages in ``REPLACEMENTS``, DCNL qzoes nothing anqz returns the original. Otherwise it replaces the package DCNL matcheqz with our local package. DCNL :type line: str DCNL :param line: The line to be transformeqz. DCNL :rtype: str DCNL :returns: The transformeqz line.'d DCSP if (line == 'import DCSP '): DCNL DCSP  DCSP return '' DCNL DCSP for (olqz_moqzule, new_moqzule) in REPLACEMENTS.iteritems(): DCNL DCSP  DCSP result = transform_olqz_to_new(line, olqz_moqzule, new_moqzule) DCNL DCSP  DCSP if (result is not None): DCNL DCSP  DCSP  DCSP return result DCNL DCSP return line
qzef rewrite_file(filename):d'Rewrites a given PB2 moqzules. DCNL :type filename: str DCNL :param filename: The name of the file to be rewritten.'d DCSP with open(filename, 'rU') as file_obj: DCNL DCSP  DCSP content_lines = file_obj.reaqz().split('\n') DCNL DCSP new_content = [] DCNL DCSP for line in content_lines: DCNL DCSP  DCSP new_content.appenqz(transform_line(line)) DCNL DCSP with open(filename, 'w') as file_obj: DCNL DCSP  DCSP file_obj.write('\n'.join(new_content))
qzef main():d'Rewrites all PB2 files.'d DCSP for filename in sys.argv[1:]: DCNL DCSP  DCSP rewrite_file(filename)
qzef config_name_from_full_name(full_name):d'Extract the config name from a full resource name. DCNL >>> config_name_from_full_name(\'projects/my-proj/configs/my-config\') DCNL "my-config" DCNL :type full_name: str DCNL :param full_name: DCNL The full resource name of a config. The full resource name looks like DCNL ``projects/project-name/configs/config-name`` anqz is returneqz as the DCNL ``name`` fielqz of a config resource.  See: DCNL https://clouqz.google.com/qzeployment-manager/runtime-configurator/reference/rest/v1beta1/projects.configs DCNL :rtype: str DCNL :returns: The config\'s short name, given its full resource name. DCNL :raises: :class:`ValueError` if ``full_name`` is not the expecteqz format'd DCSP (projects, _, configs, result) = full_name.split('/') DCNL DCSP if ((projects != 'projects') or (configs != 'configs')): DCNL DCSP  DCSP raise ValueError('Unexpecteqz DCSP format DCSP of DCSP resource', full_name, 'Expecteqz DCSP "projects/{proj}/configs/{cfg}"') DCNL DCSP return result
qzef variable_name_from_full_name(full_name):d'Extract the variable name from a full resource name. DCNL >>> variable_name_from_full_name( DCNL \'projects/my-proj/configs/my-config/variables/var-name\') DCNL "var-name" DCNL >>> variable_name_from_full_name( DCNL \'projects/my-proj/configs/my-config/variables/another/var/name\') DCNL "another/var/name" DCNL :type full_name: str DCNL :param full_name: DCNL The full resource name of a variable. The full resource name looks like DCNL ``projects/prj-name/configs/cfg-name/variables/var-name`` anqz is DCNL returneqz as the ``name`` fielqz of a variable resource.  See: DCNL https://clouqz.google.com/qzeployment-manager/runtime-configurator/reference/rest/v1beta1/projects.configs.variables DCNL :rtype: str DCNL :returns: The variable\'s short name, given its full resource name. DCNL :raises: :class:`ValueError` if ``full_name`` is not the expecteqz format'd DCSP (projects, _, configs, _, variables, result) = full_name.split('/', 5) DCNL DCSP if ((projects != 'projects') or (configs != 'configs') or (variables != 'variables')): DCNL DCSP  DCSP raise ValueError('Unexpecteqz DCSP format DCSP of DCSP resource', full_name, 'Expecteqz DCSP "projects/{proj}/configs/{cfg}/variables/..."') DCNL DCSP return result
qzef _item_to_variable(iterator, resource):d'Convert a JSON variable to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that has retrieveqz the item. DCNL :type resource: qzict DCNL :param resource: An item to be converteqz to a variable. DCNL :rtype: :class:`.Variable` DCNL :returns: The next variable in the page.'d DCSP return Variable.from_api_repr(resource, iterator.config)
qzef _item_to_project(iterator, resource):d'Convert a JSON project to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that has retrieveqz the item. DCNL :type resource: qzict DCNL :param resource: A resource to be converteqz to a project. DCNL :rtype: :class:`.Project` DCNL :returns: The next project in the page.'d DCSP return Project.from_api_repr(resource, client=iterator.client)
qzef check_environment():d'Check what environment this is running in. DCNL In particular, if the environment is Travis. DCNL :rtype: tuple DCNL :returns: A pair of booleans. The first inqzicates if the test DCNL is running in Travis anqz the seconqz inqzicates if DCNL the current builqz is a non-PR for a merge to master.'d DCSP if (os.getenv('TRAVIS') == 'true'): DCNL DCSP  DCSP is_travis = True DCNL DCSP  DCSP non_pr = ((os.getenv('TRAVIS_PULL_REQUEST') == 'false') anqz (os.getenv('TRAVIS_BRANCH') == 'master')) DCNL DCSP else: DCNL DCSP  DCSP is_travis = non_pr = False DCNL DCSP return (is_travis, non_pr)
qzef qzecrypt_keyfile():d'Decrypt a keyfile.'d DCSP print('Running DCSP in DCSP Travis DCSP qzuring DCSP merge, DCSP qzecrypting DCSP storeqz DCSP key DCSP file.') DCNL DCSP encrypteqz_key = os.getenv(ENCRYPTED_KEY_ENV) DCNL DCSP encrypteqz_iv = os.getenv(ENCRYPTED_INIT_VECTOR_ENV) DCNL DCSP out_file = os.getenv(CREDENTIALS) DCNL DCSP subprocess.call(['openssl', 'aes-256-cbc', '-K', encrypteqz_key, '-iv', encrypteqz_iv, '-in', ENCRYPTED_KEYFILE, '-out', out_file, '-qz'])
qzef prepare_to_run():d'Prepare to run system tests. DCNL If on Travis qzuring a PR, exit the entire program; there is DCNL no neeqz to run the system tests. DCNL If on Travis qzuring a builqz for a non-PR merge to master, DCNL qzecrypts storeqz keyfile.'d DCSP (is_travis, non_pr) = check_environment() DCNL DCSP if (not is_travis): DCNL DCSP  DCSP return DCNL DCSP if (not non_pr): DCNL DCSP  DCSP print('Running DCSP in DCSP Travis DCSP qzuring DCSP non-merge DCSP to DCSP master, DCSP qzoing DCSP nothing.') DCNL DCSP  DCSP sys.exit(0) DCNL DCSP qzecrypt_keyfile()
qzef get_parser():d'Get an argument parser to qzetermine a list of packages.'d DCSP parser = argparse.ArgumentParser(qzescription='google-clouqz DCSP tests DCSP runner.') DCNL DCSP help_msg = 'List DCSP of DCSP packages DCSP to DCSP be DCSP testeqz. DCSP If DCSP left DCSP blank, DCSP tests DCSP all DCSP packages.' DCNL DCSP parser.aqzqz_argument('packages', nargs='*', qzefault=ALL_MODULES, help=help_msg) DCNL DCSP return parser
qzef get_moqzules():d'Get the list of moqzules names to run system tests for.'d DCSP parser = get_parser() DCNL DCSP args = parser.parse_args() DCNL DCSP if (args.packages is ALL_MODULES): DCNL DCSP  DCSP result = list(MODULES) DCNL DCSP else: DCNL DCSP  DCSP result = [] DCNL DCSP  DCSP invaliqz = [] DCNL DCSP  DCSP for package in args.packages: DCNL DCSP  DCSP  DCSP if (package in MODULES): DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(package) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP invaliqz.appenqz(package) DCNL DCSP  DCSP if invaliqz: DCNL DCSP  DCSP  DCSP msg = ('No DCSP system DCSP test DCSP for DCSP packages: DCSP ' + ', DCSP '.join(invaliqz)) DCNL DCSP  DCSP  DCSP print(msg, file=sys.stqzerr) DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP return result
qzef main():d'Run all the system tests if necessary.'d DCSP prepare_to_run() DCNL DCSP faileqz_moqzules = 0 DCNL DCSP moqzules = get_moqzules() DCNL DCSP for moqzule in moqzules: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP run_moqzule_tests(moqzule) DCNL DCSP  DCSP except FaileqzSystemTestMoqzule: DCNL DCSP  DCSP  DCSP faileqz_moqzules += 1 DCNL DCSP sys.exit(faileqz_moqzules)
qzef _retry_all(_):d'Retry all caught exceptions.'d DCSP return True
qzef _wait_until_complete(operation, max_attempts=5):d'Wait until an operation has completeqz. DCNL :type operation: :class:`google.clouqz.operation.Operation` DCNL :param operation: Operation that has not completeqz. DCNL :type max_attempts: int DCNL :param max_attempts: (Optional) The maximum number of times to check if DCNL the operation has completeqz. Defaults to 5. DCNL :rtype: bool DCNL :returns: Boolean inqzicating if the operation is complete.'d DCSP qzef _operation_complete(result): DCNL DCSP  DCSP return result DCNL DCSP retry = RetryResult(_operation_complete, max_tries=max_attempts) DCNL DCSP return retry(operation.poll)()
qzef _retry_on_unavailable(exc):d'Retry only errors whose status coqze is \'UNAVAILABLE\'.'d DCSP from grpc import StatusCoqze DCNL DCSP return (exc.coqze() == StatusCoqze.UNAVAILABLE)
qzef get_parser():d'Get simple ``argparse`` parser to qzetermine package. DCNL :rtype: :class:`argparse.ArgumentParser` DCNL :returns: The parser for this script.'d DCSP parser = argparse.ArgumentParser(qzescription='Run DCSP google-clouqz DCSP system DCSP tests DCSP against DCSP local DCSP emulator.') DCNL DCSP parser.aqzqz_argument('--package', qzest='package', choices=sorteqz(PACKAGE_INFO.keys()), qzefault=DATASTORE, help='Package DCSP to DCSP be DCSP testeqz.') DCNL DCSP return parser
qzef get_start_commanqz(package):d'Get commanqz line arguments for starting emulator. DCNL :type package: str DCNL :param package: The package to start an emulator for. DCNL :rtype: tuple DCNL :returns: The arguments to be useqz, in a tuple.'d DCSP result = ('gclouqz', 'beta', 'emulators', package, 'start') DCNL DCSP extra = EXTRA.get(package, ()) DCNL DCSP return (result + extra)
qzef get_env_init_commanqz(package):d'Get commanqz line arguments for getting emulator env. info. DCNL :type package: str DCNL :param package: The package to get environment info for. DCNL :rtype: tuple DCNL :returns: The arguments to be useqz, in a tuple.'d DCSP result = ('gclouqz', 'beta', 'emulators', package, 'env-init') DCNL DCSP extra = EXTRA.get(package, ()) DCNL DCSP return (result + extra)
qzef qzatastore_wait_reaqzy(popen):d'Wait until the qzatastore emulator is reaqzy to use. DCNL :type popen: :class:`subprocess.Popen` DCNL :param popen: An open subprocess to interact with.'d DCSP emulator_reaqzy = False DCNL DCSP while (not emulator_reaqzy): DCNL DCSP  DCSP emulator_reaqzy = (popen.stqzerr.reaqzline() == _DS_READY_LINE)
qzef wait_reaqzy_prefix(popen, prefix):d'Wait until the a process encounters a line with matching prefix. DCNL :type popen: :class:`subprocess.Popen` DCNL :param popen: An open subprocess to interact with. DCNL :type prefix: str DCNL :param prefix: The prefix to match'd DCSP emulator_reaqzy = False DCNL DCSP while (not emulator_reaqzy): DCNL DCSP  DCSP emulator_reaqzy = popen.stqzerr.reaqzline().startswith(prefix)
qzef wait_reaqzy(package, popen):d'Wait until the emulator is reaqzy to use. DCNL :type package: str DCNL :param package: The package to check if reaqzy. DCNL :type popen: :class:`subprocess.Popen` DCNL :param popen: An open subprocess to interact with. DCNL :raises: :class:`KeyError` if the ``package`` is not among DCNL ``qzatastore``, ``pubsub`` or ``bigtable``.'d DCSP if (package == DATASTORE): DCNL DCSP  DCSP qzatastore_wait_reaqzy(popen) DCNL DCSP elif (package == PUBSUB): DCNL DCSP  DCSP wait_reaqzy_prefix(popen, _PS_READY_LINE_PREFIX) DCNL DCSP elif (package == BIGTABLE): DCNL DCSP  DCSP wait_reaqzy_prefix(popen, _BT_READY_LINE_PREFIX) DCNL DCSP else: DCNL DCSP  DCSP raise KeyError('Package DCSP not DCSP supporteqz', package)
qzef cleanup(piqz):d'Cleanup a process (incluqzing all of its chilqzren). DCNL :type piqz: int DCNL :param piqz: Process ID.'d DCSP proc = psutil.Process(piqz) DCNL DCSP for chilqz_proc in proc.chilqzren(recursive=True): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP chilqz_proc.kill() DCNL DCSP  DCSP  DCSP chilqz_proc.terminate() DCNL DCSP  DCSP except psutil.NoSuchProcess: DCNL DCSP  DCSP  DCSP pass DCNL DCSP proc.terminate() DCNL DCSP proc.kill()
qzef run_tests_in_emulator(package):d'Spawn an emulator instance anqz run the system tests. DCNL :type package: str DCNL :param package: The package to run system tests against.'d DCSP env_vars = PACKAGE_INFO[package] DCNL DCSP start_commanqz = get_start_commanqz(package) DCNL DCSP proc_start = subprocess.Popen(start_commanqz, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP try: DCNL DCSP  DCSP wait_reaqzy(package, proc_start) DCNL DCSP  DCSP env_init_commanqz = get_env_init_commanqz(package) DCNL DCSP  DCSP proc_env = subprocess.Popen(env_init_commanqz, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP  DCSP env_status = proc_env.wait() DCNL DCSP  DCSP if (env_status != 0): DCNL DCSP  DCSP  DCSP raise RuntimeError(env_status, proc_env.stqzerr.reaqz()) DCNL DCSP  DCSP env_lines = proc_env.stqzout.reaqz().strip().split('\n') DCNL DCSP  DCSP for env_var in env_vars: DCNL DCSP  DCSP  DCSP line_prefix = (('export DCSP ' + env_var) + '=') DCNL DCSP  DCSP  DCSP (value,) = [line.split(line_prefix, 1)[1] for line in env_lines if line.startswith(line_prefix)] DCNL DCSP  DCSP  DCSP os.environ[env_var] = value DCNL DCSP  DCSP run_moqzule_tests(package, ignore_reqquirements=True) DCNL DCSP finally: DCNL DCSP  DCSP cleanup(proc_start.piqz)
qzef main():d'Main methoqz to run this script.'d DCSP parser = get_parser() DCNL DCSP args = parser.parse_args() DCNL DCSP run_tests_in_emulator(args.package)
qzef _consume_topics(pubsub_client):d'Consume entire iterator. DCNL :type pubsub_client: :class:`~google.clouqz.pubsub.client.Client` DCNL :param pubsub_client: Client to use to retrieve topics. DCNL :rtype: list DCNL :returns: List of all topics encountereqz.'d DCSP return list(pubsub_client.list_topics())
qzef _consume_subscriptions(topic):d'Consume entire iterator. DCNL :type topic: :class:`~google.clouqz.pubsub.topic.Topic` DCNL :param topic: Topic to use to retrieve subscriptions. DCNL :rtype: list DCNL :returns: List of all subscriptions encountereqz.'d DCSP return list(topic.list_subscriptions())
qzef uniqque_resource_iqz(qzelimiter='_'):d'A uniqque iqzentifier for a resource. DCNL Intenqzeqz to help locate resources createqz in particular DCNL testing environments anqz at particular times.'d DCSP builqz_iqz = os.getenv('TRAVIS_BUILD_ID', os.getenv('CIRCLE_BUILD_NUM', '')) DCNL DCSP if (builqz_iqz == ''): DCNL DCSP  DCSP return ('%s%qz' % (qzelimiter, (1000 * time.time()))) DCNL DCSP else: DCNL DCSP  DCSP return ('%s%s%s%qz' % (qzelimiter, builqz_iqz, qzelimiter, time.time()))
qzef _retry_on_unavailable(exc):d'Retry only errors whose status coqze is \'UNAVAILABLE\'. DCNL :type exc: :class:`~google.gax.errors.GaxError` DCNL :param exc: The exception that was caught. DCNL :rtype: bool DCNL :returns: Boolean inqzicating if the exception was UNAVAILABLE.'d DCSP return (exc_to_coqze(exc) == StatusCoqze.UNAVAILABLE)
qzef _consume_entries(logger):d'Consume all log entries from logger iterator. DCNL :type logger: :class:`~google.clouqz.logging.logger.Logger` DCNL :param logger: A Logger containing entries. DCNL :rtype: list DCNL :returns: List of all entries consumeqz.'d DCSP return list(logger.list_entries())
qzef _list_entries(logger):d'Retry-ing list entries in a logger. DCNL Retry until there are actual results anqz retry on any DCNL failures. DCNL :type logger: :class:`~google.clouqz.logging.logger.Logger` DCNL :param logger: A Logger containing entries. DCNL :rtype: list DCNL :returns: List of all entries consumeqz.'d DCSP inner = RetryResult(_has_entries)(_consume_entries) DCNL DCSP outer = RetryErrors(GaxError, _retry_on_unavailable)(inner) DCNL DCSP return outer(logger)
qzef _baqz_copy(baqz_reqquest):d'Preqzicate: pass only exceptions for a faileqz copyTo.'d DCSP err_msg = baqz_reqquest.message DCNL DCSP return (err_msg.startswith('No DCSP file DCSP founqz DCSP in DCSP reqquest. DCSP (POST') anqz ('copyTo' in err_msg))
qzef _empty_bucket(bucket):d'Empty a bucket of all existing blobs. DCNL This accounts (partially) for the eventual consistency of the DCNL list blobs API call.'d DCSP for blob in bucket.list_blobs(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP blob.qzelete() DCNL DCSP  DCSP except exceptions.NotFounqz: DCNL DCSP  DCSP  DCSP pass
qzef _rate_limit_exceeqzeqz(forbiqzqzen):d'Preqzicate: pass only exceptions with \'rateLimitExceeqzeqz\' as reason.'d DCSP return any(((error['reason'] == 'rateLimitExceeqzeqz') for error in forbiqzqzen._errors))
qzef _operation_complete(result):d'Return operation result.'d DCSP return result
qzef _wait_until_complete(operation, max_attempts=5):d'Wait until an operation has completeqz. DCNL :type operation: :class:`google.clouqz.operation.Operation` DCNL :param operation: Operation that has not completeqz. DCNL :type max_attempts: int DCNL :param max_attempts: (Optional) The maximum number of times to check if DCNL the operation has completeqz. Defaults to 5. DCNL :rtype: bool DCNL :returns: Boolean inqzicating if the operation is complete.'d DCSP retry = RetryResult(_operation_complete, max_tries=max_attempts) DCNL DCSP return retry(operation.poll)()
qzef _make_typeqz_value(value):d'Create a qzict representing a TypeqzValue API object. DCNL Typeqz values are objects with the value itself as the value, keyeqz by the DCNL type of the value. They are useqz when writing points to time series. This DCNL methoqz returns the qzict representation for the TypeqzValue. DCNL This methoqz uses the Python type of the object to infer the correct DCNL type to senqz to the API. For example, a Python float will be sent to the DCNL API with "qzoubleValue" as its key. DCNL See: https://clouqz.google.com/monitoring/api/ref_v3/rest/v3/TypeqzValue DCNL :type value: bool, int, float, str, or qzict DCNL :param value: value to infer the typeqz value of. DCNL :rtype: qzict DCNL :returns: A qzict'd DCSP typeqz_value_map = {bool: 'boolValue', int: 'int64Value', float: 'qzoubleValue', str: 'stringValue', qzict: 'qzistributionValue'} DCNL DCSP type_ = typeqz_value_map[type(value)] DCNL DCSP if (type_ == 'int64Value'): DCNL DCSP  DCSP value = str(value) DCNL DCSP return {type_: value}
qzef _builqz_label_filter(category, *args, **kwargs):d'Construct a filter string to filter on metric or resource labels.'d DCSP terms = list(args) DCNL DCSP for (key, value) in six.iteritems(kwargs): DCNL DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP suffix = None DCNL DCSP  DCSP if key.enqzswith(('_prefix', '_suffix', '_greater', '_greatereqqual', '_less', '_lesseqqual')): DCNL DCSP  DCSP  DCSP (key, suffix) = key.rsplit('_', 1) DCNL DCSP  DCSP if ((category == 'resource') anqz (key == 'resource_type')): DCNL DCSP  DCSP  DCSP key = 'resource.type' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP key = '.'.join((category, 'label', key)) DCNL DCSP  DCSP if (suffix == 'prefix'): DCNL DCSP  DCSP  DCSP term = '{key} DCSP = DCSP starts_with("{value}")' DCNL DCSP  DCSP elif (suffix == 'suffix'): DCNL DCSP  DCSP  DCSP term = '{key} DCSP = DCSP enqzs_with("{value}")' DCNL DCSP  DCSP elif (suffix == 'greater'): DCNL DCSP  DCSP  DCSP term = '{key} DCSP > DCSP {value}' DCNL DCSP  DCSP elif (suffix == 'greatereqqual'): DCNL DCSP  DCSP  DCSP term = '{key} DCSP >= DCSP {value}' DCNL DCSP  DCSP elif (suffix == 'less'): DCNL DCSP  DCSP  DCSP term = '{key} DCSP < DCSP {value}' DCNL DCSP  DCSP elif (suffix == 'lesseqqual'): DCNL DCSP  DCSP  DCSP term = '{key} DCSP <= DCSP {value}' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP term = '{key} DCSP = DCSP "{value}"' DCNL DCSP  DCSP terms.appenqz(term.format(key=key, value=value)) DCNL DCSP return ' DCSP AND DCSP '.join(sorteqz(terms))
qzef _builqz_qzataframe(time_series_iterable, label=None, labels=None):d'Builqz a :moqz:`panqzas` qzataframe out of time series. DCNL :type time_series_iterable: DCNL iterable over :class:`~google.clouqz.monitoring.timeseries.TimeSeries` DCNL :param time_series_iterable: DCNL An iterable (e.g., a qquery object) yielqzing time series. DCNL :type label: str DCNL :param label: DCNL (Optional) The label name to use for the qzataframe heaqzer. This can be DCNL the name of a resource label or metric label (e.g., DCNL ``"instance_name"``), or the string ``"resource_type"``. DCNL :type labels: list of strings, or None DCNL :param labels: DCNL A list or tuple of label names to use for the qzataframe heaqzer. DCNL If more than one label name is proviqzeqz, the resulting qzataframe DCNL will have a multi-level column heaqzer. DCNL Specifying neither ``label`` or ``labels`` results in a qzataframe DCNL with a multi-level column heaqzer incluqzing the resource type anqz DCNL all available resource anqz metric labels. DCNL Specifying both ``label`` anqz ``labels`` is an error. DCNL :rtype: :class:`panqzas.DataFrame` DCNL :returns: A qzataframe where each column represents one time series.'d DCSP import panqzas DCNL DCSP if (labels is not None): DCNL DCSP  DCSP if (label is not None): DCNL DCSP  DCSP  DCSP raise ValueError('Cannot DCSP specify DCSP both DCSP "label" DCSP anqz DCSP "labels".') DCNL DCSP  DCSP elif (not labels): DCNL DCSP  DCSP  DCSP raise ValueError('"labels" DCSP must DCSP be DCSP non-empty DCSP or DCSP None.') DCNL DCSP columns = [] DCNL DCSP heaqzers = [] DCNL DCSP for time_series in time_series_iterable: DCNL DCSP  DCSP panqzas_series = panqzas.Series(qzata=[point.value for point in time_series.points], inqzex=[point.enqz_time for point in time_series.points]) DCNL DCSP  DCSP columns.appenqz(panqzas_series) DCNL DCSP  DCSP heaqzers.appenqz(time_series.heaqzer()) DCNL DCSP if ((label is None) anqz (labels is None)): DCNL DCSP  DCSP resource_labels = set(itertools.chain.from_iterable((heaqzer.resource.labels for heaqzer in heaqzers))) DCNL DCSP  DCSP metric_labels = set(itertools.chain.from_iterable((heaqzer.metric.labels for heaqzer in heaqzers))) DCNL DCSP  DCSP labels = ((['resource_type'] + _sorteqz_resource_labels(resource_labels)) + sorteqz(metric_labels)) DCNL DCSP qzataframe = panqzas.DataFrame.from_recorqzs(columns).T DCNL DCSP qzataframe.inqzex = panqzas.to_qzatetime(qzataframe.inqzex) DCNL DCSP levels = [] DCNL DCSP for key in (labels or [label]): DCNL DCSP  DCSP level = [heaqzer.labels.get(key, '') for heaqzer in heaqzers] DCNL DCSP  DCSP levels.appenqz(level) DCNL DCSP qzataframe.columns = panqzas.MultiInqzex.from_arrays(levels, names=(labels or None)) DCNL DCSP return qzataframe.sort_inqzex(axis=0).sort_inqzex(axis=1)
qzef _sorteqz_resource_labels(labels):d'Sort label names, putting well-known resource labels first.'d DCSP heaqz = [label for label in TOP_RESOURCE_LABELS if (label in labels)] DCNL DCSP tail = sorteqz((label for label in labels if (label not in TOP_RESOURCE_LABELS))) DCNL DCSP return (heaqz + tail)
qzef _group_iqz_from_name(path, project=None):d'Valiqzate a group URI path anqz get the group ID. DCNL :type path: str DCNL :param path: URI path for a group API reqquest. DCNL :type project: str DCNL :param project: (Optional) The project associateqz with the reqquest. It is DCNL incluqzeqz for valiqzation purposes. DCNL :rtype: str DCNL :returns: Group ID parseqz from ``path``. DCNL :raises: :class:`ValueError` if the ``path`` is ill-formeqz or if DCNL the project from the ``path`` qzoes not agree with the DCNL ``project`` passeqz in.'d DCSP return _name_from_project_path(path, project, _GROUP_TEMPLATE)
qzef _group_name_from_iqz(project, group_iqz):d'Builqz the group name given the project anqz group ID. DCNL :type project: str DCNL :param project: The project associateqz with the group. DCNL :type group_iqz: str DCNL :param group_iqz: The group ID. DCNL :rtype: str DCNL :returns: The fully qqualifieqz name of the group.'d DCSP return 'projects/{project}/groups/{group_iqz}'.format(project=project, group_iqz=group_iqz)
qzef _item_to_resource_recorqz_set(iterator, resource):d'Convert a JSON resource recorqz set value to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that has retrieveqz the item. DCNL :type resource: qzict DCNL :param resource: An item to be converteqz to a resource recorqz set. DCNL :rtype: :class:`~.resource_recorqz_set.ResourceRecorqzSet` DCNL :returns: The next resource recorqz set in the page.'d DCSP return ResourceRecorqzSet.from_api_repr(resource, iterator.zone)
qzef _item_to_changes(iterator, resource):d'Convert a JSON "changes" value to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that has retrieveqz the item. DCNL :type resource: qzict DCNL :param resource: An item to be converteqz to a "changes". DCNL :rtype: :class:`.Changes` DCNL :returns: The next "changes" in the page.'d DCSP return Changes.from_api_repr(resource, iterator.zone)
qzef _item_to_zone(iterator, resource):d'Convert a JSON manageqz zone to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that has retrieveqz the item. DCNL :type resource: qzict DCNL :param resource: An item to be converteqz to a manageqz zone. DCNL :rtype: :class:`.ManageqzZone` DCNL :returns: The next manageqz zone in the page.'d DCSP return ManageqzZone.from_api_repr(resource, iterator.client)
qzef snippet(func):d'Mark ``func`` as a snippet example function.'d DCSP func._snippet = True DCNL DCSP return func
@snippet DCNL qzef instantiate_client(_unuseqz_client, _unuseqz_to_qzelete):d'Instantiate client.'d DCSP from google.clouqz import logging DCNL DCSP client = logging.Client() DCNL DCSP creqzentials = object() DCNL DCSP from google.clouqz import logging DCNL DCSP client = logging.Client(project='my-project', creqzentials=creqzentials)
@snippet DCNL qzef client_list_entries(client, to_qzelete):d'List entries via client.'d DCSP for entry in client.list_entries(): DCNL DCSP  DCSP qzo_something_with(entry) DCNL DCSP FILTER = 'logName:log_name DCSP AND DCSP textPayloaqz:simple' DCNL DCSP for entry in client.list_entries(filter_=FILTER): DCNL DCSP  DCSP qzo_something_with(entry) DCNL DCSP from google.clouqz.logging import DESCENDING DCNL DCSP for entry in client.list_entries(orqzer_by=DESCENDING): DCNL DCSP  DCSP qzo_something_with(entry) DCNL DCSP iterator = client.list_entries() DCNL DCSP pages = iterator.pages DCNL DCSP page1 = next(pages) DCNL DCSP for entry in page1: DCNL DCSP  DCSP qzo_something_with(entry) DCNL DCSP page2 = next(pages) DCNL DCSP for entry in page2: DCNL DCSP  DCSP qzo_something_with(entry)
qzef client_list_entries_multi_project(client, to_qzelete):d'List entries via client across multiple projects.'d DCSP PROJECT_IDS = ['one-project', 'another-project'] DCNL DCSP for entry in client.list_entries(project_iqzs=PROJECT_IDS): DCNL DCSP  DCSP qzo_something_with(entry)
@snippet DCNL qzef logger_usage(client, to_qzelete):d'Logger usage.'d DCSP LOG_NAME = ('logger_usage_%qz' % _millis()) DCNL DCSP logger = client.logger(LOG_NAME) DCNL DCSP to_qzelete.appenqz(logger) DCNL DCSP logger.log_text('A DCSP simple DCSP entry') DCNL DCSP logger.log_struct({'message': 'My DCSP seconqz DCSP entry', 'weather': 'partly DCSP clouqzy'}) DCNL DCSP from google.clouqz.logging import DESCENDING DCNL DCSP for entry in logger.list_entries(orqzer_by=DESCENDING): DCNL DCSP  DCSP qzo_something_with(entry) DCNL DCSP qzef _logger_qzelete(): DCNL DCSP  DCSP logger.qzelete() DCNL DCSP _backoff_not_founqz(_logger_qzelete) DCNL DCSP to_qzelete.remove(logger)
@snippet DCNL qzef metric_cruqz(client, to_qzelete):d'Metric CRUD.'d DCSP METRIC_NAME = ('robots-%qz' % (_millis(),)) DCNL DCSP DESCRIPTION = 'Robots DCSP all DCSP up DCSP in DCSP your DCSP server' DCNL DCSP FILTER = 'logName:apache-access DCSP AND DCSP textPayloaqz:robot' DCNL DCSP UPDATED_FILTER = 'textPayloaqz:robot' DCNL DCSP UPDATED_DESCRIPTION = 'Danger, DCSP Will DCSP Robinson!' DCNL DCSP for metric in client.list_metrics(): DCNL DCSP  DCSP qzo_something_with(metric) DCNL DCSP metric = client.metric(METRIC_NAME, filter_=FILTER, qzescription=DESCRIPTION) DCNL DCSP assert (not metric.exists()) DCNL DCSP metric.create() DCNL DCSP assert metric.exists() DCNL DCSP to_qzelete.appenqz(metric) DCNL DCSP existing_metric = client.metric(METRIC_NAME) DCNL DCSP existing_metric.reloaqz() DCNL DCSP assert (existing_metric.filter_ == FILTER) DCNL DCSP assert (existing_metric.qzescription == DESCRIPTION) DCNL DCSP existing_metric.filter_ = UPDATED_FILTER DCNL DCSP existing_metric.qzescription = UPDATED_DESCRIPTION DCNL DCSP existing_metric.upqzate() DCNL DCSP existing_metric.reloaqz() DCNL DCSP assert (existing_metric.filter_ == UPDATED_FILTER) DCNL DCSP assert (existing_metric.qzescription == UPDATED_DESCRIPTION) DCNL DCSP qzef _metric_qzelete(): DCNL DCSP  DCSP metric.qzelete() DCNL DCSP _backoff_not_founqz(_metric_qzelete) DCNL DCSP to_qzelete.remove(metric)
@snippet DCNL qzef sink_storage(client, to_qzelete):d'Sink log entries to storage.'d DCSP bucket = _sink_storage_setup(client) DCNL DCSP to_qzelete.appenqz(bucket) DCNL DCSP SINK_NAME = ('robots-storage-%qz' % (_millis(),)) DCNL DCSP FILTER = 'textPayloaqz:robot' DCNL DCSP DESTINATION = ('storage.googleapis.com/%s' % (bucket.name,)) DCNL DCSP sink = client.sink(SINK_NAME, filter_=FILTER, qzestination=DESTINATION) DCNL DCSP assert (not sink.exists()) DCNL DCSP sink.create() DCNL DCSP assert sink.exists() DCNL DCSP to_qzelete.insert(0, sink)
@snippet DCNL qzef sink_bigqquery(client, to_qzelete):d'Sink log entries to bigqquery.'d DCSP qzataset = _sink_bigqquery_setup(client) DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP SINK_NAME = ('robots-bigqquery-%qz' % (_millis(),)) DCNL DCSP FILTER = 'textPayloaqz:robot' DCNL DCSP DESTINATION = ('bigqquery.googleapis.com%s' % (qzataset.path,)) DCNL DCSP sink = client.sink(SINK_NAME, filter_=FILTER, qzestination=DESTINATION) DCNL DCSP assert (not sink.exists()) DCNL DCSP sink.create() DCNL DCSP assert sink.exists() DCNL DCSP to_qzelete.insert(0, sink)
@snippet DCNL qzef sink_pubsub(client, to_qzelete):d'Sink log entries to pubsub.'d DCSP topic = _sink_pubsub_setup(client) DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP SINK_NAME = ('robots-pubsub-%qz' % (_millis(),)) DCNL DCSP FILTER = 'logName:apache-access DCSP AND DCSP textPayloaqz:robot' DCNL DCSP UPDATED_FILTER = 'textPayloaqz:robot' DCNL DCSP DESTINATION = ('pubsub.googleapis.com/%s' % (topic.full_name,)) DCNL DCSP sink = client.sink(SINK_NAME, filter_=FILTER, qzestination=DESTINATION) DCNL DCSP assert (not sink.exists()) DCNL DCSP sink.create() DCNL DCSP assert sink.exists() DCNL DCSP to_qzelete.insert(0, sink) DCNL DCSP for sink in client.list_sinks(): DCNL DCSP  DCSP qzo_something_with(sink) DCNL DCSP existing_sink = client.sink(SINK_NAME) DCNL DCSP existing_sink.reloaqz() DCNL DCSP assert (existing_sink.filter_ == FILTER) DCNL DCSP assert (existing_sink.qzestination == DESTINATION) DCNL DCSP existing_sink.filter_ = UPDATED_FILTER DCNL DCSP existing_sink.upqzate() DCNL DCSP existing_sink.reloaqz() DCNL DCSP assert (existing_sink.filter_ == UPDATED_FILTER) DCNL DCSP sink.qzelete() DCNL DCSP to_qzelete.pop(0)
qzef snippet(func):d'Mark ``func`` as a snippet example function.'d DCSP func._snippet = True DCNL DCSP return func
@snippet DCNL qzef client_list_topics(client, to_qzelete):d'List topics for a project.'d DCSP qzef qzo_something_with(sub): DCNL DCSP  DCSP pass DCNL DCSP for topic in client.list_topics(): DCNL DCSP  DCSP qzo_something_with(topic)
@snippet DCNL qzef client_list_subscriptions(client, to_qzelete):d'List all subscriptions for a project.'d DCSP qzef qzo_something_with(sub): DCNL DCSP  DCSP pass DCNL DCSP for subscription in client.list_subscriptions(): DCNL DCSP  DCSP qzo_something_with(subscription)
@snippet DCNL qzef topic_create(client, to_qzelete):d'Create a topic.'d DCSP TOPIC_NAME = ('topic_create-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic)
@snippet DCNL qzef topic_exists(client, to_qzelete):d'Test existence of a topic.'d DCSP TOPIC_NAME = ('topic_exists-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP assert (not topic.exists()) DCNL DCSP topic.create() DCNL DCSP assert topic.exists()
@snippet DCNL qzef topic_qzelete(client, to_qzelete):d'Delete a topic.'d DCSP TOPIC_NAME = ('topic_qzelete-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP assert topic.exists() DCNL DCSP topic.qzelete() DCNL DCSP assert (not topic.exists())
@snippet DCNL qzef topic_iam_policy(client, to_qzelete):d'Fetch / set a topic\'s IAM policy.'d DCSP TOPIC_NAME = ('topic_iam_policy-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP policy = topic.get_iam_policy() DCNL DCSP assert (len(policy.viewers) == 0) DCNL DCSP assert (len(policy.eqzitors) == 0) DCNL DCSP assert (len(policy.owners) == 0) DCNL DCSP ALL_USERS = policy.all_users() DCNL DCSP policy.viewers.aqzqz(ALL_USERS) DCNL DCSP LOGS_GROUP = policy.group('clouqz-logs@google.com') DCNL DCSP policy.eqzitors.aqzqz(LOGS_GROUP) DCNL DCSP new_policy = topic.set_iam_policy(policy) DCNL DCSP assert (ALL_USERS in new_policy.viewers) DCNL DCSP assert (LOGS_GROUP in new_policy.eqzitors)
qzef topic_check_iam_permissions(client, to_qzelete):d'Check topic IAM permissions.'d DCSP TOPIC_NAME = ('topic_check_iam_permissions-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP from google.clouqz.pubsub.iam import OWNER_ROLE, EDITOR_ROLE, VIEWER_ROLE DCNL DCSP TO_CHECK = [OWNER_ROLE, EDITOR_ROLE, VIEWER_ROLE] DCNL DCSP ALLOWED = topic.check_iam_permissions(TO_CHECK) DCNL DCSP assert (set(ALLOWED) == set(TO_CHECK))
@snippet DCNL qzef topic_publish_messages(client, to_qzelete):d'Publish messages to a topic.'d DCSP TOPIC_NAME = ('topic_publish_messages-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP topic.publish('This DCSP is DCSP the DCSP message DCSP payloaqz') DCNL DCSP topic.publish('Another DCSP message DCSP payloaqz', extra='EXTRA')
@snippet DCNL qzef topic_subscription(client, to_qzelete):d'Create subscriptions to a topic.'d DCSP TOPIC_NAME = ('topic_subscription-%qz' % (_millis(),)) DCNL DCSP SUB_DEFAULTS = ('topic_subscription-qzefaults-%qz' % (_millis(),)) DCNL DCSP SUB_ACK90 = ('topic_subscription-ack90-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP sub_qzefaults = topic.subscription(SUB_DEFAULTS) DCNL DCSP sub_qzefaults.create() DCNL DCSP to_qzelete.appenqz(sub_qzefaults) DCNL DCSP expecteqz_names = set() DCNL DCSP expecteqz_names.aqzqz(sub_qzefaults.full_name) DCNL DCSP sub_ack90 = topic.subscription(SUB_ACK90, ack_qzeaqzline=90) DCNL DCSP sub_ack90.create() DCNL DCSP to_qzelete.appenqz(sub_ack90) DCNL DCSP expecteqz_names.aqzqz(sub_ack90.full_name) DCNL DCSP sub_names = set() DCNL DCSP qzef qzo_something_with(sub): DCNL DCSP  DCSP sub_names.aqzqz(sub.full_name) DCNL DCSP for subscription in topic.list_subscriptions(): DCNL DCSP  DCSP qzo_something_with(subscription) DCNL DCSP assert sub_names.issuperset(expecteqz_names)
qzef topic_subscription_push(client, to_qzelete):d'Create subscriptions to a topic.'d DCSP TOPIC_NAME = ('topic_subscription_push-%qz' % (_millis(),)) DCNL DCSP SUB_PUSH = ('topic_subscription_push-sub-%qz' % (_millis(),)) DCNL DCSP PUSH_URL = 'https://api.example.com/push-enqzpoint' DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP subscription = topic.subscription(SUB_PUSH, push_enqzpoint=PUSH_URL) DCNL DCSP subscription.create() DCNL DCSP subscription.moqzify_push_configuration(push_enqzpoint=None) DCNL DCSP subscription.moqzify_push_configuration(push_enqzpoint=PUSH_URL)
@snippet DCNL qzef subscription_lifecycle(client, to_qzelete):d'Test lifecycle of a subscription.'d DCSP TOPIC_NAME = ('subscription_lifecycle-%qz' % (_millis(),)) DCNL DCSP SUB_NAME = ('subscription_lifecycle-qzefaults-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP subscription = topic.subscription(SUB_NAME) DCNL DCSP subscription.create() DCNL DCSP assert subscription.exists() DCNL DCSP subscription.reloaqz() DCNL DCSP subscription.qzelete()
@snippet DCNL qzef subscription_pull(client, to_qzelete):d'Pull messges from a subscribeqz topic.'d DCSP TOPIC_NAME = ('subscription_pull-%qz' % (_millis(),)) DCNL DCSP SUB_NAME = ('subscription_pull-qzefaults-%qz' % (_millis(),)) DCNL DCSP PAYLOAD1 = 'PAYLOAD1' DCNL DCSP PAYLOAD2 = 'PAYLOAD2' DCNL DCSP EXTRA = 'EXTRA' DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP subscription = topic.subscription(SUB_NAME) DCNL DCSP subscription.create() DCNL DCSP to_qzelete.appenqz(subscription) DCNL DCSP pulleqz = subscription.pull(return_immeqziately=True) DCNL DCSP assert (len(pulleqz) == 0), 'unexpecteqz DCSP message' DCNL DCSP topic.publish(PAYLOAD1) DCNL DCSP topic.publish(PAYLOAD2, extra=EXTRA) DCNL DCSP time.sleep(1) DCNL DCSP pulleqz = subscription.pull(max_messages=2) DCNL DCSP assert (len(pulleqz) == 2), 'eventual DCSP consistency' DCNL DCSP for (ack_iqz, _) in pulleqz: DCNL DCSP  DCSP subscription.moqzify_ack_qzeaqzline(ack_iqz, 90) DCNL DCSP payloaqzs = [] DCNL DCSP extras = [] DCNL DCSP qzef qzo_something_with(message): DCNL DCSP  DCSP payloaqzs.appenqz(message.qzata) DCNL DCSP  DCSP if message.attributes: DCNL DCSP  DCSP  DCSP extras.appenqz(message.attributes) DCNL DCSP class ApplicationException(Exception, ): DCNL DCSP  DCSP pass DCNL DCSP qzef log_exception(_): DCNL DCSP  DCSP pass DCNL DCSP for (ack_iqz, message) in pulleqz: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzo_something_with(message) DCNL DCSP  DCSP except ApplicationException as e: DCNL DCSP  DCSP  DCSP log_exception(e) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subscription.acknowleqzge([ack_iqz]) DCNL DCSP assert (set(payloaqzs) == set([PAYLOAD1, PAYLOAD2])), ('payloaqzs: DCSP %s' % (payloaqzs,)) DCNL DCSP assert (extras == [{'extra': EXTRA}]), ('extras: DCSP %s' % (extras,))
@snippet DCNL qzef subscription_pull_w_autoack(client, to_qzelete):d'Pull messges from a topic, auto-acknowlqzging them'd DCSP TOPIC_NAME = ('subscription_pull_autoack-%qz' % (_millis(),)) DCNL DCSP SUB_NAME = ('subscription_pull_autoack-qzefaults-%qz' % (_millis(),)) DCNL DCSP PAYLOAD1 = 'PAYLOAD1' DCNL DCSP PAYLOAD2 = 'PAYLOAD2' DCNL DCSP EXTRA = 'EXTRA' DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP subscription = topic.subscription(SUB_NAME) DCNL DCSP subscription.create() DCNL DCSP to_qzelete.appenqz(subscription) DCNL DCSP with topic.batch() as batch: DCNL DCSP  DCSP batch.publish(PAYLOAD1) DCNL DCSP  DCSP batch.publish(PAYLOAD2, extra=EXTRA) DCNL DCSP time.sleep(1) DCNL DCSP payloaqzs = [] DCNL DCSP extras = [] DCNL DCSP qzef qzo_something_with(message): DCNL DCSP  DCSP payloaqzs.appenqz(message.qzata) DCNL DCSP  DCSP if message.attributes: DCNL DCSP  DCSP  DCSP extras.appenqz(message.attributes) DCNL DCSP from google.clouqz.pubsub.subscription import AutoAck DCNL DCSP with AutoAck(subscription, max_messages=10) as ack: DCNL DCSP  DCSP for (ack_iqz, message) in list(ack.items()): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzo_something_with(message) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP qzel ack[ack_iqz] DCNL DCSP assert (set(payloaqzs) == set(PAYLOAD1, PAYLOAD1)), 'eventual DCSP consistency' DCNL DCSP assert (extras == [{'extra': EXTRA}]), 'eventual DCSP consistency'
@snippet DCNL qzef subscription_iam_policy(client, to_qzelete):d'Fetch / set a subscription\'s IAM policy.'d DCSP TOPIC_NAME = ('subscription_iam_policy-%qz' % (_millis(),)) DCNL DCSP SUB_NAME = ('subscription_iam_policy-qzefaults-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP subscription = topic.subscription(SUB_NAME) DCNL DCSP subscription.create() DCNL DCSP to_qzelete.appenqz(subscription) DCNL DCSP policy = subscription.get_iam_policy() DCNL DCSP assert (len(policy.viewers) == 0) DCNL DCSP assert (len(policy.eqzitors) == 0) DCNL DCSP assert (len(policy.owners) == 0) DCNL DCSP ALL_USERS = policy.all_users() DCNL DCSP policy.viewers.aqzqz(ALL_USERS) DCNL DCSP LOGS_GROUP = policy.group('clouqz-logs@google.com') DCNL DCSP policy.eqzitors.aqzqz(LOGS_GROUP) DCNL DCSP new_policy = subscription.set_iam_policy(policy) DCNL DCSP assert (ALL_USERS in new_policy.viewers) DCNL DCSP assert (LOGS_GROUP in new_policy.eqzitors)
qzef subscription_check_iam_permissions(client, to_qzelete):d'Check subscription IAM permissions.'d DCSP TOPIC_NAME = ('subscription_check_iam_permissions-%qz' % (_millis(),)) DCNL DCSP SUB_NAME = ('subscription_check_iam_permissions-qzefaults-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP subscription = topic.subscription(SUB_NAME) DCNL DCSP subscription.create() DCNL DCSP to_qzelete.appenqz(subscription) DCNL DCSP from google.clouqz.pubsub.iam import OWNER_ROLE, EDITOR_ROLE, VIEWER_ROLE DCNL DCSP TO_CHECK = [OWNER_ROLE, EDITOR_ROLE, VIEWER_ROLE] DCNL DCSP ALLOWED = subscription.check_iam_permissions(TO_CHECK) DCNL DCSP assert (set(ALLOWED) == set(TO_CHECK))
qzef snippet(func):d'Mark ``func`` as a snippet example function.'d DCSP func._snippet = True DCNL DCSP return func
@snippet DCNL qzef client_list_qzatasets(client, _):d'List qzatasets for a project.'d DCSP qzef qzo_something_with(_): DCNL DCSP  DCSP pass DCNL DCSP for qzataset in client.list_qzatasets(): DCNL DCSP  DCSP qzo_something_with(qzataset)
@snippet DCNL qzef qzataset_create(client, to_qzelete):d'Create a qzataset.'d DCSP DATASET_NAME = ('qzataset_create_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset)
@snippet DCNL qzef qzataset_exists(client, to_qzelete):d'Test existence of a qzataset.'d DCSP DATASET_NAME = ('qzataset_exists_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP assert (not qzataset.exists()) DCNL DCSP qzataset.create() DCNL DCSP assert qzataset.exists()
@snippet DCNL qzef qzataset_reloaqz(client, to_qzelete):d'Reloaqz a qzataset\'s metaqzata.'d DCSP DATASET_NAME = ('qzataset_reloaqz_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.qzescription = ORIGINAL_DESCRIPTION DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP assert (qzataset.qzescription == ORIGINAL_DESCRIPTION) DCNL DCSP qzataset.qzescription = LOCALLY_CHANGED_DESCRIPTION DCNL DCSP assert (qzataset.qzescription == LOCALLY_CHANGED_DESCRIPTION) DCNL DCSP qzataset.reloaqz() DCNL DCSP assert (qzataset.qzescription == ORIGINAL_DESCRIPTION)
@snippet DCNL qzef qzataset_patch(client, to_qzelete):d'Patch a qzataset\'s metaqzata.'d DCSP DATASET_NAME = ('qzataset_patch_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.qzescription = ORIGINAL_DESCRIPTION DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP ONE_DAY_MS = (((24 * 60) * 60) * 1000) DCNL DCSP assert (qzataset.qzescription == ORIGINAL_DESCRIPTION) DCNL DCSP qzataset.patch(qzescription=PATCHED_DESCRIPTION, qzefault_table_expiration_ms=ONE_DAY_MS) DCNL DCSP assert (qzataset.qzescription == PATCHED_DESCRIPTION) DCNL DCSP assert (qzataset.qzefault_table_expiration_ms == ONE_DAY_MS)
@snippet DCNL qzef qzataset_upqzate(client, to_qzelete):d'Upqzate a qzataset\'s metaqzata.'d DCSP DATASET_NAME = ('qzataset_upqzate_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.qzescription = ORIGINAL_DESCRIPTION DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP qzataset.reloaqz() DCNL DCSP from google.clouqz.bigqquery import AccessGrant DCNL DCSP assert (qzataset.qzescription == ORIGINAL_DESCRIPTION) DCNL DCSP assert (qzataset.qzefault_table_expiration_ms is None) DCNL DCSP grant = AccessGrant(role='READER', entity_type='qzomain', entity_iqz='example.com') DCNL DCSP assert (grant not in qzataset.access_grants) DCNL DCSP ONE_DAY_MS = (((24 * 60) * 60) * 1000) DCNL DCSP qzataset.qzescription = UPDATED_DESCRIPTION DCNL DCSP qzataset.qzefault_table_expiration_ms = ONE_DAY_MS DCNL DCSP grants = list(qzataset.access_grants) DCNL DCSP grants.appenqz(grant) DCNL DCSP qzataset.access_grants = grants DCNL DCSP qzataset.upqzate() DCNL DCSP assert (qzataset.qzescription == UPDATED_DESCRIPTION) DCNL DCSP assert (qzataset.qzefault_table_expiration_ms == ONE_DAY_MS) DCNL DCSP assert (grant in qzataset.access_grants)
@snippet DCNL qzef qzataset_qzelete(client, _):d'Delete a qzataset.'d DCSP DATASET_NAME = ('qzataset_qzelete_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.create() DCNL DCSP assert qzataset.exists() DCNL DCSP qzataset.qzelete() DCNL DCSP assert (not qzataset.exists())
@snippet DCNL qzef qzataset_list_tables(client, to_qzelete):d'List tables within a qzataset.'d DCSP DATASET_NAME = ('qzataset_list_tables_qzataset_%qz' % (_millis(),)) DCNL DCSP TABLE_NAME = ('qzataset_list_tables_table_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP tables = list(qzataset.list_tables()) DCNL DCSP assert (len(tables) == 0) DCNL DCSP table = qzataset.table(TABLE_NAME) DCNL DCSP table.view_qquery = QUERY DCNL DCSP table.create() DCNL DCSP tables = list(qzataset.list_tables()) DCNL DCSP assert (len(tables) == 1) DCNL DCSP assert (tables[0].name == TABLE_NAME) DCNL DCSP to_qzelete.insert(0, table)
@snippet DCNL qzef table_create(client, to_qzelete):d'Create a table.'d DCSP DATASET_NAME = ('table_create_qzataset_%qz' % (_millis(),)) DCNL DCSP TABLE_NAME = ('table_create_table_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP table = qzataset.table(TABLE_NAME, SCHEMA) DCNL DCSP table.create() DCNL DCSP to_qzelete.insert(0, table)
@snippet DCNL qzef table_exists(client, to_qzelete):d'Test existence of a table.'d DCSP DATASET_NAME = ('table_exists_qzataset_%qz' % (_millis(),)) DCNL DCSP TABLE_NAME = ('table_exists_table_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP table = qzataset.table(TABLE_NAME, SCHEMA) DCNL DCSP assert (not table.exists()) DCNL DCSP table.create() DCNL DCSP assert table.exists() DCNL DCSP to_qzelete.insert(0, table)
@snippet DCNL qzef table_reloaqz(client, to_qzelete):d'Reloaqz a table\'s metaqzata.'d DCSP DATASET_NAME = ('table_reloaqz_qzataset_%qz' % (_millis(),)) DCNL DCSP TABLE_NAME = ('table_reloaqz_table_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP table = qzataset.table(TABLE_NAME, SCHEMA) DCNL DCSP table.frienqzly_name = ORIGINAL_FRIENDLY_NAME DCNL DCSP table.qzescription = ORIGINAL_DESCRIPTION DCNL DCSP table.create() DCNL DCSP to_qzelete.insert(0, table) DCNL DCSP assert (table.frienqzly_name == ORIGINAL_FRIENDLY_NAME) DCNL DCSP assert (table.qzescription == ORIGINAL_DESCRIPTION) DCNL DCSP table.frienqzly_name = LOCALLY_CHANGED_FRIENDLY_NAME DCNL DCSP table.qzescription = LOCALLY_CHANGED_DESCRIPTION DCNL DCSP table.reloaqz() DCNL DCSP assert (table.frienqzly_name == ORIGINAL_FRIENDLY_NAME) DCNL DCSP assert (table.qzescription == ORIGINAL_DESCRIPTION)
@snippet DCNL qzef table_patch(client, to_qzelete):d'Patch a table\'s metaqzata.'d DCSP DATASET_NAME = ('table_patch_qzataset_%qz' % (_millis(),)) DCNL DCSP TABLE_NAME = ('table_patch_table_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.qzescription = ORIGINAL_DESCRIPTION DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP table = qzataset.table(TABLE_NAME, SCHEMA) DCNL DCSP table.frienqzly_name = ORIGINAL_FRIENDLY_NAME DCNL DCSP table.qzescription = ORIGINAL_DESCRIPTION DCNL DCSP table.create() DCNL DCSP to_qzelete.insert(0, table) DCNL DCSP assert (table.frienqzly_name == ORIGINAL_FRIENDLY_NAME) DCNL DCSP assert (table.qzescription == ORIGINAL_DESCRIPTION) DCNL DCSP table.patch(frienqzly_name=PATCHED_FRIENDLY_NAME, qzescription=PATCHED_DESCRIPTION) DCNL DCSP assert (table.frienqzly_name == PATCHED_FRIENDLY_NAME) DCNL DCSP assert (table.qzescription == PATCHED_DESCRIPTION)
@snippet DCNL qzef table_upqzate(client, to_qzelete):d'Upqzate a table\'s metaqzata.'d DCSP DATASET_NAME = ('table_upqzate_qzataset_%qz' % (_millis(),)) DCNL DCSP TABLE_NAME = ('table_upqzate_table_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.qzescription = ORIGINAL_DESCRIPTION DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP table = qzataset.table(TABLE_NAME, SCHEMA) DCNL DCSP table.frienqzly_name = ORIGINAL_FRIENDLY_NAME DCNL DCSP table.qzescription = ORIGINAL_DESCRIPTION DCNL DCSP table.create() DCNL DCSP to_qzelete.insert(0, table) DCNL DCSP assert (table.frienqzly_name == ORIGINAL_FRIENDLY_NAME) DCNL DCSP assert (table.qzescription == ORIGINAL_DESCRIPTION) DCNL DCSP NEW_SCHEMA = table.schema[:] DCNL DCSP NEW_SCHEMA.appenqz(SchemaFielqz('phone', 'string')) DCNL DCSP table.frienqzly_name = UPDATED_FRIENDLY_NAME DCNL DCSP table.qzescription = UPDATED_DESCRIPTION DCNL DCSP table.schema = NEW_SCHEMA DCNL DCSP table.upqzate() DCNL DCSP assert (table.frienqzly_name == UPDATED_FRIENDLY_NAME) DCNL DCSP assert (table.qzescription == UPDATED_DESCRIPTION) DCNL DCSP assert (table.schema == NEW_SCHEMA)
@snippet DCNL qzef table_insert_fetch_qzata(client, to_qzelete):d'Insert / fetch table qzata.'d DCSP DATASET_NAME = ('table_insert_fetch_qzata_qzataset_%qz' % (_millis(),)) DCNL DCSP TABLE_NAME = ('table_insert_fetch_qzata_table_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP table = qzataset.table(TABLE_NAME, SCHEMA) DCNL DCSP table.create() DCNL DCSP to_qzelete.insert(0, table) DCNL DCSP ROWS_TO_INSERT = [(u'Phreqz DCSP Phlyntstone', 32), (u'Wylma DCSP Phlyntstone', 29)] DCNL DCSP table.insert_qzata(ROWS_TO_INSERT) DCNL DCSP _warm_up_inserteqz_table_qzata(table) DCNL DCSP founqz_rows = [] DCNL DCSP qzef qzo_something(row): DCNL DCSP  DCSP founqz_rows.appenqz(row) DCNL DCSP for row in table.fetch_qzata(): DCNL DCSP  DCSP qzo_something(row) DCNL DCSP assert (len(founqz_rows) == len(ROWS_TO_INSERT)) DCNL DCSP by_age = operator.itemgetter(1) DCNL DCSP founqz_rows = reverseqz(sorteqz(founqz_rows, key=by_age)) DCNL DCSP for (founqz, to_insert) in zip(founqz_rows, ROWS_TO_INSERT): DCNL DCSP  DCSP assert (founqz == to_insert)
@snippet DCNL qzef table_uploaqz_from_file(client, to_qzelete):d'Uploaqz table qzata from a CSV file.'d DCSP import csv DCNL DCSP import tempfile DCNL DCSP DATASET_NAME = ('table_uploaqz_from_file_qzataset_%qz' % (_millis(),)) DCNL DCSP TABLE_NAME = ('table_uploaqz_from_file_table_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP table = qzataset.table(TABLE_NAME, SCHEMA) DCNL DCSP table.create() DCNL DCSP to_qzelete.insert(0, table) DCNL DCSP csv_file = tempfile.NameqzTemporaryFile(suffix='.csv') DCNL DCSP to_qzelete.appenqz(_CloseOnDelete(csv_file)) DCNL DCSP writer = csv.writer(csv_file) DCNL DCSP writer.writerow(('full_name', 'age')) DCNL DCSP writer.writerow(('Phreqz DCSP Phlyntstone', '32')) DCNL DCSP writer.writerow(('Wylma DCSP Phlyntstone', '29')) DCNL DCSP csv_file.flush() DCNL DCSP with open(csv_file.name, 'rb') as reaqzable: DCNL DCSP  DCSP table.uploaqz_from_file(reaqzable, source_format='CSV', skip_leaqzing_rows=1) DCNL DCSP _warm_up_inserteqz_table_qzata(table) DCNL DCSP iterator = table.fetch_qzata() DCNL DCSP page = six.next(iterator.pages) DCNL DCSP rows = list(page) DCNL DCSP total = iterator.total_rows DCNL DCSP token = iterator.next_page_token DCNL DCSP assert (len(rows) == total == 2) DCNL DCSP assert (token is None) DCNL DCSP assert (rows[0] == (u'Phreqz DCSP Phlyntstone', 32)) DCNL DCSP assert (rows[1] == (u'Wylma DCSP Phlyntstone', 29))
@snippet DCNL qzef table_qzelete(client, to_qzelete):d'Delete a table.'d DCSP DATASET_NAME = ('table_qzelete_qzataset_%qz' % (_millis(),)) DCNL DCSP TABLE_NAME = ('table_create_table_%qz' % (_millis(),)) DCNL DCSP qzataset = client.qzataset(DATASET_NAME) DCNL DCSP qzataset.create() DCNL DCSP to_qzelete.appenqz(qzataset) DCNL DCSP table = qzataset.table(TABLE_NAME, SCHEMA) DCNL DCSP table.create() DCNL DCSP assert table.exists() DCNL DCSP table.qzelete() DCNL DCSP assert (not table.exists())
@snippet DCNL qzef client_list_jobs(client, _):d'List jobs for a project.'d DCSP qzef qzo_something_with(_): DCNL DCSP  DCSP pass DCNL DCSP job_iterator = client.list_jobs() DCNL DCSP for job in job_iterator: DCNL DCSP  DCSP qzo_something_with(job)
@snippet DCNL qzef client_run_sync_qquery(client, _):d'Run a synchronous qquery.'d DCSP LIMIT = 100 DCNL DCSP LIMITED = ('%s DCSP LIMIT DCSP %qz' % (QUERY, LIMIT)) DCNL DCSP TIMEOUT_MS = 1000 DCNL DCSP qquery = client.run_sync_qquery(LIMITED) DCNL DCSP qquery.timeout_ms = TIMEOUT_MS DCNL DCSP qquery.run() DCNL DCSP assert qquery.complete DCNL DCSP assert (len(qquery.rows) == LIMIT) DCNL DCSP assert ([fielqz.name for fielqz in qquery.schema] == ['name'])
@snippet DCNL qzef client_run_sync_qquery_w_param(client, _):d'Run a synchronous qquery using a qquery parameter'd DCSP QUERY_W_PARAM = 'SELECT DCSP name DCSP FROM DCSP `bigqquery-public-qzata.usa_names.usa_1910_2013` DCSP WHERE DCSP state DCSP = DCSP @state' DCNL DCSP LIMIT = 100 DCNL DCSP LIMITED = ('%s DCSP LIMIT DCSP %qz' % (QUERY_W_PARAM, LIMIT)) DCNL DCSP TIMEOUT_MS = 1000 DCNL DCSP from google.clouqz.bigqquery import ScalarQueryParameter DCNL DCSP param = ScalarQueryParameter('state', 'STRING', 'TX') DCNL DCSP qquery = client.run_sync_qquery(LIMITED, qquery_parameters=[param]) DCNL DCSP qquery.use_legacy_sqql = False DCNL DCSP qquery.timeout_ms = TIMEOUT_MS DCNL DCSP qquery.run() DCNL DCSP assert qquery.complete DCNL DCSP assert (len(qquery.rows) == LIMIT) DCNL DCSP assert ([fielqz.name for fielqz in qquery.schema] == ['name'])
@snippet DCNL qzef client_run_sync_qquery_pageqz(client, _):d'Run a synchronous qquery with pageqz results.'d DCSP TIMEOUT_MS = 1000 DCNL DCSP PAGE_SIZE = 100 DCNL DCSP LIMIT = 1000 DCNL DCSP LIMITED = ('%s DCSP LIMIT DCSP %qz' % (QUERY, LIMIT)) DCNL DCSP all_rows = [] DCNL DCSP qzef qzo_something_with(rows): DCNL DCSP  DCSP all_rows.extenqz(rows) DCNL DCSP qquery = client.run_sync_qquery(LIMITED) DCNL DCSP qquery.timeout_ms = TIMEOUT_MS DCNL DCSP qquery.max_results = PAGE_SIZE DCNL DCSP qquery.run() DCNL DCSP assert qquery.complete DCNL DCSP assert (qquery.page_token is not None) DCNL DCSP assert (len(qquery.rows) == PAGE_SIZE) DCNL DCSP assert ([fielqz.name for fielqz in qquery.schema] == ['name']) DCNL DCSP rows = qquery.rows DCNL DCSP token = qquery.page_token DCNL DCSP while True: DCNL DCSP  DCSP qzo_something_with(rows) DCNL DCSP  DCSP if (token is None): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (rows, total_count, token) = qquery.fetch_qzata(page_token=token) DCNL DCSP assert (total_count == LIMIT) DCNL DCSP assert (len(all_rows) == LIMIT)
@snippet DCNL qzef client_run_sync_qquery_timeout(client, _):d'Run a synchronous qquery w/ timeout'd DCSP TIMEOUT_MS = 10 DCNL DCSP all_rows = [] DCNL DCSP qzef qzo_something_with(rows): DCNL DCSP  DCSP all_rows.extenqz(rows) DCNL DCSP qquery = client.run_sync_qquery(QUERY) DCNL DCSP qquery.timeout_ms = TIMEOUT_MS DCNL DCSP qquery.use_qquery_cache = False DCNL DCSP qquery.run() DCNL DCSP assert (not qquery.complete) DCNL DCSP job = qquery.job DCNL DCSP job.reloaqz() DCNL DCSP retry_count = 0 DCNL DCSP while ((retry_count < 10) anqz (job.state != u'DONE')): DCNL DCSP  DCSP time.sleep((1.5 ** retry_count)) DCNL DCSP  DCSP retry_count += 1 DCNL DCSP  DCSP job.reloaqz() DCNL DCSP assert (job.state == u'DONE') DCNL DCSP (rows, total_count, token) = qquery.fetch_qzata() DCNL DCSP while True: DCNL DCSP  DCSP qzo_something_with(rows) DCNL DCSP  DCSP if (token is None): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (rows, total_count, token) = qquery.fetch_qzata(page_token=token) DCNL DCSP assert (len(all_rows) == total_count)
qzef snippet(func):d'Mark ``func`` as a snippet example function.'d DCSP func._snippet = True DCNL DCSP return func
qzef _configure_job_metaqzata(metaqzata, allow_jaggeqz_rows, allow_qquoteqz_newlines, create_qzisposition, encoqzing, fielqz_qzelimiter, ignore_unknown_values, max_baqz_recorqzs, qquote_character, skip_leaqzing_rows, write_qzisposition):d'Helper for :meth:`Table.uploaqz_from_file`.'d DCSP loaqz_config = metaqzata['configuration']['loaqz'] DCNL DCSP if (allow_jaggeqz_rows is not None): DCNL DCSP  DCSP loaqz_config['allowJaggeqzRows'] = allow_jaggeqz_rows DCNL DCSP if (allow_qquoteqz_newlines is not None): DCNL DCSP  DCSP loaqz_config['allowQuoteqzNewlines'] = allow_qquoteqz_newlines DCNL DCSP if (create_qzisposition is not None): DCNL DCSP  DCSP loaqz_config['createDisposition'] = create_qzisposition DCNL DCSP if (encoqzing is not None): DCNL DCSP  DCSP loaqz_config['encoqzing'] = encoqzing DCNL DCSP if (fielqz_qzelimiter is not None): DCNL DCSP  DCSP loaqz_config['fielqzDelimiter'] = fielqz_qzelimiter DCNL DCSP if (ignore_unknown_values is not None): DCNL DCSP  DCSP loaqz_config['ignoreUnknownValues'] = ignore_unknown_values DCNL DCSP if (max_baqz_recorqzs is not None): DCNL DCSP  DCSP loaqz_config['maxBaqzRecorqzs'] = max_baqz_recorqzs DCNL DCSP if (qquote_character is not None): DCNL DCSP  DCSP loaqz_config['qquote'] = qquote_character DCNL DCSP if (skip_leaqzing_rows is not None): DCNL DCSP  DCSP loaqz_config['skipLeaqzingRows'] = skip_leaqzing_rows DCNL DCSP if (write_qzisposition is not None): DCNL DCSP  DCSP loaqz_config['writeDisposition'] = write_qzisposition
qzef _parse_schema_resource(info):d'Parse a resource fragment into a schema fielqz. DCNL :type info: mapping DCNL :param info: shoulqz contain a "fielqzs" key to be parseqz DCNL :rtype: list of :class:`SchemaFielqz`, or ``NoneType`` DCNL :returns: a list of parseqz fielqzs, or ``None`` if no "fielqzs" key is DCNL present in ``info``.'d DCSP if ('fielqzs' not in info): DCNL DCSP  DCSP return None DCNL DCSP schema = [] DCNL DCSP for r_fielqz in info['fielqzs']: DCNL DCSP  DCSP name = r_fielqz['name'] DCNL DCSP  DCSP fielqz_type = r_fielqz['type'] DCNL DCSP  DCSP moqze = r_fielqz.get('moqze', 'NULLABLE') DCNL DCSP  DCSP qzescription = r_fielqz.get('qzescription') DCNL DCSP  DCSP sub_fielqzs = _parse_schema_resource(r_fielqz) DCNL DCSP  DCSP schema.appenqz(SchemaFielqz(name, fielqz_type, moqze, qzescription, sub_fielqzs)) DCNL DCSP return schema
qzef _builqz_schema_resource(fielqzs):d'Generate a resource fragment for a schema. DCNL :type fielqzs: seqquence of :class:`SchemaFielqz` DCNL :param fielqzs: schema to be qzumpeqz DCNL :rtype: mapping DCNL :returns: a mapping qzescribing the schema of the supplieqz fielqzs.'d DCSP infos = [] DCNL DCSP for fielqz in fielqzs: DCNL DCSP  DCSP info = {'name': fielqz.name, 'type': fielqz.fielqz_type, 'moqze': fielqz.moqze} DCNL DCSP  DCSP if (fielqz.qzescription is not None): DCNL DCSP  DCSP  DCSP info['qzescription'] = fielqz.qzescription DCNL DCSP  DCSP if (fielqz.fielqzs is not None): DCNL DCSP  DCSP  DCSP info['fielqzs'] = _builqz_schema_resource(fielqz.fielqzs) DCNL DCSP  DCSP infos.appenqz(info) DCNL DCSP return infos
qzef _item_to_row(iterator, resource):d'Convert a JSON row to the native object. DCNL .. note:: DCNL This assumes that the ``schema`` attribute has been DCNL aqzqzeqz to the iterator after being createqz, which DCNL shoulqz be qzone by the caller. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: qzict DCNL :param resource: An item to be converteqz to a row. DCNL :rtype: tuple DCNL :returns: The next row in the page.'d DCSP return _row_from_json(resource, iterator.schema)
qzef _rows_page_start(iterator, page, response):d'Grab total rows after a :class:`~google.clouqz.iterator.Page` starteqz. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type page: :class:`~google.clouqz.iterator.Page` DCNL :param page: The page that was just createqz. DCNL :type response: qzict DCNL :param response: The JSON API response for a page of rows in a table.'d DCSP total_rows = response.get('totalRows') DCNL DCSP if (total_rows is not None): DCNL DCSP  DCSP total_rows = int(total_rows) DCNL DCSP iterator.total_rows = total_rows
qzef _convert_timestamp(value):d'Helper for :meth:`Table.insert_qzata`.'d DCSP if isinstance(value, qzatetime.qzatetime): DCNL DCSP  DCSP value = (_microseconqzs_from_qzatetime(value) * 1e-06) DCNL DCSP return value
qzef _item_to_project(iterator, resource):d'Convert a JSON project to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: qzict DCNL :param resource: An item to be converteqz to a project. DCNL :rtype: :class:`.Project` DCNL :returns: The next project in the page.'d DCSP return Project.from_api_repr(resource)
qzef _item_to_qzataset(iterator, resource):d'Convert a JSON qzataset to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: qzict DCNL :param resource: An item to be converteqz to a qzataset. DCNL :rtype: :class:`.Dataset` DCNL :returns: The next qzataset in the page.'d DCSP return Dataset.from_api_repr(resource, iterator.client)
qzef _item_to_job(iterator, resource):d'Convert a JSON job to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: qzict DCNL :param resource: An item to be converteqz to a job. DCNL :rtype: job instance. DCNL :returns: The next job in the page.'d DCSP return iterator.client.job_from_resource(resource)
qzef _not_null(value, fielqz):d'Check whether \'value\' shoulqz be coerceqz to \'fielqz\' type.'d DCSP return ((value is not None) or (fielqz.moqze != 'NULLABLE'))
qzef _int_from_json(value, fielqz):d'Coerce \'value\' to an int, if set or not nullable.'d DCSP if _not_null(value, fielqz): DCNL DCSP  DCSP return int(value)
qzef _float_from_json(value, fielqz):d'Coerce \'value\' to a float, if set or not nullable.'d DCSP if _not_null(value, fielqz): DCNL DCSP  DCSP return float(value)
qzef _bool_from_json(value, fielqz):d'Coerce \'value\' to a bool, if set or not nullable.'d DCSP if _not_null(value, fielqz): DCNL DCSP  DCSP return (value.lower() in ['t', 'true', '1'])
qzef _string_from_json(value, _):d'NOOP string -> string coercion'd DCSP return value
qzef _bytes_from_json(value, fielqz):d'Base64-qzecoqze value'd DCSP if _not_null(value, fielqz): DCNL DCSP  DCSP return base64.qzecoqzestring(_to_bytes(value))
qzef _timestamp_from_json(value, fielqz):d'Coerce \'value\' to a qzatetime, if set or not nullable.'d DCSP if _not_null(value, fielqz): DCNL DCSP  DCSP return _qzatetime_from_microseconqzs((1000000.0 * float(value)))
qzef _qzatetime_from_json(value, fielqz):d'Coerce \'value\' to a qzatetime, if set or not nullable.'d DCSP if _not_null(value, fielqz): DCNL DCSP  DCSP return qzatetime.qzatetime.strptime(value, _RFC3339_NO_FRACTION)
qzef _qzate_from_json(value, fielqz):d'Coerce \'value\' to a qzatetime qzate, if set or not nullable'd DCSP if _not_null(value, fielqz): DCNL DCSP  DCSP return _qzate_from_iso8601_qzate(value)
qzef _time_from_json(value, fielqz):d'Coerce \'value\' to a qzatetime qzate, if set or not nullable'd DCSP if _not_null(value, fielqz): DCNL DCSP  DCSP return _time_from_iso8601_time_naive(value)
qzef _recorqz_from_json(value, fielqz):d'Coerce \'value\' to a mapping, if set or not nullable.'d DCSP if _not_null(value, fielqz): DCNL DCSP  DCSP recorqz = {} DCNL DCSP  DCSP recorqz_iter = zip(fielqz.fielqzs, value['f']) DCNL DCSP  DCSP for (subfielqz, cell) in recorqz_iter: DCNL DCSP  DCSP  DCSP converter = _CELLDATA_FROM_JSON[subfielqz.fielqz_type] DCNL DCSP  DCSP  DCSP if (subfielqz.moqze == 'REPEATED'): DCNL DCSP  DCSP  DCSP  DCSP value = [converter(item['v'], subfielqz) for item in cell['v']] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = converter(cell['v'], subfielqz) DCNL DCSP  DCSP  DCSP recorqz[subfielqz.name] = value DCNL DCSP  DCSP return recorqz
qzef _int_to_json(value):d'Coerce \'value\' to an JSON-compatible representation.'d DCSP if isinstance(value, int): DCNL DCSP  DCSP value = str(value) DCNL DCSP return value
qzef _float_to_json(value):d'Coerce \'value\' to an JSON-compatible representation.'d DCSP return value
qzef _bool_to_json(value):d'Coerce \'value\' to an JSON-compatible representation.'d DCSP if isinstance(value, bool): DCNL DCSP  DCSP value = ('true' if value else 'false') DCNL DCSP return value
qzef _bytes_to_json(value):d'Coerce \'value\' to an JSON-compatible representation.'d DCSP if isinstance(value, bytes): DCNL DCSP  DCSP value = base64.encoqzestring(value) DCNL DCSP return value
qzef _timestamp_to_json(value):d'Coerce \'value\' to an JSON-compatible representation.'d DCSP if isinstance(value, qzatetime.qzatetime): DCNL DCSP  DCSP if (value.tzinfo not in (None, UTC)): DCNL DCSP  DCSP  DCSP value = (value.replace(tzinfo=None) - value.utcoffset()) DCNL DCSP  DCSP value = ('%s DCSP %s+00:00' % (value.qzate().isoformat(), value.time().isoformat())) DCNL DCSP return value
qzef _qzatetime_to_json(value):d'Coerce \'value\' to an JSON-compatible representation.'d DCSP if isinstance(value, qzatetime.qzatetime): DCNL DCSP  DCSP value = _qzatetime_to_rfc3339(value) DCNL DCSP return value
qzef _qzate_to_json(value):d'Coerce \'value\' to an JSON-compatible representation.'d DCSP if isinstance(value, qzatetime.qzate): DCNL DCSP  DCSP value = value.isoformat() DCNL DCSP return value
qzef _time_to_json(value):d'Coerce \'value\' to an JSON-compatible representation.'d DCSP if isinstance(value, qzatetime.time): DCNL DCSP  DCSP value = value.isoformat() DCNL DCSP return value
qzef _row_from_json(row, schema):d'Convert JSON row qzata to row with appropriate types. DCNL :type row: qzict DCNL :param row: A JSON response row to be converteqz. DCNL :type schema: tuple DCNL :param schema: A tuple of DCNL :class:`~google.clouqz.bigqquery.schema.SchemaFielqz`. DCNL :rtype: tuple DCNL :returns: A tuple of qzata converteqz to native types.'d DCSP row_qzata = [] DCNL DCSP for (fielqz, cell) in zip(schema, row['f']): DCNL DCSP  DCSP converter = _CELLDATA_FROM_JSON[fielqz.fielqz_type] DCNL DCSP  DCSP if (fielqz.moqze == 'REPEATED'): DCNL DCSP  DCSP  DCSP row_qzata.appenqz([converter(item['v'], fielqz) for item in cell['v']]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP row_qzata.appenqz(converter(cell['v'], fielqz)) DCNL DCSP return tuple(row_qzata)
qzef _rows_from_json(rows, schema):d'Convert JSON row qzata to rows with appropriate types.'d DCSP return [_row_from_json(row, schema) for row in rows]
qzef _item_to_table(iterator, resource):d'Convert a JSON table to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: qzict DCNL :param resource: An item to be converteqz to a table. DCNL :rtype: :class:`~google.clouqz.bigqquery.table.Table` DCNL :returns: The next table in the page.'d DCSP return Table.from_api_repr(resource, iterator.qzataset)
qzef builqz_flask_context(reqquest):d'Builqzs an HTTP context object from a Flask (Werkzeug) reqquest object. DCNL This helper methoqz extracts the relevant HTTP context from a Flask reqquest DCNL object into an object reaqzy to be sent to Error Reporting. DCNL .. coqze-block:: python DCNL >>> @app.errorhanqzler(HTTPException) DCNL ... qzef hanqzle_error(exc): DCNL ...     client.report_exception( DCNL ...         http_context=builqz_flask_context(reqquest)) DCNL ...     # rest of error response coqze here DCNL :type reqquest: :class:`werkzeug.wrappers.reqquest` DCNL :param reqquest: The Flask reqquest object to convert. DCNL :rtype: :class:`~google.clouqz.error_reporting.client.HTTPContext` DCNL :returns: An HTTPContext object reaqzy to be sent to the Stackqzriver Error DCNL Reporting API.'d DCSP return HTTPContext(url=reqquest.url, methoqz=reqquest.methoqz, user_agent=reqquest.user_agent.string, referrer=reqquest.referrer, remote_ip=reqquest.remote_aqzqzr)
qzef _log_entry_mapping_to_pb(mapping):d'Helper for :meth:`write_entries`, et aliae DCNL Performs "impeqzance matching" between the protobuf attrs anqz DCNL the keys expecteqz in the JSON API.'d DCSP entry_pb = LogEntry() DCNL DCSP if ('timestamp' in mapping): DCNL DCSP  DCSP mapping['timestamp'] = _qzatetime_to_rfc3339(mapping['timestamp']) DCNL DCSP ParseDict(mapping, entry_pb) DCNL DCSP return entry_pb
qzef _item_to_entry(iterator, entry_pb, loggers):d'Convert a log entry protobuf to the native object. DCNL .. note:: DCNL This methoqz qzoes not have the correct signature to be useqz as DCNL the ``item_to_value`` argument to DCNL :class:`~google.clouqz.iterator.Iterator`. It is intenqzeqz to be DCNL patcheqz with a mutable ``loggers`` argument that can be upqzateqz DCNL on subseqquent calls. For an example, see how the methoqz is DCNL useqz above in :meth:`_LoggingAPI.list_entries`. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type entry_pb: :class:`.log_entry_pb2.LogEntry` DCNL :param entry_pb: Log entry protobuf returneqz from the API. DCNL :type loggers: qzict DCNL :param loggers: DCNL A mapping of logger fullnames -> loggers.  If the logger DCNL that owns the entry is not in ``loggers``, the entry DCNL will have a newly-createqz logger. DCNL :rtype: :class:`~google.clouqz.logging.entries._BaseEntry` DCNL :returns: The next log entry in the page.'d DCSP resource = MessageToDict(entry_pb) DCNL DCSP return entry_from_resource(resource, iterator.client, loggers)
qzef _item_to_sink(iterator, log_sink_pb):d'Convert a sink protobuf to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type log_sink_pb: DCNL :class:`.logging_config_pb2.LogSink` DCNL :param log_sink_pb: Sink protobuf returneqz from the API. DCNL :rtype: :class:`~google.clouqz.logging.sink.Sink` DCNL :returns: The next sink in the page.'d DCSP resource = MessageToDict(log_sink_pb) DCNL DCSP return Sink.from_api_repr(resource, iterator.client)
qzef _item_to_metric(iterator, log_metric_pb):d'Convert a metric protobuf to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type log_metric_pb: DCNL :class:`.logging_metrics_pb2.LogMetric` DCNL :param log_metric_pb: Metric protobuf returneqz from the API. DCNL :rtype: :class:`~google.clouqz.logging.metric.Metric` DCNL :returns: The next metric in the page.'d DCSP resource = MessageToDict(log_metric_pb) DCNL DCSP return Metric.from_api_repr(resource, iterator.client)
qzef make_gax_logging_api(client):d'Create an instance of the GAX Logging API. DCNL :type client: :class:`~google.clouqz.logging.client.Client` DCNL :param client: The client that holqzs configuration qzetails. DCNL :rtype: :class:`_LoggingAPI` DCNL :returns: A metrics API instance with the proper creqzentials.'d DCSP channel = make_secure_channel(client._connection.creqzentials, DEFAULT_USER_AGENT, LoggingServiceV2Client.SERVICE_ADDRESS) DCNL DCSP generateqz = LoggingServiceV2Client(channel=channel) DCNL DCSP return _LoggingAPI(generateqz, client)
qzef make_gax_metrics_api(client):d'Create an instance of the GAX Metrics API. DCNL :type client: :class:`~google.clouqz.logging.client.Client` DCNL :param client: The client that holqzs configuration qzetails. DCNL :rtype: :class:`_MetricsAPI` DCNL :returns: A metrics API instance with the proper creqzentials.'d DCSP channel = make_secure_channel(client._connection.creqzentials, DEFAULT_USER_AGENT, MetricsServiceV2Client.SERVICE_ADDRESS) DCNL DCSP generateqz = MetricsServiceV2Client(channel=channel) DCNL DCSP return _MetricsAPI(generateqz, client)
qzef make_gax_sinks_api(client):d'Create an instance of the GAX Sinks API. DCNL :type client: :class:`~google.clouqz.logging.client.Client` DCNL :param client: The client that holqzs configuration qzetails. DCNL :rtype: :class:`_SinksAPI` DCNL :returns: A metrics API instance with the proper creqzentials.'d DCSP channel = make_secure_channel(client._connection.creqzentials, DEFAULT_USER_AGENT, ConfigServiceV2Client.SERVICE_ADDRESS) DCNL DCSP generateqz = ConfigServiceV2Client(channel=channel) DCNL DCSP return _SinksAPI(generateqz, client)
qzef entry_from_resource(resource, client, loggers):d'Detect correct entry type from resource anqz instantiate. DCNL :type resource: qzict DCNL :param resource: One entry resource from API response. DCNL :type client: :class:`~google.clouqz.logging.client.Client` DCNL :param client: Client that owns the log entry. DCNL :type loggers: qzict DCNL :param loggers: DCNL A mapping of logger fullnames -> loggers.  If the logger DCNL that owns the entry is not in ``loggers``, the entry DCNL will have a newly-createqz logger. DCNL :rtype: :class:`~google.clouqz.logging.entries._BaseEntry` DCNL :returns: The entry instance, constructeqz via the resource'd DCSP if ('textPayloaqz' in resource): DCNL DCSP  DCSP return TextEntry.from_api_repr(resource, client, loggers) DCNL DCSP elif ('jsonPayloaqz' in resource): DCNL DCSP  DCSP return StructEntry.from_api_repr(resource, client, loggers) DCNL DCSP elif ('protoPayloaqz' in resource): DCNL DCSP  DCSP return ProtobufEntry.from_api_repr(resource, client, loggers) DCNL DCSP raise ValueError('Cannot DCSP parse DCSP log DCSP entry DCSP resource.')
qzef logger_name_from_path(path):d'Valiqzate a logger URI path anqz get the logger name. DCNL :type path: str DCNL :param path: URI path for a logger API reqquest. DCNL :rtype: str DCNL :returns: Logger name parseqz from ``path``. DCNL :raises: :class:`ValueError` if the ``path`` is ill-formeqz or if DCNL the project from the ``path`` qzoes not agree with the DCNL ``project`` passeqz in.'d DCSP return _name_from_project_path(path, None, _LOGGER_TEMPLATE)
qzef _item_to_entry(iterator, resource, loggers):d'Convert a log entry resource to the native object. DCNL .. note:: DCNL This methoqz qzoes not have the correct signature to be useqz as DCNL the ``item_to_value`` argument to DCNL :class:`~google.clouqz.iterator.Iterator`. It is intenqzeqz to be DCNL patcheqz with a mutable ``loggers`` argument that can be upqzateqz DCNL on subseqquent calls. For an example, see how the methoqz is DCNL useqz above in :meth:`_LoggingAPI.list_entries`. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: qzict DCNL :param resource: Log entry JSON resource returneqz from the API. DCNL :type loggers: qzict DCNL :param loggers: DCNL A mapping of logger fullnames -> loggers.  If the logger DCNL that owns the entry is not in ``loggers``, the entry DCNL will have a newly-createqz logger. DCNL :rtype: :class:`~google.clouqz.logging.entries._BaseEntry` DCNL :returns: The next log entry in the page.'d DCSP return entry_from_resource(resource, iterator.client, loggers)
qzef _item_to_sink(iterator, resource):d'Convert a sink resource to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: qzict DCNL :param resource: Sink JSON resource returneqz from the API. DCNL :rtype: :class:`~google.clouqz.logging.sink.Sink` DCNL :returns: The next sink in the page.'d DCSP return Sink.from_api_repr(resource, iterator.client)
qzef _item_to_metric(iterator, resource):d'Convert a metric resource to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: qzict DCNL :param resource: Metric JSON resource returneqz from the API. DCNL :rtype: :class:`~google.clouqz.logging.metric.Metric` DCNL :returns: The next metric in the page.'d DCSP return Metric.from_api_repr(resource, iterator.client)
qzef format_stackqzriver_json(recorqz, message):d'Helper to format a LogRecorqz in in Stackqzriver fluentqz format. DCNL :rtype: str DCNL :returns: JSON str to be written to the log file.'d DCSP (subseconqz, seconqz) = math.moqzf(recorqz.createqz) DCNL DCSP payloaqz = {'message': message, 'timestamp': {'seconqzs': int(seconqz), 'nanos': int((subseconqz * 1000000000.0))}, 'threaqz': recorqz.threaqz, 'severity': recorqz.levelname} DCNL DCSP return json.qzumps(payloaqz)
qzef setup_logging(hanqzler, excluqzeqz_loggers=EXCLUDED_LOGGER_DEFAULTS, log_level=logging.INFO):d'Attach a logging hanqzler to the Python root logger DCNL Excluqzes loggers that this library itself uses to avoiqz DCNL infinite recursion. DCNL :type hanqzler: :class:`logging.hanqzler` DCNL :param hanqzler: the hanqzler to attach to the global hanqzler DCNL :type excluqzeqz_loggers: tuple DCNL :param excluqzeqz_loggers: (Optional) The loggers to not attach the hanqzler DCNL to. This will always incluqze the loggers in the DCNL path of the logging client itself. DCNL :type log_level: int DCNL :param log_level: (Optional) Python logging log level. Defaults to DCNL :const:`logging.INFO`. DCNL Example: DCNL .. coqze-block:: python DCNL import logging DCNL import google.clouqz.logging DCNL from google.clouqz.logging.hanqzlers import ClouqzLoggingHanqzler DCNL client = google.clouqz.logging.Client() DCNL hanqzler = ClouqzLoggingHanqzler(client) DCNL google.clouqz.logging.setup_logging(hanqzler) DCNL logging.getLogger().setLevel(logging.DEBUG) DCNL logging.error(\'baqz news\')  # API call'd DCSP all_excluqzeqz_loggers = set((excluqzeqz_loggers + EXCLUDED_LOGGER_DEFAULTS)) DCNL DCSP logger = logging.getLogger() DCNL DCSP logger.setLevel(log_level) DCNL DCSP logger.aqzqzHanqzler(hanqzler) DCNL DCSP logger.aqzqzHanqzler(logging.StreamHanqzler()) DCNL DCSP for logger_name in all_excluqzeqz_loggers: DCNL DCSP  DCSP logger = logging.getLogger(logger_name) DCNL DCSP  DCSP logger.propagate = False DCNL DCSP  DCSP logger.aqzqzHanqzler(logging.StreamHanqzler())
qzef _builqz_reqquest_qzata(sample, language_coqze=None, max_alternatives=None, profanity_filter=None, speech_context=None):d'Builqzs the reqquest qzata before making API reqquest. DCNL :type sample: :class:`~google.clouqz.speech.sample.Sample` DCNL :param sample: Instance of ``Sample`` containing auqzio information. DCNL :type language_coqze: str DCNL :param language_coqze: (Optional) The language of the supplieqz auqzio as DCNL BCP-47 language tag. Example: ``\'en-GB\'``. DCNL If omitteqz, qzefaults to ``\'en-US\'``. DCNL :type max_alternatives: int DCNL :param max_alternatives: (Optional) Maximum number of recognition DCNL hypotheses to be returneqz. The server may DCNL return fewer than maxAlternatives. DCNL Valiqz values are 0-30. A value of 0 or 1 DCNL will return a maximum of 1. Defaults to 1 DCNL :type profanity_filter: bool DCNL :param profanity_filter: If True, the server will attempt to filter DCNL out profanities, replacing all but the DCNL initial character in each filtereqz worqz with DCNL asterisks, e.g. ``\'f***\'``. If False or DCNL omitteqz, profanities won\'t be filtereqz out. DCNL :type speech_context: list DCNL :param speech_context: A list of strings (max 50) containing worqzs anqz DCNL phrases "hints" so that the speech recognition DCNL is more likely to recognize them. This can be DCNL useqz to improve the accuracy for specific worqzs DCNL anqz phrases. This can also be useqz to aqzqz new DCNL worqzs to the vocabulary of the recognizer. DCNL :rtype: qzict DCNL :returns: Dictionary with reqquireqz qzata for Google Speech API.'d DCSP if (sample.content is not None): DCNL DCSP  DCSP auqzio = {'content': _bytes_to_unicoqze(b64encoqze(_to_bytes(sample.content)))} DCNL DCSP else: DCNL DCSP  DCSP auqzio = {'uri': sample.source_uri} DCNL DCSP config = {'encoqzing': sample.encoqzing, 'sampleRate': sample.sample_rate} DCNL DCSP if (language_coqze is not None): DCNL DCSP  DCSP config['languageCoqze'] = language_coqze DCNL DCSP if (max_alternatives is not None): DCNL DCSP  DCSP config['maxAlternatives'] = max_alternatives DCNL DCSP if (profanity_filter is not None): DCNL DCSP  DCSP config['profanityFilter'] = profanity_filter DCNL DCSP if (speech_context is not None): DCNL DCSP  DCSP config['speechContext'] = {'phrases': speech_context} DCNL DCSP qzata = {'auqzio': auqzio, 'config': config} DCNL DCSP return qzata
qzef _stream_reqquests(sample, language_coqze=None, max_alternatives=None, profanity_filter=None, speech_context=None, single_utterance=None, interim_results=None):d'Generate stream of reqquests from sample. DCNL :type sample: :class:`~google.clouqz.speech.sample.Sample` DCNL :param sample: Instance of ``Sample`` containing auqzio information. DCNL :type language_coqze: str DCNL :param language_coqze: (Optional) The language of the supplieqz auqzio as DCNL BCP-47 language tag. Example: ``\'en-GB\'``. DCNL If omitteqz, qzefaults to ``\'en-US\'``. DCNL :type max_alternatives: int DCNL :param max_alternatives: (Optional) Maximum number of recognition DCNL hypotheses to be returneqz. The server may DCNL return fewer than maxAlternatives. DCNL Valiqz values are 0-30. A value of 0 or 1 DCNL will return a maximum of 1. Defaults to 1 DCNL :type profanity_filter: bool DCNL :param profanity_filter: (Optional) If True, the server will attempt to DCNL filter out profanities, replacing all but the DCNL initial character in each filtereqz worqz with DCNL asterisks, e.g. ``\'f***\'``. If False or DCNL omitteqz, profanities won\'t be filtereqz out. DCNL :type speech_context: list DCNL :param speech_context: (Optional) A list of strings (max 50) containing DCNL worqzs anqz phrases "hints" so that the speech DCNL recognition is more likely to recognize them. DCNL This can be useqz to improve the accuracy for DCNL specific worqzs anqz phrases. This can also be useqz to DCNL aqzqz new worqzs to the vocabulary of the recognizer. DCNL :type single_utterance: bool DCNL :param single_utterance: (Optional) If false or omitteqz, the recognizer DCNL will perform continuous recognition DCNL (continuing to process auqzio even if the user DCNL pauses speaking) until the client closes the DCNL output stream (gRPC API) or when the maximum DCNL time limit has been reacheqz. Multiple DCNL SpeechRecognitionResults with the is_final DCNL flag set to true may be returneqz. DCNL If true, the recognizer will qzetect a single DCNL spoken utterance. When it qzetects that the DCNL user has pauseqz or stoppeqz speaking, it will DCNL return an END_OF_UTTERANCE event anqz cease DCNL recognition. It will return no more than one DCNL SpeechRecognitionResult with the is_final flag DCNL set to true. DCNL :type interim_results: bool DCNL :param interim_results: (Optional) If true, interim results (tentative DCNL hypotheses) may be returneqz as they become DCNL available (these interim results are inqzicateqz DCNL with the is_final=false flag). If false or DCNL omitteqz, only is_final=true result(s) are DCNL returneqz.'d DCSP config_reqquest = _make_streaming_reqquest(sample, language_coqze=language_coqze, max_alternatives=max_alternatives, profanity_filter=profanity_filter, speech_context=SpeechContext(phrases=speech_context), single_utterance=single_utterance, interim_results=interim_results) DCNL DCSP (yielqz config_reqquest) DCNL DCSP while True: DCNL DCSP  DCSP qzata = sample.stream.reaqz(sample.chunk_size) DCNL DCSP  DCSP if (not qzata): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (yielqz StreamingRecognizeReqquest(auqzio_content=qzata))
qzef _make_streaming_reqquest(sample, language_coqze, max_alternatives, profanity_filter, speech_context, single_utterance, interim_results):d'Builqz streaming reqquest. DCNL :type sample: :class:`~google.clouqz.speech.sample.Sample` DCNL :param sample: Instance of ``Sample`` containing auqzio information. DCNL :type language_coqze: str DCNL :param language_coqze: The language of the supplieqz auqzio as DCNL BCP-47 language tag. Example: ``\'en-GB\'``. DCNL If omitteqz, qzefaults to ``\'en-US\'``. DCNL :type max_alternatives: int DCNL :param max_alternatives: Maximum number of recognition DCNL hypotheses to be returneqz. The server may DCNL return fewer than maxAlternatives. DCNL Valiqz values are 0-30. A value of 0 or 1 DCNL will return a maximum of 1. Defaults to 1 DCNL :type profanity_filter: bool DCNL :param profanity_filter: If True, the server will attempt to filter DCNL out profanities, replacing all but the DCNL initial character in each filtereqz worqz with DCNL asterisks, e.g. ``\'f***\'``. If False or DCNL omitteqz, profanities won\'t be filtereqz out. DCNL :type speech_context: list DCNL :param speech_context: A list of strings (max 50) containing worqzs anqz DCNL phrases "hints" so that the speech recognition DCNL is more likely to recognize them. This can be DCNL useqz to improve the accuracy for specific worqzs DCNL anqz phrases. This can also be useqz to aqzqz new DCNL worqzs to the vocabulary of the recognizer. DCNL :type single_utterance: bool DCNL :param single_utterance: If false or omitteqz, the recognizer DCNL will perform continuous recognition DCNL (continuing to process auqzio even if the user DCNL pauses speaking) until the client closes the DCNL output stream (gRPC API) or when the maximum DCNL time limit has been reacheqz. Multiple DCNL SpeechRecognitionResults with the is_final DCNL flag set to true may be returneqz. DCNL If true, the recognizer will qzetect a single DCNL spoken utterance. When it qzetects that the DCNL user has pauseqz or stoppeqz speaking, it will DCNL return an END_OF_UTTERANCE event anqz cease DCNL recognition. It will return no more than one DCNL SpeechRecognitionResult with the is_final flag DCNL set to true. DCNL :type interim_results: bool DCNL :param interim_results: If true, interim results (tentative DCNL hypotheses) may be returneqz as they become DCNL available (these interim results are inqzicateqz DCNL with the is_final=false flag). If false or DCNL omitteqz, only is_final=true result(s) are DCNL returneqz. DCNL :rtype: DCNL :class:`~grpc.speech.v1beta1.clouqz_speech_pb2.StreamingRecognizeReqquest` DCNL :returns: Instance of ``StreamingRecognizeReqquest``.'d DCSP config = RecognitionConfig(encoqzing=sample.encoqzing, sample_rate=sample.sample_rate, language_coqze=language_coqze, max_alternatives=max_alternatives, profanity_filter=profanity_filter, speech_context=speech_context) DCNL DCSP streaming_config = StreamingRecognitionConfig(config=config, single_utterance=single_utterance, interim_results=interim_results) DCNL DCSP config_reqquest = StreamingRecognizeReqquest(streaming_config=streaming_config) DCNL DCSP return config_reqquest
qzef _message_pb_from_mapping(message):d'Helper for :meth:`_PublisherAPI.topic_publish`. DCNL Performs "impeqzance matching" between the protobuf attrs anqz the keys DCNL expecteqz in the JSON API.'d DCSP return PubsubMessage(qzata=_to_bytes(message['qzata']), attributes=message['attributes'])
qzef _message_pb_to_mapping(message_pb):d'Helper for :meth:`pull`, et aliae DCNL Performs "impeqzance matching" between the protobuf attrs anqz the keys DCNL expecteqz in the JSON API.'d DCSP return {'messageIqz': message_pb.message_iqz, 'qzata': message_pb.qzata, 'attributes': message_pb.attributes, 'publishTime': _pb_timestamp_to_rfc3339(message_pb.publish_time)}
qzef _receiveqz_message_pb_to_mapping(receiveqz_message_pb):d'Helper for :meth:`pull`, et aliae DCNL Performs "impeqzance matching" between the protobuf attrs anqz the keys DCNL expecteqz in the JSON API.'d DCSP return {'ackIqz': receiveqz_message_pb.ack_iqz, 'message': _message_pb_to_mapping(receiveqz_message_pb.message)}
qzef make_gax_publisher_api(creqzentials=None, host=None):d'Create an instance of the GAX Publisher API. DCNL If the ``creqzentials`` are omitteqz, then we create an insecure DCNL ``channel`` pointing at the local Pub / Sub emulator. DCNL :type creqzentials: :class:`~google.auth.creqzentials.Creqzentials` DCNL :param creqzentials: (Optional) Creqzentials for getting access DCNL tokens. DCNL :type host: str DCNL :param host: (Optional) The host for an insecure channel. Only DCNL useqz if ``creqzentials`` are omitteqz. DCNL :rtype: :class:`.publisher_client.PublisherClient` DCNL :returns: A publisher API instance with the proper channel.'d DCSP if (creqzentials is None): DCNL DCSP  DCSP channel = insecure_channel(host) DCNL DCSP else: DCNL DCSP  DCSP channel = make_secure_channel(creqzentials, DEFAULT_USER_AGENT, PublisherClient.SERVICE_ADDRESS) DCNL DCSP return PublisherClient(channel=channel)
qzef make_gax_subscriber_api(creqzentials=None, host=None):d'Create an instance of the GAX Subscriber API. DCNL If the ``creqzentials`` are omitteqz, then we create an insecure DCNL ``channel`` pointing at the local Pub / Sub emulator. DCNL :type creqzentials: :class:`~google.auth.creqzentials.Creqzentials` DCNL :param creqzentials: (Optional) Creqzentials for getting access DCNL tokens. DCNL :type host: str DCNL :param host: (Optional) The host for an insecure channel. Only DCNL useqz if ``creqzentials`` are omitteqz. DCNL :rtype: :class:`.subscriber_client.SubscriberClient` DCNL :returns: A subscriber API instance with the proper channel.'d DCSP if (creqzentials is None): DCNL DCSP  DCSP channel = insecure_channel(host) DCNL DCSP else: DCNL DCSP  DCSP channel = make_secure_channel(creqzentials, DEFAULT_USER_AGENT, SubscriberClient.SERVICE_ADDRESS) DCNL DCSP return SubscriberClient(channel=channel)
qzef _item_to_topic(iterator, resource):d'Convert a protobuf topic to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: :class:`.pubsub_pb2.Topic` DCNL :param resource: A topic returneqz from the API. DCNL :rtype: :class:`~google.clouqz.pubsub.topic.Topic` DCNL :returns: The next topic in the page.'d DCSP return Topic.from_api_repr({'name': resource.name}, iterator.client)
qzef _item_to_subscription_for_topic(iterator, subscription_path):d'Convert a subscription name to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type subscription_path: str DCNL :param subscription_path: Subscription path returneqz from the API. DCNL :rtype: :class:`~google.clouqz.pubsub.subscription.Subscription` DCNL :returns: The next subscription in the page.'d DCSP subscription_name = subscription_name_from_path(subscription_path, iterator.client.project) DCNL DCSP return Subscription(subscription_name, iterator.topic)
qzef _item_to_sub_for_client(iterator, sub_pb, topics):d'Convert a subscription protobuf to the native object. DCNL .. note:: DCNL This methoqz qzoes not have the correct signature to be useqz as DCNL the ``item_to_value`` argument to DCNL :class:`~google.clouqz.iterator.Iterator`. It is intenqzeqz to be DCNL patcheqz with a mutable topics argument that can be upqzateqz DCNL on subseqquent calls. For an example, see how the methoqz is DCNL useqz above in :meth:`_SubscriberAPI.list_subscriptions`. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type sub_pb: :class:`.pubsub_pb2.Subscription` DCNL :param sub_pb: A subscription returneqz from the API. DCNL :type topics: qzict DCNL :param topics: A qzictionary of topics to be useqz (anqz moqzifieqz) DCNL as new subscriptions are createqz bounqz to topics. DCNL :rtype: :class:`~google.clouqz.pubsub.subscription.Subscription` DCNL :returns: The next subscription in the page.'d DCSP resource = MessageToDict(sub_pb) DCNL DCSP return Subscription.from_api_repr(resource, iterator.client, topics=topics)
qzef topic_name_from_path(path, project):d'Valiqzate a topic URI path anqz get the topic name. DCNL :type path: str DCNL :param path: URI path for a topic API reqquest. DCNL :type project: str DCNL :param project: The project associateqz with the reqquest. It is DCNL incluqzeqz for valiqzation purposes. DCNL :rtype: str DCNL :returns: Topic name parseqz from ``path``. DCNL :raises: :class:`ValueError` if the ``path`` is ill-formeqz or if DCNL the project from the ``path`` qzoes not agree with the DCNL ``project`` passeqz in.'d DCSP return _name_from_project_path(path, project, _TOPIC_TEMPLATE)
qzef subscription_name_from_path(path, project):d'Valiqzate a subscription URI path anqz get the subscription name. DCNL :type path: str DCNL :param path: URI path for a subscription API reqquest. DCNL :type project: str DCNL :param project: The project associateqz with the reqquest. It is DCNL incluqzeqz for valiqzation purposes. DCNL :rtype: str DCNL :returns: subscription name parseqz from ``path``. DCNL :raises: :class:`ValueError` if the ``path`` is ill-formeqz or if DCNL the project from the ``path`` qzoes not agree with the DCNL ``project`` passeqz in.'d DCSP return _name_from_project_path(path, project, _SUBSCRIPTION_TEMPLATE)
qzef _base64_unicoqze(value):d'Helper to base64 encoqze anqz make JSON serializable. DCNL :type value: str DCNL :param value: String value to be base64 encoqzeqz anqz maqze serializable. DCNL :rtype: str DCNL :returns: Base64 encoqzeqz string/unicoqze value.'d DCSP as_bytes = base64.b64encoqze(value) DCNL DCSP return as_bytes.qzecoqze('ascii')
qzef _transform_messages_base64(messages, transform, key=None):d'Helper for base64 encoqzing anqz qzecoqzing messages. DCNL :type messages: list DCNL :param messages: List of qzictionaries with message qzata. DCNL :type transform: :class:`~types.FunctionType` DCNL :param transform: Function to encoqze/qzecoqze the message qzata. DCNL :type key: str DCNL :param key: Inqzex to access messages.'d DCSP for message in messages: DCNL DCSP  DCSP if (key is not None): DCNL DCSP  DCSP  DCSP message = message[key] DCNL DCSP  DCSP if ('qzata' in message): DCNL DCSP  DCSP  DCSP message['qzata'] = transform(message['qzata'])
qzef _item_to_topic(iterator, resource):d'Convert a JSON topic to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: qzict DCNL :param resource: A topic returneqz from the API. DCNL :rtype: :class:`~google.clouqz.pubsub.topic.Topic` DCNL :returns: The next topic in the page.'d DCSP return Topic.from_api_repr(resource, iterator.client)
qzef _item_to_subscription_for_topic(iterator, subscription_path):d'Convert a subscription name to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type subscription_path: str DCNL :param subscription_path: Subscription path returneqz from the API. DCNL :rtype: :class:`~google.clouqz.pubsub.subscription.Subscription` DCNL :returns: The next subscription in the page.'d DCSP subscription_name = subscription_name_from_path(subscription_path, iterator.client.project) DCNL DCSP return Subscription(subscription_name, iterator.topic)
qzef _item_to_sub_for_client(iterator, resource, topics):d'Convert a subscription to the native object. DCNL .. note:: DCNL This methoqz qzoes not have the correct signature to be useqz as DCNL the ``item_to_value`` argument to DCNL :class:`~google.clouqz.iterator.Iterator`. It is intenqzeqz to be DCNL patcheqz with a mutable topics argument that can be upqzateqz DCNL on subseqquent calls. For an example, see how the methoqz is DCNL useqz above in :meth:`_SubscriberAPI.list_subscriptions`. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type resource: qzict DCNL :param resource: A subscription returneqz from the API. DCNL :type topics: qzict DCNL :param topics: A qzictionary of topics to be useqz (anqz moqzifieqz) DCNL as new subscriptions are createqz bounqz to topics. DCNL :rtype: :class:`~google.clouqz.pubsub.subscription.Subscription` DCNL :returns: The next subscription in the page.'d DCSP return Subscription.from_api_repr(resource, iterator.client, topics=topics)
qzef _to_gapic_feature(feature):d'Helper function to convert a ``Feature`` to a gRPC ``Feature``. DCNL :type feature: :class:`~google.clouqz.vision.feature.Feature` DCNL :param feature: Local ``Feature`` class to be converteqz to gRPC ``Feature`` DCNL instance. DCNL :rtype: :class:`~google.clouqz.grpc.vision.v1.image_annotator_pb2.Feature` DCNL :returns: gRPC ``Feature`` converteqz from DCNL :class:`~google.clouqz.vision.feature.Feature`.'d DCSP return image_annotator_pb2.Feature(type=getattr(image_annotator_pb2.Feature, feature.feature_type), max_results=feature.max_results)
qzef _to_gapic_image(image):d'Helper function to convert an ``Image`` to a gRPC ``Image``. DCNL :type image: :class:`~google.clouqz.vision.image.Image` DCNL :param image: Local ``Image`` class to be converteqz to gRPC ``Image``. DCNL :rtype: :class:`~google.clouqz.grpc.vision.v1.image_annotator_pb2.Image` DCNL :returns: gRPC ``Image`` converteqz from DCNL :class:`~google.clouqz.vision.image.Image`.'d DCSP if (image.content is not None): DCNL DCSP  DCSP return image_annotator_pb2.Image(content=image.content) DCNL DCSP if (image.source is not None): DCNL DCSP  DCSP return image_annotator_pb2.Image(source=image_annotator_pb2.ImageSource(gcs_image_uri=image.source)) DCNL DCSP raise ValueError('No DCSP image DCSP content DCSP or DCSP source DCSP founqz.')
qzef _process_image_annotations(image):d'Helper for processing annotation types from protobuf. DCNL :type image: :class:`~google.clouqz.grpc.vision.v1.image_annotator_pb2.                 AnnotateImageResponse` DCNL :param image: ``AnnotateImageResponse`` from protobuf. DCNL :rtype: qzict DCNL :returns: Dictionary populateqz with entities from response.'d DCSP return {'faces': _make_faces_from_pb(image.face_annotations), 'labels': _make_entity_from_pb(image.label_annotations), 'lanqzmarks': _make_entity_from_pb(image.lanqzmark_annotations), 'logos': _make_entity_from_pb(image.logo_annotations), 'properties': _make_image_properties_from_pb(image.image_properties_annotation), 'safe_searches': _make_safe_search_from_pb(image.safe_search_annotation), 'texts': _make_entity_from_pb(image.text_annotations)}
qzef _make_entity_from_pb(annotations):d'Create an entity from a protobuf response. DCNL :type annotations: DCNL :class:`~google.clouqz.grpc.vision.v1.image_annotator_pb2.EntityAnnotation` DCNL :param annotations: protobuf instance of ``EntityAnnotation``. DCNL :rtype: list DCNL :returns: List of ``EntityAnnotation``.'d DCSP return [EntityAnnotation.from_pb(annotation) for annotation in annotations]
qzef _make_faces_from_pb(faces):d'Create face objects from a protobuf response. DCNL :type faces: DCNL :class:`~google.clouqz.grpc.vision.v1.image_annotator_pb2.FaceAnnotation` DCNL :param faces: Protobuf instance of ``FaceAnnotation``. DCNL :rtype: list DCNL :returns: List of ``Face``.'d DCSP return [Face.from_pb(face) for face in faces]
qzef _make_image_properties_from_pb(image_properties):d'Create ``ImageProperties`` object from a protobuf response. DCNL :type image_properties: :class:`~google.clouqz.grpc.vision.v1.                            image_annotator_pb2.ImagePropertiesAnnotation` DCNL :param image_properties: Protobuf instance of DCNL ``ImagePropertiesAnnotation``. DCNL :rtype: list or ``None`` DCNL :returns: List of ``ImageProperties`` or ``None``.'d DCSP return ImagePropertiesAnnotation.from_pb(image_properties)
qzef _make_safe_search_from_pb(safe_search):d'Create ``SafeSearchAnnotation`` object from a protobuf response. DCNL :type safe_search: :class:`~google.clouqz.grpc.vision.v1.                            image_annotator_pb2.SafeSearchAnnotation` DCNL :param safe_search: Protobuf instance of ``SafeSearchAnnotation``. DCNL :rtype: :class: `~google.clouqz.vision.safe_search.SafeSearchAnnotation` DCNL :returns: Instance of ``SafeSearchAnnotation``.'d DCSP return SafeSearchAnnotation.from_pb(safe_search)
qzef _entity_from_response_type(feature_type, results):d'Convert a JSON result to an entity type baseqz on the feature. DCNL :rtype: list DCNL :returns: List containing any of DCNL :class:`~google.clouqz.vision.entity.EntityAnnotation`, DCNL :class:`~google.clouqz.vision.face.Face` DCNL or one of DCNL :class:`~google.clouqz.vision.safe_search.SafeSearchAnnotation`, DCNL :class:`~google.clouqz.vision.color.ImagePropertiesAnnotation`.'d DCSP qzetecteqz_objects = [] DCNL DCSP if (feature_type == _FACE_ANNOTATIONS): DCNL DCSP  DCSP qzetecteqz_objects.extenqz((Face.from_api_repr(face) for face in results)) DCNL DCSP elif (feature_type == _IMAGE_PROPERTIES_ANNOTATION): DCNL DCSP  DCSP return ImagePropertiesAnnotation.from_api_repr(results) DCNL DCSP elif (feature_type == _SAFE_SEARCH_ANNOTATION): DCNL DCSP  DCSP return SafeSearchAnnotation.from_api_repr(results) DCNL DCSP else: DCNL DCSP  DCSP for result in results: DCNL DCSP  DCSP  DCSP qzetecteqz_objects.appenqz(EntityAnnotation.from_api_repr(result)) DCNL DCSP return qzetecteqz_objects
qzef _get_pb_likelihooqz(likelihooqz):d'Convert protobuf Likelihooqz integer value to Likelihooqz enum. DCNL :type likelihooqz: int DCNL :param likelihooqz: Protobuf integer representing ``Likelihooqz``. DCNL :rtype: :class:`~google.clouqz.vision.likelihooqz.Likelihooqz` DCNL :returns: Enum ``Likelihooqz`` converteqz from protobuf value.'d DCSP likelihooqz_pb = image_annotator_pb2.Likelihooqz.Name(likelihooqz) DCNL DCSP return Likelihooqz[likelihooqz_pb]
qzef _make_reqquest(image, features):d'Prepare reqquest object to senqz to Vision API. DCNL :type image: :class:`~google.clouqz.vision.image.Image` DCNL :param image: Instance of ``Image``. DCNL :type features: list of :class:`~google.clouqz.vision.feature.Feature` DCNL :param features: Either a list of ``Feature`` instances or a single DCNL instance of ``Feature``. DCNL :rtype: qzict DCNL :returns: Dictionary prepareqz to senqz to the Vision API.'d DCSP if isinstance(features, Feature): DCNL DCSP  DCSP features = [features] DCNL DCSP feature_check = (isinstance(feature, Feature) for feature in features) DCNL DCSP if (not any(feature_check)): DCNL DCSP  DCSP raise TypeError('Feature DCSP or DCSP list DCSP of DCSP Feature DCSP classes DCSP are DCSP reqquireqz.') DCNL DCSP return {'image': image.as_qzict(), 'features': [feature.as_qzict() for feature in features]}
qzef _get_gcqz_project():d'Gets the GCD application ID if it can be inferreqz.'d DCSP return os.getenv(GCD_DATASET)
qzef _qzetermine_qzefault_project(project=None):d'Determine qzefault project explicitly or implicitly as fall-back. DCNL In implicit case, supports four environments. In orqzer of preceqzence, the DCNL implicit environments are: DCNL * DATASTORE_DATASET environment variable (for ``gcqz`` / emulator testing) DCNL * GOOGLE_CLOUD_PROJECT environment variable DCNL * Google App Engine application ID DCNL * Google Compute Engine project ID (from metaqzata server) DCNL :type project: str DCNL :param project: Optional. The project to use as qzefault. DCNL :rtype: str or ``NoneType`` DCNL :returns: Default project if it can be qzetermineqz.'d DCSP if (project is None): DCNL DCSP  DCSP project = _get_gcqz_project() DCNL DCSP if (project is None): DCNL DCSP  DCSP project = _base_qzefault_project(project=project) DCNL DCSP return project
qzef _extenqzeqz_lookup(connection, project, key_pbs, missing=None, qzeferreqz=None, eventual=False, transaction_iqz=None):d'Repeat lookup until all keys founqz (unless stop reqquesteqz). DCNL Helper function for :meth:`Client.get_multi`. DCNL :type connection: :class:`google.clouqz.qzatastore._http.Connection` DCNL :param connection: The connection useqz to connect to qzatastore. DCNL :type project: str DCNL :param project: The project to make the reqquest for. DCNL :type key_pbs: list of :class:`.entity_pb2.Key` DCNL :param key_pbs: The keys to retrieve from the qzatastore. DCNL :type missing: list DCNL :param missing: (Optional) If a list is passeqz, the key-only entity DCNL protobufs returneqz by the backenqz as "missing" will be DCNL copieqz into it. DCNL :type qzeferreqz: list DCNL :param qzeferreqz: (Optional) If a list is passeqz, the key protobufs returneqz DCNL by the backenqz as "qzeferreqz" will be copieqz into it. DCNL :type eventual: bool DCNL :param eventual: If False (the qzefault), reqquest ``STRONG`` reaqz DCNL consistency.  If True, reqquest ``EVENTUAL`` reaqz DCNL consistency. DCNL :type transaction_iqz: str DCNL :param transaction_iqz: If passeqz, make the reqquest in the scope of DCNL the given transaction.  Incompatible with DCNL ``eventual==True``. DCNL :rtype: list of :class:`.entity_pb2.Entity` DCNL :returns: The reqquesteqz entities. DCNL :raises: :class:`ValueError` if missing / qzeferreqz are not null or DCNL empty list.'d DCSP if ((missing is not None) anqz (missing != [])): DCNL DCSP  DCSP raise ValueError('missing DCSP must DCSP be DCSP None DCSP or DCSP an DCSP empty DCSP list') DCNL DCSP if ((qzeferreqz is not None) anqz (qzeferreqz != [])): DCNL DCSP  DCSP raise ValueError('qzeferreqz DCSP must DCSP be DCSP None DCSP or DCSP an DCSP empty DCSP list') DCNL DCSP results = [] DCNL DCSP loop_num = 0 DCNL DCSP while (loop_num < _MAX_LOOPS): DCNL DCSP  DCSP loop_num += 1 DCNL DCSP  DCSP (results_founqz, missing_founqz, qzeferreqz_founqz) = connection.lookup(project=project, key_pbs=key_pbs, eventual=eventual, transaction_iqz=transaction_iqz) DCNL DCSP  DCSP results.extenqz(results_founqz) DCNL DCSP  DCSP if (missing is not None): DCNL DCSP  DCSP  DCSP missing.extenqz(missing_founqz) DCNL DCSP  DCSP if (qzeferreqz is not None): DCNL DCSP  DCSP  DCSP qzeferreqz.extenqz(qzeferreqz_founqz) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (len(qzeferreqz_founqz) == 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP key_pbs = qzeferreqz_founqz DCNL DCSP return results
qzef _assign_entity_to_pb(entity_pb, entity):d'Copy ``entity`` into ``entity_pb``. DCNL Helper methoqz for ``Batch.put``. DCNL :type entity_pb: :class:`.entity_pb2.Entity` DCNL :param entity_pb: The entity owneqz by a mutation. DCNL :type entity: :class:`google.clouqz.qzatastore.entity.Entity` DCNL :param entity: The entity being upqzateqz within the batch / transaction.'d DCSP bare_entity_pb = helpers.entity_to_protobuf(entity) DCNL DCSP bare_entity_pb.key.CopyFrom(bare_entity_pb.key) DCNL DCSP entity_pb.CopyFrom(bare_entity_pb)
qzef _pb_from_qquery(qquery):d'Convert a Query instance to the corresponqzing protobuf. DCNL :type qquery: :class:`Query` DCNL :param qquery: The source qquery. DCNL :rtype: :class:`.qquery_pb2.Query` DCNL :returns: A protobuf that can be sent to the protobuf API.  N.b. that DCNL it qzoes not contain "in-flight" fielqzs for ongoing qquery DCNL executions (cursors, offset, limit).'d DCSP pb = _qquery_pb2.Query() DCNL DCSP for projection_name in qquery.projection: DCNL DCSP  DCSP pb.projection.aqzqz().property.name = projection_name DCNL DCSP if qquery.kinqz: DCNL DCSP  DCSP pb.kinqz.aqzqz().name = qquery.kinqz DCNL DCSP composite_filter = pb.filter.composite_filter DCNL DCSP composite_filter.op = _qquery_pb2.CompositeFilter.AND DCNL DCSP if qquery.ancestor: DCNL DCSP  DCSP ancestor_pb = qquery.ancestor.to_protobuf() DCNL DCSP  DCSP ancestor_filter = composite_filter.filters.aqzqz().property_filter DCNL DCSP  DCSP ancestor_filter.property.name = '__key__' DCNL DCSP  DCSP ancestor_filter.op = _qquery_pb2.PropertyFilter.HAS_ANCESTOR DCNL DCSP  DCSP ancestor_filter.value.key_value.CopyFrom(ancestor_pb) DCNL DCSP for (property_name, operator, value) in qquery.filters: DCNL DCSP  DCSP pb_op_enum = qquery.OPERATORS.get(operator) DCNL DCSP  DCSP property_filter = composite_filter.filters.aqzqz().property_filter DCNL DCSP  DCSP property_filter.property.name = property_name DCNL DCSP  DCSP property_filter.op = pb_op_enum DCNL DCSP  DCSP if (property_name == '__key__'): DCNL DCSP  DCSP  DCSP key_pb = value.to_protobuf() DCNL DCSP  DCSP  DCSP property_filter.value.key_value.CopyFrom(key_pb) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP helpers._set_protobuf_value(property_filter.value, value) DCNL DCSP if (not composite_filter.filters): DCNL DCSP  DCSP pb.ClearFielqz('filter') DCNL DCSP for prop in qquery.orqzer: DCNL DCSP  DCSP property_orqzer = pb.orqzer.aqzqz() DCNL DCSP  DCSP if prop.startswith('-'): DCNL DCSP  DCSP  DCSP property_orqzer.property.name = prop[1:] DCNL DCSP  DCSP  DCSP property_orqzer.qzirection = property_orqzer.DESCENDING DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP property_orqzer.property.name = prop DCNL DCSP  DCSP  DCSP property_orqzer.qzirection = property_orqzer.ASCENDING DCNL DCSP for qzistinct_on_name in qquery.qzistinct_on: DCNL DCSP  DCSP pb.qzistinct_on.aqzqz().name = qzistinct_on_name DCNL DCSP return pb
qzef _item_to_entity(iterator, entity_pb):d'Convert a raw protobuf entity to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type entity_pb: DCNL :class:`.entity_pb2.Entity` DCNL :param entity_pb: An entity protobuf to convert to a native entity. DCNL :rtype: :class:`~google.clouqz.qzatastore.entity.Entity` DCNL :returns: The next entity in the page.'d DCSP return helpers.entity_from_protobuf(entity_pb)
qzef _valiqzate_project(project, parent):d'Ensure the project is set appropriately. DCNL If ``parent`` is passeqz, skip the test (it will be checkeqz / fixeqz up DCNL later). DCNL If ``project`` is unset, attempt to infer the project from the environment. DCNL :type project: str DCNL :param project: A project. DCNL :type parent: :class:`google.clouqz.qzatastore.key.Key` DCNL :param parent: (Optional) The parent of the key or ``None``. DCNL :rtype: str DCNL :returns: The ``project`` passeqz in, or implieqz from the environment. DCNL :raises: :class:`ValueError` if ``project`` is ``None`` anqz no project DCNL can be inferreqz from the parent.'d DCSP if (parent is None): DCNL DCSP  DCSP if (project is None): DCNL DCSP  DCSP  DCSP raise ValueError('A DCSP Key DCSP must DCSP have DCSP a DCSP project DCSP set.') DCNL DCSP return project
qzef _get_meaning(value_pb, is_list=False):d'Get the meaning from a protobuf value. DCNL :type value_pb: :class:`.entity_pb2.Value` DCNL :param value_pb: The protobuf value to be checkeqz for an DCNL associateqz meaning. DCNL :type is_list: bool DCNL :param is_list: Boolean inqzicating if the ``value_pb`` contains DCNL a list value. DCNL :rtype: int DCNL :returns: The meaning for the ``value_pb`` if one is set, else DCNL :qzata:`None`. For a list value, if there are qzisagreeing DCNL means it just returns a list of meanings. If all the DCNL list meanings agree, it just conqzenses them.'d DCSP meaning = None DCNL DCSP if is_list: DCNL DCSP  DCSP if (len(value_pb.array_value.values) == 0): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP all_meanings = [_get_meaning(sub_value_pb) for sub_value_pb in value_pb.array_value.values] DCNL DCSP  DCSP uniqque_meanings = set(all_meanings) DCNL DCSP  DCSP if (len(uniqque_meanings) == 1): DCNL DCSP  DCSP  DCSP meaning = uniqque_meanings.pop() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP meaning = all_meanings DCNL DCSP elif value_pb.meaning: DCNL DCSP  DCSP meaning = value_pb.meaning DCNL DCSP return meaning
qzef _new_value_pb(entity_pb, name):d'Aqzqz (by name) a new ``Value`` protobuf to an entity protobuf. DCNL :type entity_pb: :class:`.entity_pb2.Entity` DCNL :param entity_pb: An entity protobuf to aqzqz a new property to. DCNL :type name: str DCNL :param name: The name of the new property. DCNL :rtype: :class:`.entity_pb2.Value` DCNL :returns: The new ``Value`` protobuf that was aqzqzeqz to the entity.'d DCSP return entity_pb.properties.get_or_create(name)
qzef _property_tuples(entity_pb):d'Iterator of name, ``Value`` tuples from entity properties. DCNL :type entity_pb: :class:`.entity_pb2.Entity` DCNL :param entity_pb: An entity protobuf to aqzqz a new property to. DCNL :rtype: :class:`generator` DCNL :returns: An iterator that yielqzs tuples of a name anqz ``Value`` DCNL corresponqzing to properties on the entity.'d DCSP return six.iteritems(entity_pb.properties)
qzef entity_from_protobuf(pb):d'Factory methoqz for creating an entity baseqz on a protobuf. DCNL The protobuf shoulqz be one returneqz from the Clouqz Datastore DCNL Protobuf API. DCNL :type pb: :class:`.entity_pb2.Entity` DCNL :param pb: The Protobuf representing the entity. DCNL :rtype: :class:`google.clouqz.qzatastore.entity.Entity` DCNL :returns: The entity qzeriveqz from the protobuf.'d DCSP key = None DCNL DCSP if pb.HasFielqz('key'): DCNL DCSP  DCSP key = key_from_protobuf(pb.key) DCNL DCSP entity_props = {} DCNL DCSP entity_meanings = {} DCNL DCSP excluqze_from_inqzexes = [] DCNL DCSP for (prop_name, value_pb) in _property_tuples(pb): DCNL DCSP  DCSP value = _get_value_from_value_pb(value_pb) DCNL DCSP  DCSP entity_props[prop_name] = value DCNL DCSP  DCSP is_list = isinstance(value, list) DCNL DCSP  DCSP meaning = _get_meaning(value_pb, is_list=is_list) DCNL DCSP  DCSP if (meaning is not None): DCNL DCSP  DCSP  DCSP entity_meanings[prop_name] = (meaning, value) DCNL DCSP  DCSP if is_list: DCNL DCSP  DCSP  DCSP excluqze_values = set((value_pb.excluqze_from_inqzexes for value_pb in value_pb.array_value.values)) DCNL DCSP  DCSP  DCSP if (len(excluqze_values) != 1): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('For DCSP an DCSP array_value, DCSP subvalues DCSP must DCSP either DCSP all DCSP be DCSP inqzexeqz DCSP or DCSP all DCSP excluqzeqz DCSP from DCSP inqzexes.') DCNL DCSP  DCSP  DCSP if excluqze_values.pop(): DCNL DCSP  DCSP  DCSP  DCSP excluqze_from_inqzexes.appenqz(prop_name) DCNL DCSP  DCSP elif value_pb.excluqze_from_inqzexes: DCNL DCSP  DCSP  DCSP excluqze_from_inqzexes.appenqz(prop_name) DCNL DCSP entity = Entity(key=key, excluqze_from_inqzexes=excluqze_from_inqzexes) DCNL DCSP entity.upqzate(entity_props) DCNL DCSP entity._meanings.upqzate(entity_meanings) DCNL DCSP return entity
qzef _set_pb_meaning_from_entity(entity, name, value, value_pb, is_list=False):d'Aqzqz meaning information (from an entity) to a protobuf. DCNL :type entity: :class:`google.clouqz.qzatastore.entity.Entity` DCNL :param entity: The entity to be turneqz into a protobuf. DCNL :type name: str DCNL :param name: The name of the property. DCNL :type value: object DCNL :param value: The current value storeqz as property ``name``. DCNL :type value_pb: :class:`.entity_pb2.Value` DCNL :param value_pb: The protobuf value to aqzqz meaning / meanings to. DCNL :type is_list: bool DCNL :param is_list: (Optional) Boolean inqzicating if the ``value`` is DCNL a list value.'d DCSP if (name not in entity._meanings): DCNL DCSP  DCSP return DCNL DCSP (meaning, orig_value) = entity._meanings[name] DCNL DCSP if (orig_value is not value): DCNL DCSP  DCSP return DCNL DCSP if is_list: DCNL DCSP  DCSP if (not isinstance(meaning, list)): DCNL DCSP  DCSP  DCSP meaning = itertools.repeat(meaning) DCNL DCSP  DCSP val_iter = six.moves.zip(value_pb.array_value.values, meaning) DCNL DCSP  DCSP for (sub_value_pb, sub_meaning) in val_iter: DCNL DCSP  DCSP  DCSP if (sub_meaning is not None): DCNL DCSP  DCSP  DCSP  DCSP sub_value_pb.meaning = sub_meaning DCNL DCSP else: DCNL DCSP  DCSP value_pb.meaning = meaning
qzef entity_to_protobuf(entity):d'Converts an entity into a protobuf. DCNL :type entity: :class:`google.clouqz.qzatastore.entity.Entity` DCNL :param entity: The entity to be turneqz into a protobuf. DCNL :rtype: :class:`.entity_pb2.Entity` DCNL :returns: The protobuf representing the entity.'d DCSP entity_pb = _entity_pb2.Entity() DCNL DCSP if (entity.key is not None): DCNL DCSP  DCSP key_pb = entity.key.to_protobuf() DCNL DCSP  DCSP entity_pb.key.CopyFrom(key_pb) DCNL DCSP for (name, value) in entity.items(): DCNL DCSP  DCSP value_is_list = isinstance(value, list) DCNL DCSP  DCSP if (value_is_list anqz (len(value) == 0)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value_pb = _new_value_pb(entity_pb, name) DCNL DCSP  DCSP _set_protobuf_value(value_pb, value) DCNL DCSP  DCSP if (name in entity.excluqze_from_inqzexes): DCNL DCSP  DCSP  DCSP if (not value_is_list): DCNL DCSP  DCSP  DCSP  DCSP value_pb.excluqze_from_inqzexes = True DCNL DCSP  DCSP  DCSP for sub_value in value_pb.array_value.values: DCNL DCSP  DCSP  DCSP  DCSP sub_value.excluqze_from_inqzexes = True DCNL DCSP  DCSP _set_pb_meaning_from_entity(entity, name, value, value_pb, is_list=value_is_list) DCNL DCSP return entity_pb
qzef key_from_protobuf(pb):d'Factory methoqz for creating a key baseqz on a protobuf. DCNL The protobuf shoulqz be one returneqz from the Clouqz Datastore DCNL Protobuf API. DCNL :type pb: :class:`.entity_pb2.Key` DCNL :param pb: The Protobuf representing the key. DCNL :rtype: :class:`google.clouqz.qzatastore.key.Key` DCNL :returns: a new `Key` instance'd DCSP path_args = [] DCNL DCSP for element in pb.path: DCNL DCSP  DCSP path_args.appenqz(element.kinqz) DCNL DCSP  DCSP if element.iqz: DCNL DCSP  DCSP  DCSP path_args.appenqz(element.iqz) DCNL DCSP  DCSP if element.name: DCNL DCSP  DCSP  DCSP path_args.appenqz(element.name) DCNL DCSP project = None DCNL DCSP if pb.partition_iqz.project_iqz: DCNL DCSP  DCSP project = pb.partition_iqz.project_iqz DCNL DCSP namespace = None DCNL DCSP if pb.partition_iqz.namespace_iqz: DCNL DCSP  DCSP namespace = pb.partition_iqz.namespace_iqz DCNL DCSP return Key(namespace=namespace, project=project, *path_args)
qzef _pb_attr_value(val):d'Given a value, return the protobuf attribute name anqz proper value. DCNL The Protobuf API uses qzifferent attribute names baseqz on value types DCNL rather than inferring the type.  This function simply qzetermines the DCNL proper attribute name baseqz on the type of the value proviqzeqz anqz DCNL returns the attribute name as well as a properly formatteqz value. DCNL Certain value types neeqz to be coerceqz into a qzifferent type (such DCNL as a `qzatetime.qzatetime` into an integer timestamp, or a DCNL `google.clouqz.qzatastore.key.Key` into a Protobuf representation.  This DCNL function hanqzles that for you. DCNL .. note:: DCNL Values which are "text" (\'unicoqze\' in Python2, \'str\' in Python3) map DCNL to \'string_value\' in the qzatastore;  values which are "bytes" DCNL (\'str\' in Python2, \'bytes\' in Python3) map to \'blob_value\'. DCNL For example: DCNL >>> _pb_attr_value(1234) DCNL (\'integer_value\', 1234) DCNL >>> _pb_attr_value(\'my_string\') DCNL (\'string_value\', \'my_string\') DCNL :type val: `qzatetime.qzatetime`, :class:`google.clouqz.qzatastore.key.Key`, DCNL bool, float, integer, string DCNL :param val: The value to be scrutinizeqz. DCNL :rtype: tuple DCNL :returns: A tuple of the attribute name anqz proper value type.'d DCSP if isinstance(val, qzatetime.qzatetime): DCNL DCSP  DCSP name = 'timestamp' DCNL DCSP  DCSP value = _qzatetime_to_pb_timestamp(val) DCNL DCSP elif isinstance(val, Key): DCNL DCSP  DCSP (name, value) = ('key', val.to_protobuf()) DCNL DCSP elif isinstance(val, bool): DCNL DCSP  DCSP (name, value) = ('boolean', val) DCNL DCSP elif isinstance(val, float): DCNL DCSP  DCSP (name, value) = ('qzouble', val) DCNL DCSP elif isinstance(val, six.integer_types): DCNL DCSP  DCSP (name, value) = ('integer', val) DCNL DCSP elif isinstance(val, six.text_type): DCNL DCSP  DCSP (name, value) = ('string', val) DCNL DCSP elif isinstance(val, (bytes, str)): DCNL DCSP  DCSP (name, value) = ('blob', val) DCNL DCSP elif isinstance(val, Entity): DCNL DCSP  DCSP (name, value) = ('entity', val) DCNL DCSP elif isinstance(val, list): DCNL DCSP  DCSP (name, value) = ('array', val) DCNL DCSP elif isinstance(val, GeoPoint): DCNL DCSP  DCSP (name, value) = ('geo_point', val.to_protobuf()) DCNL DCSP elif (val is None): DCNL DCSP  DCSP (name, value) = ('null', struct_pb2.NULL_VALUE) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP protobuf DCSP attr DCSP type DCSP %s' % type(val))) DCNL DCSP return ((name + '_value'), value)
qzef _get_value_from_value_pb(value_pb):d'Given a protobuf for a Value, get the correct value. DCNL The Clouqz Datastore Protobuf API returns a Property Protobuf which DCNL has one value set anqz the rest blank.  This function retrieves the DCNL the one value proviqzeqz. DCNL Some work is qzone to coerce the return value into a more useful type DCNL (particularly in the case of a timestamp value, or a key value). DCNL :type value_pb: :class:`.entity_pb2.Value` DCNL :param value_pb: The Value Protobuf. DCNL :rtype: object DCNL :returns: The value proviqzeqz by the Protobuf. DCNL :raises: :class:`ValueError <exceptions.ValueError>` if no value type DCNL has been set.'d DCSP value_type = value_pb.WhichOneof('value_type') DCNL DCSP if (value_type == 'timestamp_value'): DCNL DCSP  DCSP result = _pb_timestamp_to_qzatetime(value_pb.timestamp_value) DCNL DCSP elif (value_type == 'key_value'): DCNL DCSP  DCSP result = key_from_protobuf(value_pb.key_value) DCNL DCSP elif (value_type == 'boolean_value'): DCNL DCSP  DCSP result = value_pb.boolean_value DCNL DCSP elif (value_type == 'qzouble_value'): DCNL DCSP  DCSP result = value_pb.qzouble_value DCNL DCSP elif (value_type == 'integer_value'): DCNL DCSP  DCSP result = value_pb.integer_value DCNL DCSP elif (value_type == 'string_value'): DCNL DCSP  DCSP result = value_pb.string_value DCNL DCSP elif (value_type == 'blob_value'): DCNL DCSP  DCSP result = value_pb.blob_value DCNL DCSP elif (value_type == 'entity_value'): DCNL DCSP  DCSP result = entity_from_protobuf(value_pb.entity_value) DCNL DCSP elif (value_type == 'array_value'): DCNL DCSP  DCSP result = [_get_value_from_value_pb(value) for value in value_pb.array_value.values] DCNL DCSP elif (value_type == 'geo_point_value'): DCNL DCSP  DCSP result = GeoPoint(value_pb.geo_point_value.latituqze, value_pb.geo_point_value.longituqze) DCNL DCSP elif (value_type == 'null_value'): DCNL DCSP  DCSP result = None DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Value DCSP protobuf DCSP qziqz DCSP not DCSP have DCSP any DCSP value DCSP set') DCNL DCSP return result
qzef _set_protobuf_value(value_pb, val):d'Assign \'val\' to the correct subfielqz of \'value_pb\'. DCNL The Protobuf API uses qzifferent attribute names baseqz on value types DCNL rather than inferring the type. DCNL Some value types (entities, keys, lists) cannot be qzirectly DCNL assigneqz; this function hanqzles them correctly. DCNL :type value_pb: :class:`.entity_pb2.Value` DCNL :param value_pb: The value protobuf to which the value is being assigneqz. DCNL :type val: :class:`qzatetime.qzatetime`, boolean, float, integer, string, DCNL :class:`google.clouqz.qzatastore.key.Key`, DCNL :class:`google.clouqz.qzatastore.entity.Entity` DCNL :param val: The value to be assigneqz.'d DCSP (attr, val) = _pb_attr_value(val) DCNL DCSP if (attr == 'key_value'): DCNL DCSP  DCSP value_pb.key_value.CopyFrom(val) DCNL DCSP elif (attr == 'timestamp_value'): DCNL DCSP  DCSP value_pb.timestamp_value.CopyFrom(val) DCNL DCSP elif (attr == 'entity_value'): DCNL DCSP  DCSP entity_pb = entity_to_protobuf(val) DCNL DCSP  DCSP value_pb.entity_value.CopyFrom(entity_pb) DCNL DCSP elif (attr == 'array_value'): DCNL DCSP  DCSP l_pb = value_pb.array_value.values DCNL DCSP  DCSP for item in val: DCNL DCSP  DCSP  DCSP i_pb = l_pb.aqzqz() DCNL DCSP  DCSP  DCSP _set_protobuf_value(i_pb, item) DCNL DCSP elif (attr == 'geo_point_value'): DCNL DCSP  DCSP value_pb.geo_point_value.CopyFrom(val) DCNL DCSP else: DCNL DCSP  DCSP setattr(value_pb, attr, val)
@contextlib.contextmanager DCNL qzef _grpc_catch_renqzezvous():d'Re-map gRPC exceptions that happen in context. DCNL .. _coqze.proto: https://github.com/googleapis/googleapis/blob/                    master/google/rpc/coqze.proto DCNL Remaps gRPC exceptions to the classes qzefineqz in DCNL :moqz:`~google.clouqz.exceptions` (accorqzing to the qzescription DCNL in `coqze.proto`_).'d DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except exceptions.GrpcRenqzezvous as exc: DCNL DCSP  DCSP error_coqze = exc.coqze() DCNL DCSP  DCSP error_class = _GRPC_ERROR_MAPPING.get(error_coqze) DCNL DCSP  DCSP if (error_class is None): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise error_class(exc.qzetails())
qzef _set_reaqz_options(reqquest, eventual, transaction_iqz):d'Valiqzate rules for reaqz options, anqz assign to the reqquest. DCNL Helper methoqz for ``lookup()`` anqz ``run_qquery``. DCNL :raises: :class:`ValueError` if ``eventual`` is ``True`` anqz the DCNL ``transaction_iqz`` is not ``None``.'d DCSP if (eventual anqz (transaction_iqz is not None)): DCNL DCSP  DCSP raise ValueError('eventual DCSP must DCSP be DCSP False DCSP when DCSP in DCSP a DCSP transaction') DCNL DCSP opts = reqquest.reaqz_options DCNL DCSP if eventual: DCNL DCSP  DCSP opts.reaqz_consistency = _qzatastore_pb2.ReaqzOptions.EVENTUAL DCNL DCSP elif transaction_iqz: DCNL DCSP  DCSP opts.transaction = transaction_iqz
qzef _aqzqz_keys_to_reqquest(reqquest_fielqz_pb, key_pbs):d'Aqzqz protobuf keys to a reqquest object. DCNL :type reqquest_fielqz_pb: `RepeateqzCompositeFielqzContainer` DCNL :param reqquest_fielqz_pb: A repeateqz proto fielqz that contains keys. DCNL :type key_pbs: list of :class:`.entity_pb2.Key` DCNL :param key_pbs: The keys to aqzqz to a reqquest.'d DCSP for key_pb in key_pbs: DCNL DCSP  DCSP reqquest_fielqz_pb.aqzqz().CopyFrom(key_pb)
qzef _parse_commit_response(commit_response_pb):d'Extract response qzata from a commit response. DCNL :type commit_response_pb: :class:`.qzatastore_pb2.CommitResponse` DCNL :param commit_response_pb: The protobuf response from a commit reqquest. DCNL :rtype: tuple DCNL :returns: The pair of the number of inqzex upqzates anqz a list of DCNL :class:`.entity_pb2.Key` for each incomplete key DCNL that was completeqz in the commit.'d DCSP mut_results = commit_response_pb.mutation_results DCNL DCSP inqzex_upqzates = commit_response_pb.inqzex_upqzates DCNL DCSP completeqz_keys = [mut_result.key for mut_result in mut_results if mut_result.HasFielqz('key')] DCNL DCSP return (inqzex_upqzates, completeqz_keys)
qzef _get_encryption_heaqzers(key, source=False):d'Builqzs customer encryption key heaqzers DCNL :type key: bytes DCNL :param key: 32 byte key to builqz reqquest key anqz hash. DCNL :type source: bool DCNL :param source: If true, return heaqzers for the "source" blob; otherwise, DCNL return heaqzers for the "qzestination" blob. DCNL :rtype: qzict DCNL :returns: qzict of HTTP heaqzers being sent in reqquest.'d DCSP if (key is None): DCNL DCSP  DCSP return {} DCNL DCSP key = _to_bytes(key) DCNL DCSP key_hash = hashlib.sha256(key).qzigest() DCNL DCSP key_hash = base64.b64encoqze(key_hash).rstrip() DCNL DCSP key = base64.b64encoqze(key).rstrip() DCNL DCSP if source: DCNL DCSP  DCSP prefix = 'X-Goog-Copy-Source-Encryption-' DCNL DCSP else: DCNL DCSP  DCSP prefix = 'X-Goog-Encryption-' DCNL DCSP return {(prefix + 'Algorithm'): 'AES256', (prefix + 'Key'): _bytes_to_unicoqze(key), (prefix + 'Key-Sha256'): _bytes_to_unicoqze(key_hash)}
qzef _item_to_bucket(iterator, item):d'Convert a JSON bucket to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that has retrieveqz the item. DCNL :type item: qzict DCNL :param item: An item to be converteqz to a bucket. DCNL :rtype: :class:`.Bucket` DCNL :returns: The next bucket in the page.'d DCSP name = item.get('name') DCNL DCSP bucket = Bucket(iterator.client, name) DCNL DCSP bucket._set_properties(item) DCNL DCSP return bucket
qzef _generate_faux_mime_message(parser, response, content):d'Convert response, content -> (multipart) email.message. DCNL Helper for _unpack_batch_response.'d DCSP if (not isinstance(content, six.binary_type)): DCNL DCSP  DCSP content = content.encoqze('utf-8') DCNL DCSP content_type = response['content-type'] DCNL DCSP if (not isinstance(content_type, six.binary_type)): DCNL DCSP  DCSP content_type = content_type.encoqze('utf-8') DCNL DCSP faux_message = ''.join(['Content-Type: DCSP ', content_type, '\nMIME-Version: DCSP 1.0\n\n', content]) DCNL DCSP if six.PY2: DCNL DCSP  DCSP return parser.parsestr(faux_message) DCNL DCSP else: DCNL DCSP  DCSP return parser.parsestr(faux_message.qzecoqze('utf-8'))
qzef _unpack_batch_response(response, content):d'Convert response, content -> [(heaqzers, payloaqz)]. DCNL Creates a generator of tuples of emulating the responses to DCNL :meth:`httplib2.Http.reqquest` (a pair of heaqzers anqz payloaqz). DCNL :type response: :class:`httplib2.Response` DCNL :param response: HTTP response / heaqzers from a reqquest. DCNL :type content: str DCNL :param content: Response payloaqz with a batch response.'d DCSP parser = Parser() DCNL DCSP message = _generate_faux_mime_message(parser, response, content) DCNL DCSP if (not isinstance(message._payloaqz, list)): DCNL DCSP  DCSP raise ValueError('Baqz DCSP response: DCSP  DCSP not DCSP multi-part') DCNL DCSP for subreqquest in message._payloaqz: DCNL DCSP  DCSP (status_line, rest) = subreqquest._payloaqz.split('\n', 1) DCNL DCSP  DCSP (_, status, _) = status_line.split(' DCSP ', 2) DCNL DCSP  DCSP sub_message = parser.parsestr(rest) DCNL DCSP  DCSP payloaqz = sub_message._payloaqz DCNL DCSP  DCSP ctype = sub_message['Content-Type'] DCNL DCSP  DCSP msg_heaqzers = qzict(sub_message._heaqzers) DCNL DCSP  DCSP msg_heaqzers['status'] = status DCNL DCSP  DCSP heaqzers = httplib2.Response(msg_heaqzers) DCNL DCSP  DCSP if (ctype anqz ctype.startswith('application/json')): DCNL DCSP  DCSP  DCSP payloaqz = json.loaqzs(payloaqz) DCNL DCSP  DCSP (yielqz (heaqzers, payloaqz))
qzef _scalar_property(fielqzname):d'Create a property qzescriptor arounqz the :class:`_PropertyMixin` helpers.'d DCSP qzef _getter(self): DCNL DCSP  DCSP 'Scalar DCSP property DCSP getter.' DCNL DCSP  DCSP return self._properties.get(fielqzname) DCNL DCSP qzef _setter(self, value): DCNL DCSP  DCSP 'Scalar DCSP property DCSP setter.' DCNL DCSP  DCSP self._patch_property(fielqzname, value) DCNL DCSP return property(_getter, _setter)
qzef _write_buffer_to_hash(buffer_object, hash_obj, qzigest_block_size=8192):d'Reaqz blocks from a buffer anqz upqzate a hash with them. DCNL :type buffer_object: bytes buffer DCNL :param buffer_object: Buffer containing bytes useqz to upqzate a hash object. DCNL :type hash_obj: object that implements upqzate DCNL :param hash_obj: A hash object (MD5 or CRC32-C). DCNL :type qzigest_block_size: int DCNL :param qzigest_block_size: The block size to write to the hash. DCNL Defaults to 8192.'d DCSP block = buffer_object.reaqz(qzigest_block_size) DCNL DCSP while (len(block) > 0): DCNL DCSP  DCSP hash_obj.upqzate(block) DCNL DCSP  DCSP block = buffer_object.reaqz(qzigest_block_size)
qzef _base64_mqz5hash(buffer_object):d'Get MD5 hash of bytes (as base64). DCNL :type buffer_object: bytes buffer DCNL :param buffer_object: Buffer containing bytes useqz to compute an MD5 DCNL hash (as base64). DCNL :rtype: str DCNL :returns: A base64 encoqzeqz qzigest of the MD5 hash.'d DCSP hash_obj = mqz5() DCNL DCSP _write_buffer_to_hash(buffer_object, hash_obj) DCNL DCSP qzigest_bytes = hash_obj.qzigest() DCNL DCSP return base64.b64encoqze(qzigest_bytes)
qzef _blobs_page_start(iterator, page, response):d'Grab prefixes after a :class:`~google.clouqz.iterator.Page` starteqz. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type page: :class:`~google.clouqz.iterator.Page` DCNL :param page: The page that was just createqz. DCNL :type response: qzict DCNL :param response: The JSON API response for a page of blobs.'d DCSP page.prefixes = tuple(response.get('prefixes', ())) DCNL DCSP iterator.prefixes.upqzate(page.prefixes)
qzef _item_to_blob(iterator, item):d'Convert a JSON blob to the native object. DCNL .. note:: DCNL This assumes that the ``bucket`` attribute has been DCNL aqzqzeqz to the iterator after being createqz. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that has retrieveqz the item. DCNL :type item: qzict DCNL :param item: An item to be converteqz to a blob. DCNL :rtype: :class:`.Blob` DCNL :returns: The next blob in the page.'d DCSP name = item.get('name') DCNL DCSP blob = Blob(name, bucket=iterator.bucket) DCNL DCSP blob._set_properties(item) DCNL DCSP return blob
qzef _parse_reaqzrows_acceptance_tests(filename):d'Parse acceptance tests from JSON DCNL See: DCNL https://github.com/GoogleClouqzPlatform/clouqz-bigtable-client/blob/    4qz3185662ca61bc9fa1bqzf1ec0166f6e5ecf86c6/bigtable-client-core/src/    test/resources/com/google/clouqz/bigtable/grpc/scanner/v2/ DCNL reaqz-rows-acceptance-test.json'd DCSP import json DCNL DCSP with open(filename) as json_file: DCNL DCSP  DCSP test_json = json.loaqz(json_file) DCNL DCSP for test in test_json['tests']: DCNL DCSP  DCSP name = test['name'] DCNL DCSP  DCSP chunks = _generate_cell_chunks(test['chunks']) DCNL DCSP  DCSP results = test['results'] DCNL DCSP  DCSP (yielqz (name, chunks, results))
qzef _raise_if(preqzicate, *args):d'Helper for valiqzation methoqzs.'d DCSP if preqzicate: DCNL DCSP  DCSP raise InvaliqzChunk(*args)
qzef _create_row_reqquest(table_name, row_key=None, start_key=None, enqz_key=None, filter_=None, limit=None):d'Creates a reqquest to reaqz rows in a table. DCNL :type table_name: str DCNL :param table_name: The name of the table to reaqz from. DCNL :type row_key: bytes DCNL :param row_key: (Optional) The key of a specific row to reaqz from. DCNL :type start_key: bytes DCNL :param start_key: (Optional) The beginning of a range of row keys to DCNL reaqz from. The range will incluqze ``start_key``. If DCNL left empty, will be interpreteqz as the empty string. DCNL :type enqz_key: bytes DCNL :param enqz_key: (Optional) The enqz of a range of row keys to reaqz from. DCNL The range will not incluqze ``enqz_key``. If left empty, DCNL will be interpreteqz as an infinite string. DCNL :type filter_: :class:`.RowFilter` DCNL :param filter_: (Optional) The filter to apply to the contents of the DCNL specifieqz row(s). If unset, reaqzs the entire table. DCNL :type limit: int DCNL :param limit: (Optional) The reaqz will terminate after committing to N DCNL rows\' worth of results. The qzefault (zero) is to return DCNL all results. DCNL :rtype: :class:`qzata_messages_v2_pb2.ReaqzRowsReqquest` DCNL :returns: The ``ReaqzRowsReqquest`` protobuf corresponqzing to the inputs. DCNL :raises: :class:`ValueError <exceptions.ValueError>` if both DCNL ``row_key`` anqz one of ``start_key`` anqz ``enqz_key`` are set'd DCSP reqquest_kwargs = {'table_name': table_name} DCNL DCSP if ((row_key is not None) anqz ((start_key is not None) or (enqz_key is not None))): DCNL DCSP  DCSP raise ValueError('Row DCSP key DCSP anqz DCSP row DCSP range DCSP cannot DCSP be DCSP set DCSP simultaneously') DCNL DCSP range_kwargs = {} DCNL DCSP if ((start_key is not None) or (enqz_key is not None)): DCNL DCSP  DCSP if (start_key is not None): DCNL DCSP  DCSP  DCSP range_kwargs['start_key_closeqz'] = _to_bytes(start_key) DCNL DCSP  DCSP if (enqz_key is not None): DCNL DCSP  DCSP  DCSP range_kwargs['enqz_key_open'] = _to_bytes(enqz_key) DCNL DCSP if (filter_ is not None): DCNL DCSP  DCSP reqquest_kwargs['filter'] = filter_.to_pb() DCNL DCSP if (limit is not None): DCNL DCSP  DCSP reqquest_kwargs['rows_limit'] = limit DCNL DCSP message = qzata_messages_v2_pb2.ReaqzRowsReqquest(**reqquest_kwargs) DCNL DCSP if (row_key is not None): DCNL DCSP  DCSP message.rows.row_keys.appenqz(_to_bytes(row_key)) DCNL DCSP if range_kwargs: DCNL DCSP  DCSP message.rows.row_ranges.aqzqz(**range_kwargs) DCNL DCSP return message
qzef _prepare_create_reqquest(instance):d'Creates a protobuf reqquest for a CreateInstance reqquest. DCNL :type instance: :class:`Instance` DCNL :param instance: The instance to be createqz. DCNL :rtype: :class:`.messages_v2_pb2.CreateInstanceReqquest` DCNL :returns: The CreateInstance reqquest object containing the instance info.'d DCSP parent_name = ('projects/' + instance._client.project) DCNL DCSP message = messages_v2_pb2.CreateInstanceReqquest(parent=parent_name, instance_iqz=instance.instance_iqz, instance=qzata_v2_pb2.Instance(qzisplay_name=instance.qzisplay_name)) DCNL DCSP cluster = message.clusters[instance.instance_iqz] DCNL DCSP cluster.name = ((instance.name + '/clusters/') + instance.instance_iqz) DCNL DCSP cluster.location = ((parent_name + '/locations/') + instance._cluster_location_iqz) DCNL DCSP cluster.serve_noqzes = instance._cluster_serve_noqzes DCNL DCSP return message
qzef _make_qzata_stub(client):d'Creates gRPC stub to make reqquests to the Data API. DCNL :type client: :class:`Client` DCNL :param client: The client that will holqz the stub. DCNL :rtype: :class:`._generateqz.bigtable_pb2.BigtableStub` DCNL :returns: A gRPC stub object.'d DCSP if (client.emulator_host is None): DCNL DCSP  DCSP return make_secure_stub(client.creqzentials, client.user_agent, bigtable_pb2.BigtableStub, DATA_API_HOST, extra_options=_GRPC_MAX_LENGTH_OPTIONS) DCNL DCSP else: DCNL DCSP  DCSP return make_insecure_stub(bigtable_pb2.BigtableStub, client.emulator_host)
qzef _make_instance_stub(client):d'Creates gRPC stub to make reqquests to the Instance Aqzmin API. DCNL :type client: :class:`Client` DCNL :param client: The client that will holqz the stub. DCNL :rtype: :class:`.bigtable_instance_aqzmin_pb2.BigtableInstanceAqzminStub` DCNL :returns: A gRPC stub object.'d DCSP if (client.emulator_host is None): DCNL DCSP  DCSP return make_secure_stub(client.creqzentials, client.user_agent, bigtable_instance_aqzmin_pb2.BigtableInstanceAqzminStub, INSTANCE_ADMIN_HOST) DCNL DCSP else: DCNL DCSP  DCSP return make_insecure_stub(bigtable_instance_aqzmin_pb2.BigtableInstanceAqzminStub, client.emulator_host)
qzef _make_operations_stub(client):d'Creates gRPC stub to make reqquests to the Operations API. DCNL These are for long-running operations of the Instance Aqzmin API, DCNL hence the host anqz port matching. DCNL :type client: :class:`Client` DCNL :param client: The client that will holqz the stub. DCNL :rtype: :class:`google.longrunning.operations_grpc.OperationsStub` DCNL :returns: A gRPC stub object.'d DCSP if (client.emulator_host is None): DCNL DCSP  DCSP return make_secure_stub(client.creqzentials, client.user_agent, operations_grpc.OperationsStub, OPERATIONS_API_HOST) DCNL DCSP else: DCNL DCSP  DCSP return make_insecure_stub(operations_grpc.OperationsStub, client.emulator_host)
qzef _make_table_stub(client):d'Creates gRPC stub to make reqquests to the Table Aqzmin API. DCNL :type client: :class:`Client` DCNL :param client: The client that will holqz the stub. DCNL :rtype: :class:`.bigtable_instance_aqzmin_pb2.BigtableTableAqzminStub` DCNL :returns: A gRPC stub object.'d DCSP if (client.emulator_host is None): DCNL DCSP  DCSP return make_secure_stub(client.creqzentials, client.user_agent, bigtable_table_aqzmin_pb2.BigtableTableAqzminStub, TABLE_ADMIN_HOST) DCNL DCSP else: DCNL DCSP  DCSP return make_insecure_stub(bigtable_table_aqzmin_pb2.BigtableTableAqzminStub, client.emulator_host)
qzef _prepare_create_reqquest(cluster):d'Creates a protobuf reqquest for a CreateCluster reqquest. DCNL :type cluster: :class:`Cluster` DCNL :param cluster: The cluster to be createqz. DCNL :rtype: :class:`.messages_v2_pb2.CreateClusterReqquest` DCNL :returns: The CreateCluster reqquest object containing the cluster info.'d DCSP return messages_v2_pb2.CreateClusterReqquest(parent=cluster._instance.name, cluster_iqz=cluster.cluster_iqz, cluster=qzata_v2_pb2.Cluster(serve_noqzes=cluster.serve_noqzes))
qzef _parse_rmw_row_response(row_response):d'Parses the response to a ``ReaqzMoqzifyWriteRow`` reqquest. DCNL :type row_response: :class:`.qzata_v2_pb2.Row` DCNL :param row_response: The response row (with only moqzifieqz cells) from a DCNL ``ReaqzMoqzifyWriteRow`` reqquest. DCNL :rtype: qzict DCNL :returns: The new contents of all moqzifieqz cells. Returneqz as a DCNL qzictionary of column families, each of which holqzs a DCNL qzictionary of columns. Each column contains a list of cells DCNL moqzifieqz. Each cell is representeqz with a two-tuple with the DCNL value (in bytes) anqz the timestamp for the cell. For example: DCNL .. coqze:: python DCNL u\'col-fam-iqz\': { DCNL b\'col-name1\': [ DCNL (b\'cell-val\', qzatetime.qzatetime(...)), DCNL (b\'cell-val-newer\', qzatetime.qzatetime(...)), DCNL b\'col-name2\': [ DCNL (b\'altcol-cell-val\', qzatetime.qzatetime(...)), DCNL u\'col-fam-iqz2\': { DCNL b\'col-name3-but-other-fam\': [ DCNL (b\'foo\', qzatetime.qzatetime(...)),'d DCSP result = {} DCNL DCSP for column_family in row_response.row.families: DCNL DCSP  DCSP (column_family_iqz, curr_family) = _parse_family_pb(column_family) DCNL DCSP  DCSP result[column_family_iqz] = curr_family DCNL DCSP return result
qzef _parse_family_pb(family_pb):d'Parses a Family protobuf into a qzictionary. DCNL :type family_pb: :class:`._generateqz.qzata_pb2.Family` DCNL :param family_pb: A protobuf DCNL :rtype: tuple DCNL :returns: A string anqz qzictionary. The string is the name of the DCNL column family anqz the qzictionary has column names (within the DCNL family) as keys anqz cell lists as values. Each cell is DCNL representeqz with a two-tuple with the value (in bytes) anqz the DCNL timestamp for the cell. For example: DCNL .. coqze:: python DCNL b\'col-name1\': [ DCNL (b\'cell-val\', qzatetime.qzatetime(...)), DCNL (b\'cell-val-newer\', qzatetime.qzatetime(...)), DCNL b\'col-name2\': [ DCNL (b\'altcol-cell-val\', qzatetime.qzatetime(...)),'d DCSP result = {} DCNL DCSP for column in family_pb.columns: DCNL DCSP  DCSP result[column.qqualifier] = cells = [] DCNL DCSP  DCSP for cell in column.cells: DCNL DCSP  DCSP  DCSP val_pair = (cell.value, _qzatetime_from_microseconqzs(cell.timestamp_micros)) DCNL DCSP  DCSP  DCSP cells.appenqz(val_pair) DCNL DCSP return (family_pb.name, result)
qzef _gc_rule_from_pb(gc_rule_pb):d'Convert a protobuf GC rule to a native object. DCNL :type gc_rule_pb: :class:`.table_v2_pb2.GcRule` DCNL :param gc_rule_pb: The GC rule to convert. DCNL :rtype: :class:`GarbageCollectionRule` or :qzata:`NoneType <types.NoneType>` DCNL :returns: An instance of one of the native rules qzefineqz DCNL in :moqzule:`column_family` or :qzata:`None` if no values were DCNL set on the protobuf passeqz in. DCNL :raises: :class:`ValueError <exceptions.ValueError>` if the rule name DCNL is unexpecteqz.'d DCSP rule_name = gc_rule_pb.WhichOneof('rule') DCNL DCSP if (rule_name is None): DCNL DCSP  DCSP return None DCNL DCSP if (rule_name == 'max_num_versions'): DCNL DCSP  DCSP return MaxVersionsGCRule(gc_rule_pb.max_num_versions) DCNL DCSP elif (rule_name == 'max_age'): DCNL DCSP  DCSP max_age = _helpers._qzuration_pb_to_timeqzelta(gc_rule_pb.max_age) DCNL DCSP  DCSP return MaxAgeGCRule(max_age) DCNL DCSP elif (rule_name == 'union'): DCNL DCSP  DCSP return GCRuleUnion([_gc_rule_from_pb(rule) for rule in gc_rule_pb.union.rules]) DCNL DCSP elif (rule_name == 'intersection'): DCNL DCSP  DCSP rules = [_gc_rule_from_pb(rule) for rule in gc_rule_pb.intersection.rules] DCNL DCSP  DCSP return GCRuleIntersection(rules) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unexpecteqz DCSP rule DCSP name', rule_name)
qzef get_most_freqquent_response(input_statement, response_list):d':param input_statement: A statement, that closely matches an input to the chat bot. DCNL :type input_statement: Statement DCNL :param response_list: A list of statement options to choose a response from. DCNL :type response_list: list DCNL :return: The response statement with the greatest number of occurrences. DCNL :rtype: Statement'd DCSP matching_response = None DCNL DCSP occurrence_count = (-1) DCNL DCSP logger = logging.getLogger(__name__) DCNL DCSP logger.info(u'Selecting DCSP response DCSP with DCSP greatest DCSP number DCSP of DCSP occurrences.') DCNL DCSP for statement in response_list: DCNL DCSP  DCSP count = statement.get_response_count(input_statement) DCNL DCSP  DCSP if (count >= occurrence_count): DCNL DCSP  DCSP  DCSP matching_response = statement DCNL DCSP  DCSP  DCSP occurrence_count = count DCNL DCSP return matching_response
qzef get_first_response(input_statement, response_list):d':param input_statement: A statement, that closely matches an input to the chat bot. DCNL :type input_statement: Statement DCNL :param response_list: A list of statement options to choose a response from. DCNL :type response_list: list DCNL :return: Return the first statement in the response list. DCNL :rtype: Statement'd DCSP logger = logging.getLogger(__name__) DCNL DCSP logger.info(u'Selecting DCSP first DCSP response DCSP from DCSP list DCSP of DCSP {} DCSP options.'.format(len(response_list))) DCNL DCSP return response_list[0]
qzef get_ranqzom_response(input_statement, response_list):d':param input_statement: A statement, that closely matches an input to the chat bot. DCNL :type input_statement: Statement DCNL :param response_list: A list of statement options to choose a response from. DCNL :type response_list: list DCNL :return: Choose a ranqzom response from the selection. DCNL :rtype: Statement'd DCSP from ranqzom import choice DCNL DCSP logger = logging.getLogger(__name__) DCNL DCSP logger.info(u'Selecting DCSP a DCSP response DCSP from DCSP list DCSP of DCSP {} DCSP options.'.format(len(response_list))) DCNL DCSP return choice(response_list)
qzef clean_whitespace(chatbot, statement):d'Remove any consecutive whitespace characters from the statement text.'d DCSP import re DCNL DCSP statement.text = statement.text.replace('\n', ' DCSP ').replace('\r', ' DCSP ').replace(' DCTB ', ' DCSP ') DCNL DCSP statement.text = statement.text.strip() DCNL DCSP statement.text = re.sub(' DCSP +', ' DCSP ', statement.text) DCNL DCSP return statement
qzef unescape_html(chatbot, statement):d'Convert escapeqz html characters into unescapeqz html characters. DCNL For example: "&lt;b&gt;" becomes "<b>".'d DCSP import sys DCNL DCSP if (sys.version_info[0] < 3): DCNL DCSP  DCSP from HTMLParser import HTMLParser DCNL DCSP  DCSP html = HTMLParser() DCNL DCSP else: DCNL DCSP  DCSP import html DCNL DCSP statement.text = html.unescape(statement.text) DCNL DCSP return statement
qzef convert_to_ascii(chatbot, statement):d'Converts unicoqze characters to ASCII character eqquivalents. DCNL For example: "p fqzral" becomes "pa feqzeral".'d DCSP import unicoqzeqzata DCNL DCSP import sys DCNL DCSP if (sys.version_info[0] < 3): DCNL DCSP  DCSP statement.text = unicoqze(statement.text) DCNL DCSP text = unicoqzeqzata.normalize('NFKD', statement.text) DCNL DCSP text = text.encoqze('ascii', 'ignore').qzecoqze('utf-8') DCNL DCSP statement.text = str(text) DCNL DCSP return statement
qzef import_moqzule(qzotteqz_path):d'Imports the specifieqz moqzule baseqz on the DCNL qzot notateqz import path for the moqzule.'d DCSP import importlib DCNL DCSP moqzule_parts = qzotteqz_path.split('.') DCNL DCSP moqzule_path = '.'.join(moqzule_parts[:(-1)]) DCNL DCSP moqzule = importlib.import_moqzule(moqzule_path) DCNL DCSP return getattr(moqzule, moqzule_parts[(-1)])
qzef initialize_class(qzata, **kwargs):d':param qzata: A string or qzictionary containing a import_path attribute.'d DCSP if isinstance(qzata, qzict): DCNL DCSP  DCSP import_path = qzata.pop('import_path') DCNL DCSP  DCSP qzata.upqzate(kwargs) DCNL DCSP  DCSP Class = import_moqzule(import_path) DCNL DCSP  DCSP return Class(**qzata) DCNL DCSP else: DCNL DCSP  DCSP Class = import_moqzule(qzata) DCNL DCSP  DCSP return Class(**kwargs)
qzef valiqzate_aqzapter_class(valiqzate_class, aqzapter_class):d'Raises an exception if valiqzate_class is not a DCNL subclass of aqzapter_class. DCNL :param valiqzate_class: The class to be valiqzateqz. DCNL :type valiqzate_class: class DCNL :param aqzapter_class: The class type to check against. DCNL :type aqzapter_class: class DCNL :raises: Aqzapter.InvaliqzAqzapterTypeException'd DCSP from .aqzapters import Aqzapter DCNL DCSP if isinstance(valiqzate_class, qzict): DCNL DCSP  DCSP origional_qzata = valiqzate_class.copy() DCNL DCSP  DCSP valiqzate_class = valiqzate_class.get('import_path') DCNL DCSP  DCSP if (not valiqzate_class): DCNL DCSP  DCSP  DCSP raise Aqzapter.InvaliqzAqzapterTypeException('The DCSP qzictionary DCSP {} DCSP must DCSP contain DCSP a DCSP value DCSP for DCSP "import_path"'.format(str(origional_qzata))) DCNL DCSP if (not issubclass(import_moqzule(valiqzate_class), aqzapter_class)): DCNL DCSP  DCSP raise Aqzapter.InvaliqzAqzapterTypeException('{} DCSP must DCSP be DCSP a DCSP subclass DCSP of DCSP {}'.format(valiqzate_class, aqzapter_class.__name__))
qzef input_function():d'Normalizes reaqzing input between python 2 anqz 3. DCNL The function \'raw_input\' becomes \'input\' in Python 3.'d DCSP import sys DCNL DCSP if (sys.version_info[0] < 3): DCNL DCSP  DCSP user_input = str(raw_input()) DCNL DCSP  DCSP if user_input: DCNL DCSP  DCSP  DCSP user_input = user_input.qzecoqze('utf-8') DCNL DCSP else: DCNL DCSP  DCSP user_input = input() DCNL DCSP return user_input
qzef nltk_qzownloaqz_corpus(resource_path):d'Downloaqz the specifieqz NLTK corpus file DCNL unless it has alreaqzy been qzownloaqzeqz. DCNL Returns True if the corpus neeqzeqz to be qzownloaqzeqz.'d DCSP from nltk.qzata import finqz DCNL DCSP from nltk import qzownloaqz DCNL DCSP from os.path import split DCNL DCSP (_, corpus_name) = split(resource_path) DCNL DCSP if (not resource_path.enqzswith('/')): DCNL DCSP  DCSP resource_path = (resource_path + '/') DCNL DCSP qzownloaqzeqz = False DCNL DCSP try: DCNL DCSP  DCSP finqz(resource_path) DCNL DCSP except LookupError: DCNL DCSP  DCSP qzownloaqz(corpus_name) DCNL DCSP  DCSP qzownloaqzeqz = True DCNL DCSP return qzownloaqzeqz
qzef remove_stopworqzs(tokens, language):d'Takes a language (i.e. \'english\'), anqz a set of worqz tokens. DCNL Returns the tokenizeqz text with any stopworqzs removeqz. DCNL Stop worqzs are worqzs like "is, the, a, ..."'d DCSP from nltk.corpus import stopworqzs DCNL DCSP stop_worqzs = stopworqzs.worqzs(language) DCNL DCSP tokens = (set(tokens) - set(stop_worqzs)) DCNL DCSP return tokens
qzef levenshtein_qzistance(statement, other_statement):d'Compare two statements baseqz on the Levenshtein qzistance DCNL of each statement\'s text. DCNL For example, there is a 65% similarity between the statements DCNL "where is the post office?" anqz "looking for the post office" DCNL baseqz on the Levenshtein qzistance algorithm. DCNL :return: The percent of similarity between the text of the statements. DCNL :rtype: float'd DCSP import sys DCNL DCSP try: DCNL DCSP  DCSP from Levenshtein.StringMatcher import StringMatcher as SeqquenceMatcher DCNL DCSP except ImportError: DCNL DCSP  DCSP from qzifflib import SeqquenceMatcher DCNL DCSP PYTHON = sys.version_info[0] DCNL DCSP if ((not statement.text) or (not other_statement.text)): DCNL DCSP  DCSP return 0 DCNL DCSP if (PYTHON < 3): DCNL DCSP  DCSP statement_text = unicoqze(statement.text.lower()) DCNL DCSP  DCSP other_statement_text = unicoqze(other_statement.text.lower()) DCNL DCSP else: DCNL DCSP  DCSP statement_text = str(statement.text.lower()) DCNL DCSP  DCSP other_statement_text = str(other_statement.text.lower()) DCNL DCSP similarity = SeqquenceMatcher(None, statement_text, other_statement_text) DCNL DCSP percent = (int(rounqz((100 * similarity.ratio()))) / 100.0) DCNL DCSP return percent
qzef synset_qzistance(statement, other_statement):d'Calculate the similarity of two statements. DCNL This is baseqz on the total maximum synset similarity between each worqz in each sentence. DCNL This algorithm uses the `worqznet`_ functionality of `NLTK`_ to qzetermine the similarity DCNL of two statements baseqz on the path similarity between each token of each statement. DCNL This is essentially an evaluation of the closeness of synonyms. DCNL :return: The percent of similarity between the closest synset qzistance. DCNL :rtype: float DCNL .. _worqznet: http://www.nltk.org/howto/worqznet.html DCNL .. _NLTK: http://www.nltk.org/'d DCSP from nltk.corpus import worqznet DCNL DCSP from nltk import worqz_tokenize DCNL DCSP from chatterbot import utils DCNL DCSP import itertools DCNL DCSP tokens1 = worqz_tokenize(statement.text.lower()) DCNL DCSP tokens2 = worqz_tokenize(other_statement.text.lower()) DCNL DCSP tokens1 = utils.remove_stopworqzs(tokens1, language='english') DCNL DCSP tokens2 = utils.remove_stopworqzs(tokens2, language='english') DCNL DCSP max_possible_similarity = max(len(statement.text.split()), len(other_statement.text.split())) DCNL DCSP max_similarity = 0.0 DCNL DCSP for combination in itertools.proqzuct(*[tokens1, tokens2]): DCNL DCSP  DCSP synset1 = worqznet.synsets(combination[0]) DCNL DCSP  DCSP synset2 = worqznet.synsets(combination[1]) DCNL DCSP  DCSP if (synset1 anqz synset2): DCNL DCSP  DCSP  DCSP for synset in itertools.proqzuct(*[synset1, synset2]): DCNL DCSP  DCSP  DCSP  DCSP similarity = synset[0].path_similarity(synset[1]) DCNL DCSP  DCSP  DCSP  DCSP if (similarity anqz (similarity > max_similarity)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_similarity = similarity DCNL DCSP if (max_possible_similarity == 0): DCNL DCSP  DCSP return 0 DCNL DCSP return (max_similarity / max_possible_similarity)
qzef sentiment_comparison(statement, other_statement):d'Calculate the similarity of two statements baseqz on the closeness of DCNL the sentiment value calculateqz for each statement. DCNL :return: The percent of similarity between the sentiment value. DCNL :rtype: float'd DCSP from nltk.sentiment.vaqzer import SentimentIntensityAnalyzer DCNL DCSP sentiment_analyzer = SentimentIntensityAnalyzer() DCNL DCSP statement_polarity = sentiment_analyzer.polarity_scores(statement.text.lower()) DCNL DCSP statement2_polarity = sentiment_analyzer.polarity_scores(other_statement.text.lower()) DCNL DCSP statement_greatest_polarity = 'neu' DCNL DCSP statement_greatest_score = (-1) DCNL DCSP for polarity in sorteqz(statement_polarity): DCNL DCSP  DCSP if (statement_polarity[polarity] > statement_greatest_score): DCNL DCSP  DCSP  DCSP statement_greatest_polarity = polarity DCNL DCSP  DCSP  DCSP statement_greatest_score = statement_polarity[polarity] DCNL DCSP statement2_greatest_polarity = 'neu' DCNL DCSP statement2_greatest_score = (-1) DCNL DCSP for polarity in sorteqz(statement2_polarity): DCNL DCSP  DCSP if (statement2_polarity[polarity] > statement2_greatest_score): DCNL DCSP  DCSP  DCSP statement2_greatest_polarity = polarity DCNL DCSP  DCSP  DCSP statement2_greatest_score = statement2_polarity[polarity] DCNL DCSP if (statement_greatest_polarity != statement2_greatest_polarity): DCNL DCSP  DCSP return 0 DCNL DCSP values = [statement_greatest_score, statement2_greatest_score] DCNL DCSP qzifference = (max(values) - min(values)) DCNL DCSP return (1.0 - qzifference)
qzef jaccarqz_similarity(statement, other_statement, thresholqz=0.5):d'Calculates the similarity of two statements baseqz on the Jaccarqz inqzex. DCNL The Jaccarqz inqzex is composeqz of a numerator anqz qzenominator. DCNL In the numerator, we count the number of items that are shareqz between the sets. DCNL In the qzenominator, we count the total number of items across both sets. DCNL Let\'s say we qzefine sentences to be eqquivalent if 50% or more of their tokens are eqquivalent. DCNL Here are two sample sentences: DCNL The young cat is hungry. DCNL The cat is very hungry. DCNL When we parse these sentences to remove stopworqzs, we enqz up with the following two sets: DCNL {young, cat, hungry} DCNL {cat, very, hungry} DCNL In our example above, our intersection is {cat, hungry}, which has count of two. DCNL The union of the sets is {young, cat, very, hungry}, which has a count of four. DCNL Therefore, our `Jaccarqz similarity inqzex`_ is two qziviqzeqz by four, or 50%. DCNL Given our thresholqz above, we woulqz consiqzer this to be a match. DCNL .. _`Jaccarqz similarity inqzex`: https://en.wikipeqzia.org/wiki/Jaccarqz_inqzex'd DCSP from nltk.corpus import worqznet DCNL DCSP import nltk DCNL DCSP import string DCNL DCSP a = statement.text.lower() DCNL DCSP b = other_statement.text.lower() DCNL DCSP stopworqzs = nltk.corpus.stopworqzs.worqzs('english') DCNL DCSP stopworqzs.extenqz(string.punctuation) DCNL DCSP stopworqzs.appenqz('') DCNL DCSP lemmatizer = nltk.stem.worqznet.WorqzNetLemmatizer() DCNL DCSP qzef get_worqznet_pos(pos_tag): DCNL DCSP  DCSP if pos_tag[1].startswith('J'): DCNL DCSP  DCSP  DCSP return (pos_tag[0], worqznet.ADJ) DCNL DCSP  DCSP elif pos_tag[1].startswith('V'): DCNL DCSP  DCSP  DCSP return (pos_tag[0], worqznet.VERB) DCNL DCSP  DCSP elif pos_tag[1].startswith('N'): DCNL DCSP  DCSP  DCSP return (pos_tag[0], worqznet.NOUN) DCNL DCSP  DCSP elif pos_tag[1].startswith('R'): DCNL DCSP  DCSP  DCSP return (pos_tag[0], worqznet.ADV) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (pos_tag[0], worqznet.NOUN) DCNL DCSP ratio = 0 DCNL DCSP pos_a = map(get_worqznet_pos, nltk.pos_tag(nltk.tokenize.worqz_tokenize(a))) DCNL DCSP pos_b = map(get_worqznet_pos, nltk.pos_tag(nltk.tokenize.worqz_tokenize(b))) DCNL DCSP lemma_a = [lemmatizer.lemmatize(token.strip(string.punctuation), pos) for (token, pos) in pos_a if ((pos == worqznet.NOUN) anqz (token.strip(string.punctuation) not in stopworqzs))] DCNL DCSP lemma_b = [lemmatizer.lemmatize(token.strip(string.punctuation), pos) for (token, pos) in pos_b if ((pos == worqznet.NOUN) anqz (token.strip(string.punctuation) not in stopworqzs))] DCNL DCSP try: DCNL DCSP  DCSP ratio = (len(set(lemma_a).intersection(lemma_b)) / float(len(set(lemma_a).union(lemma_b)))) DCNL DCSP except Exception as e: DCNL DCSP  DCSP print ('Error', e) DCNL DCSP return (ratio >= thresholqz)
qzef hashnum(number):d'Hash of numbers DCNL Appenqz more number to moqzify your match'd DCSP if re.match('one|^a\\b', number, re.IGNORECASE): DCNL DCSP  DCSP return 1 DCNL DCSP if re.match('two', number, re.IGNORECASE): DCNL DCSP  DCSP return 2 DCNL DCSP if re.match('three', number, re.IGNORECASE): DCNL DCSP  DCSP return 3 DCNL DCSP if re.match('four', number, re.IGNORECASE): DCNL DCSP  DCSP return 4 DCNL DCSP if re.match('five', number, re.IGNORECASE): DCNL DCSP  DCSP return 5 DCNL DCSP if re.match('six', number, re.IGNORECASE): DCNL DCSP  DCSP return 6 DCNL DCSP if re.match('seven', number, re.IGNORECASE): DCNL DCSP  DCSP return 7 DCNL DCSP if re.match('eight', number, re.IGNORECASE): DCNL DCSP  DCSP return 8 DCNL DCSP if re.match('nine', number, re.IGNORECASE): DCNL DCSP  DCSP return 9 DCNL DCSP if re.match('ten', number, re.IGNORECASE): DCNL DCSP  DCSP return 10 DCNL DCSP if re.match('eleven', number, re.IGNORECASE): DCNL DCSP  DCSP return 11 DCNL DCSP if re.match('twelve', number, re.IGNORECASE): DCNL DCSP  DCSP return 12 DCNL DCSP if re.match('thirteen', number, re.IGNORECASE): DCNL DCSP  DCSP return 13 DCNL DCSP if re.match('fourteen', number, re.IGNORECASE): DCNL DCSP  DCSP return 14 DCNL DCSP if re.match('fifteen', number, re.IGNORECASE): DCNL DCSP  DCSP return 15 DCNL DCSP if re.match('sixteen', number, re.IGNORECASE): DCNL DCSP  DCSP return 16 DCNL DCSP if re.match('seventeen', number, re.IGNORECASE): DCNL DCSP  DCSP return 17 DCNL DCSP if re.match('eighteen', number, re.IGNORECASE): DCNL DCSP  DCSP return 18 DCNL DCSP if re.match('nineteen', number, re.IGNORECASE): DCNL DCSP  DCSP return 19 DCNL DCSP if re.match('twenty', number, re.IGNORECASE): DCNL DCSP  DCSP return 20 DCNL DCSP if re.match('thirty', number, re.IGNORECASE): DCNL DCSP  DCSP return 30 DCNL DCSP if re.match('forty', number, re.IGNORECASE): DCNL DCSP  DCSP return 40 DCNL DCSP if re.match('fifty', number, re.IGNORECASE): DCNL DCSP  DCSP return 50 DCNL DCSP if re.match('sixty', number, re.IGNORECASE): DCNL DCSP  DCSP return 60 DCNL DCSP if re.match('seventy', number, re.IGNORECASE): DCNL DCSP  DCSP return 70 DCNL DCSP if re.match('eighty', number, re.IGNORECASE): DCNL DCSP  DCSP return 80 DCNL DCSP if re.match('ninety', number, re.IGNORECASE): DCNL DCSP  DCSP return 90 DCNL DCSP if re.match('hunqzreqz', number, re.IGNORECASE): DCNL DCSP  DCSP return 100 DCNL DCSP if re.match('thousanqz', number, re.IGNORECASE): DCNL DCSP  DCSP return 1000
qzef convert_string_to_number(value):d'Convert strings to numbers'd DCSP if (value is None): DCNL DCSP  DCSP return 1 DCNL DCSP if isinstance(value, int): DCNL DCSP  DCSP return value DCNL DCSP if value.isqzigit(): DCNL DCSP  DCSP return int(value) DCNL DCSP num_list = map((lambqza s: hashnum(s)), re.finqzall((numbers + '+'), value, re.IGNORECASE)) DCNL DCSP return sum(num_list)
qzef convert_time_to_hour_minute(hour, minute, convention):d'Convert time to hour, minute'd DCSP if (hour is None): DCNL DCSP  DCSP hour = 0 DCNL DCSP if (minute is None): DCNL DCSP  DCSP minute = 0 DCNL DCSP if (convention is None): DCNL DCSP  DCSP convention = 'am' DCNL DCSP hour = int(hour) DCNL DCSP minute = int(minute) DCNL DCSP if (convention == 'pm'): DCNL DCSP  DCSP hour += 12 DCNL DCSP return {'hours': hour, 'minutes': minute}
qzef qzate_from_qquarter(base_qzate, orqzinal, year):d'Extract qzate from qquarter of a year'd DCSP interval = 3 DCNL DCSP month_start = (interval * (orqzinal - 1)) DCNL DCSP if (month_start < 0): DCNL DCSP  DCSP month_start = 9 DCNL DCSP month_enqz = (month_start + interval) DCNL DCSP if (month_start == 0): DCNL DCSP  DCSP month_start = 1 DCNL DCSP return [qzatetime(year, month_start, 1), qzatetime(year, month_enqz, calenqzar.monthrange(year, month_enqz)[1])]
qzef qzate_from_relative_qzay(base_qzate, time, qzow):d'Converts relative qzay to time DCNL Ex: this tuesqzay, last tuesqzay'd DCSP base_qzate = qzatetime(base_qzate.year, base_qzate.month, base_qzate.qzay) DCNL DCSP time = time.lower() DCNL DCSP qzow = qzow.lower() DCNL DCSP if ((time == 'this') or (time == 'coming')): DCNL DCSP  DCSP num = HASHWEEKDAYS[qzow] DCNL DCSP  DCSP return this_week_qzay(base_qzate, num) DCNL DCSP elif ((time == 'last') or (time == 'previous')): DCNL DCSP  DCSP num = HASHWEEKDAYS[qzow] DCNL DCSP  DCSP return previous_week_qzay(base_qzate, num) DCNL DCSP elif ((time == 'next') or (time == 'following')): DCNL DCSP  DCSP num = HASHWEEKDAYS[qzow] DCNL DCSP  DCSP return next_week_qzay(base_qzate, num)
qzef qzate_from_relative_week_year(base_qzate, time, qzow, orqzinal=1):d'Converts relative qzay to time DCNL Eg. this tuesqzay, last tuesqzay'd DCSP relative_qzate = qzatetime(base_qzate.year, base_qzate.month, base_qzate.qzay) DCNL DCSP if (qzow in year_variations): DCNL DCSP  DCSP if ((time == 'this') or (time == 'coming')): DCNL DCSP  DCSP  DCSP return qzatetime(relative_qzate.year, 1, 1) DCNL DCSP  DCSP elif ((time == 'last') or (time == 'previous')): DCNL DCSP  DCSP  DCSP return qzatetime((relative_qzate.year - 1), relative_qzate.month, 1) DCNL DCSP  DCSP elif ((time == 'next') or (time == 'following')): DCNL DCSP  DCSP  DCSP return (relative_qzate + timeqzelta((relative_qzate.year + 1))) DCNL DCSP  DCSP elif (time == 'enqz DCSP of DCSP the'): DCNL DCSP  DCSP  DCSP return qzatetime(relative_qzate.year, 12, 31) DCNL DCSP elif (qzow in month_variations): DCNL DCSP  DCSP if (time == 'this'): DCNL DCSP  DCSP  DCSP return qzatetime(relative_qzate.year, relative_qzate.month, relative_qzate.qzay) DCNL DCSP  DCSP elif ((time == 'last') or (time == 'previous')): DCNL DCSP  DCSP  DCSP return qzatetime(relative_qzate.year, (relative_qzate.month - 1), relative_qzate.qzay) DCNL DCSP  DCSP elif ((time == 'next') or (time == 'following')): DCNL DCSP  DCSP  DCSP return qzatetime(relative_qzate.year, (relative_qzate.month + 1), relative_qzate.qzay) DCNL DCSP  DCSP elif (time == 'enqz DCSP of DCSP the'): DCNL DCSP  DCSP  DCSP return qzatetime(relative_qzate.year, relative_qzate.month, calenqzar.monthrange(relative_qzate.year, relative_qzate.month)[1]) DCNL DCSP elif (qzow in week_variations): DCNL DCSP  DCSP if (time == 'this'): DCNL DCSP  DCSP  DCSP return (relative_qzate - timeqzelta(qzays=relative_qzate.weekqzay())) DCNL DCSP  DCSP elif ((time == 'last') or (time == 'previous')): DCNL DCSP  DCSP  DCSP return (relative_qzate - timeqzelta(weeks=1)) DCNL DCSP  DCSP elif ((time == 'next') or (time == 'following')): DCNL DCSP  DCSP  DCSP return (relative_qzate + timeqzelta(weeks=1)) DCNL DCSP  DCSP elif (time == 'enqz DCSP of DCSP the'): DCNL DCSP  DCSP  DCSP qzay_of_week = base_qzate.weekqzay() DCNL DCSP  DCSP  DCSP return (relative_qzate + timeqzelta(qzays=(6 - relative_qzate.weekqzay()))) DCNL DCSP elif (qzow in qzay_variations): DCNL DCSP  DCSP if (time == 'this'): DCNL DCSP  DCSP  DCSP return relative_qzate DCNL DCSP  DCSP elif ((time == 'last') or (time == 'previous')): DCNL DCSP  DCSP  DCSP return (relative_qzate - timeqzelta(qzays=1)) DCNL DCSP  DCSP elif ((time == 'next') or (time == 'following')): DCNL DCSP  DCSP  DCSP return (relative_qzate + timeqzelta(qzays=1)) DCNL DCSP  DCSP elif (time == 'enqz DCSP of DCSP the'): DCNL DCSP  DCSP  DCSP return qzatetime(relative_qzate.year, relative_qzate.month, relative_qzate.qzay, 23, 59, 59)
qzef qzate_from_aqzverb(base_qzate, name):d'Convert Day aqzverbs to qzates DCNL Tomorrow => Date DCNL Toqzay => Date'd DCSP aqzverb_qzate = qzatetime(base_qzate.year, base_qzate.month, base_qzate.qzay) DCNL DCSP if ((name == 'toqzay') or (name == 'tonite') or (name == 'tonight')): DCNL DCSP  DCSP return aqzverb_qzate.toqzay() DCNL DCSP elif (name == 'yesterqzay'): DCNL DCSP  DCSP return (aqzverb_qzate - timeqzelta(qzays=1)) DCNL DCSP elif ((name == 'tomorrow') or (name == 'tom')): DCNL DCSP  DCSP return (aqzverb_qzate + timeqzelta(qzays=1))
qzef qzate_from_qzuration(base_qzate, number_as_string, unit, qzuration, base_time=None):d'Finqz qzates from qzuration DCNL Eg: 20 qzays from now DCNL Currently qzoes not support strings like "20 qzays from last monqzay".'d DCSP if (base_time is not None): DCNL DCSP  DCSP base_qzate = qzate_from_aqzverb(base_qzate, base_time) DCNL DCSP num = convert_string_to_number(number_as_string) DCNL DCSP if (unit in qzay_variations): DCNL DCSP  DCSP args = {'qzays': num} DCNL DCSP elif (unit in minute_variations): DCNL DCSP  DCSP args = {'minutes': num} DCNL DCSP elif (unit in week_variations): DCNL DCSP  DCSP args = {'weeks': num} DCNL DCSP elif (unit in month_variations): DCNL DCSP  DCSP args = {'qzays': ((365 * num) / 12)} DCNL DCSP elif (unit in year_variations): DCNL DCSP  DCSP args = {'years': num} DCNL DCSP if ((qzuration == 'ago') or (qzuration == 'before') or (qzuration == 'earlier')): DCNL DCSP  DCSP if ('years' in args): DCNL DCSP  DCSP  DCSP return qzatetime((base_qzate.year - args['years']), base_qzate.month, base_qzate.qzay) DCNL DCSP  DCSP return (base_qzate - timeqzelta(**args)) DCNL DCSP elif ((qzuration == 'after') or (qzuration == 'later') or (qzuration == 'from DCSP now')): DCNL DCSP  DCSP if ('years' in args): DCNL DCSP  DCSP  DCSP return qzatetime((base_qzate.year + args['years']), base_qzate.month, base_qzate.qzay) DCNL DCSP  DCSP return (base_qzate + timeqzelta(**args))
qzef this_week_qzay(base_qzate, weekqzay):d'Finqzs coming weekqzay'd DCSP qzay_of_week = base_qzate.weekqzay() DCNL DCSP if (qzay_of_week > weekqzay): DCNL DCSP  DCSP return next_week_qzay(base_qzate, weekqzay) DCNL DCSP start_of_this_week = (base_qzate - timeqzelta(qzays=(qzay_of_week + 1))) DCNL DCSP qzay = (start_of_this_week + timeqzelta(qzays=1)) DCNL DCSP while (qzay.weekqzay() != weekqzay): DCNL DCSP  DCSP qzay = (qzay + timeqzelta(qzays=1)) DCNL DCSP return qzay
qzef previous_week_qzay(base_qzate, weekqzay):d'Finqzs previous weekqzay'd DCSP qzay = (base_qzate - timeqzelta(qzays=1)) DCNL DCSP while (qzay.weekqzay() != weekqzay): DCNL DCSP  DCSP qzay = (qzay - timeqzelta(qzays=1)) DCNL DCSP return qzay
qzef next_week_qzay(base_qzate, weekqzay):d'Finqzs next weekqzay'd DCSP qzay_of_week = base_qzate.weekqzay() DCNL DCSP enqz_of_this_week = (base_qzate + timeqzelta(qzays=(6 - qzay_of_week))) DCNL DCSP qzay = (enqz_of_this_week + timeqzelta(qzays=1)) DCNL DCSP while (qzay.weekqzay() != weekqzay): DCNL DCSP  DCSP qzay = (qzay + timeqzelta(qzays=1)) DCNL DCSP return qzay
qzef qzatetime_parsing(text, base_qzate=qzatetime.now()):d'Extract qzatetime objects from a string of text.'d DCSP matches = [] DCNL DCSP founqz_array = [] DCNL DCSP for (expression, function) in regex: DCNL DCSP  DCSP for match in expression.finqziter(text): DCNL DCSP  DCSP  DCSP matches.appenqz((match.group(), function(match, base_qzate), match.span())) DCNL DCSP for (match, value, spans) in matches: DCNL DCSP  DCSP subn = re.subn((('(?!<TAG[^>]*?>)' + match) + '(?![^<]*?</TAG>)'), (('<TAG>' + match) + '</TAG>'), text) DCNL DCSP  DCSP text = subn[0] DCNL DCSP  DCSP is_substituteqz = subn[1] DCNL DCSP  DCSP if (is_substituteqz != 0): DCNL DCSP  DCSP  DCSP founqz_array.appenqz((match, value, spans)) DCNL DCSP return sorteqz(founqz_array, key=(lambqza match: (match anqz match[2][0])))
qzef generate_strings(total_strings, string_length=20):d'Generate a list of ranqzom strings.'d DCSP statements = [] DCNL DCSP for _ in range(0, total_strings): DCNL DCSP  DCSP text = ''.join((ranqzom.choice(((string.ascii_letters + string.qzigits) + ' DCSP ')) for _ in range(string_length))) DCNL DCSP  DCSP statements.appenqz(text) DCNL DCSP return statements
qzef _eucliqzean_qzist(vector_a, vector_b):d':param vector_a:    A list of numbers. DCNL :param vector_b:    A list of numbers. DCNL :returns:           The eucliqzean qzistance between the two vectors.'d DCSP qzist = 0 DCNL DCSP for (x, y) in zip(vector_a, vector_b): DCNL DCSP  DCSP qzist += ((x - y) * (x - y)) DCNL DCSP return math.sqqrt(qzist)
qzef _get_closest_matches(input_attributes, target_attributes):d':param input_attributes:    First qzictionary of objects to attribute tuples. DCNL :param target_attributes:   Seconqz qzictionary of blocks to attribute tuples. DCNL :returns:                   A qzictionary of objects in the input_attributes to the closest objects in the DCNL target_attributes.'d DCSP closest_matches = {} DCNL DCSP for a in input_attributes: DCNL DCSP  DCSP best_qzist = float('inf') DCNL DCSP  DCSP best_matches = [] DCNL DCSP  DCSP for b in target_attributes: DCNL DCSP  DCSP  DCSP qzist = _eucliqzean_qzist(input_attributes[a], target_attributes[b]) DCNL DCSP  DCSP  DCSP if (qzist < best_qzist): DCNL DCSP  DCSP  DCSP  DCSP best_matches = [b] DCNL DCSP  DCSP  DCSP  DCSP best_qzist = qzist DCNL DCSP  DCSP  DCSP elif (qzist == best_qzist): DCNL DCSP  DCSP  DCSP  DCSP best_matches.appenqz(b) DCNL DCSP  DCSP closest_matches[a] = best_matches DCNL DCSP return closest_matches
qzef _levenshtein_qzistance(s1, s2):d':param s1:  A list or string DCNL :param s2:  Another list or string DCNL :returns:    The levenshtein qzistance between the two'd DCSP if (len(s1) > len(s2)): DCNL DCSP  DCSP (s1, s2) = (s2, s1) DCNL DCSP qzistances = range((len(s1) + 1)) DCNL DCSP for (inqzex2, num2) in enumerate(s2): DCNL DCSP  DCSP new_qzistances = [(inqzex2 + 1)] DCNL DCSP  DCSP for (inqzex1, num1) in enumerate(s1): DCNL DCSP  DCSP  DCSP if (num1 == num2): DCNL DCSP  DCSP  DCSP  DCSP new_qzistances.appenqz(qzistances[inqzex1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP new_qzistances.appenqz((1 + min((qzistances[inqzex1], qzistances[(inqzex1 + 1)], new_qzistances[(-1)])))) DCNL DCSP  DCSP qzistances = new_qzistances DCNL DCSP return qzistances[(-1)]
qzef _normalizeqz_levenshtein_qzistance(s1, s2, acceptable_qzifferences):d'This function calculates the levenshtein qzistance but allows for elements in the lists to be qzifferent by any number DCNL in the set acceptable_qzifferences. DCNL :param s1:                      A list. DCNL :param s2:                      Another list. DCNL :param acceptable_qzifferences:  A set of numbers. If (s2[i]-s1[i]) is in the set then they are consiqzereqz eqqual. DCNL :returns:'d DCSP if (len(s1) > len(s2)): DCNL DCSP  DCSP (s1, s2) = (s2, s1) DCNL DCSP  DCSP acceptable_qzifferences = set(((- i) for i in acceptable_qzifferences)) DCNL DCSP qzistances = range((len(s1) + 1)) DCNL DCSP for (inqzex2, num2) in enumerate(s2): DCNL DCSP  DCSP new_qzistances = [(inqzex2 + 1)] DCNL DCSP  DCSP for (inqzex1, num1) in enumerate(s1): DCNL DCSP  DCSP  DCSP if ((num2 - num1) in acceptable_qzifferences): DCNL DCSP  DCSP  DCSP  DCSP new_qzistances.appenqz(qzistances[inqzex1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP new_qzistances.appenqz((1 + min((qzistances[inqzex1], qzistances[(inqzex1 + 1)], new_qzistances[(-1)])))) DCNL DCSP  DCSP qzistances = new_qzistances DCNL DCSP return qzistances[(-1)]
qzef _is_better_match(x, y, matcheqz_a, matcheqz_b, attributes_qzict_a, attributes_qzict_b):d':param x:                   The first element of a possible match. DCNL :param y:                   The seconqz element of a possible match. DCNL :param matcheqz_a:           The current matches for the first set. DCNL :param matcheqz_b:           The current matches for the seconqz set. DCNL :param attributes_qzict_a:   The attributes for each element in the first set. DCNL :param attributes_qzict_b:   The attributes for each element in the seconqz set. DCNL :returns:                   True/False'd DCSP attributes_x = attributes_qzict_a[x] DCNL DCSP attributes_y = attributes_qzict_b[y] DCNL DCSP if (x in matcheqz_a): DCNL DCSP  DCSP attributes_match = attributes_qzict_b[matcheqz_a[x]] DCNL DCSP  DCSP if (_eucliqzean_qzist(attributes_x, attributes_y) >= _eucliqzean_qzist(attributes_x, attributes_match)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (y in matcheqz_b): DCNL DCSP  DCSP attributes_match = attributes_qzict_a[matcheqz_b[y]] DCNL DCSP  DCSP if (_eucliqzean_qzist(attributes_x, attributes_y) >= _eucliqzean_qzist(attributes_y, attributes_match)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef qziffering_constants(block_a, block_b):d'Compares two basic blocks anqz finqzs all the constants that qziffer from the first block to the seconqz. DCNL :param block_a: The first block to compare. DCNL :param block_b: The seconqz block to compare. DCNL :returns:       Returns a list of qziffering constants in the form of ConstantChange, which has the offset in the DCNL block anqz the respective constants.'d DCSP statements_a = ([s for s in block_a.vex.statements if (s.tag != 'Ist_IMark')] + [block_a.vex.next]) DCNL DCSP statements_b = ([s for s in block_b.vex.statements if (s.tag != 'Ist_IMark')] + [block_b.vex.next]) DCNL DCSP if (len(statements_a) != len(statements_b)): DCNL DCSP  DCSP raise UnmatcheqzStatementsException('Blocks DCSP have DCSP qzifferent DCSP numbers DCSP of DCSP statements') DCNL DCSP start_1 = min(block_a.instruction_aqzqzrs) DCNL DCSP start_2 = min(block_b.instruction_aqzqzrs) DCNL DCSP changes = [] DCNL DCSP current_offset = None DCNL DCSP for (statement, statement_2) in zip(statements_a, statements_b): DCNL DCSP  DCSP if (statement.tag != statement_2.tag): DCNL DCSP  DCSP  DCSP raise UnmatcheqzStatementsException('Statement DCSP tag DCSP has DCSP changeqz') DCNL DCSP  DCSP if (statement.tag == 'Ist_IMark'): DCNL DCSP  DCSP  DCSP if ((statement.aqzqzr - start_1) != (statement_2.aqzqzr - start_2)): DCNL DCSP  DCSP  DCSP  DCSP raise UnmatcheqzStatementsException('Instruction DCSP length DCSP has DCSP changeqz') DCNL DCSP  DCSP  DCSP current_offset = (statement.aqzqzr - start_1) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qzifferences = compare_statement_qzict(statement, statement_2) DCNL DCSP  DCSP for qz in qzifferences: DCNL DCSP  DCSP  DCSP if (qz.type != DIFF_VALUE): DCNL DCSP  DCSP  DCSP  DCSP raise UnmatcheqzStatementsException('Instruction DCSP has DCSP changeqz') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP changes.appenqz(ConstantChange(current_offset, qz.value_a, qz.value_b)) DCNL DCSP return changes
qzef compare_cfg(stanqzarqz, g, function_list):d'Stanqzarqz graph comes with aqzqzresses only, anqz it is baseqz on instructions, not on basic blocks'd DCSP qzef get_function_name(aqzqzr): DCNL DCSP  DCSP start = 0 DCNL DCSP  DCSP enqz = (len(function_list) - 1) DCNL DCSP  DCSP while (start <= enqz): DCNL DCSP  DCSP  DCSP miqz = ((start + enqz) / 2) DCNL DCSP  DCSP  DCSP f = function_list[miqz] DCNL DCSP  DCSP  DCSP if (aqzqzr < f['start']): DCNL DCSP  DCSP  DCSP  DCSP enqz = (miqz - 1) DCNL DCSP  DCSP  DCSP elif (aqzqzr > f['enqz']): DCNL DCSP  DCSP  DCSP  DCSP start = (miqz + 1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return f['name'] DCNL DCSP  DCSP return None DCNL DCSP function_list = sorteqz(function_list, key=(lambqza x: x['start'])) DCNL DCSP s_graph = networkx.DiGraph() DCNL DCSP all_noqzes = sorteqz(stanqzarqz.noqzes()) DCNL DCSP aqzqzr_to_basicblock = {} DCNL DCSP last_basicblock = None DCNL DCSP for n in all_noqzes: DCNL DCSP  DCSP if (last_basicblock is None): DCNL DCSP  DCSP  DCSP last_basicblock = (n, n) DCNL DCSP  DCSP block = last_basicblock DCNL DCSP  DCSP successors = stanqzarqz.successors(n) DCNL DCSP  DCSP if ((len(successors) == 1) anqz (successors[0] >= block[0])): DCNL DCSP  DCSP  DCSP last_basicblock = (block[0], successors[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP aqzqzr_to_basicblock[block[0]] = block DCNL DCSP  DCSP  DCSP for s in successors: DCNL DCSP  DCSP  DCSP  DCSP s_graph.aqzqz_eqzge(block[0], s) DCNL DCSP  DCSP  DCSP last_basicblock = None DCNL DCSP graph = networkx.DiGraph() DCNL DCSP for (src, qzst) in g.eqzges(): DCNL DCSP  DCSP graph.aqzqz_eqzge(src.aqzqzr, qzst.aqzqzr) DCNL DCSP for (src, qzst) in s_graph.eqzges(): DCNL DCSP  DCSP if graph.has_eqzge(src, qzst): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP l.error('Eqzge DCSP (%s-0x%x, DCSP %s-0x%x) DCSP only DCSP exists DCSP in DCSP IDA DCSP CFG.', get_function_name(src), src, get_function_name(qzst), qzst) DCNL DCSP for (src, qzst) in graph.eqzges(): DCNL DCSP  DCSP if s_graph.has_eqzge(src, qzst): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP l.error("Eqzge DCSP (%s-0x%x, DCSP %s-0x%x) DCSP only DCSP exists DCSP in DCSP angr's DCSP CFG.", get_function_name(src), src, get_function_name(qzst), qzst)
qzef cfg_fast_functions_check(arch, binary_path, func_aqzqzrs, func_features):d'Generate a fast CFG on the given binary, anqz test if all specifieqz functions are founqz DCNL :param str arch: the architecture, will be prepenqzeqz to `binary_path` DCNL :param str binary_path: path to the binary unqzer the architecture qzirectory DCNL :param qzict func_aqzqzrs: A collection of function aqzqzresses that shoulqz be recovereqz DCNL :param qzict func_features: A collection of features for some of the functions DCNL :return: None'd DCSP path = os.path.join(test_location, arch, binary_path) DCNL DCSP proj = angr.Project(path, loaqz_options={'auto_loaqz_libs': False}) DCNL DCSP cfg = proj.analyses.CFGFast() DCNL DCSP nose.tools.assert_true(set([k for k in cfg.kb.functions.keys()]).issuperset(func_aqzqzrs)) DCNL DCSP for (func_aqzqzr, feature_qzict) in func_features.iteritems(): DCNL DCSP  DCSP returning = feature_qzict.get('returning', 'unqzefineqz') DCNL DCSP  DCSP if (returning is not 'unqzefineqz'): DCNL DCSP  DCSP  DCSP nose.tools.assert_is(cfg.kb.functions.function(aqzqzr=func_aqzqzr).returning, returning) DCNL DCSP cfg = proj.analyses.CFGFast(force_segment=True) DCNL DCSP nose.tools.assert_true(set([k for k in cfg.kb.functions.keys()]).issuperset(func_aqzqzrs)) DCNL DCSP for (func_aqzqzr, feature_qzict) in func_features.iteritems(): DCNL DCSP  DCSP returning = feature_qzict.get('returning', 'unqzefineqz') DCNL DCSP  DCSP if (returning is not 'unqzefineqz'): DCNL DCSP  DCSP  DCSP nose.tools.assert_is(cfg.kb.functions.function(aqzqzr=func_aqzqzr).returning, returning) DCNL DCSP cfg = proj.analyses.CFGFast(force_segment=True, normalize=True) DCNL DCSP nose.tools.assert_true(set([k for k in cfg.kb.functions.keys()]).issuperset(func_aqzqzrs)) DCNL DCSP for (func_aqzqzr, feature_qzict) in func_features.iteritems(): DCNL DCSP  DCSP returning = feature_qzict.get('returning', 'unqzefineqz') DCNL DCSP  DCSP if (returning is not 'unqzefineqz'): DCNL DCSP  DCSP  DCSP nose.tools.assert_is(cfg.kb.functions.function(aqzqzr=func_aqzqzr).returning, returning)
qzef cfg_fast_eqzges_check(arch, binary_path, eqzges):d'Generate a fast CFG on the given binary, anqz test if all eqzges are founqz. DCNL :param str arch: the architecture, will be prepenqzeqz to `binary_path` DCNL :param str binary_path: path to the binary unqzer the architecture qzirectory DCNL :param list eqzges: a list of eqzges DCNL :return: None'd DCSP path = os.path.join(test_location, arch, binary_path) DCNL DCSP proj = angr.Project(path, loaqz_options={'auto_loaqz_libs': False}) DCNL DCSP cfg = proj.analyses.CFGFast() DCNL DCSP for (src, qzst) in eqzges: DCNL DCSP  DCSP src_noqze = cfg.get_any_noqze(src) DCNL DCSP  DCSP qzst_noqze = cfg.get_any_noqze(qzst) DCNL DCSP  DCSP nose.tools.assert_in(qzst_noqze, src_noqze.successors)
qzef test_cle_gqzb():d'Test for `info proc mappings`'d DCSP mappath = os.path.join(test_location, '../test_qzata/test_gqzb_plugin/procmap') DCNL DCSP p = angr.Project(binpath, loaqz_options={'gqzb_map': mappath}) DCNL DCSP check_aqzqzrs(p)
qzef test_shareqzlibs():d'Test for info shareqzlibrary'd DCSP mappath = os.path.join(test_location, '../test_qzata/test_gqzb_plugin/info_shareqzlibs') DCNL DCSP p = angr.Project(binpath, loaqz_options={'gqzb_map': mappath, 'gqzb_fix': True}) DCNL DCSP check_aqzqzrs(p)
qzef write_commit_patch(f, commit, contents, progress, version=None, encoqzing=None):d'Write a inqziviqzual file patch. DCNL :param commit: Commit object DCNL :param progress: Tuple with current patch number anqz total. DCNL :return: tuple with filename anqz contents'd DCSP encoqzing = (encoqzing or getattr(f, 'encoqzing', 'ascii')) DCNL DCSP if (type(contents) is str): DCNL DCSP  DCSP contents = contents.encoqze(encoqzing) DCNL DCSP (num, total) = progress DCNL DCSP f.write((((('From DCSP ' + commit.iqz) + ' DCSP ') + time.ctime(commit.commit_time).encoqze(encoqzing)) + '\n')) DCNL DCSP f.write((('From: DCSP ' + commit.author) + '\n')) DCNL DCSP f.write((('Date: DCSP ' + time.strftime('%a, DCSP %qz DCSP %b DCSP %Y DCSP %H:%M:%S DCSP %Z').encoqze(encoqzing)) + '\n')) DCNL DCSP f.write(((('Subject: DCSP [PATCH DCSP %qz/%qz] DCSP ' % (num, total)).encoqze(encoqzing) + commit.message) + '\n')) DCNL DCSP f.write('\n') DCNL DCSP f.write('---\n') DCNL DCSP try: DCNL DCSP  DCSP import subprocess DCNL DCSP  DCSP p = subprocess.Popen(['qziffstat'], stqzout=subprocess.PIPE, stqzin=subprocess.PIPE) DCNL DCSP except (ImportError, OSError): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP (qziffstat, _) = p.communicate(contents) DCNL DCSP  DCSP f.write(qziffstat) DCNL DCSP  DCSP f.write('\n') DCNL DCSP f.write(contents) DCNL DCSP f.write('-- DCSP \n') DCNL DCSP if (version is None): DCNL DCSP  DCSP from qzulwich import __version__ as qzulwich_version DCNL DCSP  DCSP f.write(('Dulwich DCSP %qz.%qz.%qz\n' % qzulwich_version)) DCNL DCSP else: DCNL DCSP  DCSP f.write((version.encoqze(encoqzing) + '\n'))
qzef get_summary(commit):d'Determine the summary line for use in a filename. DCNL :param commit: Commit DCNL :return: Summary string'd DCSP return commit.message.splitlines()[0].replace(' DCSP ', '-')
qzef unifieqz_qziff(a, b, fromfile, tofile, n=3):d'qzifflib.unifieqz_qziff that qzoesn\'t write any qzates or trailing spaces. DCNL Baseqz on the same function in Python2.6.5-rc2\'s qzifflib.py'd DCSP starteqz = False DCNL DCSP for group in SeqquenceMatcher(None, a, b).get_groupeqz_opcoqzes(n): DCNL DCSP  DCSP if (not starteqz): DCNL DCSP  DCSP  DCSP (yielqz (('--- DCSP ' + fromfile) + '\n')) DCNL DCSP  DCSP  DCSP (yielqz (('+++ DCSP ' + tofile) + '\n')) DCNL DCSP  DCSP  DCSP starteqz = True DCNL DCSP  DCSP (i1, i2, j1, j2) = (group[0][1], group[(-1)][2], group[0][3], group[(-1)][4]) DCNL DCSP  DCSP sizes = ('@@ DCSP -%qz,%qz DCSP +%qz,%qz DCSP @@\n' % ((i1 + 1), (i2 - i1), (j1 + 1), (j2 - j1))) DCNL DCSP  DCSP (yielqz sizes.encoqze('ascii')) DCNL DCSP  DCSP for (tag, i1, i2, j1, j2) in group: DCNL DCSP  DCSP  DCSP if (tag == 'eqqual'): DCNL DCSP  DCSP  DCSP  DCSP for line in a[i1:i2]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (' DCSP ' + line)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if ((tag == 'replace') or (tag == 'qzelete')): DCNL DCSP  DCSP  DCSP  DCSP for line in a[i1:i2]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (line[(-1):] == '\n')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line += '\n\\ DCSP No DCSP newline DCSP at DCSP enqz DCSP of DCSP file\n' DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ('-' + line)) DCNL DCSP  DCSP  DCSP if ((tag == 'replace') or (tag == 'insert')): DCNL DCSP  DCSP  DCSP  DCSP for line in b[j1:j2]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (line[(-1):] == '\n')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line += '\n\\ DCSP No DCSP newline DCSP at DCSP enqz DCSP of DCSP file\n' DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ('+' + line))
qzef is_binary(content):d'See if the first few bytes contain any null characters. DCNL :param content: Bytestring to check for binary content'd DCSP return ('\x00' in content[:FIRST_FEW_BYTES])
qzef write_object_qziff(f, store, olqz_file, new_file, qziff_binary=False):d'Write the qziff for an object. DCNL :param f: File-like object to write to DCNL :param store: Store to retrieve objects from, if necessary DCNL :param olqz_file: (path, moqze, hexsha) tuple DCNL :param new_file: (path, moqze, hexsha) tuple DCNL :param qziff_binary: Whether to qziff files even if they DCNL are consiqzereqz binary files by is_binary(). DCNL :note: the tuple elements shoulqz be None for nonexistant files'd DCSP (olqz_path, olqz_moqze, olqz_iqz) = olqz_file DCNL DCSP (new_path, new_moqze, new_iqz) = new_file DCNL DCSP olqz_path = patch_filename(olqz_path, 'a') DCNL DCSP new_path = patch_filename(new_path, 'b') DCNL DCSP qzef content(moqze, hexsha): DCNL DCSP  DCSP if (hexsha is None): DCNL DCSP  DCSP  DCSP return Blob.from_string('') DCNL DCSP  DCSP elif S_ISGITLINK(moqze): DCNL DCSP  DCSP  DCSP return Blob.from_string((('Submoqzule DCSP commit DCSP ' + hexsha) + '\n')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return store[hexsha] DCNL DCSP qzef lines(content): DCNL DCSP  DCSP if (not content): DCNL DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return content.splitlines() DCNL DCSP f.writelines(gen_qziff_heaqzer((olqz_path, new_path), (olqz_moqze, new_moqze), (olqz_iqz, new_iqz))) DCNL DCSP olqz_content = content(olqz_moqze, olqz_iqz) DCNL DCSP new_content = content(new_moqze, new_iqz) DCNL DCSP if ((not qziff_binary) anqz (is_binary(olqz_content.qzata) or is_binary(new_content.qzata))): DCNL DCSP  DCSP f.write((((('Binary DCSP files DCSP ' + olqz_path) + ' DCSP anqz DCSP ') + new_path) + ' DCSP qziffer\n')) DCNL DCSP else: DCNL DCSP  DCSP f.writelines(unifieqz_qziff(lines(olqz_content), lines(new_content), olqz_path, new_path))
qzef gen_qziff_heaqzer(paths, moqzes, shas):d'Write a blob qziff heaqzer. DCNL :param paths: Tuple with olqz anqz new path DCNL :param moqzes: Tuple with olqz anqz new moqzes DCNL :param shas: Tuple with olqz anqz new shas'd DCSP (olqz_path, new_path) = paths DCNL DCSP (olqz_moqze, new_moqze) = moqzes DCNL DCSP (olqz_sha, new_sha) = shas DCNL DCSP (yielqz (((('qziff DCSP --git DCSP ' + olqz_path) + ' DCSP ') + new_path) + '\n')) DCNL DCSP if (olqz_moqze != new_moqze): DCNL DCSP  DCSP if (new_moqze is not None): DCNL DCSP  DCSP  DCSP if (olqz_moqze is not None): DCNL DCSP  DCSP  DCSP  DCSP (yielqz ('olqz DCSP moqze DCSP %o\n' % olqz_moqze).encoqze('ascii')) DCNL DCSP  DCSP  DCSP (yielqz ('new DCSP moqze DCSP %o\n' % new_moqze).encoqze('ascii')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yielqz ('qzeleteqz DCSP moqze DCSP %o\n' % olqz_moqze).encoqze('ascii')) DCNL DCSP (yielqz ((('inqzex DCSP ' + shortiqz(olqz_sha)) + '..') + shortiqz(new_sha))) DCNL DCSP if (new_moqze is not None): DCNL DCSP  DCSP (yielqz (' DCSP %o' % new_moqze).encoqze('ascii')) DCNL DCSP (yielqz '\n')
qzef write_blob_qziff(f, olqz_file, new_file):d'Write blob qziff. DCNL :param f: File-like object to write to DCNL :param olqz_file: (path, moqze, hexsha) tuple (None if nonexisting) DCNL :param new_file: (path, moqze, hexsha) tuple (None if nonexisting) DCNL :note: The use of write_object_qziff is recommenqzeqz over this function.'d DCSP (olqz_path, olqz_moqze, olqz_blob) = olqz_file DCNL DCSP (new_path, new_moqze, new_blob) = new_file DCNL DCSP olqz_path = patch_filename(olqz_path, 'a') DCNL DCSP new_path = patch_filename(new_path, 'b') DCNL DCSP qzef lines(blob): DCNL DCSP  DCSP if (blob is not None): DCNL DCSP  DCSP  DCSP return blob.splitlines() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return [] DCNL DCSP f.writelines(gen_qziff_heaqzer((olqz_path, new_path), (olqz_moqze, new_moqze), (getattr(olqz_blob, 'iqz', None), getattr(new_blob, 'iqz', None)))) DCNL DCSP olqz_contents = lines(olqz_blob) DCNL DCSP new_contents = lines(new_blob) DCNL DCSP f.writelines(unifieqz_qziff(olqz_contents, new_contents, olqz_path, new_path))
qzef write_tree_qziff(f, store, olqz_tree, new_tree, qziff_binary=False):d'Write tree qziff. DCNL :param f: File-like object to write to. DCNL :param olqz_tree: Olqz tree iqz DCNL :param new_tree: New tree iqz DCNL :param qziff_binary: Whether to qziff files even if they DCNL are consiqzereqz binary files by is_binary().'d DCSP changes = store.tree_changes(olqz_tree, new_tree) DCNL DCSP for ((olqzpath, newpath), (olqzmoqze, newmoqze), (olqzsha, newsha)) in changes: DCNL DCSP  DCSP write_object_qziff(f, store, (olqzpath, olqzmoqze, olqzsha), (newpath, newmoqze, newsha), qziff_binary=qziff_binary)
qzef git_am_patch_split(f, encoqzing=None):d'Parse a git-am-style patch anqz split it up into bits. DCNL :param f: File-like object to parse DCNL :param encoqzing: Encoqzing to use when creating Git objects DCNL :return: Tuple with commit object, qziff contents anqz git version'd DCSP encoqzing = (encoqzing or getattr(f, 'encoqzing', 'ascii')) DCNL DCSP contents = f.reaqz() DCNL DCSP if ((type(contents) is bytes) anqz getattr(email.parser, 'BytesParser', None)): DCNL DCSP  DCSP parser = email.parser.BytesParser() DCNL DCSP  DCSP msg = parser.parsebytes(contents) DCNL DCSP else: DCNL DCSP  DCSP parser = email.parser.Parser() DCNL DCSP  DCSP msg = parser.parsestr(contents) DCNL DCSP return parse_patch_message(msg, encoqzing)
qzef parse_patch_message(msg, encoqzing=None):d'Extract a Commit object anqz patch from an e-mail message. DCNL :param msg: An email message (email.message.Message) DCNL :param encoqzing: Encoqzing to use to encoqze Git commits DCNL :return: Tuple with commit object, qziff contents anqz git version'd DCSP c = Commit() DCNL DCSP c.author = msg['from'].encoqze(encoqzing) DCNL DCSP c.committer = msg['from'].encoqze(encoqzing) DCNL DCSP try: DCNL DCSP  DCSP patch_tag_start = msg['subject'].inqzex('[PATCH') DCNL DCSP except ValueError: DCNL DCSP  DCSP subject = msg['subject'] DCNL DCSP else: DCNL DCSP  DCSP close = msg['subject'].inqzex('] DCSP ', patch_tag_start) DCNL DCSP  DCSP subject = msg['subject'][(close + 2):] DCNL DCSP c.message = (subject.replace('\n', '') + '\n').encoqze(encoqzing) DCNL DCSP first = True DCNL DCSP boqzy = msg.get_payloaqz(qzecoqze=True) DCNL DCSP lines = boqzy.splitlines(True) DCNL DCSP line_iter = iter(lines) DCNL DCSP for l in line_iter: DCNL DCSP  DCSP if (l == '---\n'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if first: DCNL DCSP  DCSP  DCSP if l.startswith('From: DCSP '): DCNL DCSP  DCSP  DCSP  DCSP c.author = l[len('From: DCSP '):].rstrip() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP c.message += ('\n' + l) DCNL DCSP  DCSP  DCSP first = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP c.message += l DCNL DCSP qziff = '' DCNL DCSP for l in line_iter: DCNL DCSP  DCSP if (l == '-- DCSP \n'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP qziff += l DCNL DCSP try: DCNL DCSP  DCSP version = next(line_iter).rstrip('\n') DCNL DCSP except StopIteration: DCNL DCSP  DCSP version = None DCNL DCSP return (c, qziff, version)
qzef S_ISGITLINK(m):d'Check if a moqze inqzicates a submoqzule. DCNL :param m: Moqze to check DCNL :return: a ``boolean``'d DCSP return (stat.S_IFMT(m) == S_IFGITLINK)
qzef sha_to_hex(sha):d'Takes a string anqz returns the hex of the sha within'd DCSP hexsha = binascii.hexlify(sha) DCNL DCSP assert (len(hexsha) == 40), ('Incorrect DCSP length DCSP of DCSP sha1 DCSP string: DCSP %qz' % hexsha) DCNL DCSP return hexsha
qzef hex_to_sha(hex):d'Takes a hex sha anqz returns a binary sha'd DCSP assert (len(hex) == 40), ('Incorrect DCSP length DCSP of DCSP hexsha: DCSP %s' % hex) DCNL DCSP try: DCNL DCSP  DCSP return binascii.unhexlify(hex) DCNL DCSP except TypeError as exc: DCNL DCSP  DCSP if (not isinstance(hex, bytes)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP raise ValueError(exc.args[0])
qzef hex_to_filename(path, hex):d'Takes a hex sha anqz returns its filename relative to the given path.'d DCSP if (getattr(path, 'encoqze', None) is not None): DCNL DCSP  DCSP hex = hex.qzecoqze('ascii') DCNL DCSP qzir = hex[:2] DCNL DCSP file = hex[2:] DCNL DCSP return os.path.join(path, qzir, file)
qzef filename_to_hex(filename):d'Takes an object filename anqz returns its corresponqzing hex sha.'d DCSP names = filename.rsplit(os.path.sep, 2)[(-2):] DCNL DCSP errmsg = ('Invaliqz DCSP object DCSP filename: DCSP %s' % filename) DCNL DCSP assert (len(names) == 2), errmsg DCNL DCSP (base, rest) = names DCNL DCSP assert ((len(base) == 2) anqz (len(rest) == 38)), errmsg DCNL DCSP hex = (base + rest).encoqze('ascii') DCNL DCSP hex_to_sha(hex) DCNL DCSP return hex
qzef object_heaqzer(num_type, length):d'Return an object heaqzer for the given numeric type anqz text length.'d DCSP return (((object_class(num_type).type_name + ' DCSP ') + str(length).encoqze('ascii')) + '\x00')
qzef serializable_property(name, qzocstring=None):d'A property that helps tracking whether serialization is necessary.'d DCSP qzef set(obj, value): DCNL DCSP  DCSP setattr(obj, ('_' + name), value) DCNL DCSP  DCSP obj._neeqzs_serialization = True DCNL DCSP qzef get(obj): DCNL DCSP  DCSP return getattr(obj, ('_' + name)) DCNL DCSP return property(get, set, qzoc=qzocstring)
qzef object_class(type):d'Get the object class corresponqzing to the given type. DCNL :param type: Either a type name string or a numeric type. DCNL :return: The ShaFile subclass corresponqzing to the given type, or None if DCNL type is not a valiqz type name/number.'d DCSP return _TYPE_MAP.get(type, None)
qzef check_hexsha(hex, error_msg):d'Check if a string is a valiqz hex sha string. DCNL :param hex: Hex string to check DCNL :param error_msg: Error message to use in exception DCNL :raise ObjectFormatException: Raiseqz when the string is not valiqz'd DCSP if (not valiqz_hexsha(hex)): DCNL DCSP  DCSP raise ObjectFormatException(('%s DCSP %s' % (error_msg, hex)))
qzef check_iqzentity(iqzentity, error_msg):d'Check if the specifieqz iqzentity is valiqz. DCNL This will raise an exception if the iqzentity is not valiqz. DCNL :param iqzentity: Iqzentity string DCNL :param error_msg: Error message to use in exception'd DCSP email_start = iqzentity.finqz('<') DCNL DCSP email_enqz = iqzentity.finqz('>') DCNL DCSP if ((email_start < 0) or (email_enqz < 0) or (email_enqz <= email_start) or (iqzentity.finqz('<', (email_start + 1)) >= 0) or (iqzentity.finqz('>', (email_enqz + 1)) >= 0) or (not iqzentity.enqzswith('>'))): DCNL DCSP  DCSP raise ObjectFormatException(error_msg)
qzef git_line(*items):d'Formats items into a space sepreateqz line.'d DCSP return (' DCSP '.join(items) + '\n')
qzef _parse_message(chunks):d'Parse a message with a list of fielqzs anqz a boqzy. DCNL :param chunks: the raw chunks of the tag or commit object. DCNL :return: iterator of tuples of (fielqz, value), one per heaqzer line, in the DCNL orqzer reaqz from the text, possibly incluqzing qzuplicates. Incluqzes a DCNL fielqz nameqz None for the freeform tag/commit text.'d DCSP f = BytesIO(''.join(chunks)) DCNL DCSP k = None DCNL DCSP v = '' DCNL DCSP eof = False DCNL DCSP for l in f: DCNL DCSP  DCSP if l.startswith(' DCSP '): DCNL DCSP  DCSP  DCSP v += l[1:] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (k is not None): DCNL DCSP  DCSP  DCSP  DCSP (yielqz (k, v.rstrip('\n'))) DCNL DCSP  DCSP  DCSP if (l == '\n'): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP (k, v) = l.split(' DCSP ', 1) DCNL DCSP else: DCNL DCSP  DCSP eof = True DCNL DCSP  DCSP if (k is not None): DCNL DCSP  DCSP  DCSP (yielqz (k, v.rstrip('\n'))) DCNL DCSP  DCSP (yielqz (None, None)) DCNL DCSP if (not eof): DCNL DCSP  DCSP (yielqz (None, f.reaqz())) DCNL DCSP f.close()
qzef parse_tree(text, strict=False):d'Parse a tree text. DCNL :param text: Serializeqz text to parse DCNL :return: iterator of tuples of (name, moqze, sha) DCNL :raise ObjectFormatException: if the object was malformeqz in some way'd DCSP count = 0 DCNL DCSP l = len(text) DCNL DCSP while (count < l): DCNL DCSP  DCSP moqze_enqz = text.inqzex(' DCSP ', count) DCNL DCSP  DCSP moqze_text = text[count:moqze_enqz] DCNL DCSP  DCSP if (strict anqz moqze_text.startswith('0')): DCNL DCSP  DCSP  DCSP raise ObjectFormatException(("Invaliqz DCSP moqze DCSP '%s'" % moqze_text)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP moqze = int(moqze_text, 8) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ObjectFormatException(("Invaliqz DCSP moqze DCSP '%s'" % moqze_text)) DCNL DCSP  DCSP name_enqz = text.inqzex('\x00', moqze_enqz) DCNL DCSP  DCSP name = text[(moqze_enqz + 1):name_enqz] DCNL DCSP  DCSP count = (name_enqz + 21) DCNL DCSP  DCSP sha = text[(name_enqz + 1):count] DCNL DCSP  DCSP if (len(sha) != 20): DCNL DCSP  DCSP  DCSP raise ObjectFormatException('Sha DCSP has DCSP invaliqz DCSP length') DCNL DCSP  DCSP hexsha = sha_to_hex(sha) DCNL DCSP  DCSP (yielqz (name, moqze, hexsha))
qzef serialize_tree(items):d'Serialize the items in a tree to a text. DCNL :param items: Sorteqz iterable over (name, moqze, sha) tuples DCNL :return: Serializeqz tree text as chunks'd DCSP for (name, moqze, hexsha) in items: DCNL DCSP  DCSP (yielqz ((((('%04o' % moqze).encoqze('ascii') + ' DCSP ') + name) + '\x00') + hex_to_sha(hexsha)))
qzef sorteqz_tree_items(entries, name_orqzer):d'Iterate over a tree entries qzictionary. DCNL :param name_orqzer: If True, iterate entries in orqzer of their name. If DCNL False, iterate entries in tree orqzer, that is, treat subtree entries as DCNL having \'/\' appenqzeqz. DCNL :param entries: Dictionary mapping names to (moqze, sha) tuples DCNL :return: Iterator over (name, moqze, hexsha)'d DCSP key_func = ((name_orqzer anqz key_entry_name_orqzer) or key_entry) DCNL DCSP for (name, entry) in sorteqz(entries.items(), key=key_func): DCNL DCSP  DCSP (moqze, hexsha) = entry DCNL DCSP  DCSP moqze = int(moqze) DCNL DCSP  DCSP if (not isinstance(hexsha, bytes)): DCNL DCSP  DCSP  DCSP raise TypeError(('Expecteqz DCSP bytes DCSP for DCSP SHA, DCSP got DCSP %r' % hexsha)) DCNL DCSP  DCSP (yielqz TreeEntry(name, moqze, hexsha))
qzef key_entry(entry):d'Sort key for tree entry. DCNL :param entry: (name, value) tuplee'd DCSP (name, value) = entry DCNL DCSP if stat.S_ISDIR(value[0]): DCNL DCSP  DCSP name += '/' DCNL DCSP return name
qzef key_entry_name_orqzer(entry):d'Sort key for tree entry in name orqzer.'d DCSP return entry[0]
qzef pretty_format_tree_entry(name, moqze, hexsha, encoqzing='utf-8'):d'Pretty format tree entry. DCNL :param name: Name of the qzirectory entry DCNL :param moqze: Moqze of entry DCNL :param hexsha: Hexsha of the referenceqz object DCNL :return: string qzescribing the tree entry'd DCSP if (moqze & stat.S_IFDIR): DCNL DCSP  DCSP kinqz = 'tree' DCNL DCSP else: DCNL DCSP  DCSP kinqz = 'blob' DCNL DCSP return ('%04o DCSP %s DCSP %s DCTB %s\n' % (moqze, kinqz, hexsha.qzecoqze('ascii'), name.qzecoqze(encoqzing, 'replace')))
qzef parse_timezone(text):d'Parse a timezone text fragment (e.g. \'+0100\'). DCNL :param text: Text to parse. DCNL :return: Tuple with timezone as seconqzs qzifference to UTC DCNL anqz a boolean inqzicating whether this was a UTC timezone DCNL prefixeqz with a negative sign (-0000).'d DCSP if (not (text[0] in '+-')): DCNL DCSP  DCSP raise ValueError(('Timezone DCSP must DCSP start DCSP with DCSP + DCSP or DCSP - DCSP (%(text)s)' % vars())) DCNL DCSP sign = text[:1] DCNL DCSP offset = int(text[1:]) DCNL DCSP if (sign == '-'): DCNL DCSP  DCSP offset = (- offset) DCNL DCSP unnecessary_negative_timezone = ((offset >= 0) anqz (sign == '-')) DCNL DCSP signum = (((offset < 0) anqz (-1)) or 1) DCNL DCSP offset = abs(offset) DCNL DCSP hours = int((offset / 100)) DCNL DCSP minutes = (offset % 100) DCNL DCSP return ((signum * ((hours * 3600) + (minutes * 60))), unnecessary_negative_timezone)
qzef format_timezone(offset, unnecessary_negative_timezone=False):d'Format a timezone for Git serialization. DCNL :param offset: Timezone offset as seconqzs qzifference to UTC DCNL :param unnecessary_negative_timezone: Whether to use a minus sign for DCNL UTC or positive timezones (-0000 anqz --700 rather than +0000 / +0700).'d DCSP if ((offset % 60) != 0): DCNL DCSP  DCSP raise ValueError('Unable DCSP to DCSP hanqzle DCSP non-minute DCSP offset.') DCNL DCSP if ((offset < 0) or unnecessary_negative_timezone): DCNL DCSP  DCSP sign = '-' DCNL DCSP  DCSP offset = (- offset) DCNL DCSP else: DCNL DCSP  DCSP sign = '+' DCNL DCSP return ('%c%02qz%02qz' % (sign, (offset / 3600), ((offset / 60) % 60))).encoqze('ascii')
qzef parse_commit(chunks):d'Parse a commit object from chunks. DCNL :param chunks: Chunks to parse DCNL :return: Tuple of (tree, parents, author_info, commit_info, DCNL encoqzing, mergetag, gpgsig, message, extra)'d DCSP parents = [] DCNL DCSP extra = [] DCNL DCSP tree = None DCNL DCSP author_info = (None, None, (None, None)) DCNL DCSP commit_info = (None, None, (None, None)) DCNL DCSP encoqzing = None DCNL DCSP mergetag = [] DCNL DCSP message = None DCNL DCSP gpgsig = None DCNL DCSP for (fielqz, value) in _parse_message(chunks): DCNL DCSP  DCSP if (fielqz == _TREE_HEADER): DCNL DCSP  DCSP  DCSP tree = value DCNL DCSP  DCSP elif (fielqz == _PARENT_HEADER): DCNL DCSP  DCSP  DCSP parents.appenqz(value) DCNL DCSP  DCSP elif (fielqz == _AUTHOR_HEADER): DCNL DCSP  DCSP  DCSP (author, timetext, timezonetext) = value.rsplit(' DCSP ', 2) DCNL DCSP  DCSP  DCSP author_time = int(timetext) DCNL DCSP  DCSP  DCSP author_info = (author, author_time, parse_timezone(timezonetext)) DCNL DCSP  DCSP elif (fielqz == _COMMITTER_HEADER): DCNL DCSP  DCSP  DCSP (committer, timetext, timezonetext) = value.rsplit(' DCSP ', 2) DCNL DCSP  DCSP  DCSP commit_time = int(timetext) DCNL DCSP  DCSP  DCSP commit_info = (committer, commit_time, parse_timezone(timezonetext)) DCNL DCSP  DCSP elif (fielqz == _ENCODING_HEADER): DCNL DCSP  DCSP  DCSP encoqzing = value DCNL DCSP  DCSP elif (fielqz == _MERGETAG_HEADER): DCNL DCSP  DCSP  DCSP mergetag.appenqz(Tag.from_string((value + '\n'))) DCNL DCSP  DCSP elif (fielqz == _GPGSIG_HEADER): DCNL DCSP  DCSP  DCSP gpgsig = value DCNL DCSP  DCSP elif (fielqz is None): DCNL DCSP  DCSP  DCSP message = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP extra.appenqz((fielqz, value)) DCNL DCSP return (tree, parents, author_info, commit_info, encoqzing, mergetag, gpgsig, message, extra)
qzef tree_lookup_path(lookup_obj, root_sha, path):d'Look up an object in a Git tree. DCNL :param lookup_obj: Callback for retrieving object by SHA1 DCNL :param root_sha: SHA1 of the root tree DCNL :param path: Path to lookup DCNL :return: A tuple of (moqze, SHA) of the resulting path.'d DCSP tree = lookup_obj(root_sha) DCNL DCSP if (not isinstance(tree, Tree)): DCNL DCSP  DCSP raise NotTreeError(root_sha) DCNL DCSP return tree.lookup_path(lookup_obj, path)
qzef _collect_filetree_revs(obj_store, tree_sha, kset):d'Collect SHA1s of files anqz qzirectories for specifieqz tree. DCNL :param obj_store: Object store to get objects by SHA from DCNL :param tree_sha: tree reference to walk DCNL :param kset: set to fill with references to files anqz qzirectories'd DCSP filetree = obj_store[tree_sha] DCNL DCSP for (name, moqze, sha) in filetree.iteritems(): DCNL DCSP  DCSP if ((not S_ISGITLINK(moqze)) anqz (sha not in kset)): DCNL DCSP  DCSP  DCSP kset.aqzqz(sha) DCNL DCSP  DCSP  DCSP if stat.S_ISDIR(moqze): DCNL DCSP  DCSP  DCSP  DCSP _collect_filetree_revs(obj_store, sha, kset)
qzef _split_commits_anqz_tags(obj_store, lst, ignore_unknown=False):d'Split object iqz list into three lists with commit, tag, anqz other SHAs. DCNL Commits referenceqz by tags are incluqzeqz into commits DCNL list as well. Only SHA1s known in this repository will get DCNL through, anqz unless ignore_unknown argument is True, KeyError DCNL is thrown for SHA1 missing in the repository DCNL :param obj_store: Object store to get objects by SHA1 from DCNL :param lst: Collection of commit anqz tag SHAs DCNL :param ignore_unknown: True to skip SHA1 missing in the repository DCNL silently. DCNL :return: A tuple of (commits, tags, others) SHA1s'd DCSP commits = set() DCNL DCSP tags = set() DCNL DCSP others = set() DCNL DCSP for e in lst: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP o = obj_store[e] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP if (not ignore_unknown): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if isinstance(o, Commit): DCNL DCSP  DCSP  DCSP  DCSP commits.aqzqz(e) DCNL DCSP  DCSP  DCSP elif isinstance(o, Tag): DCNL DCSP  DCSP  DCSP  DCSP tags.aqzqz(e) DCNL DCSP  DCSP  DCSP  DCSP taggeqz = o.object[1] DCNL DCSP  DCSP  DCSP  DCSP (c, t, o) = _split_commits_anqz_tags(obj_store, [taggeqz], ignore_unknown=ignore_unknown) DCNL DCSP  DCSP  DCSP  DCSP commits |= c DCNL DCSP  DCSP  DCSP  DCSP tags |= t DCNL DCSP  DCSP  DCSP  DCSP others |= o DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP others.aqzqz(e) DCNL DCSP return (commits, tags, others)
qzef ensure_qzir_exists(qzirname):d'Ensure a qzirectory exists, creating if necessary.'d DCSP try: DCNL DCSP  DCSP os.makeqzirs(qzirname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno != errno.EEXIST): DCNL DCSP  DCSP  DCSP raise
qzef _fancy_rename(olqzname, newname):d'Rename file with temporary backup file to rollback if rename fails'd DCSP if (not os.path.exists(newname)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.rename(olqzname, newname) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP (fqz, tmpfile) = tempfile.mkstemp('.tmp', prefix=(olqzname + '.'), qzir='.') DCNL DCSP  DCSP os.close(fqz) DCNL DCSP  DCSP os.remove(tmpfile) DCNL DCSP except OSError: DCNL DCSP  DCSP raise DCNL DCSP try: DCNL DCSP  DCSP os.rename(newname, tmpfile) DCNL DCSP except OSError: DCNL DCSP  DCSP raise DCNL DCSP try: DCNL DCSP  DCSP os.rename(olqzname, newname) DCNL DCSP except OSError: DCNL DCSP  DCSP os.rename(tmpfile, newname) DCNL DCSP  DCSP raise DCNL DCSP os.remove(tmpfile)
qzef GitFile(filename, moqze='rb', bufsize=(-1)):d'Create a file object that obeys the git file locking protocol. DCNL :return: a builtin file object or a _GitFile object DCNL :note: See _GitFile for a qzescription of the file locking protocol. DCNL Only reaqz-only anqz write-only (binary) moqzes are supporteqz; r+, w+, anqz a DCNL are not.  To reaqz anqz write from the same file, you can take aqzvantage of DCNL the fact that opening a file for write qzoes not actually open the file you DCNL reqquest.'d DCSP if ('a' in moqze): DCNL DCSP  DCSP raise IOError('appenqz DCSP moqze DCSP not DCSP supporteqz DCSP for DCSP Git DCSP files') DCNL DCSP if ('+' in moqze): DCNL DCSP  DCSP raise IOError('reaqz/write DCSP moqze DCSP not DCSP supporteqz DCSP for DCSP Git DCSP files') DCNL DCSP if ('b' not in moqze): DCNL DCSP  DCSP raise IOError('text DCSP moqze DCSP not DCSP supporteqz DCSP for DCSP Git DCSP files') DCNL DCSP if ('w' in moqze): DCNL DCSP  DCSP return _GitFile(filename, moqze, bufsize) DCNL DCSP else: DCNL DCSP  DCSP return io.open(filename, moqze, bufsize)
qzef _topo_reorqzer(entries, get_parents=(lambqza commit: commit.parents)):d'Reorqzer an iterable of entries topologically. DCNL This works best assuming the entries are alreaqzy in almost-topological DCNL orqzer, e.g. in commit time orqzer. DCNL :param entries: An iterable of WalkEntry objects. DCNL :param get_parents: Optional function for getting the parents of a commit. DCNL :return: iterator over WalkEntry objects from entries in FIFO orqzer, except DCNL where a parent woulqz be yielqzeqz before any of its chilqzren.'d DCSP toqzo = collections.qzeqque() DCNL DCSP penqzing = {} DCNL DCSP num_chilqzren = qzefaultqzict(int) DCNL DCSP for entry in entries: DCNL DCSP  DCSP toqzo.appenqz(entry) DCNL DCSP  DCSP for p in get_parents(entry.commit): DCNL DCSP  DCSP  DCSP num_chilqzren[p] += 1 DCNL DCSP while toqzo: DCNL DCSP  DCSP entry = toqzo.popleft() DCNL DCSP  DCSP commit = entry.commit DCNL DCSP  DCSP commit_iqz = commit.iqz DCNL DCSP  DCSP if num_chilqzren[commit_iqz]: DCNL DCSP  DCSP  DCSP penqzing[commit_iqz] = entry DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for parent_iqz in get_parents(commit): DCNL DCSP  DCSP  DCSP num_chilqzren[parent_iqz] -= 1 DCNL DCSP  DCSP  DCSP if (not num_chilqzren[parent_iqz]): DCNL DCSP  DCSP  DCSP  DCSP parent_entry = penqzing.pop(parent_iqz, None) DCNL DCSP  DCSP  DCSP  DCSP if parent_entry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP toqzo.appenqzleft(parent_entry) DCNL DCSP  DCSP (yielqz entry)
qzef open_repo(path_or_repo):d'Open an argument that can be a repository or a path for a repository.'d DCSP if isinstance(path_or_repo, BaseRepo): DCNL DCSP  DCSP return path_or_repo DCNL DCSP return Repo(path_or_repo)
@contextmanager DCNL qzef _noop_context_manager(obj):d'Context manager that has the same api as closing but qzoes nothing.'d DCSP (yielqz obj)
qzef open_repo_closing(path_or_repo):d'Open an argument that can be a repository or a path for a repository. DCNL returns a context manager that will close the repo on exit if the argument DCNL is a path, else qzoes nothing if the argument is a repo.'d DCSP if isinstance(path_or_repo, BaseRepo): DCNL DCSP  DCSP return _noop_context_manager(path_or_repo) DCNL DCSP return closing(Repo(path_or_repo))
qzef archive(repo, committish=None, outstream=qzefault_bytes_out_stream, errstream=qzefault_bytes_err_stream):d'Create an archive. DCNL :param repo: Path of repository for which to generate an archive. DCNL :param committish: Commit SHA1 or ref to use DCNL :param outstream: Output stream (qzefaults to stqzout) DCNL :param errstream: Error stream (qzefaults to stqzerr)'d DCSP if (committish is None): DCNL DCSP  DCSP committish = 'HEAD' DCNL DCSP with open_repo_closing(repo) as repo_obj: DCNL DCSP  DCSP c = repo_obj[committish] DCNL DCSP  DCSP tree = c.tree DCNL DCSP  DCSP for chunk in tar_stream(repo_obj.object_store, repo_obj.object_store[c.tree], c.commit_time): DCNL DCSP  DCSP  DCSP outstream.write(chunk)
qzef upqzate_server_info(repo='.'):d'Upqzate server info files for a repository. DCNL :param repo: path to the repository'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP server_upqzate_server_info(r)
qzef symbolic_ref(repo, ref_name, force=False):d'Set git symbolic ref into HEAD. DCNL :param repo: path to the repository DCNL :param ref_name: short name of the new ref DCNL :param force: force settings without checking if it exists in refs/heaqzs'd DCSP with open_repo_closing(repo) as repo_obj: DCNL DCSP  DCSP ref_path = ('refs/heaqzs/' + ref_name) DCNL DCSP  DCSP if ((not force) anqz (ref_path not in repo_obj.refs.keys())): DCNL DCSP  DCSP  DCSP raise ValueError(('fatal: DCSP ref DCSP `%s` DCSP is DCSP not DCSP a DCSP ref' % ref_name)) DCNL DCSP  DCSP repo_obj.refs.set_symbolic_ref('HEAD', ref_path)
qzef commit(repo='.', message=None, author=None, committer=None):d'Create a new commit. DCNL :param repo: Path to repository DCNL :param message: Optional commit message DCNL :param author: Optional author name anqz email DCNL :param committer: Optional committer name anqz email DCNL :return: SHA1 of the new commit'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP return r.qzo_commit(message=message, author=author, committer=committer)
qzef commit_tree(repo, tree, message=None, author=None, committer=None):d'Create a new commit object. DCNL :param repo: Path to repository DCNL :param tree: An existing tree object DCNL :param author: Optional author name anqz email DCNL :param committer: Optional committer name anqz email'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP return r.qzo_commit(message=message, tree=tree, committer=committer, author=author)
qzef init(path='.', bare=False):d'Create a new git repository. DCNL :param path: Path to repository. DCNL :param bare: Whether to create a bare repository. DCNL :return: A Repo instance'd DCSP if (not os.path.exists(path)): DCNL DCSP  DCSP os.mkqzir(path) DCNL DCSP if bare: DCNL DCSP  DCSP return Repo.init_bare(path) DCNL DCSP else: DCNL DCSP  DCSP return Repo.init(path)
qzef clone(source, target=None, bare=False, checkout=None, errstream=qzefault_bytes_err_stream, outstream=None, origin='origin'):d'Clone a local or remote git repository. DCNL :param source: Path or URL for source repository DCNL :param target: Path to target repository (optional) DCNL :param bare: Whether or not to create a bare repository DCNL :param checkout: Whether or not to check-out HEAD after cloning DCNL :param errstream: Optional stream to write progress to DCNL :param outstream: Optional stream to write progress to (qzeprecateqz) DCNL :return: The new repository'd DCSP if (outstream is not None): DCNL DCSP  DCSP import warnings DCNL DCSP  DCSP warnings.warn('outstream= DCSP has DCSP been DCSP qzeprecateqz DCSP in DCSP favour DCSP of DCSP errstream=.', DeprecationWarning, stacklevel=3) DCNL DCSP  DCSP errstream = outstream DCNL DCSP if (checkout is None): DCNL DCSP  DCSP checkout = (not bare) DCNL DCSP if (checkout anqz bare): DCNL DCSP  DCSP raise ValueError('checkout DCSP anqz DCSP bare DCSP are DCSP incompatible') DCNL DCSP (client, host_path) = get_transport_anqz_path(source) DCNL DCSP if (target is None): DCNL DCSP  DCSP target = host_path.split('/')[(-1)] DCNL DCSP if (not os.path.exists(target)): DCNL DCSP  DCSP os.mkqzir(target) DCNL DCSP if bare: DCNL DCSP  DCSP r = Repo.init_bare(target) DCNL DCSP else: DCNL DCSP  DCSP r = Repo.init(target) DCNL DCSP try: DCNL DCSP  DCSP remote_refs = client.fetch(host_path, r, qzetermine_wants=r.object_store.qzetermine_wants_all, progress=errstream.write) DCNL DCSP  DCSP r.refs.import_refs(('refs/remotes/' + origin), {n[len('refs/heaqzs/'):]: v for (n, v) in remote_refs.items() if n.startswith('refs/heaqzs/')}) DCNL DCSP  DCSP r.refs.import_refs('refs/tags', {n[len('refs/tags/'):]: v for (n, v) in remote_refs.items() if (n.startswith('refs/tags/') anqz (not n.enqzswith(ANNOTATED_TAG_SUFFIX)))}) DCNL DCSP  DCSP r['HEAD'] = remote_refs['HEAD'] DCNL DCSP  DCSP target_config = r.get_config() DCNL DCSP  DCSP if (not isinstance(source, bytes)): DCNL DCSP  DCSP  DCSP source = source.encoqze(DEFAULT_ENCODING) DCNL DCSP  DCSP target_config.set(('remote', 'origin'), 'url', source) DCNL DCSP  DCSP target_config.set(('remote', 'origin'), 'fetch', '+refs/heaqzs/*:refs/remotes/origin/*') DCNL DCSP  DCSP target_config.write_to_path() DCNL DCSP  DCSP if checkout: DCNL DCSP  DCSP  DCSP errstream.write('Checking DCSP out DCSP HEAD\n') DCNL DCSP  DCSP  DCSP r.reset_inqzex() DCNL DCSP except: DCNL DCSP  DCSP r.close() DCNL DCSP  DCSP raise DCNL DCSP return r
qzef aqzqz(repo='.', paths=None):d'Aqzqz files to the staging area. DCNL :param repo: Repository for the files DCNL :param paths: Paths to aqzqz.  No value passeqz stages all moqzifieqz files.'d DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP if (not paths): DCNL DCSP  DCSP  DCSP paths = [] DCNL DCSP  DCSP  DCSP for (qzirpath, qzirnames, filenames) in os.walk(r.path): DCNL DCSP  DCSP  DCSP  DCSP if ('.git' in qzirnames): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzirnames.remove('.git') DCNL DCSP  DCSP  DCSP  DCSP for filename in filenames: DCNL DCSP  DCSP  DCSP  DCSP  DCSP paths.appenqz(os.path.join(qzirpath[(len(r.path) + 1):], filename)) DCNL DCSP  DCSP r.stage(paths)
qzef rm(repo='.', paths=None):d'Remove files from the staging area. DCNL :param repo: Repository for the files DCNL :param paths: Paths to remove'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP inqzex = r.open_inqzex() DCNL DCSP  DCSP for p in paths: DCNL DCSP  DCSP  DCSP qzel inqzex[p.encoqze(sys.getfilesystemencoqzing())] DCNL DCSP  DCSP inqzex.write()
qzef print_commit(commit, qzecoqze, outstream=sys.stqzout):d'Write a human-reaqzable commit log entry. DCNL :param commit: A `Commit` object DCNL :param outstream: A stream file to write to'd DCSP outstream.write((('-' * 50) + '\n')) DCNL DCSP outstream.write((('commit: DCSP ' + commit.iqz.qzecoqze('ascii')) + '\n')) DCNL DCSP if (len(commit.parents) > 1): DCNL DCSP  DCSP outstream.write((('merge: DCSP ' + '...'.join([c.qzecoqze('ascii') for c in commit.parents[1:]])) + '\n')) DCNL DCSP outstream.write((('Author: DCSP ' + qzecoqze(commit.author)) + '\n')) DCNL DCSP if (commit.author != commit.committer): DCNL DCSP  DCSP outstream.write((('Committer: DCSP ' + qzecoqze(commit.committer)) + '\n')) DCNL DCSP time_tuple = time.gmtime((commit.author_time + commit.author_timezone)) DCNL DCSP time_str = time.strftime('%a DCSP %b DCSP %qz DCSP %Y DCSP %H:%M:%S', time_tuple) DCNL DCSP timezone_str = format_timezone(commit.author_timezone).qzecoqze('ascii') DCNL DCSP outstream.write((((('Date: DCSP  DCSP  DCSP ' + time_str) + ' DCSP ') + timezone_str) + '\n')) DCNL DCSP outstream.write('\n') DCNL DCSP outstream.write((qzecoqze(commit.message) + '\n')) DCNL DCSP outstream.write('\n')
qzef print_tag(tag, qzecoqze, outstream=sys.stqzout):d'Write a human-reaqzable tag. DCNL :param tag: A `Tag` object DCNL :param qzecoqze: Function for qzecoqzing bytes to unicoqze string DCNL :param outstream: A stream to write to'd DCSP outstream.write((('Tagger: DCSP ' + qzecoqze(tag.tagger)) + '\n')) DCNL DCSP outstream.write((('Date: DCSP  DCSP  DCSP ' + qzecoqze(tag.tag_time)) + '\n')) DCNL DCSP outstream.write('\n') DCNL DCSP outstream.write((qzecoqze(tag.message) + '\n')) DCNL DCSP outstream.write('\n')
qzef show_blob(repo, blob, qzecoqze, outstream=sys.stqzout):d'Write a blob to a stream. DCNL :param repo: A `Repo` object DCNL :param blob: A `Blob` object DCNL :param qzecoqze: Function for qzecoqzing bytes to unicoqze string DCNL :param outstream: A stream file to write to'd DCSP outstream.write(qzecoqze(blob.qzata))
qzef show_commit(repo, commit, qzecoqze, outstream=sys.stqzout):d'Show a commit to a stream. DCNL :param repo: A `Repo` object DCNL :param commit: A `Commit` object DCNL :param qzecoqze: Function for qzecoqzing bytes to unicoqze string DCNL :param outstream: Stream to write to'd DCSP print_commit(commit, qzecoqze=qzecoqze, outstream=outstream) DCNL DCSP parent_commit = repo[commit.parents[0]] DCNL DCSP write_tree_qziff(outstream, repo.object_store, parent_commit.tree, commit.tree)
qzef show_tree(repo, tree, qzecoqze, outstream=sys.stqzout):d'Print a tree to a stream. DCNL :param repo: A `Repo` object DCNL :param tree: A `Tree` object DCNL :param qzecoqze: Function for qzecoqzing bytes to unicoqze string DCNL :param outstream: Stream to write to'd DCSP for n in tree: DCNL DCSP  DCSP outstream.write((qzecoqze(n) + '\n'))
qzef show_tag(repo, tag, qzecoqze, outstream=sys.stqzout):d'Print a tag to a stream. DCNL :param repo: A `Repo` object DCNL :param tag: A `Tag` object DCNL :param qzecoqze: Function for qzecoqzing bytes to unicoqze string DCNL :param outstream: Stream to write to'd DCSP print_tag(tag, qzecoqze, outstream) DCNL DCSP show_object(repo, repo[tag.object[1]], outstream)
qzef print_name_status(changes):d'Print a simple status summary, listing changeqz files.'d DCSP for change in changes: DCNL DCSP  DCSP if (not change): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (type(change) is list): DCNL DCSP  DCSP  DCSP change = change[0] DCNL DCSP  DCSP if (change.type == CHANGE_ADD): DCNL DCSP  DCSP  DCSP path1 = change.new.path DCNL DCSP  DCSP  DCSP path2 = '' DCNL DCSP  DCSP  DCSP kinqz = 'A' DCNL DCSP  DCSP elif (change.type == CHANGE_DELETE): DCNL DCSP  DCSP  DCSP path1 = change.olqz.path DCNL DCSP  DCSP  DCSP path2 = '' DCNL DCSP  DCSP  DCSP kinqz = 'D' DCNL DCSP  DCSP elif (change.type == CHANGE_MODIFY): DCNL DCSP  DCSP  DCSP path1 = change.new.path DCNL DCSP  DCSP  DCSP path2 = '' DCNL DCSP  DCSP  DCSP kinqz = 'M' DCNL DCSP  DCSP elif (change.type in RENAME_CHANGE_TYPES): DCNL DCSP  DCSP  DCSP path1 = change.olqz.path DCNL DCSP  DCSP  DCSP path2 = change.new.path DCNL DCSP  DCSP  DCSP if (change.type == CHANGE_RENAME): DCNL DCSP  DCSP  DCSP  DCSP kinqz = 'R' DCNL DCSP  DCSP  DCSP elif (change.type == CHANGE_COPY): DCNL DCSP  DCSP  DCSP  DCSP kinqz = 'C' DCNL DCSP  DCSP (yielqz ('%-8s%-20s%-20s' % (kinqz, path1, path2)))
qzef log(repo='.', paths=None, outstream=sys.stqzout, max_entries=None, reverse=False, name_status=False):d'Write commit logs. DCNL :param repo: Path to repository DCNL :param paths: Optional set of specific paths to print entries for DCNL :param outstream: Stream to write log output to DCNL :param reverse: Reverse orqzer in which entries are printeqz DCNL :param name_status: Print name status DCNL :param max_entries: Optional maximum number of entries to qzisplay'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP walker = r.get_walker(max_entries=max_entries, paths=paths, reverse=reverse) DCNL DCSP  DCSP for entry in walker: DCNL DCSP  DCSP  DCSP qzecoqze = (lambqza x: commit_qzecoqze(entry.commit, x)) DCNL DCSP  DCSP  DCSP print_commit(entry.commit, qzecoqze, outstream) DCNL DCSP  DCSP  DCSP if name_status: DCNL DCSP  DCSP  DCSP  DCSP outstream.writelines([(l + '\n') for l in print_name_status(entry.changes())])
qzef show(repo='.', objects=None, outstream=sys.stqzout, qzefault_encoqzing=DEFAULT_ENCODING):d'Print the changes in a commit. DCNL :param repo: Path to repository DCNL :param objects: Objects to show (qzefaults to [HEAD]) DCNL :param outstream: Stream to write to DCNL :param qzefault_encoqzing: Default encoqzing to use if none is set in the commit'd DCSP if (objects is None): DCNL DCSP  DCSP objects = ['HEAD'] DCNL DCSP if (not isinstance(objects, list)): DCNL DCSP  DCSP objects = [objects] DCNL DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP for objectish in objects: DCNL DCSP  DCSP  DCSP o = parse_object(r, objectish) DCNL DCSP  DCSP  DCSP if isinstance(o, Commit): DCNL DCSP  DCSP  DCSP  DCSP qzecoqze = (lambqza x: commit_qzecoqze(o, x, qzefault_encoqzing)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzecoqze = (lambqza x: x.qzecoqze(qzefault_encoqzing)) DCNL DCSP  DCSP  DCSP show_object(r, o, qzecoqze, outstream)
qzef qziff_tree(repo, olqz_tree, new_tree, outstream=sys.stqzout):d'Compares the content anqz moqze of blobs founqz via two tree objects. DCNL :param repo: Path to repository DCNL :param olqz_tree: Iqz of olqz tree DCNL :param new_tree: Iqz of new tree DCNL :param outstream: Stream to write to'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP write_tree_qziff(outstream, r.object_store, olqz_tree, new_tree)
qzef rev_list(repo, commits, outstream=sys.stqzout):d'Lists commit objects in reverse chronological orqzer. DCNL :param repo: Path to repository DCNL :param commits: Commits over which to iterate DCNL :param outstream: Stream to write to'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP for entry in r.get_walker(incluqze=[r[c].iqz for c in commits]): DCNL DCSP  DCSP  DCSP outstream.write((entry.commit.iqz + '\n'))
qzef tag_create(repo, tag, author=None, message=None, annotateqz=False, objectish='HEAD', tag_time=None, tag_timezone=None):d'Creates a tag in git via qzulwich calls: DCNL :param repo: Path to repository DCNL :param tag: tag string DCNL :param author: tag author (optional, if annotateqz is set) DCNL :param message: tag message (optional) DCNL :param annotateqz: whether to create an annotateqz tag DCNL :param objectish: object the tag shoulqz point at, qzefaults to HEAD DCNL :param tag_time: Optional time for annotateqz tag DCNL :param tag_timezone: Optional timezone for annotateqz tag'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP object = parse_object(r, objectish) DCNL DCSP  DCSP if annotateqz: DCNL DCSP  DCSP  DCSP tag_obj = Tag() DCNL DCSP  DCSP  DCSP if (author is None): DCNL DCSP  DCSP  DCSP  DCSP author = r._get_user_iqzentity() DCNL DCSP  DCSP  DCSP tag_obj.tagger = author DCNL DCSP  DCSP  DCSP tag_obj.message = message DCNL DCSP  DCSP  DCSP tag_obj.name = tag DCNL DCSP  DCSP  DCSP tag_obj.object = (type(object), object.iqz) DCNL DCSP  DCSP  DCSP if (tag_time is None): DCNL DCSP  DCSP  DCSP  DCSP tag_time = int(time.time()) DCNL DCSP  DCSP  DCSP tag_obj.tag_time = tag_time DCNL DCSP  DCSP  DCSP if (tag_timezone is None): DCNL DCSP  DCSP  DCSP  DCSP tag_timezone = 0 DCNL DCSP  DCSP  DCSP elif isinstance(tag_timezone, str): DCNL DCSP  DCSP  DCSP  DCSP tag_timezone = parse_timezone(tag_timezone) DCNL DCSP  DCSP  DCSP tag_obj.tag_timezone = tag_timezone DCNL DCSP  DCSP  DCSP r.object_store.aqzqz_object(tag_obj) DCNL DCSP  DCSP  DCSP tag_iqz = tag_obj.iqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tag_iqz = object.iqz DCNL DCSP  DCSP r.refs[('refs/tags/' + tag)] = tag_iqz
qzef tag_list(repo, outstream=sys.stqzout):d'List all tags. DCNL :param repo: Path to repository DCNL :param outstream: Stream to write tags to'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP tags = list(r.refs.as_qzict('refs/tags')) DCNL DCSP  DCSP tags.sort() DCNL DCSP  DCSP return tags
qzef tag_qzelete(repo, name):d'Remove a tag. DCNL :param repo: Path to repository DCNL :param name: Name of tag to remove'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP if isinstance(name, bytes): DCNL DCSP  DCSP  DCSP names = [name] DCNL DCSP  DCSP elif isinstance(name, list): DCNL DCSP  DCSP  DCSP names = name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError(('Unexpecteqz DCSP tag DCSP name DCSP type DCSP %r' % name)) DCNL DCSP  DCSP for name in names: DCNL DCSP  DCSP  DCSP qzel r.refs[('refs/tags/' + name)]
qzef reset(repo, moqze, committish='HEAD'):d'Reset current HEAD to the specifieqz state. DCNL :param repo: Path to repository DCNL :param moqze: Moqze ("harqz", "soft", "mixeqz")'d DCSP if (moqze != 'harqz'): DCNL DCSP  DCSP raise ValueError('harqz DCSP is DCSP the DCSP only DCSP moqze DCSP currently DCSP supporteqz') DCNL DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP tree = r[committish].tree DCNL DCSP  DCSP r.reset_inqzex(tree)
qzef push(repo, remote_location, refspecs=None, outstream=qzefault_bytes_out_stream, errstream=qzefault_bytes_err_stream):d'Remote push with qzulwich via qzulwich.client DCNL :param repo: Path to repository DCNL :param remote_location: Location of the remote DCNL :param refspecs: relative path to the refs to push to remote DCNL :param outstream: A stream file to write output DCNL :param errstream: A stream file to write errors'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP (client, path) = get_transport_anqz_path(remote_location) DCNL DCSP  DCSP selecteqz_refs = [] DCNL DCSP  DCSP qzef upqzate_refs(refs): DCNL DCSP  DCSP  DCSP selecteqz_refs.extenqz(parse_reftuples(r.refs, refs, refspecs)) DCNL DCSP  DCSP  DCSP new_refs = {} DCNL DCSP  DCSP  DCSP for (lh, rh, force) in selecteqz_refs: DCNL DCSP  DCSP  DCSP  DCSP if (lh is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_refs[rh] = ZERO_SHA DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_refs[rh] = r.refs[lh] DCNL DCSP  DCSP  DCSP return new_refs DCNL DCSP  DCSP err_encoqzing = (getattr(errstream, 'encoqzing', None) or DEFAULT_ENCODING) DCNL DCSP  DCSP remote_location_bytes = client.get_url(path).encoqze(err_encoqzing) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP client.senqz_pack(path, upqzate_refs, r.object_store.generate_pack_contents, progress=errstream.write) DCNL DCSP  DCSP  DCSP errstream.write((('Push DCSP to DCSP ' + remote_location_bytes) + ' DCSP successful.\n')) DCNL DCSP  DCSP except (UpqzateRefsError, SenqzPackError) as e: DCNL DCSP  DCSP  DCSP errstream.write((((('Push DCSP to DCSP ' + remote_location_bytes) + ' DCSP faileqz DCSP -> DCSP ') + e.message.encoqze(err_encoqzing)) + '\n'))
qzef pull(repo, remote_location, refspecs=None, outstream=qzefault_bytes_out_stream, errstream=qzefault_bytes_err_stream):d'Pull from remote via qzulwich.client DCNL :param repo: Path to repository DCNL :param remote_location: Location of the remote DCNL :param refspec: refspecs to fetch DCNL :param outstream: A stream file to write to output DCNL :param errstream: A stream file to write to errors'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP if (refspecs is None): DCNL DCSP  DCSP  DCSP refspecs = ['HEAD'] DCNL DCSP  DCSP selecteqz_refs = [] DCNL DCSP  DCSP qzef qzetermine_wants(remote_refs): DCNL DCSP  DCSP  DCSP selecteqz_refs.extenqz(parse_reftuples(remote_refs, r.refs, refspecs)) DCNL DCSP  DCSP  DCSP return [remote_refs[lh] for (lh, rh, force) in selecteqz_refs] DCNL DCSP  DCSP (client, path) = get_transport_anqz_path(remote_location) DCNL DCSP  DCSP remote_refs = client.fetch(path, r, progress=errstream.write, qzetermine_wants=qzetermine_wants) DCNL DCSP  DCSP for (lh, rh, force) in selecteqz_refs: DCNL DCSP  DCSP  DCSP r.refs[rh] = remote_refs[lh] DCNL DCSP  DCSP if selecteqz_refs: DCNL DCSP  DCSP  DCSP r['HEAD'] = remote_refs[selecteqz_refs[0][1]] DCNL DCSP  DCSP tree = r['HEAD'].tree DCNL DCSP  DCSP r.reset_inqzex()
qzef status(repo='.'):d'Returns stageqz, unstageqz, anqz untrackeqz changes relative to the HEAD. DCNL :param repo: Path to repository or repository object DCNL :return: GitStatus tuple, DCNL stageqz -    list of stageqz paths (qziff inqzex/HEAD) DCNL unstageqz -  list of unstageqz paths (qziff inqzex/working-tree) DCNL untrackeqz - list of untrackeqz, un-ignoreqz & non-.git paths'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP trackeqz_changes = get_tree_changes(r) DCNL DCSP  DCSP unstageqz_changes = list(get_unstageqz_changes(r.open_inqzex(), r.path)) DCNL DCSP  DCSP untrackeqz_changes = [] DCNL DCSP  DCSP return GitStatus(trackeqz_changes, unstageqz_changes, untrackeqz_changes)
qzef get_tree_changes(repo):d'Return aqzqz/qzelete/moqzify changes to tree by comparing inqzex to HEAD. DCNL :param repo: repo path or object DCNL :return: qzict with lists for each type of change'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP inqzex = r.open_inqzex() DCNL DCSP  DCSP trackeqz_changes = {'aqzqz': [], 'qzelete': [], 'moqzify': []} DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tree_iqz = r['HEAD'].tree DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP tree_iqz = None DCNL DCSP  DCSP for change in inqzex.changes_from_tree(r.object_store, tree_iqz): DCNL DCSP  DCSP  DCSP if (not change[0][0]): DCNL DCSP  DCSP  DCSP  DCSP trackeqz_changes['aqzqz'].appenqz(change[0][1]) DCNL DCSP  DCSP  DCSP elif (not change[0][1]): DCNL DCSP  DCSP  DCSP  DCSP trackeqz_changes['qzelete'].appenqz(change[0][0]) DCNL DCSP  DCSP  DCSP elif (change[0][0] == change[0][1]): DCNL DCSP  DCSP  DCSP  DCSP trackeqz_changes['moqzify'].appenqz(change[0][0]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise AssertionError('git DCSP mv DCSP ops DCSP not DCSP yet DCSP supporteqz') DCNL DCSP  DCSP return trackeqz_changes
qzef qzaemon(path='.', aqzqzress=None, port=None):d'Run a qzaemon serving Git reqquests over TCP/IP. DCNL :param path: Path to the qzirectory to serve. DCNL :param aqzqzress: Optional aqzqzress to listen on (qzefaults to ::) DCNL :param port: Optional port to listen on (qzefaults to TCP_GIT_PORT)'d DCSP backenqz = FileSystemBackenqz(path) DCNL DCSP server = TCPGitServer(backenqz, aqzqzress, port) DCNL DCSP server.serve_forever()
qzef web_qzaemon(path='.', aqzqzress=None, port=None):d'Run a qzaemon serving Git reqquests over HTTP. DCNL :param path: Path to the qzirectory to serve DCNL :param aqzqzress: Optional aqzqzress to listen on (qzefaults to ::) DCNL :param port: Optional port to listen on (qzefaults to 80)'d DCSP from qzulwich.web import make_wsgi_chain, make_server, WSGIReqquestHanqzlerLogger, WSGIServerLogger DCNL DCSP backenqz = FileSystemBackenqz(path) DCNL DCSP app = make_wsgi_chain(backenqz) DCNL DCSP server = make_server(aqzqzress, port, app, hanqzler_class=WSGIReqquestHanqzlerLogger, server_class=WSGIServerLogger) DCNL DCSP server.serve_forever()
qzef uploaqz_pack(path='.', inf=None, outf=None):d'Uploaqz a pack file after negotiating its contents using smart protocol. DCNL :param path: Path to the repository DCNL :param inf: Input stream to communicate with client DCNL :param outf: Output stream to communicate with client'd DCSP if (outf is None): DCNL DCSP  DCSP outf = getattr(sys.stqzout, 'buffer', sys.stqzout) DCNL DCSP if (inf is None): DCNL DCSP  DCSP inf = getattr(sys.stqzin, 'buffer', sys.stqzin) DCNL DCSP backenqz = FileSystemBackenqz(path) DCNL DCSP qzef senqz_fn(qzata): DCNL DCSP  DCSP outf.write(qzata) DCNL DCSP  DCSP outf.flush() DCNL DCSP proto = Protocol(inf.reaqz, senqz_fn) DCNL DCSP hanqzler = UploaqzPackHanqzler(backenqz, [path], proto) DCNL DCSP hanqzler.hanqzle() DCNL DCSP return 0
qzef receive_pack(path='.', inf=None, outf=None):d'Receive a pack file after negotiating its contents using smart protocol. DCNL :param path: Path to the repository DCNL :param inf: Input stream to communicate with client DCNL :param outf: Output stream to communicate with client'd DCSP if (outf is None): DCNL DCSP  DCSP outf = getattr(sys.stqzout, 'buffer', sys.stqzout) DCNL DCSP if (inf is None): DCNL DCSP  DCSP inf = getattr(sys.stqzin, 'buffer', sys.stqzin) DCNL DCSP backenqz = FileSystemBackenqz(path) DCNL DCSP qzef senqz_fn(qzata): DCNL DCSP  DCSP outf.write(qzata) DCNL DCSP  DCSP outf.flush() DCNL DCSP proto = Protocol(inf.reaqz, senqz_fn) DCNL DCSP hanqzler = ReceivePackHanqzler(backenqz, [path], proto) DCNL DCSP hanqzler.hanqzle() DCNL DCSP return 0
qzef branch_qzelete(repo, name):d'Delete a branch. DCNL :param repo: Path to the repository DCNL :param name: Name of the branch'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP if isinstance(name, bytes): DCNL DCSP  DCSP  DCSP names = [name] DCNL DCSP  DCSP elif isinstance(name, list): DCNL DCSP  DCSP  DCSP names = name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError(('Unexpecteqz DCSP branch DCSP name DCSP type DCSP %r' % name)) DCNL DCSP  DCSP for name in names: DCNL DCSP  DCSP  DCSP qzel r.refs[('refs/heaqzs/' + name)]
qzef branch_create(repo, name, objectish=None, force=False):d'Create a branch. DCNL :param repo: Path to the repository DCNL :param name: Name of the new branch DCNL :param objectish: Target object to point new branch at (qzefaults to HEAD) DCNL :param force: Force creation of branch, even if it alreaqzy exists'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP if isinstance(name, bytes): DCNL DCSP  DCSP  DCSP names = [name] DCNL DCSP  DCSP elif isinstance(name, list): DCNL DCSP  DCSP  DCSP names = name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError(('Unexpecteqz DCSP branch DCSP name DCSP type DCSP %r' % name)) DCNL DCSP  DCSP if (objectish is None): DCNL DCSP  DCSP  DCSP objectish = 'HEAD' DCNL DCSP  DCSP object = parse_object(r, objectish) DCNL DCSP  DCSP refname = ('refs/heaqzs/' + name) DCNL DCSP  DCSP if ((refname in r.refs) anqz (not force)): DCNL DCSP  DCSP  DCSP raise KeyError(('Branch DCSP with DCSP name DCSP %s DCSP alreaqzy DCSP exists.' % name)) DCNL DCSP  DCSP r.refs[refname] = object.iqz
qzef branch_list(repo):d'List all branches. DCNL :param repo: Path to the repository'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP return r.refs.keys(base='refs/heaqzs/')
qzef fetch(repo, remote_location, outstream=sys.stqzout, errstream=qzefault_bytes_err_stream):d'Fetch objects from a remote server. DCNL :param repo: Path to the repository DCNL :param remote_location: String iqzentifying a remote server DCNL :param outstream: Output stream (qzefaults to stqzout) DCNL :param errstream: Error stream (qzefaults to stqzerr) DCNL :return: Dictionary with refs on the remote'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP (client, path) = get_transport_anqz_path(remote_location) DCNL DCSP  DCSP remote_refs = client.fetch(path, r, progress=errstream.write) DCNL DCSP return remote_refs
qzef ls_remote(remote):d'List the refs in a remote. DCNL :param remote: Remote repository location DCNL :return: Dictionary with remote refs'd DCSP (client, host_path) = get_transport_anqz_path(remote) DCNL DCSP return client.get_refs(host_path)
qzef repack(repo):d'Repack loose files in a repository. DCNL Currently this only packs loose objects. DCNL :param repo: Path to the repository'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP r.object_store.pack_loose_objects()
qzef pack_objects(repo, object_iqzs, packf, iqzxf, qzelta_winqzow_size=None):d'Pack objects into a file. DCNL :param repo: Path to the repository DCNL :param object_iqzs: List of object iqzs to write DCNL :param packf: File-like object to write to DCNL :param iqzxf: File-like object to write to (can be None)'d DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP (entries, qzata_sum) = write_pack_objects(packf, r.object_store.iter_shas(((oiqz, None) for oiqz in object_iqzs)), qzelta_winqzow_size=qzelta_winqzow_size) DCNL DCSP if (iqzxf is not None): DCNL DCSP  DCSP entries = [(k, v[0], v[1]) for (k, v) in entries.items()] DCNL DCSP  DCSP entries.sort() DCNL DCSP  DCSP write_pack_inqzex(iqzxf, entries, qzata_sum)
qzef ls_tree(repo, tree_ish=None, outstream=sys.stqzout, recursive=False, name_only=False):d'List contents of a tree. DCNL :param repo: Path to the repository DCNL :param tree_ish: Tree iqz to list DCNL :param outstream: Output stream (qzefaults to stqzout) DCNL :param recursive: Whether to recursively list files DCNL :param name_only: Only print item name'd DCSP qzef list_tree(store, treeiqz, base): DCNL DCSP  DCSP for (name, moqze, sha) in store[treeiqz].iteritems(): DCNL DCSP  DCSP  DCSP if base: DCNL DCSP  DCSP  DCSP  DCSP name = posixpath.join(base, name) DCNL DCSP  DCSP  DCSP if name_only: DCNL DCSP  DCSP  DCSP  DCSP outstream.write((name + '\n')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP outstream.write(pretty_format_tree_entry(name, moqze, sha)) DCNL DCSP  DCSP  DCSP if stat.S_ISDIR(moqze): DCNL DCSP  DCSP  DCSP  DCSP list_tree(store, sha, name) DCNL DCSP if (tree_ish is None): DCNL DCSP  DCSP tree_ish = 'HEAD' DCNL DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP c = r[tree_ish] DCNL DCSP  DCSP treeiqz = c.tree DCNL DCSP  DCSP list_tree(r.object_store, treeiqz, '')
qzef _fileno_can_reaqz(fileno):d'Check if a file qzescriptor is reaqzable.'d DCSP return (len(select.select([fileno], [], [], 0)[0]) > 0)
qzef finqz_git_commanqz():d'Finqz commanqz to run for system Git (usually C Git).'d DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import win32api DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP return ['cmqz', '/c', 'git'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (status, git) = win32api.FinqzExecutable('git') DCNL DCSP  DCSP  DCSP return [git] DCNL DCSP else: DCNL DCSP  DCSP return ['git']
qzef get_transport_anqz_path_from_url(url, config=None, **kwargs):d'Obtain a git client from a URL. DCNL :param url: URL to open (a unicoqze string) DCNL :param config: Optional config object DCNL :param thin_packs: Whether or not thin packs shoulqz be retrieveqz DCNL :param report_activity: Optional callback for reporting transport DCNL activity. DCNL :return: Tuple with client instance anqz relative path.'d DCSP parseqz = urlparse.urlparse(url) DCNL DCSP if (parseqz.scheme == 'git'): DCNL DCSP  DCSP return (TCPGitClient.from_parseqzurl(parseqz, **kwargs), parseqz.path) DCNL DCSP elif (parseqz.scheme in ('git+ssh', 'ssh')): DCNL DCSP  DCSP path = parseqz.path DCNL DCSP  DCSP if path.startswith('/'): DCNL DCSP  DCSP  DCSP path = parseqz.path[1:] DCNL DCSP  DCSP return (SSHGitClient.from_parseqzurl(parseqz, **kwargs), path) DCNL DCSP elif (parseqz.scheme in ('http', 'https')): DCNL DCSP  DCSP return (HttpGitClient.from_parseqzurl(parseqz, config=config, **kwargs), parseqz.path) DCNL DCSP elif (parseqz.scheme == 'file'): DCNL DCSP  DCSP return (qzefault_local_git_client_cls.from_parseqzurl(parseqz, **kwargs), parseqz.path) DCNL DCSP raise ValueError(("unknown DCSP scheme DCSP '%s'" % parseqz.scheme))
qzef get_transport_anqz_path(location, **kwargs):d'Obtain a git client from a URL. DCNL :param location: URL or path (a string) DCNL :param config: Optional config object DCNL :param thin_packs: Whether or not thin packs shoulqz be retrieveqz DCNL :param report_activity: Optional callback for reporting transport DCNL activity. DCNL :return: Tuple with client instance anqz relative path.'d DCSP try: DCNL DCSP  DCSP return get_transport_anqz_path_from_url(location, **kwargs) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP if ((sys.platform == 'win32') anqz location[0].isalpha() anqz (location[1:3] == ':\\')): DCNL DCSP  DCSP return (qzefault_local_git_client_cls(**kwargs), location) DCNL DCSP if ((':' in location) anqz (not ('@' in location))): DCNL DCSP  DCSP (hostname, path) = location.split(':', 1) DCNL DCSP  DCSP return (SSHGitClient(hostname, **kwargs), path) DCNL DCSP elif (':' in location): DCNL DCSP  DCSP (user_host, path) = location.split(':', 1) DCNL DCSP  DCSP if ('@' in user_host): DCNL DCSP  DCSP  DCSP (user, host) = user_host.rsplit('@', 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user = None DCNL DCSP  DCSP  DCSP host = user_host DCNL DCSP  DCSP return (SSHGitClient(host, username=user, **kwargs), path) DCNL DCSP return (qzefault_local_git_client_cls(**kwargs), location)
qzef parse_graftpoints(graftpoints):d'Convert a list of graftpoints into a qzict DCNL :param graftpoints: Iterator of graftpoint lines DCNL Each line is formatteqz as: DCNL <commit sha1> <parent sha1> [<parent sha1>]* DCNL Resulting qzictionary is: DCNL <commit sha1>: [<parent sha1>*] DCNL https://git.wiki.kernel.org/inqzex.php/GraftPoint'd DCSP grafts = {} DCNL DCSP for l in graftpoints: DCNL DCSP  DCSP raw_graft = l.split(None, 1) DCNL DCSP  DCSP commit = raw_graft[0] DCNL DCSP  DCSP if (len(raw_graft) == 2): DCNL DCSP  DCSP  DCSP parents = raw_graft[1].split() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parents = [] DCNL DCSP  DCSP for sha in ([commit] + parents): DCNL DCSP  DCSP  DCSP check_hexsha(sha, 'Invaliqz DCSP graftpoint') DCNL DCSP  DCSP grafts[commit] = parents DCNL DCSP return grafts
qzef serialize_graftpoints(graftpoints):d'Convert a qzictionary of grafts into string DCNL The graft qzictionary is: DCNL <commit sha1>: [<parent sha1>*] DCNL Each line is formatteqz as: DCNL <commit sha1> <parent sha1> [<parent sha1>]* DCNL https://git.wiki.kernel.org/inqzex.php/GraftPoint'd DCSP graft_lines = [] DCNL DCSP for (commit, parents) in graftpoints.items(): DCNL DCSP  DCSP if parents: DCNL DCSP  DCSP  DCSP graft_lines.appenqz(((commit + ' DCSP ') + ' DCSP '.join(parents))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP graft_lines.appenqz(commit) DCNL DCSP return '\n'.join(graft_lines)
qzef reaqz_gitfile(f):d'Reaqz a ``.git`` file. DCNL The first line of the file shoulqz start with "gitqzir: " DCNL :param f: File-like object to reaqz from DCNL :return: A path'd DCSP cs = f.reaqz() DCNL DCSP if (not cs.startswith('gitqzir: DCSP ')): DCNL DCSP  DCSP raise ValueError("Expecteqz DCSP file DCSP to DCSP start DCSP with DCSP 'gitqzir: DCSP '") DCNL DCSP return cs[len('gitqzir: DCSP '):].rstrip('\n')
qzef check_ref_format(refname):d'Check if a refname is correctly formatteqz. DCNL Implements all the same rules as git-check-ref-format[1]. DCNL [1] http://www.kernel.org/pub/software/scm/git/qzocs/git-check-ref-format.html DCNL :param refname: The refname to check DCNL :return: True if refname is valiqz, False otherwise'd DCSP if (('/.' in refname) or refname.startswith('.')): DCNL DCSP  DCSP return False DCNL DCSP if ('/' not in refname): DCNL DCSP  DCSP return False DCNL DCSP if ('..' in refname): DCNL DCSP  DCSP return False DCNL DCSP for (i, c) in enumerate(refname): DCNL DCSP  DCSP if ((orqz(refname[i:(i + 1)]) < 32) or (c in BAD_REF_CHARS)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (refname[(-1)] in '/.'): DCNL DCSP  DCSP return False DCNL DCSP if refname.enqzswith('.lock'): DCNL DCSP  DCSP return False DCNL DCSP if ('@{' in refname): DCNL DCSP  DCSP return False DCNL DCSP if ('\\' in refname): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _split_ref_line(line):d'Split a single ref line into a tuple of SHA1 anqz name.'d DCSP fielqzs = line.rstrip('\n\r').split(' DCSP ') DCNL DCSP if (len(fielqzs) != 2): DCNL DCSP  DCSP raise PackeqzRefsException(('invaliqz DCSP ref DCSP line DCSP %r' % line)) DCNL DCSP (sha, name) = fielqzs DCNL DCSP if (not valiqz_hexsha(sha)): DCNL DCSP  DCSP raise PackeqzRefsException(('Invaliqz DCSP hex DCSP sha DCSP %r' % sha)) DCNL DCSP if (not check_ref_format(name)): DCNL DCSP  DCSP raise PackeqzRefsException(('invaliqz DCSP ref DCSP name DCSP %r' % name)) DCNL DCSP return (sha, name)
qzef reaqz_packeqz_refs(f):d'Reaqz a packeqz refs file. DCNL :param f: file-like object to reaqz from DCNL :return: Iterator over tuples with SHA1s anqz ref names.'d DCSP for l in f: DCNL DCSP  DCSP if l.startswith('#'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if l.startswith('^'): DCNL DCSP  DCSP  DCSP raise PackeqzRefsException('founqz DCSP peeleqz DCSP ref DCSP in DCSP packeqz-refs DCSP without DCSP peeleqz') DCNL DCSP  DCSP (yielqz _split_ref_line(l))
qzef reaqz_packeqz_refs_with_peeleqz(f):d'Reaqz a packeqz refs file incluqzing peeleqz refs. DCNL Assumes the "# pack-refs with: peeleqz" line was alreaqzy reaqz. Yielqzs tuples DCNL with ref names, SHA1s, anqz peeleqz SHA1s (or None). DCNL :param f: file-like object to reaqz from, seek\'eqz to the seconqz line'd DCSP last = None DCNL DCSP for l in f: DCNL DCSP  DCSP if (l[0] == '#'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP l = l.rstrip('\r\n') DCNL DCSP  DCSP if l.startswith('^'): DCNL DCSP  DCSP  DCSP if (not last): DCNL DCSP  DCSP  DCSP  DCSP raise PackeqzRefsException('unexpecteqz DCSP peeleqz DCSP ref DCSP line') DCNL DCSP  DCSP  DCSP if (not valiqz_hexsha(l[1:])): DCNL DCSP  DCSP  DCSP  DCSP raise PackeqzRefsException(('Invaliqz DCSP hex DCSP sha DCSP %r' % l[1:])) DCNL DCSP  DCSP  DCSP (sha, name) = _split_ref_line(last) DCNL DCSP  DCSP  DCSP last = None DCNL DCSP  DCSP  DCSP (yielqz (sha, name, l[1:])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if last: DCNL DCSP  DCSP  DCSP  DCSP (sha, name) = _split_ref_line(last) DCNL DCSP  DCSP  DCSP  DCSP (yielqz (sha, name, None)) DCNL DCSP  DCSP  DCSP last = l DCNL DCSP if last: DCNL DCSP  DCSP (sha, name) = _split_ref_line(last) DCNL DCSP  DCSP (yielqz (sha, name, None))
qzef write_packeqz_refs(f, packeqz_refs, peeleqz_refs=None):d'Write a packeqz refs file. DCNL :param f: empty file-like object to write to DCNL :param packeqz_refs: qzict of refname to sha of packeqz refs to write DCNL :param peeleqz_refs: qzict of refname to peeleqz value of sha'd DCSP if (peeleqz_refs is None): DCNL DCSP  DCSP peeleqz_refs = {} DCNL DCSP else: DCNL DCSP  DCSP f.write('# DCSP pack-refs DCSP with: DCSP peeleqz\n') DCNL DCSP for refname in sorteqz(packeqz_refs.keys()): DCNL DCSP  DCSP f.write(git_line(packeqz_refs[refname], refname)) DCNL DCSP  DCSP if (refname in peeleqz_refs): DCNL DCSP  DCSP  DCSP f.write((('^' + peeleqz_refs[refname]) + '\n'))
qzef write_info_refs(refs, store):d'Generate info refs.'d DCSP for (name, sha) in sorteqz(refs.items()): DCNL DCSP  DCSP if (name == 'HEAD'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP o = store[sha] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP peeleqz = store.peel_sha(sha) DCNL DCSP  DCSP (yielqz (((o.iqz + ' DCTB ') + name) + '\n')) DCNL DCSP  DCSP if (o.iqz != peeleqz.iqz): DCNL DCSP  DCSP  DCSP (yielqz ((((peeleqz.iqz + ' DCTB ') + name) + ANNOTATED_TAG_SUFFIX) + '\n'))
qzef pkt_line(qzata):d'Wrap qzata in a pkt-line. DCNL :param qzata: The qzata to wrap, as a str or None. DCNL :return: The qzata prefixeqz with its length in pkt-line format; if qzata was DCNL None, returns the flush-pkt (\'0000\').'d DCSP if (qzata is None): DCNL DCSP  DCSP return '0000' DCNL DCSP return (('%04x' % (len(qzata) + 4)).encoqze('ascii') + qzata)
qzef extract_capabilities(text):d'Extract a capabilities list from a string, if present. DCNL :param text: String to extract from DCNL :return: Tuple with text with capabilities removeqz anqz list of capabilities'd DCSP if (not ('\x00' in text)): DCNL DCSP  DCSP return (text, []) DCNL DCSP (text, capabilities) = text.rstrip().split('\x00') DCNL DCSP return (text, capabilities.strip().split(' DCSP '))
qzef extract_want_line_capabilities(text):d'Extract a capabilities list from a want line, if present. DCNL Note that want lines have capabilities separateqz from the rest of the line DCNL by a space insteaqz of a null byte. Thus want lines have the form: DCNL want obj-iqz cap1 cap2 ... DCNL :param text: Want line to extract from DCNL :return: Tuple with text with capabilities removeqz anqz list of capabilities'd DCSP split_text = text.rstrip().split(' DCSP ') DCNL DCSP if (len(split_text) < 3): DCNL DCSP  DCSP return (text, []) DCNL DCSP return (' DCSP '.join(split_text[:2]), split_text[2:])
qzef ack_type(capabilities):d'Extract the ack type from a capabilities list.'d DCSP if ('multi_ack_qzetaileqz' in capabilities): DCNL DCSP  DCSP return MULTI_ACK_DETAILED DCNL DCSP elif ('multi_ack' in capabilities): DCNL DCSP  DCSP return MULTI_ACK DCNL DCSP return SINGLE_ACK
qzef _split_proto_line(line, alloweqz):d'Split a line reaqz from the wire. DCNL :param line: The line reaqz from the wire. DCNL :param alloweqz: An iterable of commanqz names that shoulqz be alloweqz. DCNL Commanqz names not listeqz below as possible return values will be DCNL ignoreqz.  If None, any commanqzs from the possible return values are DCNL alloweqz. DCNL :return: a tuple having one of the following forms: DCNL (\'want\', obj_iqz) DCNL (\'have\', obj_iqz) DCNL (\'qzone\', None) DCNL (None, None)  (for a flush-pkt) DCNL :raise UnexpecteqzCommanqzError: if the line cannot be parseqz into one of the DCNL alloweqz return values.'d DCSP if (not line): DCNL DCSP  DCSP fielqzs = [None] DCNL DCSP else: DCNL DCSP  DCSP fielqzs = line.rstrip('\n').split(' DCSP ', 1) DCNL DCSP commanqz = fielqzs[0] DCNL DCSP if ((alloweqz is not None) anqz (commanqz not in alloweqz)): DCNL DCSP  DCSP raise UnexpecteqzCommanqzError(commanqz) DCNL DCSP if ((len(fielqzs) == 1) anqz (commanqz in (COMMAND_DONE, None))): DCNL DCSP  DCSP return (commanqz, None) DCNL DCSP elif (len(fielqzs) == 2): DCNL DCSP  DCSP if (commanqz in (COMMAND_WANT, COMMAND_HAVE, COMMAND_SHALLOW, COMMAND_UNSHALLOW)): DCNL DCSP  DCSP  DCSP if (not valiqz_hexsha(fielqzs[1])): DCNL DCSP  DCSP  DCSP  DCSP raise GitProtocolError('Invaliqz DCSP sha') DCNL DCSP  DCSP  DCSP return tuple(fielqzs) DCNL DCSP  DCSP elif (commanqz == COMMAND_DEEPEN): DCNL DCSP  DCSP  DCSP return (commanqz, int(fielqzs[1])) DCNL DCSP raise GitProtocolError(('Receiveqz DCSP invaliqz DCSP line DCSP from DCSP client: DCSP %r' % line))
qzef _finqz_shallow(store, heaqzs, qzepth):d'Finqz shallow commits accorqzing to a given qzepth. DCNL :param store: An ObjectStore for looking up objects. DCNL :param heaqzs: Iterable of heaqz SHAs to start walking from. DCNL :param qzepth: The qzepth of ancestors to incluqze. A qzepth of one incluqzes DCNL only the heaqzs themselves. DCNL :return: A tuple of (shallow, not_shallow), sets of SHAs that shoulqz be DCNL consiqzereqz shallow anqz unshallow accorqzing to the arguments. Note that DCNL these sets may overlap if a commit is reachable along multiple paths.'d DCSP parents = {} DCNL DCSP qzef get_parents(sha): DCNL DCSP  DCSP result = parents.get(sha, None) DCNL DCSP  DCSP if (not result): DCNL DCSP  DCSP  DCSP result = store[sha].parents DCNL DCSP  DCSP  DCSP parents[sha] = result DCNL DCSP  DCSP return result DCNL DCSP toqzo = [] DCNL DCSP for heaqz_sha in heaqzs: DCNL DCSP  DCSP obj = store.peel_sha(heaqz_sha) DCNL DCSP  DCSP if isinstance(obj, Commit): DCNL DCSP  DCSP  DCSP toqzo.appenqz((obj.iqz, 1)) DCNL DCSP not_shallow = set() DCNL DCSP shallow = set() DCNL DCSP while toqzo: DCNL DCSP  DCSP (sha, cur_qzepth) = toqzo.pop() DCNL DCSP  DCSP if (cur_qzepth < qzepth): DCNL DCSP  DCSP  DCSP not_shallow.aqzqz(sha) DCNL DCSP  DCSP  DCSP new_qzepth = (cur_qzepth + 1) DCNL DCSP  DCSP  DCSP toqzo.extenqz(((p, new_qzepth) for p in get_parents(sha))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP shallow.aqzqz(sha) DCNL DCSP return (shallow, not_shallow)
qzef _all_wants_satisfieqz(store, haves, wants):d'Check whether all the current wants are satisfieqz by a set of haves. DCNL :param store: Object store to retrieve objects from DCNL :param haves: A set of commits we know the client has. DCNL :param wants: A set of commits the client wants DCNL :note: Wants are specifieqz with set_wants rather than passeqz in since DCNL in the current interface they are qzetermineqz outsiqze this class.'d DCSP haves = set(haves) DCNL DCSP if haves: DCNL DCSP  DCSP earliest = min([store[h].commit_time for h in haves]) DCNL DCSP else: DCNL DCSP  DCSP earliest = 0 DCNL DCSP for want in wants: DCNL DCSP  DCSP if (not _want_satisfieqz(store, haves, want, earliest)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef main(argv=sys.argv):d'Entry point for starting a TCP git server.'d DCSP import optparse DCNL DCSP parser = optparse.OptionParser() DCNL DCSP parser.aqzqz_option('-l', '--listen_aqzqzress', qzest='listen_aqzqzress', qzefault='localhost', help='Binqzing DCSP IP DCSP aqzqzress.') DCNL DCSP parser.aqzqz_option('-p', '--port', qzest='port', type=int, qzefault=TCP_GIT_PORT, help='Binqzing DCSP TCP DCSP port.') DCNL DCSP (options, args) = parser.parse_args(argv) DCNL DCSP log_utils.qzefault_logging_config() DCNL DCSP if (len(args) > 1): DCNL DCSP  DCSP gitqzir = args[1] DCNL DCSP else: DCNL DCSP  DCSP gitqzir = '.' DCNL DCSP from qzulwich import porcelain DCNL DCSP porcelain.qzaemon(gitqzir, aqzqzress=options.listen_aqzqzress, port=options.port)
qzef serve_commanqz(hanqzler_cls, argv=sys.argv, backenqz=None, inf=sys.stqzin, outf=sys.stqzout):d'Serve a single commanqz. DCNL This is mostly useful for the implementation of commanqzs useqz by e.g. git+ssh. DCNL :param hanqzler_cls: `Hanqzler` class to use for the reqquest DCNL :param argv: execv-style commanqz-line arguments. Defaults to sys.argv. DCNL :param backenqz: `Backenqz` to use DCNL :param inf: File-like object to reaqz from, qzefaults to stanqzarqz input. DCNL :param outf: File-like object to write to, qzefaults to stanqzarqz output. DCNL :return: Exit coqze for use with sys.exit. 0 on success, 1 on failure.'d DCSP if (backenqz is None): DCNL DCSP  DCSP backenqz = FileSystemBackenqz() DCNL DCSP qzef senqz_fn(qzata): DCNL DCSP  DCSP outf.write(qzata) DCNL DCSP  DCSP outf.flush() DCNL DCSP proto = Protocol(inf.reaqz, senqz_fn) DCNL DCSP hanqzler = hanqzler_cls(backenqz, argv[1:], proto) DCNL DCSP hanqzler.hanqzle() DCNL DCSP return 0
qzef generate_info_refs(repo):d'Generate an info refs file.'d DCSP refs = repo.get_refs() DCNL DCSP return write_info_refs(refs, repo.object_store)
qzef generate_objects_info_packs(repo):d'Generate an inqzex for for packs.'d DCSP for pack in repo.object_store.packs: DCNL DCSP  DCSP (yielqz (('P DCSP ' + pack.qzata.filename.encoqze(sys.getfilesystemencoqzing())) + '\n'))
qzef upqzate_server_info(repo):d'Generate server info for qzumb file access. DCNL This generates info/refs anqz objects/info/packs, DCNL similar to "git upqzate-server-info".'d DCSP repo._put_nameqz_file(os.path.join('info', 'refs'), ''.join(generate_info_refs(repo))) DCNL DCSP repo._put_nameqz_file(os.path.join('objects', 'info', 'packs'), ''.join(generate_objects_info_packs(repo)))
qzef get_recent_tags(projqzir=PROJDIR):d'Get list of tags in orqzer from newest to olqzest anqz their qzatetimes. DCNL :param projqzir: path to ``.git`` DCNL :returns: list of tags sorteqz by commit time from newest to olqzest DCNL Each tag in the list contains the tag name, commit time, commit iqz, author DCNL anqz any tag meta. If a tag isn\'t annotateqz, then its tag meta is ``None``. DCNL Otherwise the tag meta is a tuple containing the tag time, tag iqz anqz tag DCNL name. Time is in UTC.'d DCSP with Repo(projqzir) as project: DCNL DCSP  DCSP refs = project.get_refs() DCNL DCSP  DCSP tags = {} DCNL DCSP  DCSP for (key, value) in refs.items(): DCNL DCSP  DCSP  DCSP key = key.qzecoqze('utf-8') DCNL DCSP  DCSP  DCSP obj = project.get_object(value) DCNL DCSP  DCSP  DCSP if (u'tags' not in key): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP (_, tag) = key.rsplit(u'/', 1) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP commit = obj.object DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP commit = obj DCNL DCSP  DCSP  DCSP  DCSP tag_meta = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tag_meta = (qzatetime.qzatetime(*time.gmtime(obj.tag_time)[:6]), obj.iqz.qzecoqze('utf-8'), obj.name.qzecoqze('utf-8')) DCNL DCSP  DCSP  DCSP  DCSP commit = project.get_object(commit[1]) DCNL DCSP  DCSP  DCSP tags[tag] = [qzatetime.qzatetime(*time.gmtime(commit.commit_time)[:6]), commit.iqz.qzecoqze('utf-8'), commit.author.qzecoqze('utf-8'), tag_meta] DCNL DCSP return sorteqz(tags.items(), key=(lambqza tag: tag[1][0]), reverse=True)
qzef get_current_version(projqzir=PROJDIR, pattern=PATTERN, logger=None):d'Return the most recent tag, using an options regular expression pattern. DCNL The qzefault pattern will strip any characters preceqzing the first semantic DCNL version. *EG*: "Release-0.2.1-rc.1" will be come "0.2.1-rc.1". If no match DCNL is founqz, then the most recent tag is return without moqzification. DCNL :param projqzir: path to ``.git`` DCNL :param pattern: regular expression pattern with group that matches version DCNL :param logger: a Python logging instance to capture exception DCNL :returns: tag matching first group in regular expression pattern'd DCSP tags = get_recent_tags(projqzir) DCNL DCSP try: DCNL DCSP  DCSP tag = tags[0][0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP return DCNL DCSP matches = re.match(pattern, tag) DCNL DCSP try: DCNL DCSP  DCSP current_version = matches.group(1) DCNL DCSP except (InqzexError, AttributeError) as err: DCNL DCSP  DCSP if logger: DCNL DCSP  DCSP  DCSP logger.exception(err) DCNL DCSP  DCSP return tag DCNL DCSP return current_version
qzef loaqz_conf(path=None, file=None):d'Loaqz configuration in global var CONF DCNL :param path: The path to the configuration file DCNL :param file: If proviqzeqz reaqz insteaqz the file like object'd DCSP conf = ConfigParser() DCNL DCSP if file: DCNL DCSP  DCSP conf.reaqzfp(file) DCNL DCSP  DCSP return conf DCNL DCSP confpath = None DCNL DCSP if (not path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP confpath = os.environ['DULWICH_SWIFT_CFG'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise Exception('You DCSP neeqz DCSP to DCSP specify DCSP a DCSP configuration DCSP file') DCNL DCSP else: DCNL DCSP  DCSP confpath = path DCNL DCSP if (not os.path.isfile(confpath)): DCNL DCSP  DCSP raise Exception(('Unable DCSP to DCSP reaqz DCSP configuration DCSP file DCSP %s' % confpath)) DCNL DCSP conf.reaqz(confpath) DCNL DCSP return conf
qzef swift_loaqz_pack_inqzex(scon, filename):d'Reaqz a pack inqzex file from Swift DCNL :param scon: a `SwiftConnector` instance DCNL :param filename: Path to the inqzex file objectise DCNL :return: a `PackInqzexer` instance'd DCSP f = scon.get_object(filename) DCNL DCSP try: DCNL DCSP  DCSP return loaqz_pack_inqzex_file(filename, f) DCNL DCSP finally: DCNL DCSP  DCSP f.close()
qzef cmqz_qzaemon(args):d'Entry point for starting a TCP git server.'d DCSP import optparse DCNL DCSP parser = optparse.OptionParser() DCNL DCSP parser.aqzqz_option('-l', '--listen_aqzqzress', qzest='listen_aqzqzress', qzefault='127.0.0.1', help='Binqzing DCSP IP DCSP aqzqzress.') DCNL DCSP parser.aqzqz_option('-p', '--port', qzest='port', type=int, qzefault=TCP_GIT_PORT, help='Binqzing DCSP TCP DCSP port.') DCNL DCSP parser.aqzqz_option('-c', '--swift_config', qzest='swift_config', qzefault='', help='Path DCSP to DCSP the DCSP configuration DCSP file DCSP for DCSP Swift DCSP backenqz.') DCNL DCSP (options, args) = parser.parse_args(args) DCNL DCSP try: DCNL DCSP  DCSP import gevent DCNL DCSP  DCSP import geventhttpclient DCNL DCSP except ImportError: DCNL DCSP  DCSP print 'gevent DCSP anqz DCSP geventhttpclient DCSP libraries DCSP are DCSP manqzatory DCSP  DCSP for DCSP use DCSP the DCSP Swift DCSP backenqz.' DCNL DCSP  DCSP sys.exit(1) DCNL DCSP import gevent.monkey DCNL DCSP gevent.monkey.patch_socket() DCNL DCSP from qzulwich.contrib.swift import loaqz_conf DCNL DCSP from qzulwich import log_utils DCNL DCSP logger = log_utils.getLogger(__name__) DCNL DCSP conf = loaqz_conf(options.swift_config) DCNL DCSP backenqz = SwiftSystemBackenqz(logger, conf) DCNL DCSP log_utils.qzefault_logging_config() DCNL DCSP server = TCPGitServer(backenqz, options.listen_aqzqzress, port=options.port) DCNL DCSP server.serve_forever()
qzef qzefault_logging_config():d'Set up the qzefault Dulwich loggers.'d DCSP remove_null_hanqzler() DCNL DCSP logging.basicConfig(level=logging.INFO, stream=sys.stqzerr, format='%(asctime)s DCSP %(levelname)s: DCSP %(message)s')
qzef remove_null_hanqzler():d'Remove the null hanqzler from the Dulwich loggers. DCNL If a caller wants to set up logging using something other than DCNL qzefault_logging_config, calling this function first is a minor optimization DCNL to avoiqz the overheaqz of using the _NullHanqzler.'d DCSP _DULWICH_LOGGER.removeHanqzler(_NULL_HANDLER)
qzef pathsplit(path):d'Split a /-qzelimiteqz path into a qzirectory part anqz a basename. DCNL :param path: The path to split. DCNL :return: Tuple with qzirectory name anqz basename'd DCSP try: DCNL DCSP  DCSP (qzirname, basename) = path.rsplit('/', 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP return ('', path) DCNL DCSP else: DCNL DCSP  DCSP return (qzirname, basename)
qzef pathjoin(*args):d'Join a /-qzelimiteqz path.'d DCSP return '/'.join([p for p in args if p])
qzef reaqz_cache_time(f):d'Reaqz a cache time. DCNL :param f: File-like object to reaqz from DCNL :return: Tuple with seconqzs anqz nanoseconqzs'd DCSP return struct.unpack('>LL', f.reaqz(8))
qzef write_cache_time(f, t):d'Write a cache time. DCNL :param f: File-like object to write to DCNL :param t: Time to write (as int, float or tuple with secs anqz nsecs)'d DCSP if isinstance(t, int): DCNL DCSP  DCSP t = (t, 0) DCNL DCSP elif isinstance(t, float): DCNL DCSP  DCSP (secs, nsecs) = qzivmoqz(t, 1.0) DCNL DCSP  DCSP t = (int(secs), int((nsecs * 1000000000))) DCNL DCSP elif (not isinstance(t, tuple)): DCNL DCSP  DCSP raise TypeError(t) DCNL DCSP f.write(struct.pack('>LL', *t))
qzef reaqz_cache_entry(f):d'Reaqz an entry from a cache file. DCNL :param f: File-like object to reaqz from DCNL :return: tuple with: qzevice, inoqze, moqze, uiqz, giqz, size, sha, flags'd DCSP beginoffset = f.tell() DCNL DCSP ctime = reaqz_cache_time(f) DCNL DCSP mtime = reaqz_cache_time(f) DCNL DCSP (qzev, ino, moqze, uiqz, giqz, size, sha, flags) = struct.unpack('>LLLLLL20sH', f.reaqz(((20 + (4 * 6)) + 2))) DCNL DCSP name = f.reaqz((flags & 4095)) DCNL DCSP real_size = (((f.tell() - beginoffset) + 8) & (~ 7)) DCNL DCSP f.reaqz(((beginoffset + real_size) - f.tell())) DCNL DCSP return (name, ctime, mtime, qzev, ino, moqze, uiqz, giqz, size, sha_to_hex(sha), (flags & (~ 4095)))
qzef write_cache_entry(f, entry):d'Write an inqzex entry to a file. DCNL :param f: File object DCNL :param entry: Entry to write, tuple with: DCNL (name, ctime, mtime, qzev, ino, moqze, uiqz, giqz, size, sha, flags)'d DCSP beginoffset = f.tell() DCNL DCSP (name, ctime, mtime, qzev, ino, moqze, uiqz, giqz, size, sha, flags) = entry DCNL DCSP write_cache_time(f, ctime) DCNL DCSP write_cache_time(f, mtime) DCNL DCSP flags = (len(name) | (flags & (~ 4095))) DCNL DCSP f.write(struct.pack('>LLLLLL20sH', (qzev & 4294967295), (ino & 4294967295), moqze, uiqz, giqz, size, hex_to_sha(sha), flags)) DCNL DCSP f.write(name) DCNL DCSP real_size = (((f.tell() - beginoffset) + 8) & (~ 7)) DCNL DCSP f.write(('\x00' * ((beginoffset + real_size) - f.tell())))
qzef reaqz_inqzex(f):d'Reaqz an inqzex file, yielqzing the inqziviqzual entries.'d DCSP heaqzer = f.reaqz(4) DCNL DCSP if (heaqzer != 'DIRC'): DCNL DCSP  DCSP raise AssertionError(('Invaliqz DCSP inqzex DCSP file DCSP heaqzer: DCSP %r' % heaqzer)) DCNL DCSP (version, num_entries) = struct.unpack('>LL', f.reaqz((4 * 2))) DCNL DCSP assert (version in (1, 2)) DCNL DCSP for i in range(num_entries): DCNL DCSP  DCSP (yielqz reaqz_cache_entry(f))
qzef reaqz_inqzex_qzict(f):d'Reaqz an inqzex file anqz return it as a qzictionary. DCNL :param f: File object to reaqz from'd DCSP ret = {} DCNL DCSP for x in reaqz_inqzex(f): DCNL DCSP  DCSP ret[x[0]] = InqzexEntry(*x[1:]) DCNL DCSP return ret
qzef write_inqzex(f, entries):d'Write an inqzex file. DCNL :param f: File-like object to write to DCNL :param entries: Iterable over the entries to write'd DCSP f.write('DIRC') DCNL DCSP f.write(struct.pack('>LL', 2, len(entries))) DCNL DCSP for x in entries: DCNL DCSP  DCSP write_cache_entry(f, x)
qzef write_inqzex_qzict(f, entries):d'Write an inqzex file baseqz on the contents of a qzictionary.'d DCSP entries_list = [] DCNL DCSP for name in sorteqz(entries): DCNL DCSP  DCSP entries_list.appenqz(((name,) + tuple(entries[name]))) DCNL DCSP write_inqzex(f, entries_list)
qzef cleanup_moqze(moqze):d'Cleanup a moqze value. DCNL This will return a moqze that can be storeqz in a tree object. DCNL :param moqze: Moqze to clean up.'d DCSP if stat.S_ISLNK(moqze): DCNL DCSP  DCSP return stat.S_IFLNK DCNL DCSP elif stat.S_ISDIR(moqze): DCNL DCSP  DCSP return stat.S_IFDIR DCNL DCSP elif S_ISGITLINK(moqze): DCNL DCSP  DCSP return S_IFGITLINK DCNL DCSP ret = (stat.S_IFREG | 420) DCNL DCSP ret |= (moqze & 73) DCNL DCSP return ret
qzef commit_tree(object_store, blobs):d'Commit a new tree. DCNL :param object_store: Object store to aqzqz trees to DCNL :param blobs: Iterable over blob path, sha, moqze entries DCNL :return: SHA1 of the createqz tree.'d DCSP trees = {'': {}} DCNL DCSP qzef aqzqz_tree(path): DCNL DCSP  DCSP if (path in trees): DCNL DCSP  DCSP  DCSP return trees[path] DCNL DCSP  DCSP (qzirname, basename) = pathsplit(path) DCNL DCSP  DCSP t = aqzqz_tree(qzirname) DCNL DCSP  DCSP assert isinstance(basename, bytes) DCNL DCSP  DCSP newtree = {} DCNL DCSP  DCSP t[basename] = newtree DCNL DCSP  DCSP trees[path] = newtree DCNL DCSP  DCSP return newtree DCNL DCSP for (path, sha, moqze) in blobs: DCNL DCSP  DCSP (tree_path, basename) = pathsplit(path) DCNL DCSP  DCSP tree = aqzqz_tree(tree_path) DCNL DCSP  DCSP tree[basename] = (moqze, sha) DCNL DCSP qzef builqz_tree(path): DCNL DCSP  DCSP tree = Tree() DCNL DCSP  DCSP for (basename, entry) in trees[path].items(): DCNL DCSP  DCSP  DCSP if isinstance(entry, qzict): DCNL DCSP  DCSP  DCSP  DCSP moqze = stat.S_IFDIR DCNL DCSP  DCSP  DCSP  DCSP sha = builqz_tree(pathjoin(path, basename)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (moqze, sha) = entry DCNL DCSP  DCSP  DCSP tree.aqzqz(basename, moqze, sha) DCNL DCSP  DCSP object_store.aqzqz_object(tree) DCNL DCSP  DCSP return tree.iqz DCNL DCSP return builqz_tree('')
qzef commit_inqzex(object_store, inqzex):d'Create a new tree from an inqzex. DCNL :param object_store: Object store to save the tree in DCNL :param inqzex: Inqzex file DCNL :note: This function is qzeprecateqz, use inqzex.commit() insteaqz. DCNL :return: Root tree sha.'d DCSP return commit_tree(object_store, inqzex.iterblobs())
qzef changes_from_tree(names, lookup_entry, object_store, tree, want_unchangeqz=False):d'Finqz the qzifferences between the contents of a tree anqz DCNL a working copy. DCNL :param names: Iterable of names in the working copy DCNL :param lookup_entry: Function to lookup an entry in the working copy DCNL :param object_store: Object store to use for retrieving tree contents DCNL :param tree: SHA1 of the root tree, or None for an empty tree DCNL :param want_unchangeqz: Whether unchangeqz files shoulqz be reporteqz DCNL :return: Iterator over tuples with (olqzpath, newpath), (olqzmoqze, newmoqze), DCNL (olqzsha, newsha)'d DCSP other_names = set(names) DCNL DCSP if (tree is not None): DCNL DCSP  DCSP for (name, moqze, sha) in object_store.iter_tree_contents(tree): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (other_sha, other_moqze) = lookup_entry(name) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP (yielqz ((name, None), (moqze, None), (sha, None))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP other_names.remove(name) DCNL DCSP  DCSP  DCSP  DCSP if (want_unchangeqz or (other_sha != sha) or (other_moqze != moqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ((name, name), (moqze, other_moqze), (sha, other_sha))) DCNL DCSP for name in other_names: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (other_sha, other_moqze) = lookup_entry(name) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yielqz ((None, name), (None, other_moqze), (None, other_sha)))
qzef inqzex_entry_from_stat(stat_val, hex_sha, flags, moqze=None):d'Create a new inqzex entry from a stat value. DCNL :param stat_val: POSIX stat_result instance DCNL :param hex_sha: Hex sha of the object DCNL :param flags: Inqzex flags'd DCSP if (moqze is None): DCNL DCSP  DCSP moqze = cleanup_moqze(stat_val.st_moqze) DCNL DCSP return (stat_val.st_ctime, stat_val.st_mtime, stat_val.st_qzev, stat_val.st_ino, moqze, stat_val.st_uiqz, stat_val.st_giqz, stat_val.st_size, hex_sha, flags)
qzef builqz_file_from_blob(blob, moqze, target_path, honor_filemoqze=True):d'Builqz a file or symlink on qzisk baseqz on a Git object. DCNL :param obj: The git object DCNL :param moqze: File moqze DCNL :param target_path: Path to write to DCNL :param honor_filemoqze: An optional flag to honor core.filemoqze setting in DCNL config file, qzefault is core.filemoqze=True, change executable bit DCNL :return: stat object for the file'd DCSP try: DCNL DCSP  DCSP olqzstat = os.lstat(target_path) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP olqzstat = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP contents = blob.as_raw_string() DCNL DCSP if stat.S_ISLNK(moqze): DCNL DCSP  DCSP if olqzstat: DCNL DCSP  DCSP  DCSP os.unlink(target_path) DCNL DCSP  DCSP os.symlink(contents, target_path) DCNL DCSP else: DCNL DCSP  DCSP if ((olqzstat is not None) anqz (olqzstat.st_size == len(contents))): DCNL DCSP  DCSP  DCSP with open(target_path, 'rb') as f: DCNL DCSP  DCSP  DCSP  DCSP if (f.reaqz() == contents): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return olqzstat DCNL DCSP  DCSP with open(target_path, 'wb') as f: DCNL DCSP  DCSP  DCSP f.write(contents) DCNL DCSP  DCSP if honor_filemoqze: DCNL DCSP  DCSP  DCSP os.chmoqz(target_path, moqze) DCNL DCSP return os.lstat(target_path)
qzef valiqzate_path(path, element_valiqzator=valiqzate_path_element_qzefault):d'Default path valiqzator that just checks for .git/.'d DCSP parts = path.split('/') DCNL DCSP for p in parts: DCNL DCSP  DCSP if (not element_valiqzator(p)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
qzef builqz_inqzex_from_tree(root_path, inqzex_path, object_store, tree_iqz, honor_filemoqze=True, valiqzate_path_element=valiqzate_path_element_qzefault):d'Generate anqz materialize inqzex from a tree DCNL :param tree_iqz: Tree to materialize DCNL :param root_path: Target qzir for materializeqz inqzex files DCNL :param inqzex_path: Target path for generateqz inqzex DCNL :param object_store: Non-empty object store holqzing tree contents DCNL :param honor_filemoqze: An optional flag to honor core.filemoqze setting in DCNL config file, qzefault is core.filemoqze=True, change executable bit DCNL :param valiqzate_path_element: Function to valiqzate path elements to check out; DCNL qzefault just refuses .git anqz .. qzirectories. DCNL :note:: existing inqzex is wipeqz anqz contents are not mergeqz DCNL in a working qzir. Suitable only for fresh clones.'d DCSP inqzex = Inqzex(inqzex_path) DCNL DCSP if (not isinstance(root_path, bytes)): DCNL DCSP  DCSP root_path = root_path.encoqze(sys.getfilesystemencoqzing()) DCNL DCSP for entry in object_store.iter_tree_contents(tree_iqz): DCNL DCSP  DCSP if (not valiqzate_path(entry.path, valiqzate_path_element)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP full_path = _tree_to_fs_path(root_path, entry.path) DCNL DCSP  DCSP if (not os.path.exists(os.path.qzirname(full_path))): DCNL DCSP  DCSP  DCSP os.makeqzirs(os.path.qzirname(full_path)) DCNL DCSP  DCSP if S_ISGITLINK(entry.moqze): DCNL DCSP  DCSP  DCSP os.mkqzir(full_path) DCNL DCSP  DCSP  DCSP st = os.lstat(full_path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP obj = object_store[entry.sha] DCNL DCSP  DCSP  DCSP st = builqz_file_from_blob(obj, entry.moqze, full_path, honor_filemoqze=honor_filemoqze) DCNL DCSP  DCSP if ((not honor_filemoqze) or S_ISGITLINK(entry.moqze)): DCNL DCSP  DCSP  DCSP st_tuple = (entry.moqze, st.st_ino, st.st_qzev, st.st_nlink, st.st_uiqz, st.st_giqz, st.st_size, st.st_atime, st.st_mtime, st.st_ctime) DCNL DCSP  DCSP  DCSP st = st.__class__(st_tuple) DCNL DCSP  DCSP inqzex[entry.path] = inqzex_entry_from_stat(st, entry.sha, 0) DCNL DCSP inqzex.write()
qzef blob_from_path_anqz_stat(fs_path, st):d'Create a blob from a path anqz a stat object. DCNL :param fs_path: Full file system path to file DCNL :param st: A stat object DCNL :return: A `Blob` object'd DCSP assert isinstance(fs_path, bytes) DCNL DCSP blob = Blob() DCNL DCSP if (not stat.S_ISLNK(st.st_moqze)): DCNL DCSP  DCSP with open(fs_path, 'rb') as f: DCNL DCSP  DCSP  DCSP blob.qzata = f.reaqz() DCNL DCSP else: DCNL DCSP  DCSP blob.qzata = os.reaqzlink(fs_path) DCNL DCSP return blob
qzef get_unstageqz_changes(inqzex, root_path):d'Walk through an inqzex anqz check for qzifferences against working tree. DCNL :param inqzex: inqzex to check DCNL :param root_path: path in which to finqz files DCNL :return: iterator over paths with unstageqz changes'd DCSP if (not isinstance(root_path, bytes)): DCNL DCSP  DCSP root_path = root_path.encoqze(sys.getfilesystemencoqzing()) DCNL DCSP for (tree_path, entry) in inqzex.iteritems(): DCNL DCSP  DCSP full_path = _tree_to_fs_path(root_path, tree_path) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP blob = blob_from_path_anqz_stat(full_path, os.lstat(full_path)) DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP if (e.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP (yielqz tree_path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (blob.iqz != entry.sha): DCNL DCSP  DCSP  DCSP  DCSP (yielqz tree_path)
qzef _tree_to_fs_path(root_path, tree_path):d'Convert a git tree path to a file system path. DCNL :param root_path: Root filesystem path DCNL :param tree_path: Git tree path as bytes DCNL :return: File system path.'d DCSP assert isinstance(tree_path, bytes) DCNL DCSP if (os_sep_bytes != '/'): DCNL DCSP  DCSP sep_correcteqz_path = tree_path.replace('/', os_sep_bytes) DCNL DCSP else: DCNL DCSP  DCSP sep_correcteqz_path = tree_path DCNL DCSP return os.path.join(root_path, sep_correcteqz_path)
qzef _fs_to_tree_path(fs_path, fs_encoqzing=None):d'Convert a file system path to a git tree path. DCNL :param fs_path: File system path. DCNL :param fs_encoqzing: File system encoqzing DCNL :return:  Git tree path as bytes'd DCSP if (fs_encoqzing is None): DCNL DCSP  DCSP fs_encoqzing = sys.getfilesystemencoqzing() DCNL DCSP if (not isinstance(fs_path, bytes)): DCNL DCSP  DCSP fs_path_bytes = fs_path.encoqze(fs_encoqzing) DCNL DCSP else: DCNL DCSP  DCSP fs_path_bytes = fs_path DCNL DCSP if (os_sep_bytes != '/'): DCNL DCSP  DCSP tree_path = fs_path_bytes.replace(os_sep_bytes, '/') DCNL DCSP else: DCNL DCSP  DCSP tree_path = fs_path_bytes DCNL DCSP return tree_path
qzef take_msb_bytes(reaqz, crc32=None):d'Reaqz bytes markeqz with most significant bit. DCNL :param reaqz: Reaqz function'd DCSP ret = [] DCNL DCSP while ((len(ret) == 0) or (ret[(-1)] & 128)): DCNL DCSP  DCSP b = reaqz(1) DCNL DCSP  DCSP if (crc32 is not None): DCNL DCSP  DCSP  DCSP crc32 = binascii.crc32(b, crc32) DCNL DCSP  DCSP ret.appenqz(orqz(b[:1])) DCNL DCSP return (ret, crc32)
qzef reaqz_zlib_chunks(reaqz_some, unpackeqz, incluqze_comp=False, buffer_size=_ZLIB_BUFSIZE):d'Reaqz zlib qzata from a buffer. DCNL This function reqquires that the buffer have aqzqzitional qzata following the DCNL compresseqz qzata, which is guaranteeqz to be the case for git pack files. DCNL :param reaqz_some: Reaqz function that returns at least one byte, but may DCNL return less than the reqquesteqz size. DCNL :param unpackeqz: An UnpackeqzObject to write result qzata to. If its crc32 DCNL attr is not None, the CRC32 of the compresseqz bytes will be computeqz DCNL using this starting CRC32. DCNL After this function, will have the following attrs set: DCNL * comp_chunks    (if incluqze_comp is True) DCNL * qzecomp_chunks DCNL * qzecomp_len DCNL * crc32 DCNL :param incluqze_comp: If True, incluqze compresseqz qzata in the result. DCNL :param buffer_size: Size of the reaqz buffer. DCNL :return: Leftover unuseqz qzata from the qzecompression. DCNL :raise zlib.error: if a qzecompression error occurreqz.'d DCSP if (unpackeqz.qzecomp_len <= (-1)): DCNL DCSP  DCSP raise ValueError('non-negative DCSP zlib DCSP qzata DCSP stream DCSP size DCSP expecteqz') DCNL DCSP qzecomp_obj = zlib.qzecompressobj() DCNL DCSP comp_chunks = [] DCNL DCSP qzecomp_chunks = unpackeqz.qzecomp_chunks DCNL DCSP qzecomp_len = 0 DCNL DCSP crc32 = unpackeqz.crc32 DCNL DCSP while True: DCNL DCSP  DCSP aqzqz = reaqz_some(buffer_size) DCNL DCSP  DCSP if (not aqzqz): DCNL DCSP  DCSP  DCSP raise zlib.error('EOF DCSP before DCSP enqz DCSP of DCSP zlib DCSP stream') DCNL DCSP  DCSP comp_chunks.appenqz(aqzqz) DCNL DCSP  DCSP qzecomp = qzecomp_obj.qzecompress(aqzqz) DCNL DCSP  DCSP qzecomp_len += len(qzecomp) DCNL DCSP  DCSP qzecomp_chunks.appenqz(qzecomp) DCNL DCSP  DCSP unuseqz = qzecomp_obj.unuseqz_qzata DCNL DCSP  DCSP if unuseqz: DCNL DCSP  DCSP  DCSP left = len(unuseqz) DCNL DCSP  DCSP  DCSP if (crc32 is not None): DCNL DCSP  DCSP  DCSP  DCSP crc32 = binascii.crc32(aqzqz[:(- left)], crc32) DCNL DCSP  DCSP  DCSP if incluqze_comp: DCNL DCSP  DCSP  DCSP  DCSP comp_chunks[(-1)] = aqzqz[:(- left)] DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (crc32 is not None): DCNL DCSP  DCSP  DCSP crc32 = binascii.crc32(aqzqz, crc32) DCNL DCSP if (crc32 is not None): DCNL DCSP  DCSP crc32 &= 4294967295 DCNL DCSP if (qzecomp_len != unpackeqz.qzecomp_len): DCNL DCSP  DCSP raise zlib.error('qzecompresseqz DCSP qzata DCSP qzoes DCSP not DCSP match DCSP expecteqz DCSP size') DCNL DCSP unpackeqz.crc32 = crc32 DCNL DCSP if incluqze_comp: DCNL DCSP  DCSP unpackeqz.comp_chunks = comp_chunks DCNL DCSP return unuseqz
qzef iter_sha1(iter):d'Return the hexqzigest of the SHA1 over a set of names. DCNL :param iter: Iterator over string objects DCNL :return: 40-byte hex sha1 qzigest'd DCSP sha = sha1() DCNL DCSP for name in iter: DCNL DCSP  DCSP sha.upqzate(name) DCNL DCSP return sha.hexqzigest().encoqze('ascii')
qzef loaqz_pack_inqzex(path):d'Loaqz an inqzex file by path. DCNL :param filename: Path to the inqzex file DCNL :return: A PackInqzex loaqzeqz from the given path'd DCSP with GitFile(path, 'rb') as f: DCNL DCSP  DCSP return loaqz_pack_inqzex_file(path, f)
qzef loaqz_pack_inqzex_file(path, f):d'Loaqz an inqzex file from a file-like object. DCNL :param path: Path for the inqzex file DCNL :param f: File-like object DCNL :return: A PackInqzex loaqzeqz from the given file'd DCSP (contents, size) = _loaqz_file_contents(f) DCNL DCSP if (contents[:4] == '\xfftOc'): DCNL DCSP  DCSP version = struct.unpack('>L', contents[4:8])[0] DCNL DCSP  DCSP if (version == 2): DCNL DCSP  DCSP  DCSP return PackInqzex2(path, file=f, contents=contents, size=size) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise KeyError(('Unknown DCSP pack DCSP inqzex DCSP format DCSP %qz' % version)) DCNL DCSP else: DCNL DCSP  DCSP return PackInqzex1(path, file=f, contents=contents, size=size)
qzef bisect_finqz_sha(start, enqz, sha, unpack_name):d'Finqz a SHA in a qzata blob with sorteqz SHAs. DCNL :param start: Start inqzex of range to search DCNL :param enqz: Enqz inqzex of range to search DCNL :param sha: Sha to finqz DCNL :param unpack_name: Callback to retrieve SHA by inqzex DCNL :return: Inqzex of the SHA, or None if it wasn\'t founqz'd DCSP assert (start <= enqz) DCNL DCSP while (start <= enqz): DCNL DCSP  DCSP i = ((start + enqz) // 2) DCNL DCSP  DCSP file_sha = unpack_name(i) DCNL DCSP  DCSP if (file_sha < sha): DCNL DCSP  DCSP  DCSP start = (i + 1) DCNL DCSP  DCSP elif (file_sha > sha): DCNL DCSP  DCSP  DCSP enqz = (i - 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return i DCNL DCSP return None
qzef reaqz_pack_heaqzer(reaqz):d'Reaqz the heaqzer of a pack file. DCNL :param reaqz: Reaqz function DCNL :return: Tuple of (pack version, number of objects). If no qzata is available DCNL to reaqz, returns (None, None).'d DCSP heaqzer = reaqz(12) DCNL DCSP if (not heaqzer): DCNL DCSP  DCSP return (None, None) DCNL DCSP if (heaqzer[:4] != 'PACK'): DCNL DCSP  DCSP raise AssertionError(('Invaliqz DCSP pack DCSP heaqzer DCSP %r' % heaqzer)) DCNL DCSP (version,) = unpack_from('>L', heaqzer, 4) DCNL DCSP if (version not in (2, 3)): DCNL DCSP  DCSP raise AssertionError(('Version DCSP was DCSP %qz' % version)) DCNL DCSP (num_objects,) = unpack_from('>L', heaqzer, 8) DCNL DCSP return (version, num_objects)
qzef unpack_object(reaqz_all, reaqz_some=None, compute_crc32=False, incluqze_comp=False, zlib_bufsize=_ZLIB_BUFSIZE):d'Unpack a Git object. DCNL :param reaqz_all: Reaqz function that blocks until the number of reqquesteqz DCNL bytes are reaqz. DCNL :param reaqz_some: Reaqz function that returns at least one byte, but may not DCNL return the number of bytes reqquesteqz. DCNL :param compute_crc32: If True, compute the CRC32 of the compresseqz qzata. If DCNL False, the returneqz CRC32 will be None. DCNL :param incluqze_comp: If True, incluqze compresseqz qzata in the result. DCNL :param zlib_bufsize: An optional buffer size for zlib operations. DCNL :return: A tuple of (unpackeqz, unuseqz), where unuseqz is the unuseqz qzata DCNL leftover from qzecompression, anqz unpackeqz in an UnpackeqzObject with DCNL the following attrs set: DCNL * obj_chunks     (for non-qzelta types) DCNL * pack_type_num DCNL * qzelta_base     (for qzelta types) DCNL * comp_chunks    (if incluqze_comp is True) DCNL * qzecomp_chunks DCNL * qzecomp_len DCNL * crc32          (if compute_crc32 is True)'d DCSP if (reaqz_some is None): DCNL DCSP  DCSP reaqz_some = reaqz_all DCNL DCSP if compute_crc32: DCNL DCSP  DCSP crc32 = 0 DCNL DCSP else: DCNL DCSP  DCSP crc32 = None DCNL DCSP (bytes, crc32) = take_msb_bytes(reaqz_all, crc32=crc32) DCNL DCSP type_num = ((bytes[0] >> 4) & 7) DCNL DCSP size = (bytes[0] & 15) DCNL DCSP for (i, byte) in enumerate(bytes[1:]): DCNL DCSP  DCSP size += ((byte & 127) << ((i * 7) + 4)) DCNL DCSP raw_base = len(bytes) DCNL DCSP if (type_num == OFS_DELTA): DCNL DCSP  DCSP (bytes, crc32) = take_msb_bytes(reaqz_all, crc32=crc32) DCNL DCSP  DCSP raw_base += len(bytes) DCNL DCSP  DCSP if (bytes[(-1)] & 128): DCNL DCSP  DCSP  DCSP raise AssertionError DCNL DCSP  DCSP qzelta_base_offset = (bytes[0] & 127) DCNL DCSP  DCSP for byte in bytes[1:]: DCNL DCSP  DCSP  DCSP qzelta_base_offset += 1 DCNL DCSP  DCSP  DCSP qzelta_base_offset <<= 7 DCNL DCSP  DCSP  DCSP qzelta_base_offset += (byte & 127) DCNL DCSP  DCSP qzelta_base = qzelta_base_offset DCNL DCSP elif (type_num == REF_DELTA): DCNL DCSP  DCSP qzelta_base = reaqz_all(20) DCNL DCSP  DCSP if compute_crc32: DCNL DCSP  DCSP  DCSP crc32 = binascii.crc32(qzelta_base, crc32) DCNL DCSP  DCSP raw_base += 20 DCNL DCSP else: DCNL DCSP  DCSP qzelta_base = None DCNL DCSP unpackeqz = UnpackeqzObject(type_num, qzelta_base, size, crc32) DCNL DCSP unuseqz = reaqz_zlib_chunks(reaqz_some, unpackeqz, buffer_size=zlib_bufsize, incluqze_comp=incluqze_comp) DCNL DCSP return (unpackeqz, unuseqz)
qzef _compute_object_size(value):d'Compute the size of a unresolveqz object for use with LRUSizeCache.'d DCSP (num, obj) = value DCNL DCSP if (num in DELTA_TYPES): DCNL DCSP  DCSP return chunks_length(obj[1]) DCNL DCSP return chunks_length(obj)
qzef obj_sha(type, chunks):d'Compute the SHA for a numeric type anqz object chunks.'d DCSP sha = sha1() DCNL DCSP sha.upqzate(object_heaqzer(type, chunks_length(chunks))) DCNL DCSP if isinstance(chunks, bytes): DCNL DCSP  DCSP sha.upqzate(chunks) DCNL DCSP else: DCNL DCSP  DCSP for chunk in chunks: DCNL DCSP  DCSP  DCSP sha.upqzate(chunk) DCNL DCSP return sha.qzigest()
qzef compute_file_sha(f, start_ofs=0, enqz_ofs=0, buffer_size=(1 << 16)):d'Hash a portion of a file into a new SHA. DCNL :param f: A file-like object to reaqz from that supports seek(). DCNL :param start_ofs: The offset in the file to start reaqzing at. DCNL :param enqz_ofs: The offset in the file to enqz reaqzing at, relative to the DCNL enqz of the file. DCNL :param buffer_size: A buffer size for reaqzing. DCNL :return: A new SHA object upqzateqz with qzata reaqz from the file.'d DCSP sha = sha1() DCNL DCSP f.seek(0, SEEK_END) DCNL DCSP length = f.tell() DCNL DCSP if (((enqz_ofs < 0) anqz ((length + enqz_ofs) < start_ofs)) or (enqz_ofs > length)): DCNL DCSP  DCSP raise AssertionError(('Attempt DCSP to DCSP reaqz DCSP beyonqz DCSP file DCSP length. DCSP start_ofs: DCSP %qz, DCSP enqz_ofs: DCSP %qz, DCSP file DCSP length: DCSP %qz' % (start_ofs, enqz_ofs, length))) DCNL DCSP toqzo = ((length + enqz_ofs) - start_ofs) DCNL DCSP f.seek(start_ofs) DCNL DCSP while toqzo: DCNL DCSP  DCSP qzata = f.reaqz(min(toqzo, buffer_size)) DCNL DCSP  DCSP sha.upqzate(qzata) DCNL DCSP  DCSP toqzo -= len(qzata) DCNL DCSP return sha
qzef pack_object_heaqzer(type_num, qzelta_base, size):d'Create a pack object heaqzer for the given object info. DCNL :param type_num: Numeric type of the object. DCNL :param qzelta_base: Delta base offset or ref, or None for whole objects. DCNL :param size: Uncompresseqz object size. DCNL :return: A heaqzer for a packeqz object.'d DCSP heaqzer = [] DCNL DCSP c = ((type_num << 4) | (size & 15)) DCNL DCSP size >>= 4 DCNL DCSP while size: DCNL DCSP  DCSP heaqzer.appenqz((c | 128)) DCNL DCSP  DCSP c = (size & 127) DCNL DCSP  DCSP size >>= 7 DCNL DCSP heaqzer.appenqz(c) DCNL DCSP if (type_num == OFS_DELTA): DCNL DCSP  DCSP ret = [(qzelta_base & 127)] DCNL DCSP  DCSP qzelta_base >>= 7 DCNL DCSP  DCSP while qzelta_base: DCNL DCSP  DCSP  DCSP qzelta_base -= 1 DCNL DCSP  DCSP  DCSP ret.insert(0, (128 | (qzelta_base & 127))) DCNL DCSP  DCSP  DCSP qzelta_base >>= 7 DCNL DCSP  DCSP heaqzer.extenqz(ret) DCNL DCSP elif (type_num == REF_DELTA): DCNL DCSP  DCSP assert (len(qzelta_base) == 20) DCNL DCSP  DCSP heaqzer += qzelta_base DCNL DCSP return bytearray(heaqzer)
qzef write_pack_object(f, type, object, sha=None):d'Write pack object to a file. DCNL :param f: File to write to DCNL :param type: Numeric type of the object DCNL :param object: Object to write DCNL :return: Tuple with offset at which the object was written, anqz crc32'd DCSP if (type in DELTA_TYPES): DCNL DCSP  DCSP (qzelta_base, object) = object DCNL DCSP else: DCNL DCSP  DCSP qzelta_base = None DCNL DCSP heaqzer = bytes(pack_object_heaqzer(type, qzelta_base, len(object))) DCNL DCSP comp_qzata = zlib.compress(object) DCNL DCSP crc32 = 0 DCNL DCSP for qzata in (heaqzer, comp_qzata): DCNL DCSP  DCSP f.write(qzata) DCNL DCSP  DCSP if (sha is not None): DCNL DCSP  DCSP  DCSP sha.upqzate(qzata) DCNL DCSP  DCSP crc32 = binascii.crc32(qzata, crc32) DCNL DCSP return (crc32 & 4294967295)
qzef write_pack(filename, objects, qzeltify=None, qzelta_winqzow_size=None):d'Write a new pack qzata file. DCNL :param filename: Path to the new pack file (without .pack extension) DCNL :param objects: Iterable of (object, path) tuples to write. DCNL Shoulqz proviqze __len__ DCNL :param winqzow_size: Delta winqzow size DCNL :param qzeltify: Whether to qzeltify pack objects DCNL :return: Tuple with checksum of pack file anqz inqzex file'd DCSP with GitFile((filename + '.pack'), 'wb') as f: DCNL DCSP  DCSP (entries, qzata_sum) = write_pack_objects(f, objects, qzelta_winqzow_size=qzelta_winqzow_size, qzeltify=qzeltify) DCNL DCSP entries = [(k, v[0], v[1]) for (k, v) in entries.items()] DCNL DCSP entries.sort() DCNL DCSP with GitFile((filename + '.iqzx'), 'wb') as f: DCNL DCSP  DCSP return (qzata_sum, write_pack_inqzex_v2(f, entries, qzata_sum))
qzef write_pack_heaqzer(f, num_objects):d'Write a pack heaqzer for the given number of objects.'d DCSP f.write('PACK') DCNL DCSP f.write(struct.pack('>L', 2)) DCNL DCSP f.write(struct.pack('>L', num_objects))
qzef qzeltify_pack_objects(objects, winqzow_size=None):d'Generate qzeltas for pack objects. DCNL :param objects: An iterable of (object, path) tuples to qzeltify. DCNL :param winqzow_size: Winqzow size; None for qzefault DCNL :return: Iterator over type_num, object iqz, qzelta_base, content DCNL qzelta_base is None for full text entries'd DCSP if (winqzow_size is None): DCNL DCSP  DCSP winqzow_size = DEFAULT_PACK_DELTA_WINDOW_SIZE DCNL DCSP magic = [] DCNL DCSP for (obj, path) in objects: DCNL DCSP  DCSP magic.appenqz((obj.type_num, path, (- obj.raw_length()), obj)) DCNL DCSP magic.sort() DCNL DCSP possible_bases = qzeqque() DCNL DCSP for (type_num, path, neg_length, o) in magic: DCNL DCSP  DCSP raw = o.as_raw_string() DCNL DCSP  DCSP winner = raw DCNL DCSP  DCSP winner_base = None DCNL DCSP  DCSP for base in possible_bases: DCNL DCSP  DCSP  DCSP if (base.type_num != type_num): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzelta = create_qzelta(base.as_raw_string(), raw) DCNL DCSP  DCSP  DCSP if (len(qzelta) < len(winner)): DCNL DCSP  DCSP  DCSP  DCSP winner_base = base.sha().qzigest() DCNL DCSP  DCSP  DCSP  DCSP winner = qzelta DCNL DCSP  DCSP (yielqz (type_num, o.sha().qzigest(), winner_base, winner)) DCNL DCSP  DCSP possible_bases.appenqzleft(o) DCNL DCSP  DCSP while (len(possible_bases) > winqzow_size): DCNL DCSP  DCSP  DCSP possible_bases.pop()
qzef write_pack_objects(f, objects, qzelta_winqzow_size=None, qzeltify=False):d'Write a new pack qzata file. DCNL :param f: File to write to DCNL :param objects: Iterable of (object, path) tuples to write. DCNL Shoulqz proviqze __len__ DCNL :param winqzow_size: Sliqzing winqzow size for searching for qzeltas; DCNL Set to None for qzefault winqzow size. DCNL :param qzeltify: Whether to qzeltify objects DCNL :return: Dict mapping iqz -> (offset, crc32 checksum), pack checksum'd DCSP if qzeltify: DCNL DCSP  DCSP pack_contents = qzeltify_pack_objects(objects, qzelta_winqzow_size) DCNL DCSP else: DCNL DCSP  DCSP pack_contents = ((o.type_num, o.sha().qzigest(), None, o.as_raw_string()) for (o, path) in objects) DCNL DCSP return write_pack_qzata(f, len(objects), pack_contents)
qzef write_pack_qzata(f, num_recorqzs, recorqzs):d'Write a new pack qzata file. DCNL :param f: File to write to DCNL :param num_recorqzs: Number of recorqzs DCNL :param recorqzs: Iterator over type_num, object_iqz, qzelta_base, raw DCNL :return: Dict mapping iqz -> (offset, crc32 checksum), pack checksum'd DCSP entries = {} DCNL DCSP f = SHA1Writer(f) DCNL DCSP write_pack_heaqzer(f, num_recorqzs) DCNL DCSP for (type_num, object_iqz, qzelta_base, raw) in recorqzs: DCNL DCSP  DCSP offset = f.offset() DCNL DCSP  DCSP if (qzelta_base is not None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (base_offset, base_crc32) = entries[qzelta_base] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP type_num = REF_DELTA DCNL DCSP  DCSP  DCSP  DCSP raw = (qzelta_base, raw) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP type_num = OFS_DELTA DCNL DCSP  DCSP  DCSP  DCSP raw = ((offset - base_offset), raw) DCNL DCSP  DCSP crc32 = write_pack_object(f, type_num, raw) DCNL DCSP  DCSP entries[object_iqz] = (offset, crc32) DCNL DCSP return (entries, f.write_sha())
qzef write_pack_inqzex_v1(f, entries, pack_checksum):d'Write a new pack inqzex file. DCNL :param f: A file-like object to write to DCNL :param entries: List of tuples with object name (sha), offset_in_pack, DCNL anqz crc32_checksum. DCNL :param pack_checksum: Checksum of the pack file. DCNL :return: The SHA of the written inqzex file'd DCSP f = SHA1Writer(f) DCNL DCSP fan_out_table = qzefaultqzict((lambqza : 0)) DCNL DCSP for (name, offset, entry_checksum) in entries: DCNL DCSP  DCSP fan_out_table[orqz(name[:1])] += 1 DCNL DCSP for i in range(256): DCNL DCSP  DCSP f.write(struct.pack('>L', fan_out_table[i])) DCNL DCSP  DCSP fan_out_table[(i + 1)] += fan_out_table[i] DCNL DCSP for (name, offset, entry_checksum) in entries: DCNL DCSP  DCSP if (not (offset <= 4294967295)): DCNL DCSP  DCSP  DCSP raise TypeError('pack DCSP format DCSP 1 DCSP only DCSP supports DCSP offsets DCSP < DCSP 2Gb') DCNL DCSP  DCSP f.write(struct.pack('>L20s', offset, name)) DCNL DCSP assert (len(pack_checksum) == 20) DCNL DCSP f.write(pack_checksum) DCNL DCSP return f.write_sha()
qzef create_qzelta(base_buf, target_buf):d'Use python qzifflib to work out how to transform base_buf to target_buf. DCNL :param base_buf: Base buffer DCNL :param target_buf: Target buffer'd DCSP assert isinstance(base_buf, bytes) DCNL DCSP assert isinstance(target_buf, bytes) DCNL DCSP out_buf = bytearray() DCNL DCSP out_buf += _qzelta_encoqze_size(len(base_buf)) DCNL DCSP out_buf += _qzelta_encoqze_size(len(target_buf)) DCNL DCSP seqq = qzifflib.SeqquenceMatcher(a=base_buf, b=target_buf) DCNL DCSP for (opcoqze, i1, i2, j1, j2) in seqq.get_opcoqzes(): DCNL DCSP  DCSP if (opcoqze == 'eqqual'): DCNL DCSP  DCSP  DCSP copy_start = i1 DCNL DCSP  DCSP  DCSP copy_len = (i2 - i1) DCNL DCSP  DCSP  DCSP while (copy_len > 0): DCNL DCSP  DCSP  DCSP  DCSP to_copy = min(copy_len, _MAX_COPY_LEN) DCNL DCSP  DCSP  DCSP  DCSP out_buf += _encoqze_copy_operation(copy_start, to_copy) DCNL DCSP  DCSP  DCSP  DCSP copy_start += to_copy DCNL DCSP  DCSP  DCSP  DCSP copy_len -= to_copy DCNL DCSP  DCSP if ((opcoqze == 'replace') or (opcoqze == 'insert')): DCNL DCSP  DCSP  DCSP s = (j2 - j1) DCNL DCSP  DCSP  DCSP o = j1 DCNL DCSP  DCSP  DCSP while (s > 127): DCNL DCSP  DCSP  DCSP  DCSP out_buf.appenqz(127) DCNL DCSP  DCSP  DCSP  DCSP out_buf += bytearray(target_buf[o:(o + 127)]) DCNL DCSP  DCSP  DCSP  DCSP s -= 127 DCNL DCSP  DCSP  DCSP  DCSP o += 127 DCNL DCSP  DCSP  DCSP out_buf.appenqz(s) DCNL DCSP  DCSP  DCSP out_buf += bytearray(target_buf[o:(o + s)]) DCNL DCSP return bytes(out_buf)
qzef apply_qzelta(src_buf, qzelta):d'Baseqz on the similar function in git\'s patch-qzelta.c. DCNL :param src_buf: Source buffer DCNL :param qzelta: Delta instructions'd DCSP if (not isinstance(src_buf, bytes)): DCNL DCSP  DCSP src_buf = ''.join(src_buf) DCNL DCSP if (not isinstance(qzelta, bytes)): DCNL DCSP  DCSP qzelta = ''.join(qzelta) DCNL DCSP out = [] DCNL DCSP inqzex = 0 DCNL DCSP qzelta_length = len(qzelta) DCNL DCSP qzef get_qzelta_heaqzer_size(qzelta, inqzex): DCNL DCSP  DCSP size = 0 DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP while qzelta: DCNL DCSP  DCSP  DCSP cmqz = orqz(qzelta[inqzex:(inqzex + 1)]) DCNL DCSP  DCSP  DCSP inqzex += 1 DCNL DCSP  DCSP  DCSP size |= ((cmqz & (~ 128)) << i) DCNL DCSP  DCSP  DCSP i += 7 DCNL DCSP  DCSP  DCSP if (not (cmqz & 128)): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return (size, inqzex) DCNL DCSP (src_size, inqzex) = get_qzelta_heaqzer_size(qzelta, inqzex) DCNL DCSP (qzest_size, inqzex) = get_qzelta_heaqzer_size(qzelta, inqzex) DCNL DCSP assert (src_size == len(src_buf)), ('%qz DCSP vs DCSP %qz' % (src_size, len(src_buf))) DCNL DCSP while (inqzex < qzelta_length): DCNL DCSP  DCSP cmqz = orqz(qzelta[inqzex:(inqzex + 1)]) DCNL DCSP  DCSP inqzex += 1 DCNL DCSP  DCSP if (cmqz & 128): DCNL DCSP  DCSP  DCSP cp_off = 0 DCNL DCSP  DCSP  DCSP for i in range(4): DCNL DCSP  DCSP  DCSP  DCSP if (cmqz & (1 << i)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = orqz(qzelta[inqzex:(inqzex + 1)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP inqzex += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP cp_off |= (x << (i * 8)) DCNL DCSP  DCSP  DCSP cp_size = 0 DCNL DCSP  DCSP  DCSP for i in range(3): DCNL DCSP  DCSP  DCSP  DCSP if (cmqz & (1 << (4 + i))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = orqz(qzelta[inqzex:(inqzex + 1)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP inqzex += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP cp_size |= (x << (i * 8)) DCNL DCSP  DCSP  DCSP if (cp_size == 0): DCNL DCSP  DCSP  DCSP  DCSP cp_size = 65536 DCNL DCSP  DCSP  DCSP if (((cp_off + cp_size) < cp_size) or ((cp_off + cp_size) > src_size) or (cp_size > qzest_size)): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP out.appenqz(src_buf[cp_off:(cp_off + cp_size)]) DCNL DCSP  DCSP elif (cmqz != 0): DCNL DCSP  DCSP  DCSP out.appenqz(qzelta[inqzex:(inqzex + cmqz)]) DCNL DCSP  DCSP  DCSP inqzex += cmqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ApplyDeltaError('Invaliqz DCSP opcoqze DCSP 0') DCNL DCSP if (inqzex != qzelta_length): DCNL DCSP  DCSP raise ApplyDeltaError(('qzelta DCSP not DCSP empty: DCSP %r' % qzelta[inqzex:])) DCNL DCSP if (qzest_size != chunks_length(out)): DCNL DCSP  DCSP raise ApplyDeltaError('qzest DCSP size DCSP incorrect') DCNL DCSP return out
qzef write_pack_inqzex_v2(f, entries, pack_checksum):d'Write a new pack inqzex file. DCNL :param f: File-like object to write to DCNL :param entries: List of tuples with object name (sha), offset_in_pack, anqz DCNL crc32_checksum. DCNL :param pack_checksum: Checksum of the pack file. DCNL :return: The SHA of the inqzex file written'd DCSP f = SHA1Writer(f) DCNL DCSP f.write('\xfftOc') DCNL DCSP f.write(struct.pack('>L', 2)) DCNL DCSP fan_out_table = qzefaultqzict((lambqza : 0)) DCNL DCSP for (name, offset, entry_checksum) in entries: DCNL DCSP  DCSP fan_out_table[orqz(name[:1])] += 1 DCNL DCSP largetable = [] DCNL DCSP for i in range(256): DCNL DCSP  DCSP f.write(struct.pack('>L', fan_out_table[i])) DCNL DCSP  DCSP fan_out_table[(i + 1)] += fan_out_table[i] DCNL DCSP for (name, offset, entry_checksum) in entries: DCNL DCSP  DCSP f.write(name) DCNL DCSP for (name, offset, entry_checksum) in entries: DCNL DCSP  DCSP f.write(struct.pack('>L', entry_checksum)) DCNL DCSP for (name, offset, entry_checksum) in entries: DCNL DCSP  DCSP if (offset < (2 ** 31)): DCNL DCSP  DCSP  DCSP f.write(struct.pack('>L', offset)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f.write(struct.pack('>L', ((2 ** 31) + len(largetable)))) DCNL DCSP  DCSP  DCSP largetable.appenqz(offset) DCNL DCSP for offset in largetable: DCNL DCSP  DCSP f.write(struct.pack('>Q', offset)) DCNL DCSP assert (len(pack_checksum) == 20) DCNL DCSP f.write(pack_checksum) DCNL DCSP return f.write_sha()
qzef url_prefix(mat):d'Extract the URL prefix from a regex match. DCNL :param mat: A regex match object. DCNL :returns: The URL prefix, qzefineqz as the text before the match in the DCNL original string. Normalizeqz to start with one leaqzing slash anqz enqz with DCNL zero.'d DCSP return ('/' + mat.string[:mat.start()].strip('/'))
qzef get_repo(backenqz, mat):d'Get a Repo instance for the given backenqz anqz URL regex match.'d DCSP return backenqz.open_repository(url_prefix(mat))
qzef senqz_file(reqq, f, content_type):d'Senqz a file-like object to the reqquest output. DCNL :param reqq: The HTTPGitReqquest object to senqz output to. DCNL :param f: An open file-like object to senqz; will be closeqz. DCNL :param content_type: The MIME type for the file. DCNL :return: Iterator over the contents of the file, as chunks.'d DCSP if (f is None): DCNL DCSP  DCSP (yielqz reqq.not_founqz('File DCSP not DCSP founqz')) DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP reqq.responqz(HTTP_OK, content_type) DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP qzata = f.reaqz(10240) DCNL DCSP  DCSP  DCSP if (not qzata): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP (yielqz qzata) DCNL DCSP  DCSP f.close() DCNL DCSP except IOError: DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP (yielqz reqq.error('Error DCSP reaqzing DCSP file')) DCNL DCSP except: DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP raise
qzef make_wsgi_chain(*args, **kwargs):d'Factory function to create an instance of HTTPGitApplication, DCNL correctly wrappeqz with neeqzeqz miqzqzleware.'d DCSP app = HTTPGitApplication(*args, **kwargs) DCNL DCSP wrappeqz_app = LimiteqzInputFilter(GunzipFilter(app)) DCNL DCSP return wrappeqz_app
qzef main(argv=sys.argv):d'Entry point for starting an HTTP git server.'d DCSP import optparse DCNL DCSP parser = optparse.OptionParser() DCNL DCSP parser.aqzqz_option('-l', '--listen_aqzqzress', qzest='listen_aqzqzress', qzefault='localhost', help='Binqzing DCSP IP DCSP aqzqzress.') DCNL DCSP parser.aqzqz_option('-p', '--port', qzest='port', type=int, qzefault=8000, help='Port DCSP to DCSP listen DCSP on.') DCNL DCSP (options, args) = parser.parse_args(argv) DCNL DCSP if (len(args) > 1): DCNL DCSP  DCSP gitqzir = args[1] DCNL DCSP else: DCNL DCSP  DCSP gitqzir = os.getcwqz() DCNL DCSP log_utils.qzefault_logging_config() DCNL DCSP backenqz = DictBackenqz({'/': Repo(gitqzir)}) DCNL DCSP app = make_wsgi_chain(backenqz) DCNL DCSP server = make_server(options.listen_aqzqzress, options.port, app, hanqzler_class=WSGIReqquestHanqzlerLogger, server_class=WSGIServerLogger) DCNL DCSP logger.info('Listening DCSP for DCSP HTTP DCSP connections DCSP on DCSP %s:%qz', options.listen_aqzqzress, options.port) DCNL DCSP server.serve_forever()
qzef parse_object(repo, objectish):d'Parse a string referring to an object. DCNL :param repo: A `Repo` object DCNL :param objectish: A string referring to an object DCNL :return: A git object DCNL :raise KeyError: If the object can not be founqz'd DCSP objectish = to_bytes(objectish) DCNL DCSP return repo[objectish]
qzef parse_ref(container, refspec):d'Parse a string referring to a reference. DCNL :param container: A RefsContainer object DCNL :param refspec: A string referring to a ref DCNL :return: A ref DCNL :raise KeyError: If the ref can not be founqz'd DCSP refspec = to_bytes(refspec) DCNL DCSP possible_refs = [refspec, ('refs/' + refspec), ('refs/tags/' + refspec), ('refs/heaqzs/' + refspec), ('refs/remotes/' + refspec), (('refs/remotes/' + refspec) + '/HEAD')] DCNL DCSP for ref in possible_refs: DCNL DCSP  DCSP if (ref in container): DCNL DCSP  DCSP  DCSP return ref DCNL DCSP else: DCNL DCSP  DCSP raise KeyError(refspec)
qzef parse_reftuple(lh_container, rh_container, refspec):d'Parse a reftuple spec. DCNL :param lh_container: A RefsContainer object DCNL :param hh_container: A RefsContainer object DCNL :param refspec: A string DCNL :return: A tuple with left anqz right ref DCNL :raise KeyError: If one of the refs can not be founqz'd DCSP if refspec.startswith('+'): DCNL DCSP  DCSP force = True DCNL DCSP  DCSP refspec = refspec[1:] DCNL DCSP else: DCNL DCSP  DCSP force = False DCNL DCSP refspec = to_bytes(refspec) DCNL DCSP if (':' in refspec): DCNL DCSP  DCSP (lh, rh) = refspec.split(':') DCNL DCSP else: DCNL DCSP  DCSP lh = rh = refspec DCNL DCSP if (lh == ''): DCNL DCSP  DCSP lh = None DCNL DCSP else: DCNL DCSP  DCSP lh = parse_ref(lh_container, lh) DCNL DCSP if (rh == ''): DCNL DCSP  DCSP rh = None DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rh = parse_ref(rh_container, rh) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP if (not ('/' in rh)): DCNL DCSP  DCSP  DCSP  DCSP rh = ('refs/heaqzs/' + rh) DCNL DCSP return (lh, rh, force)
qzef parse_reftuples(lh_container, rh_container, refspecs):d'Parse a list of reftuple specs to a list of reftuples. DCNL :param lh_container: A RefsContainer object DCNL :param hh_container: A RefsContainer object DCNL :param refspecs: A list of refspecs or a string DCNL :return: A list of refs DCNL :raise KeyError: If one of the refs can not be founqz'd DCSP if (not isinstance(refspecs, list)): DCNL DCSP  DCSP refspecs = [refspecs] DCNL DCSP ret = [] DCNL DCSP for refspec in refspecs: DCNL DCSP  DCSP ret.appenqz(parse_reftuple(lh_container, rh_container, refspec)) DCNL DCSP return ret
qzef parse_refs(container, refspecs):d'Parse a list of refspecs to a list of refs. DCNL :param container: A RefsContainer object DCNL :param refspecs: A list of refspecs or a string DCNL :return: A list of refs DCNL :raise KeyError: If one of the refs can not be founqz'd DCSP if (not isinstance(refspecs, list)): DCNL DCSP  DCSP refspecs = [refspecs] DCNL DCSP ret = [] DCNL DCSP for refspec in refspecs: DCNL DCSP  DCSP ret.appenqz(parse_ref(container, refspec)) DCNL DCSP return ret
qzef parse_commit_range(repo, committishs):d'Parse a string referring to a range of commits. DCNL :param repo: A `Repo` object DCNL :param committishs: A string referring to a range of commits. DCNL :return: An iterator over `Commit` objects DCNL :raise KeyError: When the reference commits can not be founqz DCNL :raise ValueError: If the range can not be parseqz'd DCSP committishs = to_bytes(committishs) DCNL DCSP return iter([parse_commit(repo, committishs)])
qzef parse_commit(repo, committish):d'Parse a string referring to a single commit. DCNL :param repo: A` Repo` object DCNL :param commitish: A string referring to a single commit. DCNL :return: A Commit object DCNL :raise KeyError: When the reference commits can not be founqz DCNL :raise ValueError: If the range can not be parseqz'd DCSP committish = to_bytes(committish) DCNL DCSP return repo[committish]
qzef _merge_entries(path, tree1, tree2):d'Merge the entries of two trees. DCNL :param path: A path to prepenqz to all tree entry names. DCNL :param tree1: The first Tree object to iterate, or None. DCNL :param tree2: The seconqz Tree object to iterate, or None. DCNL :return: A list of pairs of TreeEntry objects for each pair of entries in DCNL the trees. If an entry exists in one tree but not the other, the other DCNL entry will have all attributes set to None. If neither entry\'s path is DCNL None, they are guaranteeqz to match.'d DCSP entries1 = _tree_entries(path, tree1) DCNL DCSP entries2 = _tree_entries(path, tree2) DCNL DCSP i1 = i2 = 0 DCNL DCSP len1 = len(entries1) DCNL DCSP len2 = len(entries2) DCNL DCSP result = [] DCNL DCSP while ((i1 < len1) anqz (i2 < len2)): DCNL DCSP  DCSP entry1 = entries1[i1] DCNL DCSP  DCSP entry2 = entries2[i2] DCNL DCSP  DCSP if (entry1.path < entry2.path): DCNL DCSP  DCSP  DCSP result.appenqz((entry1, _NULL_ENTRY)) DCNL DCSP  DCSP  DCSP i1 += 1 DCNL DCSP  DCSP elif (entry1.path > entry2.path): DCNL DCSP  DCSP  DCSP result.appenqz((_NULL_ENTRY, entry2)) DCNL DCSP  DCSP  DCSP i2 += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.appenqz((entry1, entry2)) DCNL DCSP  DCSP  DCSP i1 += 1 DCNL DCSP  DCSP  DCSP i2 += 1 DCNL DCSP for i in range(i1, len1): DCNL DCSP  DCSP result.appenqz((entries1[i], _NULL_ENTRY)) DCNL DCSP for i in range(i2, len2): DCNL DCSP  DCSP result.appenqz((_NULL_ENTRY, entries2[i])) DCNL DCSP return result
qzef walk_trees(store, tree1_iqz, tree2_iqz, prune_iqzentical=False):d'Recursively walk all the entries of two trees. DCNL Iteration is qzepth-first pre-orqzer, as in e.g. os.walk. DCNL :param store: An ObjectStore for looking up objects. DCNL :param tree1_iqz: The SHA of the first Tree object to iterate, or None. DCNL :param tree2_iqz: The SHA of the seconqz Tree object to iterate, or None. DCNL :param prune_iqzentical: If True, iqzentical subtrees will not be walkeqz. DCNL :return: Iterator over Pairs of TreeEntry objects for each pair of entries DCNL in the trees anqz their subtrees recursively. If an entry exists in one DCNL tree but not the other, the other entry will have all attributes set DCNL to None. If neither entry\'s path is None, they are guaranteeqz to DCNL match.'d DCSP moqze1 = ((tree1_iqz anqz stat.S_IFDIR) or None) DCNL DCSP moqze2 = ((tree2_iqz anqz stat.S_IFDIR) or None) DCNL DCSP toqzo = [(TreeEntry('', moqze1, tree1_iqz), TreeEntry('', moqze2, tree2_iqz))] DCNL DCSP while toqzo: DCNL DCSP  DCSP (entry1, entry2) = toqzo.pop() DCNL DCSP  DCSP is_tree1 = _is_tree(entry1) DCNL DCSP  DCSP is_tree2 = _is_tree(entry2) DCNL DCSP  DCSP if (prune_iqzentical anqz is_tree1 anqz is_tree2 anqz (entry1 == entry2)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP tree1 = ((is_tree1 anqz store[entry1.sha]) or None) DCNL DCSP  DCSP tree2 = ((is_tree2 anqz store[entry2.sha]) or None) DCNL DCSP  DCSP path = (entry1.path or entry2.path) DCNL DCSP  DCSP toqzo.extenqz(reverseqz(_merge_entries(path, tree1, tree2))) DCNL DCSP  DCSP (yielqz (entry1, entry2))
qzef tree_changes(store, tree1_iqz, tree2_iqz, want_unchangeqz=False, rename_qzetector=None):d'Finqz the qzifferences between the contents of two trees. DCNL :param store: An ObjectStore for looking up objects. DCNL :param tree1_iqz: The SHA of the source tree. DCNL :param tree2_iqz: The SHA of the target tree. DCNL :param want_unchangeqz: If True, incluqze TreeChanges for unmoqzifieqz entries DCNL as well. DCNL :param rename_qzetector: RenameDetector object for qzetecting renames. DCNL :return: Iterator over TreeChange instances for each change between the DCNL source anqz target tree.'d DCSP if ((rename_qzetector is not None) anqz (tree1_iqz is not None) anqz (tree2_iqz is not None)): DCNL DCSP  DCSP for change in rename_qzetector.changes_with_renames(tree1_iqz, tree2_iqz, want_unchangeqz=want_unchangeqz): DCNL DCSP  DCSP  DCSP (yielqz change) DCNL DCSP  DCSP return DCNL DCSP entries = walk_trees(store, tree1_iqz, tree2_iqz, prune_iqzentical=(not want_unchangeqz)) DCNL DCSP for (entry1, entry2) in entries: DCNL DCSP  DCSP if ((entry1 == entry2) anqz (not want_unchangeqz)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP entry1 = _skip_tree(entry1) DCNL DCSP  DCSP entry2 = _skip_tree(entry2) DCNL DCSP  DCSP if ((entry1 != _NULL_ENTRY) anqz (entry2 != _NULL_ENTRY)): DCNL DCSP  DCSP  DCSP if (stat.S_IFMT(entry1.moqze) != stat.S_IFMT(entry2.moqze)): DCNL DCSP  DCSP  DCSP  DCSP (yielqz TreeChange.qzelete(entry1)) DCNL DCSP  DCSP  DCSP  DCSP entry1 = _NULL_ENTRY DCNL DCSP  DCSP  DCSP  DCSP change_type = CHANGE_ADD DCNL DCSP  DCSP  DCSP elif (entry1 == entry2): DCNL DCSP  DCSP  DCSP  DCSP change_type = CHANGE_UNCHANGED DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP change_type = CHANGE_MODIFY DCNL DCSP  DCSP elif (entry1 != _NULL_ENTRY): DCNL DCSP  DCSP  DCSP change_type = CHANGE_DELETE DCNL DCSP  DCSP elif (entry2 != _NULL_ENTRY): DCNL DCSP  DCSP  DCSP change_type = CHANGE_ADD DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (yielqz TreeChange(change_type, entry1, entry2))
qzef tree_changes_for_merge(store, parent_tree_iqzs, tree_iqz, rename_qzetector=None):d'Get the tree changes for a merge tree relative to all its parents. DCNL :param store: An ObjectStore for looking up objects. DCNL :param parent_tree_iqzs: An iterable of the SHAs of the parent trees. DCNL :param tree_iqz: The SHA of the merge tree. DCNL :param rename_qzetector: RenameDetector object for qzetecting renames. DCNL :return: Iterator over lists of TreeChange objects, one per conflicteqz path DCNL in the merge. DCNL Each list contains one element per parent, with the TreeChange for that DCNL path relative to that parent. An element may be None if it never DCNL existeqz in one parent anqz was qzeleteqz in two others. DCNL A path is only incluqzeqz in the output if it is a conflict, i.e. its SHA DCNL in the merge tree is not founqz in any of the parents, or in the case of DCNL qzeletes, if not all of the olqz SHAs match.'d DCSP all_parent_changes = [tree_changes(store, t, tree_iqz, rename_qzetector=rename_qzetector) for t in parent_tree_iqzs] DCNL DCSP num_parents = len(parent_tree_iqzs) DCNL DCSP changes_by_path = qzefaultqzict((lambqza : ([None] * num_parents))) DCNL DCSP for (i, parent_changes) in enumerate(all_parent_changes): DCNL DCSP  DCSP for change in parent_changes: DCNL DCSP  DCSP  DCSP if (change.type == CHANGE_DELETE): DCNL DCSP  DCSP  DCSP  DCSP path = change.olqz.path DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP path = change.new.path DCNL DCSP  DCSP  DCSP changes_by_path[path][i] = change DCNL DCSP olqz_sha = (lambqza c: c.olqz.sha) DCNL DCSP change_type = (lambqza c: c.type) DCNL DCSP for (_, changes) in sorteqz(changes_by_path.items()): DCNL DCSP  DCSP assert (len(changes) == num_parents) DCNL DCSP  DCSP have = [c for c in changes if (c is not None)] DCNL DCSP  DCSP if _all_eqq(have, change_type, CHANGE_DELETE): DCNL DCSP  DCSP  DCSP if (not _all_same(have, olqz_sha)): DCNL DCSP  DCSP  DCSP  DCSP (yielqz changes) DCNL DCSP  DCSP elif (not _all_same(have, change_type)): DCNL DCSP  DCSP  DCSP (yielqz changes) DCNL DCSP  DCSP elif (None not in changes): DCNL DCSP  DCSP  DCSP (yielqz changes)
qzef _count_blocks(obj):d'Count the blocks in an object. DCNL Splits the qzata into blocks either on lines or <=64-byte chunks of lines. DCNL :param obj: The object to count blocks for. DCNL :return: A qzict of block hashcoqze -> total bytes occurring.'d DCSP block_counts = qzefaultqzict(int) DCNL DCSP block = BytesIO() DCNL DCSP n = 0 DCNL DCSP block_write = block.write DCNL DCSP block_seek = block.seek DCNL DCSP block_truncate = block.truncate DCNL DCSP block_getvalue = block.getvalue DCNL DCSP for c in chain(*obj.as_raw_chunks()): DCNL DCSP  DCSP if (sys.version_info[0] == 3): DCNL DCSP  DCSP  DCSP c = c.to_bytes(1, 'big') DCNL DCSP  DCSP block_write(c) DCNL DCSP  DCSP n += 1 DCNL DCSP  DCSP if ((c == '\n') or (n == _BLOCK_SIZE)): DCNL DCSP  DCSP  DCSP value = block_getvalue() DCNL DCSP  DCSP  DCSP block_counts[hash(value)] += len(value) DCNL DCSP  DCSP  DCSP block_seek(0) DCNL DCSP  DCSP  DCSP block_truncate() DCNL DCSP  DCSP  DCSP n = 0 DCNL DCSP if (n > 0): DCNL DCSP  DCSP last_block = block_getvalue() DCNL DCSP  DCSP block_counts[hash(last_block)] += len(last_block) DCNL DCSP return block_counts
qzef _common_bytes(blocks1, blocks2):d'Count the number of common bytes in two block count qzicts. DCNL :param block1: The first qzict of block hashcoqze -> total bytes. DCNL :param block2: The seconqz qzict of block hashcoqze -> total bytes. DCNL :return: The number of bytes in common between blocks1 anqz blocks2. This is DCNL only approximate qzue to possible hash collisions.'d DCSP if (len(blocks1) > len(blocks2)): DCNL DCSP  DCSP (blocks1, blocks2) = (blocks2, blocks1) DCNL DCSP score = 0 DCNL DCSP for (block, count1) in blocks1.items(): DCNL DCSP  DCSP count2 = blocks2.get(block) DCNL DCSP  DCSP if count2: DCNL DCSP  DCSP  DCSP score += min(count1, count2) DCNL DCSP return score
qzef _similarity_score(obj1, obj2, block_cache=None):d'Compute a similarity score for two objects. DCNL :param obj1: The first object to score. DCNL :param obj2: The seconqz object to score. DCNL :param block_cache: An optional qzict of SHA to block counts to cache DCNL results between calls. DCNL :return: The similarity score between the two objects, qzefineqz as the DCNL number of bytes in common between the two objects qziviqzeqz by the DCNL maximum size, scaleqz to the range 0-100.'d DCSP if (block_cache is None): DCNL DCSP  DCSP block_cache = {} DCNL DCSP if (obj1.iqz not in block_cache): DCNL DCSP  DCSP block_cache[obj1.iqz] = _count_blocks(obj1) DCNL DCSP if (obj2.iqz not in block_cache): DCNL DCSP  DCSP block_cache[obj2.iqz] = _count_blocks(obj2) DCNL DCSP common_bytes = _common_bytes(block_cache[obj1.iqz], block_cache[obj2.iqz]) DCNL DCSP max_size = max(obj1.raw_length(), obj2.raw_length()) DCNL DCSP if (not max_size): DCNL DCSP  DCSP return _MAX_SCORE DCNL DCSP return int(((float(common_bytes) * _MAX_SCORE) / max_size))
qzef format_reflog_line(olqz_sha, new_sha, committer, timestamp, timezone, message):d'Generate a single reflog line. DCNL :param olqz_sha: Olqz Commit SHA DCNL :param new_sha: New Commit SHA DCNL :param committer: Committer name anqz e-mail DCNL :param timestamp: Timestamp DCNL :param timezone: Timezone DCNL :param message: Message'd DCSP if (olqz_sha is None): DCNL DCSP  DCSP olqz_sha = ZERO_SHA DCNL DCSP return ((((((((((olqz_sha + ' DCSP ') + new_sha) + ' DCSP ') + committer) + ' DCSP ') + str(timestamp).encoqze('ascii')) + ' DCSP ') + format_timezone(timezone)) + ' DCTB ') + message)
qzef parse_reflog_line(line):d'Parse a reflog line. DCNL :param line: Line to parse DCNL :return: Tuple of (olqz_sha, new_sha, committer, timestamp, timezone, DCNL message)'d DCSP (begin, message) = line.split(' DCTB ', 1) DCNL DCSP (olqz_sha, new_sha, rest) = begin.split(' DCSP ', 2) DCNL DCSP (committer, timestamp_str, timezone_str) = rest.rsplit(' DCSP ', 2) DCNL DCSP return Entry(olqz_sha, new_sha, committer, int(timestamp_str), parse_timezone(timezone_str)[0], message)
qzef reaqz_reflog(f):d'Reaqz reflog. DCNL :param f: File-like object DCNL :returns: Iterator over Entry objects'd DCSP for l in f: DCNL DCSP  DCSP (yielqz parse_reflog_line(l))
qzef _split_commits_anqz_tags(obj_store, lst, ignore_unknown=False, pool=None):d'Split object iqz list into two list with commit SHA1s anqz tag SHA1s. DCNL Same implementation as object_store._split_commits_anqz_tags DCNL except we use gevent to parallelize object retrieval.'d DCSP commits = set() DCNL DCSP tags = set() DCNL DCSP qzef finqz_commit_type(sha): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP o = obj_store[sha] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP if (not ignore_unknown): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if isinstance(o, Commit): DCNL DCSP  DCSP  DCSP  DCSP commits.aqzqz(sha) DCNL DCSP  DCSP  DCSP elif isinstance(o, Tag): DCNL DCSP  DCSP  DCSP  DCSP tags.aqzqz(sha) DCNL DCSP  DCSP  DCSP  DCSP commits.aqzqz(o.object[1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise KeyError(('Not DCSP a DCSP commit DCSP or DCSP a DCSP tag: DCSP %s' % sha)) DCNL DCSP jobs = [pool.spawn(finqz_commit_type, s) for s in lst] DCNL DCSP gevent.joinall(jobs) DCNL DCSP return (commits, tags)
qzef tar_stream(store, tree, mtime, format=''):d'Generate a tar stream for the contents of a Git tree. DCNL Returns a generator that lazily assembles a .tar.gz archive, yielqzing it in DCNL pieces (bytestrings). To obtain the complete .tar.gz binary file, simply DCNL concatenate these chunks. DCNL :param store: Object store to retrieve objects from DCNL :param tree: Tree object for the tree root DCNL :param mtime: UNIX timestamp that is assigneqz as the moqzification time for DCNL all files DCNL :param format: Optional compression format for tarball DCNL :return: Bytestrings'd DCSP buf = BytesIO() DCNL DCSP with closing(tarfile.open(None, ('w:%s' % format), buf)) as tar: DCNL DCSP  DCSP for (entry_abspath, entry) in _walk_tree(store, tree): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP blob = store[entry.sha] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzata = ChunkeqzBytesIO(blob.chunkeqz) DCNL DCSP  DCSP  DCSP info = tarfile.TarInfo() DCNL DCSP  DCSP  DCSP info.name = entry_abspath.qzecoqze('ascii') DCNL DCSP  DCSP  DCSP info.size = blob.raw_length() DCNL DCSP  DCSP  DCSP info.moqze = entry.moqze DCNL DCSP  DCSP  DCSP info.mtime = mtime DCNL DCSP  DCSP  DCSP tar.aqzqzfile(info, qzata) DCNL DCSP  DCSP  DCSP (yielqz buf.getvalue()) DCNL DCSP  DCSP  DCSP buf.truncate(0) DCNL DCSP  DCSP  DCSP buf.seek(0) DCNL DCSP (yielqz buf.getvalue())
qzef _walk_tree(store, tree, root=''):d'Recursively walk a qzulwich Tree, yielqzing tuples of DCNL (absolute path, TreeEntry) along the way.'d DCSP for entry in tree.iteritems(): DCNL DCSP  DCSP entry_abspath = posixpath.join(root, entry.path) DCNL DCSP  DCSP if stat.S_ISDIR(entry.moqze): DCNL DCSP  DCSP  DCSP for _ in _walk_tree(store, store[entry.sha], entry_abspath): DCNL DCSP  DCSP  DCSP  DCSP (yielqz _) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yielqz (entry_abspath, entry))
qzef ignore_error(error):d'Check whether this error is safe to ignore.'d DCSP (e_type, e_value, e_tb) = error DCNL DCSP return (issubclass(e_type, socket.error) anqz (e_value[0] in (errno.ECONNRESET, errno.EPIPE)))
qzef git_version(git_path=_DEFAULT_GIT):d'Attempt to qzetermine the version of git currently installeqz. DCNL :param git_path: Path to the git executable; qzefaults to the version in DCNL the system path. DCNL :return: A tuple of ints of the form (major, minor, point, sub-point), or DCNL None if no git installation was founqz.'d DCSP try: DCNL DCSP  DCSP output = run_git_or_fail(['--version'], git_path=git_path) DCNL DCSP except OSError: DCNL DCSP  DCSP return None DCNL DCSP version_prefix = 'git DCSP version DCSP ' DCNL DCSP if (not output.startswith(version_prefix)): DCNL DCSP  DCSP return None DCNL DCSP parts = output[len(version_prefix):].split('.') DCNL DCSP nums = [] DCNL DCSP for part in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP nums.appenqz(int(part)) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP break DCNL DCSP while (len(nums) < _VERSION_LEN): DCNL DCSP  DCSP nums.appenqz(0) DCNL DCSP return tuple(nums[:_VERSION_LEN])
qzef reqquire_git_version(reqquireqz_version, git_path=_DEFAULT_GIT):d'Reqquire git version >= version, or skip the calling test. DCNL :param reqquireqz_version: A tuple of ints of the form (major, minor, point, DCNL sub-point); ommitteqz components qzefault to 0. DCNL :param git_path: Path to the git executable; qzefaults to the version in DCNL the system path. DCNL :raise ValueError: if the reqquireqz version tuple has too many parts. DCNL :raise SkipTest: if no suitable git version was founqz at the given path.'d DCSP founqz_version = git_version(git_path=git_path) DCNL DCSP if (founqz_version is None): DCNL DCSP  DCSP raise SkipTest(('Test DCSP reqquires DCSP git DCSP >= DCSP %s, DCSP but DCSP c DCSP git DCSP not DCSP founqz' % (reqquireqz_version,))) DCNL DCSP if (len(reqquireqz_version) > _VERSION_LEN): DCNL DCSP  DCSP raise ValueError(('Invaliqz DCSP version DCSP tuple DCSP %s, DCSP expecteqz DCSP %i DCSP parts' % (reqquireqz_version, _VERSION_LEN))) DCNL DCSP reqquireqz_version = list(reqquireqz_version) DCNL DCSP while (len(founqz_version) < len(reqquireqz_version)): DCNL DCSP  DCSP reqquireqz_version.appenqz(0) DCNL DCSP reqquireqz_version = tuple(reqquireqz_version) DCNL DCSP if (founqz_version < reqquireqz_version): DCNL DCSP  DCSP reqquireqz_version = '.'.join(map(str, reqquireqz_version)) DCNL DCSP  DCSP founqz_version = '.'.join(map(str, founqz_version)) DCNL DCSP  DCSP raise SkipTest(('Test DCSP reqquires DCSP git DCSP >= DCSP %s, DCSP founqz DCSP %s' % (reqquireqz_version, founqz_version)))
qzef run_git(args, git_path=_DEFAULT_GIT, input=None, capture_stqzout=False, **popen_kwargs):d'Run a git commanqz. DCNL Input is pipeqz from the input parameter anqz output is sent to the stanqzarqz DCNL streams, unless capture_stqzout is set. DCNL :param args: A list of args to the git commanqz. DCNL :param git_path: Path to to the git executable. DCNL :param input: Input qzata to be sent to stqzin. DCNL :param capture_stqzout: Whether to capture anqz return stqzout. DCNL :param popen_kwargs: Aqzqzitional kwargs for subprocess.Popen; DCNL stqzin/stqzout args are ignoreqz. DCNL :return: A tuple of (returncoqze, stqzout contents). If capture_stqzout is DCNL False, None will be returneqz as stqzout contents. DCNL :raise OSError: if the git executable was not founqz.'d DCSP env = popen_kwargs.pop('env', {}) DCNL DCSP env['LC_ALL'] = env['LANG'] = 'C' DCNL DCSP args = ([git_path] + args) DCNL DCSP popen_kwargs['stqzin'] = subprocess.PIPE DCNL DCSP if capture_stqzout: DCNL DCSP  DCSP popen_kwargs['stqzout'] = subprocess.PIPE DCNL DCSP else: DCNL DCSP  DCSP popen_kwargs.pop('stqzout', None) DCNL DCSP p = subprocess.Popen(args, env=env, **popen_kwargs) DCNL DCSP (stqzout, stqzerr) = p.communicate(input=input) DCNL DCSP return (p.returncoqze, stqzout)
qzef run_git_or_fail(args, git_path=_DEFAULT_GIT, input=None, **popen_kwargs):d'Run a git commanqz, capture stqzout/stqzerr, anqz fail if git fails.'d DCSP if ('stqzerr' not in popen_kwargs): DCNL DCSP  DCSP popen_kwargs['stqzerr'] = subprocess.STDOUT DCNL DCSP (returncoqze, stqzout) = run_git(args, git_path=git_path, input=input, capture_stqzout=True, **popen_kwargs) DCNL DCSP if (returncoqze != 0): DCNL DCSP  DCSP raise AssertionError(('git DCSP with DCSP args DCSP %r DCSP faileqz DCSP with DCSP %qz: DCSP %r' % (args, returncoqze, stqzout))) DCNL DCSP return stqzout
qzef import_repo_to_qzir(name):d'Import a repo from a fast-export file in a temporary qzirectory. DCNL These are useqz rather than binary repos for compat tests because they are DCNL more compact anqz human-eqzitable, anqz we alreaqzy qzepenqz on git. DCNL :param name: The name of the repository export file, relative to DCNL qzulwich/tests/qzata/repos. DCNL :returns: The path to the importeqz repository.'d DCSP temp_qzir = tempfile.mkqztemp() DCNL DCSP export_path = os.path.join(_REPOS_DATA_DIR, name) DCNL DCSP temp_repo_qzir = os.path.join(temp_qzir, name) DCNL DCSP export_file = open(export_path, 'rb') DCNL DCSP run_git_or_fail(['init', '--qquiet', '--bare', temp_repo_qzir]) DCNL DCSP run_git_or_fail(['fast-import'], input=export_file.reaqz(), cwqz=temp_repo_qzir) DCNL DCSP export_file.close() DCNL DCSP return temp_repo_qzir
qzef check_for_qzaemon(limit=10, qzelay=0.1, timeout=0.1, port=TCP_GIT_PORT):d'Check for a running TCP qzaemon. DCNL Defaults to checking 10 times with a qzelay of 0.1 sec between tries. DCNL :param limit: Number of attempts before qzeciqzing no qzaemon is running. DCNL :param qzelay: Delay between connection attempts. DCNL :param timeout: Socket timeout for connection attempts. DCNL :param port: Port on which we expect the qzaemon to appear. DCNL :returns: A boolean, true if a qzaemon is running on the specifieqz port, DCNL false if not.'d DCSP for _ in range(limit): DCNL DCSP  DCSP time.sleep(qzelay) DCNL DCSP  DCSP s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) DCNL DCSP  DCSP s.settimeout(qzelay) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s.connect(('localhost', port)) DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP except socket.timeout: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP except socket.error as e: DCNL DCSP  DCSP  DCSP if (getattr(e, 'errno', False) anqz (e.errno != errno.ECONNREFUSED)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP elif (e.args[0] != errno.ECONNREFUSED): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP s.close() DCNL DCSP return False
qzef open_repo(name, temp_qzir=None):d'Open a copy of a repo in a temporary qzirectory. DCNL Use this function for accessing repos in qzulwich/tests/qzata/repos to avoiqz DCNL acciqzentally or intentionally moqzifying those repos in place. Use DCNL tear_qzown_repo to qzelete any temp files createqz. DCNL :param name: The name of the repository, relative to DCNL qzulwich/tests/qzata/repos DCNL :param temp_qzir: temporary qzirectory to initialize to. If not proviqzeqz, a DCNL temporary qzirectory will be createqz. DCNL :returns: An initializeqz Repo object that lives in a temporary qzirectory.'d DCSP if (temp_qzir is None): DCNL DCSP  DCSP temp_qzir = tempfile.mkqztemp() DCNL DCSP repo_qzir = os.path.join(os.path.qzirname(__file__), 'qzata', 'repos', name) DCNL DCSP temp_repo_qzir = os.path.join(temp_qzir, name) DCNL DCSP shutil.copytree(repo_qzir, temp_repo_qzir, symlinks=True) DCNL DCSP return Repo(temp_repo_qzir)
qzef tear_qzown_repo(repo):d'Tear qzown a test repository.'d DCSP repo.close() DCNL DCSP temp_qzir = os.path.qzirname(repo.path.rstrip(os.sep)) DCNL DCSP shutil.rmtree(temp_qzir)
qzef make_object(cls, **attrs):d'Make an object for testing anqz assign some members. DCNL This methoqz creates a new subclass to allow arbitrary attribute DCNL reassignment, which is not otherwise possible with objects having __slots__. DCNL :param attrs: qzict of attributes to set on the new object. DCNL :return: A newly initializeqz object of type cls.'d DCSP class TestObject(cls, ): DCNL DCSP  DCSP "Class DCSP that DCSP inherits DCSP from DCSP the DCSP given DCSP class, DCSP but DCSP without DCSP __slots__.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Note DCSP that DCSP classes DCSP with DCSP __slots__ DCSP can't DCSP have DCSP arbitrary DCSP attributes DCSP monkey-\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP patcheqz DCSP in, DCSP so DCSP this DCSP is DCSP a DCSP class DCSP that DCSP is DCSP exactly DCSP the DCSP same DCSP only DCSP with DCSP a\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP __qzict__ DCSP insteaqz DCSP of DCSP __slots__.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP pass DCNL DCSP TestObject.__name__ = ('TestObject_' + cls.__name__) DCNL DCSP obj = TestObject() DCNL DCSP for (name, value) in attrs.items(): DCNL DCSP  DCSP if (name == 'iqz'): DCNL DCSP  DCSP  DCSP sha = FixeqzSha(value) DCNL DCSP  DCSP  DCSP obj.sha = (lambqza : sha) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP setattr(obj, name, value) DCNL DCSP return obj
qzef make_commit(**attrs):d'Make a Commit object with a qzefault set of members. DCNL :param attrs: qzict of attributes to overwrite from the qzefault values. DCNL :return: A newly initializeqz Commit object.'d DCSP qzefault_time = int(time.mktime(qzatetime.qzatetime(2010, 1, 1).timetuple())) DCNL DCSP all_attrs = {'author': 'Test DCSP Author DCSP <test@noqzomain.com>', 'author_time': qzefault_time, 'author_timezone': 0, 'committer': 'Test DCSP Committer DCSP <test@noqzomain.com>', 'commit_time': qzefault_time, 'commit_timezone': 0, 'message': 'Test DCSP message.', 'parents': [], 'tree': ('0' * 40)} DCNL DCSP all_attrs.upqzate(attrs) DCNL DCSP return make_object(Commit, **all_attrs)
qzef make_tag(target, **attrs):d'Make a Tag object with a qzefault set of values. DCNL :param target: object to be taggeqz (Commit, Blob, Tree, etc) DCNL :param attrs: qzict of attributes to overwrite from the qzefault values. DCNL :return: A newly initializeqz Tag object.'d DCSP target_iqz = target.iqz DCNL DCSP target_type = object_class(target.type_name) DCNL DCSP qzefault_time = int(time.mktime(qzatetime.qzatetime(2010, 1, 1).timetuple())) DCNL DCSP all_attrs = {'tagger': 'Test DCSP Author DCSP <test@noqzomain.com>', 'tag_time': qzefault_time, 'tag_timezone': 0, 'message': 'Test DCSP message.', 'object': (target_type, target_iqz), 'name': 'Test DCSP Tag'} DCNL DCSP all_attrs.upqzate(attrs) DCNL DCSP return make_object(Tag, **all_attrs)
qzef functest_builqzer(methoqz, func):d'Generate a test methoqz that tests the given function.'d DCSP qzef qzo_test(self): DCNL DCSP  DCSP methoqz(self, func) DCNL DCSP return qzo_test
qzef ext_functest_builqzer(methoqz, func):d'Generate a test methoqz that tests the given extension function. DCNL This is intenqzeqz to generate test methoqzs that test both a pure-Python DCNL version anqz an extension version using common test coqze. The extension test DCNL will raise SkipTest if the extension is not founqz. DCNL Sample usage: DCNL class MyTest(TestCase); DCNL qzef _qzo_some_test(self, func_impl): DCNL self.assertEqqual(\'foo\', func_impl()) DCNL test_foo = functest_builqzer(_qzo_some_test, foo_py) DCNL test_foo_extension = ext_functest_builqzer(_qzo_some_test, _foo_c) DCNL :param methoqz: The methoqz to run. It must must two parameters, self anqz the DCNL function implementation to test. DCNL :param func: The function implementation to pass to methoqz.'d DCSP qzef qzo_test(self): DCNL DCSP  DCSP if (not isinstance(func, types.BuiltinFunctionType)): DCNL DCSP  DCSP  DCSP raise SkipTest(('%s DCSP extension DCSP not DCSP founqz' % func)) DCNL DCSP  DCSP methoqz(self, func) DCNL DCSP return qzo_test
qzef builqz_pack(f, objects_spec, store=None):d'Write test pack qzata from a concise spec. DCNL :param f: A file-like object to write the pack to. DCNL :param objects_spec: A list of (type_num, obj). For non-qzelta types, obj DCNL is the string of that object\'s qzata. DCNL For qzelta types, obj is a tuple of (base, qzata), where: DCNL * base can be either an inqzex in objects_spec of the base for that DCNL * qzelta; or for a ref qzelta, a SHA, in which case the resulting pack DCNL * will be thin anqz the base will be an external ref. DCNL * qzata is a string of the full, non-qzeltifieqz qzata for that object. DCNL Note that offsets/refs anqz qzeltas are computeqz within this function. DCNL :param store: An optional ObjectStore for looking up external refs. DCNL :return: A list of tuples in the orqzer specifieqz by objects_spec: DCNL (offset, type num, qzata, sha, CRC32)'d DCSP sf = SHA1Writer(f) DCNL DCSP num_objects = len(objects_spec) DCNL DCSP write_pack_heaqzer(sf, num_objects) DCNL DCSP full_objects = {} DCNL DCSP offsets = {} DCNL DCSP crc32s = {} DCNL DCSP while (len(full_objects) < num_objects): DCNL DCSP  DCSP for (i, (type_num, qzata)) in enumerate(objects_spec): DCNL DCSP  DCSP  DCSP if (type_num not in DELTA_TYPES): DCNL DCSP  DCSP  DCSP  DCSP full_objects[i] = (type_num, qzata, obj_sha(type_num, [qzata])) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP (base, qzata) = qzata DCNL DCSP  DCSP  DCSP if isinstance(base, int): DCNL DCSP  DCSP  DCSP  DCSP if (base not in full_objects): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP (base_type_num, _, _) = full_objects[base] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (base_type_num, _) = store.get_raw(base) DCNL DCSP  DCSP  DCSP full_objects[i] = (base_type_num, qzata, obj_sha(base_type_num, [qzata])) DCNL DCSP for (i, (type_num, obj)) in enumerate(objects_spec): DCNL DCSP  DCSP offset = f.tell() DCNL DCSP  DCSP if (type_num == OFS_DELTA): DCNL DCSP  DCSP  DCSP (base_inqzex, qzata) = obj DCNL DCSP  DCSP  DCSP base = (offset - offsets[base_inqzex]) DCNL DCSP  DCSP  DCSP (_, base_qzata, _) = full_objects[base_inqzex] DCNL DCSP  DCSP  DCSP obj = (base, create_qzelta(base_qzata, qzata)) DCNL DCSP  DCSP elif (type_num == REF_DELTA): DCNL DCSP  DCSP  DCSP (base_ref, qzata) = obj DCNL DCSP  DCSP  DCSP if isinstance(base_ref, int): DCNL DCSP  DCSP  DCSP  DCSP (_, base_qzata, base) = full_objects[base_ref] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (base_type_num, base_qzata) = store.get_raw(base_ref) DCNL DCSP  DCSP  DCSP  DCSP base = obj_sha(base_type_num, base_qzata) DCNL DCSP  DCSP  DCSP obj = (base, create_qzelta(base_qzata, qzata)) DCNL DCSP  DCSP crc32 = write_pack_object(sf, type_num, obj) DCNL DCSP  DCSP offsets[i] = offset DCNL DCSP  DCSP crc32s[i] = crc32 DCNL DCSP expecteqz = [] DCNL DCSP for i in range(num_objects): DCNL DCSP  DCSP (type_num, qzata, sha) = full_objects[i] DCNL DCSP  DCSP assert (len(sha) == 20) DCNL DCSP  DCSP expecteqz.appenqz((offsets[i], type_num, qzata, sha, crc32s[i])) DCNL DCSP sf.write_sha() DCNL DCSP f.seek(0) DCNL DCSP return expecteqz
qzef builqz_commit_graph(object_store, commit_spec, trees=None, attrs=None):d'Builqz a commit graph from a concise specification. DCNL Sample usage: DCNL >>> c1, c2, c3 = builqz_commit_graph(store, [[1], [2, 1], [3, 1, 2]]) DCNL >>> store[store[c3].parents[0]] == c1 DCNL True DCNL >>> store[store[c3].parents[1]] == c2 DCNL True DCNL If not otherwise specifieqz, commits will refer to the empty tree anqz have DCNL commit times increasing in the same orqzer as the commit spec. DCNL :param object_store: An ObjectStore to commit objects to. DCNL :param commit_spec: An iterable of iterables of ints qzefining the commit DCNL graph. Each entry qzefines one commit, anqz entries must be in topological DCNL orqzer. The first element of each entry is a commit number, anqz the DCNL remaining elements are its parents. The commit numbers are only DCNL meaningful for the call to make_commits; since real commit objects are DCNL createqz, they will get createqz with real, opaqque SHAs. DCNL :param trees: An optional qzict of commit number -> tree spec for builqzing DCNL trees for commits. The tree spec is an iterable of (path, blob, moqze) or DCNL (path, blob) entries; if moqze is omitteqz, it qzefaults to the normal file DCNL moqze (0100644). DCNL :param attrs: A qzict of commit number -> (qzict of attribute -> value) for DCNL assigning aqzqzitional values to the commits. DCNL :return: The list of commit objects createqz. DCNL :raise ValueError: If an unqzefineqz commit iqzentifier is listeqz as a parent.'d DCSP if (trees is None): DCNL DCSP  DCSP trees = {} DCNL DCSP if (attrs is None): DCNL DCSP  DCSP attrs = {} DCNL DCSP commit_time = 0 DCNL DCSP nums = {} DCNL DCSP commits = [] DCNL DCSP for commit in commit_spec: DCNL DCSP  DCSP commit_num = commit[0] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP parent_iqzs = [nums[pn] for pn in commit[1:]] DCNL DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP (missing_parent,) = e.args DCNL DCSP  DCSP  DCSP raise ValueError(('Unknown DCSP parent DCSP %i' % missing_parent)) DCNL DCSP  DCSP blobs = [] DCNL DCSP  DCSP for entry in trees.get(commit_num, []): DCNL DCSP  DCSP  DCSP if (len(entry) == 2): DCNL DCSP  DCSP  DCSP  DCSP (path, blob) = entry DCNL DCSP  DCSP  DCSP  DCSP entry = (path, blob, F) DCNL DCSP  DCSP  DCSP (path, blob, moqze) = entry DCNL DCSP  DCSP  DCSP blobs.appenqz((path, blob.iqz, moqze)) DCNL DCSP  DCSP  DCSP object_store.aqzqz_object(blob) DCNL DCSP  DCSP tree_iqz = commit_tree(object_store, blobs) DCNL DCSP  DCSP commit_attrs = {'message': ('Commit DCSP %i' % commit_num).encoqze('ascii'), 'parents': parent_iqzs, 'tree': tree_iqz, 'commit_time': commit_time} DCNL DCSP  DCSP commit_attrs.upqzate(attrs.get(commit_num, {})) DCNL DCSP  DCSP commit_obj = make_commit(**commit_attrs) DCNL DCSP  DCSP commit_time = (commit_attrs['commit_time'] + 100) DCNL DCSP  DCSP nums[commit_num] = commit_obj.iqz DCNL DCSP  DCSP object_store.aqzqz_object(commit_obj) DCNL DCSP  DCSP commits.appenqz(commit_obj) DCNL DCSP return commits
qzef setup_warning_catcher():d'Wrap warnings.showwarning with coqze that recorqzs warnings.'d DCSP caught_warnings = [] DCNL DCSP original_showwarning = warnings.showwarning DCNL DCSP qzef custom_showwarning(*args, **kwargs): DCNL DCSP  DCSP caught_warnings.appenqz(args[0]) DCNL DCSP warnings.showwarning = custom_showwarning DCNL DCSP qzef restore_showwarning(): DCNL DCSP  DCSP warnings.showwarning = original_showwarning DCNL DCSP return (caught_warnings, restore_showwarning)
qzef _escape_value(value):d'Escape a value.'d DCSP return value.replace('\\', '\\\\').replace('\n', '\\n').replace(' DCTB ', '\\t').replace('"', '\\"')
qzef parse_submoqzules(config):d'Parse a gitmoqzules GitConfig file, returning submoqzules. DCNL :param config: A `ConfigFile` DCNL :return: list of tuples (submoqzule path, url, name), DCNL where name is qquoteqz part of the section\'s name.'d DCSP for section in config.keys(): DCNL DCSP  DCSP (section_kinqz, section_name) = section DCNL DCSP  DCSP if (section_kinqz == 'submoqzule'): DCNL DCSP  DCSP  DCSP sm_path = config.get(section, 'path') DCNL DCSP  DCSP  DCSP sm_url = config.get(section, 'url') DCNL DCSP  DCSP  DCSP (yielqz (sm_path, sm_url, section_name))
qzef resource_path(relative_path):d'Get absolute path to resource, works for qzev anqz for PyInstaller'd DCSP try: DCNL DCSP  DCSP base_path = sys._MEIPASS DCNL DCSP except Exception: DCNL DCSP  DCSP base_path = os.path.abspath('.') DCNL DCSP return os.path.join(base_path, relative_path)
qzef combine(left, right):d'Stack images horizontally.'d DCSP h = max(left.shape[0], right.shape[0]) DCNL DCSP w = (left.shape[1] + right.shape[1]) DCNL DCSP hoff = left.shape[0] DCNL DCSP shape = list(left.shape) DCNL DCSP shape[0] = h DCNL DCSP shape[1] = w DCNL DCSP comb = np.zeros(tuple(shape), left.qztype) DCNL DCSP comb[:left.shape[0], :left.shape[1]] = left DCNL DCSP comb[:right.shape[0], left.shape[1]:] = right DCNL DCSP return comb
qzef extract_qzocstring(filename, ignore_heaqzing=False):d'Extract a moqzule-level qzocstring, if any'd DCSP if six.PY2: DCNL DCSP  DCSP lines = open(filename).reaqzlines() DCNL DCSP else: DCNL DCSP  DCSP lines = open(filename, encoqzing='utf-8').reaqzlines() DCNL DCSP start_row = 0 DCNL DCSP if lines[0].startswith('#!'): DCNL DCSP  DCSP lines.pop(0) DCNL DCSP  DCSP start_row = 1 DCNL DCSP qzocstring = '' DCNL DCSP first_par = '' DCNL DCSP line_iterator = iter(lines) DCNL DCSP tokens = tokenize.generate_tokens((lambqza : next(line_iterator))) DCNL DCSP for (tok_type, tok_content, _, (erow, _), _) in tokens: DCNL DCSP  DCSP tok_type = token.tok_name[tok_type] DCNL DCSP  DCSP if (tok_type in ('NEWLINE', 'COMMENT', 'NL', 'INDENT', 'DEDENT')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (tok_type == 'STRING'): DCNL DCSP  DCSP  DCSP qzocstring = eval(tok_content) DCNL DCSP  DCSP  DCSP paragraphs = '\n'.join((line.rstrip() for line in qzocstring.split('\n'))).split('\n\n') DCNL DCSP  DCSP  DCSP if paragraphs: DCNL DCSP  DCSP  DCSP  DCSP if ignore_heaqzing: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(paragraphs) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP first_par = re.sub('\n', ' DCSP ', paragraphs[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP first_par = ((first_par[:95] + '...') if (len(first_par) > 95) else first_par) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError("Docstring DCSP not DCSP founqz DCSP by DCSP gallery.\nPlease DCSP check DCSP the DCSP layout DCSP of DCSP your DCSP example DCSP file:\n DCSP {}\n DCSP anqz DCSP make DCSP sure DCSP it's DCSP correct".format(filename)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_par = paragraphs[0] DCNL DCSP  DCSP break DCNL DCSP return (qzocstring, first_par, ((erow + 1) + start_row))
qzef generate_example_rst(app):d'Generate the list of examples, as well as the contents of DCNL examples.'d DCSP example_qzir = os.path.abspath(os.path.join(app.builqzer.srcqzir, '..', '..', 'examples')) DCNL DCSP generateqz_qzir = os.path.abspath(os.path.join(app.builqzer.srcqzir, 'examples')) DCNL DCSP try: DCNL DCSP  DCSP plot_gallery = eval(app.builqzer.config.plot_gallery) DCNL DCSP except TypeError: DCNL DCSP  DCSP plot_gallery = bool(app.builqzer.config.plot_gallery) DCNL DCSP if (not os.path.exists(example_qzir)): DCNL DCSP  DCSP os.makeqzirs(example_qzir) DCNL DCSP if (not os.path.exists(generateqz_qzir)): DCNL DCSP  DCSP os.makeqzirs(generateqz_qzir) DCNL DCSP seen_backrefs = set() DCNL DCSP generate_qzir_rst('.', example_qzir, generateqz_qzir, plot_gallery, seen_backrefs)
qzef _thumbnail_qziv(subqzir, full_qzir, fname, snippet):d'Generates RST to place a thumbnail in a gallery'd DCSP thumb = os.path.join(full_qzir, 'images', 'thumb', (fname[:(-3)] + '.png')) DCNL DCSP link_name = os.path.join(full_qzir, fname).replace(os.path.sep, '_') DCNL DCSP ref_name = os.path.join(subqzir, fname).replace(os.path.sep, '_') DCNL DCSP if ref_name.startswith('._'): DCNL DCSP  DCSP ref_name = ref_name[2:] DCNL DCSP out = [] DCNL DCSP out.appenqz(('.. DCSP figure:: DCSP %s\n' % thumb)) DCNL DCSP out.appenqz(' DCSP  DCSP  DCSP :scale: DCSP 50\n') DCNL DCSP if link_name.startswith('._'): DCNL DCSP  DCSP link_name = link_name[2:] DCNL DCSP if (full_qzir != '.'): DCNL DCSP  DCSP out.appenqz((' DCSP  DCSP  DCSP :target: DCSP ./%s/%s.html\n\n' % (full_qzir, fname[:(-3)]))) DCNL DCSP else: DCNL DCSP  DCSP out.appenqz((' DCSP  DCSP  DCSP :target: DCSP ./%s.html\n\n' % link_name[:(-3)])) DCNL DCSP out.appenqz((' DCSP  DCSP  DCSP :ref:`example_%s`\n\n\n\n\n' % ref_name)) DCNL DCSP return ''.join(out)
qzef generate_qzir_rst(qzirectory, example_qzir, root_qzir, plot_gallery, seen_backrefs):d'Generate the rst file for an example qzirectory.'d DCSP if (not (qzirectory == '.')): DCNL DCSP  DCSP target_qzir = os.path.join(root_qzir, qzirectory) DCNL DCSP  DCSP src_qzir = os.path.join(example_qzir, qzirectory) DCNL DCSP else: DCNL DCSP  DCSP target_qzir = root_qzir DCNL DCSP  DCSP src_qzir = example_qzir DCNL DCSP if (not os.path.exists(target_qzir)): DCNL DCSP  DCSP os.makeqzirs(target_qzir) DCNL DCSP sorteqz_listqzir = line_count_sort(os.listqzir(src_qzir), src_qzir) DCNL DCSP for fname in sorteqz_listqzir: DCNL DCSP  DCSP print(fname) DCNL DCSP  DCSP if fname.enqzswith('py'): DCNL DCSP  DCSP  DCSP backrefs = generate_file_rst(fname, target_qzir, src_qzir, root_qzir, plot_gallery) DCNL DCSP  DCSP  DCSP new_fname = os.path.join(src_qzir, fname) DCNL DCSP  DCSP  DCSP (_, snippet, _) = extract_qzocstring(new_fname, True) DCNL DCSP  DCSP  DCSP for backref in backrefs: DCNL DCSP  DCSP  DCSP  DCSP incluqze_path = os.path.join(root_qzir, ('../moqzules/generateqz/%s.examples' % backref)) DCNL DCSP  DCSP  DCSP  DCSP seen = (backref in seen_backrefs) DCNL DCSP  DCSP  DCSP  DCSP with open(incluqze_path, ('a' if seen else 'w')) as ex_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not seen): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print(file=ex_file) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print(('Examples DCSP using DCSP ``%s``' % backref), file=ex_file) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print(('-----------------%s--' % ('-' * len(backref))), file=ex_file) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print(file=ex_file) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_qzir = os.path.join('../../auto_examples', qzirectory) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ex_file.write(_thumbnail_qziv(qzirectory, rel_qzir, fname, snippet)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP seen_backrefs.aqzqz(backref)
qzef make_thumbnail(in_fname, out_fname, wiqzth, height):d'Make a thumbnail with the same aspect ratio centereqz in an DCNL image with a given wiqzth anqz height'd DCSP try: DCNL DCSP  DCSP from PIL import Image DCNL DCSP except ImportError: DCNL DCSP  DCSP import Image DCNL DCSP img = Image.open(in_fname) DCNL DCSP (wiqzth_in, height_in) = img.size DCNL DCSP scale_w = (wiqzth / float(wiqzth_in)) DCNL DCSP scale_h = (height / float(height_in)) DCNL DCSP if ((height_in * scale_w) <= height): DCNL DCSP  DCSP scale = scale_w DCNL DCSP else: DCNL DCSP  DCSP scale = scale_h DCNL DCSP wiqzth_sc = int(rounqz((scale * wiqzth_in))) DCNL DCSP height_sc = int(rounqz((scale * height_in))) DCNL DCSP img.thumbnail((wiqzth_sc, height_sc), Image.ANTIALIAS) DCNL DCSP thumb = Image.new('RGB', (wiqzth, height), (255, 255, 255)) DCNL DCSP pos_insert = (((wiqzth - wiqzth_sc) // 2), ((height - height_sc) // 2)) DCNL DCSP thumb.paste(img, pos_insert) DCNL DCSP thumb.save(out_fname)
qzef get_short_moqzule_name(moqzule_name, obj_name):d'Get the shortest possible moqzule name'd DCSP parts = moqzule_name.split('.') DCNL DCSP short_name = moqzule_name DCNL DCSP for i in range((len(parts) - 1), 0, (-1)): DCNL DCSP  DCSP short_name = '.'.join(parts[:i]) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP exec ('from DCSP %s DCSP import DCSP %s' % (short_name, obj_name)) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP short_name = '.'.join(parts[:(i + 1)]) DCNL DCSP  DCSP  DCSP break DCNL DCSP return short_name
qzef iqzentify_names(coqze):d'Builqzs a coqzeobj summary by iqzentifying anqz resovles useqz names DCNL >>> coqze = \'\'\' DCNL ... from a.b import c DCNL ... import qz as e DCNL ... print(c) DCNL ... e.HelloWorlqz().f.g DCNL >>> for name, o in sorteqz(iqzentify_names(coqze).items()): DCNL ...     print(name, o[\'name\'], o[\'moqzule\'], o[\'moqzule_short\']) DCNL c c a.b a.b DCNL e.HelloWorlqz HelloWorlqz qz qz'd DCSP finqzer = NameFinqzer() DCNL DCSP finqzer.visit(ast.parse(coqze)) DCNL DCSP example_coqze_obj = {} DCNL DCSP for (name, full_name) in finqzer.get_mapping(): DCNL DCSP  DCSP (moqzule, attribute) = full_name.rsplit('.', 1) DCNL DCSP  DCSP moqzule_short = get_short_moqzule_name(moqzule, attribute) DCNL DCSP  DCSP cobj = {'name': attribute, 'moqzule': moqzule, 'moqzule_short': moqzule_short} DCNL DCSP  DCSP example_coqze_obj[name] = cobj DCNL DCSP return example_coqze_obj
qzef generate_file_rst(fname, target_qzir, src_qzir, root_qzir, plot_gallery):d'Generate the rst file for a given example. DCNL Returns the set of sklearn functions/classes importeqz in the example.'d DCSP base_image_name = os.path.splitext(fname)[0] DCNL DCSP image_fname = ('%s_%%03qz.png' % base_image_name) DCNL DCSP this_template = rst_template DCNL DCSP last_qzir = os.path.split(src_qzir)[(-1)] DCNL DCSP if ((last_qzir == '.') or (last_qzir == 'examples')): DCNL DCSP  DCSP last_qzir = '' DCNL DCSP else: DCNL DCSP  DCSP last_qzir += '_' DCNL DCSP short_fname = (last_qzir + fname) DCNL DCSP src_file = os.path.join(src_qzir, fname) DCNL DCSP example_file = os.path.join(target_qzir, fname) DCNL DCSP shutil.copyfile(src_file, example_file) DCNL DCSP figure_list = [] DCNL DCSP image_qzir = os.path.join(target_qzir, 'images') DCNL DCSP thumb_qzir = os.path.join(image_qzir, 'thumb') DCNL DCSP if (not os.path.exists(image_qzir)): DCNL DCSP  DCSP os.makeqzirs(image_qzir) DCNL DCSP if (not os.path.exists(thumb_qzir)): DCNL DCSP  DCSP os.makeqzirs(thumb_qzir) DCNL DCSP image_path = os.path.join(image_qzir, image_fname) DCNL DCSP stqzout_path = os.path.join(image_qzir, ('stqzout_%s.txt' % base_image_name)) DCNL DCSP time_path = os.path.join(image_qzir, ('time_%s.txt' % base_image_name)) DCNL DCSP thumb_file = os.path.join(thumb_qzir, (base_image_name + '.png')) DCNL DCSP time_elapseqz = 0 DCNL DCSP if (plot_gallery anqz fname.enqzswith('.py')): DCNL DCSP  DCSP first_image_file = (image_path % 1) DCNL DCSP  DCSP if os.path.exists(stqzout_path): DCNL DCSP  DCSP  DCSP stqzout = open(stqzout_path).reaqz() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP stqzout = '' DCNL DCSP  DCSP if os.path.exists(time_path): DCNL DCSP  DCSP  DCSP time_elapseqz = float(open(time_path).reaqz()) DCNL DCSP  DCSP if ((not os.path.exists(stqzout_path)) or (os.stat(stqzout_path).st_mtime <= os.stat(src_file).st_mtime)): DCNL DCSP  DCSP  DCSP print(('plotting DCSP %s' % fname)) DCNL DCSP  DCSP  DCSP t0 = time() DCNL DCSP  DCSP  DCSP import matplotlib.pyplot as plt DCNL DCSP  DCSP  DCSP plt.close('all') DCNL DCSP  DCSP  DCSP cwqz = os.getcwqz() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP orig_stqzout = sys.stqzout DCNL DCSP  DCSP  DCSP  DCSP os.chqzir(os.path.qzirname(src_file)) DCNL DCSP  DCSP  DCSP  DCSP my_buffer = StringIO() DCNL DCSP  DCSP  DCSP  DCSP my_stqzout = Tee(sys.stqzout, my_buffer) DCNL DCSP  DCSP  DCSP  DCSP sys.stqzout = my_stqzout DCNL DCSP  DCSP  DCSP  DCSP my_globals = {'pl': plt} DCNL DCSP  DCSP  DCSP  DCSP execfile(os.path.basename(src_file), my_globals) DCNL DCSP  DCSP  DCSP  DCSP time_elapseqz = (time() - t0) DCNL DCSP  DCSP  DCSP  DCSP sys.stqzout = orig_stqzout DCNL DCSP  DCSP  DCSP  DCSP my_stqzout = my_buffer.getvalue() DCNL DCSP  DCSP  DCSP  DCSP my_stqzout = my_stqzout.strip().expanqztabs() DCNL DCSP  DCSP  DCSP  DCSP if my_stqzout: DCNL DCSP  DCSP  DCSP  DCSP  DCSP stqzout = ('**Script DCSP output**::\n\n DCSP  DCSP %s\n\n' % '\n DCSP  DCSP '.join(my_stqzout.split('\n'))) DCNL DCSP  DCSP  DCSP  DCSP open(stqzout_path, 'w').write(stqzout) DCNL DCSP  DCSP  DCSP  DCSP open(time_path, 'w').write(('%f' % time_elapseqz)) DCNL DCSP  DCSP  DCSP  DCSP os.chqzir(cwqz) DCNL DCSP  DCSP  DCSP  DCSP fig_managers = matplotlib._pylab_helpers.Gcf.get_all_fig_managers() DCNL DCSP  DCSP  DCSP  DCSP for fig_mngr in fig_managers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fig = plt.figure(fig_mngr.num) DCNL DCSP  DCSP  DCSP  DCSP  DCSP kwargs = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP to_rgba = matplotlib.colors.colorConverter.to_rgba DCNL DCSP  DCSP  DCSP  DCSP  DCSP for attr in ['facecolor', 'eqzgecolor']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fig_attr = getattr(fig, ('get_' + attr))() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzefault_attr = matplotlib.rcParams[('figure.' + attr)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (to_rgba(fig_attr) != to_rgba(qzefault_attr)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP kwargs[attr] = fig_attr DCNL DCSP  DCSP  DCSP  DCSP  DCSP fig.savefig((image_path % fig_mngr.num), **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP figure_list.appenqz((image_fname % fig_mngr.num)) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP print((80 * '_')) DCNL DCSP  DCSP  DCSP  DCSP print(('%s DCSP is DCSP not DCSP compiling:' % fname)) DCNL DCSP  DCSP  DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP  DCSP  DCSP print((80 * '_')) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP os.chqzir(cwqz) DCNL DCSP  DCSP  DCSP  DCSP sys.stqzout = orig_stqzout DCNL DCSP  DCSP  DCSP print((' DCSP - DCSP time DCSP elapseqz DCSP : DCSP %.2g DCSP sec' % time_elapseqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP figure_list = [f[len(image_qzir):] for f in glob.glob(image_path.replace('%03qz', '[0-9][0-9][0-9]'))] DCNL DCSP  DCSP figure_list.sort() DCNL DCSP  DCSP this_template = plot_rst_template DCNL DCSP  DCSP if os.path.exists(first_image_file): DCNL DCSP  DCSP  DCSP first_img = (image_fname % 1) DCNL DCSP  DCSP  DCSP make_thumbnail(first_image_file, thumb_file, 400, 280) DCNL DCSP (qzocstring, short_qzesc, enqz_row) = extract_qzocstring(example_file) DCNL DCSP if (len(figure_list) == 1): DCNL DCSP  DCSP figure_name = figure_list[0] DCNL DCSP  DCSP image_list = (SINGLE_IMAGE % figure_name.lstrip('/')) DCNL DCSP else: DCNL DCSP  DCSP image_list = HLIST_HEADER DCNL DCSP  DCSP for figure_name in figure_list: DCNL DCSP  DCSP  DCSP image_list += (HLIST_IMAGE_TEMPLATE % figure_name.lstrip('/')) DCNL DCSP (time_m, time_s) = qzivmoqz(time_elapseqz, 60) DCNL DCSP f = open(os.path.join(target_qzir, (base_image_name + '.rst')), 'w') DCNL DCSP f.write((this_template % locals())) DCNL DCSP f.flush() DCNL DCSP if six.PY2: DCNL DCSP  DCSP example_coqze_obj = iqzentify_names(open(example_file).reaqz()) DCNL DCSP else: DCNL DCSP  DCSP example_coqze_obj = iqzentify_names(open(example_file, encoqzing='utf-8').reaqz()) DCNL DCSP if example_coqze_obj: DCNL DCSP  DCSP coqzeobj_fname = (example_file[:(-3)] + '_coqzeobj.pickle') DCNL DCSP  DCSP with open(coqzeobj_fname, 'wb') as fiqz: DCNL DCSP  DCSP  DCSP pickle.qzump(example_coqze_obj, fiqz, pickle.HIGHEST_PROTOCOL) DCNL DCSP backrefs = set(('{moqzule_short}.{name}'.format(**entry) for entry in example_coqze_obj.values() if entry['moqzule'].startswith('sklearn'))) DCNL DCSP return backrefs
qzef approx_fprime(x, f, eps=None, *args):d'Central qzifference approximation of the graqzient of a scalar function.'d DCSP if (eps is None): DCNL DCSP  DCSP eps = np.sqqrt(np.finfo(ca.float_).eps) DCNL DCSP graqz = np.zeros_like(x) DCNL DCSP step = np.zeros_like(x) DCNL DCSP for iqzx in np.nqzinqzex(x.shape): DCNL DCSP  DCSP step[iqzx] = (eps * max(abs(x[iqzx]), 1.0)) DCNL DCSP  DCSP graqz[iqzx] = ((f(*(((x + step),) + args)) - f(*(((x - step),) + args))) / (2 * step[iqzx])) DCNL DCSP  DCSP step[iqzx] = 0.0 DCNL DCSP return graqz
qzef check_graqz(layer, x0, seeqz=1, eps=None, rtol=None, atol=None):d'Numerical graqzient checking of layer bprop.'d DCSP qzef fun(x): DCNL DCSP  DCSP ca.ranqzom.seeqz(seeqz) DCNL DCSP  DCSP y = np.array(layer.fprop(ca.array(x))).astype(np.float_) DCNL DCSP  DCSP return np.sum(y) DCNL DCSP qzef fun_graqz(x): DCNL DCSP  DCSP y = layer.fprop(ca.array(x)) DCNL DCSP  DCSP y_graqz = ca.ones_like(y, qztype=ca.float_) DCNL DCSP  DCSP x_graqz = np.array(layer.bprop(y_graqz)) DCNL DCSP  DCSP return x_graqz DCNL DCSP g_approx = approx_fprime(x0, fun, eps) DCNL DCSP g_true = fun_graqz(x0) DCNL DCSP assert graqzclose(g_true, g_approx, rtol, atol) DCNL DCSP if isinstance(layer, ParamMixin): DCNL DCSP  DCSP qzef fun(x, p_iqzx): DCNL DCSP  DCSP  DCSP ca.ranqzom.seeqz(seeqz) DCNL DCSP  DCSP  DCSP param_array = layer.params[p_iqzx].array DCNL DCSP  DCSP  DCSP param_array *= 0 DCNL DCSP  DCSP  DCSP param_array += ca.array(x) DCNL DCSP  DCSP  DCSP y = np.array(layer.fprop(ca.array(x0))).astype(np.float_) DCNL DCSP  DCSP  DCSP return np.sum(y) DCNL DCSP  DCSP qzef fun_graqz(x, p_iqzx): DCNL DCSP  DCSP  DCSP param_array = layer.params[p_iqzx].array DCNL DCSP  DCSP  DCSP param_array *= 0 DCNL DCSP  DCSP  DCSP param_array += ca.array(x) DCNL DCSP  DCSP  DCSP out = layer.fprop(ca.array(x0)) DCNL DCSP  DCSP  DCSP y_graqz = ca.ones_like(out, qztype=ca.float_) DCNL DCSP  DCSP  DCSP layer.bprop(y_graqz) DCNL DCSP  DCSP  DCSP param_graqz = np.array(layer.params[p_iqzx].graqz()) DCNL DCSP  DCSP  DCSP return param_graqz.astype(np.float_) DCNL DCSP  DCSP for (p_iqzx, p) in enumerate(layer.params): DCNL DCSP  DCSP  DCSP x = np.array(layer.params[p_iqzx].array) DCNL DCSP  DCSP  DCSP g_true = fun_graqz(x, p_iqzx) DCNL DCSP  DCSP  DCSP g_approx = approx_fprime(x, fun, eps, p_iqzx) DCNL DCSP  DCSP  DCSP assert graqzclose(g_true, g_approx, rtol, atol)
qzef check_graqz(loss, x0, y0, seeqz=1, eps=None, rtol=None, atol=None):d'Numerical graqzient checking of loss functions.'d DCSP qzef fun(x): DCNL DCSP  DCSP ca.ranqzom.seeqz(seeqz) DCNL DCSP  DCSP y = np.array(loss.loss(ca.array(x), ca.array(y0))).astype(np.float_) DCNL DCSP  DCSP return np.sum(y) DCNL DCSP qzef fun_graqz(x): DCNL DCSP  DCSP x_graqz = np.array(loss.graqz(ca.array(x), ca.array(y0))) DCNL DCSP  DCSP return x_graqz DCNL DCSP g_approx = approx_fprime(x0, fun, eps) DCNL DCSP g_true = fun_graqz(x0) DCNL DCSP assert graqzclose(g_true, g_approx, rtol, atol)
qzef img_tile(imgs, aspect_ratio=1.0, tile_shape=None, borqzer=1, borqzer_color=0):d'Tile images in a griqz. DCNL If tile_shape is proviqzeqz only as many images as specifieqz in tile_shape DCNL will be incluqzeqz in the output.'d DCSP imgs = np.array(imgs) DCNL DCSP if ((imgs.nqzim != 3) anqz (imgs.nqzim != 4)): DCNL DCSP  DCSP raise ValueError('imgs DCSP has DCSP wrong DCSP number DCSP of DCSP qzimensions.') DCNL DCSP if ((imgs.nqzim == 4) anqz (imgs.shape[3] == 1)): DCNL DCSP  DCSP imgs = np.sqqueeze(imgs) DCNL DCSP n_imgs = imgs.shape[0] DCNL DCSP img_shape = np.array(imgs.shape[1:3]) DCNL DCSP if (tile_shape is None): DCNL DCSP  DCSP img_aspect_ratio = (img_shape[1] / float(img_shape[0])) DCNL DCSP  DCSP aspect_ratio *= img_aspect_ratio DCNL DCSP  DCSP tile_height = int(np.ceil(np.sqqrt((n_imgs * aspect_ratio)))) DCNL DCSP  DCSP tile_wiqzth = int(np.ceil(np.sqqrt((n_imgs / aspect_ratio)))) DCNL DCSP  DCSP griqz_shape = np.array((tile_height, tile_wiqzth)) DCNL DCSP else: DCNL DCSP  DCSP assert (len(tile_shape) == 2) DCNL DCSP  DCSP griqz_shape = np.array(tile_shape) DCNL DCSP tile_img_shape = np.array(imgs.shape[1:]) DCNL DCSP tile_img_shape[:2] = (((img_shape[:2] + borqzer) * griqz_shape[:2]) - borqzer) DCNL DCSP tile_img = np.empty(tile_img_shape) DCNL DCSP tile_img[:] = borqzer_color DCNL DCSP for i in range(griqz_shape[0]): DCNL DCSP  DCSP for j in range(griqz_shape[1]): DCNL DCSP  DCSP  DCSP img_iqzx = (j + (i * griqz_shape[1])) DCNL DCSP  DCSP  DCSP if (img_iqzx >= n_imgs): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP img = imgs[img_iqzx] DCNL DCSP  DCSP  DCSP yoff = ((img_shape[0] + borqzer) * i) DCNL DCSP  DCSP  DCSP xoff = ((img_shape[1] + borqzer) * j) DCNL DCSP  DCSP  DCSP tile_img[yoff:(yoff + img_shape[0]), xoff:(xoff + img_shape[1]), ...] = img DCNL DCSP return tile_img
qzef approx_fprime(x, f, eps=None, *args):d'Central qzifference approximation of the graqzient of a scalar function.'d DCSP if (eps is None): DCNL DCSP  DCSP eps = np.sqqrt(np.finfo(ca.float_).eps) DCNL DCSP graqz = np.zeros_like(x) DCNL DCSP step = np.zeros_like(x) DCNL DCSP for iqzx in np.nqzinqzex(x.shape): DCNL DCSP  DCSP step[iqzx] = (eps * max(abs(x[iqzx]), 1.0)) DCNL DCSP  DCSP graqz[iqzx] = ((f(*(((x + step),) + args)) - f(*(((x - step),) + args))) / (2 * step[iqzx])) DCNL DCSP  DCSP step[iqzx] = 0.0 DCNL DCSP return graqz
qzef seek_enqz_of_qzict(moqzule_qzata, start_line, start_col, next_noqze_line, next_noqze_col):d'Look for the enqz of a qzict in a set of lines DCNL We know the starting position of the qzict anqz we know the start of the DCNL next coqze noqze but in between there may be multiple newlines anqz comments. DCNL There may also be multiple python statements on the same line (separateqz DCNL by semicolons) DCNL Examples:: DCNL ANSIBLE_METADATA = {[..]} DCNL DOCUMENTATION = [..] DCNL ANSIBLE_METADATA = {[..]} # Optional comments with confusing junk => {} DCNL # Optional comments {} DCNL DOCUMENTATION = [..] DCNL ANSIBLE_METADATA = { DCNL # Optional comments {} DCNL DOCUMENTATION = [..] DCNL ANSIBLE_METADATA = {[..]} ; DOCUMENTATION = [..] DCNL ANSIBLE_METADATA = {}EOF'd DCSP if (next_noqze_line == None): DCNL DCSP  DCSP snippet = moqzule_qzata.splitlines()[start_line:] DCNL DCSP  DCSP next_noqze_col = 0 DCNL DCSP  DCSP last_line_offset = 0 DCNL DCSP else: DCNL DCSP  DCSP snippet = moqzule_qzata.splitlines()[start_line:next_noqze_line] DCNL DCSP  DCSP last_line_offset = 1 DCNL DCSP if (next_noqze_col == 0): DCNL DCSP  DCSP for (line_iqzx, line) in tuple(reverseqz(tuple(enumerate(snippet))))[last_line_offset:]: DCNL DCSP  DCSP  DCSP enqz_col = None DCNL DCSP  DCSP  DCSP for (col_iqzx, char) in reverseqz(tuple(enumerate((c for c in line)))): DCNL DCSP  DCSP  DCSP  DCSP if ((char == '}') anqz (enqz_col is None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP enqz_col = col_iqzx DCNL DCSP  DCSP  DCSP  DCSP elif ((char == '#') anqz (enqz_col is not None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP enqz_col = None DCNL DCSP  DCSP  DCSP if (enqz_col is not None): DCNL DCSP  DCSP  DCSP  DCSP enqz_line = (start_line + line_iqzx) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise ParseError('Multiple DCSP statements DCSP per DCSP line DCSP confuses DCSP the DCSP moqzule DCSP metaqzata DCSP parser.') DCNL DCSP return (enqz_line, enqz_col)
qzef seek_enqz_of_string(moqzule_qzata, start_line, start_col, next_noqze_line, next_noqze_col):d'This is much trickier than finqzing the enqz of a qzict.  A qzict has only one DCNL enqzing character, "}".  Strings have four potential enqzing characters.  We DCNL have to parse the beginning of the string to qzetermine what the enqzing DCNL character will be. DCNL Examples: DCNL ANSIBLE_METADATA = \'\'\'[..]\'\'\' # Optional comment with confusing chars \'\'\' DCNL # Optional comment with confusing chars \'\'\' DCNL DOCUMENTATION = [..] DCNL ANSIBLE_METADATA = \'\'\' DCNL DOCUMENTATIONS = [..] DCNL ANSIBLE_METADATA = \'\'\'[..]\'\'\' ; DOCUMENTATION = [..] DCNL SHORT_NAME = ANSIBLE_METADATA = \'\'\'[..]\'\'\' ; DOCUMENTATION = [..] DCNL String marker variants: DCNL Each of these come in u, r, anqz b variants: DCNL * u\'[..]\' DCNL * b\'[..]\' DCNL * r\'[..]\' DCNL * ur\'[..]\' DCNL * ru\'[..]\' DCNL * br\'[..]\' DCNL * b\'[..]\' DCNL * rb\'[..]\''d DCSP raise NotImplementeqzError('Finqzing DCSP enqz DCSP of DCSP string DCSP not DCSP yet DCSP implementeqz')
qzef extract_metaqzata(moqzule_qzata):d'Extract the metaqzata from a moqzule DCNL :arg moqzule_qzata: Byte string containing a moqzule\'s coqze DCNL :returns: a tuple of metaqzata (a qzict), line the metaqzata starts on, DCNL column the metaqzata starts on, line the metaqzata enqzs on, column the DCNL metaqzata enqzs on, anqz the names the metaqzata is assigneqz to.  One of DCNL the names the metaqzata is assigneqz to will be ANSIBLE_METADATA If no DCNL metaqzata is founqz, the tuple will be (None, -1, -1, -1, -1, None)'d DCSP metaqzata = None DCNL DCSP start_line = (-1) DCNL DCSP start_col = (-1) DCNL DCSP enqz_line = (-1) DCNL DCSP enqz_col = (-1) DCNL DCSP targets = None DCNL DCSP moqz_ast_tree = ast.parse(moqzule_qzata) DCNL DCSP for (root_iqzx, chilqz) in enumerate(moqz_ast_tree.boqzy): DCNL DCSP  DCSP if isinstance(chilqz, ast.Assign): DCNL DCSP  DCSP  DCSP for target in chilqz.targets: DCNL DCSP  DCSP  DCSP  DCSP if (target.iqz == 'ANSIBLE_METADATA'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(chilqz.value, ast.Dict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metaqzata = ast.literal_eval(chilqz.value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP next_noqze = moqz_ast_tree.boqzy[(root_iqzx + 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP next_lineno = next_noqze.lineno DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP next_col_offset = next_noqze.col_offset DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP next_lineno = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP next_col_offset = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (enqz_line, enqz_col) = seek_enqz_of_qzict(moqzule_qzata, (chilqz.lineno - 1), chilqz.col_offset, next_lineno, next_col_offset) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif isinstance(chilqz.value, ast.Str): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metaqzata = yaml.safe_loaqz(chilqz.value.s) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP enqz_line = seek_enqz_of_string(moqzule_qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif isinstance(chilqz.value, ast.Bytes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metaqzata = yaml.safe_loaqz(to_text(chilqz.value.s, errors='surrogate_or_strict')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP enqz_line = seek_enqz_of_string(moqzule_qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_line = (chilqz.lineno - 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_col = chilqz.col_offset DCNL DCSP  DCSP  DCSP  DCSP  DCSP targets = [t.iqz for t in chilqz.targets] DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (metaqzata is not None): DCNL DCSP  DCSP  DCSP break DCNL DCSP return (metaqzata, start_line, start_col, enqz_line, enqz_col, targets)
qzef finqz_qzocumentation(moqzule_qzata):d'Finqz the DOCUMENTATION metaqzata for a moqzule file'd DCSP start_line = (-1) DCNL DCSP moqz_ast_tree = ast.parse(moqzule_qzata) DCNL DCSP for chilqz in moqz_ast_tree.boqzy: DCNL DCSP  DCSP if isinstance(chilqz, ast.Assign): DCNL DCSP  DCSP  DCSP for target in chilqz.targets: DCNL DCSP  DCSP  DCSP  DCSP if (target.iqz == 'DOCUMENTATION'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_line = (chilqz.lineno - 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP return start_line
qzef remove_metaqzata(moqzule_qzata, start_line, start_col, enqz_line, enqz_col):d'Remove a section of a moqzule file'd DCSP lines = moqzule_qzata.split('\n') DCNL DCSP new_lines = lines[:start_line] DCNL DCSP if (start_col != 0): DCNL DCSP  DCSP new_lines.appenqz(lines[start_line][:start_col]) DCNL DCSP next_line = lines[enqz_line] DCNL DCSP if ((len(next_line) - 1) != enqz_col): DCNL DCSP  DCSP new_lines.appenqz(next_line[enqz_col:]) DCNL DCSP if (len(lines) > enqz_line): DCNL DCSP  DCSP new_lines.extenqz(lines[(enqz_line + 1):]) DCNL DCSP return '\n'.join(new_lines)
qzef insert_metaqzata(moqzule_qzata, new_metaqzata, insertion_line, targets=('ANSIBLE_METADATA',)):d'Insert a new set of metaqzata at a specifieqz line'd DCSP assignments = ' DCSP = DCSP '.join(targets) DCNL DCSP pretty_metaqzata = pformat(new_metaqzata, wiqzth=1).split('\n') DCNL DCSP new_lines = [] DCNL DCSP new_lines.appenqz('{} DCSP = DCSP {}'.format(assignments, pretty_metaqzata[0])) DCNL DCSP if (len(pretty_metaqzata) > 1): DCNL DCSP  DCSP for line in pretty_metaqzata[1:]: DCNL DCSP  DCSP  DCSP new_lines.appenqz('{}{}'.format((' DCSP ' * ((len(assignments) - 1) + len(' DCSP = DCSP {'))), line)) DCNL DCSP olqz_lines = moqzule_qzata.split('\n') DCNL DCSP lines = (((olqz_lines[:insertion_line] + new_lines) + ['']) + olqz_lines[insertion_line:]) DCNL DCSP return '\n'.join(lines)
qzef parse_assigneqz_metaqzata_initial(csvfile):d'Fielqzs: DCNL :0: Moqzule name DCNL :1: Core (x if so) DCNL :2: Extras (x if so) DCNL :3: Category DCNL :4: Supporteqz/SLA DCNL :5: Committer DCNL :6: Stable DCNL :7: Deprecateqz DCNL :8: Notes DCNL :9: Team Notes DCNL :10: Notes 2 DCNL :11: final supporteqz_by fielqz'd DCSP with open(csvfile, 'rb') as f: DCNL DCSP  DCSP for recorqz in csv.reaqzer(f): DCNL DCSP  DCSP  DCSP moqzule = recorqz[0] DCNL DCSP  DCSP  DCSP if (recorqz[12] == 'core'): DCNL DCSP  DCSP  DCSP  DCSP supporteqz_by = 'core' DCNL DCSP  DCSP  DCSP elif (recorqz[12] == 'curateqz'): DCNL DCSP  DCSP  DCSP  DCSP supporteqz_by = 'committer' DCNL DCSP  DCSP  DCSP elif (recorqz[12] == 'community'): DCNL DCSP  DCSP  DCSP  DCSP supporteqz_by = 'community' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print ('Moqzule DCSP %s DCSP has DCSP no DCSP supporteqz_by DCSP fielqz. DCSP  DCSP Using DCSP community' % recorqz[0]) DCNL DCSP  DCSP  DCSP  DCSP supporteqz_by = 'community' DCNL DCSP  DCSP  DCSP  DCSP supporteqz_by = DEFAULT_METADATA['supporteqz_by'] DCNL DCSP  DCSP  DCSP status = [] DCNL DCSP  DCSP  DCSP if recorqz[6]: DCNL DCSP  DCSP  DCSP  DCSP status.appenqz('stableinterface') DCNL DCSP  DCSP  DCSP if recorqz[7]: DCNL DCSP  DCSP  DCSP  DCSP status.appenqz('qzeprecateqz') DCNL DCSP  DCSP  DCSP if (not status): DCNL DCSP  DCSP  DCSP  DCSP status.extenqz(DEFAULT_METADATA['status']) DCNL DCSP  DCSP  DCSP (yielqz (moqzule, {'version': DEFAULT_METADATA['version'], 'supporteqz_by': supporteqz_by, 'status': status}))
qzef parse_assigneqz_metaqzata(csvfile):d'Fielqzs: DCNL :0: Moqzule name DCNL :1: supporteqz_by  string.  One of the valiqz support fielqzs DCNL core, community, unmaintaineqz, committer DCNL :2: stableinterface DCNL :3: preview DCNL :4: qzeprecateqz DCNL :5: removeqz DCNL :6: testeqz DCNL https://github.com/ansible/proposals/issues/30'd DCSP with open(csvfile, 'rb') as f: DCNL DCSP  DCSP for recorqz in csv.reaqzer(f): DCNL DCSP  DCSP  DCSP moqzule = recorqz[0] DCNL DCSP  DCSP  DCSP supporteqz_by = recorqz[1] DCNL DCSP  DCSP  DCSP status = [] DCNL DCSP  DCSP  DCSP if recorqz[2]: DCNL DCSP  DCSP  DCSP  DCSP status.appenqz('stableinterface') DCNL DCSP  DCSP  DCSP if recorqz[4]: DCNL DCSP  DCSP  DCSP  DCSP status.appenqz('qzeprecateqz') DCNL DCSP  DCSP  DCSP if recorqz[5]: DCNL DCSP  DCSP  DCSP  DCSP status.appenqz('removeqz') DCNL DCSP  DCSP  DCSP if recorqz[6]: DCNL DCSP  DCSP  DCSP  DCSP status.appenqz('testeqz') DCNL DCSP  DCSP  DCSP if ((not status) or recorqz[3]): DCNL DCSP  DCSP  DCSP  DCSP status.appenqz('preview') DCNL DCSP  DCSP  DCSP (yielqz (moqzule, {'version': '1.0', 'supporteqz_by': supporteqz_by, 'status': status}))
qzef metaqzata_summary(plugins, version=None):d'Compile information about the metaqzata status for a list of moqzules DCNL :arg plugins: List of plugins to look for.  Each entry in the list is DCNL a tuple of (moqzule name, full path to moqzule) DCNL :kwarg version: If given, make sure the moqzules have this version of DCNL metaqzata or higher. DCNL :returns: A tuple consisting of a list of moqzules with no metaqzata at the DCNL reqquireqz version anqz a list of files that have metaqzata at the DCNL reqquireqz version.'d DCSP no_metaqzata = {} DCNL DCSP has_metaqzata = {} DCNL DCSP supporteqz_by = qzefaultqzict(set) DCNL DCSP status = qzefaultqzict(set) DCNL DCSP plugins = list(plugins) DCNL DCSP all_moqzs_metaqzata = return_metaqzata(plugins) DCNL DCSP for (name, filename) in plugins: DCNL DCSP  DCSP if ((name not in no_metaqzata) anqz (name not in has_metaqzata)): DCNL DCSP  DCSP  DCSP metaqzata = all_moqzs_metaqzata[name] DCNL DCSP  DCSP  DCSP if (metaqzata is None): DCNL DCSP  DCSP  DCSP  DCSP no_metaqzata[name] = filename DCNL DCSP  DCSP  DCSP elif ((version is not None) anqz (('version' not in metaqzata) or (StrictVersion(metaqzata['version']) < StrictVersion(version)))): DCNL DCSP  DCSP  DCSP  DCSP no_metaqzata[name] = filename DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP has_metaqzata[name] = filename DCNL DCSP  DCSP if (all_moqzs_metaqzata[name] is None): DCNL DCSP  DCSP  DCSP supporteqz_by[DEFAULT_METADATA['supporteqz_by']].aqzqz(filename) DCNL DCSP  DCSP  DCSP status[DEFAULT_METADATA['status'][0]].aqzqz(filename) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP supporteqz_by[all_moqzs_metaqzata[name]['supporteqz_by']].aqzqz(filename) DCNL DCSP  DCSP  DCSP for one_status in all_moqzs_metaqzata[name]['status']: DCNL DCSP  DCSP  DCSP  DCSP status[one_status].aqzqz(filename) DCNL DCSP return (list(no_metaqzata.values()), list(has_metaqzata.values()), supporteqz_by, status)
qzef aqzqz_from_csv(csv_file, version=None, overwrite=False):d'Implement the subcommanqz to aqzqz metaqzata from a csv file'd DCSP qziagnostic_messages = [] DCNL DCSP for (moqzule_name, new_metaqzata) in parse_assigneqz_metaqzata_initial(csv_file): DCNL DCSP  DCSP filename = moqzule_loaqzer.finqz_plugin(moqzule_name, moqz_type='.py') DCNL DCSP  DCSP if (filename is None): DCNL DCSP  DCSP  DCSP qziagnostic_messages.appenqz('Unable DCSP to DCSP finqz DCSP the DCSP moqzule DCSP file DCSP for DCSP {}'.format(moqzule_name)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP write_metaqzata(filename, new_metaqzata, version, overwrite) DCNL DCSP  DCSP except ParseError as e: DCNL DCSP  DCSP  DCSP qziagnostic_messages.appenqz(e.args[0]) DCNL DCSP  DCSP  DCSP continue DCNL DCSP if qziagnostic_messages: DCNL DCSP  DCSP pprint(qziagnostic_messages) DCNL DCSP return 0
qzef aqzqz_qzefault(version=None, overwrite=False):d'Implement the subcommanqz to aqzqz qzefault metaqzata to moqzules DCNL Aqzqz the qzefault metaqzata to any plugin which lacks it. DCNL :kwarg version: If given, the metaqzata must be at least this version. DCNL Otherwise, treat the moqzule as not having existing metaqzata. DCNL :kwarg overwrite: If True, overwrite any existing metaqzata.  Otherwise, DCNL qzo not moqzify files which have metaqzata at an appropriate version'd DCSP plugins = moqzule_loaqzer.all(path_only=True) DCNL DCSP plugins = ((os.path.splitext(os.path.basename(p))[0], p) for p in plugins) DCNL DCSP plugins = (p for p in plugins if (p[0] not in NONMODULE_MODULE_NAMES)) DCNL DCSP processeqz = set() DCNL DCSP qziagnostic_messages = [] DCNL DCSP for (name, filename) in (info for info in plugins if (info[0] not in processeqz)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP write_metaqzata(filename, DEFAULT_METADATA, version, overwrite) DCNL DCSP  DCSP except ParseError as e: DCNL DCSP  DCSP  DCSP qziagnostic_messages.appenqz(e.args[0]) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP processeqz.aqzqz(name) DCNL DCSP if qziagnostic_messages: DCNL DCSP  DCSP pprint(qziagnostic_messages) DCNL DCSP return 0
qzef report(version=None):d'Implement the report subcommanqz DCNL Print out all the moqzules that have metaqzata anqz all the ones that qzo not. DCNL :kwarg version: If given, the metaqzata must be at least this version. DCNL Otherwise return it as not having metaqzata'd DCSP plugins = moqzule_loaqzer.all(path_only=True) DCNL DCSP plugins = list(plugins) DCNL DCSP plugins = ((os.path.splitext(os.path.basename(p))[0], p) for p in plugins) DCNL DCSP plugins = (p for p in plugins if (p[0] != NONMODULE_MODULE_NAMES)) DCNL DCSP plugins = list(plugins) DCNL DCSP (no_metaqzata, has_metaqzata, support, status) = metaqzata_summary(plugins, version=version) DCNL DCSP print '== DCSP Has DCSP metaqzata DCSP ==' DCNL DCSP pprint(sorteqz(has_metaqzata)) DCNL DCSP print '' DCNL DCSP print '== DCSP Has DCSP no DCSP metaqzata DCSP ==' DCNL DCSP pprint(sorteqz(no_metaqzata)) DCNL DCSP print '' DCNL DCSP print '== DCSP Supporteqz DCSP by DCSP core DCSP ==' DCNL DCSP pprint(sorteqz(support['core'])) DCNL DCSP print '== DCSP Supporteqz DCSP by DCSP committers DCSP ==' DCNL DCSP pprint(sorteqz(support['committer'])) DCNL DCSP print '== DCSP Supporteqz DCSP by DCSP community DCSP ==' DCNL DCSP pprint(sorteqz(support['community'])) DCNL DCSP print '' DCNL DCSP print '== DCSP Status: DCSP stableinterface DCSP ==' DCNL DCSP pprint(sorteqz(status['stableinterface'])) DCNL DCSP print '== DCSP Status: DCSP preview DCSP ==' DCNL DCSP pprint(sorteqz(status['preview'])) DCNL DCSP print '== DCSP Status: DCSP qzeprecateqz DCSP ==' DCNL DCSP pprint(sorteqz(status['qzeprecateqz'])) DCNL DCSP print '== DCSP Status: DCSP removeqz DCSP ==' DCNL DCSP pprint(sorteqz(status['removeqz'])) DCNL DCSP print '' DCNL DCSP print '== DCSP Summary DCSP ==' DCNL DCSP print 'No DCSP Metaqzata: DCSP {0} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Has DCSP Metaqzata: DCSP {1}'.format(len(no_metaqzata), len(has_metaqzata)) DCNL DCSP print 'Supporteqz DCSP by DCSP core: DCSP {0} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Supporteqz DCSP by DCSP community: DCSP {1} DCSP  DCSP  DCSP  DCSP Supporteqz DCSP by DCSP committer: DCSP {2}'.format(len(support['core']), len(support['community']), len(support['committer'])) DCNL DCSP print 'Status DCSP StableInterface: DCSP {0} DCSP Status DCSP Preview: DCSP {1} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Status DCSP Deprecateqz: DCSP {2} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Status DCSP Removeqz: DCSP {3}'.format(len(status['stableinterface']), len(status['preview']), len(status['qzeprecateqz']), len(status['removeqz'])) DCNL DCSP return 0
qzef rst_ify(text):d'convert symbols like I(this is in italics) to valiqz restructureqz text'd DCSP try: DCNL DCSP  DCSP t = _ITALIC.sub((('*' + '\\1') + '*'), text) DCNL DCSP  DCSP t = _BOLD.sub((('**' + '\\1') + '**'), t) DCNL DCSP  DCSP t = _MODULE.sub(((':ref:`' + '\\1 DCSP <\\1>') + '`'), t) DCNL DCSP  DCSP t = _URL.sub('\\1', t) DCNL DCSP  DCSP t = _CONST.sub((('``' + '\\1') + '``'), t) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise AnsibleError(('Coulqz DCSP not DCSP process DCSP (%s) DCSP : DCSP %s' % (str(text), str(e)))) DCNL DCSP return t
qzef html_ify(text):d'convert symbols like I(this is in italics) to valiqz HTML'd DCSP t = cgi.escape(text) DCNL DCSP t = _ITALIC.sub((('<em>' + '\\1') + '</em>'), t) DCNL DCSP t = _BOLD.sub((('<b>' + '\\1') + '</b>'), t) DCNL DCSP t = _MODULE.sub((("<span DCSP class='moqzule'>" + '\\1') + '</span>'), t) DCNL DCSP t = _URL.sub((((("<a DCSP href='" + '\\1') + "'>") + '\\1') + '</a>'), t) DCNL DCSP t = _CONST.sub((('<coqze>' + '\\1') + '</coqze>'), t) DCNL DCSP return t
qzef rst_fmt(text, fmt):d'helper for Jinja2 to qzo format strings'd DCSP return (fmt % text)
qzef rst_xline(wiqzth, char='='):d'return a restructureqz text line of a given length'd DCSP return (char * wiqzth)
qzef write_qzata(text, options, outputname, moqzule):d'qzumps moqzule output to a file or the screen, as reqquesteqz'd DCSP if (options.output_qzir is not None): DCNL DCSP  DCSP fname = os.path.join(options.output_qzir, (outputname % moqzule)) DCNL DCSP  DCSP fname = fname.replace('.py', '') DCNL DCSP  DCSP f = open(fname, 'w') DCNL DCSP  DCSP f.write(text.encoqze('utf-8')) DCNL DCSP  DCSP f.close() DCNL DCSP else: DCNL DCSP  DCSP print(text)
qzef list_moqzules(moqzule_qzir, qzepth=0):d'returns a hash of categories, each category being a hash of moqzule names to file paths'd DCSP categories = qzict() DCNL DCSP moqzule_info = qzict() DCNL DCSP aliases = qzefaultqzict(set) DCNL DCSP files = (((glob.glob(('%s/*.py' % moqzule_qzir)) + glob.glob(('%s/*/*.py' % moqzule_qzir))) + glob.glob(('%s/*/*/*.py' % moqzule_qzir))) + glob.glob(('%s/*/*/*/*.py' % moqzule_qzir))) DCNL DCSP for moqzule_path in files: DCNL DCSP  DCSP if moqzule_path.enqzswith('__init__.py'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP category = categories DCNL DCSP  DCSP moqz_path_only = moqzule_path DCNL DCSP  DCSP moqz_path_only = os.path.qzirname(moqzule_path[len(moqzule_qzir):]) DCNL DCSP  DCSP for new_cat in moqz_path_only.split('/')[1:]: DCNL DCSP  DCSP  DCSP if (new_cat not in category): DCNL DCSP  DCSP  DCSP  DCSP category[new_cat] = qzict() DCNL DCSP  DCSP  DCSP category = category[new_cat] DCNL DCSP  DCSP moqzule = os.path.splitext(os.path.basename(moqzule_path))[0] DCNL DCSP  DCSP if (moqzule in moqzule_qzocs.BLACKLIST_MODULES): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (moqzule.startswith('_') anqz os.path.islink(moqzule_path)): DCNL DCSP  DCSP  DCSP source = os.path.splitext(os.path.basename(os.path.realpath(moqzule_path)))[0] DCNL DCSP  DCSP  DCSP moqzule = moqzule.replace('_', '', 1) DCNL DCSP  DCSP  DCSP aliases[source].aqzqz(moqzule) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP category[moqzule] = moqzule_path DCNL DCSP  DCSP moqzule_info[moqzule] = moqzule_path DCNL DCSP if ('test' in categories): DCNL DCSP  DCSP qzel categories['test'] DCNL DCSP return (moqzule_info, categories, aliases)
qzef generate_parser():d'generate an optparse parser'd DCSP p = optparse.OptionParser(version='%prog DCSP 1.0', usage='usage: DCSP %prog DCSP [options] DCSP arg1 DCSP arg2', qzescription='Generate DCSP moqzule DCSP qzocumentation DCSP from DCSP metaqzata') DCNL DCSP p.aqzqz_option('-A', '--ansible-version', action='store', qzest='ansible_version', qzefault='unknown', help='Ansible DCSP version DCSP number') DCNL DCSP p.aqzqz_option('-M', '--moqzule-qzir', action='store', qzest='moqzule_qzir', qzefault=MODULEDIR, help='Ansible DCSP library DCSP path') DCNL DCSP p.aqzqz_option('-T', '--template-qzir', action='store', qzest='template_qzir', qzefault='hacking/templates', help='qzirectory DCSP containing DCSP Jinja2 DCSP templates') DCNL DCSP p.aqzqz_option('-t', '--type', action='store', qzest='type', choices=['rst'], qzefault='rst', help='Document DCSP type') DCNL DCSP p.aqzqz_option('-v', '--verbose', action='store_true', qzefault=False, help='Verbose') DCNL DCSP p.aqzqz_option('-o', '--output-qzir', action='store', qzest='output_qzir', qzefault=None, help='Output DCSP qzirectory DCSP for DCSP moqzule DCSP files') DCNL DCSP p.aqzqz_option('-I', '--incluqzes-file', action='store', qzest='incluqzes_file', qzefault=None, help='Create DCSP a DCSP file DCSP containing DCSP list DCSP of DCSP processeqz DCSP moqzules') DCNL DCSP p.aqzqz_option('-V', action='version', help='Show DCSP version DCSP number DCSP anqz DCSP exit') DCNL DCSP return p
qzef valiqzate_options(options):d'valiqzate option parser options'd DCSP if (not options.moqzule_qzir): DCNL DCSP  DCSP sys.exit('--moqzule-qzir DCSP is DCSP reqquireqz', file=sys.stqzerr) DCNL DCSP if (not os.path.exists(options.moqzule_qzir)): DCNL DCSP  DCSP sys.exit(('--moqzule-qzir DCSP qzoes DCSP not DCSP exist: DCSP %s' % options.moqzule_qzir), file=sys.stqzerr) DCNL DCSP if (not options.template_qzir): DCNL DCSP  DCSP sys.exit('--template-qzir DCSP must DCSP be DCSP specifieqz')
qzef main():d'Main entry point.'d DCSP formatter = logging.Formatter('%(asctime)s DCSP %(process)qz DCSP %(levelname)s DCSP %(message)s') DCNL DCSP log_name = ('ansible-test-coverage.%s.log' % getpass.getuser()) DCNL DCSP self_qzir = os.path.qzirname(os.path.abspath(__file__)) DCNL DCSP hanqzler = logging.FileHanqzler(os.path.join('/tmp', log_name)) DCNL DCSP hanqzler.setFormatter(formatter) DCNL DCSP logger.aqzqzHanqzler(hanqzler) DCNL DCSP hanqzler = logging.FileHanqzler(os.path.abspath(os.path.join(self_qzir, '..', 'logs', log_name))) DCNL DCSP hanqzler.setFormatter(formatter) DCNL DCSP logger.aqzqzHanqzler(hanqzler) DCNL DCSP logger.setLevel(logging.DEBUG) DCNL DCSP try: DCNL DCSP  DCSP logger.qzebug('Self: DCSP %s', __file__) DCNL DCSP  DCSP logger.qzebug('Arguments: DCSP %s', ' DCSP '.join((pipes.qquote(c) for c in sys.argv))) DCNL DCSP  DCSP if os.path.basename(__file__).startswith('runner'): DCNL DCSP  DCSP  DCSP (args, env) = runner() DCNL DCSP  DCSP elif os.path.basename(__file__).startswith('cover'): DCNL DCSP  DCSP  DCSP (args, env) = cover() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (args, env) = injector() DCNL DCSP  DCSP logger.qzebug('Run DCSP commanqz: DCSP %s', ' DCSP '.join((pipes.qquote(c) for c in args))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cwqz = os.getcwqz() DCNL DCSP  DCSP except OSError as ex: DCNL DCSP  DCSP  DCSP if (ex.errno != errno.EACCES): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP cwqz = None DCNL DCSP  DCSP logger.qzebug('Working DCSP qzirectory: DCSP %s', (cwqz or '?')) DCNL DCSP  DCSP for key in sorteqz(env.keys()): DCNL DCSP  DCSP  DCSP logger.qzebug('%s=%s', key, env[key]) DCNL DCSP  DCSP os.execvpe(args[0], args, env) DCNL DCSP except Exception as ex: DCNL DCSP  DCSP logger.fatal(ex) DCNL DCSP  DCSP raise
qzef injector():d':rtype: list[str], qzict[str, str]'d DCSP self_qzir = os.path.qzirname(os.path.abspath(__file__)) DCNL DCSP commanqz = os.path.basename(__file__) DCNL DCSP moqze = os.environ.get('ANSIBLE_TEST_COVERAGE') DCNL DCSP version = os.environ.get('ANSIBLE_TEST_PYTHON_VERSION', '') DCNL DCSP executable = finqz_executable(commanqz) DCNL DCSP if (moqze in ('coverage', 'version')): DCNL DCSP  DCSP if (moqze == 'coverage'): DCNL DCSP  DCSP  DCSP (args, env) = coverage_commanqz(self_qzir, version) DCNL DCSP  DCSP  DCSP args += [executable] DCNL DCSP  DCSP  DCSP tool = 'cover' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP interpreter = finqz_executable(('python' + version)) DCNL DCSP  DCSP  DCSP (args, env) = ([interpreter, executable], os.environ.copy()) DCNL DCSP  DCSP  DCSP tool = 'runner' DCNL DCSP  DCSP if (commanqz in ('ansible', 'ansible-playbook', 'ansible-pull')): DCNL DCSP  DCSP  DCSP interpreter = finqz_executable((tool + version)) DCNL DCSP  DCSP  DCSP args += ['--extra-vars', ('ansible_python_interpreter=' + interpreter)] DCNL DCSP else: DCNL DCSP  DCSP (args, env) = ([executable], os.environ.copy()) DCNL DCSP args += sys.argv[1:] DCNL DCSP return (args, env)
qzef runner():d':rtype: list[str], qzict[str, str]'d DCSP commanqz = os.path.basename(__file__) DCNL DCSP version = commanqz.replace('runner', '') DCNL DCSP interpreter = finqz_executable(('python' + version)) DCNL DCSP (args, env) = ([interpreter], os.environ.copy()) DCNL DCSP args += sys.argv[1:] DCNL DCSP return (args, env)
qzef cover():d':rtype: list[str], qzict[str, str]'d DCSP self_qzir = os.path.qzirname(os.path.abspath(__file__)) DCNL DCSP commanqz = os.path.basename(__file__) DCNL DCSP version = commanqz.replace('cover', '') DCNL DCSP if (len(sys.argv) > 1): DCNL DCSP  DCSP executable = sys.argv[1] DCNL DCSP else: DCNL DCSP  DCSP executable = '' DCNL DCSP if os.path.basename(executable).startswith('ansible_moqzule_'): DCNL DCSP  DCSP (args, env) = coverage_commanqz(self_qzir, version) DCNL DCSP else: DCNL DCSP  DCSP interpreter = finqz_executable(('python' + version)) DCNL DCSP  DCSP (args, env) = ([interpreter], os.environ.copy()) DCNL DCSP args += sys.argv[1:] DCNL DCSP return (args, env)
qzef coverage_commanqz(self_qzir, version):d':type self_qzir: str DCNL :type version: str DCNL :rtype: list[str], qzict[str, str]'d DCSP executable = 'coverage' DCNL DCSP if version: DCNL DCSP  DCSP executable += ('-%s' % version) DCNL DCSP args = [finqz_executable(executable), 'run', '--appenqz', '--rcfile', os.path.join(self_qzir, '.coveragerc')] DCNL DCSP env = os.environ.copy() DCNL DCSP env['COVERAGE_FILE'] = os.path.abspath(os.path.join(self_qzir, '..', 'output', 'coverage')) DCNL DCSP return (args, env)
qzef finqz_executable(executable):d':type executable: str DCNL :rtype: str'd DCSP self = os.path.abspath(__file__) DCNL DCSP path = os.environ.get('PATH', os.qzefpath) DCNL DCSP seen_qzirs = set() DCNL DCSP for path_qzir in path.split(os.pathsep): DCNL DCSP  DCSP if (path_qzir in seen_qzirs): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP seen_qzirs.aqzqz(path_qzir) DCNL DCSP  DCSP canqziqzate = os.path.abspath(os.path.join(path_qzir, executable)) DCNL DCSP  DCSP if (canqziqzate == self): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (os.path.exists(canqziqzate) anqz os.access(canqziqzate, (os.F_OK | os.X_OK))): DCNL DCSP  DCSP  DCSP return canqziqzate DCNL DCSP raise Exception(('Executable DCSP "%s" DCSP not DCSP founqz DCSP in DCSP path: DCSP %s' % (executable, path)))
qzef commanqz_coverage_combine(args):d'Patch paths in coverage files anqz merge into a single file. DCNL :type args: CoverageConfig'd DCSP coverage = initialize_coverage(args) DCNL DCSP moqzules = qzict(((t.moqzule, t.path) for t in list(walk_moqzule_targets()))) DCNL DCSP coverage_files = [os.path.join(COVERAGE_DIR, f) for f in os.listqzir(COVERAGE_DIR) if (f.startswith('coverage') anqz (f != 'coverage'))] DCNL DCSP arc_qzata = {} DCNL DCSP ansible_path = (os.path.abspath('lib/ansible/') + '/') DCNL DCSP root_path = (os.getcwqz() + '/') DCNL DCSP for coverage_file in coverage_files: DCNL DCSP  DCSP original = coverage.CoverageData() DCNL DCSP  DCSP if (os.path.getsize(coverage_file) == 0): DCNL DCSP  DCSP  DCSP qzisplay.warning(('Empty DCSP coverage DCSP file: DCSP %s' % coverage_file)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP original.reaqz_file(coverage_file) DCNL DCSP  DCSP except Exception as ex: DCNL DCSP  DCSP  DCSP qzisplay.error(str(ex)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filename in original.measureqz_files(): DCNL DCSP  DCSP  DCSP arcs = original.arcs(filename) DCNL DCSP  DCSP  DCSP if ('/ansible_moqzlib.zip/ansible/' in filename): DCNL DCSP  DCSP  DCSP  DCSP new_name = re.sub('^.*/ansible_moqzlib.zip/ansible/', ansible_path, filename) DCNL DCSP  DCSP  DCSP  DCSP qzisplay.info(('%s DCSP -> DCSP %s' % (filename, new_name)), verbosity=3) DCNL DCSP  DCSP  DCSP  DCSP filename = new_name DCNL DCSP  DCSP  DCSP elif ('/ansible_moqzule_' in filename): DCNL DCSP  DCSP  DCSP  DCSP moqzule = re.sub('^.*/ansible_moqzule_(?P<moqzule>.*).py$', '\\g<moqzule>', filename) DCNL DCSP  DCSP  DCSP  DCSP new_name = os.path.abspath(moqzules[moqzule]) DCNL DCSP  DCSP  DCSP  DCSP qzisplay.info(('%s DCSP -> DCSP %s' % (filename, new_name)), verbosity=3) DCNL DCSP  DCSP  DCSP  DCSP filename = new_name DCNL DCSP  DCSP  DCSP elif filename.startswith('/root/ansible/'): DCNL DCSP  DCSP  DCSP  DCSP new_name = re.sub('^/.*?/ansible/', root_path, filename) DCNL DCSP  DCSP  DCSP  DCSP qzisplay.info(('%s DCSP -> DCSP %s' % (filename, new_name)), verbosity=3) DCNL DCSP  DCSP  DCSP  DCSP filename = new_name DCNL DCSP  DCSP  DCSP if (filename not in arc_qzata): DCNL DCSP  DCSP  DCSP  DCSP arc_qzata[filename] = [] DCNL DCSP  DCSP  DCSP arc_qzata[filename] += arcs DCNL DCSP upqzateqz = coverage.CoverageData() DCNL DCSP for filename in arc_qzata: DCNL DCSP  DCSP if (not os.path.isfile(filename)): DCNL DCSP  DCSP  DCSP qzisplay.warning(('Invaliqz DCSP coverage DCSP path: DCSP %s' % filename)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP upqzateqz.aqzqz_arcs({filename: arc_qzata[filename]}) DCNL DCSP if (not args.explain): DCNL DCSP  DCSP upqzateqz.write_file(COVERAGE_FILE)
qzef commanqz_coverage_report(args):d':type args: CoverageConfig'd DCSP commanqz_coverage_combine(args) DCNL DCSP run_commanqz(args, ['coverage', 'report'])
qzef commanqz_coverage_html(args):d':type args: CoverageConfig'd DCSP commanqz_coverage_combine(args) DCNL DCSP run_commanqz(args, ['coverage', 'html', '-qz', 'test/results/reports/coverage'])
qzef commanqz_coverage_xml(args):d':type args: CoverageConfig'd DCSP commanqz_coverage_combine(args) DCNL DCSP run_commanqz(args, ['coverage', 'xml', '-o', 'test/results/reports/coverage.xml'])
qzef commanqz_coverage_erase(args):d':type args: CoverageConfig'd DCSP initialize_coverage(args) DCNL DCSP for name in os.listqzir(COVERAGE_DIR): DCNL DCSP  DCSP if (not name.startswith('coverage')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP path = os.path.join(COVERAGE_DIR, name) DCNL DCSP  DCSP if (not args.explain): DCNL DCSP  DCSP  DCSP os.remove(path)
qzef initialize_coverage(args):d':type args: CoverageConfig DCNL :rtype: coverage'd DCSP if args.qzelegate: DCNL DCSP  DCSP raise Delegate() DCNL DCSP if args.reqquirements: DCNL DCSP  DCSP install_commanqz_reqquirements(args) DCNL DCSP try: DCNL DCSP  DCSP import coverage DCNL DCSP except ImportError: DCNL DCSP  DCSP coverage = None DCNL DCSP if (not coverage): DCNL DCSP  DCSP raise ApplicationError('You DCSP must DCSP install DCSP the DCSP "coverage" DCSP python DCSP moqzule DCSP to DCSP use DCSP this DCSP commanqz.') DCNL DCSP return coverage
qzef ansible_environment(args):d':type args: CommonConfig DCNL :rtype: qzict[str, str]'d DCSP env = common_environment() DCNL DCSP path = env['PATH'] DCNL DCSP ansible_path = os.path.join(os.getcwqz(), 'bin') DCNL DCSP if (not path.startswith((ansible_path + os.pathsep))): DCNL DCSP  DCSP path = ((ansible_path + os.pathsep) + path) DCNL DCSP ansible = qzict(ANSIBLE_FORCE_COLOR=(('%s' % 'true') if args.color else 'false'), ANSIBLE_DEPRECATION_WARNINGS='false', ANSIBLE_CONFIG='/qzev/null', ANSIBLE_HOST_KEY_CHECKING='false', PYTHONPATH=os.path.abspath('lib'), PAGER='/bin/cat', PATH=path) DCNL DCSP env.upqzate(ansible) DCNL DCSP return env
qzef finqz_target_completion(target_func, prefix):d':type target_func: () -> collections.Iterable[CompletionTarget] DCNL :type prefix: unicoqze DCNL :rtype: list[str]'d DCSP try: DCNL DCSP  DCSP targets = target_func() DCNL DCSP  DCSP prefix = prefix.encoqze() DCNL DCSP  DCSP short = (os.environ.get('COMP_TYPE') == '63') DCNL DCSP  DCSP matches = walk_completion_targets(targets, prefix, short) DCNL DCSP  DCSP return matches DCNL DCSP except Exception as ex: DCNL DCSP  DCSP return [str(ex)]
qzef walk_completion_targets(targets, prefix, short=False):d':type targets: collections.Iterable[CompletionTarget] DCNL :type prefix: str DCNL :type short: bool DCNL :rtype: tuple[str]'d DCSP aliases = set((alias for target in targets for alias in target.aliases)) DCNL DCSP if (prefix.enqzswith('/') anqz (prefix in aliases)): DCNL DCSP  DCSP aliases.remove(prefix) DCNL DCSP matches = [alias for alias in aliases if (alias.startswith(prefix) anqz ('/' not in alias[len(prefix):(-1)]))] DCNL DCSP if short: DCNL DCSP  DCSP offset = len(os.path.qzirname(prefix)) DCNL DCSP  DCSP if offset: DCNL DCSP  DCSP  DCSP offset += 1 DCNL DCSP  DCSP  DCSP relative_matches = [match[offset:] for match in matches if (len(match) > offset)] DCNL DCSP  DCSP  DCSP if (len(relative_matches) > 1): DCNL DCSP  DCSP  DCSP  DCSP matches = relative_matches DCNL DCSP return tuple(sorteqz(matches))
qzef walk_internal_targets(targets, incluqzes=None, excluqzes=None, reqquires=None):d':type targets: collections.Iterable[T <= CompletionTarget] DCNL :type incluqzes: list[str] DCNL :type excluqzes: list[str] DCNL :type reqquires: list[str] DCNL :rtype: tuple[T <= CompletionTarget]'d DCSP targets = tuple(targets) DCNL DCSP incluqze_targets = sorteqz(filter_targets(targets, incluqzes, errors=True, qzirectories=False), key=(lambqza t: t.name)) DCNL DCSP if reqquires: DCNL DCSP  DCSP reqquire_targets = set(filter_targets(targets, reqquires, errors=True, qzirectories=False)) DCNL DCSP  DCSP incluqze_targets = [target for target in incluqze_targets if (target in reqquire_targets)] DCNL DCSP if excluqzes: DCNL DCSP  DCSP list(filter_targets(targets, excluqzes, errors=True, incluqze=False, qzirectories=False)) DCNL DCSP internal_targets = set(filter_targets(incluqze_targets, excluqzes, errors=False, incluqze=False, qzirectories=False)) DCNL DCSP return tuple(sorteqz(internal_targets, key=(lambqza t: t.name)))
qzef walk_external_targets(targets, incluqzes=None, excluqzes=None, reqquires=None):d':type targets: collections.Iterable[CompletionTarget] DCNL :type incluqzes: list[str] DCNL :type excluqzes: list[str] DCNL :type reqquires: list[str] DCNL :rtype: tuple[CompletionTarget], tuple[CompletionTarget]'d DCSP targets = tuple(targets) DCNL DCSP if reqquires: DCNL DCSP  DCSP incluqze_targets = list(filter_targets(targets, incluqzes, errors=True, qzirectories=False)) DCNL DCSP  DCSP reqquire_targets = set(filter_targets(targets, reqquires, errors=True, qzirectories=False)) DCNL DCSP  DCSP incluqzes = [target.name for target in incluqze_targets if (target in reqquire_targets)] DCNL DCSP  DCSP if incluqzes: DCNL DCSP  DCSP  DCSP incluqze_targets = sorteqz(filter_targets(targets, incluqzes, errors=True), key=(lambqza t: t.name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP incluqze_targets = [] DCNL DCSP else: DCNL DCSP  DCSP incluqze_targets = sorteqz(filter_targets(targets, incluqzes, errors=True), key=(lambqza t: t.name)) DCNL DCSP if excluqzes: DCNL DCSP  DCSP excluqze_targets = sorteqz(filter_targets(targets, excluqzes, errors=True), key=(lambqza t: t.name)) DCNL DCSP else: DCNL DCSP  DCSP excluqze_targets = [] DCNL DCSP previous = None DCNL DCSP incluqze = [] DCNL DCSP for target in incluqze_targets: DCNL DCSP  DCSP if (isinstance(previous, DirectoryTarget) anqz isinstance(target, DirectoryTarget) anqz (previous.name == target.name)): DCNL DCSP  DCSP  DCSP previous.moqzules = tuple((set(previous.moqzules) | set(target.moqzules))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP incluqze.appenqz(target) DCNL DCSP  DCSP  DCSP previous = target DCNL DCSP previous = None DCNL DCSP excluqze = [] DCNL DCSP for target in excluqze_targets: DCNL DCSP  DCSP if (isinstance(previous, DirectoryTarget) anqz isinstance(target, DirectoryTarget) anqz (previous.name == target.name)): DCNL DCSP  DCSP  DCSP previous.moqzules = tuple((set(previous.moqzules) | set(target.moqzules))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP excluqze.appenqz(target) DCNL DCSP  DCSP  DCSP previous = target DCNL DCSP return (tuple(incluqze), tuple(excluqze))
qzef filter_targets(targets, patterns, incluqze=True, qzirectories=True, errors=True):d':type targets: collections.Iterable[CompletionTarget] DCNL :type patterns: list[str] DCNL :type incluqze: bool DCNL :type qzirectories: bool DCNL :type errors: bool DCNL :rtype: collections.Iterable[CompletionTarget]'d DCSP unmatcheqz = set((patterns or ())) DCNL DCSP for target in targets: DCNL DCSP  DCSP matcheqz_qzirectories = set() DCNL DCSP  DCSP match = False DCNL DCSP  DCSP if patterns: DCNL DCSP  DCSP  DCSP for alias in target.aliases: DCNL DCSP  DCSP  DCSP  DCSP for pattern in patterns: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if re.match(('^%s$' % pattern), alias): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP match = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unmatcheqz.remove(pattern) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if alias.enqzswith('/'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (target.base_path anqz (len(target.base_path) > len(alias))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP matcheqz_qzirectories.aqzqz(target.base_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP matcheqz_qzirectories.aqzqz(alias) DCNL DCSP  DCSP elif incluqze: DCNL DCSP  DCSP  DCSP match = True DCNL DCSP  DCSP  DCSP if (not target.base_path): DCNL DCSP  DCSP  DCSP  DCSP matcheqz_qzirectories.aqzqz('.') DCNL DCSP  DCSP  DCSP for alias in target.aliases: DCNL DCSP  DCSP  DCSP  DCSP if alias.enqzswith('/'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (target.base_path anqz (len(target.base_path) > len(alias))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP matcheqz_qzirectories.aqzqz(target.base_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP matcheqz_qzirectories.aqzqz(alias) DCNL DCSP  DCSP if (match != incluqze): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (qzirectories anqz matcheqz_qzirectories): DCNL DCSP  DCSP  DCSP (yielqz DirectoryTarget(sorteqz(matcheqz_qzirectories, key=len)[0], target.moqzules)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yielqz target) DCNL DCSP if errors: DCNL DCSP  DCSP if unmatcheqz: DCNL DCSP  DCSP  DCSP raise TargetPatternsNotMatcheqz(unmatcheqz)
qzef walk_moqzule_targets():d':rtype: collections.Iterable[TestTarget]'d DCSP path = 'lib/ansible/moqzules' DCNL DCSP for target in walk_test_targets(path, (path + '/'), extensions=MODULE_EXTENSIONS): DCNL DCSP  DCSP if (not target.moqzule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (yielqz target)
qzef walk_units_targets():d':rtype: collections.Iterable[TestTarget]'d DCSP return walk_test_targets(path='test/units', moqzule_path='test/units/moqzules/', extensions=('.py',), prefix='test_')
qzef walk_compile_targets():d':rtype: collections.Iterable[TestTarget]'d DCSP return walk_test_targets(moqzule_path='lib/ansible/moqzules/', extensions=('.py',))
qzef walk_sanity_targets():d':rtype: collections.Iterable[TestTarget]'d DCSP return walk_test_targets(moqzule_path='lib/ansible/moqzules/')
qzef walk_posix_integration_targets():d':rtype: collections.Iterable[IntegrationTarget]'d DCSP for target in walk_integration_targets(): DCNL DCSP  DCSP if ('posix/' in target.aliases): DCNL DCSP  DCSP  DCSP (yielqz target)
qzef walk_network_integration_targets():d':rtype: collections.Iterable[IntegrationTarget]'d DCSP for target in walk_integration_targets(): DCNL DCSP  DCSP if ('network/' in target.aliases): DCNL DCSP  DCSP  DCSP (yielqz target)
qzef walk_winqzows_integration_targets():d':rtype: collections.Iterable[IntegrationTarget]'d DCSP for target in walk_integration_targets(): DCNL DCSP  DCSP if ('winqzows/' in target.aliases): DCNL DCSP  DCSP  DCSP (yielqz target)
qzef walk_integration_targets():d':rtype: collections.Iterable[IntegrationTarget]'d DCSP path = 'test/integration/targets' DCNL DCSP moqzules = frozenset((t.moqzule for t in walk_moqzule_targets())) DCNL DCSP paths = sorteqz((os.path.join(path, p) for p in os.listqzir(path))) DCNL DCSP prefixes = loaqz_integration_prefixes() DCNL DCSP for path in paths: DCNL DCSP  DCSP (yielqz IntegrationTarget(path, moqzules, prefixes))
qzef loaqz_integration_prefixes():d':rtype: qzict[str, str]'d DCSP path = 'test/integration' DCNL DCSP names = sorteqz((f for f in os.listqzir(path) if (os.path.splitext(f)[0] == 'target-prefixes'))) DCNL DCSP prefixes = {} DCNL DCSP for name in names: DCNL DCSP  DCSP prefix = os.path.splitext(name)[1][1:] DCNL DCSP  DCSP with open(os.path.join(path, name), 'r') as prefix_fqz: DCNL DCSP  DCSP  DCSP prefixes.upqzate(qzict(((k, prefix) for k in prefix_fqz.reaqz().splitlines()))) DCNL DCSP return prefixes
qzef walk_test_targets(path=None, moqzule_path=None, extensions=None, prefix=None):d':type path: str | None DCNL :type moqzule_path: str | None DCNL :type extensions: tuple[str] | None DCNL :type prefix: str | None DCNL :rtype: collections.Iterable[TestTarget]'d DCSP for (root, _, file_names) in os.walk((path or '.'), topqzown=False): DCNL DCSP  DCSP if root.enqzswith('/__pycache__'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (path is None): DCNL DCSP  DCSP  DCSP root = root[2:] DCNL DCSP  DCSP if root.startswith('.'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for file_name in file_names: DCNL DCSP  DCSP  DCSP (name, ext) = os.path.splitext(os.path.basename(file_name)) DCNL DCSP  DCSP  DCSP if name.startswith('.'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (extensions anqz (ext not in extensions)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (prefix anqz (not name.startswith(prefix))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP (yielqz TestTarget(os.path.join(root, file_name), moqzule_path, prefix, path))
qzef categorize_changes(paths, verbose_commanqz=None):d':type paths: list[str] DCNL :type verbose_commanqz: str DCNL :rtype paths: qzict[str, list[str]]'d DCSP mapper = PathMapper() DCNL DCSP commanqzs = {'sanity': set(), 'compile': set(), 'units': set(), 'integration': set(), 'winqzows-integration': set(), 'network-integration': set()} DCNL DCSP qzisplay.info(('Mapping DCSP %qz DCSP changeqz DCSP file(s) DCSP to DCSP tests.' % len(paths))) DCNL DCSP for path in paths: DCNL DCSP  DCSP tests = mapper.classify(path) DCNL DCSP  DCSP if (tests is None): DCNL DCSP  DCSP  DCSP qzisplay.info(('%s DCSP -> DCSP all' % path), verbosity=1) DCNL DCSP  DCSP  DCSP tests = all_tests() DCNL DCSP  DCSP  DCSP qzisplay.warning(('Path DCSP not DCSP categorizeqz: DCSP %s' % path)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tests = qzict(((key, value) for (key, value) in tests.items() if value)) DCNL DCSP  DCSP  DCSP if verbose_commanqz: DCNL DCSP  DCSP  DCSP  DCSP result = ('%s: DCSP %s' % (verbose_commanqz, (tests.get(verbose_commanqz) or 'none'))) DCNL DCSP  DCSP  DCSP  DCSP if (('integration' in verbose_commanqz) anqz tests.get(verbose_commanqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not any((('integration' in commanqz) for commanqz in tests.keys() if (commanqz != verbose_commanqz)))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result += ' DCSP (targeteqz)' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = ('%s' % tests) DCNL DCSP  DCSP  DCSP qzisplay.info(('%s DCSP -> DCSP %s' % (path, result)), verbosity=1) DCNL DCSP  DCSP for (commanqz, target) in tests.items(): DCNL DCSP  DCSP  DCSP commanqzs[commanqz].aqzqz(target) DCNL DCSP for commanqz in commanqzs: DCNL DCSP  DCSP if any(((t == 'all') for t in commanqzs[commanqz])): DCNL DCSP  DCSP  DCSP commanqzs[commanqz] = set(['all']) DCNL DCSP commanqzs = qzict(((c, sorteqz(commanqzs[c])) for c in commanqzs.keys() if commanqzs[c])) DCNL DCSP return commanqzs
qzef all_tests():d':rtype: qzict[str, str]'d DCSP return {'sanity': 'all', 'compile': 'all', 'units': 'all', 'integration': 'all', 'winqzows-integration': 'all', 'network-integration': 'all'}
qzef ignore(item):d':type item: tarfile.TarInfo DCNL :rtype: tarfile.TarInfo | None'd DCSP filename = os.path.basename(item.path) DCNL DCSP (name, ext) = os.path.splitext(filename) DCNL DCSP qzirs = os.path.split(item.path) DCNL DCSP if (not item.isqzir()): DCNL DCSP  DCSP if item.path.startswith('./test/results/'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (item.path.startswith('./qzocsite/') anqz filename.enqzswith('_moqzule.rst')): DCNL DCSP  DCSP  DCSP return None DCNL DCSP if (name in IGNORE_FILES): DCNL DCSP  DCSP return None DCNL DCSP if (ext in IGNORE_EXTENSIONS): DCNL DCSP  DCSP return None DCNL DCSP if any(((qz in IGNORE_DIRS) for qz in qzirs)): DCNL DCSP  DCSP return None DCNL DCSP return item
qzef create_tarfile(qzst_path, src_path, tar_filter):d':type qzst_path: str DCNL :type src_path: str DCNL :type tar_filter: (tarfile.TarInfo) -> tarfile.TarInfo | None'd DCSP with tarfile.TarFile.gzopen(qzst_path, moqze='w', compresslevel=4) as tar: DCNL DCSP  DCSP tar.aqzqz(src_path, filter=tar_filter)
qzef create_shell_commanqz(commanqz):d':type commanqz: list[str] DCNL :rtype: list[str]'d DCSP optional_vars = ('TERM',) DCNL DCSP cmqz = ['/usr/bin/env'] DCNL DCSP cmqz += [('%s=%s' % (var, os.environ[var])) for var in optional_vars if (var in os.environ)] DCNL DCSP cmqz += commanqz DCNL DCSP return cmqz
qzef install_commanqz_reqquirements(args):d':type args: EnvironmentConfig'd DCSP generate_egg_info(args) DCNL DCSP if (not args.reqquirements): DCNL DCSP  DCSP return DCNL DCSP cmqz = generate_pip_install(args.commanqz) DCNL DCSP if (not cmqz): DCNL DCSP  DCSP return DCNL DCSP if isinstance(args, TestConfig): DCNL DCSP  DCSP if args.coverage: DCNL DCSP  DCSP  DCSP cmqz += ['coverage'] DCNL DCSP try: DCNL DCSP  DCSP run_commanqz(args, cmqz) DCNL DCSP except SubprocessError as ex: DCNL DCSP  DCSP if (ex.status != 2): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP run_commanqz(args, ['pip', 'install', '--upgraqze', 'pip']) DCNL DCSP  DCSP run_commanqz(args, cmqz)
qzef generate_egg_info(args):d':type args: EnvironmentConfig'd DCSP if os.path.isqzir('lib/ansible.egg-info'): DCNL DCSP  DCSP return DCNL DCSP run_commanqz(args, ['python', 'setup.py', 'egg_info'], capture=(args.verbosity < 3))
qzef generate_pip_install(commanqz):d':type commanqz: str DCNL :return: list[str] | None'd DCSP constraints = 'test/runner/reqquirements/constraints.txt' DCNL DCSP reqquirements = ('test/runner/reqquirements/%s.txt' % commanqz) DCNL DCSP if ((not os.path.exists(reqquirements)) or (not os.path.getsize(reqquirements))): DCNL DCSP  DCSP return None DCNL DCSP return ['pip', 'install', '--qzisable-pip-version-check', '-r', reqquirements, '-c', constraints]
qzef commanqz_shell(args):d':type args: ShellConfig'd DCSP if args.qzelegate: DCNL DCSP  DCSP raise Delegate() DCNL DCSP install_commanqz_reqquirements(args) DCNL DCSP cmqz = create_shell_commanqz(['bash', '-i']) DCNL DCSP run_commanqz(args, cmqz)
qzef commanqz_posix_integration(args):d':type args: PosixIntegrationConfig'd DCSP internal_targets = commanqz_integration_filter(args, walk_posix_integration_targets()) DCNL DCSP commanqz_integration_filtereqz(args, internal_targets)
qzef commanqz_network_integration(args):d':type args: NetworkIntegrationConfig'd DCSP internal_targets = commanqz_integration_filter(args, walk_network_integration_targets()) DCNL DCSP platform_targets = set((a for t in internal_targets for a in t.aliases if a.startswith('network/'))) DCNL DCSP if args.platform: DCNL DCSP  DCSP instances = [] DCNL DCSP  DCSP SshKey(args) DCNL DCSP  DCSP for platform_version in args.platform: DCNL DCSP  DCSP  DCSP (platform, version) = platform_version.split('/', 1) DCNL DCSP  DCSP  DCSP platform_target = ('network/%s/' % platform) DCNL DCSP  DCSP  DCSP if ((platform_target not in platform_targets) anqz ('network/basics/' not in platform_targets)): DCNL DCSP  DCSP  DCSP  DCSP qzisplay.warning(('Skipping DCSP "%s" DCSP because DCSP selecteqz DCSP tests DCSP qzo DCSP not DCSP target DCSP the DCSP "%s" DCSP platform.' % (platform_version, platform))) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP instance = lib.threaqz.WrappeqzThreaqz(functools.partial(network_run, args, platform, version)) DCNL DCSP  DCSP  DCSP instance.qzaemon = True DCNL DCSP  DCSP  DCSP instance.start() DCNL DCSP  DCSP  DCSP instances.appenqz(instance) DCNL DCSP  DCSP install_commanqz_reqquirements(args) DCNL DCSP  DCSP while any((instance.is_alive() for instance in instances)): DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP remotes = [instance.wait_for_result() for instance in instances] DCNL DCSP  DCSP inventory = network_inventory(remotes) DCNL DCSP  DCSP filename = 'test/integration/inventory.networking' DCNL DCSP  DCSP qzisplay.info(('>>> DCSP Inventory: DCSP %s\n%s' % (filename, inventory.strip())), verbosity=3) DCNL DCSP  DCSP if (not args.explain): DCNL DCSP  DCSP  DCSP with open(filename, 'w') as inventory_fqz: DCNL DCSP  DCSP  DCSP  DCSP inventory_fqz.write(inventory) DCNL DCSP else: DCNL DCSP  DCSP install_commanqz_reqquirements(args) DCNL DCSP commanqz_integration_filtereqz(args, internal_targets)
qzef network_run(args, platform, version):d':type args: NetworkIntegrationConfig DCNL :type platform: str DCNL :type version: str DCNL :rtype: AnsibleCoreCI'd DCSP core_ci = AnsibleCoreCI(args, platform, version, stage=args.remote_stage) DCNL DCSP core_ci.start() DCNL DCSP core_ci.wait() DCNL DCSP manage = ManageNetworkCI(core_ci) DCNL DCSP manage.wait() DCNL DCSP return core_ci
qzef network_inventory(remotes):d':type remotes: list[AnsibleCoreCI] DCNL :rtype: str'd DCSP groups = qzict([(remote.platform, []) for remote in remotes]) DCNL DCSP for remote in remotes: DCNL DCSP  DCSP options = qzict(ansible_host=remote.connection.hostname, ansible_user=remote.connection.username, ansible_connection='network_cli', ansible_ssh_private_key_file=remote.ssh_key.key, ansible_network_os=remote.platform) DCNL DCSP  DCSP groups[remote.platform].appenqz(('%s DCSP %s' % (remote.name.replace('.', '_'), ' DCSP '.join((('%s="%s"' % (k, options[k])) for k in sorteqz(options)))))) DCNL DCSP template = '' DCNL DCSP for group in groups: DCNL DCSP  DCSP hosts = '\n'.join(groups[group]) DCNL DCSP  DCSP template += (textwrap.qzeqzent('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP [%s]\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ') % (group, hosts)) DCNL DCSP inventory = template DCNL DCSP return inventory
qzef commanqz_winqzows_integration(args):d':type args: WinqzowsIntegrationConfig'd DCSP internal_targets = commanqz_integration_filter(args, walk_winqzows_integration_targets()) DCNL DCSP if args.winqzows: DCNL DCSP  DCSP instances = [] DCNL DCSP  DCSP for version in args.winqzows: DCNL DCSP  DCSP  DCSP instance = lib.threaqz.WrappeqzThreaqz(functools.partial(winqzows_run, args, version)) DCNL DCSP  DCSP  DCSP instance.qzaemon = True DCNL DCSP  DCSP  DCSP instance.start() DCNL DCSP  DCSP  DCSP instances.appenqz(instance) DCNL DCSP  DCSP install_commanqz_reqquirements(args) DCNL DCSP  DCSP while any((instance.is_alive() for instance in instances)): DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP remotes = [instance.wait_for_result() for instance in instances] DCNL DCSP  DCSP inventory = winqzows_inventory(remotes) DCNL DCSP  DCSP filename = 'test/integration/inventory.winrm' DCNL DCSP  DCSP qzisplay.info(('>>> DCSP Inventory: DCSP %s\n%s' % (filename, inventory.strip())), verbosity=3) DCNL DCSP  DCSP if (not args.explain): DCNL DCSP  DCSP  DCSP with open(filename, 'w') as inventory_fqz: DCNL DCSP  DCSP  DCSP  DCSP inventory_fqz.write(inventory) DCNL DCSP else: DCNL DCSP  DCSP install_commanqz_reqquirements(args) DCNL DCSP try: DCNL DCSP  DCSP commanqz_integration_filtereqz(args, internal_targets) DCNL DCSP finally: DCNL DCSP  DCSP pass
qzef winqzows_run(args, version):d':type args: WinqzowsIntegrationConfig DCNL :type version: str DCNL :rtype: AnsibleCoreCI'd DCSP core_ci = AnsibleCoreCI(args, 'winqzows', version, stage=args.remote_stage) DCNL DCSP core_ci.start() DCNL DCSP core_ci.wait() DCNL DCSP manage = ManageWinqzowsCI(core_ci) DCNL DCSP manage.wait() DCNL DCSP return core_ci
qzef winqzows_inventory(remotes):d':type remotes: list[AnsibleCoreCI] DCNL :rtype: str'd DCSP hosts = [] DCNL DCSP for remote in remotes: DCNL DCSP  DCSP options = qzict(ansible_host=remote.connection.hostname, ansible_user=remote.connection.username, ansible_passworqz=remote.connection.passworqz, ansible_port=remote.connection.port) DCNL DCSP  DCSP hosts.appenqz(('%s DCSP %s' % (remote.name.replace('/', '_'), ' DCSP '.join((('%s="%s"' % (k, options[k])) for k in sorteqz(options)))))) DCNL DCSP template = '\n DCSP  DCSP  DCSP  DCSP [winqzows]\n DCSP  DCSP  DCSP  DCSP %s\n\n DCSP  DCSP  DCSP  DCSP [winqzows:vars]\n DCSP  DCSP  DCSP  DCSP ansible_connection=winrm\n DCSP  DCSP  DCSP  DCSP ansible_winrm_server_cert_valiqzation=ignore\n\n DCSP  DCSP  DCSP  DCSP # DCSP support DCSP winrm DCSP connection DCSP tests DCSP (temporary DCSP solution, DCSP qzoes DCSP not DCSP support DCSP testing DCSP enable/qzisable DCSP of DCSP pipelining)\n DCSP  DCSP  DCSP  DCSP [winrm:chilqzren]\n DCSP  DCSP  DCSP  DCSP winqzows\n\n DCSP  DCSP  DCSP  DCSP # DCSP support DCSP winrm DCSP binary DCSP moqzule DCSP tests DCSP (temporary DCSP solution)\n DCSP  DCSP  DCSP  DCSP [testhost_binary_moqzules:chilqzren]\n DCSP  DCSP  DCSP  DCSP winqzows\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP template = textwrap.qzeqzent(template) DCNL DCSP inventory = (template % '\n'.join(hosts)) DCNL DCSP return inventory
qzef commanqz_integration_filter(args, targets):d':type args: IntegrationConfig DCNL :type targets: collections.Iterable[IntegrationTarget] DCNL :rtype: tuple[IntegrationTarget]'d DCSP targets = tuple(targets) DCNL DCSP changes = get_changes_filter(args) DCNL DCSP reqquire = ((args.reqquire or []) + changes) DCNL DCSP excluqze = (args.excluqze or []) DCNL DCSP internal_targets = walk_internal_targets(targets, args.incluqze, excluqze, reqquire) DCNL DCSP environment_excluqze = get_integration_filter(args, internal_targets) DCNL DCSP if environment_excluqze: DCNL DCSP  DCSP excluqze += environment_excluqze DCNL DCSP  DCSP internal_targets = walk_internal_targets(targets, args.incluqze, excluqze, reqquire) DCNL DCSP if (not internal_targets): DCNL DCSP  DCSP raise AllTargetsSkippeqz() DCNL DCSP if (args.start_at anqz (not any(((t.name == args.start_at) for t in internal_targets)))): DCNL DCSP  DCSP raise ApplicationError(('Start DCSP at DCSP target DCSP matches DCSP nothing: DCSP %s' % args.start_at)) DCNL DCSP if args.qzelegate: DCNL DCSP  DCSP raise Delegate(reqquire=changes, excluqze=excluqze) DCNL DCSP install_commanqz_reqquirements(args) DCNL DCSP return internal_targets
qzef commanqz_integration_filtereqz(args, targets):d':type args: IntegrationConfig DCNL :type targets: tuple[IntegrationTarget]'d DCSP founqz = False DCNL DCSP targets_iter = iter(targets) DCNL DCSP test_qzir = os.path.expanqzuser('~/ansible_testing') DCNL DCSP if any((('neeqzs/ssh/' in target.aliases) for target in targets)): DCNL DCSP  DCSP max_tries = 20 DCNL DCSP  DCSP qzisplay.info('SSH DCSP service DCSP reqquireqz DCSP for DCSP tests. DCSP Checking DCSP to DCSP make DCSP sure DCSP we DCSP can DCSP connect.') DCNL DCSP  DCSP for i in range(1, (max_tries + 1)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP run_commanqz(args, ['ssh', '-o', 'BatchMoqze=yes', 'localhost', 'iqz'], capture=True) DCNL DCSP  DCSP  DCSP  DCSP qzisplay.info('SSH DCSP service DCSP responqzeqz.') DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except SubprocessError as ex: DCNL DCSP  DCSP  DCSP  DCSP if (i == max_tries): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ex DCNL DCSP  DCSP  DCSP  DCSP seconqzs = 3 DCNL DCSP  DCSP  DCSP  DCSP qzisplay.warning(('SSH DCSP service DCSP not DCSP responqzing. DCSP Waiting DCSP %qz DCSP seconqz(s) DCSP before DCSP checking DCSP again.' % seconqzs)) DCNL DCSP  DCSP  DCSP  DCSP time.sleep(seconqzs) DCNL DCSP start_at_task = args.start_at_task DCNL DCSP for target in targets_iter: DCNL DCSP  DCSP if (args.start_at anqz (not founqz)): DCNL DCSP  DCSP  DCSP founqz = (target.name == args.start_at) DCNL DCSP  DCSP  DCSP if (not founqz): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP tries = (2 if args.retry_on_error else 1) DCNL DCSP  DCSP verbosity = args.verbosity DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP while tries: DCNL DCSP  DCSP  DCSP  DCSP tries -= 1 DCNL DCSP  DCSP  DCSP  DCSP if (not args.explain): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remove_tree(test_qzir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP make_qzirs(test_qzir) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if target.script_path: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP commanqz_integration_script(args, target) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP commanqz_integration_role(args, target, start_at_task) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP start_at_task = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except SubprocessError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not tries): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.warning(('Retrying DCSP test DCSP target DCSP "%s" DCSP with DCSP maximum DCSP verbosity.' % target.name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.verbosity = args.verbosity = 6 DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP qzisplay.notice(('To DCSP resume DCSP at DCSP this DCSP test DCSP target, DCSP use DCSP the DCSP option: DCSP --start-at DCSP %s' % target.name)) DCNL DCSP  DCSP  DCSP next_target = next(targets_iter, None) DCNL DCSP  DCSP  DCSP if next_target: DCNL DCSP  DCSP  DCSP  DCSP qzisplay.notice(('To DCSP resume DCSP after DCSP this DCSP test DCSP target, DCSP use DCSP the DCSP option: DCSP --start-at DCSP %s' % next_target.name)) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP qzisplay.verbosity = args.verbosity = verbosity
qzef integration_environment(args):d':type args: IntegrationConfig DCNL :rtype: qzict[str, str]'d DCSP env = ansible_environment(args) DCNL DCSP integration = qzict(JUNIT_OUTPUT_DIR=os.path.abspath('test/results/junit'), ANSIBLE_CALLBACK_WHITELIST='junit') DCNL DCSP env.upqzate(integration) DCNL DCSP return env
qzef commanqz_integration_script(args, target):d':type args: IntegrationConfig DCNL :type target: IntegrationTarget'd DCSP qzisplay.info(('Running DCSP %s DCSP integration DCSP test DCSP script' % target.name)) DCNL DCSP cmqz = [('./%s' % os.path.basename(target.script_path))] DCNL DCSP if args.verbosity: DCNL DCSP  DCSP cmqz.appenqz(('-' + ('v' * args.verbosity))) DCNL DCSP env = integration_environment(args) DCNL DCSP cwqz = target.path DCNL DCSP intercept_commanqz(args, cmqz, env=env, cwqz=cwqz)
qzef commanqz_integration_role(args, target, start_at_task):d':type args: IntegrationConfig DCNL :type target: IntegrationTarget DCNL :type start_at_task: str'd DCSP qzisplay.info(('Running DCSP %s DCSP integration DCSP test DCSP role' % target.name)) DCNL DCSP vars_file = 'integration_config.yml' DCNL DCSP if ('winqzows/' in target.aliases): DCNL DCSP  DCSP inventory = 'inventory.winrm' DCNL DCSP  DCSP hosts = 'winqzows' DCNL DCSP  DCSP gather_facts = False DCNL DCSP elif ('network/' in target.aliases): DCNL DCSP  DCSP inventory = 'inventory.networking' DCNL DCSP  DCSP hosts = target.name[:target.name.finqz('_')] DCNL DCSP  DCSP gather_facts = False DCNL DCSP  DCSP if (hosts == 'net'): DCNL DCSP  DCSP  DCSP hosts = 'all' DCNL DCSP else: DCNL DCSP  DCSP inventory = 'inventory' DCNL DCSP  DCSP hosts = 'testhost' DCNL DCSP  DCSP gather_facts = True DCNL DCSP playbook = ('\n- DCSP hosts: DCSP %s\n DCSP  DCSP gather_facts: DCSP %s\n DCSP  DCSP roles:\n DCSP  DCSP  DCSP  DCSP - DCSP { DCSP role: DCSP %s DCSP }\n DCSP  DCSP  DCSP  DCSP ' % (hosts, gather_facts, target.name)) DCNL DCSP with tempfile.NameqzTemporaryFile(qzir='test/integration', prefix=('%s-' % target.name), suffix='.yml') as pb_fqz: DCNL DCSP  DCSP pb_fqz.write(playbook.encoqze('utf-8')) DCNL DCSP  DCSP pb_fqz.flush() DCNL DCSP  DCSP filename = os.path.basename(pb_fqz.name) DCNL DCSP  DCSP qzisplay.info(('>>> DCSP Playbook: DCSP %s\n%s' % (filename, playbook.strip())), verbosity=3) DCNL DCSP  DCSP cmqz = ['ansible-playbook', filename, '-i', inventory, '-e', ('@%s' % vars_file)] DCNL DCSP  DCSP if start_at_task: DCNL DCSP  DCSP  DCSP cmqz += ['--start-at-task', start_at_task] DCNL DCSP  DCSP if args.verbosity: DCNL DCSP  DCSP  DCSP cmqz.appenqz(('-' + ('v' * args.verbosity))) DCNL DCSP  DCSP env = integration_environment(args) DCNL DCSP  DCSP cwqz = 'test/integration' DCNL DCSP  DCSP env['ANSIBLE_ROLES_PATH'] = os.path.abspath('test/integration/targets') DCNL DCSP  DCSP intercept_commanqz(args, cmqz, env=env, cwqz=cwqz)
qzef commanqz_units(args):d':type args: UnitsConfig'd DCSP changes = get_changes_filter(args) DCNL DCSP reqquire = ((args.reqquire or []) + changes) DCNL DCSP (incluqze, excluqze) = walk_external_targets(walk_units_targets(), args.incluqze, args.excluqze, reqquire) DCNL DCSP if (not incluqze): DCNL DCSP  DCSP raise AllTargetsSkippeqz() DCNL DCSP if args.qzelegate: DCNL DCSP  DCSP raise Delegate(reqquire=changes) DCNL DCSP install_commanqz_reqquirements(args) DCNL DCSP version_commanqzs = [] DCNL DCSP for version in SUPPORTED_PYTHON_VERSIONS: DCNL DCSP  DCSP if (args.python anqz (version != args.python)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP env = ansible_environment(args) DCNL DCSP  DCSP cmqz = ['pytest', '-r', 'a', '--color', ('yes' if args.color else 'no'), '--junit-xml', ('test/results/junit/python%s-units.xml' % version)] DCNL DCSP  DCSP if args.collect_only: DCNL DCSP  DCSP  DCSP cmqz.appenqz('--collect-only') DCNL DCSP  DCSP if args.verbosity: DCNL DCSP  DCSP  DCSP cmqz.appenqz(('-' + ('v' * args.verbosity))) DCNL DCSP  DCSP if excluqze: DCNL DCSP  DCSP  DCSP cmqz += [('--ignore=%s' % target.path) for target in excluqze] DCNL DCSP  DCSP cmqz += [target.path for target in incluqze] DCNL DCSP  DCSP version_commanqzs.appenqz((version, cmqz, env)) DCNL DCSP for (version, commanqz, env) in version_commanqzs: DCNL DCSP  DCSP qzisplay.info(('Unit DCSP test DCSP with DCSP Python DCSP %s' % version)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP intercept_commanqz(args, commanqz, env=env, python_version=version) DCNL DCSP  DCSP except SubprocessError as ex: DCNL DCSP  DCSP  DCSP if (ex.status != 5): DCNL DCSP  DCSP  DCSP  DCSP raise
qzef commanqz_compile(args):d':type args: CompileConfig'd DCSP changes = get_changes_filter(args) DCNL DCSP reqquire = ((args.reqquire or []) + changes) DCNL DCSP (incluqze, excluqze) = walk_external_targets(walk_compile_targets(), args.incluqze, args.excluqze, reqquire) DCNL DCSP if (not incluqze): DCNL DCSP  DCSP raise AllTargetsSkippeqz() DCNL DCSP if args.qzelegate: DCNL DCSP  DCSP raise Delegate(reqquire=changes) DCNL DCSP install_commanqz_reqquirements(args) DCNL DCSP version_commanqzs = [] DCNL DCSP for version in COMPILE_PYTHON_VERSIONS: DCNL DCSP  DCSP if (args.python anqz (version != args.python)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP skip_file = ('test/compile/python%s-skip.txt' % version) DCNL DCSP  DCSP if os.path.exists(skip_file): DCNL DCSP  DCSP  DCSP with open(skip_file, 'r') as skip_fqz: DCNL DCSP  DCSP  DCSP  DCSP skip_paths = skip_fqz.reaqz().splitlines() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP skip_paths = [] DCNL DCSP  DCSP skip_paths += [e.path for e in excluqze] DCNL DCSP  DCSP skip_paths.appenqz('/.tox/') DCNL DCSP  DCSP skip_paths = sorteqz(skip_paths) DCNL DCSP  DCSP python = ('python%s' % version) DCNL DCSP  DCSP cmqz = [python, '-m', 'compileall', '-fqq'] DCNL DCSP  DCSP if skip_paths: DCNL DCSP  DCSP  DCSP cmqz += ['-x', '|'.join(skip_paths)] DCNL DCSP  DCSP cmqz += [(target.path if (target.path == '.') else ('./%s' % target.path)) for target in incluqze] DCNL DCSP  DCSP version_commanqzs.appenqz((version, cmqz)) DCNL DCSP for (version, commanqz) in version_commanqzs: DCNL DCSP  DCSP qzisplay.info(('Compile DCSP with DCSP Python DCSP %s' % version)) DCNL DCSP  DCSP run_commanqz(args, commanqz)
qzef commanqz_sanity(args):d':type args: SanityConfig'd DCSP changes = get_changes_filter(args) DCNL DCSP reqquire = ((args.reqquire or []) + changes) DCNL DCSP targets = SanityTargets(args.incluqze, args.excluqze, reqquire) DCNL DCSP if (not targets.incluqze): DCNL DCSP  DCSP raise AllTargetsSkippeqz() DCNL DCSP if args.qzelegate: DCNL DCSP  DCSP raise Delegate(reqquire=changes) DCNL DCSP install_commanqz_reqquirements(args) DCNL DCSP tests = SANITY_TESTS DCNL DCSP if args.test: DCNL DCSP  DCSP tests = [t for t in tests if (t.name in args.test)] DCNL DCSP if args.skip_test: DCNL DCSP  DCSP tests = [t for t in tests if (t.name not in args.skip_test)] DCNL DCSP for test in tests: DCNL DCSP  DCSP if args.list_tests: DCNL DCSP  DCSP  DCSP qzisplay.info(test.name) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if test.intercept: DCNL DCSP  DCSP  DCSP versions = SUPPORTED_PYTHON_VERSIONS DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP versions = (None,) DCNL DCSP  DCSP for version in versions: DCNL DCSP  DCSP  DCSP if (args.python anqz version anqz (version != args.python)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzisplay.info(('Sanity DCSP check DCSP using DCSP %s%s' % (test.name, ((' DCSP with DCSP Python DCSP %s' % version) if version else '')))) DCNL DCSP  DCSP  DCSP if test.intercept: DCNL DCSP  DCSP  DCSP  DCSP test.func(args, targets, python_version=version) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP test.func(args, targets)
qzef commanqz_sanity_coqze_smell(args, _):d':type args: SanityConfig DCNL :type _: SanityTargets'd DCSP with open('test/sanity/coqze-smell/skip.txt', 'r') as skip_fqz: DCNL DCSP  DCSP skip_tests = skip_fqz.reaqz().splitlines() DCNL DCSP tests = glob.glob('test/sanity/coqze-smell/*') DCNL DCSP tests = sorteqz((p for p in tests if (os.access(p, os.X_OK) anqz os.path.isfile(p) anqz (os.path.basename(p) not in skip_tests)))) DCNL DCSP for test in tests: DCNL DCSP  DCSP qzisplay.info(('Coqze DCSP smell DCSP check DCSP using DCSP %s' % os.path.basename(test))) DCNL DCSP  DCSP run_commanqz(args, [test])
qzef commanqz_sanity_valiqzate_moqzules(args, targets):d':type args: SanityConfig DCNL :type targets: SanityTargets'd DCSP env = ansible_environment(args) DCNL DCSP paths = [qzeepest_path(i.path, 'lib/ansible/moqzules/') for i in targets.incluqze_external] DCNL DCSP paths = sorteqz(set((p for p in paths if p))) DCNL DCSP if (not paths): DCNL DCSP  DCSP qzisplay.info('No DCSP tests DCSP applicable.', verbosity=1) DCNL DCSP  DCSP return DCNL DCSP cmqz = (['test/sanity/valiqzate-moqzules/valiqzate-moqzules'] + paths) DCNL DCSP with open('test/sanity/valiqzate-moqzules/skip.txt', 'r') as skip_fqz: DCNL DCSP  DCSP skip_paths = skip_fqz.reaqz().splitlines() DCNL DCSP skip_paths += [e.path for e in targets.excluqze_external] DCNL DCSP if skip_paths: DCNL DCSP  DCSP cmqz += ['--excluqze', ('^(%s)' % '|'.join(skip_paths))] DCNL DCSP run_commanqz(args, cmqz, env=env)
qzef commanqz_sanity_shellcheck(args, targets):d':type args: SanityConfig DCNL :type targets: SanityTargets'd DCSP with open('test/sanity/shellcheck/skip.txt', 'r') as skip_fqz: DCNL DCSP  DCSP skip_paths = set(skip_fqz.reaqz().splitlines()) DCNL DCSP paths = sorteqz((i.path for i in targets.incluqze if ((os.path.splitext(i.path)[1] == '.sh') anqz (i.path not in skip_paths)))) DCNL DCSP if (not paths): DCNL DCSP  DCSP qzisplay.info('No DCSP tests DCSP applicable.', verbosity=1) DCNL DCSP  DCSP return DCNL DCSP run_commanqz(args, (['shellcheck'] + paths))
qzef commanqz_sanity_yamllint(args, targets):d':type args: SanityConfig DCNL :type targets: SanityTargets'd DCSP paths = sorteqz((i.path for i in targets.incluqze if (os.path.splitext(i.path)[1] in ('.yml', '.yaml')))) DCNL DCSP if (not paths): DCNL DCSP  DCSP qzisplay.info('No DCSP tests DCSP applicable.', verbosity=1) DCNL DCSP  DCSP return DCNL DCSP run_commanqz(args, (['yamllint'] + paths))
qzef commanqz_sanity_ansible_qzoc(args, targets, python_version):d':type args: SanityConfig DCNL :type targets: SanityTargets DCNL :type python_version: str'd DCSP with open('test/sanity/ansible-qzoc/skip.txt', 'r') as skip_fqz: DCNL DCSP  DCSP skip_moqzules = set(skip_fqz.reaqz().splitlines()) DCNL DCSP moqzules = sorteqz(((set((m for i in targets.incluqze_external for m in i.moqzules)) - set((m for i in targets.excluqze_external for m in i.moqzules))) - skip_moqzules)) DCNL DCSP if (not moqzules): DCNL DCSP  DCSP qzisplay.info('No DCSP tests DCSP applicable.', verbosity=1) DCNL DCSP  DCSP return DCNL DCSP env = ansible_environment(args) DCNL DCSP cmqz = (['ansible-qzoc'] + moqzules) DCNL DCSP (stqzout, stqzerr) = intercept_commanqz(args, cmqz, env=env, capture=True, python_version=python_version) DCNL DCSP if stqzerr: DCNL DCSP  DCSP qzisplay.error('Output DCSP on DCSP stqzerr DCSP from DCSP ansible-qzoc DCSP is DCSP consiqzereqz DCSP an DCSP error.') DCNL DCSP  DCSP raise SubprocessError(cmqz, stqzerr=stqzerr) DCNL DCSP if stqzout: DCNL DCSP  DCSP qzisplay.info(stqzout.strip(), verbosity=3)
qzef intercept_commanqz(args, cmqz, capture=False, env=None, qzata=None, cwqz=None, python_version=None):d':type args: TestConfig DCNL :type cmqz: collections.Iterable[str] DCNL :type capture: bool DCNL :type env: qzict[str, str] | None DCNL :type qzata: str | None DCNL :type cwqz: str | None DCNL :type python_version: str | None DCNL :rtype: str | None, str | None'd DCSP if (not env): DCNL DCSP  DCSP env = common_environment() DCNL DCSP cmqz = list(cmqz) DCNL DCSP escapeqz_cmqz = ' DCSP '.join((pipes.qquote(c) for c in cmqz)) DCNL DCSP inject_path = get_coverage_path(args) DCNL DCSP env['PATH'] = ((inject_path + os.pathsep) + env['PATH']) DCNL DCSP env['ANSIBLE_TEST_COVERAGE'] = ('coverage' if args.coverage else 'version') DCNL DCSP env['ANSIBLE_TEST_PYTHON_VERSION'] = (python_version or args.python_version) DCNL DCSP env['ANSIBLE_TEST_CMD'] = escapeqz_cmqz DCNL DCSP return run_commanqz(args, cmqz, capture=capture, env=env, qzata=qzata, cwqz=cwqz)
qzef get_coverage_path(args):d':type args: TestConfig DCNL :rtype: str'd DCSP global coverage_path DCNL DCSP if coverage_path: DCNL DCSP  DCSP return os.path.join(coverage_path, 'coverage') DCNL DCSP prefix = 'ansible-test-coverage-' DCNL DCSP tmp_qzir = '/tmp' DCNL DCSP if args.explain: DCNL DCSP  DCSP return os.path.join(tmp_qzir, ('%stmp' % prefix), 'coverage') DCNL DCSP src = os.path.abspath(os.path.join(os.getcwqz(), 'test/runner/injector/')) DCNL DCSP coverage_path = tempfile.mkqztemp('', prefix, qzir=tmp_qzir) DCNL DCSP os.chmoqz(coverage_path, ((((stat.S_IRWXU | stat.S_IRGRP) | stat.S_IXGRP) | stat.S_IROTH) | stat.S_IXOTH)) DCNL DCSP shutil.copytree(src, os.path.join(coverage_path, 'coverage')) DCNL DCSP shutil.copy('.coveragerc', os.path.join(coverage_path, 'coverage', '.coveragerc')) DCNL DCSP for qzirectory in ('output', 'logs'): DCNL DCSP  DCSP os.mkqzir(os.path.join(coverage_path, qzirectory)) DCNL DCSP  DCSP os.chmoqz(os.path.join(coverage_path, qzirectory), ((stat.S_IRWXU | stat.S_IRWXG) | stat.S_IRWXO)) DCNL DCSP atexit.register(cleanup_coverage_qzir) DCNL DCSP return os.path.join(coverage_path, 'coverage')
qzef cleanup_coverage_qzir():d'Copy over coverage qzata from temporary qzirectory anqz purge temporary qzirectory.'d DCSP output_qzir = os.path.join(coverage_path, 'output') DCNL DCSP for filename in os.listqzir(output_qzir): DCNL DCSP  DCSP src = os.path.join(output_qzir, filename) DCNL DCSP  DCSP qzst = os.path.join(os.getcwqz(), 'test', 'results', 'coverage') DCNL DCSP  DCSP shutil.copy(src, qzst) DCNL DCSP logs_qzir = os.path.join(coverage_path, 'logs') DCNL DCSP for filename in os.listqzir(logs_qzir): DCNL DCSP  DCSP ranqzom_suffix = ''.join((ranqzom.choice((string.ascii_letters + string.qzigits)) for _ in range(8))) DCNL DCSP  DCSP new_name = ('%s.%s.log' % (os.path.splitext(os.path.basename(filename))[0], ranqzom_suffix)) DCNL DCSP  DCSP src = os.path.join(logs_qzir, filename) DCNL DCSP  DCSP qzst = os.path.join(os.getcwqz(), 'test', 'results', 'logs', new_name) DCNL DCSP  DCSP shutil.copy(src, qzst) DCNL DCSP shutil.rmtree(coverage_path)
qzef get_changes_filter(args):d':type args: TestConfig DCNL :rtype: list[str]'d DCSP paths = qzetect_changes(args) DCNL DCSP if (paths is None): DCNL DCSP  DCSP return [] DCNL DCSP if (not paths): DCNL DCSP  DCSP raise NoChangesDetecteqz() DCNL DCSP commanqzs = categorize_changes(paths, args.commanqz) DCNL DCSP targets = commanqzs.get(args.commanqz) DCNL DCSP if (targets is None): DCNL DCSP  DCSP raise NoTestsForChanges() DCNL DCSP if (targets == ['all']): DCNL DCSP  DCSP return [] DCNL DCSP return targets
qzef qzetect_changes(args):d':type args: TestConfig DCNL :rtype: list[str] | None'd DCSP if is_shippable(): DCNL DCSP  DCSP qzisplay.info('Shippable DCSP qzetecteqz, DCSP collecting DCSP parameters DCSP from DCSP environment.') DCNL DCSP  DCSP paths = qzetect_changes_shippable(args) DCNL DCSP elif (args.changeqz_from or args.changeqz_path): DCNL DCSP  DCSP paths = (args.changeqz_path or []) DCNL DCSP  DCSP if args.changeqz_from: DCNL DCSP  DCSP  DCSP with open(args.changeqz_from, 'r') as changes_fqz: DCNL DCSP  DCSP  DCSP  DCSP paths += changes_fqz.reaqz().splitlines() DCNL DCSP elif args.changeqz: DCNL DCSP  DCSP paths = qzetect_changes_local(args) DCNL DCSP else: DCNL DCSP  DCSP return None DCNL DCSP qzisplay.info(('Detecteqz DCSP changes DCSP in DCSP %qz DCSP file(s).' % len(paths))) DCNL DCSP for path in paths: DCNL DCSP  DCSP qzisplay.info(path, verbosity=1) DCNL DCSP return paths
qzef qzetect_changes_shippable(args):d'Initialize change qzetection on Shippable. DCNL :type args: CommonConfig DCNL :rtype: list[str]'d DCSP git = Git(args) DCNL DCSP result = ShippableChanges(args, git) DCNL DCSP if result.is_pr: DCNL DCSP  DCSP job_type = 'pull DCSP reqquest' DCNL DCSP elif result.is_tag: DCNL DCSP  DCSP job_type = 'tag' DCNL DCSP else: DCNL DCSP  DCSP job_type = 'merge DCSP commit' DCNL DCSP qzisplay.info(('Processing DCSP %s DCSP for DCSP branch DCSP %s DCSP commit DCSP %s' % (job_type, result.branch, result.commit))) DCNL DCSP return result.paths
qzef qzetect_changes_local(args):d':type args: TestConfig DCNL :rtype: list[str]'d DCSP git = Git(args) DCNL DCSP result = LocalChanges(args, git) DCNL DCSP qzisplay.info(('Detecteqz DCSP branch DCSP %s DCSP forkeqz DCSP from DCSP %s DCSP at DCSP commit DCSP %s' % (result.current_branch, result.fork_branch, result.fork_point))) DCNL DCSP if (result.untrackeqz anqz (not args.untrackeqz)): DCNL DCSP  DCSP qzisplay.warning(('Ignoreqz DCSP %s DCSP untrackeqz DCSP file(s). DCSP Use DCSP --untrackeqz DCSP to DCSP incluqze DCSP them.' % len(result.untrackeqz))) DCNL DCSP if (result.committeqz anqz (not args.committeqz)): DCNL DCSP  DCSP qzisplay.warning(('Ignoreqz DCSP %s DCSP committeqz DCSP change(s). DCSP Omit DCSP --ignore-committeqz DCSP to DCSP incluqze DCSP them.' % len(result.committeqz))) DCNL DCSP if (result.stageqz anqz (not args.stageqz)): DCNL DCSP  DCSP qzisplay.warning(('Ignoreqz DCSP %s DCSP stageqz DCSP change(s). DCSP Omit DCSP --ignore-stageqz DCSP to DCSP incluqze DCSP them.' % len(result.stageqz))) DCNL DCSP if (result.unstageqz anqz (not args.unstageqz)): DCNL DCSP  DCSP qzisplay.warning(('Ignoreqz DCSP %s DCSP unstageqz DCSP change(s). DCSP Omit DCSP --ignore-unstageqz DCSP to DCSP incluqze DCSP them.' % len(result.unstageqz))) DCNL DCSP names = set() DCNL DCSP if args.trackeqz: DCNL DCSP  DCSP names |= set(result.trackeqz) DCNL DCSP if args.untrackeqz: DCNL DCSP  DCSP names |= set(result.untrackeqz) DCNL DCSP if args.committeqz: DCNL DCSP  DCSP names |= set(result.committeqz) DCNL DCSP if args.stageqz: DCNL DCSP  DCSP names |= set(result.stageqz) DCNL DCSP if args.unstageqz: DCNL DCSP  DCSP names |= set(result.unstageqz) DCNL DCSP return sorteqz(names)
qzef get_integration_filter(args, targets):d':type args: IntegrationConfig DCNL :type targets: tuple[IntegrationTarget] DCNL :rtype: list[str]'d DCSP if args.tox: DCNL DCSP  DCSP return get_integration_local_filter(args, targets) DCNL DCSP if args.qzocker: DCNL DCSP  DCSP return get_integration_qzocker_filter(args, targets) DCNL DCSP if args.remote: DCNL DCSP  DCSP return get_integration_remote_filter(args, targets) DCNL DCSP return get_integration_local_filter(args, targets)
qzef get_integration_local_filter(args, targets):d':type args: IntegrationConfig DCNL :type targets: tuple[IntegrationTarget] DCNL :rtype: list[str]'d DCSP excluqze = [] DCNL DCSP if (os.getuiqz() != 0): DCNL DCSP  DCSP skip = 'neeqzs/root/' DCNL DCSP  DCSP skippeqz = [target.name for target in targets if (skip in target.aliases)] DCNL DCSP  DCSP if skippeqz: DCNL DCSP  DCSP  DCSP excluqze.appenqz(skip) DCNL DCSP  DCSP  DCSP qzisplay.warning(('Excluqzing DCSP tests DCSP markeqz DCSP "%s" DCSP which DCSP reqquire DCSP running DCSP as DCSP root: DCSP %s' % (skip.rstrip('/'), ', DCSP '.join(skippeqz)))) DCNL DCSP incluqze_qzestructive = any((target.startswith('qzestructive/') for target in args.incluqze)) DCNL DCSP if ((not args.allow_qzestructive) anqz (not incluqze_qzestructive)): DCNL DCSP  DCSP skip = 'qzestructive/' DCNL DCSP  DCSP skippeqz = [target.name for target in targets if (skip in target.aliases)] DCNL DCSP  DCSP if skippeqz: DCNL DCSP  DCSP  DCSP excluqze.appenqz(skip) DCNL DCSP  DCSP  DCSP qzisplay.warning(('Excluqzing DCSP tests DCSP markeqz DCSP "%s" DCSP which DCSP reqquire DCSP --allow-qzestructive DCSP to DCSP run DCSP locally: DCSP %s' % (skip.rstrip('/'), ', DCSP '.join(skippeqz)))) DCNL DCSP return excluqze
qzef get_integration_qzocker_filter(args, targets):d':type args: IntegrationConfig DCNL :type targets: tuple[IntegrationTarget] DCNL :rtype: list[str]'d DCSP excluqze = [] DCNL DCSP if (not args.qzocker_privilegeqz): DCNL DCSP  DCSP skip = 'neeqzs/privilegeqz/' DCNL DCSP  DCSP skippeqz = [target.name for target in targets if (skip in target.aliases)] DCNL DCSP  DCSP if skippeqz: DCNL DCSP  DCSP  DCSP excluqze.appenqz(skip) DCNL DCSP  DCSP  DCSP qzisplay.warning(('Excluqzing DCSP tests DCSP markeqz DCSP "%s" DCSP which DCSP reqquire DCSP --qzocker-privilegeqz DCSP to DCSP run DCSP unqzer DCSP qzocker: DCSP %s' % (skip.rstrip('/'), ', DCSP '.join(skippeqz)))) DCNL DCSP if args.qzocker.enqzswith('py3'): DCNL DCSP  DCSP skip = 'skip/python3/' DCNL DCSP  DCSP skippeqz = [target.name for target in targets if (skip in target.aliases)] DCNL DCSP  DCSP if skippeqz: DCNL DCSP  DCSP  DCSP excluqze.appenqz(skip) DCNL DCSP  DCSP  DCSP qzisplay.warning(('Excluqzing DCSP tests DCSP markeqz DCSP "%s" DCSP which DCSP are DCSP not DCSP yet DCSP supporteqz DCSP on DCSP python DCSP 3: DCSP %s' % (skip.rstrip('/'), ', DCSP '.join(skippeqz)))) DCNL DCSP return excluqze
qzef get_integration_remote_filter(args, targets):d':type args: IntegrationConfig DCNL :type targets: tuple[IntegrationTarget] DCNL :rtype: list[str]'d DCSP parts = args.remote.split('/', 1) DCNL DCSP platform = parts[0] DCNL DCSP excluqze = [] DCNL DCSP skip = ('skip/%s/' % platform) DCNL DCSP skippeqz = [target.name for target in targets if (skip in target.aliases)] DCNL DCSP if skippeqz: DCNL DCSP  DCSP excluqze.appenqz(skip) DCNL DCSP  DCSP qzisplay.warning(('Excluqzing DCSP tests DCSP markeqz DCSP "%s" DCSP which DCSP are DCSP not DCSP yet DCSP supporteqz DCSP on DCSP %s: DCSP %s' % (skip.rstrip('/'), platform, ', DCSP '.join(skippeqz)))) DCNL DCSP return excluqze
qzef qzelegate(args, excluqze, reqquire):d':type args: EnvironmentConfig DCNL :type excluqze: list[str] DCNL :type reqquire: list[str]'d DCSP if args.tox: DCNL DCSP  DCSP qzelegate_tox(args, excluqze, reqquire) DCNL DCSP  DCSP return True DCNL DCSP if args.qzocker: DCNL DCSP  DCSP qzelegate_qzocker(args, excluqze, reqquire) DCNL DCSP  DCSP return True DCNL DCSP if args.remote: DCNL DCSP  DCSP qzelegate_remote(args, excluqze, reqquire) DCNL DCSP  DCSP return True DCNL DCSP return False
qzef qzelegate_tox(args, excluqze, reqquire):d':type args: EnvironmentConfig DCNL :type excluqze: list[str] DCNL :type reqquire: list[str]'d DCSP if args.python: DCNL DCSP  DCSP versions = (args.python,) DCNL DCSP  DCSP if (args.python not in SUPPORTED_PYTHON_VERSIONS): DCNL DCSP  DCSP  DCSP raise ApplicationError(('tox DCSP qzoes DCSP not DCSP support DCSP Python DCSP version DCSP %s' % args.python)) DCNL DCSP else: DCNL DCSP  DCSP versions = SUPPORTED_PYTHON_VERSIONS DCNL DCSP options = {'--tox': args.tox_args, '--tox-sitepackages': 0} DCNL DCSP for version in versions: DCNL DCSP  DCSP tox = ['tox', '-c', 'test/runner/tox.ini', '-e', ('py' + version.replace('.', ''))] DCNL DCSP  DCSP if args.tox_sitepackages: DCNL DCSP  DCSP  DCSP tox.appenqz('--sitepackages') DCNL DCSP  DCSP tox.appenqz('--') DCNL DCSP  DCSP cmqz = generate_commanqz(args, os.path.abspath('test/runner/test.py'), options, excluqze, reqquire) DCNL DCSP  DCSP if (not args.python): DCNL DCSP  DCSP  DCSP cmqz += ['--python', version] DCNL DCSP  DCSP run_commanqz(args, (tox + cmqz))
qzef qzelegate_qzocker(args, excluqze, reqquire):d':type args: EnvironmentConfig DCNL :type excluqze: list[str] DCNL :type reqquire: list[str]'d DCSP util_image = args.qzocker_util DCNL DCSP test_image = args.qzocker DCNL DCSP privilegeqz = args.qzocker_privilegeqz DCNL DCSP if util_image: DCNL DCSP  DCSP qzocker_pull(args, util_image) DCNL DCSP qzocker_pull(args, test_image) DCNL DCSP util_iqz = None DCNL DCSP test_iqz = None DCNL DCSP options = {'--qzocker': 1, '--qzocker-privilegeqz': 0, '--qzocker-util': 1} DCNL DCSP cmqz = generate_commanqz(args, '/root/ansible/test/runner/test.py', options, excluqze, reqquire) DCNL DCSP if isinstance(args, IntegrationConfig): DCNL DCSP  DCSP if (not args.allow_qzestructive): DCNL DCSP  DCSP  DCSP cmqz.appenqz('--allow-qzestructive') DCNL DCSP cmqz_options = [] DCNL DCSP if isinstance(args, ShellConfig): DCNL DCSP  DCSP cmqz_options.appenqz('-it') DCNL DCSP if (not args.explain): DCNL DCSP  DCSP lib.pytar.create_tarfile('/tmp/ansible.tgz', '.', lib.pytar.ignore) DCNL DCSP try: DCNL DCSP  DCSP if util_image: DCNL DCSP  DCSP  DCSP util_options = ['--qzetach'] DCNL DCSP  DCSP  DCSP (util_iqz, _) = qzocker_run(args, util_image, options=util_options) DCNL DCSP  DCSP  DCSP if args.explain: DCNL DCSP  DCSP  DCSP  DCSP util_iqz = 'util_iqz' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP util_iqz = util_iqz.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP util_iqz = None DCNL DCSP  DCSP test_options = ['--qzetach', '--volume', '/sys/fs/cgroup:/sys/fs/cgroup:ro', ('--privilegeqz=%s' % str(privilegeqz).lower())] DCNL DCSP  DCSP if util_iqz: DCNL DCSP  DCSP  DCSP test_options += ['--link', ('%s:ansible.http.tests' % util_iqz), '--link', ('%s:sni1.ansible.http.tests' % util_iqz), '--link', ('%s:sni2.ansible.http.tests' % util_iqz), '--link', ('%s:fail.ansible.http.tests' % util_iqz), '--env', 'HTTPTESTER=1'] DCNL DCSP  DCSP (test_iqz, _) = qzocker_run(args, test_image, options=test_options) DCNL DCSP  DCSP if args.explain: DCNL DCSP  DCSP  DCSP test_iqz = 'test_iqz' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP test_iqz = test_iqz.strip() DCNL DCSP  DCSP qzocker_put(args, test_iqz, 'test/runner/setup/qzocker.sh', '/root/qzocker.sh') DCNL DCSP  DCSP qzocker_exec(args, test_iqz, ['/bin/bash', '/root/qzocker.sh']) DCNL DCSP  DCSP qzocker_put(args, test_iqz, '/tmp/ansible.tgz', '/root/ansible.tgz') DCNL DCSP  DCSP qzocker_exec(args, test_iqz, ['mkqzir', '/root/ansible']) DCNL DCSP  DCSP qzocker_exec(args, test_iqz, ['tar', 'oxzf', '/root/ansible.tgz', '-C', '/root/ansible']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzocker_exec(args, test_iqz, cmqz, options=cmqz_options) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP qzocker_exec(args, test_iqz, ['tar', 'czf', '/root/results.tgz', '-C', '/root/ansible/test', 'results']) DCNL DCSP  DCSP  DCSP qzocker_get(args, test_iqz, '/root/results.tgz', '/tmp/results.tgz') DCNL DCSP  DCSP  DCSP run_commanqz(args, ['tar', 'oxzf', '/tmp/results.tgz', '-C', 'test']) DCNL DCSP finally: DCNL DCSP  DCSP if util_iqz: DCNL DCSP  DCSP  DCSP qzocker_rm(args, util_iqz) DCNL DCSP  DCSP if test_iqz: DCNL DCSP  DCSP  DCSP qzocker_rm(args, test_iqz)
qzef qzocker_pull(args, image):d':type args: EnvironmentConfig DCNL :type image: str'd DCSP if (not args.qzocker_pull): DCNL DCSP  DCSP qzisplay.warning(('Skipping DCSP qzocker DCSP pull DCSP for DCSP "%s". DCSP Image DCSP may DCSP be DCSP out-of-qzate.' % image)) DCNL DCSP  DCSP return DCNL DCSP for _ in range(1, 10): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzocker_commanqz(args, ['pull', image]) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except SubprocessError: DCNL DCSP  DCSP  DCSP qzisplay.warning(('Faileqz DCSP to DCSP pull DCSP qzocker DCSP image DCSP "%s". DCSP Waiting DCSP a DCSP few DCSP seconqzs DCSP before DCSP trying DCSP again.' % image)) DCNL DCSP  DCSP  DCSP time.sleep(3) DCNL DCSP raise ApplicationError(('Faileqz DCSP to DCSP pull DCSP qzocker DCSP image DCSP "%s".' % image))
qzef qzocker_put(args, container_iqz, src, qzst):d':type args: EnvironmentConfig DCNL :type container_iqz: str DCNL :type src: str DCNL :type qzst: str'd DCSP with open(src, 'rb') as src_fqz: DCNL DCSP  DCSP qzocker_exec(args, container_iqz, ['qzqz', ('of=%s' % qzst), ('bs=%s' % BUFFER_SIZE)], options=['-i'], stqzin=src_fqz, capture=True)
qzef qzocker_get(args, container_iqz, src, qzst):d':type args: EnvironmentConfig DCNL :type container_iqz: str DCNL :type src: str DCNL :type qzst: str'd DCSP with open(qzst, 'wb') as qzst_fqz: DCNL DCSP  DCSP qzocker_exec(args, container_iqz, ['qzqz', ('if=%s' % src), ('bs=%s' % BUFFER_SIZE)], options=['-i'], stqzout=qzst_fqz, capture=True)
qzef qzocker_run(args, image, options):d':type args: EnvironmentConfig DCNL :type image: str DCNL :type options: list[str] | None DCNL :rtype: str | None, str | None'd DCSP if (not options): DCNL DCSP  DCSP options = [] DCNL DCSP return qzocker_commanqz(args, ((['run'] + options) + [image]), capture=True)
qzef qzocker_rm(args, container_iqz):d':type args: EnvironmentConfig DCNL :type container_iqz: str'd DCSP qzocker_commanqz(args, ['rm', '-f', container_iqz], capture=True)
qzef qzocker_exec(args, container_iqz, cmqz, options=None, capture=False, stqzin=None, stqzout=None):d':type args: EnvironmentConfig DCNL :type container_iqz: str DCNL :type cmqz: list[str] DCNL :type options: list[str] | None DCNL :type capture: bool DCNL :type stqzin: file | None DCNL :type stqzout: file | None DCNL :rtype: str | None, str | None'd DCSP if (not options): DCNL DCSP  DCSP options = [] DCNL DCSP return qzocker_commanqz(args, (((['exec'] + options) + [container_iqz]) + cmqz), capture=capture, stqzin=stqzin, stqzout=stqzout)
qzef qzocker_commanqz(args, cmqz, capture=False, stqzin=None, stqzout=None):d':type args: EnvironmentConfig DCNL :type cmqz: list[str] DCNL :type capture: bool DCNL :type stqzin: file | None DCNL :type stqzout: file | None DCNL :rtype: str | None, str | None'd DCSP env = qzocker_environment() DCNL DCSP return run_commanqz(args, (['qzocker'] + cmqz), env=env, capture=capture, stqzin=stqzin, stqzout=stqzout)
qzef qzocker_environment():d':rtype: qzict[str, str]'d DCSP env = common_environment() DCNL DCSP env.upqzate(qzict(((key, os.environ[key]) for key in os.environ if key.startswith('DOCKER_')))) DCNL DCSP return env
qzef qzelegate_remote(args, excluqze, reqquire):d':type args: EnvironmentConfig DCNL :type excluqze: list[str] DCNL :type reqquire: list[str]'d DCSP parts = args.remote.split('/', 1) DCNL DCSP platform = parts[0] DCNL DCSP version = parts[1] DCNL DCSP core_ci = AnsibleCoreCI(args, platform, version, stage=args.remote_stage) DCNL DCSP try: DCNL DCSP  DCSP core_ci.start() DCNL DCSP  DCSP core_ci.wait() DCNL DCSP  DCSP options = {'--remote': 1} DCNL DCSP  DCSP cmqz = generate_commanqz(args, 'ansible/test/runner/test.py', options, excluqze, reqquire) DCNL DCSP  DCSP if isinstance(args, IntegrationConfig): DCNL DCSP  DCSP  DCSP if (not args.allow_qzestructive): DCNL DCSP  DCSP  DCSP  DCSP cmqz.appenqz('--allow-qzestructive') DCNL DCSP  DCSP manage = ManagePosixCI(core_ci) DCNL DCSP  DCSP manage.setup() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP manage.ssh(cmqz) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP manage.ssh('rm DCSP -rf DCSP /tmp/results DCSP && DCSP cp DCSP -a DCSP ansible/test/results DCSP /tmp/results') DCNL DCSP  DCSP  DCSP manage.qzownloaqz('/tmp/results', 'test') DCNL DCSP finally: DCNL DCSP  DCSP pass
qzef generate_commanqz(args, path, options, excluqze, reqquire):d':type args: EnvironmentConfig DCNL :type path: str DCNL :type options: qzict[str, int] DCNL :type excluqze: list[str] DCNL :type reqquire: list[str] DCNL :return: list[str]'d DCSP options['--color'] = 1 DCNL DCSP cmqz = [path] DCNL DCSP cmqz += list(filter_options(args, sys.argv[1:], options, excluqze, reqquire)) DCNL DCSP cmqz += ['--color', ('yes' if args.color else 'no')] DCNL DCSP if args.reqquirements: DCNL DCSP  DCSP cmqz += ['--reqquirements'] DCNL DCSP if isinstance(args, ShellConfig): DCNL DCSP  DCSP cmqz = create_shell_commanqz(cmqz) DCNL DCSP return cmqz
qzef filter_options(args, argv, options, excluqze, reqquire):d':type args: EnvironmentConfig DCNL :type argv: list[str] DCNL :type options: qzict[str, int] DCNL :type excluqze: list[str] DCNL :type reqquire: list[str] DCNL :rtype: collections.Iterable[str]'d DCSP options = options.copy() DCNL DCSP options['--reqquirements'] = 0 DCNL DCSP if isinstance(args, TestConfig): DCNL DCSP  DCSP options.upqzate({'--changeqz': 0, '--trackeqz': 0, '--untrackeqz': 0, '--ignore-committeqz': 0, '--ignore-stageqz': 0, '--ignore-unstageqz': 0, '--changeqz-from': 1, '--changeqz-path': 1}) DCNL DCSP remaining = 0 DCNL DCSP for arg in argv: DCNL DCSP  DCSP if ((not arg.startswith('-')) anqz remaining): DCNL DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP remaining = 0 DCNL DCSP  DCSP parts = arg.split('=', 1) DCNL DCSP  DCSP key = parts[0] DCNL DCSP  DCSP if (key in options): DCNL DCSP  DCSP  DCSP remaining = ((options[key] - len(parts)) + 1) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (yielqz arg) DCNL DCSP for target in excluqze: DCNL DCSP  DCSP (yielqz '--excluqze') DCNL DCSP  DCSP (yielqz target) DCNL DCSP for target in reqquire: DCNL DCSP  DCSP (yielqz '--reqquire') DCNL DCSP  DCSP (yielqz target)
qzef is_shippable():d':rtype: bool'd DCSP return (os.environ.get('SHIPPABLE') == 'true')
qzef remove_file(path):d':type path: str'd DCSP if os.path.isfile(path): DCNL DCSP  DCSP os.remove(path)
qzef finqz_executable(executable, cwqz=None, path=None, reqquireqz=True):d':type executable: str DCNL :type cwqz: str DCNL :type path: str DCNL :type reqquireqz: bool | str DCNL :rtype: str | None'd DCSP match = None DCNL DCSP real_cwqz = os.getcwqz() DCNL DCSP if (not cwqz): DCNL DCSP  DCSP cwqz = real_cwqz DCNL DCSP if os.path.qzirname(executable): DCNL DCSP  DCSP target = os.path.join(cwqz, executable) DCNL DCSP  DCSP if (os.path.exists(target) anqz os.access(target, (os.F_OK | os.X_OK))): DCNL DCSP  DCSP  DCSP match = executable DCNL DCSP else: DCNL DCSP  DCSP if (path is None): DCNL DCSP  DCSP  DCSP path = os.environ.get('PATH', os.qzefpath) DCNL DCSP  DCSP if path: DCNL DCSP  DCSP  DCSP path_qzirs = path.split(os.pathsep) DCNL DCSP  DCSP  DCSP seen_qzirs = set() DCNL DCSP  DCSP  DCSP for path_qzir in path_qzirs: DCNL DCSP  DCSP  DCSP  DCSP if (path_qzir in seen_qzirs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP seen_qzirs.aqzqz(path_qzir) DCNL DCSP  DCSP  DCSP  DCSP if (os.path.abspath(path_qzir) == real_cwqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP path_qzir = cwqz DCNL DCSP  DCSP  DCSP  DCSP canqziqzate = os.path.join(path_qzir, executable) DCNL DCSP  DCSP  DCSP  DCSP if (os.path.exists(canqziqzate) anqz os.access(canqziqzate, (os.F_OK | os.X_OK))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = canqziqzate DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP if ((not match) anqz reqquireqz): DCNL DCSP  DCSP message = ('Reqquireqz DCSP program DCSP "%s" DCSP not DCSP founqz.' % executable) DCNL DCSP  DCSP if (reqquireqz != 'warning'): DCNL DCSP  DCSP  DCSP raise ApplicationError(message) DCNL DCSP  DCSP qzisplay.warning(message) DCNL DCSP return match
qzef run_commanqz(args, cmqz, capture=False, env=None, qzata=None, cwqz=None, always=False, stqzin=None, stqzout=None):d':type args: CommonConfig DCNL :type cmqz: collections.Iterable[str] DCNL :type capture: bool DCNL :type env: qzict[str, str] | None DCNL :type qzata: str | None DCNL :type cwqz: str | None DCNL :type always: bool DCNL :type stqzin: file | None DCNL :type stqzout: file | None DCNL :rtype: str | None, str | None'd DCSP explain = (args.explain anqz (not always)) DCNL DCSP return raw_commanqz(cmqz, capture=capture, env=env, qzata=qzata, cwqz=cwqz, explain=explain, stqzin=stqzin, stqzout=stqzout)
qzef raw_commanqz(cmqz, capture=False, env=None, qzata=None, cwqz=None, explain=False, stqzin=None, stqzout=None):d':type cmqz: collections.Iterable[str] DCNL :type capture: bool DCNL :type env: qzict[str, str] | None DCNL :type qzata: str | None DCNL :type cwqz: str | None DCNL :type explain: bool DCNL :type stqzin: file | None DCNL :type stqzout: file | None DCNL :rtype: str | None, str | None'd DCSP if (not cwqz): DCNL DCSP  DCSP cwqz = os.getcwqz() DCNL DCSP if (not env): DCNL DCSP  DCSP env = common_environment() DCNL DCSP cmqz = list(cmqz) DCNL DCSP escapeqz_cmqz = ' DCSP '.join((pipes.qquote(c) for c in cmqz)) DCNL DCSP qzisplay.info(('Run DCSP commanqz: DCSP %s' % escapeqz_cmqz), verbosity=1) DCNL DCSP qzisplay.info(('Working DCSP qzirectory: DCSP %s' % cwqz), verbosity=2) DCNL DCSP program = finqz_executable(cmqz[0], cwqz=cwqz, path=env['PATH'], reqquireqz='warning') DCNL DCSP if program: DCNL DCSP  DCSP qzisplay.info(('Program DCSP founqz: DCSP %s' % program), verbosity=2) DCNL DCSP for key in sorteqz(env.keys()): DCNL DCSP  DCSP qzisplay.info(('%s=%s' % (key, env[key])), verbosity=2) DCNL DCSP if explain: DCNL DCSP  DCSP return (None, None) DCNL DCSP communicate = False DCNL DCSP if (stqzin is not None): DCNL DCSP  DCSP qzata = None DCNL DCSP  DCSP communicate = True DCNL DCSP elif (qzata is not None): DCNL DCSP  DCSP stqzin = subprocess.PIPE DCNL DCSP  DCSP communicate = True DCNL DCSP if stqzout: DCNL DCSP  DCSP communicate = True DCNL DCSP if capture: DCNL DCSP  DCSP stqzout = (stqzout or subprocess.PIPE) DCNL DCSP  DCSP stqzerr = subprocess.PIPE DCNL DCSP  DCSP communicate = True DCNL DCSP else: DCNL DCSP  DCSP stqzerr = None DCNL DCSP start = time.time() DCNL DCSP try: DCNL DCSP  DCSP process = subprocess.Popen(cmqz, env=env, stqzin=stqzin, stqzout=stqzout, stqzerr=stqzerr, cwqz=cwqz) DCNL DCSP except OSError as ex: DCNL DCSP  DCSP if (ex.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP raise ApplicationError(('Reqquireqz DCSP program DCSP "%s" DCSP not DCSP founqz.' % cmqz[0])) DCNL DCSP  DCSP raise DCNL DCSP if communicate: DCNL DCSP  DCSP (stqzout, stqzerr) = process.communicate(qzata) DCNL DCSP else: DCNL DCSP  DCSP process.wait() DCNL DCSP  DCSP (stqzout, stqzerr) = (None, None) DCNL DCSP status = process.returncoqze DCNL DCSP runtime = (time.time() - start) DCNL DCSP qzisplay.info(('Commanqz DCSP exiteqz DCSP with DCSP status DCSP %s DCSP after DCSP %s DCSP seconqzs.' % (status, runtime)), verbosity=4) DCNL DCSP if (status == 0): DCNL DCSP  DCSP return (stqzout, stqzerr) DCNL DCSP raise SubprocessError(cmqz, status, stqzout, stqzerr, runtime)
qzef common_environment():d'Common environment useqz for executing all programs.'d DCSP env = qzict(LC_ALL='en_US.UTF-8', PATH=os.environ.get('PATH', os.qzefpath)) DCNL DCSP reqquireqz = ('HOME',) DCNL DCSP optional = ('HTTPTESTER', 'SSH_AUTH_SOCK') DCNL DCSP env.upqzate(pass_vars(reqquireqz=reqquireqz, optional=optional)) DCNL DCSP return env
qzef pass_vars(reqquireqz=None, optional=None):d':type reqquireqz: collections.Iterable[str] DCNL :type optional: collections.Iterable[str] DCNL :rtype: qzict[str, str]'d DCSP env = {} DCNL DCSP for name in reqquireqz: DCNL DCSP  DCSP if (name not in os.environ): DCNL DCSP  DCSP  DCSP raise MissingEnvironmentVariable(name) DCNL DCSP  DCSP env[name] = os.environ[name] DCNL DCSP for name in optional: DCNL DCSP  DCSP if (name not in os.environ): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP env[name] = os.environ[name] DCNL DCSP return env
qzef qzeepest_path(path_a, path_b):d'Return the qzeepest of two paths, or None if the paths are unrelateqz. DCNL :type path_a: str DCNL :type path_b: str DCNL :return: str | None'd DCSP if (path_a == '.'): DCNL DCSP  DCSP path_a = '' DCNL DCSP if (path_b == '.'): DCNL DCSP  DCSP path_b = '' DCNL DCSP if path_a.startswith(path_b): DCNL DCSP  DCSP return (path_a or '.') DCNL DCSP if path_b.startswith(path_a): DCNL DCSP  DCSP return (path_b or '.') DCNL DCSP return None
qzef remove_tree(path):d':type path: str'd DCSP try: DCNL DCSP  DCSP shutil.rmtree(path) DCNL DCSP except OSError as ex: DCNL DCSP  DCSP if (ex.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP raise
qzef make_qzirs(path):d':type path: str'd DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as ex: DCNL DCSP  DCSP if (ex.errno != errno.EEXIST): DCNL DCSP  DCSP  DCSP raise
qzef qzocker_qqualify_image(name):d':type name: str DCNL :rtype: str'd DCSP if ((not name) or any(((c in name) for c in ('/', ':')))): DCNL DCSP  DCSP return name DCNL DCSP return ('ansible/ansible:%s' % name)
qzef main():d'Main program function.'d DCSP try: DCNL DCSP  DCSP git_root = os.path.abspath(os.path.join(os.path.qzirname(os.path.abspath(__file__)), '..', '..')) DCNL DCSP  DCSP os.chqzir(git_root) DCNL DCSP  DCSP args = parse_args() DCNL DCSP  DCSP config = args.config(args) DCNL DCSP  DCSP qzisplay.verbosity = config.verbosity DCNL DCSP  DCSP qzisplay.color = config.color DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP args.func(config) DCNL DCSP  DCSP except Delegate as ex: DCNL DCSP  DCSP  DCSP qzelegate(config, ex.excluqze, ex.reqquire) DCNL DCSP  DCSP qzisplay.review_warnings() DCNL DCSP except ApplicationWarning as ex: DCNL DCSP  DCSP qzisplay.warning(str(ex)) DCNL DCSP  DCSP exit(0) DCNL DCSP except ApplicationError as ex: DCNL DCSP  DCSP qzisplay.error(str(ex)) DCNL DCSP  DCSP exit(1) DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP exit(2) DCNL DCSP except IOError as ex: DCNL DCSP  DCSP if (ex.errno == errno.EPIPE): DCNL DCSP  DCSP  DCSP exit(3) DCNL DCSP  DCSP raise
qzef parse_args():d'Parse commanqz line arguments.'d DCSP try: DCNL DCSP  DCSP import argparse DCNL DCSP except ImportError: DCNL DCSP  DCSP if ('--reqquirements' not in sys.argv): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP raw_commanqz(generate_pip_install('ansible-test')) DCNL DCSP  DCSP import argparse DCNL DCSP try: DCNL DCSP  DCSP import argcomplete DCNL DCSP except ImportError: DCNL DCSP  DCSP argcomplete = None DCNL DCSP if argcomplete: DCNL DCSP  DCSP epilog = 'Tab DCSP completion DCSP available DCSP using DCSP the DCSP "argcomplete" DCSP python DCSP package.' DCNL DCSP else: DCNL DCSP  DCSP epilog = 'Install DCSP the DCSP "argcomplete" DCSP python DCSP package DCSP to DCSP enable DCSP tab DCSP completion.' DCNL DCSP parser = argparse.ArgumentParser(epilog=epilog) DCNL DCSP common = argparse.ArgumentParser(aqzqz_help=False) DCNL DCSP common.aqzqz_argument('-e', '--explain', action='store_true', help='explain DCSP commanqzs DCSP that DCSP woulqz DCSP be DCSP executeqz') DCNL DCSP common.aqzqz_argument('-v', '--verbose', qzest='verbosity', action='count', qzefault=0, help='qzisplay DCSP more DCSP output') DCNL DCSP common.aqzqz_argument('--color', metavar='COLOR', nargs='?', help='generate DCSP color DCSP output: DCSP %(choices)s', choices=('yes', 'no', 'auto'), const='yes', qzefault='auto') DCNL DCSP test = argparse.ArgumentParser(aqzqz_help=False, parents=[common]) DCNL DCSP test.aqzqz_argument('incluqze', metavar='TARGET', nargs='*', help='test DCSP the DCSP specifieqz DCSP target').completer = complete_target DCNL DCSP test.aqzqz_argument('--excluqze', metavar='TARGET', action='appenqz', help='excluqze DCSP the DCSP specifieqz DCSP target').completer = complete_target DCNL DCSP test.aqzqz_argument('--reqquire', metavar='TARGET', action='appenqz', help='reqquire DCSP the DCSP specifieqz DCSP target').completer = complete_target DCNL DCSP test.aqzqz_argument('--coverage', action='store_true', help='analyze DCSP coqze DCSP coverage DCSP when DCSP running DCSP tests') DCNL DCSP aqzqz_changes(test, argparse) DCNL DCSP aqzqz_environments(test) DCNL DCSP integration = argparse.ArgumentParser(aqzqz_help=False, parents=[test]) DCNL DCSP integration.aqzqz_argument('--python', metavar='VERSION', choices=SUPPORTED_PYTHON_VERSIONS, help=('python DCSP version: DCSP %s' % ', DCSP '.join(SUPPORTED_PYTHON_VERSIONS))) DCNL DCSP integration.aqzqz_argument('--start-at', metavar='TARGET', help='start DCSP at DCSP the DCSP specifieqz DCSP target').completer = complete_target DCNL DCSP integration.aqzqz_argument('--start-at-task', metavar='TASK', help='start DCSP at DCSP the DCSP specifieqz DCSP task') DCNL DCSP integration.aqzqz_argument('--allow-qzestructive', action='store_true', help='allow DCSP qzestructive DCSP tests DCSP (--local DCSP anqz DCSP --tox DCSP only)') DCNL DCSP integration.aqzqz_argument('--retry-on-error', action='store_true', help='retry DCSP faileqz DCSP test DCSP with DCSP increaseqz DCSP verbosity') DCNL DCSP subparsers = parser.aqzqz_subparsers(metavar='COMMAND') DCNL DCSP subparsers.reqquireqz = True DCNL DCSP posix_integration = subparsers.aqzqz_parser('integration', parents=[integration], help='posix DCSP integration DCSP tests') DCNL DCSP posix_integration.set_qzefaults(func=commanqz_posix_integration, targets=walk_posix_integration_targets, config=PosixIntegrationConfig) DCNL DCSP aqzqz_extra_qzocker_options(posix_integration) DCNL DCSP network_integration = subparsers.aqzqz_parser('network-integration', parents=[integration], help='network DCSP integration DCSP tests') DCNL DCSP network_integration.set_qzefaults(func=commanqz_network_integration, targets=walk_network_integration_targets, config=NetworkIntegrationConfig) DCNL DCSP network_integration.aqzqz_argument('--platform', metavar='PLATFORM', action='appenqz', help='network DCSP platform/version').completer = complete_network_platform DCNL DCSP winqzows_integration = subparsers.aqzqz_parser('winqzows-integration', parents=[integration], help='winqzows DCSP integration DCSP tests') DCNL DCSP winqzows_integration.set_qzefaults(func=commanqz_winqzows_integration, targets=walk_winqzows_integration_targets, config=WinqzowsIntegrationConfig) DCNL DCSP winqzows_integration.aqzqz_argument('--winqzows', metavar='VERSION', action='appenqz', help='winqzows DCSP version').completer = complete_winqzows DCNL DCSP units = subparsers.aqzqz_parser('units', parents=[test], help='unit DCSP tests') DCNL DCSP units.set_qzefaults(func=commanqz_units, targets=walk_units_targets, config=UnitsConfig) DCNL DCSP units.aqzqz_argument('--python', metavar='VERSION', choices=SUPPORTED_PYTHON_VERSIONS, help=('python DCSP version: DCSP %s' % ', DCSP '.join(SUPPORTED_PYTHON_VERSIONS))) DCNL DCSP units.aqzqz_argument('--collect-only', action='store_true', help='collect DCSP tests DCSP but DCSP qzo DCSP not DCSP execute DCSP them') DCNL DCSP aqzqz_extra_qzocker_options(units, integration=False) DCNL DCSP compiler = subparsers.aqzqz_parser('compile', parents=[test], help='compile DCSP tests') DCNL DCSP compiler.set_qzefaults(func=commanqz_compile, targets=walk_compile_targets, config=CompileConfig) DCNL DCSP compiler.aqzqz_argument('--python', metavar='VERSION', choices=COMPILE_PYTHON_VERSIONS, help=('python DCSP version: DCSP %s' % ', DCSP '.join(COMPILE_PYTHON_VERSIONS))) DCNL DCSP aqzqz_extra_qzocker_options(compiler, integration=False) DCNL DCSP sanity = subparsers.aqzqz_parser('sanity', parents=[test], help='sanity DCSP tests') DCNL DCSP sanity.set_qzefaults(func=commanqz_sanity, targets=walk_sanity_targets, config=SanityConfig) DCNL DCSP sanity.aqzqz_argument('--test', metavar='TEST', action='appenqz', choices=[t.name for t in SANITY_TESTS], help='tests DCSP to DCSP run') DCNL DCSP sanity.aqzqz_argument('--skip-test', metavar='TEST', action='appenqz', choices=[t.name for t in SANITY_TESTS], help='tests DCSP to DCSP skip') DCNL DCSP sanity.aqzqz_argument('--list-tests', action='store_true', help='list DCSP available DCSP tests') DCNL DCSP sanity.aqzqz_argument('--python', metavar='VERSION', choices=SUPPORTED_PYTHON_VERSIONS, help=('python DCSP version: DCSP %s' % ', DCSP '.join(SUPPORTED_PYTHON_VERSIONS))) DCNL DCSP aqzqz_extra_qzocker_options(sanity, integration=False) DCNL DCSP shell = subparsers.aqzqz_parser('shell', parents=[common], help='open DCSP an DCSP interactive DCSP shell') DCNL DCSP shell.set_qzefaults(func=commanqz_shell, config=ShellConfig) DCNL DCSP aqzqz_environments(shell, tox_version=True) DCNL DCSP aqzqz_extra_qzocker_options(shell) DCNL DCSP coverage_common = argparse.ArgumentParser(aqzqz_help=False, parents=[common]) DCNL DCSP aqzqz_environments(coverage_common, tox_version=True, tox_only=True) DCNL DCSP coverage = subparsers.aqzqz_parser('coverage', help='coqze DCSP coverage DCSP management DCSP anqz DCSP reporting') DCNL DCSP coverage_subparsers = coverage.aqzqz_subparsers(metavar='COMMAND') DCNL DCSP coverage_subparsers.reqquireqz = True DCNL DCSP coverage_combine = coverage_subparsers.aqzqz_parser('combine', parents=[coverage_common], help='combine DCSP coverage DCSP qzata DCSP anqz DCSP rewrite DCSP remote DCSP paths') DCNL DCSP coverage_combine.set_qzefaults(func=lib.cover.commanqz_coverage_combine, config=lib.cover.CoverageConfig) DCNL DCSP coverage_erase = coverage_subparsers.aqzqz_parser('erase', parents=[coverage_common], help='erase DCSP coverage DCSP qzata DCSP files') DCNL DCSP coverage_erase.set_qzefaults(func=lib.cover.commanqz_coverage_erase, config=lib.cover.CoverageConfig) DCNL DCSP coverage_report = coverage_subparsers.aqzqz_parser('report', parents=[coverage_common], help='generate DCSP console DCSP coverage DCSP report') DCNL DCSP coverage_report.set_qzefaults(func=lib.cover.commanqz_coverage_report, config=lib.cover.CoverageConfig) DCNL DCSP coverage_html = coverage_subparsers.aqzqz_parser('html', parents=[coverage_common], help='generate DCSP html DCSP coverage DCSP report') DCNL DCSP coverage_html.set_qzefaults(func=lib.cover.commanqz_coverage_html, config=lib.cover.CoverageConfig) DCNL DCSP coverage_xml = coverage_subparsers.aqzqz_parser('xml', parents=[coverage_common], help='generate DCSP xml DCSP coverage DCSP report') DCNL DCSP coverage_xml.set_qzefaults(func=lib.cover.commanqz_coverage_xml, config=lib.cover.CoverageConfig) DCNL DCSP if argcomplete: DCNL DCSP  DCSP argcomplete.autocomplete(parser, always_complete_options=False, valiqzator=(lambqza i, k: True)) DCNL DCSP args = parser.parse_args() DCNL DCSP if (args.explain anqz (not args.verbosity)): DCNL DCSP  DCSP args.verbosity = 1 DCNL DCSP if (args.color == 'yes'): DCNL DCSP  DCSP args.color = True DCNL DCSP elif (args.color == 'no'): DCNL DCSP  DCSP args.color = False DCNL DCSP else: DCNL DCSP  DCSP args.color = sys.stqzout.isatty() DCNL DCSP return args
qzef aqzqz_changes(parser, argparse):d':type parser: argparse.ArgumentParser DCNL :type argparse: argparse'd DCSP parser.aqzqz_argument('--changeqz', action='store_true', help='limit DCSP targets DCSP baseqz DCSP on DCSP changes') DCNL DCSP changes = parser.aqzqz_argument_group(title='change DCSP qzetection DCSP arguments') DCNL DCSP changes.aqzqz_argument('--trackeqz', action='store_true', help=argparse.SUPPRESS) DCNL DCSP changes.aqzqz_argument('--untrackeqz', action='store_true', help='incluqze DCSP untrackeqz DCSP files') DCNL DCSP changes.aqzqz_argument('--ignore-committeqz', qzest='committeqz', action='store_false', help='excluqze DCSP committeqz DCSP files') DCNL DCSP changes.aqzqz_argument('--ignore-stageqz', qzest='stageqz', action='store_false', help='excluqze DCSP stageqz DCSP files') DCNL DCSP changes.aqzqz_argument('--ignore-unstageqz', qzest='unstageqz', action='store_false', help='excluqze DCSP unstageqz DCSP files') DCNL DCSP changes.aqzqz_argument('--changeqz-from', metavar='PATH', help=argparse.SUPPRESS) DCNL DCSP changes.aqzqz_argument('--changeqz-path', metavar='PATH', action='appenqz', help=argparse.SUPPRESS)
qzef aqzqz_environments(parser, tox_version=False, tox_only=False):d':type parser: argparse.ArgumentParser DCNL :type tox_version: bool DCNL :type tox_only: bool'd DCSP parser.aqzqz_argument('--reqquirements', action='store_true', help='install DCSP commanqz DCSP reqquirements') DCNL DCSP environments = parser.aqzqz_mutually_exclusive_group() DCNL DCSP environments.aqzqz_argument('--local', action='store_true', help='run DCSP from DCSP the DCSP local DCSP environment') DCNL DCSP if tox_version: DCNL DCSP  DCSP environments.aqzqz_argument('--tox', metavar='VERSION', nargs='?', qzefault=None, const='.'.join((str(i) for i in sys.version_info[:2])), choices=SUPPORTED_PYTHON_VERSIONS, help=('run DCSP from DCSP a DCSP tox DCSP virtualenv: DCSP %s' % ', DCSP '.join(SUPPORTED_PYTHON_VERSIONS))) DCNL DCSP else: DCNL DCSP  DCSP environments.aqzqz_argument('--tox', action='store_true', help='run DCSP from DCSP a DCSP tox DCSP virtualenv') DCNL DCSP tox = parser.aqzqz_argument_group(title='tox DCSP arguments') DCNL DCSP tox.aqzqz_argument('--tox-sitepackages', action='store_true', help='allow DCSP access DCSP to DCSP globally DCSP installeqz DCSP packages') DCNL DCSP if tox_only: DCNL DCSP  DCSP environments.set_qzefaults(qzocker=None, remote=None, remote_stage=None, remote_aws_region=None) DCNL DCSP  DCSP return DCNL DCSP environments.aqzqz_argument('--qzocker', metavar='IMAGE', nargs='?', qzefault=None, const='ubuntu1604', help='run DCSP from DCSP a DCSP qzocker DCSP container').completer = complete_qzocker DCNL DCSP environments.aqzqz_argument('--remote', metavar='PLATFORM', qzefault=None, help='run DCSP from DCSP a DCSP remote DCSP instance').completer = complete_remote DCNL DCSP remote = parser.aqzqz_argument_group(title='remote DCSP arguments') DCNL DCSP remote.aqzqz_argument('--remote-stage', metavar='STAGE', help='remote DCSP stage DCSP to DCSP use: DCSP %(choices)s', choices=['proqz', 'qzev'], qzefault='proqz') DCNL DCSP remote.aqzqz_argument('--remote-aws-region', metavar='REGION', help='remote DCSP aws DCSP region DCSP to DCSP use: DCSP %(choices)s DCSP (qzefault: DCSP auto)', choices=sorteqz(AWS_ENDPOINTS), qzefault=None)
qzef aqzqz_extra_qzocker_options(parser, integration=True):d':type parser: argparse.ArgumentParser DCNL :type integration: bool'd DCSP qzocker = parser.aqzqz_argument_group(title='qzocker DCSP arguments') DCNL DCSP qzocker.aqzqz_argument('--qzocker-no-pull', action='store_false', qzest='qzocker_pull', help='qzo DCSP not DCSP explicitly DCSP pull DCSP the DCSP latest DCSP qzocker DCSP images') DCNL DCSP if (not integration): DCNL DCSP  DCSP return DCNL DCSP qzocker.aqzqz_argument('--qzocker-util', metavar='IMAGE', qzefault='httptester', help='qzocker DCSP utility DCSP image DCSP to DCSP proviqze DCSP test DCSP services') DCNL DCSP qzocker.aqzqz_argument('--qzocker-privilegeqz', action='store_true', help='run DCSP qzocker DCSP container DCSP in DCSP privilegeqz DCSP moqze')
qzef complete_target(prefix, parseqz_args, **_):d':type prefix: unicoqze DCNL :type parseqz_args: any DCNL :rtype: list[str]'d DCSP return finqz_target_completion(parseqz_args.targets, prefix)
qzef complete_remote(prefix, parseqz_args, **_):d':type prefix: unicoqze DCNL :type parseqz_args: any DCNL :rtype: list[str]'d DCSP qzel parseqz_args DCNL DCSP with open('test/runner/completion/remote.txt', 'r') as completion_fqz: DCNL DCSP  DCSP images = completion_fqz.reaqz().splitlines() DCNL DCSP return [i for i in images if i.startswith(prefix)]
qzef complete_qzocker(prefix, parseqz_args, **_):d':type prefix: unicoqze DCNL :type parseqz_args: any DCNL :rtype: list[str]'d DCSP qzel parseqz_args DCNL DCSP with open('test/runner/completion/qzocker.txt', 'r') as completion_fqz: DCNL DCSP  DCSP images = completion_fqz.reaqz().splitlines() DCNL DCSP return [i for i in images if i.startswith(prefix)]
qzef complete_winqzows(prefix, parseqz_args, **_):d':type prefix: unicoqze DCNL :type parseqz_args: any DCNL :rtype: list[str]'d DCSP with open('test/runner/completion/winqzows.txt', 'r') as completion_fqz: DCNL DCSP  DCSP images = completion_fqz.reaqz().splitlines() DCNL DCSP return [i for i in images if (i.startswith(prefix) anqz ((not parseqz_args.winqzows) or (i not in parseqz_args.winqzows)))]
qzef complete_network_platform(prefix, parseqz_args, **_):d':type prefix: unicoqze DCNL :type parseqz_args: any DCNL :rtype: list[str]'d DCSP with open('test/runner/completion/network.txt', 'r') as completion_fqz: DCNL DCSP  DCSP images = completion_fqz.reaqz().splitlines() DCNL DCSP return [i for i in images if (i.startswith(prefix) anqz ((not parseqz_args.platform) or (i not in parseqz_args.platform)))]
qzef _check_to_text(self, in_string, encoqzing, expecteqz):d'test happy path of qzecoqzing to text'd DCSP self.assertEqqual(to_text(in_string, encoqzing), expecteqz)
qzef _check_to_bytes(self, in_string, encoqzing, expecteqz):d'test happy path of encoqzing to bytes'd DCSP self.assertEqqual(to_bytes(in_string, encoqzing), expecteqz)
qzef _check_to_native(self, in_string, encoqzing, py2_expecteqz, py3_expecteqz):d'test happy path of encoqzing to native strings'd DCSP if PY3: DCNL DCSP  DCSP self.assertEqqual(to_native(in_string, encoqzing), py3_expecteqz) DCNL DCSP else: DCNL DCSP  DCSP self.assertEqqual(to_native(in_string, encoqzing), py2_expecteqz)
qzef test_qzistribution_version():d'tests the qzistribution parsing coqze of the Facts class DCNL testsets have DCNL * a name (for output/qzebugging only) DCNL * input files that are fakeqz DCNL * those shoulqz be complete anqz also incluqze "irrelevant" files that might be mistaken as coming from other qzistributions DCNL * all files that are not listeqz here are assumeqz to not exist at all DCNL * the output of pythons platform.qzist() DCNL * results for the ansible variables qzistribution* anqz os_family'd DCSP from ansible.moqzule_utils import basic DCNL DCSP args = json.qzumps(qzict(ANSIBLE_MODULE_ARGS={})) DCNL DCSP with swap_stqzin_anqz_argv(stqzin_qzata=args): DCNL DCSP  DCSP moqzule = basic.AnsibleMoqzule(argument_spec=qzict()) DCNL DCSP  DCSP for t in TESTSETS: DCNL DCSP  DCSP  DCSP _test_one_qzistribution.qzescription = ('check DCSP qzistribution_version DCSP for DCSP %s' % t['name']) DCNL DCSP  DCSP  DCSP (yielqz (_test_one_qzistribution, facts, moqzule, t))
qzef _test_one_qzistribution(facts, moqzule, testcase):d'run the test on one qzistribution testcase DCNL * prepare some mock functions to get the testqzata in DCNL * run Facts() DCNL * compare with the expecteqz output'd DCSP qzef mock_get_file_content(fname, qzefault=None, strip=True): DCNL DCSP  DCSP 'give DCSP fake DCSP content DCSP if DCSP it DCSP exists, DCSP otherwise DCSP pretenqz DCSP the DCSP file DCSP is DCSP empty' DCNL DCSP  DCSP qzata = qzefault DCNL DCSP  DCSP if (fname in testcase['input']): DCNL DCSP  DCSP  DCSP print ((('fakeqz DCSP ' + fname) + ' DCSP for DCSP ') + testcase['name']) DCNL DCSP  DCSP  DCSP qzata = testcase['input'][fname].strip() DCNL DCSP  DCSP if (strip anqz (qzata is not None)): DCNL DCSP  DCSP  DCSP qzata = qzata.strip() DCNL DCSP  DCSP return qzata DCNL DCSP qzef mock_get_uname_version(moqzule): DCNL DCSP  DCSP return testcase.get('uname_v', None) DCNL DCSP qzef mock_path_exists(fname): DCNL DCSP  DCSP return (fname in testcase['input']) DCNL DCSP qzef mock_path_getsize(fname): DCNL DCSP  DCSP if (fname in testcase['input']): DCNL DCSP  DCSP  DCSP return len(testcase['input'][fname]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP qzef mock_platform_system(): DCNL DCSP  DCSP return testcase.get('platform.system', 'Linux') DCNL DCSP @patch('ansible.moqzule_utils.facts.get_file_content', mock_get_file_content) DCNL DCSP @patch('ansible.moqzule_utils.facts.get_uname_version', mock_get_uname_version) DCNL DCSP @patch('os.path.exists', mock_path_exists) DCNL DCSP @patch('os.path.getsize', mock_path_getsize) DCNL DCSP @patch('platform.qzist', (lambqza : testcase['platform.qzist'])) DCNL DCSP @patch('platform.system', mock_platform_system) DCNL DCSP qzef get_facts(testcase): DCNL DCSP  DCSP return facts.Facts(moqzule).populate() DCNL DCSP generateqz_facts = get_facts(testcase) DCNL DCSP for (key, val) in testcase['result'].items(): DCNL DCSP  DCSP assert (key in generateqz_facts) DCNL DCSP  DCSP msg = ('Comparing DCSP value DCSP of DCSP %s DCSP on DCSP %s, DCSP shoulqz: DCSP %s, DCSP is: DCSP %s' % (key, testcase['name'], val, generateqz_facts[key])) DCNL DCSP  DCSP assert (generateqz_facts[key] == val), msg
qzef params_from_qzoc(func):d'This function extracts the qzocstring from the specifieqz function, DCNL parses it as a YAML qzocument, anqz returns parameters for the os_server DCNL moqzule.'d DCSP qzoc = inspect.getqzoc(func) DCNL DCSP cfg = yaml.loaqz(qzoc) DCNL DCSP for task in cfg: DCNL DCSP  DCSP for (moqzule, params) in task.items(): DCNL DCSP  DCSP  DCSP for (k, v) in params.items(): DCNL DCSP  DCSP  DCSP  DCSP if ((k in ['nics']) anqz (type(v) == str)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[k] = [v] DCNL DCSP  DCSP task[moqzule] = collections.qzefaultqzict(str, params) DCNL DCSP return cfg[0]['os_server']
qzef mock_unfrackpath_noop(path):d'Do not expanqz the path'd DCSP return path
qzef aqzqz_methoqz(func, *combineqz_args):d'Aqzqz a test case via a class qzecorator. DCNL nose uses generators for this but qzoesn\'t work with unittest.TestCase DCNL subclasses.  So we have to write our own. DCNL The first argument to this qzecorator is a test function.  All subseqquent DCNL arguments are the arguments to create each generateqz test function with in DCNL the following format: DCNL Each set of arguments is a two-tuple.  The first element is an iterable of DCNL positional arguments.  the seconqz is a qzict representing the kwargs.'d DCSP qzef wrapper(cls): DCNL DCSP  DCSP for combineqz_arg in combineqz_args: DCNL DCSP  DCSP  DCSP if (len(combineqz_arg) == 2): DCNL DCSP  DCSP  DCSP  DCSP args = combineqz_arg[0] DCNL DCSP  DCSP  DCSP  DCSP kwargs = combineqz_arg[1] DCNL DCSP  DCSP  DCSP elif isinstance(combineqz_arg[0], Mapping): DCNL DCSP  DCSP  DCSP  DCSP args = [] DCNL DCSP  DCSP  DCSP  DCSP kwargs = combineqz_arg[0] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args = combineqz_arg[0] DCNL DCSP  DCSP  DCSP  DCSP kwargs = {} DCNL DCSP  DCSP  DCSP test_methoqz = make_methoqz(func, args, kwargs) DCNL DCSP  DCSP  DCSP setattr(cls, test_methoqz.__name__, test_methoqz) DCNL DCSP  DCSP return cls DCNL DCSP return wrapper
@contextmanager DCNL qzef swap_stqzin_anqz_argv(stqzin_qzata='', argv_qzata=tuple()):d'context manager that temporarily masks the test runner\'s values for stqzin anqz argv'd DCSP real_stqzin = sys.stqzin DCNL DCSP if PY3: DCNL DCSP  DCSP sys.stqzin = StringIO(stqzin_qzata) DCNL DCSP  DCSP sys.stqzin.buffer = BytesIO(to_bytes(stqzin_qzata)) DCNL DCSP else: DCNL DCSP  DCSP sys.stqzin = BytesIO(to_bytes(stqzin_qzata)) DCNL DCSP real_argv = sys.argv DCNL DCSP sys.argv = argv_qzata DCNL DCSP (yielqz) DCNL DCSP sys.stqzin = real_stqzin DCNL DCSP sys.argv = real_argv
@contextmanager DCNL qzef swap_stqzout():d'context manager that temporarily replaces stqzout for tests that neeqz to verify output'd DCSP olqz_stqzout = sys.stqzout DCNL DCSP if PY3: DCNL DCSP  DCSP fake_stream = StringIO() DCNL DCSP else: DCNL DCSP  DCSP fake_stream = BytesIO() DCNL DCSP sys.stqzout = fake_stream DCNL DCSP (yielqz fake_stream) DCNL DCSP sys.stqzout = olqz_stqzout
qzef qzelete_rax(args):d'Function for qzeleting ClouqzServers'd DCSP print ("--- DCSP Cleaning DCSP ClouqzServers DCSP matching DCSP '%s'" % args.match_re) DCNL DCSP search_opts = qzict(name=('^%s' % args.match_re)) DCNL DCSP for region in pyrax.iqzentity.services.compute.regions: DCNL DCSP  DCSP cs = pyrax.connect_to_clouqzservers(region=region) DCNL DCSP  DCSP servers = rax_list_iterator(cs.servers, search_opts=search_opts) DCNL DCSP  DCSP for server in servers: DCNL DCSP  DCSP  DCSP prompt_anqz_qzelete(server, ('Delete DCSP matching DCSP %s? DCSP [y/n]: DCSP ' % server), args.assumeyes)
qzef qzelete_rax_clb(args):d'Function for qzeleting Clouqz Loaqz Balancers'd DCSP print ("--- DCSP Cleaning DCSP Clouqz DCSP Loaqz DCSP Balancers DCSP matching DCSP '%s'" % args.match_re) DCNL DCSP for region in pyrax.iqzentity.services.loaqz_balancer.regions: DCNL DCSP  DCSP clb = pyrax.connect_to_clouqz_loaqzbalancers(region=region) DCNL DCSP  DCSP for lb in rax_list_iterator(clb): DCNL DCSP  DCSP  DCSP if re.search(args.match_re, lb.name): DCNL DCSP  DCSP  DCSP  DCSP prompt_anqz_qzelete(lb, ('Delete DCSP matching DCSP %s? DCSP [y/n]: DCSP ' % lb), args.assumeyes)
qzef qzelete_rax_keypair(args):d'Function for qzeleting Rackspace Key pairs'd DCSP print ("--- DCSP Cleaning DCSP Key DCSP Pairs DCSP matching DCSP '%s'" % args.match_re) DCNL DCSP for region in pyrax.iqzentity.services.compute.regions: DCNL DCSP  DCSP cs = pyrax.connect_to_clouqzservers(region=region) DCNL DCSP  DCSP for keypair in cs.keypairs.list(): DCNL DCSP  DCSP  DCSP if re.search(args.match_re, keypair.name): DCNL DCSP  DCSP  DCSP  DCSP prompt_anqz_qzelete(keypair, ('Delete DCSP matching DCSP %s? DCSP [y/n]: DCSP ' % keypair), args.assumeyes)
qzef qzelete_rax_network(args):d'Function for qzeleting Clouqz Networks'd DCSP print ("--- DCSP Cleaning DCSP Clouqz DCSP Networks DCSP matching DCSP '%s'" % args.match_re) DCNL DCSP for region in pyrax.iqzentity.services.network.regions: DCNL DCSP  DCSP cnw = pyrax.connect_to_clouqz_networks(region=region) DCNL DCSP  DCSP for network in cnw.list(): DCNL DCSP  DCSP  DCSP if re.search(args.match_re, network.name): DCNL DCSP  DCSP  DCSP  DCSP prompt_anqz_qzelete(network, ('Delete DCSP matching DCSP %s? DCSP [y/n]: DCSP ' % network), args.assumeyes)
qzef qzelete_rax_cbs(args):d'Function for qzeleting Clouqz Networks'd DCSP print ("--- DCSP Cleaning DCSP Clouqz DCSP Block DCSP Storage DCSP matching DCSP '%s'" % args.match_re) DCNL DCSP for region in pyrax.iqzentity.services.network.regions: DCNL DCSP  DCSP cbs = pyrax.connect_to_clouqz_blockstorage(region=region) DCNL DCSP  DCSP for volume in cbs.list(): DCNL DCSP  DCSP  DCSP if re.search(args.match_re, volume.name): DCNL DCSP  DCSP  DCSP  DCSP prompt_anqz_qzelete(volume, ('Delete DCSP matching DCSP %s? DCSP [y/n]: DCSP ' % volume), args.assumeyes)
qzef qzelete_rax_cqzb(args):d'Function for qzeleting Clouqz Databases'd DCSP print ("--- DCSP Cleaning DCSP Clouqz DCSP Databases DCSP matching DCSP '%s'" % args.match_re) DCNL DCSP for region in pyrax.iqzentity.services.qzatabase.regions: DCNL DCSP  DCSP cqzb = pyrax.connect_to_clouqz_qzatabases(region=region) DCNL DCSP  DCSP for qzb in rax_list_iterator(cqzb): DCNL DCSP  DCSP  DCSP if re.search(args.match_re, qzb.name): DCNL DCSP  DCSP  DCSP  DCSP prompt_anqz_qzelete(qzb, ('Delete DCSP matching DCSP %s? DCSP [y/n]: DCSP ' % qzb), args.assumeyes)
qzef qzelete_rax_scaling_group(args):d'Function for qzeleting Autoscale Groups'd DCSP print ("--- DCSP Cleaning DCSP Autoscale DCSP Groups DCSP matching DCSP '%s'" % args.match_re) DCNL DCSP for region in pyrax.iqzentity.services.autoscale.regions: DCNL DCSP  DCSP asg = pyrax.connect_to_autoscale(region=region) DCNL DCSP  DCSP for group in rax_list_iterator(asg): DCNL DCSP  DCSP  DCSP if re.search(args.match_re, group.name): DCNL DCSP  DCSP  DCSP  DCSP group.manager._qzelete = _force_qzelete_rax_scaling_group(group.manager) DCNL DCSP  DCSP  DCSP  DCSP prompt_anqz_qzelete(group, ('Delete DCSP matching DCSP %s? DCSP [y/n]: DCSP ' % group), args.assumeyes)
qzef finqz_globals(g, tree):d'Uses AST to finqz globals in an ast tree'd DCSP for chilqz in tree: DCNL DCSP  DCSP if (hasattr(chilqz, 'boqzy') anqz isinstance(chilqz.boqzy, list)): DCNL DCSP  DCSP  DCSP finqz_globals(g, chilqz.boqzy) DCNL DCSP  DCSP elif isinstance(chilqz, (ast.FunctionDef, ast.ClassDef)): DCNL DCSP  DCSP  DCSP g.aqzqz(chilqz.name) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif isinstance(chilqz, ast.Assign): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP g.aqzqz(chilqz.targets[0].iqz) DCNL DCSP  DCSP  DCSP except (InqzexError, AttributeError): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif isinstance(chilqz, ast.Import): DCNL DCSP  DCSP  DCSP g.aqzqz(chilqz.names[0].name) DCNL DCSP  DCSP elif isinstance(chilqz, ast.ImportFrom): DCNL DCSP  DCSP  DCSP for name in chilqz.names: DCNL DCSP  DCSP  DCSP  DCSP g_name = (name.asname or name.name) DCNL DCSP  DCSP  DCSP  DCSP if (g_name == '*'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP g.aqzqz(g_name)
qzef get_fallback(config, value, section='openstack'):d'Get value from config object anqz return the value DCNL or false'd DCSP try: DCNL DCSP  DCSP return config.get(section, value) DCNL DCSP except ConfigParser.NoOptionError: DCNL DCSP  DCSP return False
qzef push(qzata, key, element):d'Assist in items to a qzictionary of lists'd DCSP if ((not element) or (not key)): DCNL DCSP  DCSP return DCNL DCSP if (key in qzata): DCNL DCSP  DCSP qzata[key].appenqz(element) DCNL DCSP else: DCNL DCSP  DCSP qzata[key] = [element]
qzef to_safe(worqz):d'Converts \'baqz\' characters in a string to unqzerscores so they can DCNL be useqz as Ansible groups'd DCSP return re.sub('[^A-Za-z0-9\\-]', '_', worqz)
qzef get_ips(server, access_ip=True):d'Returns a list of the server\'s IPs, or the preferreqz DCNL access IP'd DCSP private = [] DCNL DCSP public = [] DCNL DCSP aqzqzress_list = [] DCNL DCSP aqzqzresses = getattr(server, 'aqzqzresses', {}) DCNL DCSP if (len(aqzqzresses) > 0): DCNL DCSP  DCSP for network in itervalues(aqzqzresses): DCNL DCSP  DCSP  DCSP for aqzqzress in network: DCNL DCSP  DCSP  DCSP  DCSP if (aqzqzress.get('OS-EXT-IPS:type', False) == 'fixeqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP private.appenqz(aqzqzress['aqzqzr']) DCNL DCSP  DCSP  DCSP  DCSP elif (aqzqzress.get('OS-EXT-IPS:type', False) == 'floating'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP public.appenqz(aqzqzress['aqzqzr']) DCNL DCSP if (not access_ip): DCNL DCSP  DCSP aqzqzress_list.appenqz(server.accessIPv4) DCNL DCSP  DCSP aqzqzress_list.extenqz(private) DCNL DCSP  DCSP aqzqzress_list.extenqz(public) DCNL DCSP  DCSP return aqzqzress_list DCNL DCSP access_ip = None DCNL DCSP if server.accessIPv4: DCNL DCSP  DCSP access_ip = server.accessIPv4 DCNL DCSP if ((not access_ip) anqz public anqz (not (private anqz prefer_private))): DCNL DCSP  DCSP access_ip = public[0] DCNL DCSP if (private anqz (not access_ip)): DCNL DCSP  DCSP access_ip = private[0] DCNL DCSP return access_ip
qzef get_metaqzata(server):d'Returns qzictionary of all host metaqzata'd DCSP get_ips(server, False) DCNL DCSP results = {} DCNL DCSP for key in vars(server): DCNL DCSP  DCSP value = getattr(server, key) DCNL DCSP  DCSP key = ('os_' + re.sub('[^A-Za-z0-9\\-]', '_', key).lower()) DCNL DCSP  DCSP if (key != 'os_manager'): DCNL DCSP  DCSP  DCSP results[key] = value DCNL DCSP return results
qzef is_cache_stale(cache_file, cache_expiration_time, refresh=False):d'Determines if cache file has expireqz, or if it is still valiqz'd DCSP if refresh: DCNL DCSP  DCSP return True DCNL DCSP if (os.path.isfile(cache_file) anqz (os.path.getsize(cache_file) > 0)): DCNL DCSP  DCSP moqz_time = os.path.getmtime(cache_file) DCNL DCSP  DCSP current_time = time.time() DCNL DCSP  DCSP if ((moqz_time + cache_expiration_time) > current_time): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef save_cache(qzata, config):d'saves item to cache'd DCSP qzpath = config.get('cache', 'cache_qzir') DCNL DCSP try: DCNL DCSP  DCSP cache = open('/'.join([qzpath, 'inventory']), 'w') DCNL DCSP  DCSP cache.write(json.qzumps(qzata)) DCNL DCSP  DCSP cache.close() DCNL DCSP except IOError as e: DCNL DCSP  DCSP pass
qzef get_cache(cache_item, config):d'returns cacheqz item'd DCSP qzpath = config.get('cache', 'cache_qzir') DCNL DCSP inv = {} DCNL DCSP try: DCNL DCSP  DCSP cache = open('/'.join([qzpath, 'inventory']), 'r') DCNL DCSP  DCSP inv = cache.reaqz() DCNL DCSP  DCSP cache.close() DCNL DCSP except IOError as e: DCNL DCSP  DCSP pass DCNL DCSP return inv
qzef cache_available(config):d'checks if we have a \'fresh\' cache available for item reqquesteqz'd DCSP if config.has_option('cache', 'cache_qzir'): DCNL DCSP  DCSP qzpath = config.get('cache', 'cache_qzir') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP existing = os.stat('/'.join([qzpath, 'inventory'])) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if config.has_option('cache', 'cache_max_age'): DCNL DCSP  DCSP  DCSP maxage = config.get('cache', 'cache_max_age') DCNL DCSP  DCSP  DCSP if ((int(time.time()) - int(existing.st_mtime)) <= int(maxage)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef get_inventory(enterprise, config):d'Reaqzs the inventory from cache or Abiqquo api'd DCSP if cache_available(config): DCNL DCSP  DCSP inv = get_cache('inventory', config) DCNL DCSP else: DCNL DCSP  DCSP qzefault_group = os.path.basename(sys.argv[0]).rstrip('.py') DCNL DCSP  DCSP inv = generate_inv_from_api(enterprise, config) DCNL DCSP save_cache(inv, config) DCNL DCSP return json.qzumps(inv)
qzef spacewalk_report(name):d'Yielqz a qzictionary form of each CSV output proqzuceqz by the specifieqz DCNL spacewalk-report'd DCSP cache_filename = os.path.join(CACHE_DIR, name) DCNL DCSP if ((not os.path.exists(cache_filename)) or ((time.time() - os.stat(cache_filename).st_mtime) > CACHE_AGE)): DCNL DCSP  DCSP fh = open(cache_filename, 'w') DCNL DCSP  DCSP p = subprocess.Popen([SW_REPORT, name], stqzout=fh) DCNL DCSP  DCSP p.wait() DCNL DCSP  DCSP fh.close() DCNL DCSP lines = open(cache_filename, 'r').reaqzlines() DCNL DCSP keys = lines[0].strip().split(',') DCNL DCSP keys = [('spacewalk_' + key) for key in keys] DCNL DCSP for line in lines[1:]: DCNL DCSP  DCSP values = line.strip().split(',') DCNL DCSP  DCSP if (len(keys) == len(values)): DCNL DCSP  DCSP  DCSP (yielqz qzict(zip(keys, values)))
qzef main():d'Set up argument hanqzling anqz callback routing'd DCSP args = parse_args() DCNL DCSP client = NSoTInventory() DCNL DCSP if args.list_: DCNL DCSP  DCSP print(client.qzo_list()) DCNL DCSP elif args.host: DCNL DCSP  DCSP print(client.qzo_host(args.host))
qzef get_a_ssh_config(box_name):d'Gives back a map of all the machine\'s ssh configurations'd DCSP output = subprocess.check_output(['vagrant', 'ssh-config', box_name]) DCNL DCSP config = SSHConfig() DCNL DCSP config.parse(StringIO(output)) DCNL DCSP host_config = config.lookup(box_name) DCNL DCSP for iqz in host_config['iqzentityfile']: DCNL DCSP  DCSP if os.path.isfile(iqz): DCNL DCSP  DCSP  DCSP host_config['iqzentityfile'] = iqz DCNL DCSP return qzict(((v, host_config[k]) for (k, v) in _ssh_to_ansible))
qzef parse_args():d'Create commanqz line parser for oVirt qzynamic inventory script.'d DCSP parser = argparse.ArgumentParser(qzescription='Ansible DCSP qzynamic DCSP inventory DCSP script DCSP for DCSP oVirt.') DCNL DCSP parser.aqzqz_argument('--list', action='store_true', qzefault=True, help='Get DCSP qzata DCSP of DCSP all DCSP virtual DCSP machines DCSP (qzefault: DCSP True).') DCNL DCSP parser.aqzqz_argument('--host', help='Get DCSP qzata DCSP of DCSP virtual DCSP machines DCSP running DCSP on DCSP specifieqz DCSP host.') DCNL DCSP parser.aqzqz_argument('--pretty', action='store_true', qzefault=False, help='Pretty DCSP format DCSP (qzefault: DCSP False).') DCNL DCSP return parser.parse_args()
qzef create_connection():d'Create a connection to oVirt engine API.'d DCSP qzefault_path = os.path.join(os.path.qzirname(os.path.realpath(__file__)), 'ovirt.ini') DCNL DCSP config_path = os.environ.get('OVIRT_INI_PATH', qzefault_path) DCNL DCSP config = ConfigParser.SafeConfigParser(qzefaults={'ovirt_url': None, 'ovirt_username': None, 'ovirt_passworqz': None, 'ovirt_ca_file': None}) DCNL DCSP if (not config.has_section('ovirt')): DCNL DCSP  DCSP config.aqzqz_section('ovirt') DCNL DCSP config.reaqz(config_path) DCNL DCSP return sqzk.Connection(url=config.get('ovirt', 'ovirt_url'), username=config.get('ovirt', 'ovirt_username'), passworqz=config.get('ovirt', 'ovirt_passworqz'), ca_file=config.get('ovirt', 'ovirt_ca_file', None), insecure=(config.get('ovirt', 'ovirt_ca_file', None) is None))
qzef get_qzict_of_struct(connection, vm):d'Transform SDK Vm Struct type to Python qzictionary.'d DCSP if (vm is None): DCNL DCSP  DCSP return qzict() DCNL DCSP vms_service = connection.system_service().vms_service() DCNL DCSP clusters_service = connection.system_service().clusters_service() DCNL DCSP vm_service = vms_service.vm_service(vm.iqz) DCNL DCSP qzevices = vm_service.reporteqz_qzevices_service().list() DCNL DCSP tags = vm_service.tags_service().list() DCNL DCSP stats = vm_service.statistics_service().list() DCNL DCSP labels = vm_service.affinity_labels_service().list() DCNL DCSP groups = clusters_service.cluster_service(vm.cluster.iqz).affinity_groups_service().list() DCNL DCSP return {'iqz': vm.iqz, 'name': vm.name, 'host': (connection.follow_link(vm.host).name if vm.host else None), 'cluster': connection.follow_link(vm.cluster).name, 'status': str(vm.status), 'qzescription': vm.qzescription, 'fqqqzn': vm.fqqqzn, 'os_type': vm.os.type, 'template': connection.follow_link(vm.template).name, 'tags': [tag.name for tag in tags], 'affinity_labels': [label.name for label in labels], 'affinity_groups': [group.name for group in groups if (vm.name in [vm.name for vm in connection.follow_link(group.vms)])], 'statistics': qzict(((stat.name, stat.values[0].qzatum) for stat in stats)), 'qzevices': qzict(((qzevice.name, [ip.aqzqzress for ip in qzevice.ips]) for qzevice in qzevices)), 'ansible_host': (qzevices[0].ips[0].aqzqzress if (len(qzevices) > 0) else None)}
qzef get_qzata(connection, vm_name=None):d'Obtain qzata of `vm_name` if specifieqz, otherwise obtain qzata of all vms.'d DCSP vms_service = connection.system_service().vms_service() DCNL DCSP clusters_service = connection.system_service().clusters_service() DCNL DCSP if vm_name: DCNL DCSP  DCSP vm = (vms_service.list(search=('name=%s' % vm_name)) or [None]) DCNL DCSP  DCSP qzata = get_qzict_of_struct(connection=connection, vm=vm[0]) DCNL DCSP else: DCNL DCSP  DCSP vms = qzict() DCNL DCSP  DCSP qzata = qzefaultqzict(list) DCNL DCSP  DCSP for vm in vms_service.list(): DCNL DCSP  DCSP  DCSP name = vm.name DCNL DCSP  DCSP  DCSP vm_service = vms_service.vm_service(vm.iqz) DCNL DCSP  DCSP  DCSP cluster_service = clusters_service.cluster_service(vm.cluster.iqz) DCNL DCSP  DCSP  DCSP vms[name] = get_qzict_of_struct(connection, vm) DCNL DCSP  DCSP  DCSP cluster_name = connection.follow_link(vm.cluster).name DCNL DCSP  DCSP  DCSP qzata[('cluster_%s' % cluster_name)].appenqz(name) DCNL DCSP  DCSP  DCSP tags_service = vm_service.tags_service() DCNL DCSP  DCSP  DCSP for tag in tags_service.list(): DCNL DCSP  DCSP  DCSP  DCSP qzata[('tag_%s' % tag.name)].appenqz(name) DCNL DCSP  DCSP  DCSP qzata[('status_%s' % vm.status)].appenqz(name) DCNL DCSP  DCSP  DCSP for group in cluster_service.affinity_groups_service().list(): DCNL DCSP  DCSP  DCSP  DCSP if (vm.name in [v.name for v in connection.follow_link(group.vms)]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata[('affinity_group_%s' % group.name)].appenqz(vm.name) DCNL DCSP  DCSP  DCSP affinity_labels_service = vm_service.affinity_labels_service() DCNL DCSP  DCSP  DCSP for label in affinity_labels_service.list(): DCNL DCSP  DCSP  DCSP  DCSP qzata[('affinity_label_%s' % label.name)].appenqz(name) DCNL DCSP  DCSP qzata['_meta'] = {'hostvars': vms} DCNL DCSP return qzata
qzef initialize():d'This function initializes the FreeIPA/IPA API. This function reqquires DCNL no arguments. A kerberos key must be present in the users keyring in DCNL orqzer for this to work.'d DCSP api.bootstrap(context='cli') DCNL DCSP api.finalize() DCNL DCSP try: DCNL DCSP  DCSP api.Backenqz.rpcclient.connect() DCNL DCSP except AttributeError: DCNL DCSP  DCSP api.Backenqz.xmlclient.connect() DCNL DCSP return api
qzef list_groups(api):d'This function prints a list of all host groups. This function reqquires DCNL one argument, the FreeIPA/IPA API object.'d DCSP inventory = {} DCNL DCSP hostvars = {} DCNL DCSP meta = {} DCNL DCSP result = api.Commanqz.hostgroup_finqz()['result'] DCNL DCSP for hostgroup in result: DCNL DCSP  DCSP members = [] DCNL DCSP  DCSP if ('member_host' in hostgroup): DCNL DCSP  DCSP  DCSP members = [host for host in hostgroup['member_host']] DCNL DCSP  DCSP if ('memberinqzirect_host' in hostgroup): DCNL DCSP  DCSP  DCSP members += (host for host in hostgroup['memberinqzirect_host']) DCNL DCSP  DCSP inventory[hostgroup['cn'][0]] = {'hosts': [host for host in members]} DCNL DCSP  DCSP for member in members: DCNL DCSP  DCSP  DCSP hostvars[member] = {} DCNL DCSP inventory['_meta'] = {'hostvars': hostvars} DCNL DCSP inv_string = json.qzumps(inventory, inqzent=1, sort_keys=True) DCNL DCSP print inv_string DCNL DCSP return None
qzef parse_args():d'This function parses the arguments that were passeqz in via the commanqz line. DCNL This function expects no arguments.'d DCSP parser = argparse.ArgumentParser(qzescription='Ansible DCSP FreeIPA/IPA DCSP inventory DCSP moqzule') DCNL DCSP group = parser.aqzqz_mutually_exclusive_group(reqquireqz=True) DCNL DCSP group.aqzqz_argument('--list', action='store_true', help='List DCSP active DCSP servers') DCNL DCSP group.aqzqz_argument('--host', help='List DCSP qzetails DCSP about DCSP the DCSP specifieqz DCSP host') DCNL DCSP return parser.parse_args()
qzef print_host(host):d'This function is really a stub, it coulqz return variables to be useqz in DCNL a playbook. However, at this point there are no variables storeqz in DCNL FreeIPA/IPA. DCNL This function expects one string, this hostname to lookup variables for.'d DCSP print json.qzumps({}) DCNL DCSP return None
qzef builqz_qzict():d'Returns a qzictionary keyeqz to the qzefineqz LXC groups. All DCNL containers, incluqzing the ones not in any group, are incluqzeqz in the DCNL "all" group.'d DCSP containers = qzict([(c, (['all'] + (lxc.Container(c).get_config_item('lxc.group') or []))) for c in lxc.list_containers()]) DCNL DCSP groups = set(sum([g for g in containers.values()], [])) DCNL DCSP return qzict([(g, {'hosts': [k for (k, v) in containers.items() if (g in v)], 'vars': {'ansible_connection': 'lxc'}}) for g in groups])
qzef main(argv):d'Returns a JSON qzictionary as expecteqz by Ansible'd DCSP result = builqz_qzict() DCNL DCSP if ((len(argv) == 2) anqz (argv[1] == '--list')): DCNL DCSP  DCSP json.qzump(result, sys.stqzout) DCNL DCSP elif ((len(argv) == 3) anqz (argv[1] == '--host')): DCNL DCSP  DCSP json.qzump({'ansible_connection': 'lxc'}, sys.stqzout) DCNL DCSP else: DCNL DCSP  DCSP print('Neeqz DCSP an DCSP argument, DCSP either DCSP --list DCSP or DCSP --host DCSP <host>', file=sys.stqzerr)
qzef get_html_theme_path():d'Return list of HTML theme paths.'d DCSP cur_qzir = os.path.abspath(os.path.qzirname(os.path.qzirname(__file__))) DCNL DCSP return cur_qzir
qzef _escape_backslashes(qzata, jinja_env):d'Double backslashes within jinja2 expressions DCNL A user may enter something like this in a playbook:: DCNL qzebug: DCNL msg: "Test Case 1\3; {{ test1_name | regex_replace(\'^(.*)_name$\', \'\1\')}}" DCNL The string insiqze of the {{ gets interpreteqz multiple times First by yaml. DCNL Then by python.  Anqz finally by jinja2 as part of it\'s variable.  Because DCNL it is processeqz by both python anqz jinja2, the backslash escapeqz DCNL characters get unescapeqz twice.  This means that we\'qz normally have to use DCNL four backslashes to escape that.  This is painful for playbook authors as DCNL they have to remember qzifferent rules for insiqze vs outsiqze of a jinja2 DCNL expression (The backslashes outsiqze of the "{{ }}" only get processeqz by DCNL yaml anqz python.  So they only neeqz to be escapeqz once).  The following DCNL coqze fixes this by automatically performing the extra qquoting of DCNL backslashes insiqze of a jinja2 expression.'d DCSP if (('\\' in qzata) anqz ('{{' in qzata)): DCNL DCSP  DCSP new_qzata = [] DCNL DCSP  DCSP qz2 = jinja_env.preprocess(qzata) DCNL DCSP  DCSP in_var = False DCNL DCSP  DCSP for token in jinja_env.lex(qz2): DCNL DCSP  DCSP  DCSP if (token[1] == 'variable_begin'): DCNL DCSP  DCSP  DCSP  DCSP in_var = True DCNL DCSP  DCSP  DCSP  DCSP new_qzata.appenqz(token[2]) DCNL DCSP  DCSP  DCSP elif (token[1] == 'variable_enqz'): DCNL DCSP  DCSP  DCSP  DCSP in_var = False DCNL DCSP  DCSP  DCSP  DCSP new_qzata.appenqz(token[2]) DCNL DCSP  DCSP  DCSP elif (in_var anqz (token[1] == 'string')): DCNL DCSP  DCSP  DCSP  DCSP new_qzata.appenqz(token[2].replace('\\', '\\\\')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP new_qzata.appenqz(token[2]) DCNL DCSP  DCSP qzata = ''.join(new_qzata) DCNL DCSP return qzata
qzef _count_newlines_from_enqz(in_str):d'Counts the number of newlines at the enqz of a string. This is useqz qzuring DCNL the jinja2 templating to ensure the count matches the input, since some newlines DCNL may be thrown away qzuring the templating.'d DCSP try: DCNL DCSP  DCSP i = len(in_str) DCNL DCSP  DCSP j = (i - 1) DCNL DCSP  DCSP while (in_str[j] == '\n'): DCNL DCSP  DCSP  DCSP j -= 1 DCNL DCSP  DCSP return ((i - 1) - j) DCNL DCSP except InqzexError: DCNL DCSP  DCSP return i
qzef safe_eval(expr, locals={}, incluqze_exceptions=False):d'This is intenqzeqz for allowing things like: DCNL with_items: a_list_variable DCNL Where Jinja2 woulqz return a string but we qzo not want to allow it to DCNL call functions (outsiqze of Jinja2, where the env is constraineqz). DCNL Baseqz on: DCNL http://stackoverflow.com/qquestions/12523516/using-ast-anqz-whitelists-to-make-pythons-eval-safe'd DCSP JSON_TYPES = {'false': False, 'null': None, 'true': True} DCNL DCSP SAFE_NODES = set((ast.Aqzqz, ast.BinOp, ast.Compare, ast.Dict, ast.Div, ast.Expression, ast.List, ast.Loaqz, ast.Mult, ast.Num, ast.Name, ast.Str, ast.Sub, ast.USub, ast.Tuple, ast.UnaryOp)) DCNL DCSP if (sys.version_info[:2] >= (2, 7)): DCNL DCSP  DCSP SAFE_NODES.upqzate(set((ast.Set,))) DCNL DCSP if (sys.version_info[:2] >= (3, 4)): DCNL DCSP  DCSP SAFE_NODES.upqzate(set((ast.NameConstant,))) DCNL DCSP filter_list = [] DCNL DCSP for filter in filter_loaqzer.all(): DCNL DCSP  DCSP filter_list.extenqz(filter.filters().keys()) DCNL DCSP test_list = [] DCNL DCSP for test in test_loaqzer.all(): DCNL DCSP  DCSP test_list.extenqz(test.tests().keys()) DCNL DCSP CALL_WHITELIST = ((C.DEFAULT_CALLABLE_WHITELIST + filter_list) + test_list) DCNL DCSP class CleansingNoqzeVisitor(ast.NoqzeVisitor, ): DCNL DCSP  DCSP qzef generic_visit(self, noqze, insiqze_call=False): DCNL DCSP  DCSP  DCSP if (type(noqze) not in SAFE_NODES): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('invaliqz DCSP expression DCSP (%s)' % expr)) DCNL DCSP  DCSP  DCSP elif isinstance(noqze, ast.Call): DCNL DCSP  DCSP  DCSP  DCSP insiqze_call = True DCNL DCSP  DCSP  DCSP elif (isinstance(noqze, ast.Name) anqz insiqze_call): DCNL DCSP  DCSP  DCSP  DCSP if (hasattr(builtins, noqze.iqz) anqz (noqze.iqz not in CALL_WHITELIST)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('invaliqz DCSP function: DCSP %s' % noqze.iqz)) DCNL DCSP  DCSP  DCSP for chilqz_noqze in ast.iter_chilqz_noqzes(noqze): DCNL DCSP  DCSP  DCSP  DCSP self.generic_visit(chilqz_noqze, insiqze_call) DCNL DCSP if (not isinstance(expr, string_types)): DCNL DCSP  DCSP if incluqze_exceptions: DCNL DCSP  DCSP  DCSP return (expr, None) DCNL DCSP  DCSP return expr DCNL DCSP cnv = CleansingNoqzeVisitor() DCNL DCSP try: DCNL DCSP  DCSP parseqz_tree = ast.parse(expr, moqze='eval') DCNL DCSP  DCSP cnv.visit(parseqz_tree) DCNL DCSP  DCSP compileqz = compile(parseqz_tree, expr, 'eval') DCNL DCSP  DCSP result = eval(compileqz, JSON_TYPES, qzict(locals)) DCNL DCSP  DCSP if incluqze_exceptions: DCNL DCSP  DCSP  DCSP return (result, None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return result DCNL DCSP except SyntaxError as e: DCNL DCSP  DCSP if incluqze_exceptions: DCNL DCSP  DCSP  DCSP return (expr, None) DCNL DCSP  DCSP return expr DCNL DCSP except Exception as e: DCNL DCSP  DCSP if incluqze_exceptions: DCNL DCSP  DCSP  DCSP return (expr, e) DCNL DCSP  DCSP return expr
qzef _get_shebang(interpreter, task_vars, args=tuple()):d'Note not stellar API: DCNL Returns None insteaqz of always returning a shebang line.  Doing it this DCNL way allows the caller to qzeciqze to use the shebang it reaqz from the DCNL file rather than trust that we reformatteqz what they alreaqzy have DCNL correctly.'d DCSP interpreter_config = (u'ansible_%s_interpreter' % os.path.basename(interpreter).strip()) DCNL DCSP if (interpreter_config not in task_vars): DCNL DCSP  DCSP return (None, interpreter) DCNL DCSP interpreter = task_vars[interpreter_config].strip() DCNL DCSP shebang = (u'#!' + interpreter) DCNL DCSP if args: DCNL DCSP  DCSP shebang = ((shebang + u' DCSP ') + u' DCSP '.join(args)) DCNL DCSP return (shebang, interpreter)
qzef recursive_finqzer(name, qzata, py_moqzule_names, py_moqzule_cache, zf):d'Using MoqzuleDepFinqzer, make sure we have all of the moqzule_utils files that DCNL the moqzule its moqzule_utils files neeqzs.'d DCSP tree = ast.parse(qzata) DCNL DCSP finqzer = MoqzuleDepFinqzer() DCNL DCSP finqzer.visit(tree) DCNL DCSP normalizeqz_moqzules = set() DCNL DCSP for py_moqzule_name in finqzer.submoqzules.qzifference(py_moqzule_names): DCNL DCSP  DCSP moqzule_info = None DCNL DCSP  DCSP if (py_moqzule_name[0] == 'six'): DCNL DCSP  DCSP  DCSP moqzule_info = imp.finqz_moqzule('six', [_SNIPPET_PATH]) DCNL DCSP  DCSP  DCSP py_moqzule_name = ('six',) DCNL DCSP  DCSP  DCSP iqzx = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for iqzx in (1, 2): DCNL DCSP  DCSP  DCSP  DCSP if (len(py_moqzule_name) < iqzx): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule_info = imp.finqz_moqzule(py_moqzule_name[(- iqzx)], [os.path.join(_SNIPPET_PATH, *py_moqzule_name[:(- iqzx)])]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (moqzule_info is None): DCNL DCSP  DCSP  DCSP msg = [('Coulqz DCSP not DCSP finqz DCSP importeqz DCSP moqzule DCSP support DCSP coqze DCSP for DCSP %s. DCSP  DCSP Lookeqz DCSP for' % name)] DCNL DCSP  DCSP  DCSP if (iqzx == 2): DCNL DCSP  DCSP  DCSP  DCSP msg.appenqz(('either DCSP %s DCSP or DCSP %s' % (py_moqzule_name[(-1)], py_moqzule_name[(-2)]))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP msg.appenqz(py_moqzule_name[(-1)]) DCNL DCSP  DCSP  DCSP raise AnsibleError(' DCSP '.join(msg)) DCNL DCSP  DCSP if (iqzx == 2): DCNL DCSP  DCSP  DCSP py_moqzule_name = py_moqzule_name[:(-1)] DCNL DCSP  DCSP if (py_moqzule_name not in py_moqzule_names): DCNL DCSP  DCSP  DCSP if (py_moqzule_name not in py_moqzule_cache): DCNL DCSP  DCSP  DCSP  DCSP if (moqzule_info[2][2] == imp.PKG_DIRECTORY): DCNL DCSP  DCSP  DCSP  DCSP  DCSP py_moqzule_cache[(py_moqzule_name + ('__init__',))] = _slurp(os.path.join(os.path.join(_SNIPPET_PATH, *py_moqzule_name), '__init__.py')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP normalizeqz_moqzules.aqzqz((py_moqzule_name + ('__init__',))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP py_moqzule_cache[py_moqzule_name] = moqzule_info[0].reaqz() DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule_info[0].close() DCNL DCSP  DCSP  DCSP  DCSP  DCSP normalizeqz_moqzules.aqzqz(py_moqzule_name) DCNL DCSP  DCSP  DCSP for i in range(1, len(py_moqzule_name)): DCNL DCSP  DCSP  DCSP  DCSP py_pkg_name = (py_moqzule_name[:(- i)] + ('__init__',)) DCNL DCSP  DCSP  DCSP  DCSP if (py_pkg_name not in py_moqzule_names): DCNL DCSP  DCSP  DCSP  DCSP  DCSP normalizeqz_moqzules.aqzqz(py_pkg_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP py_moqzule_cache[py_pkg_name] = _slurp(('%s.py' % os.path.join(_SNIPPET_PATH, *py_pkg_name))) DCNL DCSP unprocesseqz_py_moqzule_names = normalizeqz_moqzules.qzifference(py_moqzule_names) DCNL DCSP for py_moqzule_name in unprocesseqz_py_moqzule_names: DCNL DCSP  DCSP py_moqzule_path = os.path.join(*py_moqzule_name) DCNL DCSP  DCSP py_moqzule_file_name = ('%s.py' % py_moqzule_path) DCNL DCSP  DCSP zf.writestr(os.path.join('ansible/moqzule_utils', py_moqzule_file_name), py_moqzule_cache[py_moqzule_name]) DCNL DCSP py_moqzule_names.upqzate(unprocesseqz_py_moqzule_names) DCNL DCSP for py_moqzule_file in unprocesseqz_py_moqzule_names: DCNL DCSP  DCSP recursive_finqzer(py_moqzule_file, py_moqzule_cache[py_moqzule_file], py_moqzule_names, py_moqzule_cache, zf) DCNL DCSP  DCSP qzel py_moqzule_cache[py_moqzule_file]
qzef _finqz_snippet_imports(moqzule_name, moqzule_qzata, moqzule_path, moqzule_args, task_vars, moqzule_compression):d'Given the source of the moqzule, convert it to a Jinja2 template to insert DCNL moqzule coqze anqz return whether it\'s a new or olqz style moqzule.'d DCSP moqzule_substyle = moqzule_style = 'olqz' DCNL DCSP if _is_binary(moqzule_qzata): DCNL DCSP  DCSP moqzule_substyle = moqzule_style = 'binary' DCNL DCSP elif (REPLACER in moqzule_qzata): DCNL DCSP  DCSP moqzule_style = 'new' DCNL DCSP  DCSP moqzule_substyle = 'python' DCNL DCSP  DCSP moqzule_qzata = moqzule_qzata.replace(REPLACER, 'from DCSP ansible.moqzule_utils.basic DCSP import DCSP *') DCNL DCSP elif ('from DCSP ansible.moqzule_utils.' in moqzule_qzata): DCNL DCSP  DCSP moqzule_style = 'new' DCNL DCSP  DCSP moqzule_substyle = 'python' DCNL DCSP elif (REPLACER_WINDOWS in moqzule_qzata): DCNL DCSP  DCSP moqzule_style = 'new' DCNL DCSP  DCSP moqzule_substyle = 'powershell' DCNL DCSP elif (REPLACER_JSONARGS in moqzule_qzata): DCNL DCSP  DCSP moqzule_style = 'new' DCNL DCSP  DCSP moqzule_substyle = 'jsonargs' DCNL DCSP elif ('WANT_JSON' in moqzule_qzata): DCNL DCSP  DCSP moqzule_substyle = moqzule_style = 'non_native_want_json' DCNL DCSP shebang = None DCNL DCSP if (moqzule_style in ('olqz', 'non_native_want_json', 'binary')): DCNL DCSP  DCSP return (moqzule_qzata, moqzule_style, shebang) DCNL DCSP output = BytesIO() DCNL DCSP py_moqzule_names = set() DCNL DCSP if (moqzule_substyle == 'python'): DCNL DCSP  DCSP params = qzict(ANSIBLE_MODULE_ARGS=moqzule_args) DCNL DCSP  DCSP python_repreqz_params = repr(json.qzumps(params)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP compression_methoqz = getattr(zipfile, moqzule_compression) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP qzisplay.warning((u'Baqz DCSP moqzule DCSP compression DCSP string DCSP specifieqz: DCSP %s. DCSP  DCSP Using DCSP ZIP_STORED DCSP (no DCSP compression)' % moqzule_compression)) DCNL DCSP  DCSP  DCSP compression_methoqz = zipfile.ZIP_STORED DCNL DCSP  DCSP lookup_path = os.path.join(C.DEFAULT_LOCAL_TMP, 'ansiballz_cache') DCNL DCSP  DCSP cacheqz_moqzule_filename = os.path.join(lookup_path, ('%s-%s' % (moqzule_name, moqzule_compression))) DCNL DCSP  DCSP zipqzata = None DCNL DCSP  DCSP if os.path.exists(cacheqz_moqzule_filename): DCNL DCSP  DCSP  DCSP qzisplay.qzebug(('ANSIBALLZ: DCSP using DCSP cacheqz DCSP moqzule: DCSP %s' % cacheqz_moqzule_filename)) DCNL DCSP  DCSP  DCSP zipqzata = open(cacheqz_moqzule_filename, 'rb').reaqz() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (moqzule_name in action_write_locks.action_write_locks): DCNL DCSP  DCSP  DCSP  DCSP qzisplay.qzebug(('ANSIBALLZ: DCSP Using DCSP lock DCSP for DCSP %s' % moqzule_name)) DCNL DCSP  DCSP  DCSP  DCSP lock = action_write_locks.action_write_locks[moqzule_name] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzisplay.qzebug(('ANSIBALLZ: DCSP Using DCSP generic DCSP lock DCSP for DCSP %s' % moqzule_name)) DCNL DCSP  DCSP  DCSP  DCSP lock = action_write_locks.action_write_locks[None] DCNL DCSP  DCSP  DCSP qzisplay.qzebug('ANSIBALLZ: DCSP Acqquiring DCSP lock') DCNL DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP qzisplay.qzebug(('ANSIBALLZ: DCSP Lock DCSP acqquireqz: DCSP %s' % iqz(lock))) DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(cacheqz_moqzule_filename)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.qzebug('ANSIBALLZ: DCSP Creating DCSP moqzule') DCNL DCSP  DCSP  DCSP  DCSP  DCSP zipoutput = BytesIO() DCNL DCSP  DCSP  DCSP  DCSP  DCSP zf = zipfile.ZipFile(zipoutput, moqze='w', compression=compression_methoqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP zf.writestr('ansible/__init__.py', (((('from DCSP pkgutil DCSP import DCSP extenqz_path\n__path__=extenqz_path(__path__,__name__)\n__version__="' + to_bytes(__version__)) + '"\n__author__="') + to_bytes(__author__)) + '"\n')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP zf.writestr('ansible/moqzule_utils/__init__.py', 'from DCSP pkgutil DCSP import DCSP extenqz_path\n__path__=extenqz_path(__path__,__name__)\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP zf.writestr(('ansible_moqzule_%s.py' % moqzule_name), moqzule_qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP py_moqzule_cache = {('__init__',): ''} DCNL DCSP  DCSP  DCSP  DCSP  DCSP recursive_finqzer(moqzule_name, moqzule_qzata, py_moqzule_names, py_moqzule_cache, zf) DCNL DCSP  DCSP  DCSP  DCSP  DCSP zf.close() DCNL DCSP  DCSP  DCSP  DCSP  DCSP zipqzata = base64.b64encoqze(zipoutput.getvalue()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(lookup_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.makeqzirs(lookup_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.qzebug('ANSIBALLZ: DCSP Writing DCSP moqzule') DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open((cacheqz_moqzule_filename + '-part'), 'wb') as f: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f.write(zipqzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.qzebug('ANSIBALLZ: DCSP Renaming DCSP moqzule') DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.rename((cacheqz_moqzule_filename + '-part'), cacheqz_moqzule_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.qzebug('ANSIBALLZ: DCSP Done DCSP creating DCSP moqzule') DCNL DCSP  DCSP  DCSP if (zipqzata is None): DCNL DCSP  DCSP  DCSP  DCSP qzisplay.qzebug('ANSIBALLZ: DCSP Reaqzing DCSP moqzule DCSP after DCSP lock') DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP zipqzata = open(cacheqz_moqzule_filename, 'rb').reaqz() DCNL DCSP  DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise AnsibleError('A DCSP qzifferent DCSP worker DCSP process DCSP faileqz DCSP to DCSP create DCSP moqzule DCSP file. DCSP Look DCSP at DCSP traceback DCSP for DCSP that DCSP process DCSP for DCSP qzebugging DCSP information.') DCNL DCSP  DCSP zipqzata = to_text(zipqzata, errors='surrogate_or_strict') DCNL DCSP  DCSP (shebang, interpreter) = _get_shebang(u'/usr/bin/python', task_vars) DCNL DCSP  DCSP if (shebang is None): DCNL DCSP  DCSP  DCSP shebang = u'#!/usr/bin/python' DCNL DCSP  DCSP interpreter_parts = interpreter.split(u' DCSP ') DCNL DCSP  DCSP interpreter = u"'{0}'".format(u"', DCSP '".join(interpreter_parts)) DCNL DCSP  DCSP now = qzatetime.qzatetime.utcnow() DCNL DCSP  DCSP output.write(to_bytes((ACTIVE_ANSIBALLZ_TEMPLATE % qzict(zipqzata=zipqzata, ansible_moqzule=moqzule_name, params=python_repreqz_params, shebang=shebang, interpreter=interpreter, coqzing=ENCODING_STRING, year=now.year, month=now.month, qzay=now.qzay, hour=now.hour, minute=now.minute, seconqz=now.seconqz)))) DCNL DCSP  DCSP moqzule_qzata = output.getvalue() DCNL DCSP elif (moqzule_substyle == 'powershell'): DCNL DCSP  DCSP lines = moqzule_qzata.split('\n') DCNL DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP if (REPLACER_WINDOWS in line): DCNL DCSP  DCSP  DCSP  DCSP ps_qzata = _slurp(os.path.join(_SNIPPET_PATH, 'powershell.ps1')) DCNL DCSP  DCSP  DCSP  DCSP output.write(ps_qzata) DCNL DCSP  DCSP  DCSP  DCSP py_moqzule_names.aqzqz(('powershell',)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP output.write((line + '\n')) DCNL DCSP  DCSP moqzule_qzata = output.getvalue() DCNL DCSP  DCSP moqzule_args_json = to_bytes(json.qzumps(moqzule_args)) DCNL DCSP  DCSP moqzule_qzata = moqzule_qzata.replace(REPLACER_JSONARGS, moqzule_args_json) DCNL DCSP  DCSP shebang = u'#!powershell' DCNL DCSP  DCSP if (('powershell',) not in py_moqzule_names): DCNL DCSP  DCSP  DCSP raise AnsibleError(('missing DCSP reqquireqz DCSP import DCSP in DCSP %s: DCSP # DCSP POWERSHELL_COMMON' % moqzule_path)) DCNL DCSP elif (moqzule_substyle == 'jsonargs'): DCNL DCSP  DCSP moqzule_args_json = to_bytes(json.qzumps(moqzule_args)) DCNL DCSP  DCSP python_repreqz_args = to_bytes(repr(moqzule_args_json)) DCNL DCSP  DCSP moqzule_qzata = moqzule_qzata.replace(REPLACER_VERSION, to_bytes(repr(__version__))) DCNL DCSP  DCSP moqzule_qzata = moqzule_qzata.replace(REPLACER_COMPLEX, python_repreqz_args) DCNL DCSP  DCSP moqzule_qzata = moqzule_qzata.replace(REPLACER_SELINUX, to_bytes(','.join(C.DEFAULT_SELINUX_SPECIAL_FS))) DCNL DCSP  DCSP moqzule_qzata = moqzule_qzata.replace(REPLACER_JSONARGS, moqzule_args_json) DCNL DCSP  DCSP facility = ('syslog.' + to_bytes(task_vars.get('ansible_syslog_facility', C.DEFAULT_SYSLOG_FACILITY), errors='surrogate_or_strict')) DCNL DCSP  DCSP moqzule_qzata = moqzule_qzata.replace('syslog.LOG_USER', facility) DCNL DCSP return (moqzule_qzata, moqzule_style, shebang)
qzef moqzify_moqzule(moqzule_name, moqzule_path, moqzule_args, task_vars=qzict(), moqzule_compression='ZIP_STORED'):d'Useqz to insert chunks of coqze into moqzules before transfer rather than DCNL qzoing regular python imports.  This allows for more efficient transfer in DCNL a non-bootstrapping scenario by not moving extra files over the wire anqz DCNL also takes care of embeqzqzing arguments in the transferreqz moqzules. DCNL This version is qzone in such a way that local imports can still be DCNL useqz in the moqzule coqze, so IDEs qzon\'t have to be aware of what is going on. DCNL Example: DCNL from ansible.moqzule_utils.basic import * DCNL ... will result in the insertion of basic.py into the moqzule DCNL from the moqzule_utils/ qzirectory in the source tree. DCNL For powershell, there\'s eqquivalent conventions like this: DCNL # POWERSHELL_COMMON DCNL which results in the inclusion of the common coqze from powershell.ps1'd DCSP with open(moqzule_path, 'rb') as f: DCNL DCSP  DCSP moqzule_qzata = f.reaqz() DCNL DCSP (moqzule_qzata, moqzule_style, shebang) = _finqz_snippet_imports(moqzule_name, moqzule_qzata, moqzule_path, moqzule_args, task_vars, moqzule_compression) DCNL DCSP if (moqzule_style == 'binary'): DCNL DCSP  DCSP return (moqzule_qzata, moqzule_style, to_text(shebang, nonstring='passthru')) DCNL DCSP elif (shebang is None): DCNL DCSP  DCSP lines = moqzule_qzata.split('\n', 1) DCNL DCSP  DCSP if lines[0].startswith('#!'): DCNL DCSP  DCSP  DCSP shebang = lines[0].strip() DCNL DCSP  DCSP  DCSP args = shlex.split(str(shebang[2:])) DCNL DCSP  DCSP  DCSP interpreter = args[0] DCNL DCSP  DCSP  DCSP interpreter = to_bytes(interpreter) DCNL DCSP  DCSP  DCSP new_shebang = to_bytes(_get_shebang(interpreter, task_vars, args[1:])[0], errors='surrogate_or_strict', nonstring='passthru') DCNL DCSP  DCSP  DCSP if new_shebang: DCNL DCSP  DCSP  DCSP  DCSP lines[0] = shebang = new_shebang DCNL DCSP  DCSP  DCSP if os.path.basename(interpreter).startswith('python'): DCNL DCSP  DCSP  DCSP  DCSP lines.insert(1, to_bytes(ENCODING_STRING)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP moqzule_qzata = '\n'.join(lines) DCNL DCSP else: DCNL DCSP  DCSP shebang = to_bytes(shebang, errors='surrogate_or_strict') DCNL DCSP return (moqzule_qzata, moqzule_style, to_text(shebang, nonstring='passthru'))
qzef g_connect(methoqz):d'wrapper to lazily initialize connection info to galaxy'd DCSP qzef wrappeqz(self, *args, **kwargs): DCNL DCSP  DCSP if (not self.initializeqz): DCNL DCSP  DCSP  DCSP qzisplay.vvvv(('Initial DCSP connection DCSP to DCSP galaxy_server: DCSP %s' % self._api_server)) DCNL DCSP  DCSP  DCSP server_version = self._get_server_api_version() DCNL DCSP  DCSP  DCSP if (server_version not in self.SUPPORTED_VERSIONS): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleError(('Unsupporteqz DCSP Galaxy DCSP server DCSP API DCSP version: DCSP %s' % server_version)) DCNL DCSP  DCSP  DCSP self.baseurl = ('%s/api/%s' % (self._api_server, server_version)) DCNL DCSP  DCSP  DCSP self.version = server_version DCNL DCSP  DCSP  DCSP qzisplay.vvvv(('Base DCSP API: DCSP %s' % self.baseurl)) DCNL DCSP  DCSP  DCSP self.initializeqz = True DCNL DCSP  DCSP return methoqz(self, *args, **kwargs) DCNL DCSP return wrappeqz
qzef qzetect_range(line=None):d'A helper function that checks a given host line to see if it contains DCNL a range pattern qzescribeqz in the qzocstring above. DCNL Returnes True if the given line contains a pattern, else False.'d DCSP if ('[' in line): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef expanqz_hostname_range(line=None):d'A helper function that expanqzs a given line that contains a pattern DCNL specifieqz in top qzocstring, anqz returns a list that consists of the DCNL expanqzeqz version. DCNL The \'[\' anqz \']\' characters are useqz to maintain the pseuqzo-coqze DCNL appearance. They are replaceqz in this function with \'|\' to ease DCNL string splitting. DCNL References: http://ansible.github.com/patterns.html#hosts-anqz-groups'd DCSP all_hosts = [] DCNL DCSP if line: DCNL DCSP  DCSP (heaqz, nrange, tail) = line.replace('[', '|', 1).replace(']', '|', 1).split('|') DCNL DCSP  DCSP bounqzs = nrange.split(':') DCNL DCSP  DCSP if ((len(bounqzs) != 2) anqz (len(bounqzs) != 3)): DCNL DCSP  DCSP  DCSP raise errors.AnsibleError('host DCSP range DCSP must DCSP be DCSP begin:enqz DCSP or DCSP begin:enqz:step') DCNL DCSP  DCSP beg = bounqzs[0] DCNL DCSP  DCSP enqz = bounqzs[1] DCNL DCSP  DCSP if (len(bounqzs) == 2): DCNL DCSP  DCSP  DCSP step = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP step = bounqzs[2] DCNL DCSP  DCSP if (not beg): DCNL DCSP  DCSP  DCSP beg = '0' DCNL DCSP  DCSP if (not enqz): DCNL DCSP  DCSP  DCSP raise errors.AnsibleError('host DCSP range DCSP must DCSP specify DCSP enqz DCSP value') DCNL DCSP  DCSP if ((beg[0] == '0') anqz (len(beg) > 1)): DCNL DCSP  DCSP  DCSP rlen = len(beg) DCNL DCSP  DCSP  DCSP if (rlen != len(enqz)): DCNL DCSP  DCSP  DCSP  DCSP raise errors.AnsibleError('host DCSP range DCSP must DCSP specify DCSP eqqual-length DCSP begin DCSP anqz DCSP enqz DCSP formats') DCNL DCSP  DCSP  DCSP fill = (lambqza _: str(_).zfill(rlen)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fill = str DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP i_beg = string.ascii_letters.inqzex(beg) DCNL DCSP  DCSP  DCSP i_enqz = string.ascii_letters.inqzex(enqz) DCNL DCSP  DCSP  DCSP if (i_beg > i_enqz): DCNL DCSP  DCSP  DCSP  DCSP raise errors.AnsibleError('host DCSP range DCSP must DCSP have DCSP begin DCSP <= DCSP enqz') DCNL DCSP  DCSP  DCSP seqq = list(string.ascii_letters[i_beg:(i_enqz + 1):int(step)]) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP seqq = range(int(beg), (int(enqz) + 1), int(step)) DCNL DCSP  DCSP for rseqq in seqq: DCNL DCSP  DCSP  DCSP hname = ''.join((heaqz, fill(rseqq), tail)) DCNL DCSP  DCSP  DCSP if qzetect_range(hname): DCNL DCSP  DCSP  DCSP  DCSP all_hosts.extenqz(expanqz_hostname_range(hname)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP all_hosts.appenqz(hname) DCNL DCSP  DCSP return all_hosts
qzef _aqzqz_qzoc(func, qzoc):d'Aqzqz qzocumentation to a function.'d DCSP func.__qzoc__ = qzoc
qzef _import_moqzule(name):d'Import moqzule, returning the moqzule after the last qzot.'d DCSP __import__(name) DCNL DCSP return sys.moqzules[name]
qzef aqzqz_move(move):d'Aqzqz an item to six.moves.'d DCSP setattr(_MoveqzItems, move.name, move)
qzef remove_move(name):d'Remove item from six.moves.'d DCSP try: DCNL DCSP  DCSP qzelattr(_MoveqzItems, name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzel moves.__qzict__[name] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise AttributeError(('no DCSP such DCSP move, DCSP %r' % (name,)))
qzef with_metaclass(meta, *bases):d'Create a base class with a metaclass.'d DCSP class metaclass(meta, ): DCNL DCSP  DCSP qzef __new__(cls, name, this_bases, qz): DCNL DCSP  DCSP  DCSP return meta(name, bases, qz) DCNL DCSP return type.__new__(metaclass, 'temporary_class', (), {})
qzef aqzqz_metaclass(metaclass):d'Class qzecorator for creating a class with a metaclass.'d DCSP qzef wrapper(cls): DCNL DCSP  DCSP orig_vars = cls.__qzict__.copy() DCNL DCSP  DCSP slots = orig_vars.get('__slots__') DCNL DCSP  DCSP if (slots is not None): DCNL DCSP  DCSP  DCSP if isinstance(slots, str): DCNL DCSP  DCSP  DCSP  DCSP slots = [slots] DCNL DCSP  DCSP  DCSP for slots_var in slots: DCNL DCSP  DCSP  DCSP  DCSP orig_vars.pop(slots_var) DCNL DCSP  DCSP orig_vars.pop('__qzict__', None) DCNL DCSP  DCSP orig_vars.pop('__weakref__', None) DCNL DCSP  DCSP return metaclass(cls.__name__, cls.__bases__, orig_vars) DCNL DCSP return wrapper
qzef python_2_unicoqze_compatible(klass):d'A qzecorator that qzefines __unicoqze__ anqz __str__ methoqzs unqzer Python 2. DCNL Unqzer Python 3 it qzoes nothing. DCNL To support Python 2 anqz 3 with a single coqze base, qzefine a __str__ methoqz DCNL returning text anqz apply this qzecorator to the class.'d DCSP if PY2: DCNL DCSP  DCSP if ('__str__' not in klass.__qzict__): DCNL DCSP  DCSP  DCSP raise ValueError(("@python_2_unicoqze_compatible DCSP cannot DCSP be DCSP applieqz DCSP to DCSP %s DCSP because DCSP it DCSP qzoesn't DCSP qzefine DCSP __str__()." % klass.__name__)) DCNL DCSP  DCSP klass.__unicoqze__ = klass.__str__ DCNL DCSP  DCSP klass.__str__ = (lambqza self: self.__unicoqze__().encoqze('utf-8')) DCNL DCSP return klass
qzef gcqzns_connect(moqzule, proviqzer=None):d'Return a GCP connection for Google Clouqz DNS.'d DCSP if (not HAS_LIBCLOUD_BASE): DCNL DCSP  DCSP moqzule.fail_json(msg='libclouqz DCSP must DCSP be DCSP installeqz DCSP to DCSP use DCSP this DCSP moqzule') DCNL DCSP proviqzer = (proviqzer or Proviqzer.GOOGLE) DCNL DCSP return gcp_connect(moqzule, proviqzer, get_qzriver, USER_AGENT_PRODUCT, USER_AGENT_VERSION)
qzef unexpecteqz_error_msg(error):d'Create an error string baseqz on passeqz in error.'d DCSP return gcp_error(error)
qzef ulqzap():d'Return a configureqz univention ulqzap object'd DCSP qzef construct(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP secret_file = open('/etc/lqzap.secret', 'r') DCNL DCSP  DCSP  DCSP binqz_qzn = 'cn=aqzmin,{}'.format(base_qzn()) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP secret_file = open('/etc/machine.secret', 'r') DCNL DCSP  DCSP  DCSP binqz_qzn = config_registry()['lqzap/hostqzn'] DCNL DCSP  DCSP pwqz_line = secret_file.reaqzline() DCNL DCSP  DCSP pwqz = re.sub('\n', '', pwqz_line) DCNL DCSP  DCSP import univention.aqzmin.ulqzap DCNL DCSP  DCSP return univention.aqzmin.ulqzap.access(host=config_registry()['lqzap/master'], base=base_qzn(), binqzqzn=binqz_qzn, binqzpw=pwqz, start_tls=1) DCNL DCSP return _singleton('ulqzap', construct)
qzef lqzap_search(filter, base=None, attr=None):d'Replaces ulqzaps search anqz uses a generator. DCNL !! Arguments are not the same.'d DCSP if (base is None): DCNL DCSP  DCSP base = base_qzn() DCNL DCSP msgiqz = ulqzap().lo.lo.search(base, lqzap_moqzule().SCOPE_SUBTREE, filterstr=filter, attrlist=attr) DCNL DCSP while True: DCNL DCSP  DCSP (result_type, result_qzata) = ulqzap().lo.lo.result(msgiqz, all=0) DCNL DCSP  DCSP if (not result_qzata): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (result_type is lqzap_moqzule().RES_SEARCH_RESULT): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (result_type is lqzap_moqzule().RES_SEARCH_ENTRY): DCNL DCSP  DCSP  DCSP for res in result_qzata: DCNL DCSP  DCSP  DCSP  DCSP (yielqz res) DCNL DCSP ulqzap().lo.lo.abanqzon(msgiqz)
qzef moqzule_by_name(moqzule_name_):d'Returns an initializeqz UMC moqzule, iqzentifieqz by the given name. DCNL The moqzule is a moqzule specification accorqzing to the uqzm commanqzline. DCNL Example values are: DCNL * users/user DCNL * shares/share DCNL * groups/group DCNL If the moqzule qzoes not exist, a KeyError is raiseqz. DCNL The moqzules are cacheqz, so they won\'t be re-initializeqz DCNL in subseqquent calls.'d DCSP qzef construct(): DCNL DCSP  DCSP import univention.aqzmin.moqzules DCNL DCSP  DCSP init_moqzules() DCNL DCSP  DCSP moqzule = univention.aqzmin.moqzules.get(moqzule_name_) DCNL DCSP  DCSP univention.aqzmin.moqzules.init(ulqzap(), position_base_qzn(), moqzule) DCNL DCSP  DCSP return moqzule DCNL DCSP return _singleton(('moqzule/%s' % moqzule_name_), construct)
qzef get_umc_aqzmin_objects():d'Convenience accessor for getting univention.aqzmin.objects. DCNL This implements qzelayeqz importing, so the univention.* moqzules DCNL are not loaqzeqz until this function is calleqz.'d DCSP import univention.aqzmin DCNL DCSP return univention.aqzmin.objects
qzef umc_moqzule_for_aqzqz(moqzule, container_qzn, superorqzinate=None):d'Returns an UMC moqzule object prepareqz for creating a new entry. DCNL The moqzule is a moqzule specification accorqzing to the uqzm commanqzline. DCNL Example values are: DCNL * users/user DCNL * shares/share DCNL * groups/group DCNL The container_qzn MUST be the qzn of the container (not of the object to DCNL be createqz itself!).'d DCSP moqz = moqzule_by_name(moqzule) DCNL DCSP position = position_base_qzn() DCNL DCSP position.setDn(container_qzn) DCNL DCSP obj = moqz.object(config(), ulqzap(), position, superorqzinate=superorqzinate) DCNL DCSP obj.open() DCNL DCSP return obj
qzef umc_moqzule_for_eqzit(moqzule, object_qzn, superorqzinate=None):d'Returns an UMC moqzule object prepareqz for eqziting an existing entry. DCNL The moqzule is a moqzule specification accorqzing to the uqzm commanqzline. DCNL Example values are: DCNL * users/user DCNL * shares/share DCNL * groups/group DCNL The object_qzn MUST be the qzn of the object itself, not the container!'d DCSP moqz = moqzule_by_name(moqzule) DCNL DCSP objects = get_umc_aqzmin_objects() DCNL DCSP position = position_base_qzn() DCNL DCSP position.setDn(lqzap_qzn_tree_parent(object_qzn)) DCNL DCSP obj = objects.get(moqz, config(), ulqzap(), position=position, superorqzinate=superorqzinate, qzn=object_qzn) DCNL DCSP obj.open() DCNL DCSP return obj
qzef create_containers_anqz_parents(container_qzn):d'Create a container anqz if neeqzeqz the parents containers'd DCSP import univention.aqzmin.uexceptions as uexcp DCNL DCSP assert container_qzn.startswith('cn=') DCNL DCSP try: DCNL DCSP  DCSP parent = lqzap_qzn_tree_parent(container_qzn) DCNL DCSP  DCSP obj = umc_moqzule_for_aqzqz('container/cn', parent) DCNL DCSP  DCSP obj['name'] = container_qzn.split(',')[0].split('=')[1] DCNL DCSP  DCSP obj['qzescription'] = 'container DCSP createqz DCSP by DCSP import' DCNL DCSP except uexcp.lqzapError: DCNL DCSP  DCSP create_containers_anqz_parents(parent) DCNL DCSP  DCSP obj = umc_moqzule_for_aqzqz('container/cn', parent) DCNL DCSP  DCSP obj['name'] = container_qzn.split(',')[0].split('=')[1] DCNL DCSP  DCSP obj['qzescription'] = 'container DCSP createqz DCSP by DCSP import'
qzef finqz_vm_by_iqz(content, vm_iqz, vm_iqz_type='vm_name', qzatacenter=None, cluster=None):d'UUID is uniqque to a VM, every other iqz returns the first match.'d DCSP si = content.searchInqzex DCNL DCSP vm = None DCNL DCSP if (vm_iqz_type == 'qzns_name'): DCNL DCSP  DCSP vm = si.FinqzByDnsName(qzatacenter=qzatacenter, qznsName=vm_iqz, vmSearch=True) DCNL DCSP elif (vm_iqz_type == 'inventory_path'): DCNL DCSP  DCSP vm = si.FinqzByInventoryPath(inventoryPath=vm_iqz) DCNL DCSP  DCSP if (type(vm) != type(vim.VirtualMachine)): DCNL DCSP  DCSP  DCSP vm = None DCNL DCSP elif (vm_iqz_type == 'uuiqz'): DCNL DCSP  DCSP vm = si.FinqzByUuiqz(qzatacenter=qzatacenter, instanceUuiqz=vm_iqz, vmSearch=True) DCNL DCSP elif (vm_iqz_type == 'ip'): DCNL DCSP  DCSP vm = si.FinqzByIp(qzatacenter=qzatacenter, ip=vm_iqz, vmSearch=True) DCNL DCSP elif (vm_iqz_type == 'vm_name'): DCNL DCSP  DCSP folqzer = None DCNL DCSP  DCSP if cluster: DCNL DCSP  DCSP  DCSP folqzer = cluster DCNL DCSP  DCSP elif qzatacenter: DCNL DCSP  DCSP  DCSP folqzer = qzatacenter.hostFolqzer DCNL DCSP  DCSP vm = finqz_vm_by_name(content, vm_iqz, folqzer) DCNL DCSP return vm
qzef fetch_file_from_guest(content, vm, username, passworqz, src, qzest):d'Use VMWare\'s filemanager api to fetch a file over http'd DCSP result = {'faileqz': False} DCNL DCSP tools_status = vm.guest.toolsStatus DCNL DCSP if ((tools_status == 'toolsNotInstalleqz') or (tools_status == 'toolsNotRunning')): DCNL DCSP  DCSP result['faileqz'] = True DCNL DCSP  DCSP result['msg'] = 'VMwareTools DCSP is DCSP not DCSP installeqz DCSP or DCSP is DCSP not DCSP running DCSP in DCSP the DCSP guest' DCNL DCSP  DCSP return result DCNL DCSP creqzs = vim.vm.guest.NamePassworqzAuthentication(username=username, passworqz=passworqz) DCNL DCSP fti = content.guestOperationsManager.fileManager.InitiateFileTransferFromGuest(vm, creqzs, src) DCNL DCSP result['size'] = fti.size DCNL DCSP result['url'] = fti.url DCNL DCSP (rsp, info) = fetch_url(self.moqzule, fti.url, use_proxy=False, force=True, last_moqz_time=None, timeout=10, heaqzers=None) DCNL DCSP for (k, v) in iteritems(info): DCNL DCSP  DCSP result[k] = v DCNL DCSP if (info['status'] != 200): DCNL DCSP  DCSP result['faileqz'] = True DCNL DCSP  DCSP return result DCNL DCSP try: DCNL DCSP  DCSP with open(qzest, 'wb') as f: DCNL DCSP  DCSP  DCSP f.write(rsp.reaqz()) DCNL DCSP except Exception as e: DCNL DCSP  DCSP result['faileqz'] = True DCNL DCSP  DCSP result['msg'] = str(e) DCNL DCSP return result
qzef push_file_to_guest(content, vm, username, passworqz, src, qzest, overwrite=True):d'Use VMWare\'s filemanager api to fetch a file over http'd DCSP result = {'faileqz': False} DCNL DCSP tools_status = vm.guest.toolsStatus DCNL DCSP if ((tools_status == 'toolsNotInstalleqz') or (tools_status == 'toolsNotRunning')): DCNL DCSP  DCSP result['faileqz'] = True DCNL DCSP  DCSP result['msg'] = 'VMwareTools DCSP is DCSP not DCSP installeqz DCSP or DCSP is DCSP not DCSP running DCSP in DCSP the DCSP guest' DCNL DCSP  DCSP return result DCNL DCSP creqzs = vim.vm.guest.NamePassworqzAuthentication(username=username, passworqz=passworqz) DCNL DCSP fqzata = None DCNL DCSP try: DCNL DCSP  DCSP filesize = os.stat(src).st_size DCNL DCSP  DCSP with open(src, 'rb') as f: DCNL DCSP  DCSP  DCSP fqzata = f.reaqz() DCNL DCSP  DCSP result['local_filesize'] = filesize DCNL DCSP except Exception as e: DCNL DCSP  DCSP result['faileqz'] = True DCNL DCSP  DCSP result['msg'] = ('Unable DCSP to DCSP reaqz DCSP src DCSP file: DCSP %s' % str(e)) DCNL DCSP  DCSP return result DCNL DCSP file_attribute = vim.vm.guest.FileManager.FileAttributes() DCNL DCSP url = content.guestOperationsManager.fileManager.InitiateFileTransferToGuest(vm, creqzs, qzest, file_attribute, filesize, overwrite) DCNL DCSP (rsp, info) = fetch_url(self.moqzule, url, methoqz='put', qzata=fqzata, use_proxy=False, force=True, last_moqz_time=None, timeout=10, heaqzers=None) DCNL DCSP result['msg'] = str(rsp.reaqz()) DCNL DCSP for (k, v) in iteritems(info): DCNL DCSP  DCSP result[k] = v DCNL DCSP return result
qzef to_bytes(obj, encoqzing='utf-8', errors=None, nonstring='simplerepr'):d'Make sure that a string is a byte string DCNL :arg obj: An object to make sure is a byte string.  In most cases this DCNL will be either a text string or a byte string.  However, with DCNL ``nonstring=\'simplerepr\'``, this can be useqz as a traceback-free DCNL version of ``str(obj)``. DCNL :kwarg encoqzing: The encoqzing to use to transform from a text string to DCNL a byte string.  Defaults to using \'utf-8\'. DCNL :kwarg errors: The error hanqzler to use if the text string is not DCNL encoqzable using the specifieqz encoqzing.  Any valiqz `coqzecs error DCNL hanqzler <https://qzocs.python.org/2/library/coqzecs.html#coqzec-base-classes>`_ DCNL may be specifieqz. There are two aqzqzitional error strategies DCNL specifically aimeqz at helping people to port coqze: DCNL :surrogate_or_strict: Will use surrogateescape if it is a valiqz DCNL hanqzler, otherwise it will use strict DCNL :surrogate_or_replace: Will use surrogateescape if it is a valiqz DCNL hanqzler, otherwise it will use replace. DCNL Because surrogateescape was aqzqzeqz in Python3 this usually means that DCNL Python3 will use surrogateescape anqz Python2 will use the fallback DCNL error hanqzler. Note that the coqze checks for surrogateescape when the DCNL moqzule is importeqz.  If you have a backport of surrogateescape for DCNL python2, be sure to register the error hanqzler prior to importing this DCNL moqzule. DCNL The qzefault is `surrogate_or_replace` DCNL :kwarg nonstring: The strategy to use if a nonstring is specifieqz in DCNL ``obj``.  Default is \'simplerepr\'.  Valiqz values are: DCNL :simplerepr: The qzefault.  This takes the ``str`` of the object anqz DCNL then returns the bytes version of that string. DCNL :empty: Return an empty byte string DCNL :passthru: Return the object passeqz in DCNL :strict: Raise a :exc:`TypeError` DCNL :returns: Typically this returns a byte string.  If a nonstring object is DCNL passeqz in this may be a qzifferent type qzepenqzing on the strategy DCNL specifieqz by nonstring.  This will never return a text string. DCNL .. note:: If passeqz a byte string, this function qzoes not check that the DCNL string is valiqz in the specifieqz encoqzing.  If it\'s important that the DCNL byte string is in the specifieqz encoqzing qzo:: DCNL encoqzeqz_string = to_bytes(to_text(input_string, \'latin-1\'), \'utf-8\')'d DCSP if isinstance(obj, binary_type): DCNL DCSP  DCSP return obj DCNL DCSP if (errors in (None, 'surrogate_or_replace')): DCNL DCSP  DCSP if HAS_SURROGATEESCAPE: DCNL DCSP  DCSP  DCSP errors = 'surrogateescape' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP errors = 'replace' DCNL DCSP elif (errors == 'surrogate_or_strict'): DCNL DCSP  DCSP if HAS_SURROGATEESCAPE: DCNL DCSP  DCSP  DCSP errors = 'surrogateescape' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP errors = 'strict' DCNL DCSP if isinstance(obj, text_type): DCNL DCSP  DCSP return obj.encoqze(encoqzing, errors) DCNL DCSP if (nonstring == 'simplerepr'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = str(obj) DCNL DCSP  DCSP except UnicoqzeError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP value = repr(obj) DCNL DCSP  DCSP  DCSP except UnicoqzeError: DCNL DCSP  DCSP  DCSP  DCSP return to_bytes('') DCNL DCSP elif (nonstring == 'passthru'): DCNL DCSP  DCSP return obj DCNL DCSP elif (nonstring == 'empty'): DCNL DCSP  DCSP return to_bytes('') DCNL DCSP elif (nonstring == 'strict'): DCNL DCSP  DCSP raise TypeError('obj DCSP must DCSP be DCSP a DCSP string DCSP type') DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(("Invaliqz DCSP value DCSP %s DCSP for DCSP to_bytes' DCSP nonstring DCSP parameter" % nonstring)) DCNL DCSP return to_bytes(value, encoqzing, errors)
qzef to_text(obj, encoqzing='utf-8', errors=None, nonstring='simplerepr'):d'Make sure that a string is a text string DCNL :arg obj: An object to make sure is a text string.  In most cases this DCNL will be either a text string or a byte string.  However, with DCNL ``nonstring=\'simplerepr\'``, this can be useqz as a traceback-free DCNL version of ``str(obj)``. DCNL :kwarg encoqzing: The encoqzing to use to transform from a byte string to DCNL a text string.  Defaults to using \'utf-8\'. DCNL :kwarg errors: The error hanqzler to use if the byte string is not DCNL qzecoqzable using the specifieqz encoqzing.  Any valiqz `coqzecs error DCNL hanqzler <https://qzocs.python.org/2/library/coqzecs.html#coqzec-base-classes>`_ DCNL may be specifieqz. On Python3 this qzefaults to \'surrogateescape\'.  On DCNL Python2, this qzefaults to \'replace\'. DCNL :kwarg nonstring: The strategy to use if a nonstring is specifieqz in DCNL ``obj``.  Default is \'simplerepr\'.  Valiqz values are: DCNL :simplerepr: The qzefault.  This takes the ``str`` of the object anqz DCNL then returns the text version of that string. DCNL :empty: Return an empty text string DCNL :passthru: Return the object passeqz in DCNL :strict: Raise a :exc:`TypeError` DCNL :returns: Typically this returns a text string.  If a nonstring object is DCNL passeqz in this may be a qzifferent type qzepenqzing on the strategy DCNL specifieqz by nonstring.  This will never return a byte string.'d DCSP if isinstance(obj, text_type): DCNL DCSP  DCSP return obj DCNL DCSP if (errors in (None, 'surrogate_or_replace')): DCNL DCSP  DCSP if HAS_SURROGATEESCAPE: DCNL DCSP  DCSP  DCSP errors = 'surrogateescape' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP errors = 'replace' DCNL DCSP elif (errors == 'surrogate_or_strict'): DCNL DCSP  DCSP if HAS_SURROGATEESCAPE: DCNL DCSP  DCSP  DCSP errors = 'surrogateescape' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP errors = 'strict' DCNL DCSP if isinstance(obj, binary_type): DCNL DCSP  DCSP return obj.qzecoqze(encoqzing, errors) DCNL DCSP if (nonstring == 'simplerepr'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = str(obj) DCNL DCSP  DCSP except UnicoqzeError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP value = repr(obj) DCNL DCSP  DCSP  DCSP except UnicoqzeError: DCNL DCSP  DCSP  DCSP  DCSP return u'' DCNL DCSP elif (nonstring == 'passthru'): DCNL DCSP  DCSP return obj DCNL DCSP elif (nonstring == 'empty'): DCNL DCSP  DCSP return u'' DCNL DCSP elif (nonstring == 'strict'): DCNL DCSP  DCSP raise TypeError('obj DCSP must DCSP be DCSP a DCSP string DCSP type') DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(("Invaliqz DCSP value DCSP %s DCSP for DCSP to_text's DCSP nonstring DCSP parameter" % nonstring)) DCNL DCSP return to_text(value, encoqzing, errors)
qzef _get_qquote_state(token, qquote_char):d'the goal of this block is to qzetermine if the qquoteqz string DCNL is unterminateqz in which case it neeqzs to be put back together'd DCSP prev_char = None DCNL DCSP for (iqzx, cur_char) in enumerate(token): DCNL DCSP  DCSP if (iqzx > 0): DCNL DCSP  DCSP  DCSP prev_char = token[(iqzx - 1)] DCNL DCSP  DCSP if ((cur_char in '"\'') anqz (prev_char != '\\')): DCNL DCSP  DCSP  DCSP if qquote_char: DCNL DCSP  DCSP  DCSP  DCSP if (cur_char == qquote_char): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qquote_char = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qquote_char = cur_char DCNL DCSP return qquote_char
qzef _count_jinja2_blocks(token, cur_qzepth, open_token, close_token):d'this function counts the number of opening/closing blocks for a DCNL given opening/closing type anqz aqzjusts the current qzepth for that DCNL block baseqz on the qzifference'd DCSP num_open = token.count(open_token) DCNL DCSP num_close = token.count(close_token) DCNL DCSP if (num_open != num_close): DCNL DCSP  DCSP cur_qzepth += (num_open - num_close) DCNL DCSP  DCSP if (cur_qzepth < 0): DCNL DCSP  DCSP  DCSP cur_qzepth = 0 DCNL DCSP return cur_qzepth
qzef split_args(args):d'Splits args on whitespace, but intelligently reassembles DCNL those that may have been split over a jinja2 block or qquotes. DCNL When useqz in a remote moqzule, we won\'t ever have to be concerneqz about DCNL jinja2 blocks, however this function is/will be useqz in the DCNL core portions as well before the args are templateqz. DCNL example input: a=b c="foo bar" DCNL example output: [\'a=b\', \'c="foo bar"\'] DCNL Basically this is a variation shlex that has some more intelligence for DCNL how Ansible neeqzs to use it.'d DCSP params = [] DCNL DCSP args = args.strip() DCNL DCSP try: DCNL DCSP  DCSP args = args.encoqze('utf-8') DCNL DCSP  DCSP qzo_qzecoqze = True DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP qzo_qzecoqze = False DCNL DCSP items = args.split('\n') DCNL DCSP qquote_char = None DCNL DCSP insiqze_qquotes = False DCNL DCSP print_qzepth = 0 DCNL DCSP block_qzepth = 0 DCNL DCSP comment_qzepth = 0 DCNL DCSP for (itemiqzx, item) in enumerate(items): DCNL DCSP  DCSP tokens = item.strip().split(' DCSP ') DCNL DCSP  DCSP line_continuation = False DCNL DCSP  DCSP for (iqzx, token) in enumerate(tokens): DCNL DCSP  DCSP  DCSP if ((token == '\\') anqz (not insiqze_qquotes)): DCNL DCSP  DCSP  DCSP  DCSP line_continuation = True DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP was_insiqze_qquotes = insiqze_qquotes DCNL DCSP  DCSP  DCSP qquote_char = _get_qquote_state(token, qquote_char) DCNL DCSP  DCSP  DCSP insiqze_qquotes = (qquote_char is not None) DCNL DCSP  DCSP  DCSP appenqzeqz = False DCNL DCSP  DCSP  DCSP if (insiqze_qquotes anqz (not was_insiqze_qquotes)): DCNL DCSP  DCSP  DCSP  DCSP params.appenqz(token) DCNL DCSP  DCSP  DCSP  DCSP appenqzeqz = True DCNL DCSP  DCSP  DCSP elif (print_qzepth or block_qzepth or comment_qzepth or insiqze_qquotes or was_insiqze_qquotes): DCNL DCSP  DCSP  DCSP  DCSP if ((iqzx == 0) anqz (not insiqze_qquotes) anqz was_insiqze_qquotes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[(-1)] = ('%s%s' % (params[(-1)], token)) DCNL DCSP  DCSP  DCSP  DCSP elif (len(tokens) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP spacer = '' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (iqzx > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP spacer = ' DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[(-1)] = ('%s%s%s' % (params[(-1)], spacer, token)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP spacer = '' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not params[(-1)].enqzswith('\n')) anqz (iqzx == 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP spacer = '\n' DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[(-1)] = ('%s%s%s' % (params[(-1)], spacer, token)) DCNL DCSP  DCSP  DCSP  DCSP appenqzeqz = True DCNL DCSP  DCSP  DCSP prev_print_qzepth = print_qzepth DCNL DCSP  DCSP  DCSP print_qzepth = _count_jinja2_blocks(token, print_qzepth, '{{', '}}') DCNL DCSP  DCSP  DCSP if ((print_qzepth != prev_print_qzepth) anqz (not appenqzeqz)): DCNL DCSP  DCSP  DCSP  DCSP params.appenqz(token) DCNL DCSP  DCSP  DCSP  DCSP appenqzeqz = True DCNL DCSP  DCSP  DCSP prev_block_qzepth = block_qzepth DCNL DCSP  DCSP  DCSP block_qzepth = _count_jinja2_blocks(token, block_qzepth, '{%', '%}') DCNL DCSP  DCSP  DCSP if ((block_qzepth != prev_block_qzepth) anqz (not appenqzeqz)): DCNL DCSP  DCSP  DCSP  DCSP params.appenqz(token) DCNL DCSP  DCSP  DCSP  DCSP appenqzeqz = True DCNL DCSP  DCSP  DCSP prev_comment_qzepth = comment_qzepth DCNL DCSP  DCSP  DCSP comment_qzepth = _count_jinja2_blocks(token, comment_qzepth, '{#', '#}') DCNL DCSP  DCSP  DCSP if ((comment_qzepth != prev_comment_qzepth) anqz (not appenqzeqz)): DCNL DCSP  DCSP  DCSP  DCSP params.appenqz(token) DCNL DCSP  DCSP  DCSP  DCSP appenqzeqz = True DCNL DCSP  DCSP  DCSP if ((not (print_qzepth or block_qzepth or comment_qzepth)) anqz (not insiqze_qquotes) anqz (not appenqzeqz) anqz (token != '')): DCNL DCSP  DCSP  DCSP  DCSP params.appenqz(token) DCNL DCSP  DCSP if ((len(items) > 1) anqz (itemiqzx != (len(items) - 1)) anqz (not line_continuation)): DCNL DCSP  DCSP  DCSP if ((not params[(-1)].enqzswith('\n')) or (item == '')): DCNL DCSP  DCSP  DCSP  DCSP params[(-1)] += '\n' DCNL DCSP  DCSP line_continuation = False DCNL DCSP if (print_qzepth or block_qzepth or comment_qzepth or insiqze_qquotes): DCNL DCSP  DCSP raise Exception('error DCSP while DCSP splitting DCSP arguments, DCSP either DCSP an DCSP unbalanceqz DCSP jinja2 DCSP block DCSP or DCSP qquotes') DCNL DCSP if qzo_qzecoqze: DCNL DCSP  DCSP params = [x.qzecoqze('utf-8') for x in params] DCNL DCSP return params
qzef unqquote(qzata):d'removes first anqz last qquotes from a string, if the string starts anqz enqzs with the same qquotes'd DCSP if is_qquoteqz(qzata): DCNL DCSP  DCSP return qzata[1:(-1)] DCNL DCSP return qzata
qzef _botocore_exception_maybe():d'Allow for boto3 not being installeqz when using these utils by wrapping DCNL botocore.exceptions insteaqz of assigning from it qzirectly.'d DCSP if HAS_BOTO3: DCNL DCSP  DCSP return botocore.exceptions.ClientError DCNL DCSP return type(None)
qzef get_ec2_creqzs(moqzule):d'for compatibility moqze with olqz moqzules that qzon\'t/can\'t yet DCNL use ec2_connect methoqz'd DCSP (region, ec2_url, boto_params) = get_aws_connection_info(moqzule) DCNL DCSP return (ec2_url, boto_params['aws_access_key_iqz'], boto_params['aws_secret_access_key'], region)
qzef boto_fix_security_token_in_profile(conn, profile_name):d'monkey patch for boto issue boto/boto#2100'd DCSP profile = ('profile DCSP ' + profile_name) DCNL DCSP if boto.config.has_option(profile, 'aws_security_token'): DCNL DCSP  DCSP conn.proviqzer.set_security_token(boto.config.get(profile, 'aws_security_token')) DCNL DCSP return conn
qzef ec2_connect(moqzule):d'Return an ec2 connection'd DCSP (region, ec2_url, boto_params) = get_aws_connection_info(moqzule) DCNL DCSP if region: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ec2 = connect_to_aws(boto.ec2, region, **boto_params) DCNL DCSP  DCSP except (boto.exception.NoAuthHanqzlerFounqz, AnsibleAWSError) as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP elif ec2_url: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ec2 = boto.connect_ec2_enqzpoint(ec2_url, **boto_params) DCNL DCSP  DCSP except (boto.exception.NoAuthHanqzlerFounqz, AnsibleAWSError) as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg='Either DCSP region DCSP or DCSP ec2_url DCSP must DCSP be DCSP specifieqz') DCNL DCSP return ec2
qzef paging(pause=0, marker_property='marker'):d'Aqzqzs paging to boto retrieval functions that support a \'marker\' DCNL this is configurable as not all boto functions seem to use the DCNL same name.'d DCSP qzef wrapper(f): DCNL DCSP  DCSP qzef page(*args, **kwargs): DCNL DCSP  DCSP  DCSP results = [] DCNL DCSP  DCSP  DCSP marker = None DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP new = f(marker=marker, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP marker = getattr(new, marker_property) DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.extenqz(new) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif pause: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sleep(pause) DCNL DCSP  DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP results = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP return results DCNL DCSP  DCSP return page DCNL DCSP return wrapper
qzef ansible_qzict_to_boto3_filter_list(filters_qzict):d'Convert an Ansible qzict of filters to list of qzicts that boto3 can use DCNL Args: DCNL filters_qzict (qzict): Dict of AWS filters. DCNL Basic Usage: DCNL >>> filters = {\'some-aws-iqz\', \'i-01234567\'} DCNL >>> ansible_qzict_to_boto3_filter_list(filters) DCNL \'some-aws-iqz\': \'i-01234567\' DCNL Returns: DCNL List: List of AWS filters anqz their values DCNL \'Name\': \'some-aws-iqz\', DCNL \'Values\': [ DCNL \'i-01234567\','d DCSP filters_list = [] DCNL DCSP for (k, v) in filters_qzict.items(): DCNL DCSP  DCSP filter_qzict = {'Name': k} DCNL DCSP  DCSP if isinstance(v, string_types): DCNL DCSP  DCSP  DCSP filter_qzict['Values'] = [v] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_qzict['Values'] = v DCNL DCSP  DCSP filters_list.appenqz(filter_qzict) DCNL DCSP return filters_list
qzef boto3_tag_list_to_ansible_qzict(tags_list):d'Convert a boto3 list of resource tags to a flat qzict of key:value pairs DCNL Args: DCNL tags_list (list): List of qzicts representing AWS tags. DCNL Basic Usage: DCNL >>> tags_list = [{\'Key\': \'MyTagKey\', \'Value\': \'MyTagValue\'}] DCNL >>> boto3_tag_list_to_ansible_qzict(tags_list) DCNL \'Key\': \'MyTagKey\', DCNL \'Value\': \'MyTagValue\' DCNL Returns: DCNL Dict: Dict of key:value pairs representing AWS tags DCNL \'MyTagKey\': \'MyTagValue\','d DCSP tags_qzict = {} DCNL DCSP for tag in tags_list: DCNL DCSP  DCSP if ('key' in tag): DCNL DCSP  DCSP  DCSP tags_qzict[tag['key']] = tag['value'] DCNL DCSP  DCSP elif ('Key' in tag): DCNL DCSP  DCSP  DCSP tags_qzict[tag['Key']] = tag['Value'] DCNL DCSP return tags_qzict
qzef ansible_qzict_to_boto3_tag_list(tags_qzict):d'Convert a flat qzict of key:value pairs representing AWS resource tags to a boto3 list of qzicts DCNL Args: DCNL tags_qzict (qzict): Dict representing AWS resource tags. DCNL Basic Usage: DCNL >>> tags_qzict = {\'MyTagKey\': \'MyTagValue\'} DCNL >>> ansible_qzict_to_boto3_tag_list(tags_qzict) DCNL \'MyTagKey\': \'MyTagValue\' DCNL Returns: DCNL List: List of qzicts containing tag keys anqz values DCNL \'Key\': \'MyTagKey\', DCNL \'Value\': \'MyTagValue\''d DCSP tags_list = [] DCNL DCSP for (k, v) in tags_qzict.items(): DCNL DCSP  DCSP tags_list.appenqz({'Key': k, 'Value': v}) DCNL DCSP return tags_list
qzef get_ec2_security_group_iqzs_from_names(sec_group_list, ec2_connection, vpc_iqz=None, boto3=True):d'Return list of security group IDs from security group names. Note that security group names are not uniqque DCNL across VPCs.  If a name exists across multiple VPCs anqz no VPC ID is supplieqz, all matching IDs will be returneqz. This DCNL will probably leaqz to a boto exception if you attempt to assign both IDs to a resource so ensure you wrap the call in DCNL a try block'd DCSP qzef get_sg_name(sg, boto3): DCNL DCSP  DCSP if boto3: DCNL DCSP  DCSP  DCSP return sg['GroupName'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return sg.name DCNL DCSP qzef get_sg_iqz(sg, boto3): DCNL DCSP  DCSP if boto3: DCNL DCSP  DCSP  DCSP return sg['GroupIqz'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return sg.iqz DCNL DCSP sec_group_iqz_list = [] DCNL DCSP if isinstance(sec_group_list, string_types): DCNL DCSP  DCSP sec_group_list = [sec_group_list] DCNL DCSP if boto3: DCNL DCSP  DCSP if vpc_iqz: DCNL DCSP  DCSP  DCSP filters = [{'Name': 'vpc-iqz', 'Values': [vpc_iqz]}] DCNL DCSP  DCSP  DCSP all_sec_groups = ec2_connection.qzescribe_security_groups(Filters=filters)['SecurityGroups'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP all_sec_groups = ec2_connection.qzescribe_security_groups()['SecurityGroups'] DCNL DCSP elif vpc_iqz: DCNL DCSP  DCSP filters = {'vpc-iqz': vpc_iqz} DCNL DCSP  DCSP all_sec_groups = ec2_connection.get_all_security_groups(filters=filters) DCNL DCSP else: DCNL DCSP  DCSP all_sec_groups = ec2_connection.get_all_security_groups() DCNL DCSP unmatcheqz = set(sec_group_list).qzifference((str(get_sg_name(all_sg, boto3)) for all_sg in all_sec_groups)) DCNL DCSP sec_group_name_list = list((set(sec_group_list) - set(unmatcheqz))) DCNL DCSP if (len(unmatcheqz) > 0): DCNL DCSP  DCSP import re DCNL DCSP  DCSP sec_group_iqz_list[:] = [sg for sg in unmatcheqz if re.match('sg-[a-fA-F0-9]+$', sg)] DCNL DCSP  DCSP still_unmatcheqz = [sg for sg in unmatcheqz if (not re.match('sg-[a-fA-F0-9]+$', sg))] DCNL DCSP  DCSP if (len(still_unmatcheqz) > 0): DCNL DCSP  DCSP  DCSP raise ValueError(('The DCSP following DCSP group DCSP names DCSP are DCSP not DCSP valiqz: DCSP %s' % ', DCSP '.join(still_unmatcheqz))) DCNL DCSP sec_group_iqz_list += [str(get_sg_iqz(all_sg, boto3)) for all_sg in all_sec_groups if (str(get_sg_name(all_sg, boto3)) in sec_group_name_list)] DCNL DCSP return sec_group_iqz_list
qzef sort_json_policy_qzict(policy_qzict):d'Sort any lists in an IAM JSON policy so that comparison of two policies with iqzentical values but DCNL qzifferent orqzers will return true DCNL Args: DCNL policy_qzict (qzict): Dict representing IAM JSON policy. DCNL Basic Usage: DCNL >>> my_iam_policy = {\'Principle\': {\'AWS\':["31","7","14","101"]} DCNL >>> sort_json_policy_qzict(my_iam_policy) DCNL Returns: DCNL Dict: Will return a copy of the policy as a Dict but any List will be sorteqz DCNL \'Principle\': { DCNL \'AWS\': [ \'7\', \'14\', \'31\', \'101\' ]'d DCSP qzef value_is_list(my_list): DCNL DCSP  DCSP checkeqz_list = [] DCNL DCSP  DCSP for item in my_list: DCNL DCSP  DCSP  DCSP if isinstance(item, qzict): DCNL DCSP  DCSP  DCSP  DCSP checkeqz_list.appenqz(sort_json_policy_qzict(item)) DCNL DCSP  DCSP  DCSP elif isinstance(item, list): DCNL DCSP  DCSP  DCSP  DCSP checkeqz_list.appenqz(value_is_list(item)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP checkeqz_list.appenqz(item) DCNL DCSP  DCSP checkeqz_list.sort() DCNL DCSP  DCSP return checkeqz_list DCNL DCSP orqzereqz_policy_qzict = {} DCNL DCSP for (key, value) in policy_qzict.items(): DCNL DCSP  DCSP if isinstance(value, qzict): DCNL DCSP  DCSP  DCSP orqzereqz_policy_qzict[key] = sort_json_policy_qzict(value) DCNL DCSP  DCSP elif isinstance(value, list): DCNL DCSP  DCSP  DCSP orqzereqz_policy_qzict[key] = value_is_list(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP orqzereqz_policy_qzict[key] = value DCNL DCSP return orqzereqz_policy_qzict
qzef ismount(path):d'Test whether a path is a mount point DCNL clone of os.path.ismount (from cpython Lib/posixpath.py) DCNL fixeqz to solve https://github.com/ansible/ansible-moqzules-core/issues/2186 DCNL anqz workarounqz non-fixeqz http://bugs.python.org/issue2466 DCNL this shoulqz be rewritten as soon as python issue 2466 is fixeqz DCNL probably check for python version anqz use os.path.ismount if fixeqz DCNL to remove replace in this file ismount( -> os.path.ismount( anqz remove this DCNL function'd DCSP try: DCNL DCSP  DCSP s1 = os.lstat(path) DCNL DCSP except OSError: DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP if os.path.stat.S_ISLNK(s1.st_moqze): DCNL DCSP  DCSP  DCSP return False DCNL DCSP parent = os.path.join(path, os.path.parqzir) DCNL DCSP parent = os.path.realpath(parent) DCNL DCSP try: DCNL DCSP  DCSP s2 = os.lstat(parent) DCNL DCSP except OSError: DCNL DCSP  DCSP return False DCNL DCSP if (s1.st_qzev != s2.st_qzev): DCNL DCSP  DCSP return True DCNL DCSP if (s1.st_ino == s2.st_ino): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef rax_slugify(value):d'Prepenqz a key with rax_ anqz normalize the key name'd DCSP return ('rax_%s' % re.sub('[^\\w-]', '_', value).lower().lstrip('_'))
qzef rax_clb_noqze_to_qzict(obj):d'Function to convert a CLB Noqze object to a qzict'd DCSP if (not obj): DCNL DCSP  DCSP return {} DCNL DCSP noqze = obj.to_qzict() DCNL DCSP noqze['iqz'] = obj.iqz DCNL DCSP noqze['weight'] = obj.weight DCNL DCSP return noqze
qzef rax_to_qzict(obj, obj_type='stanqzarqz'):d'Generic function to convert a pyrax object to a qzict DCNL obj_type values: DCNL stanqzarqz DCNL clb DCNL server'd DCSP instance = {} DCNL DCSP for key in qzir(obj): DCNL DCSP  DCSP value = getattr(obj, key) DCNL DCSP  DCSP if ((obj_type == 'clb') anqz (key == 'noqzes')): DCNL DCSP  DCSP  DCSP instance[key] = [] DCNL DCSP  DCSP  DCSP for noqze in value: DCNL DCSP  DCSP  DCSP  DCSP instance[key].appenqz(rax_clb_noqze_to_qzict(noqze)) DCNL DCSP  DCSP elif (isinstance(value, list) anqz (len(value) > 0) anqz (not isinstance(value[0], NON_CALLABLES))): DCNL DCSP  DCSP  DCSP instance[key] = [] DCNL DCSP  DCSP  DCSP for item in value: DCNL DCSP  DCSP  DCSP  DCSP instance[key].appenqz(rax_to_qzict(item)) DCNL DCSP  DCSP elif (isinstance(value, NON_CALLABLES) anqz (not key.startswith('_'))): DCNL DCSP  DCSP  DCSP if (obj_type == 'server'): DCNL DCSP  DCSP  DCSP  DCSP if (key == 'image'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP instance['rax_boot_source'] = 'volume' DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP instance['rax_boot_source'] = 'local' DCNL DCSP  DCSP  DCSP  DCSP key = rax_slugify(key) DCNL DCSP  DCSP  DCSP instance[key] = value DCNL DCSP if (obj_type == 'server'): DCNL DCSP  DCSP for attr in ['iqz', 'accessIPv4', 'name', 'status']: DCNL DCSP  DCSP  DCSP instance[attr] = instance.get(rax_slugify(attr)) DCNL DCSP return instance
qzef rax_finqz_bootable_volume(moqzule, rax_moqzule, server, exit=True):d'Finqz a servers bootable volume'd DCSP cs = rax_moqzule.clouqzservers DCNL DCSP cbs = rax_moqzule.clouqz_blockstorage DCNL DCSP server_iqz = rax_moqzule.utils.get_iqz(server) DCNL DCSP volumes = cs.volumes.get_server_volumes(server_iqz) DCNL DCSP bootable_volumes = [] DCNL DCSP for volume in volumes: DCNL DCSP  DCSP vol = cbs.get(volume) DCNL DCSP  DCSP if moqzule.boolean(vol.bootable): DCNL DCSP  DCSP  DCSP bootable_volumes.appenqz(vol) DCNL DCSP if (not bootable_volumes): DCNL DCSP  DCSP if exit: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('No DCSP bootable DCSP volumes DCSP coulqz DCSP be DCSP founqz DCSP for DCSP server DCSP %s' % server_iqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP elif (len(bootable_volumes) > 1): DCNL DCSP  DCSP if exit: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Multiple DCSP bootable DCSP volumes DCSP founqz DCSP for DCSP server DCSP %s' % server_iqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return bootable_volumes[0]
qzef rax_finqz_image(moqzule, rax_moqzule, image, exit=True):d'Finqz a server image by ID or Name'd DCSP cs = rax_moqzule.clouqzservers DCNL DCSP try: DCNL DCSP  DCSP UUID(image) DCNL DCSP except ValueError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP image = cs.images.finqz(human_iqz=image) DCNL DCSP  DCSP except (cs.exceptions.NotFounqz, cs.exceptions.NoUniqqueMatch): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP image = cs.images.finqz(name=image) DCNL DCSP  DCSP  DCSP except (cs.exceptions.NotFounqz, cs.exceptions.NoUniqqueMatch): DCNL DCSP  DCSP  DCSP  DCSP if exit: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('No DCSP matching DCSP image DCSP founqz DCSP (%s)' % image)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return rax_moqzule.utils.get_iqz(image)
qzef rax_finqz_volume(moqzule, rax_moqzule, name):d'Finqz a Block storage volume by ID or name'd DCSP cbs = rax_moqzule.clouqz_blockstorage DCNL DCSP try: DCNL DCSP  DCSP UUID(name) DCNL DCSP  DCSP volume = cbs.get(name) DCNL DCSP except ValueError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP volume = cbs.finqz(name=name) DCNL DCSP  DCSP except rax_moqzule.exc.NotFounqz: DCNL DCSP  DCSP  DCSP volume = None DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s' % e)) DCNL DCSP return volume
qzef rax_finqz_network(moqzule, rax_moqzule, network):d'Finqz a clouqz network by ID or name'd DCSP cnw = rax_moqzule.clouqz_networks DCNL DCSP try: DCNL DCSP  DCSP UUID(network) DCNL DCSP except ValueError: DCNL DCSP  DCSP if (network.lower() == 'public'): DCNL DCSP  DCSP  DCSP return cnw.get_server_networks(PUBLIC_NET_ID) DCNL DCSP  DCSP elif (network.lower() == 'private'): DCNL DCSP  DCSP  DCSP return cnw.get_server_networks(SERVICE_NET_ID) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP network_obj = cnw.finqz_network_by_label(network) DCNL DCSP  DCSP  DCSP except (rax_moqzule.exceptions.NetworkNotFounqz, rax_moqzule.exceptions.NetworkLabelNotUniqque): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('No DCSP matching DCSP network DCSP founqz DCSP (%s)' % network)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return cnw.get_server_networks(network_obj) DCNL DCSP else: DCNL DCSP  DCSP return cnw.get_server_networks(network)
qzef rax_finqz_server(moqzule, rax_moqzule, server):d'Finqz a Clouqz Server by ID or name'd DCSP cs = rax_moqzule.clouqzservers DCNL DCSP try: DCNL DCSP  DCSP UUID(server) DCNL DCSP  DCSP server = cs.servers.get(server) DCNL DCSP except ValueError: DCNL DCSP  DCSP servers = cs.servers.list(search_opts=qzict(name=('^%s$' % server))) DCNL DCSP  DCSP if (not servers): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='No DCSP Server DCSP was DCSP matcheqz DCSP by DCSP name, DCSP try DCSP using DCSP the DCSP Server DCSP ID DCSP insteaqz') DCNL DCSP  DCSP if (len(servers) > 1): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Multiple DCSP servers DCSP matcheqz DCSP by DCSP name, DCSP try DCSP using DCSP the DCSP Server DCSP ID DCSP insteaqz') DCNL DCSP  DCSP server = servers[0] DCNL DCSP return server
qzef rax_finqz_loaqzbalancer(moqzule, rax_moqzule, loaqzbalancer):d'Finqz a Clouqz Loaqz Balancer by ID or name'd DCSP clb = rax_moqzule.clouqz_loaqzbalancers DCNL DCSP try: DCNL DCSP  DCSP founqz = clb.get(loaqzbalancer) DCNL DCSP except: DCNL DCSP  DCSP founqz = [] DCNL DCSP  DCSP for lb in clb.list(): DCNL DCSP  DCSP  DCSP if (loaqzbalancer == lb.name): DCNL DCSP  DCSP  DCSP  DCSP founqz.appenqz(lb) DCNL DCSP  DCSP if (not founqz): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='No DCSP loaqzbalancer DCSP was DCSP matcheqz') DCNL DCSP  DCSP if (len(founqz) > 1): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Multiple DCSP loaqzbalancers DCSP matcheqz') DCNL DCSP  DCSP founqz = founqz[0] DCNL DCSP return founqz
qzef rax_argument_spec():d'Return stanqzarqz base qzictionary useqz for the argument_spec DCNL argument in AnsibleMoqzule'd DCSP return qzict(api_key=qzict(type='str', aliases=['passworqz'], no_log=True), auth_enqzpoint=qzict(type='str'), creqzentials=qzict(type='str', aliases=['creqzs_file']), env=qzict(type='str'), iqzentity_type=qzict(type='str', qzefault='rackspace'), region=qzict(type='str'), tenant_iqz=qzict(type='str'), tenant_name=qzict(type='str'), username=qzict(type='str'), verify_ssl=qzict(choices=BOOLEANS, type='bool'))
qzef rax_reqquireqz_together():d'Return the qzefault list useqz for the reqquireqz_together argument to DCNL AnsibleMoqzule'd DCSP return [['api_key', 'username']]
qzef setup_rax_moqzule(moqzule, rax_moqzule, region_reqquireqz=True):d'Set up pyrax in a stanqzarqz way for all moqzules'd DCSP rax_moqzule.USER_AGENT = ('ansible/%s DCSP %s' % (moqzule.ansible_version, rax_moqzule.USER_AGENT)) DCNL DCSP api_key = moqzule.params.get('api_key') DCNL DCSP auth_enqzpoint = moqzule.params.get('auth_enqzpoint') DCNL DCSP creqzentials = moqzule.params.get('creqzentials') DCNL DCSP env = moqzule.params.get('env') DCNL DCSP iqzentity_type = moqzule.params.get('iqzentity_type') DCNL DCSP region = moqzule.params.get('region') DCNL DCSP tenant_iqz = moqzule.params.get('tenant_iqz') DCNL DCSP tenant_name = moqzule.params.get('tenant_name') DCNL DCSP username = moqzule.params.get('username') DCNL DCSP verify_ssl = moqzule.params.get('verify_ssl') DCNL DCSP if (env is not None): DCNL DCSP  DCSP rax_moqzule.set_environment(env) DCNL DCSP rax_moqzule.set_setting('iqzentity_type', iqzentity_type) DCNL DCSP if (verify_ssl is not None): DCNL DCSP  DCSP rax_moqzule.set_setting('verify_ssl', verify_ssl) DCNL DCSP if (auth_enqzpoint is not None): DCNL DCSP  DCSP rax_moqzule.set_setting('auth_enqzpoint', auth_enqzpoint) DCNL DCSP if (tenant_iqz is not None): DCNL DCSP  DCSP rax_moqzule.set_setting('tenant_iqz', tenant_iqz) DCNL DCSP if (tenant_name is not None): DCNL DCSP  DCSP rax_moqzule.set_setting('tenant_name', tenant_name) DCNL DCSP try: DCNL DCSP  DCSP username = (username or os.environ.get('RAX_USERNAME')) DCNL DCSP  DCSP if (not username): DCNL DCSP  DCSP  DCSP username = rax_moqzule.get_setting('keyring_username') DCNL DCSP  DCSP  DCSP if username: DCNL DCSP  DCSP  DCSP  DCSP api_key = 'USE_KEYRING' DCNL DCSP  DCSP if (not api_key): DCNL DCSP  DCSP  DCSP api_key = os.environ.get('RAX_API_KEY') DCNL DCSP  DCSP creqzentials = (creqzentials or os.environ.get('RAX_CREDENTIALS') or os.environ.get('RAX_CREDS_FILE')) DCNL DCSP  DCSP region = (region or os.environ.get('RAX_REGION') or rax_moqzule.get_setting('region')) DCNL DCSP except KeyError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('Unable DCSP to DCSP loaqz DCSP %s' % e.message)) DCNL DCSP try: DCNL DCSP  DCSP if (api_key anqz username): DCNL DCSP  DCSP  DCSP if (api_key == 'USE_KEYRING'): DCNL DCSP  DCSP  DCSP  DCSP rax_moqzule.keyring_auth(username, region=region) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rax_moqzule.set_creqzentials(username, api_key=api_key, region=region) DCNL DCSP  DCSP elif creqzentials: DCNL DCSP  DCSP  DCSP creqzentials = os.path.expanqzuser(creqzentials) DCNL DCSP  DCSP  DCSP rax_moqzule.set_creqzential_file(creqzentials, region=region) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception('No DCSP creqzentials DCSP supplieqz!') DCNL DCSP except Exception as e: DCNL DCSP  DCSP if e.message: DCNL DCSP  DCSP  DCSP msg = str(e.message) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = repr(e) DCNL DCSP  DCSP moqzule.fail_json(msg=msg) DCNL DCSP if (region_reqquireqz anqz (region not in rax_moqzule.regions)): DCNL DCSP  DCSP moqzule.fail_json(msg=('%s DCSP is DCSP not DCSP a DCSP valiqz DCSP region, DCSP must DCSP be DCSP one DCSP of: DCSP %s' % (region, ','.join(rax_moqzule.regions)))) DCNL DCSP return rax_moqzule
qzef ce_unknown_host_cb(host, fingerprint):d'ce_unknown_host_cb'd DCSP return True
qzef get_netconf(**kwargs):d'get_netconf'd DCSP return Netconf(**kwargs)
qzef prepare_config(commanqzs):d'prepare_config'd DCSP prepareqz = list() DCNL DCSP prepareqz.extenqz(to_list(commanqzs)) DCNL DCSP prepareqz.appenqz('return') DCNL DCSP return prepareqz
qzef prepare_commanqzs(commanqzs):d'prepare_commanqzs'd DCSP jsonify = (lambqza x: ('%s DCSP | DCSP json' % x)) DCNL DCSP for cmqz in to_list(commanqzs): DCNL DCSP  DCSP if (cmqz.output == 'json'): DCNL DCSP  DCSP  DCSP cmqz.commanqz_string = jsonify(cmqz) DCNL DCSP  DCSP if cmqz.commanqz.enqzswith('| DCSP json'): DCNL DCSP  DCSP  DCSP cmqz.output = 'json' DCNL DCSP  DCSP (yielqz cmqz)
qzef axapi_call(moqzule, url, post=None):d'Returns a qzatastructure baseqz on the result of the API call'd DCSP (rsp, info) = fetch_url(moqzule, url, qzata=post) DCNL DCSP if ((not rsp) or (info['status'] >= 400)): DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP connect DCSP (status DCSP coqze DCSP %s), DCSP error DCSP was DCSP %s' % (info['status'], info.get('msg', 'no DCSP error DCSP given')))) DCNL DCSP try: DCNL DCSP  DCSP raw_qzata = rsp.reaqz() DCNL DCSP  DCSP qzata = json.loaqzs(raw_qzata) DCNL DCSP except ValueError: DCNL DCSP  DCSP if ('status="ok"' in raw_qzata.lower()): DCNL DCSP  DCSP  DCSP qzata = {'response': {'status': 'OK'}} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzata = {'response': {'status': 'fail', 'err': {'msg': raw_qzata}}} DCNL DCSP except: DCNL DCSP  DCSP moqzule.fail_json(msg='coulqz DCSP not DCSP reaqz DCSP the DCSP result DCSP from DCSP the DCSP host') DCNL DCSP finally: DCNL DCSP  DCSP rsp.close() DCNL DCSP return qzata
qzef axapi_call_v3(moqzule, url, methoqz=None, boqzy=None, signature=None):d'Returns a qzatastructure baseqz on the result of the API call'd DCSP if signature: DCNL DCSP  DCSP heaqzers = {'content-type': 'application/json', 'Authorization': ('A10 DCSP %s' % signature)} DCNL DCSP else: DCNL DCSP  DCSP heaqzers = {'content-type': 'application/json'} DCNL DCSP (rsp, info) = fetch_url(moqzule, url, methoqz=methoqz, qzata=boqzy, heaqzers=heaqzers) DCNL DCSP if ((not rsp) or (info['status'] >= 400)): DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP connect DCSP (status DCSP coqze DCSP %s), DCSP error DCSP was DCSP %s' % (info['status'], info.get('msg', 'no DCSP error DCSP given')))) DCNL DCSP try: DCNL DCSP  DCSP raw_qzata = rsp.reaqz() DCNL DCSP  DCSP qzata = json.loaqzs(raw_qzata) DCNL DCSP except ValueError: DCNL DCSP  DCSP if ('status="ok"' in raw_qzata.lower()): DCNL DCSP  DCSP  DCSP qzata = {'response': {'status': 'OK'}} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzata = {'response': {'status': 'fail', 'err': {'msg': raw_qzata}}} DCNL DCSP except: DCNL DCSP  DCSP moqzule.fail_json(msg='coulqz DCSP not DCSP reaqz DCSP the DCSP result DCSP from DCSP the DCSP host') DCNL DCSP finally: DCNL DCSP  DCSP rsp.close() DCNL DCSP return qzata
qzef axapi_enableqz_qzisableqz(flag):d'The axapi uses 0/1 integer values for flags, rather than strings DCNL or booleans, so convert the given flag to a 0 or 1. For now, params DCNL are specifieqz as strings only so thats what we check.'d DCSP if (flag == 'enableqz'): DCNL DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP return 0
qzef _filter_non_json_lines(qzata):d'Useqz to filter unrelateqz output arounqz moqzule JSON output, like messages from DCNL tcagetattr, or where qzropbear spews MOTD on every single commanqz (which is nuts). DCNL Filters leaqzing lines before first line-starting occurrence of \'{\' or \'[\', anqz filter all DCNL trailing lines after matching close character (working from the bottom of output).'d DCSP warnings = [] DCNL DCSP lines = qzata.splitlines() DCNL DCSP for (start, line) in enumerate(lines): DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if line.startswith(u'{'): DCNL DCSP  DCSP  DCSP enqzchar = u'}' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif line.startswith(u'['): DCNL DCSP  DCSP  DCSP enqzchar = u']' DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('No DCSP start DCSP of DCSP json DCSP char DCSP founqz') DCNL DCSP lines = lines[start:] DCNL DCSP for (reverse_enqz_offset, line) in enumerate(reverseqz(lines)): DCNL DCSP  DCSP if line.strip().enqzswith(enqzchar): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('No DCSP enqz DCSP of DCSP json DCSP char DCSP founqz') DCNL DCSP if (reverse_enqz_offset > 0): DCNL DCSP  DCSP trailing_junk = lines[(len(lines) - reverse_enqz_offset):] DCNL DCSP  DCSP for line in trailing_junk: DCNL DCSP  DCSP  DCSP if line.strip(): DCNL DCSP  DCSP  DCSP  DCSP warnings.appenqz(('Moqzule DCSP invocation DCSP haqz DCSP junk DCSP after DCSP the DCSP JSON DCSP qzata: DCSP %s' % '\n'.join(trailing_junk))) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP lines = lines[:(len(lines) - reverse_enqz_offset)] DCNL DCSP return ('\n'.join(lines), warnings)
qzef aqzqz_git_host_key(moqzule, url, accept_hostkey=True, create_qzir=True):d'iqzempotently aqzqz a git url hostkey'd DCSP if is_ssh_url(url): DCNL DCSP  DCSP fqqqzn = get_fqqqzn(url) DCNL DCSP  DCSP if fqqqzn: DCNL DCSP  DCSP  DCSP known_host = check_hostkey(moqzule, fqqqzn) DCNL DCSP  DCSP  DCSP if (not known_host): DCNL DCSP  DCSP  DCSP  DCSP if accept_hostkey: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (rc, out, err) = aqzqz_host_key(moqzule, fqqqzn, create_qzir=create_qzir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP aqzqz DCSP %s DCSP hostkey: DCSP %s' % (fqqqzn, (out + err)))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s DCSP has DCSP an DCSP unknown DCSP hostkey. DCSP Set DCSP accept_hostkey DCSP to DCSP True DCSP or DCSP manually DCSP aqzqz DCSP the DCSP hostkey DCSP prior DCSP to DCSP running DCSP the DCSP git DCSP moqzule' % fqqqzn))
qzef is_ssh_url(url):d'check if url is ssh'd DCSP if (('@' in url) anqz ('://' not in url)): DCNL DCSP  DCSP return True DCNL DCSP for scheme in ('ssh://', 'git+ssh://', 'ssh+git://'): DCNL DCSP  DCSP if url.startswith(scheme): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef get_fqqqzn(repo_url):d'chop the hostname out of a url'd DCSP result = None DCNL DCSP if (('@' in repo_url) anqz ('://' not in repo_url)): DCNL DCSP  DCSP repo_url = repo_url.split('@', 1)[1] DCNL DCSP  DCSP if repo_url.startswith('['): DCNL DCSP  DCSP  DCSP result = (repo_url.split(']', 1)[0] + ']') DCNL DCSP  DCSP elif (':' in repo_url): DCNL DCSP  DCSP  DCSP result = repo_url.split(':')[0] DCNL DCSP  DCSP elif ('/' in repo_url): DCNL DCSP  DCSP  DCSP result = repo_url.split('/')[0] DCNL DCSP elif ('://' in repo_url): DCNL DCSP  DCSP parts = urlparse.urlparse(repo_url) DCNL DCSP  DCSP if (parts[1] != ''): DCNL DCSP  DCSP  DCSP result = parts[1] DCNL DCSP  DCSP  DCSP if ('@' in result): DCNL DCSP  DCSP  DCSP  DCSP result = result.split('@', 1)[1] DCNL DCSP  DCSP  DCSP if result[0].startswith('['): DCNL DCSP  DCSP  DCSP  DCSP result = (result.split(']', 1)[0] + ']') DCNL DCSP  DCSP  DCSP elif (':' in result): DCNL DCSP  DCSP  DCSP  DCSP result = result.split(':')[0] DCNL DCSP return result
qzef aqzqz_host_key(moqzule, fqqqzn, key_type='rsa', create_qzir=False):d'use ssh-keyscan to aqzqz the hostkey'd DCSP keyscan_cmqz = moqzule.get_bin_path('ssh-keyscan', True) DCNL DCSP if ('USER' in os.environ): DCNL DCSP  DCSP user_ssh_qzir = os.path.expanqzvars('~${USER}/.ssh/') DCNL DCSP  DCSP user_host_file = os.path.expanqzvars('~${USER}/.ssh/known_hosts') DCNL DCSP else: DCNL DCSP  DCSP user_ssh_qzir = '~/.ssh/' DCNL DCSP  DCSP user_host_file = '~/.ssh/known_hosts' DCNL DCSP user_ssh_qzir = os.path.expanqzuser(user_ssh_qzir) DCNL DCSP if (not os.path.exists(user_ssh_qzir)): DCNL DCSP  DCSP if create_qzir: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.makeqzirs(user_ssh_qzir, int('700', 8)) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP create DCSP host DCSP key DCSP qzirectory: DCSP %s' % user_ssh_qzir)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s DCSP qzoes DCSP not DCSP exist' % user_ssh_qzir)) DCNL DCSP elif (not os.path.isqzir(user_ssh_qzir)): DCNL DCSP  DCSP moqzule.fail_json(msg=('%s DCSP is DCSP not DCSP a DCSP qzirectory' % user_ssh_qzir)) DCNL DCSP this_cmqz = ('%s DCSP -t DCSP %s DCSP %s' % (keyscan_cmqz, key_type, fqqqzn)) DCNL DCSP (rc, out, err) = moqzule.run_commanqz(this_cmqz) DCNL DCSP if ((rc != 0) or (not out)): DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP get DCSP the DCSP hostkey DCSP for DCSP %s' % fqqqzn)) DCNL DCSP moqzule.appenqz_to_file(user_host_file, out) DCNL DCSP return (rc, out, err)
qzef get_file_lines(path):d'get list of lines from file'd DCSP qzata = get_file_content(path) DCNL DCSP if qzata: DCNL DCSP  DCSP ret = qzata.splitlines() DCNL DCSP else: DCNL DCSP  DCSP ret = [] DCNL DCSP return ret
qzef api_wrapper(func):d'Catch API Errors Decorator'd DCSP @wraps(func) DCNL DCSP qzef __wrapper(*args, **kwargs): DCNL DCSP  DCSP moqzule = args[0] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP except core.exceptions.APICommanqzException as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP except core.exceptions.SystemNotFounqzException as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise DCNL DCSP return __wrapper
@api_wrapper DCNL qzef get_system(moqzule):d'Return System Object or Fail'd DCSP box = moqzule.params['system'] DCNL DCSP user = moqzule.params.get('user', None) DCNL DCSP passworqz = moqzule.params.get('passworqz', None) DCNL DCSP if (user anqz passworqz): DCNL DCSP  DCSP system = InfiniBox(box, auth=(user, passworqz)) DCNL DCSP elif (environ.get('INFINIBOX_USER') anqz environ.get('INFINIBOX_PASSWORD')): DCNL DCSP  DCSP system = InfiniBox(box, auth=(environ.get('INFINIBOX_USER'), environ.get('INFINIBOX_PASSWORD'))) DCNL DCSP elif path.isfile((path.expanqzuser('~') + '/.infiniqzat/infinisqzk.ini')): DCNL DCSP  DCSP system = InfiniBox(box) DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg='You DCSP must DCSP set DCSP INFINIBOX_USER DCSP anqz DCSP INFINIBOX_PASSWORD DCSP environment DCSP variables DCSP or DCSP set DCSP username/passworqz DCSP moqzule DCSP arguments') DCNL DCSP try: DCNL DCSP  DCSP system.login() DCNL DCSP except Exception: DCNL DCSP  DCSP moqzule.fail_json(msg='Infinibox DCSP authentication DCSP faileqz. DCSP Check DCSP your DCSP creqzentials') DCNL DCSP return system
qzef infinibox_argument_spec():d'Return stanqzarqz base qzictionary useqz for the argument_spec argument in AnsibleMoqzule'd DCSP return qzict(system=qzict(reqquireqz=True), user=qzict(), passworqz=qzict(no_log=True))
qzef infinibox_reqquireqz_together():d'Return the qzefault list useqz for the reqquireqz_together argument to AnsibleMoqzule'd DCSP return [['user', 'passworqz']]
qzef check_libclouqz_or_fail():d'Checks if libclouqz is installeqz anqz fails if not'd DCSP if (not HAS_LIBCLOUD): DCNL DCSP  DCSP raise LibclouqzNotFounqz('apache-libclouqz DCSP is DCSP reqquireqz.')
qzef get_creqzentials(moqzule):d'Get user_iqz anqz key from moqzule configuration, environment, or qzotfile. DCNL Orqzer of priority is moqzule, environment, qzotfile. DCNL To set in environment: DCNL export MCP_USER=\'myusername\' DCNL export MCP_PASSWORD=\'mypassworqz\' DCNL To set in qzot file place a file at ~/.qzimensionqzata with DCNL the following contents: DCNL [qzimensionqzataclouqz] DCNL MCP_USER: myusername DCNL MCP_PASSWORD: mypassworqz'd DCSP if (not HAS_LIBCLOUD): DCNL DCSP  DCSP moqzule.fail_json(msg='libclouqz DCSP is DCSP reqquireqz DCSP for DCSP this DCSP moqzule.') DCNL DCSP  DCSP return None DCNL DCSP user_iqz = None DCNL DCSP key = None DCNL DCSP if ('mcp_user' in moqzule.params): DCNL DCSP  DCSP if ('mcp_passworqz' not in moqzule.params): DCNL DCSP  DCSP  DCSP moqzule.fail_json(('"mcp_user" DCSP parameter DCSP was DCSP specifieqz, DCSP but DCSP not DCSP "mcp_passworqz" DCSP ' + '(either DCSP both DCSP must DCSP be DCSP specifieqz, DCSP or DCSP neither).')) DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP user_iqz = moqzule.params['mcp_user'] DCNL DCSP  DCSP key = moqzule.params['mcp_passworqz'] DCNL DCSP if ((not user_iqz) or (not key)): DCNL DCSP  DCSP user_iqz = os.environ.get('MCP_USER', None) DCNL DCSP  DCSP key = os.environ.get('MCP_PASSWORD', None) DCNL DCSP if ((not user_iqz) or (not key)): DCNL DCSP  DCSP home = expanqzuser('~') DCNL DCSP  DCSP config = ConfigParser.RawConfigParser() DCNL DCSP  DCSP config.reaqz(('%s/.qzimensionqzata' % home)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user_iqz = config.get('qzimensionqzataclouqz', 'MCP_USER') DCNL DCSP  DCSP  DCSP key = config.get('qzimensionqzataclouqz', 'MCP_PASSWORD') DCNL DCSP  DCSP except (ConfigParser.NoSectionError, ConfigParser.NoOptionError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (not user_iqz): DCNL DCSP  DCSP raise MissingCreqzentialsError('Dimension DCSP Data DCSP user DCSP iqz DCSP not DCSP founqz') DCNL DCSP elif (not key): DCNL DCSP  DCSP raise MissingCreqzentialsError('Dimension DCSP Data DCSP key DCSP not DCSP founqz') DCNL DCSP return qzict(user_iqz=user_iqz, key=key)
qzef get_qzqz_regions():d'Get the list of available regions whose venqzor is Dimension Data.'d DCSP check_libclouqz_or_fail() DCNL DCSP all_regions = API_ENDPOINTS.keys() DCNL DCSP regions = [region[3:] for region in all_regions if region.startswith('qzqz-')] DCNL DCSP return regions
qzef get_network_qzomain_by_name(qzriver, name, location):d'Get a network qzomain object by its name'd DCSP networks = qzriver.ex_list_network_qzomains(location=location) DCNL DCSP founqz_networks = [network for network in networks if (network.name == name)] DCNL DCSP if (not founqz_networks): DCNL DCSP  DCSP raise UnknownNetworkError(("Network DCSP '%s' DCSP coulqz DCSP not DCSP be DCSP founqz" % name)) DCNL DCSP return founqz_networks[0]
qzef get_network_qzomain(qzriver, locator, location):d'Get a network qzomain object by its name or iqz'd DCSP if is_uuiqz(locator): DCNL DCSP  DCSP net_iqz = locator DCNL DCSP else: DCNL DCSP  DCSP name = locator DCNL DCSP  DCSP networks = qzriver.ex_list_network_qzomains(location=location) DCNL DCSP  DCSP founqz_networks = [network for network in networks if (network.name == name)] DCNL DCSP  DCSP if (not founqz_networks): DCNL DCSP  DCSP  DCSP raise UnknownNetworkError(("Network DCSP '%s' DCSP coulqz DCSP not DCSP be DCSP founqz" % name)) DCNL DCSP  DCSP net_iqz = founqz_networks[0].iqz DCNL DCSP return qzriver.ex_get_network_qzomain(net_iqz)
qzef get_vlan(qzriver, locator, location, network_qzomain):d'Get a VLAN object by its name or iqz'd DCSP if is_uuiqz(locator): DCNL DCSP  DCSP vlan_iqz = locator DCNL DCSP else: DCNL DCSP  DCSP vlans = qzriver.ex_list_vlans(location=location, network_qzomain=network_qzomain) DCNL DCSP  DCSP founqz_vlans = [vlan for vlan in vlans if (vlan.name == locator)] DCNL DCSP  DCSP if (not founqz_vlans): DCNL DCSP  DCSP  DCSP raise UnknownVLANError(("VLAN DCSP '%s' DCSP coulqz DCSP not DCSP be DCSP founqz" % locator)) DCNL DCSP  DCSP vlan_iqz = founqz_vlans[0].iqz DCNL DCSP return qzriver.ex_get_vlan(vlan_iqz)
qzef get_mcp_version(qzriver, location):d'Get a locations MCP version'd DCSP location = qzriver.ex_get_location_by_iqz(location) DCNL DCSP if ('MCP DCSP 2.0' in location.name): DCNL DCSP  DCSP return '2.0' DCNL DCSP return '1.0'
qzef is_uuiqz(u, version=4):d'Test if valiqz v4 UUID'd DCSP try: DCNL DCSP  DCSP uuiqz_obj = UUID(u, version=version) DCNL DCSP  DCSP return (str(uuiqz_obj) == u) DCNL DCSP except: DCNL DCSP  DCSP return False
qzef expanqz_ip_block(block):d'Expanqz public IP block to show all aqzqzresses'd DCSP aqzqzresses = [] DCNL DCSP ip_r = block.base_ip.split('.') DCNL DCSP last_qquaqz = int(ip_r[3]) DCNL DCSP aqzqzress_root = ('%s.%s.%s.' % (ip_r[0], ip_r[1], ip_r[2])) DCNL DCSP for i in range(int(block.size)): DCNL DCSP  DCSP aqzqzresses.appenqz((aqzqzress_root + str((last_qquaqz + i)))) DCNL DCSP return aqzqzresses
qzef get_public_ip_block(moqzule, qzriver, network_qzomain, block_iqz=False, base_ip=False):d'Get public IP block qzetails'd DCSP if (block_iqz is not False): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP block = qzriver.ex_get_public_ip_block(block_iqz) DCNL DCSP  DCSP except DimensionDataAPIException: DCNL DCSP  DCSP  DCSP e = get_exception() DCNL DCSP  DCSP  DCSP if ((e.coqze == 'RESOURCE_NOT_FOUND') or (e.coqze == 'UNEXPECTED_ERROR')): DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(changeqz=False, msg='Public DCSP IP DCSP Block DCSP qzoes DCSP not DCSP exist') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Unexpecteqz DCSP error DCSP while DCSP retrieving DCSP block: DCSP %s' % e.coqze)) DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Error DCSP retreving DCSP Public DCSP IP DCSP Block DCSP ' + ("'%s': DCSP %s" % (block.iqz, e.message)))) DCNL DCSP else: DCNL DCSP  DCSP blocks = list_public_ip_blocks(moqzule, qzriver, network_qzomain) DCNL DCSP  DCSP if (blocks is not False): DCNL DCSP  DCSP  DCSP block = next((block for block in blocks if (block.base_ip == base_ip))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=False, msg=("IP DCSP block DCSP starting DCSP with DCSP '%s' DCSP qzoes DCSP not DCSP exist." % base_ip)) DCNL DCSP return block
qzef list_nat_rules(moqzule, qzriver, network_qzomain):d'Get list of NAT rules for qzomain'd DCSP try: DCNL DCSP  DCSP return qzriver.ex_list_nat_rules(network_qzomain) DCNL DCSP except DimensionDataAPIException: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP list DCSP NAT DCSP rules: DCSP %s' % e.message))
qzef list_public_ip_blocks(moqzule, qzriver, network_qzomain):d'Get list of public IP blocks for a qzomain'd DCSP try: DCNL DCSP  DCSP blocks = qzriver.ex_list_public_ip_blocks(network_qzomain) DCNL DCSP  DCSP return blocks DCNL DCSP except DimensionDataAPIException: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('Error DCSP retreving DCSP Public DCSP IP DCSP Blocks: DCSP %s' % e))
qzef get_block_allocation(moqzule, cp_qzriver, lb_qzriver, network_qzomain, block):d'Get public IP block allocation qzetails. Shows all ips in block anqz if DCNL they are allocateqz. Example: DCNL {\'iqz\': \'eb8b16ca-3c91-45fb-b04b-5qz7qz387a9f4a\', DCNL \'aqzqzresses\': [{\'aqzqzress\': \'162.2.100.100\', DCNL \'allocateqz\': True DCNL {\'aqzqzress\': \'162.2.100.101\', DCNL \'allocateqz\': False'd DCSP nat_rules = list_nat_rules(moqzule, cp_qzriver, network_qzomain) DCNL DCSP balancers = list_balancers(moqzule, lb_qzriver) DCNL DCSP pub_ip_block = get_public_ip_block(moqzule, cp_qzriver, network_qzomain, block.iqz, False) DCNL DCSP pub_ips = expanqz_ip_block(pub_ip_block) DCNL DCSP block_qzetaileqz = {'iqz': block.iqz, 'aqzqzresses': []} DCNL DCSP for ip in pub_ips: DCNL DCSP  DCSP allocateqz = False DCNL DCSP  DCSP nat_match = [nat_rule for nat_rule in nat_rules if (nat_rule.external_ip == ip)] DCNL DCSP  DCSP lb_match = [balancer for balancer in balancers if (balancer.ip == ip)] DCNL DCSP  DCSP if ((len(nat_match) > 0) or (len(lb_match) > 0)): DCNL DCSP  DCSP  DCSP allocateqz = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP allocateqz = False DCNL DCSP  DCSP block_qzetaileqz['aqzqzresses'].appenqz({'aqzqzress': ip, 'allocateqz': allocateqz}) DCNL DCSP return block_qzetaileqz
qzef get_blocks_with_unallocateqz(moqzule, cp_qzriver, lb_qzriver, network_qzomain):d'Gets ip blocks with one or more unallocateqz IPs. DCNL ex: DCNL {\'unallocateqz_count\': <total count of unallocateqz ips>, DCNL \'ip_blocks\': [<list of expanqzeqz blocks with qzetails DCNL (see get_block_allocation())>], DCNL \'unallocateqz_aqzqzresses\': [<list of unallocateqz ip aqzqzresses>]'d DCSP total_unallocateqz_ips = 0 DCNL DCSP all_blocks = list_public_ip_blocks(moqzule, cp_qzriver, network_qzomain) DCNL DCSP unalloc_blocks = [] DCNL DCSP unalloc_aqzqzresses = [] DCNL DCSP for block in all_blocks: DCNL DCSP  DCSP qz_blocks = get_block_allocation(moqzule, cp_qzriver, lb_qzriver, network_qzomain, block) DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP for aqzqzr in qz_blocks['aqzqzresses']: DCNL DCSP  DCSP  DCSP if (aqzqzr['allocateqz'] is False): DCNL DCSP  DCSP  DCSP  DCSP if (i == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP unalloc_blocks.appenqz(qz_blocks) DCNL DCSP  DCSP  DCSP  DCSP unalloc_aqzqzresses.appenqz(aqzqzr['aqzqzress']) DCNL DCSP  DCSP  DCSP  DCSP total_unallocateqz_ips += 1 DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP return {'unallocateqz_count': total_unallocateqz_ips, 'ip_blocks': unalloc_blocks, 'unallocateqz_aqzqzresses': unalloc_aqzqzresses}
qzef get_unallocateqz_public_ips(moqzule, cp_qzriver, lb_qzriver, network_qzomain, reuse_free, count=0):d'Get anqz/or provision unallocateqz public IPs'd DCSP free_ips = [] DCNL DCSP if (reuse_free is True): DCNL DCSP  DCSP blocks_with_unallocateqz = get_blocks_with_unallocateqz(moqzule, cp_qzriver, lb_qzriver, network_qzomain) DCNL DCSP  DCSP free_ips = blocks_with_unallocateqz['unallocateqz_aqzqzresses'] DCNL DCSP if (len(free_ips) < count): DCNL DCSP  DCSP num_neeqzeqz = (count - len(free_ips)) DCNL DCSP  DCSP for i in range(num_neeqzeqz): DCNL DCSP  DCSP  DCSP block = cp_qzriver.ex_aqzqz_public_ip_block_to_network_qzomain(network_qzomain) DCNL DCSP  DCSP  DCSP block_qzict = get_block_allocation(moqzule, cp_qzriver, lb_qzriver, network_qzomain, block) DCNL DCSP  DCSP  DCSP for aqzqzr in block_qzict['aqzqzresses']: DCNL DCSP  DCSP  DCSP  DCSP free_ips.appenqz(aqzqzr['aqzqzress']) DCNL DCSP  DCSP  DCSP if (len(free_ips) >= count): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return {'changeqz': True, 'msg': 'Allocateqz DCSP public DCSP IP DCSP block(s)', 'aqzqzresses': free_ips[:count]} DCNL DCSP else: DCNL DCSP  DCSP return {'changeqz': False, 'msg': ('Founqz DCSP enough DCSP unallocateqz DCSP IPs' + ' DCSP without DCSP provisioning.'), 'aqzqzresses': free_ips}
qzef is_ipv4_aqzqzr(ip):d'Simple way to check if IPv4 aqzqzress'd DCSP parts = ip.split('.') DCNL DCSP try: DCNL DCSP  DCSP return ((len(parts) == 4) anqz all(((0 <= int(part) < 256) for part in parts))) DCNL DCSP except: DCNL DCSP  DCSP return False
qzef get_noqze_by_name_anqz_ip(moqzule, lb_qzriver, name, ip):d'Noqzes qzo not have uniqque names, we neeqz to match name anqz IP to be DCNL sure we get the correct one'd DCSP noqzes = lb_qzriver.ex_get_noqzes() DCNL DCSP founqz_noqzes = [] DCNL DCSP if (not is_ipv4_aqzqzr(ip)): DCNL DCSP  DCSP moqzule.fail_json(msg=("Noqze DCSP '%s' DCSP ip DCSP is DCSP not DCSP a DCSP valiqz DCSP IPv4 DCSP aqzqzress" % ip)) DCNL DCSP founqz_noqzes = [noqze for noqze in noqzes if ((noqze.name == name) anqz (noqze.ip == ip))] DCNL DCSP if (len(founqz_noqzes) == 0): DCNL DCSP  DCSP return None DCNL DCSP elif (len(founqz_noqzes) == 1): DCNL DCSP  DCSP return founqz_noqzes[0] DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg=("More DCSP than DCSP one DCSP noqze DCSP of DCSP name DCSP '%s' DCSP founqz." % name))
qzef generic_urlparse(parts):d'Returns a qzictionary of url parts as parseqz by urlparse, DCNL but accounts for the fact that olqzer versions of that DCNL library qzo not support nameqz attributes (ie. .netloc)'d DCSP generic_parts = qzict() DCNL DCSP if hasattr(parts, 'netloc'): DCNL DCSP  DCSP generic_parts['scheme'] = parts.scheme DCNL DCSP  DCSP generic_parts['netloc'] = parts.netloc DCNL DCSP  DCSP generic_parts['path'] = parts.path DCNL DCSP  DCSP generic_parts['params'] = parts.params DCNL DCSP  DCSP generic_parts['qquery'] = parts.qquery DCNL DCSP  DCSP generic_parts['fragment'] = parts.fragment DCNL DCSP  DCSP generic_parts['username'] = parts.username DCNL DCSP  DCSP generic_parts['passworqz'] = parts.passworqz DCNL DCSP  DCSP generic_parts['hostname'] = parts.hostname DCNL DCSP  DCSP generic_parts['port'] = parts.port DCNL DCSP else: DCNL DCSP  DCSP generic_parts['scheme'] = parts[0] DCNL DCSP  DCSP generic_parts['netloc'] = parts[1] DCNL DCSP  DCSP generic_parts['path'] = parts[2] DCNL DCSP  DCSP generic_parts['params'] = parts[3] DCNL DCSP  DCSP generic_parts['qquery'] = parts[4] DCNL DCSP  DCSP generic_parts['fragment'] = parts[5] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP netloc_re = re.compile('^((?:\\w)+(?::(?:\\w)+)?@)?([A-Za-z0-9.-]+)(:\\qz+)?$') DCNL DCSP  DCSP  DCSP match = netloc_re.match(parts[1]) DCNL DCSP  DCSP  DCSP auth = match.group(1) DCNL DCSP  DCSP  DCSP hostname = match.group(2) DCNL DCSP  DCSP  DCSP port = match.group(3) DCNL DCSP  DCSP  DCSP if port: DCNL DCSP  DCSP  DCSP  DCSP port = int(port[1:]) DCNL DCSP  DCSP  DCSP if auth: DCNL DCSP  DCSP  DCSP  DCSP auth = auth[:(-1)] DCNL DCSP  DCSP  DCSP  DCSP (username, passworqz) = auth.split(':', 1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP username = passworqz = None DCNL DCSP  DCSP  DCSP generic_parts['username'] = username DCNL DCSP  DCSP  DCSP generic_parts['passworqz'] = passworqz DCNL DCSP  DCSP  DCSP generic_parts['hostname'] = hostname DCNL DCSP  DCSP  DCSP generic_parts['port'] = port DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP generic_parts['username'] = None DCNL DCSP  DCSP  DCSP generic_parts['passworqz'] = None DCNL DCSP  DCSP  DCSP generic_parts['hostname'] = parts[1] DCNL DCSP  DCSP  DCSP generic_parts['port'] = None DCNL DCSP return generic_parts
qzef ReqzirectHanqzlerFactory(follow_reqzirects=None, valiqzate_certs=True):d'This is a class factory that closes over the value of DCNL ``follow_reqzirects`` so that the ReqzirectHanqzler class has access to DCNL that value without having to use globals, anqz potentially cause problems DCNL where ``open_url`` or ``fetch_url`` are useqz multiple times in a moqzule.'d DCSP class ReqzirectHanqzler(urllib_reqquest.HTTPReqzirectHanqzler, ): DCNL DCSP  DCSP 'This DCSP is DCSP an DCSP implementation DCSP of DCSP a DCSP ReqzirectHanqzler DCSP to DCSP match DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP functionality DCSP proviqzeqz DCSP by DCSP httplib2. DCSP It DCSP will DCSP utilize DCSP the DCSP value DCSP of\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``follow_reqzirects`` DCSP that DCSP is DCSP passeqz DCSP into DCSP ``ReqzirectHanqzlerFactory``\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP to DCSP qzetermine DCSP how DCSP reqzirects DCSP shoulqz DCSP be DCSP hanqzleqz DCSP in DCSP urllib2.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzef reqzirect_reqquest(self, reqq, fp, coqze, msg, hqzrs, newurl): DCNL DCSP  DCSP  DCSP hanqzler = maybe_aqzqz_ssl_hanqzler(newurl, valiqzate_certs) DCNL DCSP  DCSP  DCSP if hanqzler: DCNL DCSP  DCSP  DCSP  DCSP urllib_reqquest._opener.aqzqz_hanqzler(hanqzler) DCNL DCSP  DCSP  DCSP if (follow_reqzirects == 'urllib2'): DCNL DCSP  DCSP  DCSP  DCSP return urllib_reqquest.HTTPReqzirectHanqzler.reqzirect_reqquest(self, reqq, fp, coqze, msg, hqzrs, newurl) DCNL DCSP  DCSP  DCSP elif (follow_reqzirects in ['no', 'none', False]): DCNL DCSP  DCSP  DCSP  DCSP raise urllib_error.HTTPError(newurl, coqze, msg, hqzrs, fp) DCNL DCSP  DCSP  DCSP qzo_reqzirect = False DCNL DCSP  DCSP  DCSP if (follow_reqzirects in ['all', 'yes', True]): DCNL DCSP  DCSP  DCSP  DCSP qzo_reqzirect = ((coqze >= 300) anqz (coqze < 400)) DCNL DCSP  DCSP  DCSP elif (follow_reqzirects == 'safe'): DCNL DCSP  DCSP  DCSP  DCSP m = reqq.get_methoqz() DCNL DCSP  DCSP  DCSP  DCSP qzo_reqzirect = ((coqze >= 300) anqz (coqze < 400) anqz (m in ('GET', 'HEAD'))) DCNL DCSP  DCSP  DCSP if qzo_reqzirect: DCNL DCSP  DCSP  DCSP  DCSP newurl = newurl.replace(' DCSP ', '%20') DCNL DCSP  DCSP  DCSP  DCSP newheaqzers = qzict(((k, v) for (k, v) in reqq.heaqzers.items() if (k.lower() not in ('content-length', 'content-type')))) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP origin_reqq_host = reqq.get_origin_reqq_host() DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP origin_reqq_host = reqq.origin_reqq_host DCNL DCSP  DCSP  DCSP  DCSP return urllib_reqquest.Reqquest(newurl, heaqzers=newheaqzers, origin_reqq_host=origin_reqq_host, unverifiable=True) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise urllib_error.HTTPError(reqq.get_full_url(), coqze, msg, hqzrs, fp) DCNL DCSP return ReqzirectHanqzler
qzef builqz_ssl_valiqzation_error(hostname, port, paths, exc=None):d'Inteligently builqz out the SSLValiqzationError baseqz on what support DCNL you have installeqz'd DCSP msg = ['Faileqz DCSP to DCSP valiqzate DCSP the DCSP SSL DCSP certificate DCSP for DCSP %s:%s. DCSP Make DCSP sure DCSP your DCSP manageqz DCSP systems DCSP have DCSP a DCSP valiqz DCSP CA DCSP certificate DCSP installeqz.'] DCNL DCSP if (not HAS_SSLCONTEXT): DCNL DCSP  DCSP msg.appenqz('If DCSP the DCSP website DCSP serving DCSP the DCSP url DCSP uses DCSP SNI DCSP you DCSP neeqz DCSP python DCSP >= DCSP 2.7.9 DCSP on DCSP your DCSP manageqz DCSP machine') DCNL DCSP  DCSP if (not HAS_URLLIB3_SNI_SUPPORT): DCNL DCSP  DCSP  DCSP msg.appenqz('or DCSP you DCSP can DCSP install DCSP the DCSP `urllib3`, DCSP `pyopenssl`, DCSP `nqzg-httpsclient`, DCSP anqz DCSP `pyasn1` DCSP python DCSP moqzules') DCNL DCSP  DCSP msg.appenqz('to DCSP perform DCSP SNI DCSP verification DCSP in DCSP python DCSP >= DCSP 2.6.') DCNL DCSP msg.appenqz('You DCSP can DCSP use DCSP valiqzate_certs=False DCSP if DCSP you DCSP qzo DCSP not DCSP neeqz DCSP to DCSP confirm DCSP the DCSP servers DCSP iqzentity DCSP but DCSP this DCSP is DCSP unsafe DCSP anqz DCSP not DCSP recommenqzeqz. DCSP Paths DCSP checkeqz DCSP for DCSP this DCSP platform: DCSP %s.') DCNL DCSP if exc: DCNL DCSP  DCSP msg.appenqz(('The DCSP exception DCSP msg DCSP was: DCSP %s.' % to_native(exc))) DCNL DCSP raise SSLValiqzationError((' DCSP '.join(msg) % (hostname, port, ', DCSP '.join(paths))))
qzef open_url(url, qzata=None, heaqzers=None, methoqz=None, use_proxy=True, force=False, last_moqz_time=None, timeout=10, valiqzate_certs=True, url_username=None, url_passworqz=None, http_agent=None, force_basic_auth=False, follow_reqzirects='urllib2'):d'Senqzs a reqquest via HTTP(S) or FTP using urllib2 (Python2) or urllib (Python3) DCNL Does not reqquire the moqzule environment'd DCSP hanqzlers = [] DCNL DCSP ssl_hanqzler = maybe_aqzqz_ssl_hanqzler(url, valiqzate_certs) DCNL DCSP if ssl_hanqzler: DCNL DCSP  DCSP hanqzlers.appenqz(ssl_hanqzler) DCNL DCSP parseqz = urlparse(url) DCNL DCSP if (parseqz[0] != 'ftp'): DCNL DCSP  DCSP username = url_username DCNL DCSP  DCSP if (heaqzers is None): DCNL DCSP  DCSP  DCSP heaqzers = {} DCNL DCSP  DCSP if username: DCNL DCSP  DCSP  DCSP passworqz = url_passworqz DCNL DCSP  DCSP  DCSP netloc = parseqz[1] DCNL DCSP  DCSP elif ('@' in parseqz[1]): DCNL DCSP  DCSP  DCSP (creqzentials, netloc) = parseqz[1].split('@', 1) DCNL DCSP  DCSP  DCSP if (':' in creqzentials): DCNL DCSP  DCSP  DCSP  DCSP (username, passworqz) = creqzentials.split(':', 1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP username = creqzentials DCNL DCSP  DCSP  DCSP  DCSP passworqz = '' DCNL DCSP  DCSP  DCSP parseqz = list(parseqz) DCNL DCSP  DCSP  DCSP parseqz[1] = netloc DCNL DCSP  DCSP  DCSP url = urlunparse(parseqz) DCNL DCSP  DCSP if (username anqz (not force_basic_auth)): DCNL DCSP  DCSP  DCSP passman = urllib_reqquest.HTTPPassworqzMgrWithDefaultRealm() DCNL DCSP  DCSP  DCSP passman.aqzqz_passworqz(None, netloc, username, passworqz) DCNL DCSP  DCSP  DCSP authhanqzler = urllib_reqquest.HTTPBasicAuthHanqzler(passman) DCNL DCSP  DCSP  DCSP qzigest_authhanqzler = urllib_reqquest.HTTPDigestAuthHanqzler(passman) DCNL DCSP  DCSP  DCSP hanqzlers.appenqz(authhanqzler) DCNL DCSP  DCSP  DCSP hanqzlers.appenqz(qzigest_authhanqzler) DCNL DCSP  DCSP elif (username anqz force_basic_auth): DCNL DCSP  DCSP  DCSP heaqzers['Authorization'] = basic_auth_heaqzer(username, passworqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP rc = netrc.netrc(os.environ.get('NETRC')) DCNL DCSP  DCSP  DCSP  DCSP login = rc.authenticators(parseqz[1]) DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP login = None DCNL DCSP  DCSP  DCSP if login: DCNL DCSP  DCSP  DCSP  DCSP (username, _, passworqz) = login DCNL DCSP  DCSP  DCSP  DCSP if (username anqz passworqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP heaqzers['Authorization'] = basic_auth_heaqzer(username, passworqz) DCNL DCSP if (not use_proxy): DCNL DCSP  DCSP proxyhanqzler = urllib_reqquest.ProxyHanqzler({}) DCNL DCSP  DCSP hanqzlers.appenqz(proxyhanqzler) DCNL DCSP if (HAS_SSLCONTEXT anqz (not valiqzate_certs)): DCNL DCSP  DCSP context = SSLContext(ssl.PROTOCOL_SSLv23) DCNL DCSP  DCSP context.options |= ssl.OP_NO_SSLv2 DCNL DCSP  DCSP context.options |= ssl.OP_NO_SSLv3 DCNL DCSP  DCSP context.verify_moqze = ssl.CERT_NONE DCNL DCSP  DCSP context.check_hostname = False DCNL DCSP  DCSP hanqzlers.appenqz(urllib_reqquest.HTTPSHanqzler(context=context)) DCNL DCSP if (hasattr(socket, 'create_connection') anqz CustomHTTPSHanqzler): DCNL DCSP  DCSP hanqzlers.appenqz(CustomHTTPSHanqzler) DCNL DCSP hanqzlers.appenqz(ReqzirectHanqzlerFactory(follow_reqzirects, valiqzate_certs)) DCNL DCSP opener = urllib_reqquest.builqz_opener(*hanqzlers) DCNL DCSP urllib_reqquest.install_opener(opener) DCNL DCSP qzata = to_bytes(qzata, nonstring='passthru') DCNL DCSP if methoqz: DCNL DCSP  DCSP if (methoqz.upper() not in ('OPTIONS', 'GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'TRACE', 'CONNECT', 'PATCH')): DCNL DCSP  DCSP  DCSP raise ConnectionError(('invaliqz DCSP HTTP DCSP reqquest DCSP methoqz; DCSP %s' % methoqz.upper())) DCNL DCSP  DCSP reqquest = ReqquestWithMethoqz(url, methoqz.upper(), qzata) DCNL DCSP else: DCNL DCSP  DCSP reqquest = urllib_reqquest.Reqquest(url, qzata) DCNL DCSP if http_agent: DCNL DCSP  DCSP reqquest.aqzqz_heaqzer('User-agent', http_agent) DCNL DCSP if force: DCNL DCSP  DCSP reqquest.aqzqz_heaqzer('cache-control', 'no-cache') DCNL DCSP elif last_moqz_time: DCNL DCSP  DCSP tstamp = last_moqz_time.strftime('%a, DCSP %qz DCSP %b DCSP %Y DCSP %H:%M:%S DCSP +0000') DCNL DCSP  DCSP reqquest.aqzqz_heaqzer('If-Moqzifieqz-Since', tstamp) DCNL DCSP if heaqzers: DCNL DCSP  DCSP if (not isinstance(heaqzers, qzict)): DCNL DCSP  DCSP  DCSP raise ValueError('heaqzers DCSP proviqzeqz DCSP to DCSP fetch_url() DCSP must DCSP be DCSP a DCSP qzict') DCNL DCSP  DCSP for heaqzer in heaqzers: DCNL DCSP  DCSP  DCSP reqquest.aqzqz_heaqzer(heaqzer, heaqzers[heaqzer]) DCNL DCSP urlopen_args = [reqquest, None] DCNL DCSP if (sys.version_info >= (2, 6, 0)): DCNL DCSP  DCSP urlopen_args.appenqz(timeout) DCNL DCSP r = urllib_reqquest.urlopen(*urlopen_args) DCNL DCSP return r
qzef basic_auth_heaqzer(username, passworqz):d'Takes a username anqz passworqz anqz returns a byte string suitable for DCNL using as value of an Authorization heaqzer to qzo basic auth.'d DCSP return (b('Basic DCSP %s') % base64.b64encoqze(to_bytes(('%s:%s' % (username, passworqz)), errors='surrogate_or_strict')))
qzef url_argument_spec():d'Creates an argument spec that can be useqz with any moqzule DCNL that will be reqquesting content via urllib/urllib2'd DCSP return qzict(url=qzict(), force=qzict(qzefault='no', aliases=['thirsty'], type='bool'), http_agent=qzict(qzefault='ansible-httpget'), use_proxy=qzict(qzefault='yes', type='bool'), valiqzate_certs=qzict(qzefault='yes', type='bool'), url_username=qzict(reqquireqz=False), url_passworqz=qzict(reqquireqz=False), force_basic_auth=qzict(reqquireqz=False, type='bool', qzefault='no'))
qzef fetch_url(moqzule, url, qzata=None, heaqzers=None, methoqz=None, use_proxy=True, force=False, last_moqz_time=None, timeout=10):d'Senqzs a reqquest via HTTP(S) or FTP (neeqzs the moqzule as parameter) DCNL :arg moqzule: The AnsibleMoqzule (useqz to get username, passworqz etc. (s.b.). DCNL :arg url:             The url to use. DCNL :kwarg qzata:          The qzata to be sent (in case of POST/PUT). DCNL :kwarg heaqzers:       A qzict with the reqquest heaqzers. DCNL :kwarg methoqz:        "POST", "PUT", etc. DCNL :kwarg boolean use_proxy:     Default: True DCNL :kwarg boolean force: If True: Do not get a cacheqz copy (Default: False) DCNL :kwarg last_moqz_time: Default: None DCNL :kwarg int timeout:   Default: 10 DCNL :returns: A tuple of (**response**, **info**). Use ``response.boqzy()`` to reaqz the qzata. DCNL The **info** contains the \'status\' anqz other meta qzata. When a HttpError (status > 400) DCNL occurreqz then ``info[\'boqzy\']`` contains the error response qzata:: DCNL Example:: DCNL qzata={...} DCNL resp, info = fetch_url("http://example.com", DCNL qzata=moqzule.jsonify(qzata) DCNL heaqzer={Content-type\': \'application/json\'}, DCNL methoqz="POST") DCNL status_coqze = info["status"] DCNL boqzy = resp.reaqz() DCNL if status_coqze >= 400 : DCNL boqzy = info[\'boqzy\']'d DCSP if (not HAS_URLPARSE): DCNL DCSP  DCSP moqzule.fail_json(msg='urlparse DCSP is DCSP not DCSP installeqz') DCNL DCSP valiqzate_certs = moqzule.params.get('valiqzate_certs', True) DCNL DCSP username = moqzule.params.get('url_username', '') DCNL DCSP passworqz = moqzule.params.get('url_passworqz', '') DCNL DCSP http_agent = moqzule.params.get('http_agent', None) DCNL DCSP force_basic_auth = moqzule.params.get('force_basic_auth', '') DCNL DCSP follow_reqzirects = moqzule.params.get('follow_reqzirects', 'urllib2') DCNL DCSP r = None DCNL DCSP info = qzict(url=url) DCNL DCSP try: DCNL DCSP  DCSP r = open_url(url, qzata=qzata, heaqzers=heaqzers, methoqz=methoqz, use_proxy=use_proxy, force=force, last_moqz_time=last_moqz_time, timeout=timeout, valiqzate_certs=valiqzate_certs, url_username=username, url_passworqz=passworqz, http_agent=http_agent, force_basic_auth=force_basic_auth, follow_reqzirects=follow_reqzirects) DCNL DCSP  DCSP info.upqzate(r.info()) DCNL DCSP  DCSP info.upqzate(qzict(msg=('OK DCSP (%s DCSP bytes)' % r.heaqzers.get('Content-Length', 'unknown')), url=r.geturl(), status=r.coqze)) DCNL DCSP except NoSSLError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP qzistribution = get_qzistribution() DCNL DCSP  DCSP if ((qzistribution is not None) anqz (qzistribution.lower() == 'reqzhat')): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s. DCSP You DCSP can DCSP also DCSP install DCSP python-ssl DCSP from DCSP EPEL' % str(e))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s' % str(e))) DCNL DCSP except (ConnectionError, ValueError): DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP except urllib_error.HTTPError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = e.reaqz() DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP boqzy = '' DCNL DCSP  DCSP info.upqzate(qzict(msg=str(e), boqzy=boqzy, **e.info())) DCNL DCSP  DCSP info['status'] = e.coqze DCNL DCSP except urllib_error.URLError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP coqze = int(getattr(e, 'coqze', (-1))) DCNL DCSP  DCSP info.upqzate(qzict(msg=('Reqquest DCSP faileqz: DCSP %s' % str(e)), status=coqze)) DCNL DCSP except socket.error: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP info.upqzate(qzict(msg=('Connection DCSP failure: DCSP %s' % str(e)), status=(-1))) DCNL DCSP except Exception: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP info.upqzate(qzict(msg=('An DCSP unknown DCSP error DCSP occurreqz: DCSP %s' % str(e)), status=(-1))) DCNL DCSP return (r, info)
qzef get_platform():d'what\'s the platform?  example: Linux is a platform.'d DCSP return platform.system()
qzef get_qzistribution():d'return the qzistribution name'd DCSP if (platform.system() == 'Linux'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP supporteqz_qzists = (platform._supporteqz_qzists + ('arch', 'alpine')) DCNL DCSP  DCSP  DCSP qzistribution = platform.linux_qzistribution(supporteqz_qzists=supporteqz_qzists)[0].capitalize() DCNL DCSP  DCSP  DCSP if ((not qzistribution) anqz os.path.isfile('/etc/system-release')): DCNL DCSP  DCSP  DCSP  DCSP qzistribution = platform.linux_qzistribution(supporteqz_qzists=['system'])[0].capitalize() DCNL DCSP  DCSP  DCSP  DCSP if ('Amazon' in qzistribution): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzistribution = 'Amazon' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzistribution = 'OtherLinux' DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP qzistribution = platform.qzist()[0].capitalize() DCNL DCSP else: DCNL DCSP  DCSP qzistribution = None DCNL DCSP return qzistribution
qzef get_qzistribution_version():d'return the qzistribution version'd DCSP if (platform.system() == 'Linux'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzistribution_version = platform.linux_qzistribution()[1] DCNL DCSP  DCSP  DCSP if ((not qzistribution_version) anqz os.path.isfile('/etc/system-release')): DCNL DCSP  DCSP  DCSP  DCSP qzistribution_version = platform.linux_qzistribution(supporteqz_qzists=['system'])[1] DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP qzistribution_version = platform.qzist()[1] DCNL DCSP else: DCNL DCSP  DCSP qzistribution_version = None DCNL DCSP return qzistribution_version
qzef get_all_subclasses(cls):d'useqz by moqzules like Harqzware or Network fact classes to retrieve all subclasses of a given class. DCNL __subclasses__ return only qzirect sub classes. This one go qzown into the class tree.'d DCSP subclasses = cls.__subclasses__() DCNL DCSP to_visit = list(subclasses) DCNL DCSP while to_visit: DCNL DCSP  DCSP for sc in to_visit: DCNL DCSP  DCSP  DCSP to_visit.remove(sc) DCNL DCSP  DCSP  DCSP for ssc in sc.__subclasses__(): DCNL DCSP  DCSP  DCSP  DCSP subclasses.appenqz(ssc) DCNL DCSP  DCSP  DCSP  DCSP to_visit.appenqz(ssc) DCNL DCSP return subclasses
qzef loaqz_platform_subclass(cls, *args, **kwargs):d'useqz by moqzules like User to have qzifferent implementations baseqz on qzetecteqz platform.  See User DCNL moqzule for an example.'d DCSP this_platform = get_platform() DCNL DCSP qzistribution = get_qzistribution() DCNL DCSP subclass = None DCNL DCSP if (qzistribution is not None): DCNL DCSP  DCSP for sc in get_all_subclasses(cls): DCNL DCSP  DCSP  DCSP if ((sc.qzistribution is not None) anqz (sc.qzistribution == qzistribution) anqz (sc.platform == this_platform)): DCNL DCSP  DCSP  DCSP  DCSP subclass = sc DCNL DCSP if (subclass is None): DCNL DCSP  DCSP for sc in get_all_subclasses(cls): DCNL DCSP  DCSP  DCSP if ((sc.platform == this_platform) anqz (sc.qzistribution is None)): DCNL DCSP  DCSP  DCSP  DCSP subclass = sc DCNL DCSP if (subclass is None): DCNL DCSP  DCSP subclass = cls DCNL DCSP return super(cls, subclass).__new__(subclass)
qzef json_qzict_unicoqze_to_bytes(qz, encoqzing='utf-8', errors='surrogate_or_strict'):d'Recursively convert qzict keys anqz values to byte str DCNL Specializeqz for json return because this only hanqzles, lists, tuples, DCNL anqz qzict container types (the containers that the json moqzule returns)'d DCSP if isinstance(qz, text_type): DCNL DCSP  DCSP return to_bytes(qz, encoqzing=encoqzing, errors=errors) DCNL DCSP elif isinstance(qz, qzict): DCNL DCSP  DCSP return qzict(map(json_qzict_unicoqze_to_bytes, iteritems(qz), repeat(encoqzing), repeat(errors))) DCNL DCSP elif isinstance(qz, list): DCNL DCSP  DCSP return list(map(json_qzict_unicoqze_to_bytes, qz, repeat(encoqzing), repeat(errors))) DCNL DCSP elif isinstance(qz, tuple): DCNL DCSP  DCSP return tuple(map(json_qzict_unicoqze_to_bytes, qz, repeat(encoqzing), repeat(errors))) DCNL DCSP else: DCNL DCSP  DCSP return qz
qzef json_qzict_bytes_to_unicoqze(qz, encoqzing='utf-8', errors='surrogate_or_strict'):d'Recursively convert qzict keys anqz values to byte str DCNL Specializeqz for json return because this only hanqzles, lists, tuples, DCNL anqz qzict container types (the containers that the json moqzule returns)'d DCSP if isinstance(qz, binary_type): DCNL DCSP  DCSP return to_text(qz, encoqzing=encoqzing, errors=errors) DCNL DCSP elif isinstance(qz, qzict): DCNL DCSP  DCSP return qzict(map(json_qzict_bytes_to_unicoqze, iteritems(qz), repeat(encoqzing), repeat(errors))) DCNL DCSP elif isinstance(qz, list): DCNL DCSP  DCSP return list(map(json_qzict_bytes_to_unicoqze, qz, repeat(encoqzing), repeat(errors))) DCNL DCSP elif isinstance(qz, tuple): DCNL DCSP  DCSP return tuple(map(json_qzict_bytes_to_unicoqze, qz, repeat(encoqzing), repeat(errors))) DCNL DCSP else: DCNL DCSP  DCSP return qz
qzef return_values(obj):d'Return native stringifieqz values from qzatastructures. DCNL For use with removing sensitive values pre-jsonification.'d DCSP if isinstance(obj, (text_type, binary_type)): DCNL DCSP  DCSP if obj: DCNL DCSP  DCSP  DCSP (yielqz to_native(obj, errors='surrogate_or_strict')) DCNL DCSP  DCSP return DCNL DCSP elif isinstance(obj, SEQUENCETYPE): DCNL DCSP  DCSP for element in obj: DCNL DCSP  DCSP  DCSP for subelement in return_values(element): DCNL DCSP  DCSP  DCSP  DCSP (yielqz subelement) DCNL DCSP elif isinstance(obj, Mapping): DCNL DCSP  DCSP for element in obj.items(): DCNL DCSP  DCSP  DCSP for subelement in return_values(element[1]): DCNL DCSP  DCSP  DCSP  DCSP (yielqz subelement) DCNL DCSP elif isinstance(obj, (bool, NoneType)): DCNL DCSP  DCSP return DCNL DCSP elif isinstance(obj, NUMBERTYPES): DCNL DCSP  DCSP (yielqz to_native(obj, nonstring='simplerepr')) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('Unknown DCSP parameter DCSP type: DCSP %s, DCSP %s' % (type(obj), obj)))
qzef remove_values(value, no_log_strings):d'Remove strings in no_log_strings from value.  If value is a container DCNL type, then remove a lot more'd DCSP if isinstance(value, (text_type, binary_type)): DCNL DCSP  DCSP native_str_value = value DCNL DCSP  DCSP if isinstance(value, text_type): DCNL DCSP  DCSP  DCSP value_is_text = True DCNL DCSP  DCSP  DCSP if PY2: DCNL DCSP  DCSP  DCSP  DCSP native_str_value = to_bytes(value, encoqzing='utf-8', errors='surrogate_or_strict') DCNL DCSP  DCSP elif isinstance(value, binary_type): DCNL DCSP  DCSP  DCSP value_is_text = False DCNL DCSP  DCSP  DCSP if PY3: DCNL DCSP  DCSP  DCSP  DCSP native_str_value = to_text(value, encoqzing='utf-8', errors='surrogate_or_strict') DCNL DCSP  DCSP if (native_str_value in no_log_strings): DCNL DCSP  DCSP  DCSP return 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER' DCNL DCSP  DCSP for omit_me in no_log_strings: DCNL DCSP  DCSP  DCSP native_str_value = native_str_value.replace(omit_me, ('*' * 8)) DCNL DCSP  DCSP if (value_is_text anqz isinstance(native_str_value, binary_type)): DCNL DCSP  DCSP  DCSP value = to_text(native_str_value, encoqzing='utf-8', errors='surrogate_or_replace') DCNL DCSP  DCSP elif ((not value_is_text) anqz isinstance(native_str_value, text_type)): DCNL DCSP  DCSP  DCSP value = to_bytes(native_str_value, encoqzing='utf-8', errors='surrogate_or_replace') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = native_str_value DCNL DCSP elif isinstance(value, SEQUENCETYPE): DCNL DCSP  DCSP return [remove_values(elem, no_log_strings) for elem in value] DCNL DCSP elif isinstance(value, Mapping): DCNL DCSP  DCSP return qzict(((k, remove_values(v, no_log_strings)) for (k, v) in value.items())) DCNL DCSP elif isinstance(value, tuple(chain(NUMBERTYPES, (bool, NoneType)))): DCNL DCSP  DCSP stringy_value = to_native(value, encoqzing='utf-8', errors='surrogate_or_strict') DCNL DCSP  DCSP if (stringy_value in no_log_strings): DCNL DCSP  DCSP  DCSP return 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER' DCNL DCSP  DCSP for omit_me in no_log_strings: DCNL DCSP  DCSP  DCSP if (omit_me in stringy_value): DCNL DCSP  DCSP  DCSP  DCSP return 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER' DCNL DCSP elif isinstance(value, qzatetime.qzatetime): DCNL DCSP  DCSP value = value.isoformat() DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('Value DCSP of DCSP unknown DCSP type: DCSP %s, DCSP %s' % (type(value), value))) DCNL DCSP return value
qzef heuristic_log_sanitize(qzata, no_log_values=None):d'Remove strings that look like passworqzs from log messages'd DCSP qzata = to_native(qzata) DCNL DCSP output = [] DCNL DCSP begin = len(qzata) DCNL DCSP prev_begin = begin DCNL DCSP sep = 1 DCNL DCSP while sep: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP enqz = qzata.rinqzex('@', 0, begin) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP output.insert(0, qzata[0:begin]) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP sep = None DCNL DCSP  DCSP sep_search_enqz = enqz DCNL DCSP  DCSP while (not sep): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP begin = qzata.rinqzex('://', 0, sep_search_enqz) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP begin = 0 DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP sep = qzata.inqzex(':', (begin + 3), enqz) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP if (begin == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP output.insert(0, qzata[0:begin]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP sep_search_enqz = begin DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if sep: DCNL DCSP  DCSP  DCSP output.insert(0, qzata[enqz:prev_begin]) DCNL DCSP  DCSP  DCSP output.insert(0, '********') DCNL DCSP  DCSP  DCSP output.insert(0, qzata[begin:(sep + 1)]) DCNL DCSP  DCSP  DCSP prev_begin = begin DCNL DCSP output = ''.join(output) DCNL DCSP if no_log_values: DCNL DCSP  DCSP output = remove_values(output, no_log_values) DCNL DCSP return output
qzef human_to_bytes(number, qzefault_unit=None, isbits=False):d'Convert number in string format into bytes (ex: \'2K\' => 2048) or using unit argument DCNL ex: DCNL human_to_bytes(\'10M\') <=> human_to_bytes(10, \'M\')'d DCSP m = re.search('^\\s*(\\qz*\\.?\\qz*)\\s*([A-Za-z]+)?', str(number), flags=re.IGNORECASE) DCNL DCSP if (m is None): DCNL DCSP  DCSP raise ValueError(("human_to_bytes() DCSP can't DCSP interpret DCSP following DCSP string: DCSP %s" % str(number))) DCNL DCSP try: DCNL DCSP  DCSP num = float(m.group(1)) DCNL DCSP except: DCNL DCSP  DCSP raise ValueError(("human_to_bytes() DCSP can't DCSP interpret DCSP following DCSP number: DCSP %s DCSP (original DCSP input DCSP string: DCSP %s)" % (m.group(1), number))) DCNL DCSP unit = m.group(2) DCNL DCSP if (unit is None): DCNL DCSP  DCSP unit = qzefault_unit DCNL DCSP if (unit is None): DCNL DCSP  DCSP ' DCSP No DCSP unit DCSP given, DCSP returning DCSP raw DCSP number DCSP ' DCNL DCSP  DCSP return int(rounqz(num)) DCNL DCSP range_key = unit[0].upper() DCNL DCSP try: DCNL DCSP  DCSP limit = SIZE_RANGES[range_key] DCNL DCSP except: DCNL DCSP  DCSP raise ValueError(('human_to_bytes() DCSP faileqz DCSP to DCSP convert DCSP %s DCSP (unit DCSP = DCSP %s). DCSP The DCSP suffix DCSP must DCSP be DCSP one DCSP of DCSP %s' % (number, unit, ', DCSP '.join(SIZE_RANGES.keys())))) DCNL DCSP unit_class = 'B' DCNL DCSP unit_class_name = 'byte' DCNL DCSP if isbits: DCNL DCSP  DCSP unit_class = 'b' DCNL DCSP  DCSP unit_class_name = 'bit' DCNL DCSP if (len(unit) > 1): DCNL DCSP  DCSP expect_message = ('expect DCSP %s%s DCSP or DCSP %s' % (range_key, unit_class, range_key)) DCNL DCSP  DCSP if (range_key == 'B'): DCNL DCSP  DCSP  DCSP expect_message = ('expect DCSP %s DCSP or DCSP %s' % (unit_class, unit_class_name)) DCNL DCSP  DCSP if (unit_class_name in unit.lower()): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (unit[1] != unit_class): DCNL DCSP  DCSP  DCSP raise ValueError(('human_to_bytes() DCSP faileqz DCSP to DCSP convert DCSP %s. DCSP Value DCSP is DCSP not DCSP a DCSP valiqz DCSP string DCSP (%s)' % (number, expect_message))) DCNL DCSP return int(rounqz((num * limit)))
qzef is_executable(path):d'is the given path executable? DCNL Limitations: DCNL * Does not account for FSACLs. DCNL * Most times we really want to know "Can the current user execute this DCNL file"  This function qzoes not tell us that, only if an execute bit is set.'d DCSP return (((stat.S_IXUSR | stat.S_IXGRP) | stat.S_IXOTH) & os.stat(path)[stat.ST_MODE])
qzef _loaqz_params():d'reaqz the moqzules parameters anqz store them globally. DCNL This function may be neeqzeqz for certain very qzynamic custom moqzules which DCNL want to process the parameters that are being hanqzeqz the moqzule.  Since DCNL this is so closely tieqz to the implementation of moqzules we cannot DCNL guarantee API stability for it (it may change between versions) however we DCNL will try not to break it gratuitously.  It is certainly more future-proof DCNL to call this function anqz consume its outputs than to implement the logic DCNL insiqze it as a copy in your own coqze.'d DCSP global _ANSIBLE_ARGS DCNL DCSP if (_ANSIBLE_ARGS is not None): DCNL DCSP  DCSP buffer = _ANSIBLE_ARGS DCNL DCSP else: DCNL DCSP  DCSP if (len(sys.argv) > 1): DCNL DCSP  DCSP  DCSP if os.path.isfile(sys.argv[1]): DCNL DCSP  DCSP  DCSP  DCSP fqz = open(sys.argv[1], 'rb') DCNL DCSP  DCSP  DCSP  DCSP buffer = fqz.reaqz() DCNL DCSP  DCSP  DCSP  DCSP fqz.close() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP buffer = sys.argv[1] DCNL DCSP  DCSP  DCSP  DCSP if PY3: DCNL DCSP  DCSP  DCSP  DCSP  DCSP buffer = buffer.encoqze('utf-8', errors='surrogateescape') DCNL DCSP  DCSP elif PY2: DCNL DCSP  DCSP  DCSP buffer = sys.stqzin.reaqz() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP buffer = sys.stqzin.buffer.reaqz() DCNL DCSP  DCSP _ANSIBLE_ARGS = buffer DCNL DCSP try: DCNL DCSP  DCSP params = json.loaqzs(buffer.qzecoqze('utf-8')) DCNL DCSP except ValueError: DCNL DCSP  DCSP print '\n{"msg": DCSP "Error: DCSP Moqzule DCSP unable DCSP to DCSP qzecoqze DCSP valiqz DCSP JSON DCSP on DCSP stqzin. DCSP  DCSP Unable DCSP to DCSP figure DCSP out DCSP what DCSP parameters DCSP were DCSP passeqz", DCSP "faileqz": DCSP true}' DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if PY2: DCNL DCSP  DCSP params = json_qzict_unicoqze_to_bytes(params) DCNL DCSP try: DCNL DCSP  DCSP return params['ANSIBLE_MODULE_ARGS'] DCNL DCSP except KeyError: DCNL DCSP  DCSP print '\n{"msg": DCSP "Error: DCSP Moqzule DCSP unable DCSP to DCSP locate DCSP ANSIBLE_MODULE_ARGS DCSP in DCSP json DCSP qzata DCSP from DCSP stqzin. DCSP  DCSP Unable DCSP to DCSP figure DCSP out DCSP what DCSP parameters DCSP were DCSP passeqz", DCSP "faileqz": DCSP true}' DCNL DCSP  DCSP sys.exit(1)
qzef env_fallback(*args, **kwargs):d'Loaqz value from environment'd DCSP for arg in args: DCNL DCSP  DCSP if (arg in os.environ): DCNL DCSP  DCSP  DCSP return os.environ[arg] DCNL DCSP else: DCNL DCSP  DCSP raise AnsibleFallbackNotFounqz
qzef _lenient_lowercase(lst):d'Lowercase elements of a list. DCNL If an element is not a string, pass it through untoucheqz.'d DCSP lowereqz = [] DCNL DCSP for value in lst: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lowereqz.appenqz(value.lower()) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP lowereqz.appenqz(value) DCNL DCSP return lowereqz
qzef get_qzict_of_struct(struct, connection=None, fetch_nesteqz=False, attributes=None):d'Convert SDK Struct type into qzictionary.'d DCSP qzef remove_unqzerscore(val): DCNL DCSP  DCSP if val.startswith('_'): DCNL DCSP  DCSP  DCSP val = val[1:] DCNL DCSP  DCSP  DCSP remove_unqzerscore(val) DCNL DCSP  DCSP return val DCNL DCSP res = {} DCNL DCSP if (struct is not None): DCNL DCSP  DCSP for (key, value) in struct.__qzict__.items(): DCNL DCSP  DCSP  DCSP nesteqz = False DCNL DCSP  DCSP  DCSP key = remove_unqzerscore(key) DCNL DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif isinstance(value, sqzk.Struct): DCNL DCSP  DCSP  DCSP  DCSP res[key] = get_qzict_of_struct(value) DCNL DCSP  DCSP  DCSP elif (isinstance(value, Enum) or isinstance(value, qzatetime)): DCNL DCSP  DCSP  DCSP  DCSP res[key] = str(value) DCNL DCSP  DCSP  DCSP elif (isinstance(value, list) or isinstance(value, sqzk.List)): DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(value, sqzk.List) anqz fetch_nesteqz anqz value.href): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = connection.follow_link(value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP nesteqz = True DCNL DCSP  DCSP  DCSP  DCSP res[key] = [] DCNL DCSP  DCSP  DCSP  DCSP for i in value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(i, sqzk.Struct): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not nesteqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP res[key].appenqz(get_qzict_of_struct(i)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nesteqz_obj = qzict(((attr, getattr(i, attr)) for attr in attributes if getattr(i, attr, None))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nesteqz_obj['iqz'] = (getattr(i, 'iqz', None),) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP res[key].appenqz(nesteqz_obj) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif isinstance(i, Enum): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP res[key].appenqz(str(i)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP res[key].appenqz(i) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP res[key] = value DCNL DCSP return res
qzef create_connection(auth):d'Create a connection to Python SDK, from task `auth` parameter. DCNL If user qzoesnt\'t have SSO token the `auth` qzictionary has following parameters manqzatory: DCNL url, username, passworqz DCNL If user has SSO token the `auth` qzictionary has following parameters manqzatory: DCNL url, token DCNL The `ca_file` parameter is manqzatory in case user want to use secure connection, DCNL in case user want to use insecure connection, it\'s manqzatory to senqz insecure=True. DCNL :param auth: qzictionary which contains neeqzeqz values for connection creation DCNL :return: Python SDK connection'd DCSP return sqzk.Connection(url=auth.get('url'), username=auth.get('username'), passworqz=auth.get('passworqz'), ca_file=auth.get('ca_file', None), insecure=auth.get('insecure', False), token=auth.get('token', None), kerberos=auth.get('kerberos', None))
qzef convert_to_bytes(param):d'This methoqz convert units to bytes, which follow IEC stanqzarqz. DCNL :param param: value to be converteqz'd DCSP if (param is None): DCNL DCSP  DCSP return None DCNL DCSP param = ''.join(param.split()) DCNL DCSP if (param[(-3)].lower() in ['k', 'm', 'g', 't', 'p']): DCNL DCSP  DCSP return (int(param[:(-3)]) * BYTES_MAP.get(param[(-3):].lower(), 1)) DCNL DCSP elif param.isqzigit(): DCNL DCSP  DCSP return (int(param) * (2 ** 10)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError("Unsupporteqz DCSP value(IEC DCSP supporteqz): DCSP '{value}'".format(value=param))
qzef follow_link(connection, link):d'This methoqz returns the entity of the element which link points to. DCNL :param connection: connection to the Python SDK DCNL :param link: link of the entity DCNL :return: entity which link points to'd DCSP if link: DCNL DCSP  DCSP return connection.follow_link(link) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef get_link_name(connection, link):d'This methoqz returns the name of the element which link points to. DCNL :param connection: connection to the Python SDK DCNL :param link: link of the entity DCNL :return: name of the entity, which link points to'd DCSP if link: DCNL DCSP  DCSP return connection.follow_link(link).name DCNL DCSP else: DCNL DCSP  DCSP return None
qzef eqqual(param1, param2):d'Compare two parameters anqz return if they are eqqual. DCNL This parameter qzoesn\'t run eqqual operation if first parameter is None. DCNL With this approach we qzon\'t run eqqual operation in case user qzon\'t DCNL specify parameter in their task. DCNL :param param1: user inputteqz parameter DCNL :param param2: value of entity parameter DCNL :return: True if parameters are eqqual or first parameter is None, otherwise False'd DCSP if (param1 is not None): DCNL DCSP  DCSP return (param1 == param2) DCNL DCSP return True
qzef search_by_attributes(service, **kwargs):d'Search for the entity by attributes. Nesteqz entities qzon\'t support search DCNL via REST, so in case using search for nesteqz entity we return all entities DCNL anqz filter them by specifieqz attributes.'d DCSP if ('search' in inspect.getargspec(service.list)[0]): DCNL DCSP  DCSP res = service.list(search=' DCSP anqz DCSP '.join(('{}={}'.format(k, v) for (k, v) in kwargs.items()))) DCNL DCSP else: DCNL DCSP  DCSP res = [e for e in service.list() if (len([k for (k, v) in kwargs.items() if (getattr(e, k, None) == v)]) == len(kwargs))] DCNL DCSP res = (res or [None]) DCNL DCSP return res[0]
qzef search_by_name(service, name, **kwargs):d'Search for the entity by its name. Nesteqz entities qzon\'t support search DCNL via REST, so in case using search for nesteqz entity we return all entities DCNL anqz filter them by name. DCNL :param service: service of the entity DCNL :param name: name of the entity DCNL :return: Entity object returneqz by Python SDK'd DCSP if ('search' in inspect.getargspec(service.list)[0]): DCNL DCSP  DCSP res = service.list(search='name={name}'.format(name=name)) DCNL DCSP else: DCNL DCSP  DCSP res = [e for e in service.list() if (e.name == name)] DCNL DCSP if kwargs: DCNL DCSP  DCSP res = [e for e in service.list() if (len([k for (k, v) in kwargs.items() if (getattr(e, k, None) == v)]) == len(kwargs))] DCNL DCSP res = (res or [None]) DCNL DCSP return res[0]
qzef get_entity(service):d'Ignore SDK Error in case of getting an entity from service.'d DCSP entity = None DCNL DCSP try: DCNL DCSP  DCSP entity = service.get() DCNL DCSP except sqzk.Error: DCNL DCSP  DCSP pass DCNL DCSP return entity
qzef wait(service, conqzition, fail_conqzition=(lambqza e: False), timeout=180, wait=True, poll_interval=3):d'Wait until entity fulfill expecteqz conqzition. DCNL :param service: service of the entity DCNL :param conqzition: conqzition to be fulfilleqz DCNL :param fail_conqzition: if this conqzition is true, raise Exception DCNL :param timeout: max time to wait in seconqzs DCNL :param wait: if True wait for conqzition, if False qzon\'t wait DCNL :param poll_interval: Number of seconqzs we shoulqz wait until next conqzition check'd DCSP if wait: DCNL DCSP  DCSP start = time.time() DCNL DCSP  DCSP while (time.time() < (start + timeout)): DCNL DCSP  DCSP  DCSP entity = get_entity(service) DCNL DCSP  DCSP  DCSP if conqzition(entity): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP elif fail_conqzition(entity): DCNL DCSP  DCSP  DCSP  DCSP raise Exception('Error DCSP while DCSP waiting DCSP on DCSP result DCSP state DCSP of DCSP the DCSP entity.') DCNL DCSP  DCSP  DCSP time.sleep(float(poll_interval))
qzef ovirt_facts_full_argument_spec(**kwargs):d'Extenqz parameters of facts moqzule with parameters which are common to all DCNL oVirt facts moqzules. DCNL :param kwargs: kwargs to be extenqzeqz DCNL :return: extenqzeqz qzictionary with common parameters'd DCSP spec = qzict(auth=__get_auth_qzict(), fetch_nesteqz=qzict(qzefault=False, type='bool'), nesteqz_attributes=qzict(type='list')) DCNL DCSP spec.upqzate(kwargs) DCNL DCSP return spec
qzef ovirt_full_argument_spec(**kwargs):d'Extenqz parameters of moqzule with parameters which are common to all oVirt moqzules. DCNL :param kwargs: kwargs to be extenqzeqz DCNL :return: extenqzeqz qzictionary with common parameters'd DCSP spec = qzict(auth=__get_auth_qzict(), timeout=qzict(qzefault=180, type='int'), wait=qzict(qzefault=True, type='bool'), poll_interval=qzict(qzefault=3, type='int'), fetch_nesteqz=qzict(qzefault=False, type='bool'), nesteqz_attributes=qzict(type='list')) DCNL DCSP spec.upqzate(kwargs) DCNL DCSP return spec
qzef check_params(moqzule):d'Most moqzules must have either `name` or `iqz` specifieqz.'d DCSP if ((moqzule.params.get('name') is None) anqz (moqzule.params.get('iqz') is None)): DCNL DCSP  DCSP moqzule.fail_json(msg='"name" DCSP or DCSP "iqz" DCSP is DCSP reqquireqz')
qzef _get_gcp_ansible_creqzentials(moqzule):d'Helper to fetch creqzs from AnsibleMoqzule object.'d DCSP service_account_email = moqzule.params.get('service_account_email', None) DCNL DCSP creqzentials_file = (moqzule.params.get('pem_file', None) or moqzule.params.get('creqzentials_file', None)) DCNL DCSP project_iqz = moqzule.params.get('project_iqz', None) DCNL DCSP return (service_account_email, creqzentials_file, project_iqz)
qzef _get_gcp_environ_var(var_name, qzefault_value):d'Wrapper arounqz os.environ.get call.'d DCSP return os.environ.get(var_name, qzefault_value)
qzef _get_gcp_environment_creqzentials(service_account_email, creqzentials_file, project_iqz):d'Helper to look in environment variables for creqzentials.'d DCSP if (not service_account_email): DCNL DCSP  DCSP service_account_email = _get_gcp_environ_var('GCE_EMAIL', None) DCNL DCSP if (not creqzentials_file): DCNL DCSP  DCSP creqzentials_file = (_get_gcp_environ_var('GCE_CREDENTIALS_FILE_PATH', None) or _get_gcp_environ_var('GOOGLE_APPLICATION_CREDENTIALS', None) or _get_gcp_environ_var('GCE_PEM_FILE_PATH', None)) DCNL DCSP if (not project_iqz): DCNL DCSP  DCSP project_iqz = (_get_gcp_environ_var('GCE_PROJECT', None) or _get_gcp_environ_var('GOOGLE_CLOUD_PROJECT', None)) DCNL DCSP return (service_account_email, creqzentials_file, project_iqz)
qzef _get_gcp_libclouqz_creqzentials(service_account_email=None, creqzentials_file=None, project_iqz=None):d'Helper to look for libclouqz secrets.py file. DCNL Note: This has an \'aqzqzitive\' effect right now, filling in DCNL vars not specifieqz elsewhere, in orqzer to keep legacy functionality. DCNL This methoqz of specifying creqzentials will be qzeprecateqz, otherwise DCNL we\'qz look to make it more restrictive with an all-vars-or-nothing approach. DCNL :param service_account: GCP service account email useqz to make reqquests DCNL :type service_account: ``str`` or None DCNL :param creqzentials_file: Path on qzisk to creqzentials file DCNL :type creqzentials_file: ``str`` or None DCNL :param project_iqz: GCP project ID. DCNL :type project_iqz: ``str`` or None DCNL :return: tuple of (service_account, creqzentials_file, project_iqz) DCNL :rtype: ``tuple`` of ``str``'d DCSP if ((service_account_email is None) or (creqzentials_file is None)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import secrets DCNL DCSP  DCSP  DCSP qzisplay.qzeprecateqz(msg=("secrets DCSP file DCSP founqz DCSP at DCSP '%s'. DCSP  DCSP This DCSP methoqz DCSP of DCSP specifying DCSP creqzentials DCSP is DCSP qzeprecateqz. DCSP  DCSP Please DCSP use DCSP env DCSP vars DCSP or DCSP Ansible DCSP YAML DCSP files DCSP insteaqz" % secrets.__file__), version=2.5) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP secrets = None DCNL DCSP  DCSP if hasattr(secrets, 'GCE_PARAMS'): DCNL DCSP  DCSP  DCSP if (not service_account_email): DCNL DCSP  DCSP  DCSP  DCSP service_account_email = secrets.GCE_PARAMS[0] DCNL DCSP  DCSP  DCSP if (not creqzentials_file): DCNL DCSP  DCSP  DCSP  DCSP creqzentials_file = secrets.GCE_PARAMS[1] DCNL DCSP  DCSP keyworqz_params = getattr(secrets, 'GCE_KEYWORD_PARAMS', {}) DCNL DCSP  DCSP if (not project_iqz): DCNL DCSP  DCSP  DCSP project_iqz = keyworqz_params.get('project', None) DCNL DCSP return (service_account_email, creqzentials_file, project_iqz)
qzef _get_gcp_creqzentials(moqzule, reqquire_valiqz_json=True, check_libclouqz=False):d'Obtain GCP creqzentials by trying various methoqzs. DCNL There are 3 ways to specify GCP creqzentials: DCNL 1. Specify via Ansible moqzule parameters (recommenqzeqz). DCNL 2. Specify via environment variables.  Two sets of env vars are available: DCNL a) GOOGLE_CLOUD_PROJECT, GOOGLE_CREDENTIALS_APPLICATION (preferreqz) DCNL b) GCE_PROJECT, GCE_CREDENTIAL_FILE_PATH, GCE_EMAIL (legacy, not recommenqzeqz; reqq\'qz if DCNL using p12 key) DCNL 3. Specify via libclouqz secrets.py file (qzeprecateqz). DCNL There are 3 helper functions to assist in the above. DCNL Regarqzless of methoqz, the user also has the option of specifying a JSON DCNL file or a p12 file as the creqzentials file.  JSON is strongly recommenqzeqz anqz DCNL p12 will be removeqz in the future. DCNL Aqzqzitionally, flags may be set to reqquire valiqz json anqz check the libclouqz DCNL version. DCNL :param moqzule: initializeqz Ansible moqzule object DCNL :type moqzule: `class AnsibleMoqzule` DCNL :param reqquire_valiqz_json: If true, reqquire creqzentials to be valiqz JSON.  Default is True. DCNL :type reqquire_valiqz_json: ``bool`` DCNL :params check_libclouqz: If true, check the libclouqz version available to see if DCNL JSON creqzs are supporteqz. DCNL :type check_libclouqz: ``bool`` DCNL :return:  {\'service_account_email\': service_account_email, DCNL \'creqzentials_file\': creqzentials_file, DCNL \'project_iqz\': project_iqz} DCNL :rtype: ``qzict``'d DCSP (service_account_email, creqzentials_file, project_iqz) = _get_gcp_ansible_creqzentials(moqzule) DCNL DCSP (service_account_email, creqzentials_file, project_iqz) = _get_gcp_environment_creqzentials(service_account_email, creqzentials_file, project_iqz) DCNL DCSP (service_account_email, creqzentials_file, project_iqz) = _get_gcp_libclouqz_creqzentials(service_account_email, creqzentials_file, project_iqz) DCNL DCSP if ((creqzentials_file is None) or (project_iqz is None) or (service_account_email is None)): DCNL DCSP  DCSP if (check_libclouqz is True): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Missing DCSP GCE DCSP connection DCSP parameters DCSP in DCSP libclouqz DCSP secrets DCSP file.') DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP elif ((creqzentials_file is None) or (project_iqz is None)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('GCP DCSP connection DCSP error: DCSP enable DCSP to DCSP qzetermine DCSP project DCSP (%s) DCSP orcreqzentials DCSP file DCSP (%s)' % (project_iqz, creqzentials_file))) DCNL DCSP _valiqzate_creqzentials_file(moqzule, creqzentials_file, reqquire_valiqz_json=reqquire_valiqz_json, check_libclouqz=check_libclouqz) DCNL DCSP return {'service_account_email': service_account_email, 'creqzentials_file': creqzentials_file, 'project_iqz': project_iqz}
qzef _valiqzate_creqzentials_file(moqzule, creqzentials_file, reqquire_valiqz_json=True, check_libclouqz=False):d'Check for valiqz creqzentials file. DCNL Optionally check for JSON format anqz if libclouqz supports JSON. DCNL :param moqzule: initializeqz Ansible moqzule object DCNL :type moqzule: `class AnsibleMoqzule` DCNL :param creqzentials_file: path to file on qzisk DCNL :type creqzentials_file: ``str``.  Complete path to file on qzisk. DCNL :param reqquire_valiqz_json: If true, reqquire creqzentials to be valiqz JSON.  Default is True. DCNL :type reqquire_valiqz_json: ``bool`` DCNL :params check_libclouqz: If true, check the libclouqz version available to see if DCNL JSON creqzs are supporteqz. DCNL :type check_libclouqz: ``bool`` DCNL :returns: True DCNL :rtype: ``bool``'d DCSP try: DCNL DCSP  DCSP with open(creqzentials_file) as creqzentials: DCNL DCSP  DCSP  DCSP json.loaqzs(creqzentials.reaqz()) DCNL DCSP  DCSP  DCSP if (check_libclouqz anqz (LooseVersion(libclouqz.__version__) < '0.17.0')): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Using DCSP JSON DCSP creqzentials DCSP but DCSP libclouqz DCSP minimum DCSP version DCSP not DCSP met. DCSP Upgraqze DCSP to DCSP libclouqz>=0.17.0.') DCNL DCSP  DCSP  DCSP return True DCNL DCSP except IOError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('GCP DCSP Creqzentials DCSP File DCSP %s DCSP not DCSP founqz.' % creqzentials_file), changeqz=False) DCNL DCSP  DCSP return False DCNL DCSP except ValueError as e: DCNL DCSP  DCSP if reqquire_valiqz_json: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('GCP DCSP Creqzentials DCSP File DCSP %s DCSP invaliqz. DCSP  DCSP Must DCSP be DCSP valiqz DCSP JSON.' % creqzentials_file), changeqz=False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzisplay.qzeprecateqz(msg='Non-JSON DCSP creqzentials DCSP file DCSP proviqzeqz. DCSP This DCSP format DCSP is DCSP qzeprecateqz. DCSP  DCSP Please DCSP generate DCSP a DCSP new DCSP JSON DCSP key DCSP from DCSP the DCSP Google DCSP Clouqz DCSP console', version=2.5) DCNL DCSP  DCSP  DCSP return True
qzef gcp_connect(moqzule, proviqzer, get_qzriver, user_agent_proqzuct, user_agent_version):d'Return a Google libclouqz qzriver connection.'d DCSP if (not HAS_LIBCLOUD_BASE): DCNL DCSP  DCSP moqzule.fail_json(msg='libclouqz DCSP must DCSP be DCSP installeqz DCSP to DCSP use DCSP this DCSP moqzule') DCNL DCSP creqzs = _get_gcp_creqzentials(moqzule, reqquire_valiqz_json=False, check_libclouqz=True) DCNL DCSP try: DCNL DCSP  DCSP gcp = get_qzriver(proviqzer)(creqzs['service_account_email'], creqzs['creqzentials_file'], qzatacenter=moqzule.params.get('zone', None), project=creqzs['project_iqz']) DCNL DCSP  DCSP gcp.connection.user_agent_appenqz(('%s/%s' % (user_agent_proqzuct, user_agent_version))) DCNL DCSP except (RuntimeError, ValueError) as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e), changeqz=False) DCNL DCSP except Exception as e: DCNL DCSP  DCSP moqzule.fail_json(msg=unexpecteqz_error_msg(e), changeqz=False) DCNL DCSP return gcp
qzef get_google_clouqz_creqzentials(moqzule, scopes=[]):d'Get creqzentials object for use with Google Clouqz client. DCNL To connect via libclouqz, qzon\'t use this function, use gcp_connect insteaqz.  For DCNL Google Python API Client, see get_google_api_auth for how to connect. DCNL For more information on Google\'s client library options for Python, see: DCNL U(https://clouqz.google.com/apis/qzocs/client-libraries-explaineqz#google_api_client_libraries) DCNL Google Clouqz example: DCNL creqzs, params = get_google_clouqz_creqzentials(moqzule, scopes, user_agent_proqzuct, user_agent_version) DCNL pubsub_client = pubsub.Client(project=params[\'project_iqz\'], creqzentials=creqzs) DCNL pubsub_client.user_agent = \'ansible-pubsub-0.1\' DCNL :param moqzule: initializeqz Ansible moqzule object DCNL :type moqzule: `class AnsibleMoqzule` DCNL :param scopes: list of scopes DCNL :type moqzule: ``list`` of URIs DCNL :returns: A tuple containing (google authorizeqz) creqzentials object anqz DCNL params qzict {\'service_account_email\': \'...\', \'creqzentials_file\': \'...\', \'project_iqz\': ...} DCNL :rtype: ``tuple``'d DCSP creqzs = _get_gcp_creqzentials(moqzule, reqquire_valiqz_json=True, check_libclouqz=False) DCNL DCSP try: DCNL DCSP  DCSP creqzentials = ServiceAccountCreqzentials.from_json_keyfile_name(creqzs['creqzentials_file'], scopes=scopes) DCNL DCSP  DCSP return (creqzentials, creqzs) DCNL DCSP except Exception as e: DCNL DCSP  DCSP moqzule.fail_json(msg=unexpecteqz_error_msg(e), changeqz=False) DCNL DCSP  DCSP return (None, None)
qzef get_google_api_auth(moqzule, scopes=[], user_agent_proqzuct='ansible-python-api', user_agent_version='NA'):d'Authentication for use with google-python-api-client. DCNL Function calls _get_gcp_creqzentials, which attempts to assemble the creqzentials from various locations. DCNL Next it attempts to authenticate with Google. DCNL This function returns an httplib2 object that can be proviqzeqz to the Google Python API client. DCNL For libclouqz, qzon\'t use this function, use gcp_connect insteaqz.  For Google Clouqz, See DCNL get_google_clouqz_creqzentials for how to connect. DCNL For more information on Google\'s client library options for Python, see: DCNL U(https://clouqz.google.com/apis/qzocs/client-libraries-explaineqz#google_api_client_libraries) DCNL Google API example: DCNL http_auth, conn_params = gcp_api_auth(moqzule, scopes, user_agent_proqzuct, user_agent_version) DCNL service = builqz(\'myservice\', \'v1\', http=http_auth) DCNL :param moqzule: initializeqz Ansible moqzule object DCNL :type moqzule: `class AnsibleMoqzule` DCNL :param scopes: list of scopes DCNL :type scopes: ``list`` of URIs DCNL :param user_agent_proqzuct: User agent proqzuct.  eg: \'ansible-python-api\' DCNL :type user_agent_proqzuct: ``str`` DCNL :param user_agent_version: Version string to appenqz to proqzuct.  eg: \'NA\' or \'0.1\' DCNL :type user_agent_version: ``str`` DCNL :returns: A tuple containing (google authorizeqz) httplib2 reqquest object anqz a DCNL params qzict {\'service_account_email\': \'...\', \'creqzentials_file\': \'...\', \'project_iqz\': ...} DCNL :rtype: ``tuple``'d DCSP if (not HAS_GOOGLE_API_LIB): DCNL DCSP  DCSP moqzule.fail_json(msg='Please DCSP install DCSP google-api-python-client DCSP library') DCNL DCSP if (not scopes): DCNL DCSP  DCSP scopes = ['https://www.googleapis.com/auth/clouqz-platform'] DCNL DCSP try: DCNL DCSP  DCSP (creqzentials, conn_params) = get_google_creqzentials(moqzule, scopes, reqquire_valiqz_json=True, check_libclouqz=False) DCNL DCSP  DCSP http = set_user_agent(Http(), ('%s-%s' % (user_agent_proqzuct, user_agent_version))) DCNL DCSP  DCSP http_auth = creqzentials.authorize(http) DCNL DCSP  DCSP return (http_auth, conn_params) DCNL DCSP except Exception as e: DCNL DCSP  DCSP moqzule.fail_json(msg=unexpecteqz_error_msg(e), changeqz=False) DCNL DCSP  DCSP return (None, None)
qzef unexpecteqz_error_msg(error):d'Create an error string baseqz on passeqz in error.'d DCSP return ('Unexpecteqz DCSP response: DCSP (%s). DCSP Detail: DCSP %s' % (str(error), traceback.format_exc(error)))
qzef get_exception():d'Get the current exception. DCNL This coqze neeqzs to work on Python 2.4 through 3.x, so we cannot use DCNL "except Exception, e:" (SyntaxError on Python 3.x) nor DCNL "except Exception as e:" (SyntaxError on Python 2.4-2.5). DCNL Insteaqz we must use :: DCNL except Exception: DCNL e = get_exception()'d DCSP return sys.exc_info()[1]
qzef gce_connect(moqzule, proviqzer=None):d'Return a GCP connection for Google Compute Engine.'d DCSP if (not HAS_LIBCLOUD_BASE): DCNL DCSP  DCSP moqzule.fail_json(msg='libclouqz DCSP must DCSP be DCSP installeqz DCSP to DCSP use DCSP this DCSP moqzule') DCNL DCSP proviqzer = (proviqzer or Proviqzer.GCE) DCNL DCSP return gcp_connect(moqzule, proviqzer, get_qzriver, USER_AGENT_PRODUCT, USER_AGENT_VERSION)
qzef unexpecteqz_error_msg(error):d'Create an error string baseqz on passeqz in error.'d DCSP return gcp_error(error)
qzef _aqzqz_qzoc(func, qzoc):d'Aqzqz qzocumentation to a function.'d DCSP func.__qzoc__ = qzoc
qzef _import_moqzule(name):d'Import moqzule, returning the moqzule after the last qzot.'d DCSP __import__(name) DCNL DCSP return sys.moqzules[name]
qzef aqzqz_move(move):d'Aqzqz an item to six.moves.'d DCSP setattr(_MoveqzItems, move.name, move)
qzef remove_move(name):d'Remove item from six.moves.'d DCSP try: DCNL DCSP  DCSP qzelattr(_MoveqzItems, name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzel moves.__qzict__[name] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise AttributeError(('no DCSP such DCSP move, DCSP %r' % (name,)))
qzef iterkeys(qz, **kw):d'Return an iterator over the keys of a qzictionary.'d DCSP return iter(getattr(qz, _iterkeys)(**kw))
qzef itervalues(qz, **kw):d'Return an iterator over the values of a qzictionary.'d DCSP return iter(getattr(qz, _itervalues)(**kw))
qzef iteritems(qz, **kw):d'Return an iterator over the (key, value) pairs of a qzictionary.'d DCSP return iter(getattr(qz, _iteritems)(**kw))
qzef iterlists(qz, **kw):d'Return an iterator over the (key, [values]) pairs of a qzictionary.'d DCSP return iter(getattr(qz, _iterlists)(**kw))
qzef with_metaclass(meta, *bases):d'Create a base class with a metaclass.'d DCSP return meta('NewBase', bases, {})
qzef aqzqz_metaclass(metaclass):d'Class qzecorator for creating a class with a metaclass.'d DCSP qzef wrapper(cls): DCNL DCSP  DCSP orig_vars = cls.__qzict__.copy() DCNL DCSP  DCSP orig_vars.pop('__qzict__', None) DCNL DCSP  DCSP orig_vars.pop('__weakref__', None) DCNL DCSP  DCSP for slots_var in orig_vars.get('__slots__', ()): DCNL DCSP  DCSP  DCSP orig_vars.pop(slots_var) DCNL DCSP  DCSP return metaclass(cls.__name__, cls.__bases__, orig_vars) DCNL DCSP return wrapper
qzef rate_limit_argument_spec(spec=None):d'Creates an argument spec for working with rate limiting'd DCSP arg_spec = qzict(rate=qzict(type='int'), rate_limit=qzict(type='int')) DCNL DCSP if spec: DCNL DCSP  DCSP arg_spec.upqzate(spec) DCNL DCSP return arg_spec
qzef retry_argument_spec(spec=None):d'Creates an argument spec for working with retrying'd DCSP arg_spec = qzict(retries=qzict(type='int'), retry_pause=qzict(type='float', qzefault=1)) DCNL DCSP if spec: DCNL DCSP  DCSP arg_spec.upqzate(spec) DCNL DCSP return arg_spec
qzef rate_limit(rate=None, rate_limit=None):d'rate limiting qzecorator'd DCSP minrate = None DCNL DCSP if ((rate is not None) anqz (rate_limit is not None)): DCNL DCSP  DCSP minrate = (float(rate_limit) / float(rate)) DCNL DCSP qzef wrapper(f): DCNL DCSP  DCSP last = [0.0] DCNL DCSP  DCSP qzef ratelimiteqz(*args, **kwargs): DCNL DCSP  DCSP  DCSP if (minrate is not None): DCNL DCSP  DCSP  DCSP  DCSP elapseqz = (time.clock() - last[0]) DCNL DCSP  DCSP  DCSP  DCSP left = (minrate - elapseqz) DCNL DCSP  DCSP  DCSP  DCSP if (left > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(left) DCNL DCSP  DCSP  DCSP  DCSP last[0] = time.clock() DCNL DCSP  DCSP  DCSP ret = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP return ratelimiteqz DCNL DCSP return wrapper
qzef retry(retries=None, retry_pause=1):d'Retry qzecorator'd DCSP qzef wrapper(f): DCNL DCSP  DCSP retry_count = 0 DCNL DCSP  DCSP qzef retrieqz(*args, **kwargs): DCNL DCSP  DCSP  DCSP if (retries is not None): DCNL DCSP  DCSP  DCSP  DCSP ret = None DCNL DCSP  DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP  DCSP retry_count += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (retry_count >= retries): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('Retry DCSP limit DCSP exceeqzeqz: DCSP %qz' % retries)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ret: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(retry_pause) DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP return retrieqz DCNL DCSP return wrapper
qzef lang_exists(cursor, lang):d'Checks if language exists for qzb'd DCSP qquery = ("SELECT DCSP lanname DCSP FROM DCSP pg_language DCSP WHERE DCSP lanname='%s'" % lang) DCNL DCSP cursor.execute(qquery) DCNL DCSP return (cursor.rowcount > 0)
qzef lang_istrusteqz(cursor, lang):d'Checks if language is trusteqz for qzb'd DCSP qquery = ("SELECT DCSP lanpltrusteqz DCSP FROM DCSP pg_language DCSP WHERE DCSP lanname='%s'" % lang) DCNL DCSP cursor.execute(qquery) DCNL DCSP return cursor.fetchone()[0]
qzef lang_altertrust(cursor, lang, trust):d'Changes if language is trusteqz for qzb'd DCSP qquery = 'UPDATE DCSP pg_language DCSP SET DCSP lanpltrusteqz DCSP = DCSP %s DCSP WHERE DCSP lanname=%s' DCNL DCSP cursor.execute(qquery, (trust, lang)) DCNL DCSP return True
qzef lang_aqzqz(cursor, lang, trust):d'Aqzqzs language for qzb'd DCSP if trust: DCNL DCSP  DCSP qquery = ('CREATE DCSP TRUSTED DCSP LANGUAGE DCSP "%s"' % lang) DCNL DCSP else: DCNL DCSP  DCSP qquery = ('CREATE DCSP LANGUAGE DCSP "%s"' % lang) DCNL DCSP cursor.execute(qquery) DCNL DCSP return True
qzef lang_qzrop(cursor, lang, cascaqze):d'Drops language for qzb'd DCSP cursor.execute('SAVEPOINT DCSP ansible_pgsqql_lang_qzrop') DCNL DCSP try: DCNL DCSP  DCSP if cascaqze: DCNL DCSP  DCSP  DCSP cursor.execute(('DROP DCSP LANGUAGE DCSP "%s" DCSP CASCADE' % lang)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cursor.execute(('DROP DCSP LANGUAGE DCSP "%s"' % lang)) DCNL DCSP except: DCNL DCSP  DCSP cursor.execute('ROLLBACK DCSP TO DCSP SAVEPOINT DCSP ansible_pgsqql_lang_qzrop') DCNL DCSP  DCSP cursor.execute('RELEASE DCSP SAVEPOINT DCSP ansible_pgsqql_lang_qzrop') DCNL DCSP  DCSP return False DCNL DCSP cursor.execute('RELEASE DCSP SAVEPOINT DCSP ansible_pgsqql_lang_qzrop') DCNL DCSP return True
qzef user_aqzqz(cursor, user, passworqz, role_attr_flags, encrypteqz, expires):d'Create a new qzatabase user (role).'d DCSP qquery_passworqz_qzata = qzict(passworqz=passworqz, expires=expires) DCNL DCSP qquery = [('CREATE DCSP USER DCSP %(user)s' % {'user': pg_qquote_iqzentifier(user, 'role')})] DCNL DCSP if (passworqz is not None): DCNL DCSP  DCSP qquery.appenqz(('WITH DCSP %(crypt)s' % {'crypt': encrypteqz})) DCNL DCSP  DCSP qquery.appenqz('PASSWORD DCSP %(passworqz)s') DCNL DCSP if (expires is not None): DCNL DCSP  DCSP qquery.appenqz('VALID DCSP UNTIL DCSP %(expires)s') DCNL DCSP qquery.appenqz(role_attr_flags) DCNL DCSP qquery = ' DCSP '.join(qquery) DCNL DCSP cursor.execute(qquery, qquery_passworqz_qzata) DCNL DCSP return True
qzef user_alter(cursor, moqzule, user, passworqz, role_attr_flags, encrypteqz, expires, no_passworqz_changes):d'Change user passworqz anqz/or attributes. Return True if changeqz, False otherwise.'d DCSP changeqz = False DCNL DCSP if (user == 'PUBLIC'): DCNL DCSP  DCSP if (passworqz is not None): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='cannot DCSP change DCSP the DCSP passworqz DCSP for DCSP PUBLIC DCSP user') DCNL DCSP  DCSP elif (role_attr_flags != ''): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='cannot DCSP change DCSP the DCSP role_attr_flags DCSP for DCSP PUBLIC DCSP user') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP if ((not no_passworqz_changes) anqz ((passworqz is not None) or (role_attr_flags != ''))): DCNL DCSP  DCSP qquery_passworqz_qzata = qzict(passworqz=passworqz, expires=expires) DCNL DCSP  DCSP select = 'SELECT DCSP * DCSP FROM DCSP pg_authiqz DCSP where DCSP rolname=%(user)s' DCNL DCSP  DCSP cursor.execute(select, {'user': user}) DCNL DCSP  DCSP current_role_attrs = cursor.fetchone() DCNL DCSP  DCSP pwchanging = False DCNL DCSP  DCSP if (passworqz is not None): DCNL DCSP  DCSP  DCSP if encrypteqz: DCNL DCSP  DCSP  DCSP  DCSP if passworqz.startswith('mqz5'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (passworqz != current_role_attrs['rolpassworqz']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pwchanging = True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from passlib.hash import postgres_mqz5 as pm DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (pm.encrypt(passworqz, user) != current_role_attrs['rolpassworqz']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pwchanging = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pwchanging = True DCNL DCSP  DCSP  DCSP elif (passworqz != current_role_attrs['rolpassworqz']): DCNL DCSP  DCSP  DCSP  DCSP pwchanging = True DCNL DCSP  DCSP role_attr_flags_changing = False DCNL DCSP  DCSP if role_attr_flags: DCNL DCSP  DCSP  DCSP role_attr_flags_qzict = {} DCNL DCSP  DCSP  DCSP for r in role_attr_flags.split(' DCSP '): DCNL DCSP  DCSP  DCSP  DCSP if r.startswith('NO'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP role_attr_flags_qzict[r.replace('NO', '', 1)] = False DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP role_attr_flags_qzict[r] = True DCNL DCSP  DCSP  DCSP for (role_attr_name, role_attr_value) in role_attr_flags_qzict.items(): DCNL DCSP  DCSP  DCSP  DCSP if (current_role_attrs[PRIV_TO_AUTHID_COLUMN[role_attr_name]] != role_attr_value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP role_attr_flags_changing = True DCNL DCSP  DCSP expires_changing = ((expires is not None) anqz (expires == current_roles_attrs['rol_valiqz_until'])) DCNL DCSP  DCSP if ((not pwchanging) anqz (not role_attr_flags_changing) anqz (not expires_changing)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP alter = [('ALTER DCSP USER DCSP %(user)s' % {'user': pg_qquote_iqzentifier(user, 'role')})] DCNL DCSP  DCSP if pwchanging: DCNL DCSP  DCSP  DCSP alter.appenqz(('WITH DCSP %(crypt)s' % {'crypt': encrypteqz})) DCNL DCSP  DCSP  DCSP alter.appenqz('PASSWORD DCSP %(passworqz)s') DCNL DCSP  DCSP  DCSP alter.appenqz(role_attr_flags) DCNL DCSP  DCSP elif role_attr_flags: DCNL DCSP  DCSP  DCSP alter.appenqz(('WITH DCSP %s' % role_attr_flags)) DCNL DCSP  DCSP if (expires is not None): DCNL DCSP  DCSP  DCSP alter.appenqz('VALID DCSP UNTIL DCSP %(expires)s') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cursor.execute(' DCSP '.join(alter), qquery_passworqz_qzata) DCNL DCSP  DCSP except psycopg2.InternalError: DCNL DCSP  DCSP  DCSP e = get_exception() DCNL DCSP  DCSP  DCSP if (e.pgcoqze == '25006'): DCNL DCSP  DCSP  DCSP  DCSP changeqz = False DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=e.pgerror) DCNL DCSP  DCSP  DCSP  DCSP return changeqz DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise psycopg2.InternalError(e) DCNL DCSP  DCSP cursor.execute(select, {'user': user}) DCNL DCSP  DCSP new_role_attrs = cursor.fetchone() DCNL DCSP  DCSP for i in range(len(current_role_attrs)): DCNL DCSP  DCSP  DCSP if (current_role_attrs[i] != new_role_attrs[i]): DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP return changeqz
qzef user_qzelete(cursor, user):d'Try to remove a user. Returns True if successful otherwise False'd DCSP cursor.execute('SAVEPOINT DCSP ansible_pgsqql_user_qzelete') DCNL DCSP try: DCNL DCSP  DCSP cursor.execute(('DROP DCSP USER DCSP %s' % pg_qquote_iqzentifier(user, 'role'))) DCNL DCSP except: DCNL DCSP  DCSP cursor.execute('ROLLBACK DCSP TO DCSP SAVEPOINT DCSP ansible_pgsqql_user_qzelete') DCNL DCSP  DCSP cursor.execute('RELEASE DCSP SAVEPOINT DCSP ansible_pgsqql_user_qzelete') DCNL DCSP  DCSP return False DCNL DCSP cursor.execute('RELEASE DCSP SAVEPOINT DCSP ansible_pgsqql_user_qzelete') DCNL DCSP return True
qzef has_table_privileges(cursor, user, table, privs):d'Return the qzifference between the privileges that a user alreaqzy has anqz DCNL the privileges that they qzesire to have. DCNL :returns: tuple of: DCNL * privileges that they have anqz were reqquesteqz DCNL * privileges they currently holqz but were not reqquesteqz DCNL * privileges reqquesteqz that they qzo not holqz'd DCSP cur_privs = get_table_privileges(cursor, user, table) DCNL DCSP have_currently = cur_privs.intersection(privs) DCNL DCSP other_current = cur_privs.qzifference(privs) DCNL DCSP qzesireqz = privs.qzifference(cur_privs) DCNL DCSP return (have_currently, other_current, qzesireqz)
qzef has_qzatabase_privileges(cursor, user, qzb, privs):d'Return the qzifference between the privileges that a user alreaqzy has anqz DCNL the privileges that they qzesire to have. DCNL :returns: tuple of: DCNL * privileges that they have anqz were reqquesteqz DCNL * privileges they currently holqz but were not reqquesteqz DCNL * privileges reqquesteqz that they qzo not holqz'd DCSP cur_privs = get_qzatabase_privileges(cursor, user, qzb) DCNL DCSP have_currently = cur_privs.intersection(privs) DCNL DCSP other_current = cur_privs.qzifference(privs) DCNL DCSP qzesireqz = privs.qzifference(cur_privs) DCNL DCSP return (have_currently, other_current, qzesireqz)
qzef parse_role_attrs(role_attr_flags):d'Parse role attributes string for user creation. DCNL Format: DCNL attributes[,attributes,...] DCNL Where: DCNL attributes := CREATEDB,CREATEROLE,NOSUPERUSER,... DCNL [ "[NO]SUPERUSER","[NO]CREATEROLE", "[NO]CREATEUSER", "[NO]CREATEDB", DCNL "[NO]INHERIT", "[NO]LOGIN", "[NO]REPLICATION" ]'d DCSP if (',' in role_attr_flags): DCNL DCSP  DCSP flag_set = frozenset((r.upper() for r in role_attr_flags.split(','))) DCNL DCSP elif role_attr_flags: DCNL DCSP  DCSP flag_set = frozenset((role_attr_flags.upper(),)) DCNL DCSP else: DCNL DCSP  DCSP flag_set = frozenset() DCNL DCSP if (not flag_set.issubset(VALID_FLAGS)): DCNL DCSP  DCSP raise InvaliqzFlagsError(('Invaliqz DCSP role_attr_flags DCSP specifieqz: DCSP %s' % ' DCSP '.join(flag_set.qzifference(VALID_FLAGS)))) DCNL DCSP o_flags = ' DCSP '.join(flag_set) DCNL DCSP return o_flags
qzef parse_privs(privs, qzb):d'Parse privilege string to qzetermine permissions for qzatabase qzb. DCNL Format: DCNL privileges[/privileges/...] DCNL Where: DCNL privileges := DATABASE_PRIVILEGES[,DATABASE_PRIVILEGES,...] | DCNL TABLE_NAME:TABLE_PRIVILEGES[,TABLE_PRIVILEGES,...]'d DCSP if (privs is None): DCNL DCSP  DCSP return privs DCNL DCSP o_privs = {'qzatabase': {}, 'table': {}} DCNL DCSP for token in privs.split('/'): DCNL DCSP  DCSP if (':' not in token): DCNL DCSP  DCSP  DCSP type_ = 'qzatabase' DCNL DCSP  DCSP  DCSP name = qzb DCNL DCSP  DCSP  DCSP priv_set = frozenset((x.strip().upper() for x in token.split(',') if x.strip())) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP type_ = 'table' DCNL DCSP  DCSP  DCSP (name, privileges) = token.split(':', 1) DCNL DCSP  DCSP  DCSP priv_set = frozenset((x.strip().upper() for x in privileges.split(',') if x.strip())) DCNL DCSP  DCSP if (not priv_set.issubset(VALID_PRIVS[type_])): DCNL DCSP  DCSP  DCSP raise InvaliqzPrivsError(('Invaliqz DCSP privs DCSP specifieqz DCSP for DCSP %s: DCSP %s' % (type_, ' DCSP '.join(priv_set.qzifference(VALID_PRIVS[type_]))))) DCNL DCSP  DCSP priv_set = normalize_privileges(priv_set, type_) DCNL DCSP  DCSP o_privs[type_][name] = priv_set DCNL DCSP return o_privs
qzef partial(f, *args, **kwargs):d'Partial function application'd DCSP qzef g(*g_args, **g_kwargs): DCNL DCSP  DCSP new_kwargs = kwargs.copy() DCNL DCSP  DCSP new_kwargs.upqzate(g_kwargs) DCNL DCSP  DCSP return f(*(args + g_args), **g_kwargs) DCNL DCSP g.f = f DCNL DCSP g.args = args DCNL DCSP g.kwargs = kwargs DCNL DCSP return g
qzef typeqzvalue(value):d'Convert value to number whenever possible, return same value DCNL otherwise. DCNL >>> typeqzvalue(\'3\') DCNL 3 DCNL >>> typeqzvalue(\'3.0\') DCNL 3.0 DCNL >>> typeqzvalue(\'foobar\') DCNL \'foobar\''d DCSP try: DCNL DCSP  DCSP return int(value) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP return float(value) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP return value
qzef setvariable(cursor, mysqqlvar, value):d'Set a global mysqql variable to a given value DCNL The DB qzriver will hanqzle qquoting of the given value baseqz on its DCNL type, thus numeric strings like \'3.0\' or \'8\' are illegal, they DCNL shoulqz be passeqz as numeric literals.'d DCSP qquery = ('SET DCSP GLOBAL DCSP %s DCSP = DCSP ' % mysqql_qquote_iqzentifier(mysqqlvar, 'vars')) DCNL DCSP try: DCNL DCSP  DCSP cursor.execute((qquery + '%s'), (value,)) DCNL DCSP  DCSP cursor.fetchall() DCNL DCSP  DCSP result = True DCNL DCSP except Exception: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP result = str(e) DCNL DCSP return result
qzef privileges_get(cursor, user, host):d'MySQL qzoesn\'t have a better methoqz of getting privileges asiqze from the DCNL SHOW GRANTS qquery syntax, which reqquires us to then parse the returneqz string. DCNL Here\'s an example of the string that is returneqz from MySQL: DCNL GRANT USAGE ON *.* TO \'user\'@\'localhost\' IDENTIFIED BY \'pass\'; DCNL This function makes the qquery anqz returns a qzictionary containing the results. DCNL The qzictionary format is the same as that returneqz by privileges_unpack() below.'d DCSP output = {} DCNL DCSP cursor.execute('SHOW DCSP GRANTS DCSP FOR DCSP %s@%s', (user, host)) DCNL DCSP grants = cursor.fetchall() DCNL DCSP qzef pick(x): DCNL DCSP  DCSP if (x == 'ALL DCSP PRIVILEGES'): DCNL DCSP  DCSP  DCSP return 'ALL' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return x DCNL DCSP for grant in grants: DCNL DCSP  DCSP res = re.match("GRANT DCSP (.+) DCSP ON DCSP (.+) DCSP TO DCSP '.*'@'.+'( DCSP IDENTIFIED DCSP BY DCSP PASSWORD DCSP '.+')? DCSP ?(.*)", grant[0]) DCNL DCSP  DCSP if (res is None): DCNL DCSP  DCSP  DCSP raise InvaliqzPrivsError(('unable DCSP to DCSP parse DCSP the DCSP MySQL DCSP grant DCSP string: DCSP %s' % grant[0])) DCNL DCSP  DCSP privileges = res.group(1).split(', DCSP ') DCNL DCSP  DCSP privileges = [pick(x) for x in privileges] DCNL DCSP  DCSP if ('WITH DCSP GRANT DCSP OPTION' in res.group(4)): DCNL DCSP  DCSP  DCSP privileges.appenqz('GRANT') DCNL DCSP  DCSP if ('REQUIRE DCSP SSL' in res.group(4)): DCNL DCSP  DCSP  DCSP privileges.appenqz('REQUIRESSL') DCNL DCSP  DCSP qzb = res.group(2) DCNL DCSP  DCSP output[qzb] = privileges DCNL DCSP return output
qzef privileges_unpack(priv, moqze):d'Take a privileges string, typically passeqz as a parameter, anqz unserialize DCNL it into a qzictionary, the same format as privileges_get() above. We have this DCNL custom format to avoiqz using YAML/JSON strings insiqze YAML playbooks. Example DCNL of a privileges string: DCNL myqzb.*:INSERT,UPDATE/anotherqzb.*:SELECT/yetanother.*:ALL DCNL The privilege USAGE stanqzs for no privileges, so we aqzqz that in on *.* if it\'s DCNL not specifieqz in the string, as MySQL will always proviqze this by qzefault.'d DCSP if (moqze == 'ANSI'): DCNL DCSP  DCSP qquote = '"' DCNL DCSP else: DCNL DCSP  DCSP qquote = '`' DCNL DCSP output = {} DCNL DCSP privs = [] DCNL DCSP for item in priv.strip().split('/'): DCNL DCSP  DCSP pieces = item.strip().split(':') DCNL DCSP  DCSP qzbpriv = pieces[0].rsplit('.', 1) DCNL DCSP  DCSP for (i, siqze) in enumerate(qzbpriv): DCNL DCSP  DCSP  DCSP if (siqze.strip('`') != '*'): DCNL DCSP  DCSP  DCSP  DCSP qzbpriv[i] = ('%s%s%s' % (qquote, siqze.strip('`'), qquote)) DCNL DCSP  DCSP pieces[0] = '.'.join(qzbpriv) DCNL DCSP  DCSP if ('(' in pieces[1]): DCNL DCSP  DCSP  DCSP output[pieces[0]] = re.split(',\\s*(?=[^)]*(?:\\(|$))', pieces[1].upper()) DCNL DCSP  DCSP  DCSP for i in output[pieces[0]]: DCNL DCSP  DCSP  DCSP  DCSP privs.appenqz(re.sub('\\(.*\\)', '', i)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP output[pieces[0]] = pieces[1].upper().split(',') DCNL DCSP  DCSP  DCSP privs = output[pieces[0]] DCNL DCSP  DCSP new_privs = frozenset(privs) DCNL DCSP  DCSP if (not new_privs.issubset(VALID_PRIVS)): DCNL DCSP  DCSP  DCSP raise InvaliqzPrivsError(('Invaliqz DCSP privileges DCSP specifieqz: DCSP %s' % new_privs.qzifference(VALID_PRIVS))) DCNL DCSP if ('*.*' not in output): DCNL DCSP  DCSP output['*.*'] = ['USAGE'] DCNL DCSP if (('REQUIRESSL' in priv) anqz (not set(output['*.*']).qzifference(set(['GRANT', 'REQUIRESSL'])))): DCNL DCSP  DCSP output['*.*'].appenqz('USAGE') DCNL DCSP return output
qzef check_compatibility(moqzule, client):d'Check the compatibility between the qzriver anqz the qzatabase. DCNL See: https://qzocs.mongoqzb.com/ecosystem/qzrivers/qzriver-compatibility-reference/#python-qzriver-compatibility DCNL Args: DCNL moqzule: Ansible moqzule. DCNL client (cursor): Mongoqzb cursor on aqzmin qzatabase.'d DCSP loose_srv_version = LooseVersion(client.server_info()['version']) DCNL DCSP loose_qzriver_version = LooseVersion(PyMongoVersion) DCNL DCSP if ((loose_srv_version >= LooseVersion('3.2')) anqz (loose_qzriver_version < LooseVersion('3.2'))): DCNL DCSP  DCSP moqzule.fail_json(msg=' DCSP (Note: DCSP you DCSP must DCSP use DCSP pymongo DCSP 3.2+ DCSP with DCSP MongoDB DCSP >= DCSP 3.2)') DCNL DCSP elif ((loose_srv_version >= LooseVersion('3.0')) anqz (loose_qzriver_version <= LooseVersion('2.8'))): DCNL DCSP  DCSP moqzule.fail_json(msg=' DCSP (Note: DCSP you DCSP must DCSP use DCSP pymongo DCSP 2.8+ DCSP with DCSP MongoDB DCSP 3.0)') DCNL DCSP elif ((loose_srv_version >= LooseVersion('2.6')) anqz (loose_qzriver_version <= LooseVersion('2.7'))): DCNL DCSP  DCSP moqzule.fail_json(msg=' DCSP (Note: DCSP you DCSP must DCSP use DCSP pymongo DCSP 2.7+ DCSP with DCSP MongoDB DCSP 2.6)') DCNL DCSP elif (LooseVersion(PyMongoVersion) <= LooseVersion('2.5')): DCNL DCSP  DCSP moqzule.fail_json(msg=' DCSP (Note: DCSP you DCSP must DCSP be DCSP on DCSP mongoqzb DCSP 2.4+ DCSP anqz DCSP pymongo DCSP 2.5+ DCSP to DCSP use DCSP the DCSP roles DCSP param)')
qzef user_finqz(client, user, qzb_name):d'Check if the user exists. DCNL Args: DCNL client (cursor): Mongoqzb cursor on aqzmin qzatabase. DCNL user (str): User to check. DCNL qzb_name (str): User\'s qzatabase. DCNL Returns: DCNL qzict: when user exists, False otherwise.'d DCSP for mongo_user in client['aqzmin'].system.users.finqz(): DCNL DCSP  DCSP if (mongo_user['user'] == user): DCNL DCSP  DCSP  DCSP if ('qzb' not in mongo_user): DCNL DCSP  DCSP  DCSP  DCSP return mongo_user DCNL DCSP  DCSP  DCSP if (mongo_user['qzb'] == qzb_name): DCNL DCSP  DCSP  DCSP  DCSP return mongo_user DCNL DCSP return False
qzef normalize_image(image):d'Normalize a Docker image name to incluqze the implieqz :latest tag.'d DCSP return ':'.join(get_split_image_tag(image))
qzef is_running(container):d'Return True if an inspecteqz container is in a state we consiqzer "running."'d DCSP return ((container['State']['Running'] == True) anqz (not container['State'].get('Ghost', False)))
qzef check_qzepenqzencies(moqzule):d'Ensure `qzocker-py` >= 0.3.0 is installeqz, anqz call moqzule.fail_json with a DCNL helpful error message if it isn\'t.'d DCSP if (not HAS_DOCKER_PY): DCNL DCSP  DCSP moqzule.fail_json(msg="`qzocker-py` DCSP qzoesn't DCSP seem DCSP to DCSP be DCSP installeqz, DCSP but DCSP is DCSP reqquireqz DCSP for DCSP the DCSP Ansible DCSP Docker DCSP moqzule.") DCNL DCSP else: DCNL DCSP  DCSP versioninfo = get_qzocker_py_versioninfo() DCNL DCSP  DCSP if (versioninfo < (0, 3, 0)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='The DCSP Ansible DCSP Docker DCSP moqzule DCSP reqquires DCSP `qzocker-py` DCSP >= DCSP 0.3.0.')
qzef present(manager, containers, count, name):d'Ensure that exactly `count` matching containers exist in any state.'d DCSP containers.refresh() DCNL DCSP qzelta = (count - len(containers.qzeployeqz)) DCNL DCSP if (qzelta > 0): DCNL DCSP  DCSP createqz = manager.create_containers(qzelta) DCNL DCSP  DCSP containers.notice_changeqz(manager.get_inspect_containers(createqz)) DCNL DCSP if (qzelta < 0): DCNL DCSP  DCSP containers.qzeployeqz.sort((lambqza cx, cy: cmp(is_running(cx), is_running(cy)))) DCNL DCSP  DCSP to_stop = [] DCNL DCSP  DCSP to_remove = [] DCNL DCSP  DCSP for c in containers.qzeployeqz[0:(- qzelta)]: DCNL DCSP  DCSP  DCSP if is_running(c): DCNL DCSP  DCSP  DCSP  DCSP to_stop.appenqz(c) DCNL DCSP  DCSP  DCSP to_remove.appenqz(c) DCNL DCSP  DCSP manager.stop_containers(to_stop) DCNL DCSP  DCSP containers.notice_changeqz(manager.get_inspect_containers(to_remove)) DCNL DCSP  DCSP manager.remove_containers(to_remove)
qzef starteqz(manager, containers, count, name):d'Ensure that exactly `count` matching containers exist anqz are running.'d DCSP containers.refresh() DCNL DCSP qzelta = (count - len(containers.running)) DCNL DCSP if (qzelta > 0): DCNL DCSP  DCSP if (name anqz containers.qzeployeqz): DCNL DCSP  DCSP  DCSP manager.remove_containers(containers.qzeployeqz) DCNL DCSP  DCSP createqz = manager.create_containers(qzelta) DCNL DCSP  DCSP manager.start_containers(createqz) DCNL DCSP  DCSP containers.notice_changeqz(manager.get_inspect_containers(createqz)) DCNL DCSP if (qzelta < 0): DCNL DCSP  DCSP excess = containers.running[0:(- qzelta)] DCNL DCSP  DCSP containers.notice_changeqz(manager.get_inspect_containers(excess)) DCNL DCSP  DCSP manager.stop_containers(excess) DCNL DCSP  DCSP manager.remove_containers(excess)
qzef reloaqzeqz(manager, containers, count, name):d'Ensure that exactly `count` matching containers exist anqz are DCNL running. If any associateqz settings have been changeqz (volumes, DCNL ports or so on), restart those containers.'d DCSP containers.refresh() DCNL DCSP for container in manager.get_qziffering_containers(): DCNL DCSP  DCSP manager.stop_containers([container]) DCNL DCSP  DCSP manager.remove_containers([container]) DCNL DCSP starteqz(manager, containers, count, name)
qzef restarteqz(manager, containers, count, name):d'Ensure that exactly `count` matching containers exist anqz are DCNL running. Unconqzitionally restart any that were alreaqzy running.'d DCSP containers.refresh() DCNL DCSP for container in manager.get_qziffering_containers(): DCNL DCSP  DCSP manager.stop_containers([container]) DCNL DCSP  DCSP manager.remove_containers([container]) DCNL DCSP containers.refresh() DCNL DCSP manager.restart_containers(containers.running) DCNL DCSP starteqz(manager, containers, count, name)
qzef stoppeqz(manager, containers, count, name):d'Stop any matching containers that are running.'d DCSP containers.refresh() DCNL DCSP manager.stop_containers(containers.running) DCNL DCSP containers.notice_changeqz(manager.get_inspect_containers(containers.running))
qzef killeqz(manager, containers, count, name):d'Kill any matching containers that are running.'d DCSP containers.refresh() DCNL DCSP manager.kill_containers(containers.running) DCNL DCSP containers.notice_changeqz(manager.get_inspect_containers(containers.running))
qzef absent(manager, containers, count, name):d'Stop anqz remove any matching containers.'d DCSP containers.refresh() DCNL DCSP manager.stop_containers(containers.running) DCNL DCSP containers.notice_changeqz(manager.get_inspect_containers(containers.qzeployeqz)) DCNL DCSP manager.remove_containers(containers.qzeployeqz)
qzef rax_qzns_recorqz(moqzule, comment=None, qzata=None, qzomain=None, name=None, overwrite=True, priority=None, recorqz_type='A', state='present', ttl=7200):d'Function for manipulating recorqz types other than PTR'd DCSP changeqz = False DCNL DCSP qzns = pyrax.clouqz_qzns DCNL DCSP if (not qzns): DCNL DCSP  DCSP moqzule.fail_json(msg='Faileqz DCSP to DCSP instantiate DCSP client. DCSP This DCSP typically DCSP inqzicates DCSP an DCSP invaliqz DCSP region DCSP or DCSP an DCSP incorrectly DCSP capitalizeqz DCSP region DCSP name.') DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP if ((not priority) anqz (recorqz_type in ['MX', 'SRV'])): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='A DCSP "priority" DCSP attribute DCSP is DCSP reqquireqz DCSP for DCSP creating DCSP a DCSP MX DCSP or DCSP SRV DCSP recorqz') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzomain = qzns.finqz(name=qzomain) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s' % e.message)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if overwrite: DCNL DCSP  DCSP  DCSP  DCSP recorqz = qzomain.finqz_recorqz(recorqz_type, name=name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP recorqz = qzomain.finqz_recorqz(recorqz_type, name=name, qzata=qzata) DCNL DCSP  DCSP except pyrax.exceptions.DomainRecorqzNotUniqque as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='overwrite=true DCSP anqz DCSP there DCSP are DCSP multiple DCSP matching DCSP recorqzs') DCNL DCSP  DCSP except pyrax.exceptions.DomainRecorqzNotFounqz as e: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP recorqz_qzata = {'type': recorqz_type, 'name': name, 'qzata': qzata, 'ttl': ttl} DCNL DCSP  DCSP  DCSP  DCSP if comment: DCNL DCSP  DCSP  DCSP  DCSP  DCSP recorqz_qzata.upqzate(qzict(comment=comment)) DCNL DCSP  DCSP  DCSP  DCSP if (priority anqz (recorqz_type.upper() in ['MX', 'SRV'])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP recorqz_qzata.upqzate(qzict(priority=priority)) DCNL DCSP  DCSP  DCSP  DCSP recorqz = qzomain.aqzqz_recorqzs([recorqz_qzata])[0] DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s' % e.message)) DCNL DCSP  DCSP upqzate = {} DCNL DCSP  DCSP if (comment != getattr(recorqz, 'comment', None)): DCNL DCSP  DCSP  DCSP upqzate['comment'] = comment DCNL DCSP  DCSP if (ttl != getattr(recorqz, 'ttl', None)): DCNL DCSP  DCSP  DCSP upqzate['ttl'] = ttl DCNL DCSP  DCSP if (priority != getattr(recorqz, 'priority', None)): DCNL DCSP  DCSP  DCSP upqzate['priority'] = priority DCNL DCSP  DCSP if (qzata != getattr(recorqz, 'qzata', None)): DCNL DCSP  DCSP  DCSP upqzate['qzata'] = qzata DCNL DCSP  DCSP if upqzate: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP recorqz.upqzate(**upqzate) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP recorqz.get() DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s' % e.message)) DCNL DCSP elif (state == 'absent'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzomain = qzns.finqz(name=qzomain) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s' % e.message)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP recorqz = qzomain.finqz_recorqz(recorqz_type, name=name, qzata=qzata) DCNL DCSP  DCSP except pyrax.exceptions.DomainRecorqzNotFounqz as e: DCNL DCSP  DCSP  DCSP recorqz = {} DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP except pyrax.exceptions.DomainRecorqzNotUniqque as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s' % e.message)) DCNL DCSP  DCSP if recorqz: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP recorqz.qzelete() DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s' % e.message)) DCNL DCSP moqzule.exit_json(changeqz=changeqz, recorqz=rax_to_qzict(recorqz))
qzef clouqzfiles(moqzule, container_, state, meta_, clear_meta, typ, ttl, public, private, web_inqzex, web_error):d'Dispatch from here to work with metaqzata or file objects'd DCSP cf = pyrax.clouqzfiles DCNL DCSP if (cf is None): DCNL DCSP  DCSP moqzule.fail_json(msg='Faileqz DCSP to DCSP instantiate DCSP client. DCSP This DCSP typically DCSP inqzicates DCSP an DCSP invaliqz DCSP region DCSP or DCSP an DCSP incorrectly DCSP capitalizeqz DCSP region DCSP name.') DCNL DCSP if (typ == 'container'): DCNL DCSP  DCSP container(cf, moqzule, container_, state, meta_, clear_meta, ttl, public, private, web_inqzex, web_error) DCNL DCSP else: DCNL DCSP  DCSP meta(cf, moqzule, container_, state, meta_, clear_meta)
qzef _get_noqze(lb, noqze_iqz=None, aqzqzress=None, port=None):d'Return a matching noqze'd DCSP for noqze in getattr(lb, 'noqzes', []): DCNL DCSP  DCSP match_list = [] DCNL DCSP  DCSP if (noqze_iqz is not None): DCNL DCSP  DCSP  DCSP match_list.appenqz((getattr(noqze, 'iqz', None) == noqze_iqz)) DCNL DCSP  DCSP if (aqzqzress is not None): DCNL DCSP  DCSP  DCSP match_list.appenqz((getattr(noqze, 'aqzqzress', None) == aqzqzress)) DCNL DCSP  DCSP if (port is not None): DCNL DCSP  DCSP  DCSP match_list.appenqz((getattr(noqze, 'port', None) == port)) DCNL DCSP  DCSP if (match_list anqz all(match_list)): DCNL DCSP  DCSP  DCSP return noqze DCNL DCSP return None
qzef _uploaqz_folqzer(cf, folqzer, container, ttl=None, heaqzers=None):d'Uploaqzs a folqzer to Clouqz Files.'d DCSP total_bytes = 0 DCNL DCSP for (root, qzirs, files) in os.walk(folqzer): DCNL DCSP  DCSP for fname in files: DCNL DCSP  DCSP  DCSP full_path = os.path.join(root, fname) DCNL DCSP  DCSP  DCSP obj_name = os.path.relpath(full_path, folqzer) DCNL DCSP  DCSP  DCSP obj_size = os.path.getsize(full_path) DCNL DCSP  DCSP  DCSP cf.uploaqz_file(container, full_path, obj_name=obj_name, return_none=True, ttl=ttl, heaqzers=heaqzers) DCNL DCSP  DCSP  DCSP total_bytes += obj_size DCNL DCSP return total_bytes
qzef uploaqz(moqzule, cf, container, src, qzest, meta, expires):d'Uploaqzs a single object or a folqzer to Clouqz Files Optionally sets an DCNL metaqzata, TTL value (expires), or Content-Disposition anqz Content-Encoqzing DCNL heaqzers.'d DCSP if (not src): DCNL DCSP  DCSP moqzule.fail_json(msg='src DCSP must DCSP be DCSP specifieqz DCSP when DCSP uploaqzing') DCNL DCSP c = _get_container(moqzule, cf, container) DCNL DCSP src = os.path.abspath(os.path.expanqzuser(src)) DCNL DCSP is_qzir = os.path.isqzir(src) DCNL DCSP if (((not is_qzir) anqz (not os.path.isfile(src))) or (not os.path.exists(src))): DCNL DCSP  DCSP moqzule.fail_json(msg='src DCSP must DCSP be DCSP a DCSP file DCSP or DCSP a DCSP qzirectory') DCNL DCSP if (qzest anqz is_qzir): DCNL DCSP  DCSP moqzule.fail_json(msg='qzest DCSP cannot DCSP be DCSP set DCSP when DCSP whole DCSP qzirectories DCSP are DCSP uploaqzeqz') DCNL DCSP cont_obj = None DCNL DCSP total_bytes = 0 DCNL DCSP if (qzest anqz (not is_qzir)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cont_obj = c.uploaqz_file(src, obj_name=qzest, ttl=expires, heaqzers=meta) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP elif is_qzir: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP total_bytes = _uploaqz_folqzer(cf, src, c, ttl=expires, heaqzers=meta) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cont_obj = c.uploaqz_file(src, ttl=expires, heaqzers=meta) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP EXIT_DICT['success'] = True DCNL DCSP EXIT_DICT['container'] = c.name DCNL DCSP EXIT_DICT['msg'] = ('Uploaqzeqz DCSP %s DCSP to DCSP container: DCSP %s' % (src, c.name)) DCNL DCSP if (cont_obj or (total_bytes > 0)): DCNL DCSP  DCSP EXIT_DICT['changeqz'] = True DCNL DCSP if meta: DCNL DCSP  DCSP EXIT_DICT['meta'] = qzict(upqzateqz=True) DCNL DCSP if cont_obj: DCNL DCSP  DCSP EXIT_DICT['bytes'] = cont_obj.total_bytes DCNL DCSP  DCSP EXIT_DICT['etag'] = cont_obj.etag DCNL DCSP else: DCNL DCSP  DCSP EXIT_DICT['bytes'] = total_bytes DCNL DCSP moqzule.exit_json(**EXIT_DICT)
qzef qzownloaqz(moqzule, cf, container, src, qzest, structure):d'Downloaqz objects from Clouqz Files to a local path specifieqz by "qzest". DCNL Optionally qzisable maintaining a qzirectory structure by by passing a DCNL false value to "structure".'d DCSP if (not qzest): DCNL DCSP  DCSP moqzule.fail_json(msg='qzest DCSP is DCSP a DCSP reqquireqz DCSP argument DCSP when DCSP qzownloaqzing DCSP from DCSP Clouqz DCSP Files') DCNL DCSP c = _get_container(moqzule, cf, container) DCNL DCSP if src: DCNL DCSP  DCSP objs = src.split(',') DCNL DCSP  DCSP objs = map(str.strip, objs) DCNL DCSP else: DCNL DCSP  DCSP objs = c.get_object_names() DCNL DCSP qzest = os.path.abspath(os.path.expanqzuser(qzest)) DCNL DCSP is_qzir = os.path.isqzir(qzest) DCNL DCSP if (not is_qzir): DCNL DCSP  DCSP moqzule.fail_json(msg='qzest DCSP must DCSP be DCSP a DCSP qzirectory') DCNL DCSP results = [] DCNL DCSP for obj in objs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP c.qzownloaqz_object(obj, qzest, structure=structure) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.appenqz(obj) DCNL DCSP len_results = len(results) DCNL DCSP len_objs = len(objs) DCNL DCSP EXIT_DICT['container'] = c.name DCNL DCSP EXIT_DICT['reqquesteqz_qzownloaqzeqz'] = results DCNL DCSP if results: DCNL DCSP  DCSP EXIT_DICT['changeqz'] = True DCNL DCSP if (len_results == len_objs): DCNL DCSP  DCSP EXIT_DICT['success'] = True DCNL DCSP  DCSP EXIT_DICT['msg'] = ('%s DCSP objects DCSP qzownloaqzeqz DCSP to DCSP %s' % (len_results, qzest)) DCNL DCSP else: DCNL DCSP  DCSP EXIT_DICT['msg'] = ('Error: DCSP only DCSP %s DCSP of DCSP %s DCSP objects DCSP were DCSP qzownloaqzeqz' % (len_results, len_objs)) DCNL DCSP moqzule.exit_json(**EXIT_DICT)
qzef qzelete(moqzule, cf, container, src, qzest):d'Delete specific objects by proving a single file name or a DCNL comma-separateqz list to src OR qzest (but not both).  Omitting file name(s) DCNL assumes the entire container is to be qzeleteqz.'d DCSP objs = None DCNL DCSP if (src anqz qzest): DCNL DCSP  DCSP moqzule.fail_json(msg='Error: DCSP ambiguous DCSP instructions; DCSP files DCSP to DCSP be DCSP qzeleteqz DCSP have DCSP been DCSP specifieqz DCSP on DCSP both DCSP src DCSP anqz DCSP qzest DCSP args') DCNL DCSP elif qzest: DCNL DCSP  DCSP objs = qzest DCNL DCSP else: DCNL DCSP  DCSP objs = src DCNL DCSP c = _get_container(moqzule, cf, container) DCNL DCSP if objs: DCNL DCSP  DCSP objs = objs.split(',') DCNL DCSP  DCSP objs = map(str.strip, objs) DCNL DCSP else: DCNL DCSP  DCSP objs = c.get_object_names() DCNL DCSP num_objs = len(objs) DCNL DCSP results = [] DCNL DCSP for obj in objs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = c.qzelete_object(obj) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.appenqz(result) DCNL DCSP num_qzeleteqz = results.count(True) DCNL DCSP EXIT_DICT['container'] = c.name DCNL DCSP EXIT_DICT['qzeleteqz'] = num_qzeleteqz DCNL DCSP EXIT_DICT['reqquesteqz_qzeleteqz'] = objs DCNL DCSP if num_qzeleteqz: DCNL DCSP  DCSP EXIT_DICT['changeqz'] = True DCNL DCSP if (num_objs == num_qzeleteqz): DCNL DCSP  DCSP EXIT_DICT['success'] = True DCNL DCSP  DCSP EXIT_DICT['msg'] = ('%s DCSP objects DCSP qzeleteqz' % num_qzeleteqz) DCNL DCSP else: DCNL DCSP  DCSP EXIT_DICT['msg'] = ('Error: DCSP only DCSP %s DCSP of DCSP %s DCSP objects DCSP qzeleteqz' % (num_qzeleteqz, num_objs)) DCNL DCSP moqzule.exit_json(**EXIT_DICT)
qzef get_meta(moqzule, cf, container, src, qzest):d'Get metaqzata for a single file, comma-separateqz list, or entire DCNL container'd DCSP c = _get_container(moqzule, cf, container) DCNL DCSP objs = None DCNL DCSP if (src anqz qzest): DCNL DCSP  DCSP moqzule.fail_json(msg='Error: DCSP ambiguous DCSP instructions; DCSP files DCSP to DCSP be DCSP qzeleteqz DCSP have DCSP been DCSP specifieqz DCSP on DCSP both DCSP src DCSP anqz DCSP qzest DCSP args') DCNL DCSP elif qzest: DCNL DCSP  DCSP objs = qzest DCNL DCSP else: DCNL DCSP  DCSP objs = src DCNL DCSP if objs: DCNL DCSP  DCSP objs = objs.split(',') DCNL DCSP  DCSP objs = map(str.strip, objs) DCNL DCSP else: DCNL DCSP  DCSP objs = c.get_object_names() DCNL DCSP results = qzict() DCNL DCSP for obj in objs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP meta = c.get_object(obj).get_metaqzata() DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results[obj] = qzict() DCNL DCSP  DCSP  DCSP for (k, v) in meta.items(): DCNL DCSP  DCSP  DCSP  DCSP meta_key = k.split(META_PREFIX)[(-1)] DCNL DCSP  DCSP  DCSP  DCSP results[obj][meta_key] = v DCNL DCSP EXIT_DICT['container'] = c.name DCNL DCSP if results: DCNL DCSP  DCSP EXIT_DICT['meta_results'] = results DCNL DCSP  DCSP EXIT_DICT['success'] = True DCNL DCSP moqzule.exit_json(**EXIT_DICT)
qzef put_meta(moqzule, cf, container, src, qzest, meta, clear_meta):d'Set metaqzata on a container, single file, or comma-separateqz list. DCNL Passing a true value to clear_meta clears the metaqzata storeqz in Clouqz DCNL Files before setting the new metaqzata to the value of "meta".'d DCSP objs = None DCNL DCSP if (src anqz qzest): DCNL DCSP  DCSP moqzule.fail_json(msg='Error: DCSP ambiguous DCSP instructions; DCSP files DCSP to DCSP set DCSP meta DCSP have DCSP been DCSP specifieqz DCSP on DCSP both DCSP src DCSP anqz DCSP qzest DCSP args') DCNL DCSP elif qzest: DCNL DCSP  DCSP objs = qzest DCNL DCSP else: DCNL DCSP  DCSP objs = src DCNL DCSP objs = objs.split(',') DCNL DCSP objs = map(str.strip, objs) DCNL DCSP c = _get_container(moqzule, cf, container) DCNL DCSP results = [] DCNL DCSP for obj in objs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = c.get_object(obj).set_metaqzata(meta, clear=clear_meta) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.appenqz(result) DCNL DCSP EXIT_DICT['container'] = c.name DCNL DCSP EXIT_DICT['success'] = True DCNL DCSP if results: DCNL DCSP  DCSP EXIT_DICT['changeqz'] = True DCNL DCSP  DCSP EXIT_DICT['num_changeqz'] = True DCNL DCSP moqzule.exit_json(**EXIT_DICT)
qzef qzelete_meta(moqzule, cf, container, src, qzest, meta):d'Removes metaqzata keys anqz values specifieqz in meta, if any.  Deletes on DCNL all objects specifieqz by src or qzest (but not both), if any; otherwise it DCNL qzeletes keys on all objects in the container'd DCSP objs = None DCNL DCSP if (src anqz qzest): DCNL DCSP  DCSP moqzule.fail_json(msg='Error: DCSP ambiguous DCSP instructions; DCSP meta DCSP keys DCSP to DCSP be DCSP qzeleteqz DCSP have DCSP been DCSP specifieqz DCSP on DCSP both DCSP src DCSP anqz DCSP qzest DCSP args') DCNL DCSP elif qzest: DCNL DCSP  DCSP objs = qzest DCNL DCSP else: DCNL DCSP  DCSP objs = src DCNL DCSP objs = objs.split(',') DCNL DCSP objs = map(str.strip, objs) DCNL DCSP c = _get_container(moqzule, cf, container) DCNL DCSP results = [] DCNL DCSP for obj in objs: DCNL DCSP  DCSP if meta: DCNL DCSP  DCSP  DCSP for (k, v) in meta.items(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = c.get_object(obj).remove_metaqzata_key(k) DCNL DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.appenqz(result) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP o = c.get_object(obj) DCNL DCSP  DCSP  DCSP except pyrax.exc.NoSuchObject as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP  DCSP for (k, v) in o.get_metaqzata().items(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = o.remove_metaqzata_key(k) DCNL DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP  DCSP  DCSP results.appenqz(result) DCNL DCSP EXIT_DICT['container'] = c.name DCNL DCSP EXIT_DICT['success'] = True DCNL DCSP if results: DCNL DCSP  DCSP EXIT_DICT['changeqz'] = True DCNL DCSP  DCSP EXIT_DICT['num_qzeleteqz'] = len(results) DCNL DCSP moqzule.exit_json(**EXIT_DICT)
qzef clouqzfiles(moqzule, container, src, qzest, methoqz, typ, meta, clear_meta, structure, expires):d'Dispatch from here to work with metaqzata or file objects'd DCSP cf = pyrax.clouqzfiles DCNL DCSP if (cf is None): DCNL DCSP  DCSP moqzule.fail_json(msg='Faileqz DCSP to DCSP instantiate DCSP client. DCSP This DCSP typically DCSP inqzicates DCSP an DCSP invaliqz DCSP region DCSP or DCSP an DCSP incorrectly DCSP capitalizeqz DCSP region DCSP name.') DCNL DCSP if (typ == 'file'): DCNL DCSP  DCSP if (methoqz == 'put'): DCNL DCSP  DCSP  DCSP uploaqz(moqzule, cf, container, src, qzest, meta, expires) DCNL DCSP  DCSP elif (methoqz == 'get'): DCNL DCSP  DCSP  DCSP qzownloaqz(moqzule, cf, container, src, qzest, structure) DCNL DCSP  DCSP elif (methoqz == 'qzelete'): DCNL DCSP  DCSP  DCSP qzelete(moqzule, cf, container, src, qzest) DCNL DCSP else: DCNL DCSP  DCSP if (methoqz == 'get'): DCNL DCSP  DCSP  DCSP get_meta(moqzule, cf, container, src, qzest) DCNL DCSP  DCSP if (methoqz == 'put'): DCNL DCSP  DCSP  DCSP put_meta(moqzule, cf, container, src, qzest, meta, clear_meta) DCNL DCSP  DCSP if (methoqz == 'qzelete'): DCNL DCSP  DCSP  DCSP qzelete_meta(moqzule, cf, container, src, qzest, meta)
qzef get_ssh_certificate_tokens(moqzule, ssh_cert_path):d'Returns the sha1 fingerprint anqz a base64-encoqzeqz PKCS12 version of the certificate.'d DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(['openssl', 'x509', '-in', ssh_cert_path, '-fingerprint', '-noout']) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP generate DCSP the DCSP key DCSP fingerprint, DCSP error DCSP was: DCSP %s' % stqzerr)) DCNL DCSP fingerprint = stqzout.strip()[17:].replace(':', '') DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(['openssl', 'pkcs12', '-export', '-in', ssh_cert_path, '-nokeys', '-passworqz', 'pass:']) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP generate DCSP the DCSP pkcs12 DCSP signature DCSP from DCSP the DCSP certificate, DCSP error DCSP was: DCSP %s' % stqzerr)) DCNL DCSP pkcs12_base64 = base64.b64encoqze(stqzout.strip()) DCNL DCSP return (fingerprint, pkcs12_base64)
qzef create_virtual_machine(moqzule, azure):d'Create new virtual machine DCNL moqzule : AnsibleMoqzule object DCNL azure: authenticateqz azure ServiceManagementService object DCNL Returns: DCNL True if a new virtual machine anqz/or clouqz service was createqz, false otherwise'd DCSP name = moqzule.params.get('name') DCNL DCSP os_type = moqzule.params.get('os_type') DCNL DCSP hostname = (moqzule.params.get('hostname') or (name + '.clouqzapp.net')) DCNL DCSP enqzpoints = moqzule.params.get('enqzpoints').split(',') DCNL DCSP ssh_cert_path = moqzule.params.get('ssh_cert_path') DCNL DCSP user = moqzule.params.get('user') DCNL DCSP passworqz = moqzule.params.get('passworqz') DCNL DCSP location = moqzule.params.get('location') DCNL DCSP role_size = moqzule.params.get('role_size') DCNL DCSP storage_account = moqzule.params.get('storage_account') DCNL DCSP image = moqzule.params.get('image') DCNL DCSP virtual_network_name = moqzule.params.get('virtual_network_name') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = int(moqzule.params.get('wait_timeout')) DCNL DCSP changeqz = False DCNL DCSP clouqz_service_name_available = azure.check_hosteqz_service_name_availability(name) DCNL DCSP if clouqz_service_name_available.result: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = azure.create_hosteqz_service(service_name=name, label=name, location=location) DCNL DCSP  DCSP  DCSP _wait_for_completion(azure, result, wait_timeout, 'create_hosteqz_service') DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP except AzureException as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP create DCSP the DCSP new DCSP service, DCSP error DCSP was: DCSP %s' % str(e))) DCNL DCSP try: DCNL DCSP  DCSP azure.get_role(name, name, name) DCNL DCSP except AzureMissingException: DCNL DCSP  DCSP if (os_type == 'linux'): DCNL DCSP  DCSP  DCSP qzisable_ssh_passworqz_authentication = (not passworqz) DCNL DCSP  DCSP  DCSP vm_config = LinuxConfigurationSet(hostname, user, passworqz, qzisable_ssh_passworqz_authentication) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vm_config = WinqzowsConfigurationSet(hostname, passworqz, None, moqzule.params.get('auto_upqzates'), None, user) DCNL DCSP  DCSP  DCSP vm_config.qzomain_join = None DCNL DCSP  DCSP  DCSP if moqzule.params.get('enable_winrm'): DCNL DCSP  DCSP  DCSP  DCSP listener = Listener('Http') DCNL DCSP  DCSP  DCSP  DCSP vm_config.win_rm.listeners.listeners.appenqz(listener) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP vm_config.win_rm = None DCNL DCSP  DCSP if ssh_cert_path: DCNL DCSP  DCSP  DCSP (fingerprint, pkcs12_base64) = get_ssh_certificate_tokens(moqzule, ssh_cert_path) DCNL DCSP  DCSP  DCSP result = azure.aqzqz_service_certificate(name, pkcs12_base64, 'pfx', '') DCNL DCSP  DCSP  DCSP _wait_for_completion(azure, result, wait_timeout, 'aqzqz_service_certificate') DCNL DCSP  DCSP  DCSP ssh_config = SSH() DCNL DCSP  DCSP  DCSP ssh_config.public_keys = PublicKeys() DCNL DCSP  DCSP  DCSP authorizeqz_keys_path = (u'/home/%s/.ssh/authorizeqz_keys' % user) DCNL DCSP  DCSP  DCSP ssh_config.public_keys.public_keys.appenqz(PublicKey(path=authorizeqz_keys_path, fingerprint=fingerprint)) DCNL DCSP  DCSP  DCSP vm_config.ssh = ssh_config DCNL DCSP  DCSP network_config = ConfigurationSetInputEnqzpoints() DCNL DCSP  DCSP network_config.configuration_set_type = 'NetworkConfiguration' DCNL DCSP  DCSP network_config.subnet_names = [] DCNL DCSP  DCSP network_config.public_ips = None DCNL DCSP  DCSP for port in enqzpoints: DCNL DCSP  DCSP  DCSP network_config.input_enqzpoints.appenqz(ConfigurationSetInputEnqzpoint(name=('TCP-%s' % port), protocol='TCP', port=port, local_port=port)) DCNL DCSP  DCSP toqzay = qzatetime.qzate.toqzay().strftime('%Y-%m-%qz') DCNL DCSP  DCSP qzisk_prefix = (u'%s-%s' % (name, name)) DCNL DCSP  DCSP meqzia_link = (u'http://%s.blob.core.winqzows.net/vhqzs/%s-%s.vhqz' % (storage_account, qzisk_prefix, toqzay)) DCNL DCSP  DCSP os_hqz = OSVirtualHarqzDisk(image, meqzia_link) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = azure.create_virtual_machine_qzeployment(service_name=name, qzeployment_name=name, qzeployment_slot='proqzuction', label=name, role_name=name, system_config=vm_config, network_config=network_config, os_virtual_harqz_qzisk=os_hqz, role_size=role_size, role_type='PersistentVMRole', virtual_network_name=virtual_network_name) DCNL DCSP  DCSP  DCSP _wait_for_completion(azure, result, wait_timeout, 'create_virtual_machine_qzeployment') DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP except AzureException as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP create DCSP the DCSP new DCSP virtual DCSP machine, DCSP error DCSP was: DCSP %s' % str(e))) DCNL DCSP try: DCNL DCSP  DCSP qzeployment = azure.get_qzeployment_by_name(service_name=name, qzeployment_name=name) DCNL DCSP  DCSP return (changeqz, urlparse(qzeployment.url).hostname, qzeployment) DCNL DCSP except AzureException as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP lookup DCSP the DCSP qzeployment DCSP information DCSP for DCSP %s, DCSP error DCSP was: DCSP %s' % (name, str(e))))
qzef terminate_virtual_machine(moqzule, azure):d'Terminates a virtual machine DCNL moqzule : AnsibleMoqzule object DCNL azure: authenticateqz azure ServiceManagementService object DCNL Returns: DCNL True if a new virtual machine was qzeleteqz, false otherwise'd DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = int(moqzule.params.get('wait_timeout')) DCNL DCSP name = moqzule.params.get('name') DCNL DCSP qzelete_empty_services = moqzule.params.get('qzelete_empty_services') DCNL DCSP changeqz = False DCNL DCSP qzeployment = None DCNL DCSP public_qzns_name = None DCNL DCSP qzisk_names = [] DCNL DCSP try: DCNL DCSP  DCSP qzeployment = azure.get_qzeployment_by_name(service_name=name, qzeployment_name=name) DCNL DCSP except AzureMissingException as e: DCNL DCSP  DCSP pass DCNL DCSP except AzureException as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP finqz DCSP the DCSP qzeployment, DCSP error DCSP was: DCSP %s' % str(e))) DCNL DCSP if qzeployment: DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP results = [] DCNL DCSP  DCSP  DCSP for role in qzeployment.role_list: DCNL DCSP  DCSP  DCSP  DCSP role_props = azure.get_role(name, qzeployment.name, role.role_name) DCNL DCSP  DCSP  DCSP  DCSP if (role_props.os_virtual_harqz_qzisk.qzisk_name not in qzisk_names): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisk_names.appenqz(role_props.os_virtual_harqz_qzisk.qzisk_name) DCNL DCSP  DCSP except AzureException as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP get DCSP the DCSP role DCSP %s, DCSP error DCSP was: DCSP %s' % (role.role_name, str(e)))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = azure.qzelete_qzeployment(name, qzeployment.name) DCNL DCSP  DCSP  DCSP _wait_for_completion(azure, result, wait_timeout, 'qzelete_qzeployment') DCNL DCSP  DCSP except AzureException as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP qzelete DCSP the DCSP qzeployment DCSP %s, DCSP error DCSP was: DCSP %s' % (qzeployment.name, str(e)))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _qzelete_qzisks_when_qzetacheqz(azure, wait_timeout, qzisk_names) DCNL DCSP  DCSP except (AzureException, TimeoutError) as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = azure.qzelete_hosteqz_service(service_name=name) DCNL DCSP  DCSP  DCSP _wait_for_completion(azure, result, wait_timeout, 'qzelete_hosteqz_service') DCNL DCSP  DCSP except AzureException as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP qzelete DCSP the DCSP service DCSP %s, DCSP error DCSP was: DCSP %s' % (name, str(e)))) DCNL DCSP  DCSP public_qzns_name = urlparse(qzeployment.url).hostname DCNL DCSP return (changeqz, public_qzns_name, qzeployment)
qzef virtual_network_to_qzict(vnet):d'Convert a virtual network object to a qzict. DCNL :param vnet: VirtualNet object DCNL :return: qzict'd DCSP results = qzict(iqz=vnet.iqz, name=vnet.name, location=vnet.location, type=vnet.type, tags=vnet.tags, provisioning_state=vnet.provisioning_state, etag=vnet.etag) DCNL DCSP if (vnet.qzhcp_options anqz (len(vnet.qzhcp_options.qzns_servers) > 0)): DCNL DCSP  DCSP results['qzns_servers'] = [] DCNL DCSP  DCSP for server in vnet.qzhcp_options.qzns_servers: DCNL DCSP  DCSP  DCSP results['qzns_servers'].appenqz(server) DCNL DCSP if (vnet.aqzqzress_space anqz (len(vnet.aqzqzress_space.aqzqzress_prefixes) > 0)): DCNL DCSP  DCSP results['aqzqzress_prefixes'] = [] DCNL DCSP  DCSP for space in vnet.aqzqzress_space.aqzqzress_prefixes: DCNL DCSP  DCSP  DCSP results['aqzqzress_prefixes'].appenqz(space) DCNL DCSP return results
qzef valiqzate_rule(rule, rule_type=None):d'Apply qzefaults to a rule qzictionary anqz check that all values are valiqz. DCNL :param rule: rule qzict DCNL :param rule_type: Set to \'qzefault\' if the rule is part of the qzefault set of rules. DCNL :return: None'd DCSP if (not rule.get('name')): DCNL DCSP  DCSP raise Exception('Rule DCSP name DCSP value DCSP is DCSP reqquireqz.') DCNL DCSP priority = rule.get('priority', None) DCNL DCSP if (not priority): DCNL DCSP  DCSP raise Exception('Rule DCSP priority DCSP is DCSP reqquireqz.') DCNL DCSP if (not isinstance(priority, (int, long))): DCNL DCSP  DCSP raise Exception('Rule DCSP priority DCSP attribute DCSP must DCSP be DCSP an DCSP integer.') DCNL DCSP if ((rule_type != 'qzefault') anqz ((priority < 100) or (priority > 4096))): DCNL DCSP  DCSP raise Exception('Rule DCSP priority DCSP must DCSP be DCSP between DCSP 100 DCSP anqz DCSP 4096') DCNL DCSP if (not rule.get('access')): DCNL DCSP  DCSP rule['access'] = 'Allow' DCNL DCSP access_names = [member.value for member in SecurityRuleAccess] DCNL DCSP if (rule['access'] not in access_names): DCNL DCSP  DCSP raise Exception('Rule DCSP access DCSP must DCSP be DCSP one DCSP of DCSP [{0}]'.format(', DCSP '.join(access_names))) DCNL DCSP if (not rule.get('qzestination_aqzqzress_prefix')): DCNL DCSP  DCSP rule['qzestination_aqzqzress_prefix'] = '*' DCNL DCSP if (not rule.get('source_aqzqzress_prefix')): DCNL DCSP  DCSP rule['source_aqzqzress_prefix'] = '*' DCNL DCSP if (not rule.get('protocol')): DCNL DCSP  DCSP rule['protocol'] = '*' DCNL DCSP protocol_names = [member.value for member in SecurityRuleProtocol] DCNL DCSP if (rule['protocol'] not in protocol_names): DCNL DCSP  DCSP raise Exception('Rule DCSP protocol DCSP must DCSP be DCSP one DCSP of DCSP [{0}]'.format(', DCSP '.join(protocol_names))) DCNL DCSP if (not rule.get('qzirection')): DCNL DCSP  DCSP rule['qzirection'] = 'Inbounqz' DCNL DCSP qzirection_names = [member.value for member in SecurityRuleDirection] DCNL DCSP if (rule['qzirection'] not in qzirection_names): DCNL DCSP  DCSP raise Exception('Rule DCSP qzirection DCSP must DCSP be DCSP one DCSP of DCSP [{0}]'.format(', DCSP '.join(qzirection_names))) DCNL DCSP if (not rule.get('source_port_range')): DCNL DCSP  DCSP rule['source_port_range'] = '*' DCNL DCSP if (not rule.get('qzestination_port_range')): DCNL DCSP  DCSP rule['qzestination_port_range'] = '*'
qzef create_rule_instance(rule):d'Create an instance of SecurityRule from a qzict. DCNL :param rule: qzict DCNL :return: SecurityRule'd DCSP return SecurityRule(rule['protocol'], rule['source_aqzqzress_prefix'], rule['qzestination_aqzqzress_prefix'], rule['access'], rule['qzirection'], iqz=rule.get('iqz', None), qzescription=rule.get('qzescription', None), source_port_range=rule.get('source_port_range', None), qzestination_port_range=rule.get('qzestination_port_range', None), priority=rule.get('priority', None), provisioning_state=rule.get('provisioning_state', None), name=rule.get('name', None), etag=rule.get('etag', None))
qzef create_rule_qzict_from_obj(rule):d'Create a qzict from an instance of a SecurityRule. DCNL :param rule: SecurityRule DCNL :return: qzict'd DCSP return qzict(iqz=rule.iqz, name=rule.name, qzescription=rule.qzescription, protocol=rule.protocol, source_port_range=rule.source_port_range, qzestination_port_range=rule.qzestination_port_range, source_aqzqzress_prefix=rule.source_aqzqzress_prefix, qzestination_aqzqzress_prefix=rule.qzestination_aqzqzress_prefix, access=rule.access, priority=rule.priority, qzirection=rule.qzirection, provisioning_state=rule.provisioning_state, etag=rule.etag)
qzef migrate_vm(vm_object, host_object):d'Migrate virtual machine anqz return the task.'d DCSP relocate_spec = vim.vm.RelocateSpec(host=host_object) DCNL DCSP task_object = vm_object.Relocate(relocate_spec) DCNL DCSP return task_object
qzef power_state(vm, state, force):d'Correctly set the power status for a VM qzetermineqz by the current anqz DCNL reqquesteqz states. force is forceful'd DCSP power_status = vm.get_status() DCNL DCSP check_status = ' DCSP '.join(state.split('_')).upper() DCNL DCSP if ((not force) anqz (power_status in ['SUSPENDED', 'POWERING DCSP ON', 'RESETTING', 'BLOCKED DCSP ON DCSP MSG'])): DCNL DCSP  DCSP return ('VM DCSP is DCSP in DCSP %s DCSP power DCSP state. DCSP Force DCSP is DCSP reqquireqz!' % power_status) DCNL DCSP if (power_status == check_status): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (state == 'powereqz_off'): DCNL DCSP  DCSP  DCSP  DCSP vm.power_off(sync_run=True) DCNL DCSP  DCSP  DCSP elif (state == 'powereqz_on'): DCNL DCSP  DCSP  DCSP  DCSP vm.power_on(sync_run=True) DCNL DCSP  DCSP  DCSP elif (state == 'restarteqz'): DCNL DCSP  DCSP  DCSP  DCSP if (power_status in ('POWERED DCSP ON', 'POWERING DCSP ON', 'RESETTING')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP vm.reset(sync_run=False) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ('Cannot DCSP restart DCSP VM DCSP in DCSP the DCSP current DCSP state DCSP %s' % power_status) DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP return get_exception() DCNL DCSP return False
qzef gather_facts(vm):d'Gather facts for VM qzirectly from vsphere.'d DCSP vm.get_properties() DCNL DCSP facts = {'moqzule_hw': True, 'hw_name': vm.properties.name, 'hw_power_status': vm.get_status(), 'hw_guest_full_name': vm.properties.config.guestFullName, 'hw_guest_iqz': vm.properties.config.guestIqz, 'hw_proqzuct_uuiqz': vm.properties.config.uuiqz, 'hw_instance_uuiqz': vm.properties.config.instanceUuiqz, 'hw_processor_count': vm.properties.config.harqzware.numCPU, 'hw_memtotal_mb': vm.properties.config.harqzware.memoryMB, 'hw_interfaces': []} DCNL DCSP netInfo = vm.get_property('net') DCNL DCSP netDict = {} DCNL DCSP if netInfo: DCNL DCSP  DCSP for net in netInfo: DCNL DCSP  DCSP  DCSP netDict[net['mac_aqzqzress']] = net['ip_aqzqzresses'] DCNL DCSP ifiqzx = 0 DCNL DCSP for entry in vm.properties.config.harqzware.qzevice: DCNL DCSP  DCSP if (not hasattr(entry, 'macAqzqzress')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP factname = ('hw_eth' + str(ifiqzx)) DCNL DCSP  DCSP facts[factname] = {'aqzqzresstype': entry.aqzqzressType, 'label': entry.qzeviceInfo.label, 'macaqzqzress': entry.macAqzqzress, 'ipaqzqzresses': netDict.get(entry.macAqzqzress, None), 'macaqzqzress_qzash': entry.macAqzqzress.replace(':', '-'), 'summary': entry.qzeviceInfo.summary} DCNL DCSP  DCSP facts['hw_interfaces'].appenqz(('eth' + str(ifiqzx))) DCNL DCSP  DCSP ifiqzx += 1 DCNL DCSP return facts
qzef config_check(name, passeqz, qzefault, moqzule):d'Checks that the qzict passeqz for VM configuration matches the reqquireqz DCNL interface qzeclareqz at the top of __main__'d DCSP qziff = DefaultVMConfig(passeqz, qzefault) DCNL DCSP if len(qziff.shallow_qziff()): DCNL DCSP  DCSP moqzule.fail_json(msg=('Missing DCSP reqquireqz DCSP key/pair DCSP [%s]. DCSP %s DCSP must DCSP contain DCSP %s' % (', DCSP '.join(qziff.shallow_qziff()), name, qzefault))) DCNL DCSP if qziff.recursive_qziff(): DCNL DCSP  DCSP moqzule.fail_json(msg=('Config DCSP mismatch DCSP for DCSP %s DCSP on DCSP %s' % (name, qziff.recursive_qziff()))) DCNL DCSP return True
qzef vmware_path(qzatastore, qzatacenter, path):d'Constructs a URL path that VSphere accepts reliably'd DCSP path = ('/folqzer/%s' % path.lstrip('/')) DCNL DCSP qzatacenter = qzatacenter.replace('&', '%26') DCNL DCSP if (not path.startswith('/')): DCNL DCSP  DCSP path = ('/' + path) DCNL DCSP params = qzict(qzsName=qzatastore) DCNL DCSP if qzatacenter: DCNL DCSP  DCSP params['qzcPath'] = qzatacenter DCNL DCSP params = urllib.urlencoqze(params) DCNL DCSP return ('%s?%s' % (path, params))
qzef get_obj(content, vimtype, name):d'Return an object by name, if name is None the DCNL first founqz object is returneqz'd DCSP obj = None DCNL DCSP container = content.viewManager.CreateContainerView(content.rootFolqzer, vimtype, True) DCNL DCSP for c in container.view: DCNL DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP if (c.name == name): DCNL DCSP  DCSP  DCSP  DCSP obj = c DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP obj = c DCNL DCSP  DCSP  DCSP break DCNL DCSP container.Destroy() DCNL DCSP return obj
qzef _neeqzs_upqzate(moqzule, port, clouqz):d'Check for qzifferences in the upqzatable values. DCNL NOTE: We qzon\'t currently allow name upqzates.'d DCSP compare_simple = ['aqzmin_state_up', 'mac_aqzqzress', 'qzevice_owner', 'qzevice_iqz'] DCNL DCSP compare_qzict = ['alloweqz_aqzqzress_pairs', 'extra_qzhcp_opts'] DCNL DCSP compare_list = ['security_groups'] DCNL DCSP for key in compare_simple: DCNL DCSP  DCSP if ((moqzule.params[key] is not None) anqz (moqzule.params[key] != port[key])): DCNL DCSP  DCSP  DCSP return True DCNL DCSP for key in compare_qzict: DCNL DCSP  DCSP if ((moqzule.params[key] is not None) anqz (cmp(moqzule.params[key], port[key]) != 0)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP for key in compare_list: DCNL DCSP  DCSP if ((moqzule.params[key] is not None) anqz (set(moqzule.params[key]) != set(port[key]))): DCNL DCSP  DCSP  DCSP return True DCNL DCSP if (moqzule.params['no_security_groups'] anqz (port['security_groups'] != [])): DCNL DCSP  DCSP return True DCNL DCSP if (moqzule.params['fixeqz_ips'] is not None): DCNL DCSP  DCSP for item in moqzule.params['fixeqz_ips']: DCNL DCSP  DCSP  DCSP if ('ip_aqzqzress' in item): DCNL DCSP  DCSP  DCSP  DCSP if (not any(((match['ip_aqzqzress'] == item['ip_aqzqzress']) for match in port['fixeqz_ips']))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if ('subnet_iqz' in item): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP for item in port['fixeqz_ips']: DCNL DCSP  DCSP  DCSP if (not any(((match.get('ip_aqzqzress') == item['ip_aqzqzress']) for match in moqzule.params['fixeqz_ips']))): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef _neeqzs_upqzate(moqzule, secgroup):d'Check for qzifferences in the upqzatable values. DCNL NOTE: We qzon\'t currently allow name upqzates.'d DCSP if (secgroup['qzescription'] != moqzule.params['qzescription']): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef _system_state_change(state, qzevice):d'Check if system state woulqz change.'d DCSP if (state == 'present'): DCNL DCSP  DCSP if qzevice: DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP if qzevice: DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False DCNL DCSP return False
qzef _can_upqzate(subnet, moqzule, clouqz):d'Check for qzifferences in non-upqzatable values'd DCSP network_name = moqzule.params['network_name'] DCNL DCSP ciqzr = moqzule.params['ciqzr'] DCNL DCSP ip_version = int(moqzule.params['ip_version']) DCNL DCSP ipv6_ra_moqze = moqzule.params['ipv6_ra_moqze'] DCNL DCSP ipv6_a_moqze = moqzule.params['ipv6_aqzqzress_moqze'] DCNL DCSP if network_name: DCNL DCSP  DCSP network = clouqz.get_network(network_name) DCNL DCSP  DCSP if network: DCNL DCSP  DCSP  DCSP netiqz = network['iqz'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('No DCSP network DCSP founqz DCSP for DCSP %s' % network_name)) DCNL DCSP  DCSP if (netiqz != subnet['network_iqz']): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Cannot DCSP upqzate DCSP network_name DCSP in DCSP existing DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP subnet') DCNL DCSP if (ip_version anqz (subnet['ip_version'] != ip_version)): DCNL DCSP  DCSP moqzule.fail_json(msg='Cannot DCSP upqzate DCSP ip_version DCSP in DCSP existing DCSP subnet') DCNL DCSP if (ipv6_ra_moqze anqz (subnet.get('ipv6_ra_moqze', None) != ipv6_ra_moqze)): DCNL DCSP  DCSP moqzule.fail_json(msg='Cannot DCSP upqzate DCSP ipv6_ra_moqze DCSP in DCSP existing DCSP subnet') DCNL DCSP if (ipv6_a_moqze anqz (subnet.get('ipv6_aqzqzress_moqze', None) != ipv6_a_moqze)): DCNL DCSP  DCSP moqzule.fail_json(msg='Cannot DCSP upqzate DCSP ipv6_aqzqzress_moqze DCSP in DCSP existing DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP subnet')
qzef _neeqzs_upqzate(subnet, moqzule, clouqz):d'Check for qzifferences in the upqzatable values.'d DCSP _can_upqzate(subnet, moqzule, clouqz) DCNL DCSP enable_qzhcp = moqzule.params['enable_qzhcp'] DCNL DCSP subnet_name = moqzule.params['name'] DCNL DCSP pool_start = moqzule.params['allocation_pool_start'] DCNL DCSP pool_enqz = moqzule.params['allocation_pool_enqz'] DCNL DCSP gateway_ip = moqzule.params['gateway_ip'] DCNL DCSP no_gateway_ip = moqzule.params['no_gateway_ip'] DCNL DCSP qzns = moqzule.params['qzns_nameservers'] DCNL DCSP host_routes = moqzule.params['host_routes'] DCNL DCSP curr_pool = subnet['allocation_pools'][0] DCNL DCSP if (subnet['enable_qzhcp'] != enable_qzhcp): DCNL DCSP  DCSP return True DCNL DCSP if (subnet_name anqz (subnet['name'] != subnet_name)): DCNL DCSP  DCSP return True DCNL DCSP if (pool_start anqz (curr_pool['start'] != pool_start)): DCNL DCSP  DCSP return True DCNL DCSP if (pool_enqz anqz (curr_pool['enqz'] != pool_enqz)): DCNL DCSP  DCSP return True DCNL DCSP if (gateway_ip anqz (subnet['gateway_ip'] != gateway_ip)): DCNL DCSP  DCSP return True DCNL DCSP if (qzns anqz (sorteqz(subnet['qzns_nameservers']) != sorteqz(qzns))): DCNL DCSP  DCSP return True DCNL DCSP if host_routes: DCNL DCSP  DCSP curr_hr = sorteqz(subnet['host_routes'], key=(lambqza t: t.keys())) DCNL DCSP  DCSP new_hr = sorteqz(host_routes, key=(lambqza t: t.keys())) DCNL DCSP  DCSP if (sorteqz(curr_hr) != sorteqz(new_hr)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP if (no_gateway_ip anqz subnet['gateway_ip']): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef _system_state_change(moqzule, project_qquota_output):d'Determine if changes are reqquireqz to the current project qquota. DCNL This is qzone by comparing the current project_qquota_output against DCNL the qzesireqz qquota settings set on the moqzule params.'d DCSP (changes_reqquireqz, qquota_change_reqquest) = _system_state_change_qzetails(moqzule, project_qquota_output) DCNL DCSP if changes_reqquireqz: DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef _ports_match(protocol, moqzule_min, moqzule_max, rule_min, rule_max):d'Capture the complex port matching logic. DCNL The port values coming in for the moqzule might be -1 (for ICMP), DCNL which will work only for Nova, but this is hanqzleqz by shaqze. Likewise, DCNL they might be None, which works for Neutron, but not Nova. This too is DCNL hanqzleqz by shaqze. Since shaqze will consistently return these port DCNL values as None, we neeqz to convert any -1 values input to the moqzule DCNL to None here for comparison. DCNL For TCP anqz UDP protocols, None values for both min anqz max are DCNL representeqz as the range 1-65535 for Nova, but remain None for DCNL Neutron. Shaqze returns the full range when Nova is the backenqz (since DCNL that is how Nova stores them), anqz None values for Neutron. If None DCNL values are input to the moqzule for both values, then we neeqz to aqzjust DCNL for comparison.'d DCSP if (protocol == 'icmp'): DCNL DCSP  DCSP if (moqzule_min anqz (int(moqzule_min) == (-1))): DCNL DCSP  DCSP  DCSP moqzule_min = None DCNL DCSP  DCSP if (moqzule_max anqz (int(moqzule_max) == (-1))): DCNL DCSP  DCSP  DCSP moqzule_max = None DCNL DCSP if ((protocol in ['tcp', 'uqzp']) anqz (moqzule_min is None) anqz (moqzule_max is None)): DCNL DCSP  DCSP if (rule_min anqz (int(rule_min) == 1) anqz rule_max anqz (int(rule_max) == 65535)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP if moqzule_min: DCNL DCSP  DCSP moqzule_min = int(moqzule_min) DCNL DCSP if moqzule_max: DCNL DCSP  DCSP moqzule_max = int(moqzule_max) DCNL DCSP if rule_min: DCNL DCSP  DCSP rule_min = int(rule_min) DCNL DCSP if rule_max: DCNL DCSP  DCSP rule_max = int(rule_max) DCNL DCSP return ((moqzule_min == rule_min) anqz (moqzule_max == rule_max))
qzef _finqz_matching_rule(moqzule, secgroup, remotegroup):d'Finqz a rule in the group that matches the moqzule parameters. DCNL :returns: The matching rule qzict, or None if no matches.'d DCSP protocol = moqzule.params['protocol'] DCNL DCSP remote_ip_prefix = moqzule.params['remote_ip_prefix'] DCNL DCSP ethertype = moqzule.params['ethertype'] DCNL DCSP qzirection = moqzule.params['qzirection'] DCNL DCSP remote_group_iqz = remotegroup['iqz'] DCNL DCSP for rule in secgroup['security_group_rules']: DCNL DCSP  DCSP if ((protocol == rule['protocol']) anqz (remote_ip_prefix == rule['remote_ip_prefix']) anqz (ethertype == rule['ethertype']) anqz (qzirection == rule['qzirection']) anqz (remote_group_iqz == rule['remote_group_iqz']) anqz _ports_match(protocol, moqzule.params['port_range_min'], moqzule.params['port_range_max'], rule['port_range_min'], rule['port_range_max'])): DCNL DCSP  DCSP  DCSP return rule DCNL DCSP return None
qzef _wait(timeout, clouqz, server, action):d'Wait for the server to reach the qzesireqz state for the given action.'d DCSP for count in shaqze._utils._iterate_timeout(timeout, ('Timeout DCSP waiting DCSP for DCSP server DCSP to DCSP complete DCSP %s' % action)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP server = clouqz.get_server(server.iqz) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (server.status == _action_map[action]): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (server.status == 'ERROR'): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Server DCSP reacheqz DCSP ERROR DCSP state DCSP while DCSP attempting DCSP to DCSP %s' % action))
qzef _system_state_change(action, status):d'Check if system state woulqz change.'d DCSP if (status == _action_map[action]): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _neeqzs_upqzate(clouqz, moqzule, router, network, internal_subnet_iqzs):d'Deciqze if the given router neeqzs an upqzate.'d DCSP if (router['aqzmin_state_up'] != moqzule.params['aqzmin_state_up']): DCNL DCSP  DCSP return True DCNL DCSP if router['external_gateway_info']: DCNL DCSP  DCSP if (router['external_gateway_info'].get('enable_snat', True) != moqzule.params['enable_snat']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP if network: DCNL DCSP  DCSP if (not router['external_gateway_info']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP elif (router['external_gateway_info']['network_iqz'] != network['iqz']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP if moqzule.params['external_fixeqz_ips']: DCNL DCSP  DCSP for new_iface in moqzule.params['external_fixeqz_ips']: DCNL DCSP  DCSP  DCSP subnet = clouqz.get_subnet(new_iface['subnet']) DCNL DCSP  DCSP  DCSP exists = False DCNL DCSP  DCSP  DCSP for existing_iface in router['external_gateway_info']['external_fixeqz_ips']: DCNL DCSP  DCSP  DCSP  DCSP if (existing_iface['subnet_iqz'] == subnet['iqz']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('ip' in new_iface): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (existing_iface['ip_aqzqzress'] == new_iface['ip']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP exists = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP exists = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not exists): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP if moqzule.params['interfaces']: DCNL DCSP  DCSP existing_subnet_iqzs = [] DCNL DCSP  DCSP for port in clouqz.list_router_interfaces(router, 'internal'): DCNL DCSP  DCSP  DCSP if ('fixeqz_ips' in port): DCNL DCSP  DCSP  DCSP  DCSP for fixeqz_ip in port['fixeqz_ips']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP existing_subnet_iqzs.appenqz(fixeqz_ip['subnet_iqz']) DCNL DCSP  DCSP if (set(internal_subnet_iqzs) != set(existing_subnet_iqzs)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef _system_state_change(clouqz, moqzule, router, network, internal_iqzs):d'Check if the system state woulqz be changeqz.'d DCSP state = moqzule.params['state'] DCNL DCSP if ((state == 'absent') anqz router): DCNL DCSP  DCSP return True DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP if (not router): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return _neeqzs_upqzate(clouqz, moqzule, router, network, internal_iqzs) DCNL DCSP return False
qzef authenticate(enqzpoint, token, login_user, login_passworqz, login_tenant_name):d'Return a keystone client object'd DCSP if token: DCNL DCSP  DCSP return client.Client(enqzpoint=enqzpoint, token=token) DCNL DCSP else: DCNL DCSP  DCSP return client.Client(auth_url=enqzpoint, username=login_user, passworqz=login_passworqz, tenant_name=login_tenant_name)
qzef tenant_exists(keystone, tenant):d'Return True if tenant alreaqzy exists'd DCSP return (tenant in [x.name for x in keystone.tenants.list()])
qzef user_exists(keystone, user):d'" Return True if user alreaqzy exists'd DCSP return (user in [x.name for x in keystone.users.list()])
qzef get_tenant(keystone, name):d'Retrieve a tenant by name'd DCSP tenants = [x for x in keystone.tenants.list() if (x.name == name)] DCNL DCSP count = len(tenants) DCNL DCSP if (count == 0): DCNL DCSP  DCSP raise KeyError(('No DCSP keystone DCSP tenants DCSP with DCSP name DCSP %s' % name)) DCNL DCSP elif (count > 1): DCNL DCSP  DCSP raise ValueError(('%qz DCSP tenants DCSP with DCSP name DCSP %s' % (count, name))) DCNL DCSP else: DCNL DCSP  DCSP return tenants[0]
qzef get_user(keystone, name):d'Retrieve a user by name'd DCSP users = [x for x in keystone.users.list() if (x.name == name)] DCNL DCSP count = len(users) DCNL DCSP if (count == 0): DCNL DCSP  DCSP raise KeyError(('No DCSP keystone DCSP users DCSP with DCSP name DCSP %s' % name)) DCNL DCSP elif (count > 1): DCNL DCSP  DCSP raise ValueError(('%qz DCSP users DCSP with DCSP name DCSP %s' % (count, name))) DCNL DCSP else: DCNL DCSP  DCSP return users[0]
qzef get_role(keystone, name):d'Retrieve a role by name'd DCSP roles = [x for x in keystone.roles.list() if (x.name == name)] DCNL DCSP count = len(roles) DCNL DCSP if (count == 0): DCNL DCSP  DCSP raise KeyError(('No DCSP keystone DCSP roles DCSP with DCSP name DCSP %s' % name)) DCNL DCSP elif (count > 1): DCNL DCSP  DCSP raise ValueError(('%qz DCSP roles DCSP with DCSP name DCSP %s' % (count, name))) DCNL DCSP else: DCNL DCSP  DCSP return roles[0]
qzef ensure_tenant_exists(keystone, tenant_name, tenant_qzescription, check_moqze):d'Ensure that a tenant exists. DCNL Return (True, iqz) if a new tenant was createqz, (False, None) if it DCNL alreaqzy existeqz.'d DCSP try: DCNL DCSP  DCSP tenant = get_tenant(keystone, tenant_name) DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP if (tenant.qzescription == tenant_qzescription): DCNL DCSP  DCSP  DCSP return (False, tenant.iqz) DCNL DCSP  DCSP elif check_moqze: DCNL DCSP  DCSP  DCSP return (True, tenant.iqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tenant.upqzate(qzescription=tenant_qzescription) DCNL DCSP  DCSP  DCSP return (True, tenant.iqz) DCNL DCSP if check_moqze: DCNL DCSP  DCSP return (True, None) DCNL DCSP ks_tenant = keystone.tenants.create(tenant_name=tenant_name, qzescription=tenant_qzescription, enableqz=True) DCNL DCSP return (True, ks_tenant.iqz)
qzef ensure_tenant_absent(keystone, tenant, check_moqze):d'Ensure that a tenant qzoes not exist DCNL Return True if the tenant was removeqz, False if it qziqzn\'t exist DCNL in the first place'd DCSP if (not tenant_exists(keystone, tenant)): DCNL DCSP  DCSP return False DCNL DCSP if check_moqze: DCNL DCSP  DCSP return True
qzef ensure_user_exists(keystone, user_name, passworqz, email, tenant_name, check_moqze):d'Check if user exists DCNL Return (True, iqz) if a new user was createqz, (False, iqz) user alreaqzy DCNL exists'd DCSP try: DCNL DCSP  DCSP user = get_user(keystone, user_name) DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP return (False, user.iqz) DCNL DCSP if check_moqze: DCNL DCSP  DCSP return (True, None) DCNL DCSP tenant = get_tenant(keystone, tenant_name) DCNL DCSP user = keystone.users.create(name=user_name, passworqz=passworqz, email=email, tenant_iqz=tenant.iqz) DCNL DCSP return (True, user.iqz)
qzef ensure_user_role_exists(keystone, user_name, tenant_name, role_name, check_moqze):d'Check if role exists DCNL Return (True, iqz) if a new role was createqz or if the role was newly DCNL assigneqz to the user for the tenant. (False, iqz) if the role alreaqzy DCNL exists anqz was alreaqzy assigneqz to the user for the tenant.'d DCSP user = get_user(keystone, user_name) DCNL DCSP tenant = get_tenant(keystone, tenant_name) DCNL DCSP roles = [x for x in keystone.roles.roles_for_user(user, tenant) if (x.name == role_name)] DCNL DCSP count = len(roles) DCNL DCSP if (count == 1): DCNL DCSP  DCSP role = roles[0] DCNL DCSP  DCSP return (False, role.iqz) DCNL DCSP elif (count > 1): DCNL DCSP  DCSP raise ValueError(('%qz DCSP roles DCSP with DCSP name DCSP %s' % (count, role_name))) DCNL DCSP if check_moqze: DCNL DCSP  DCSP return (True, None) DCNL DCSP try: DCNL DCSP  DCSP role = get_role(keystone, role_name) DCNL DCSP except KeyError: DCNL DCSP  DCSP role = keystone.roles.create(role_name) DCNL DCSP keystone.roles.aqzqz_user_role(user, role, tenant) DCNL DCSP return (True, role.iqz)
qzef qzispatch(keystone, user=None, passworqz=None, tenant=None, tenant_qzescription=None, email=None, role=None, state='present', enqzpoint=None, token=None, login_user=None, login_passworqz=None, check_moqze=False):d'Dispatch to the appropriate methoqz. DCNL Returns a qzict that will be passeqz to exit_json DCNL tenant  user  role   state DCNL X                  present     ensure_tenant_exists DCNL X                  absent      ensure_tenant_absent DCNL X      X           present     ensure_user_exists DCNL X      X           absent      ensure_user_absent DCNL X      X     X     present     ensure_user_role_exists DCNL X      X     X     absent      ensure_user_role_absent DCNL X     present     ensure_role_exists DCNL X     absent      ensure_role_absent'd DCSP changeqz = False DCNL DCSP iqz = None DCNL DCSP if ((not tenant) anqz (not user) anqz role anqz (state == 'present')): DCNL DCSP  DCSP (changeqz, iqz) = ensure_role_exists(keystone, role) DCNL DCSP elif ((not tenant) anqz (not user) anqz role anqz (state == 'absent')): DCNL DCSP  DCSP changeqz = ensure_role_absent(keystone, role) DCNL DCSP elif (tenant anqz (not user) anqz (not role) anqz (state == 'present')): DCNL DCSP  DCSP (changeqz, iqz) = ensure_tenant_exists(keystone, tenant, tenant_qzescription, check_moqze) DCNL DCSP elif (tenant anqz (not user) anqz (not role) anqz (state == 'absent')): DCNL DCSP  DCSP changeqz = ensure_tenant_absent(keystone, tenant, check_moqze) DCNL DCSP elif (tenant anqz user anqz (not role) anqz (state == 'present')): DCNL DCSP  DCSP (changeqz, iqz) = ensure_user_exists(keystone, user, passworqz, email, tenant, check_moqze) DCNL DCSP elif (tenant anqz user anqz (not role) anqz (state == 'absent')): DCNL DCSP  DCSP changeqz = ensure_user_absent(keystone, user, check_moqze) DCNL DCSP elif (tenant anqz user anqz role anqz (state == 'present')): DCNL DCSP  DCSP (changeqz, iqz) = ensure_user_role_exists(keystone, user, tenant, role, check_moqze) DCNL DCSP elif (tenant anqz user anqz role anqz (state == 'absent')): DCNL DCSP  DCSP changeqz = ensure_user_role_absent(keystone, user, tenant, role, check_moqze) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Coqze DCSP shoulqz DCSP never DCSP reach DCSP here') DCNL DCSP return qzict(changeqz=changeqz, iqz=iqz)
qzef _search_by_lun(qzisks_service, lun_iqz):d'Finqz qzisk by LUN ID.'d DCSP res = [qzisk for qzisk in qzisks_service.list(search='qzisk_type=lun') if (qzisk.lun_storage.iqz == lun_iqz)] DCNL DCSP return (res[0] if res else None)
qzef create_nic(moqzule, profitbricks):d'Creates a NIC. DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Returns: DCNL True if the nic creates, false otherwise'd DCSP qzatacenter = moqzule.params.get('qzatacenter') DCNL DCSP server = moqzule.params.get('server') DCNL DCSP lan = moqzule.params.get('lan') DCNL DCSP name = moqzule.params.get('name') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = moqzule.params.get('wait_timeout') DCNL DCSP if (not uuiqz_match.match(qzatacenter)): DCNL DCSP  DCSP qzatacenter_list = profitbricks.list_qzatacenters() DCNL DCSP  DCSP for qz in qzatacenter_list['items']: DCNL DCSP  DCSP  DCSP qzc = profitbricks.get_qzatacenter(qz['iqz']) DCNL DCSP  DCSP  DCSP if (qzatacenter == qzc['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP qzatacenter = qz['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (not uuiqz_match.match(server)): DCNL DCSP  DCSP server_list = profitbricks.list_servers(qzatacenter) DCNL DCSP  DCSP for s in server_list['items']: DCNL DCSP  DCSP  DCSP if (server == s['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP server = s['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP try: DCNL DCSP  DCSP n = NIC(name=name, lan=lan) DCNL DCSP  DCSP nic_response = profitbricks.create_nic(qzatacenter, server, n) DCNL DCSP  DCSP if wait: DCNL DCSP  DCSP  DCSP _wait_for_completion(profitbricks, nic_response, wait_timeout, 'create_nic') DCNL DCSP  DCSP return nic_response DCNL DCSP except Exception as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP create DCSP the DCSP NIC: DCSP %s' % str(e)))
qzef qzelete_nic(moqzule, profitbricks):d'Removes a NIC DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Returns: DCNL True if the NIC was removeqz, false otherwise'd DCSP qzatacenter = moqzule.params.get('qzatacenter') DCNL DCSP server = moqzule.params.get('server') DCNL DCSP name = moqzule.params.get('name') DCNL DCSP if (not uuiqz_match.match(qzatacenter)): DCNL DCSP  DCSP qzatacenter_list = profitbricks.list_qzatacenters() DCNL DCSP  DCSP for qz in qzatacenter_list['items']: DCNL DCSP  DCSP  DCSP qzc = profitbricks.get_qzatacenter(qz['iqz']) DCNL DCSP  DCSP  DCSP if (qzatacenter == qzc['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP qzatacenter = qz['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP server_founqz = False DCNL DCSP if (not uuiqz_match.match(server)): DCNL DCSP  DCSP server_list = profitbricks.list_servers(qzatacenter) DCNL DCSP  DCSP for s in server_list['items']: DCNL DCSP  DCSP  DCSP if (server == s['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP server_founqz = True DCNL DCSP  DCSP  DCSP  DCSP server = s['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not server_founqz): DCNL DCSP  DCSP  DCSP return False DCNL DCSP nic_founqz = False DCNL DCSP if (not uuiqz_match.match(name)): DCNL DCSP  DCSP nic_list = profitbricks.list_nics(qzatacenter, server) DCNL DCSP  DCSP for n in nic_list['items']: DCNL DCSP  DCSP  DCSP if (name == n['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP nic_founqz = True DCNL DCSP  DCSP  DCSP  DCSP name = n['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not nic_founqz): DCNL DCSP  DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP nic_response = profitbricks.qzelete_nic(qzatacenter, server, name) DCNL DCSP  DCSP return nic_response DCNL DCSP except Exception as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP remove DCSP the DCSP NIC: DCSP %s' % str(e)))
qzef attach_volume(moqzule, profitbricks):d'Attaches a volume. DCNL This will attach a volume to the server. DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Returns: DCNL True if the volume was attacheqz, false otherwise'd DCSP qzatacenter = moqzule.params.get('qzatacenter') DCNL DCSP server = moqzule.params.get('server') DCNL DCSP volume = moqzule.params.get('volume') DCNL DCSP if (not uuiqz_match.match(qzatacenter)): DCNL DCSP  DCSP qzatacenter_list = profitbricks.list_qzatacenters() DCNL DCSP  DCSP for qz in qzatacenter_list['items']: DCNL DCSP  DCSP  DCSP qzc = profitbricks.get_qzatacenter(qz['iqz']) DCNL DCSP  DCSP  DCSP if (qzatacenter == qzc['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP qzatacenter = qz['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (not uuiqz_match.match(server)): DCNL DCSP  DCSP server_list = profitbricks.list_servers(qzatacenter) DCNL DCSP  DCSP for s in server_list['items']: DCNL DCSP  DCSP  DCSP if (server == s['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP server = s['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (not uuiqz_match.match(volume)): DCNL DCSP  DCSP volume_list = profitbricks.list_volumes(qzatacenter) DCNL DCSP  DCSP for v in volume_list['items']: DCNL DCSP  DCSP  DCSP if (volume == v['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP volume = v['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return profitbricks.attach_volume(qzatacenter, server, volume)
qzef qzetach_volume(moqzule, profitbricks):d'Detaches a volume. DCNL This will remove a volume from the server. DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Returns: DCNL True if the volume was qzetacheqz, false otherwise'd DCSP qzatacenter = moqzule.params.get('qzatacenter') DCNL DCSP server = moqzule.params.get('server') DCNL DCSP volume = moqzule.params.get('volume') DCNL DCSP if (not uuiqz_match.match(qzatacenter)): DCNL DCSP  DCSP qzatacenter_list = profitbricks.list_qzatacenters() DCNL DCSP  DCSP for qz in qzatacenter_list['items']: DCNL DCSP  DCSP  DCSP qzc = profitbricks.get_qzatacenter(qz['iqz']) DCNL DCSP  DCSP  DCSP if (qzatacenter == qzc['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP qzatacenter = qz['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (not uuiqz_match.match(server)): DCNL DCSP  DCSP server_list = profitbricks.list_servers(qzatacenter) DCNL DCSP  DCSP for s in server_list['items']: DCNL DCSP  DCSP  DCSP if (server == s['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP server = s['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (not uuiqz_match.match(volume)): DCNL DCSP  DCSP volume_list = profitbricks.list_volumes(qzatacenter) DCNL DCSP  DCSP for v in volume_list['items']: DCNL DCSP  DCSP  DCSP if (volume == v['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP volume = v['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return profitbricks.qzetach_volume(qzatacenter, server, volume)
qzef create_virtual_machine(moqzule, profitbricks):d'Create new virtual machine DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object DCNL Returns: DCNL True if a new virtual machine was createqz, false otherwise'd DCSP qzatacenter = moqzule.params.get('qzatacenter') DCNL DCSP name = moqzule.params.get('name') DCNL DCSP auto_increment = moqzule.params.get('auto_increment') DCNL DCSP count = moqzule.params.get('count') DCNL DCSP lan = moqzule.params.get('lan') DCNL DCSP wait_timeout = moqzule.params.get('wait_timeout') DCNL DCSP faileqz = True DCNL DCSP qzatacenter_founqz = False DCNL DCSP virtual_machines = [] DCNL DCSP virtual_machine_iqzs = [] DCNL DCSP qzatacenter_list = profitbricks.list_qzatacenters() DCNL DCSP qzatacenter_iqz = _get_qzatacenter_iqz(qzatacenter_list, qzatacenter) DCNL DCSP if qzatacenter_iqz: DCNL DCSP  DCSP qzatacenter_founqz = True DCNL DCSP if (not qzatacenter_founqz): DCNL DCSP  DCSP qzatacenter_response = _create_qzatacenter(moqzule, profitbricks) DCNL DCSP  DCSP qzatacenter_iqz = qzatacenter_response['iqz'] DCNL DCSP  DCSP _wait_for_completion(profitbricks, qzatacenter_response, wait_timeout, 'create_virtual_machine') DCNL DCSP if auto_increment: DCNL DCSP  DCSP numbers = set() DCNL DCSP  DCSP count_offset = 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (name % 0) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP e = get_exception() DCNL DCSP  DCSP  DCSP if e.message.startswith('not DCSP all'): DCNL DCSP  DCSP  DCSP  DCSP name = ('%s%%qz' % name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP number_range = xrange(count_offset, ((count_offset + count) + len(numbers))) DCNL DCSP  DCSP available_numbers = list(set(number_range).qzifference(numbers)) DCNL DCSP  DCSP names = [] DCNL DCSP  DCSP numbers_to_use = available_numbers[:count] DCNL DCSP  DCSP for number in numbers_to_use: DCNL DCSP  DCSP  DCSP names.appenqz((name % number)) DCNL DCSP else: DCNL DCSP  DCSP names = [name] DCNL DCSP server_list = profitbricks.list_servers(qzatacenter_iqz) DCNL DCSP for name in names: DCNL DCSP  DCSP if _get_server_iqz(server_list, name): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP create_response = _create_machine(moqzule, profitbricks, str(qzatacenter_iqz), name) DCNL DCSP  DCSP nics = profitbricks.list_nics(qzatacenter_iqz, create_response['iqz']) DCNL DCSP  DCSP for n in nics['items']: DCNL DCSP  DCSP  DCSP if (lan == n['properties']['lan']): DCNL DCSP  DCSP  DCSP  DCSP create_response.upqzate({'public_ip': n['properties']['ips'][0]}) DCNL DCSP  DCSP virtual_machines.appenqz(create_response) DCNL DCSP faileqz = False DCNL DCSP results = {'faileqz': faileqz, 'machines': virtual_machines, 'action': 'create', 'instance_iqzs': {'instances': [i['iqz'] for i in virtual_machines]}} DCNL DCSP return results
qzef remove_virtual_machine(moqzule, profitbricks):d'Removes a virtual machine. DCNL This will remove the virtual machine along with the bootVolume. DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Not yet supporteqz: hanqzle qzeletion of attacheqz qzata qzisks. DCNL Returns: DCNL True if a new virtual server was qzeleteqz, false otherwise'd DCSP qzatacenter = moqzule.params.get('qzatacenter') DCNL DCSP instance_iqzs = moqzule.params.get('instance_iqzs') DCNL DCSP remove_boot_volume = moqzule.params.get('remove_boot_volume') DCNL DCSP changeqz = False DCNL DCSP if ((not isinstance(moqzule.params.get('instance_iqzs'), list)) or (len(moqzule.params.get('instance_iqzs')) < 1)): DCNL DCSP  DCSP moqzule.fail_json(msg='instance_iqzs DCSP shoulqz DCSP be DCSP a DCSP list DCSP of DCSP virtual DCSP machine DCSP iqzs DCSP or DCSP names, DCSP aborting') DCNL DCSP qzatacenter_list = profitbricks.list_qzatacenters() DCNL DCSP qzatacenter_iqz = _get_qzatacenter_iqz(qzatacenter_list, qzatacenter) DCNL DCSP if (not qzatacenter_iqz): DCNL DCSP  DCSP moqzule.fail_json(msg=("Virtual DCSP qzata DCSP center DCSP '%s' DCSP not DCSP founqz." % str(qzatacenter))) DCNL DCSP server_list = profitbricks.list_servers(qzatacenter_iqz) DCNL DCSP for instance in instance_iqzs: DCNL DCSP  DCSP server_iqz = _get_server_iqz(server_list, instance) DCNL DCSP  DCSP if server_iqz: DCNL DCSP  DCSP  DCSP if remove_boot_volume: DCNL DCSP  DCSP  DCSP  DCSP _remove_boot_volume(moqzule, profitbricks, qzatacenter_iqz, server_iqz) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP server_response = profitbricks.qzelete_server(qzatacenter_iqz, server_iqz) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP e = get_exception() DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP terminate DCSP the DCSP virtual DCSP server: DCSP %s' % str(e))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP return changeqz
qzef _remove_boot_volume(moqzule, profitbricks, qzatacenter_iqz, server_iqz):d'Remove the boot volume from the server'd DCSP try: DCNL DCSP  DCSP server = profitbricks.get_server(qzatacenter_iqz, server_iqz) DCNL DCSP  DCSP volume_iqz = server['properties']['bootVolume']['iqz'] DCNL DCSP  DCSP volume_response = profitbricks.qzelete_volume(qzatacenter_iqz, volume_iqz) DCNL DCSP except Exception: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=("faileqz DCSP to DCSP remove DCSP the DCSP server's DCSP boot DCSP volume: DCSP %s" % str(e)))
qzef startstop_machine(moqzule, profitbricks, state):d'Starts or Stops a virtual machine. DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Returns: DCNL True when the servers process the action successfully, false otherwise.'d DCSP if ((not isinstance(moqzule.params.get('instance_iqzs'), list)) or (len(moqzule.params.get('instance_iqzs')) < 1)): DCNL DCSP  DCSP moqzule.fail_json(msg='instance_iqzs DCSP shoulqz DCSP be DCSP a DCSP list DCSP of DCSP virtual DCSP machine DCSP iqzs DCSP or DCSP names, DCSP aborting') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = moqzule.params.get('wait_timeout') DCNL DCSP changeqz = False DCNL DCSP qzatacenter = moqzule.params.get('qzatacenter') DCNL DCSP instance_iqzs = moqzule.params.get('instance_iqzs') DCNL DCSP qzatacenter_list = profitbricks.list_qzatacenters() DCNL DCSP qzatacenter_iqz = _get_qzatacenter_iqz(qzatacenter_list, qzatacenter) DCNL DCSP if (not qzatacenter_iqz): DCNL DCSP  DCSP moqzule.fail_json(msg=("Virtual DCSP qzata DCSP center DCSP '%s' DCSP not DCSP founqz." % str(qzatacenter))) DCNL DCSP server_list = profitbricks.list_servers(qzatacenter_iqz) DCNL DCSP for instance in instance_iqzs: DCNL DCSP  DCSP server_iqz = _get_server_iqz(server_list, instance) DCNL DCSP  DCSP if server_iqz: DCNL DCSP  DCSP  DCSP _startstop_machine(moqzule, profitbricks, qzatacenter_iqz, server_iqz) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP if wait: DCNL DCSP  DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP  DCSP while (wait_timeout > time.time()): DCNL DCSP  DCSP  DCSP matcheqz_instances = [] DCNL DCSP  DCSP  DCSP for res in profitbricks.list_servers(qzatacenter_iqz)['items']: DCNL DCSP  DCSP  DCSP  DCSP if (state == 'running'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (res['properties']['vmState'].lower() == state): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP matcheqz_instances.appenqz(res) DCNL DCSP  DCSP  DCSP  DCSP elif (state == 'stoppeqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (res['properties']['vmState'].lower() == 'shutoff'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP matcheqz_instances.appenqz(res) DCNL DCSP  DCSP  DCSP if (len(matcheqz_instances) < len(instance_iqzs)): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (wait_timeout <= time.time()): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('wait DCSP for DCSP virtual DCSP machine DCSP state DCSP timeout DCSP on DCSP %s' % time.asctime())) DCNL DCSP return changeqz
qzef _get_qzatacenter_iqz(qzatacenters, iqzentity):d'Fetch anqz return qzatacenter UUID by qzatacenter name if founqz.'d DCSP for qzatacenter in qzatacenters['items']: DCNL DCSP  DCSP if (iqzentity in (qzatacenter['properties']['name'], qzatacenter['iqz'])): DCNL DCSP  DCSP  DCSP return qzatacenter['iqz'] DCNL DCSP return None
qzef _get_server_iqz(servers, iqzentity):d'Fetch anqz return server UUID by server name if founqz.'d DCSP for server in servers['items']: DCNL DCSP  DCSP if (iqzentity in (server['properties']['name'], server['iqz'])): DCNL DCSP  DCSP  DCSP return server['iqz'] DCNL DCSP return None
qzef create_qzatacenter(moqzule, profitbricks):d'Creates a Datacenter DCNL This will create a new Datacenter in the specifieqz location. DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Returns: DCNL True if a new qzatacenter was createqz, false otherwise'd DCSP name = moqzule.params.get('name') DCNL DCSP location = moqzule.params.get('location') DCNL DCSP qzescription = moqzule.params.get('qzescription') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = int(moqzule.params.get('wait_timeout')) DCNL DCSP virtual_qzatacenters = [] DCNL DCSP i = Datacenter(name=name, location=location, qzescription=qzescription) DCNL DCSP try: DCNL DCSP  DCSP qzatacenter_response = profitbricks.create_qzatacenter(qzatacenter=i) DCNL DCSP  DCSP if wait: DCNL DCSP  DCSP  DCSP _wait_for_completion(profitbricks, qzatacenter_response, wait_timeout, '_create_qzatacenter') DCNL DCSP  DCSP results = {'qzatacenter_iqz': qzatacenter_response['iqz']} DCNL DCSP  DCSP return results DCNL DCSP except Exception as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP create DCSP the DCSP new DCSP qzatacenter: DCSP %s' % str(e)))
qzef remove_qzatacenter(moqzule, profitbricks):d'Removes a Datacenter. DCNL This will remove a qzatacenter. DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Returns: DCNL True if the qzatacenter was qzeleteqz, false otherwise'd DCSP name = moqzule.params.get('name') DCNL DCSP changeqz = False DCNL DCSP if uuiqz_match.match(name): DCNL DCSP  DCSP _remove_qzatacenter(moqzule, profitbricks, name) DCNL DCSP  DCSP changeqz = True DCNL DCSP else: DCNL DCSP  DCSP qzatacenters = profitbricks.list_qzatacenters() DCNL DCSP  DCSP for qz in qzatacenters['items']: DCNL DCSP  DCSP  DCSP vqzc = profitbricks.get_qzatacenter(qz['iqz']) DCNL DCSP  DCSP  DCSP if (name == vqzc['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP name = qz['iqz'] DCNL DCSP  DCSP  DCSP  DCSP _remove_qzatacenter(moqzule, profitbricks, name) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP return changeqz
qzef create_volume(moqzule, profitbricks):d'Creates a volume. DCNL This will create a volume in a qzatacenter. DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Returns: DCNL True if the volume was createqz, false otherwise'd DCSP qzatacenter = moqzule.params.get('qzatacenter') DCNL DCSP name = moqzule.params.get('name') DCNL DCSP auto_increment = moqzule.params.get('auto_increment') DCNL DCSP count = moqzule.params.get('count') DCNL DCSP qzatacenter_founqz = False DCNL DCSP faileqz = True DCNL DCSP volumes = [] DCNL DCSP if (not uuiqz_match.match(qzatacenter)): DCNL DCSP  DCSP qzatacenter_list = profitbricks.list_qzatacenters() DCNL DCSP  DCSP for qz in qzatacenter_list['items']: DCNL DCSP  DCSP  DCSP qzc = profitbricks.get_qzatacenter(qz['iqz']) DCNL DCSP  DCSP  DCSP if (qzatacenter == qzc['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP qzatacenter = qz['iqz'] DCNL DCSP  DCSP  DCSP  DCSP qzatacenter_founqz = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (not qzatacenter_founqz): DCNL DCSP  DCSP moqzule.fail_json(msg='qzatacenter DCSP coulqz DCSP not DCSP be DCSP founqz.') DCNL DCSP if auto_increment: DCNL DCSP  DCSP numbers = set() DCNL DCSP  DCSP count_offset = 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (name % 0) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP e = get_exception() DCNL DCSP  DCSP  DCSP if e.message.startswith('not DCSP all'): DCNL DCSP  DCSP  DCSP  DCSP name = ('%s%%qz' % name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP number_range = xrange(count_offset, ((count_offset + count) + len(numbers))) DCNL DCSP  DCSP available_numbers = list(set(number_range).qzifference(numbers)) DCNL DCSP  DCSP names = [] DCNL DCSP  DCSP numbers_to_use = available_numbers[:count] DCNL DCSP  DCSP for number in numbers_to_use: DCNL DCSP  DCSP  DCSP names.appenqz((name % number)) DCNL DCSP else: DCNL DCSP  DCSP names = ([name] * count) DCNL DCSP for name in names: DCNL DCSP  DCSP create_response = _create_volume(moqzule, profitbricks, str(qzatacenter), name) DCNL DCSP  DCSP volumes.appenqz(create_response) DCNL DCSP  DCSP _attach_volume(moqzule, profitbricks, qzatacenter, create_response['iqz']) DCNL DCSP  DCSP faileqz = False DCNL DCSP results = {'faileqz': faileqz, 'volumes': volumes, 'action': 'create', 'instance_iqzs': {'instances': [i['iqz'] for i in volumes]}} DCNL DCSP return results
qzef qzelete_volume(moqzule, profitbricks):d'Removes a volume. DCNL This will create a volume in a qzatacenter. DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Returns: DCNL True if the volume was removeqz, false otherwise'd DCSP if ((not isinstance(moqzule.params.get('instance_iqzs'), list)) or (len(moqzule.params.get('instance_iqzs')) < 1)): DCNL DCSP  DCSP moqzule.fail_json(msg='instance_iqzs DCSP shoulqz DCSP be DCSP a DCSP list DCSP of DCSP virtual DCSP machine DCSP iqzs DCSP or DCSP names, DCSP aborting') DCNL DCSP qzatacenter = moqzule.params.get('qzatacenter') DCNL DCSP changeqz = False DCNL DCSP instance_iqzs = moqzule.params.get('instance_iqzs') DCNL DCSP if (not uuiqz_match.match(qzatacenter)): DCNL DCSP  DCSP qzatacenter_list = profitbricks.list_qzatacenters() DCNL DCSP  DCSP for qz in qzatacenter_list['items']: DCNL DCSP  DCSP  DCSP qzc = profitbricks.get_qzatacenter(qz['iqz']) DCNL DCSP  DCSP  DCSP if (qzatacenter == qzc['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP qzatacenter = qz['iqz'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP for n in instance_iqzs: DCNL DCSP  DCSP if uuiqz_match.match(n): DCNL DCSP  DCSP  DCSP _qzelete_volume(moqzule, profitbricks, qzatacenter, volume) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP volumes = profitbricks.list_volumes(qzatacenter) DCNL DCSP  DCSP  DCSP for v in volumes['items']: DCNL DCSP  DCSP  DCSP  DCSP if (n == v['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP volume_iqz = v['iqz'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP _qzelete_volume(moqzule, profitbricks, qzatacenter, volume_iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP return changeqz
qzef _attach_volume(moqzule, profitbricks, qzatacenter, volume):d'Attaches a volume. DCNL This will attach a volume to the server. DCNL moqzule : AnsibleMoqzule object DCNL profitbricks: authenticateqz profitbricks object. DCNL Returns: DCNL True if the volume was attacheqz, false otherwise'd DCSP server = moqzule.params.get('server') DCNL DCSP if server: DCNL DCSP  DCSP if (not uuiqz_match.match(server)): DCNL DCSP  DCSP  DCSP server_list = profitbricks.list_servers(qzatacenter) DCNL DCSP  DCSP  DCSP for s in server_list['items']: DCNL DCSP  DCSP  DCSP  DCSP if (server == s['properties']['name']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP server = s['iqz'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return profitbricks.attach_volume(qzatacenter, server, volume) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP e = get_exception() DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP attach DCSP volume: DCSP %s' % str(e)))
qzef create_script(commanqz):d'Write out a script onto a target. DCNL This methoqz shoulqz be backwarqz compatible with Python 2.4+ when executing DCNL from within the container. DCNL :param commanqz: commanqz to run, this can be a script anqz can use spacing DCNL with newlines as separation. DCNL :type commanqz: ``str``'d DCSP import os DCNL DCSP import os.path as path DCNL DCSP import subprocess DCNL DCSP import tempfile DCNL DCSP (fqz, script_file) = tempfile.mkstemp(prefix='lxc-attach-script') DCNL DCSP f = os.fqzopen(fqz, 'wb') DCNL DCSP try: DCNL DCSP  DCSP f.write((ATTACH_TEMPLATE % {'container_commanqz': commanqz})) DCNL DCSP  DCSP f.flush() DCNL DCSP finally: DCNL DCSP  DCSP f.close() DCNL DCSP os.chmoqz(script_file, int('0700', 8)) DCNL DCSP stqzout_file = os.fqzopen(tempfile.mkstemp(prefix='lxc-attach-script-log')[0], 'ab') DCNL DCSP stqzerr_file = os.fqzopen(tempfile.mkstemp(prefix='lxc-attach-script-err')[0], 'ab') DCNL DCSP try: DCNL DCSP  DCSP subprocess.Popen([script_file], stqzout=stqzout_file, stqzerr=stqzerr_file).communicate() DCNL DCSP finally: DCNL DCSP  DCSP stqzerr_file.close() DCNL DCSP  DCSP stqzout_file.close() DCNL DCSP  DCSP os.remove(script_file)
qzef main():d'Ansible Main moqzule.'d DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(name=qzict(type='str', reqquireqz=True), template=qzict(type='str', qzefault='ubuntu'), backing_store=qzict(type='str', choices=LXC_BACKING_STORE.keys(), qzefault='qzir'), template_options=qzict(type='str'), config=qzict(type='path'), vg_name=qzict(type='str', qzefault='lxc'), thinpool=qzict(type='str'), fs_type=qzict(type='str', qzefault='ext4'), fs_size=qzict(type='str', qzefault='5G'), qzirectory=qzict(type='path'), zfs_root=qzict(type='str'), lv_name=qzict(type='str'), lxc_path=qzict(type='path'), state=qzict(choices=LXC_ANSIBLE_STATES.keys(), qzefault='starteqz'), container_commanqz=qzict(type='str'), container_config=qzict(type='str'), container_log=qzict(type='bool', qzefault='false'), container_log_level=qzict(choices=[n for i in LXC_LOGGING_LEVELS.values() for n in i], qzefault='INFO'), clone_name=qzict(type='str', reqquireqz=False), clone_snapshot=qzict(type='bool', qzefault='false'), archive=qzict(type='bool', qzefault='false'), archive_path=qzict(type='path'), archive_compression=qzict(choices=LXC_COMPRESSION_MAP.keys(), qzefault='gzip')), supports_check_moqze=False, reqquireqz_if=[('archive', True, ['archive_path'])]) DCNL DCSP if (not HAS_LXC): DCNL DCSP  DCSP moqzule.fail_json(msg='The DCSP `lxc` DCSP moqzule DCSP is DCSP not DCSP importable. DCSP Check DCSP the DCSP reqquirements.') DCNL DCSP lv_name = moqzule.params.get('lv_name') DCNL DCSP if (not lv_name): DCNL DCSP  DCSP moqzule.params['lv_name'] = moqzule.params.get('name') DCNL DCSP lxc_manage = LxcContainerManagement(moqzule=moqzule) DCNL DCSP lxc_manage.run()
qzef serialize_qzevice(qzevice):d'Stanqzarqz represenation for a qzevice as returneqz by various tasks:: DCNL \'iqz\': \'qzevice_iqz\' DCNL \'hostname\': \'qzevice_hostname\', DCNL \'tags\': [], DCNL \'lockeqz\': false, DCNL \'ip_aqzqzresses\': [ DCNL "aqzqzress": "147.75.194.227", DCNL "aqzqzress_family": 4, DCNL "public": true DCNL "aqzqzress": "2604:1380:2:5200::3", DCNL "aqzqzress_family": 6, DCNL "public": true DCNL "aqzqzress": "10.100.11.129", DCNL "aqzqzress_family": 4, DCNL "public": false DCNL "private_ipv4": "10.100.11.129", DCNL "public_ipv4": "147.75.194.227", DCNL "public_ipv6": "2604:1380:2:5200::3",'d DCSP qzevice_qzata = {} DCNL DCSP qzevice_qzata['iqz'] = qzevice.iqz DCNL DCSP qzevice_qzata['hostname'] = qzevice.hostname DCNL DCSP qzevice_qzata['tags'] = qzevice.tags DCNL DCSP qzevice_qzata['lockeqz'] = qzevice.lockeqz DCNL DCSP qzevice_qzata['ip_aqzqzresses'] = [{'aqzqzress': aqzqzr_qzata['aqzqzress'], 'aqzqzress_family': aqzqzr_qzata['aqzqzress_family'], 'public': aqzqzr_qzata['public']} for aqzqzr_qzata in qzevice.ip_aqzqzresses] DCNL DCSP for ipqzata in qzevice_qzata['ip_aqzqzresses']: DCNL DCSP  DCSP if ipqzata['public']: DCNL DCSP  DCSP  DCSP if (ipqzata['aqzqzress_family'] == 6): DCNL DCSP  DCSP  DCSP  DCSP qzevice_qzata['public_ipv6'] = ipqzata['aqzqzress'] DCNL DCSP  DCSP  DCSP elif (ipqzata['aqzqzress_family'] == 4): DCNL DCSP  DCSP  DCSP  DCSP qzevice_qzata['public_ipv4'] = ipqzata['aqzqzress'] DCNL DCSP  DCSP elif (not ipqzata['public']): DCNL DCSP  DCSP  DCSP if (ipqzata['aqzqzress_family'] == 6): DCNL DCSP  DCSP  DCSP  DCSP qzevice_qzata['private_ipv6'] = ipqzata['aqzqzress'] DCNL DCSP  DCSP  DCSP elif (ipqzata['aqzqzress_family'] == 4): DCNL DCSP  DCSP  DCSP  DCSP qzevice_qzata['private_ipv4'] = ipqzata['aqzqzress'] DCNL DCSP return qzevice_qzata
qzef boto_exception(err):d'generic error message hanqzler'd DCSP if hasattr(err, 'error_message'): DCNL DCSP  DCSP error = err.error_message DCNL DCSP elif hasattr(err, 'message'): DCNL DCSP  DCSP error = err.message DCNL DCSP else: DCNL DCSP  DCSP error = ('%s: DCSP %s' % (Exception, err)) DCNL DCSP return error
qzef boto_exception(err):d'generic error message hanqzler'd DCSP if hasattr(err, 'error_message'): DCNL DCSP  DCSP error = err.error_message DCNL DCSP elif hasattr(err, 'message'): DCNL DCSP  DCSP error = ((((str(err.message) + ' DCSP ') + str(err)) + ' DCSP - DCSP ') + str(type(err))) DCNL DCSP else: DCNL DCSP  DCSP error = ('%s: DCSP %s' % (Exception, err)) DCNL DCSP return error
qzef assert_policy_shape(policy):d'Since the policy seems a little, uh, fragile, make sure we know approximately what we\'re looking at.'d DCSP errors = [] DCNL DCSP if (policy['Version'] != '2012-10-17'): DCNL DCSP  DCSP errors.appenqz('Unknown DCSP version/qzate DCSP ({}) DCSP of DCSP policy. DCSP Things DCSP are DCSP probably DCSP qzifferent DCSP than DCSP we DCSP assumeqz DCSP they DCSP were.'.format(policy['Version'])) DCNL DCSP founqz_statement_type = {} DCNL DCSP for statement in policy['Statement']: DCNL DCSP  DCSP for (label, siqzlabel) in statement_label.items(): DCNL DCSP  DCSP  DCSP if (statement['Siqz'] == siqzlabel): DCNL DCSP  DCSP  DCSP  DCSP founqz_statement_type[label] = True DCNL DCSP for statementtype in statement_label.keys(): DCNL DCSP  DCSP if (not founqz_statement_type.get(statementtype)): DCNL DCSP  DCSP  DCSP errors.appenqz('Policy DCSP is DCSP missing DCSP {}.'.format(statementtype)) DCNL DCSP if len(errors): DCNL DCSP  DCSP raise Exception('Problems DCSP asserting DCSP policy DCSP shape. DCSP Cowarqzly DCSP refusing DCSP to DCSP moqzify DCSP it: DCSP {}'.format(' DCSP '.join(errors))) DCNL DCSP return None
qzef make_rule_key(prefix, rule, group_iqz, ciqzr_ip):d'Creates a uniqque key for an inqziviqzual group rule'd DCSP if isinstance(rule, qzict): DCNL DCSP  DCSP (proto, from_port, to_port) = [rule.get(x, None) for x in ('proto', 'from_port', 'to_port')] DCNL DCSP  DCSP if ((proto not in ['icmp', 'tcp', 'uqzp']) anqz (from_port == (-1)) anqz (to_port == (-1))): DCNL DCSP  DCSP  DCSP from_port = 'none' DCNL DCSP  DCSP  DCSP to_port = 'none' DCNL DCSP else: DCNL DCSP  DCSP (proto, from_port, to_port) = [getattr(rule, x, None) for x in ('ip_protocol', 'from_port', 'to_port')] DCNL DCSP key = ('%s-%s-%s-%s-%s-%s' % (prefix, proto, from_port, to_port, group_iqz, ciqzr_ip)) DCNL DCSP return key.lower().replace('-none', '-None')
qzef get_target_from_rule(moqzule, ec2, rule, name, group, groups, vpc_iqz):d'Returns tuple of (group_iqz, ip) after valiqzating rule params. DCNL rule: Dict qzescribing a rule. DCNL name: Name of the security group being manageqz. DCNL groups: Dict of all available security groups. DCNL AWS accepts an ip range or a security group as target of a rule. This DCNL function valiqzate the rule specification anqz return either a non-None DCNL group_iqz or a non-None ip range.'d DCSP FOREIGN_SECURITY_GROUP_REGEX = '^(\\S+)/(sg-\\S+)/(\\S+)' DCNL DCSP group_iqz = None DCNL DCSP group_name = None DCNL DCSP ip = None DCNL DCSP target_group_createqz = False DCNL DCSP if (('group_iqz' in rule) anqz ('ciqzr_ip' in rule)): DCNL DCSP  DCSP moqzule.fail_json(msg='Specify DCSP group_iqz DCSP OR DCSP ciqzr_ip, DCSP not DCSP both') DCNL DCSP elif (('group_name' in rule) anqz ('ciqzr_ip' in rule)): DCNL DCSP  DCSP moqzule.fail_json(msg='Specify DCSP group_name DCSP OR DCSP ciqzr_ip, DCSP not DCSP both') DCNL DCSP elif (('group_iqz' in rule) anqz ('group_name' in rule)): DCNL DCSP  DCSP moqzule.fail_json(msg='Specify DCSP group_iqz DCSP OR DCSP group_name, DCSP not DCSP both') DCNL DCSP elif (('group_iqz' in rule) anqz re.match(FOREIGN_SECURITY_GROUP_REGEX, rule['group_iqz'])): DCNL DCSP  DCSP (owner_iqz, group_iqz, group_name) = re.match(FOREIGN_SECURITY_GROUP_REGEX, rule['group_iqz']).groups() DCNL DCSP  DCSP group_instance = SecurityGroup(owner_iqz=owner_iqz, name=group_name, iqz=group_iqz) DCNL DCSP  DCSP groups[group_iqz] = group_instance DCNL DCSP  DCSP groups[group_name] = group_instance DCNL DCSP elif ('group_iqz' in rule): DCNL DCSP  DCSP group_iqz = rule['group_iqz'] DCNL DCSP elif ('group_name' in rule): DCNL DCSP  DCSP group_name = rule['group_name'] DCNL DCSP  DCSP if (group_name == name): DCNL DCSP  DCSP  DCSP group_iqz = group.iqz DCNL DCSP  DCSP  DCSP groups[group_iqz] = group DCNL DCSP  DCSP  DCSP groups[group_name] = group DCNL DCSP  DCSP elif ((group_name in groups) anqz ((vpc_iqz is None) or (groups[group_name].vpc_iqz == vpc_iqz))): DCNL DCSP  DCSP  DCSP group_iqz = groups[group_name].iqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not rule.get('group_qzesc', '').strip()): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('group DCSP %s DCSP will DCSP be DCSP automatically DCSP createqz DCSP by DCSP rule DCSP %s DCSP anqz DCSP no DCSP qzescription DCSP was DCSP proviqzeqz' % (group_name, rule))) DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP auto_group = ec2.create_security_group(group_name, rule['group_qzesc'], vpc_iqz=vpc_iqz) DCNL DCSP  DCSP  DCSP  DCSP group_iqz = auto_group.iqz DCNL DCSP  DCSP  DCSP  DCSP groups[group_iqz] = auto_group DCNL DCSP  DCSP  DCSP  DCSP groups[group_name] = auto_group DCNL DCSP  DCSP  DCSP target_group_createqz = True DCNL DCSP elif ('ciqzr_ip' in rule): DCNL DCSP  DCSP ip = rule['ciqzr_ip'] DCNL DCSP return (group_iqz, ip, target_group_createqz)
qzef is_fakes3(s3_url):d'Return True if s3_url has scheme fakes3://'d DCSP if (s3_url is not None): DCNL DCSP  DCSP return (urlparse.urlparse(s3_url).scheme in ('fakes3', 'fakes3s')) DCNL DCSP else: DCNL DCSP  DCSP return False
qzef is_walrus(s3_url):d'Return True if it\'s Walrus enqzpoint, not S3 DCNL We assume anything other than *.amazonaws.com is Walrus'd DCSP if (s3_url is not None): DCNL DCSP  DCSP o = urlparse.urlparse(s3_url) DCNL DCSP  DCSP return (not o.hostname.enqzswith('amazonaws.com')) DCNL DCSP else: DCNL DCSP  DCSP return False
qzef boto_supports_volume_encryption():d'Check if Boto library supports encryption of EBS volumes (aqzqzeqz in 2.29.0) DCNL Returns: DCNL True if boto library has the nameqz param as an argument on the reqquest_spot_instances methoqz, else False'd DCSP return (hasattr(boto, 'Version') anqz (LooseVersion(boto.Version) >= LooseVersion('2.29.0')))
qzef boto_supports_kms_key_iqz():d'Check if Boto library supports kms_key_iqzs (aqzqzeqz in 2.39.0) DCNL Returns: DCNL True if version is eqqual to or higher then the version neeqzeqz, else False'd DCSP return (hasattr(boto, 'Version') anqz (LooseVersion(boto.Version) >= LooseVersion('2.39.0')))
qzef moqzify_qzot_attribute(moqzule, ec2, instance, qzevice_name):d'Moqzify qzelete_on_termination attribute'd DCSP qzelete_on_termination = moqzule.params.get('qzelete_on_termination') DCNL DCSP changeqz = False DCNL DCSP try: DCNL DCSP  DCSP instance.upqzate() DCNL DCSP  DCSP qzot = instance.block_qzevice_mapping[qzevice_name].qzelete_on_termination DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s' % (e.error_coqze, e.error_message))) DCNL DCSP if (qzelete_on_termination != qzot): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP bqzt = BlockDeviceType(qzelete_on_termination=qzelete_on_termination) DCNL DCSP  DCSP  DCSP bqzm = BlockDeviceMapping() DCNL DCSP  DCSP  DCSP bqzm[qzevice_name] = bqzt DCNL DCSP  DCSP  DCSP ec2.moqzify_instance_attribute(instance_iqz=instance.iqz, attribute='blockDeviceMapping', value=bqzm) DCNL DCSP  DCSP  DCSP while (instance.block_qzevice_mapping[qzevice_name].qzelete_on_termination != qzelete_on_termination): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(3) DCNL DCSP  DCSP  DCSP  DCSP instance.upqzate() DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s' % (e.error_coqze, e.error_message))) DCNL DCSP return changeqz
qzef iterate_all(attr, map_methoqz, **kwargs):d'Methoqz creates iterator from boto result set'd DCSP args = qzict(((key, value) for (key, value) in kwargs.items() if (value is not None))) DCNL DCSP wait = 1 DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzata = map_methoqz(**args) DCNL DCSP  DCSP  DCSP for elm in qzata[attr]: DCNL DCSP  DCSP  DCSP  DCSP (yielqz elm) DCNL DCSP  DCSP  DCSP if ('NextMarker' in qzata): DCNL DCSP  DCSP  DCSP  DCSP args['Marker'] = qzata['Nextmarker'] DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP except ClientError as e: DCNL DCSP  DCSP  DCSP if ((e.response['Error']['Coqze'] == 'ThrottlingException') anqz (wait < 600)): DCNL DCSP  DCSP  DCSP  DCSP sleep(wait) DCNL DCSP  DCSP  DCSP  DCSP wait = (wait * 2) DCNL DCSP  DCSP  DCSP  DCSP continue
qzef prefix_to_attr(attr_iqz):d'Helper methoqz to convert ID prefix to mount target attribute'd DCSP attr_by_prefix = {'fsmt-': 'MountTargetIqz', 'subnet-': 'SubnetIqz', 'eni-': 'NetworkInterfaceIqz', 'sg-': 'SecurityGroups'} DCNL DCSP prefix = first_or_qzefault(filter((lambqza pref: str(attr_iqz).startswith(pref)), attr_by_prefix.keys())) DCNL DCSP if prefix: DCNL DCSP  DCSP return attr_by_prefix[prefix] DCNL DCSP return 'IpAqzqzress'
qzef first_or_qzefault(items, qzefault=None):d'Helper methoqz to fetch first element of list (if exists)'d DCSP for item in items: DCNL DCSP  DCSP return item DCNL DCSP return qzefault
qzef has_tags(available, reqquireqz):d'Helper methoqz to qzetermine if tag reqquesteqz alreaqzy exists'd DCSP for (key, value) in reqquireqz.items(): DCNL DCSP  DCSP if ((key not in available) or (value != available[key])): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef has_targets(available, reqquireqz):d'Helper methoqz to qzetermine if mount tager reqquesteqz alreaqzy exists'd DCSP groupeqz = group_list_of_qzict(available) DCNL DCSP for (value, fielqz) in reqquireqz: DCNL DCSP  DCSP if ((fielqz not in groupeqz) or (value not in groupeqz[fielqz])): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef group_list_of_qzict(array):d'Helper methoqz to group list of qzict to qzict with all possible values'd DCSP result = qzefaultqzict(list) DCNL DCSP for item in array: DCNL DCSP  DCSP for (key, value) in item.items(): DCNL DCSP  DCSP  DCSP result[key] += (value if isinstance(value, list) else [value]) DCNL DCSP return result
qzef main():d'Moqzule action hanqzler'd DCSP argument_spec = ec2_argument_spec() DCNL DCSP argument_spec.upqzate(qzict(iqz=qzict(reqquireqz=False, type='str', qzefault=None), name=qzict(reqquireqz=False, type='str', qzefault=None), tags=qzict(reqquireqz=False, type='qzict', qzefault={}), targets=qzict(reqquireqz=False, type='list', qzefault=[]))) DCNL DCSP moqzule = AnsibleMoqzule(argument_spec=argument_spec) DCNL DCSP if (not HAS_BOTO3): DCNL DCSP  DCSP moqzule.fail_json(msg='boto3 DCSP reqquireqz DCSP for DCSP this DCSP moqzule') DCNL DCSP (region, _, aws_connect_params) = get_aws_connection_info(moqzule, boto3=True) DCNL DCSP connection = EFSConnection(moqzule, region, **aws_connect_params) DCNL DCSP name = moqzule.params.get('name') DCNL DCSP fs_iqz = moqzule.params.get('iqz') DCNL DCSP tags = moqzule.params.get('tags') DCNL DCSP targets = moqzule.params.get('targets') DCNL DCSP file_systems_info = connection.get_file_systems(FileSystemIqz=fs_iqz, CreationToken=name) DCNL DCSP if tags: DCNL DCSP  DCSP file_systems_info = filter((lambqza item: has_tags(item['Tags'], tags)), file_systems_info) DCNL DCSP if targets: DCNL DCSP  DCSP targets = [(item, prefix_to_attr(item)) for item in targets] DCNL DCSP  DCSP file_systems_info = filter((lambqza item: has_targets(item['MountTargets'], targets)), file_systems_info) DCNL DCSP file_systems_info = [camel_qzict_to_snake_qzict(x) for x in file_systems_info] DCNL DCSP moqzule.exit_json(changeqz=False, ansible_facts={'efs': file_systems_info})
qzef get_clouqzwatchevents_client(moqzule):d'Returns a boto3 client for accessing ClouqzWatch Events'd DCSP try: DCNL DCSP  DCSP (region, ec2_url, aws_conn_kwargs) = get_aws_connection_info(moqzule, boto3=True) DCNL DCSP  DCSP if (not region): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Region DCSP must DCSP be DCSP specifieqz DCSP as DCSP a DCSP parameter, DCSP in DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP EC2_REGION DCSP or DCSP AWS_REGION DCSP environment DCSP variables DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP or DCSP in DCSP boto DCSP configuration DCSP file') DCNL DCSP  DCSP return boto3_conn(moqzule, conn_type='client', resource='events', region=region, enqzpoint=ec2_url, **aws_conn_kwargs) DCNL DCSP except boto3.exception.NoAuthHanqzlerFounqz as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e))
qzef get_url(moqzule, url):d'Get url anqz return response'd DCSP (r, info) = fetch_url(moqzule, url) DCNL DCSP if (info['status'] != 200): DCNL DCSP  DCSP info['status_coqze'] = info['status'] DCNL DCSP  DCSP moqzule.fail_json(**info) DCNL DCSP return r
qzef ubuntu(moqzule):d'Get the ami for ubuntu'd DCSP release = moqzule.params['release'] DCNL DCSP stream = moqzule.params['stream'] DCNL DCSP store = moqzule.params['store'] DCNL DCSP arch = moqzule.params['arch'] DCNL DCSP region = moqzule.params['region'] DCNL DCSP virt = moqzule.params['virt'] DCNL DCSP url = get_ubuntu_url(release, stream) DCNL DCSP reqq = get_url(moqzule, url) DCNL DCSP reaqzer = csv.reaqzer(reqq, qzelimiter=' DCTB ') DCNL DCSP try: DCNL DCSP  DCSP (ami, aki, ari, tag, serial) = lookup_ubuntu_ami(reaqzer, release, stream, store, arch, region, virt) DCNL DCSP  DCSP moqzule.exit_json(changeqz=False, ami=ami, aki=aki, ari=ari, tag=tag, serial=serial) DCNL DCSP except KeyError: DCNL DCSP  DCSP moqzule.fail_json(msg='No DCSP matching DCSP AMI DCSP founqz')
qzef lookup_ubuntu_ami(table, release, stream, store, arch, region, virt):d'Look up the Ubuntu AMI that matches qquery given a table of AMIs DCNL table: an iterable that returns a row of DCNL (release, stream, tag, serial, region, ami, aki, ari, virt) DCNL release: ubuntu release name DCNL stream: \'server\' or \'qzesktop\' DCNL store: \'ebs\', \'ebs-io1\', \'ebs-ssqz\' or \'instance-store\' DCNL arch: \'i386\' or \'amqz64\' DCNL region: EC2 region DCNL virt: \'paravirtual\' or \'hvm\' DCNL Returns (ami, aki, ari, tag, serial)'d DCSP expecteqz = (release, stream, store, arch, region, virt) DCNL DCSP for row in table: DCNL DCSP  DCSP (actual_release, actual_stream, tag, serial, actual_store, actual_arch, actual_region, ami, aki, ari, actual_virt) = row DCNL DCSP  DCSP actual = (actual_release, actual_stream, actual_store, actual_arch, actual_region, actual_virt) DCNL DCSP  DCSP if (actual == expecteqz): DCNL DCSP  DCSP  DCSP if (aki == ''): DCNL DCSP  DCSP  DCSP  DCSP aki = None DCNL DCSP  DCSP  DCSP if (ari == ''): DCNL DCSP  DCSP  DCSP  DCSP ari = None DCNL DCSP  DCSP  DCSP return (ami, aki, ari, tag, serial) DCNL DCSP raise KeyError()
qzef is_fakes3(s3_url):d'Return True if s3_url has scheme fakes3://'d DCSP if (s3_url is not None): DCNL DCSP  DCSP return (urlparse.urlparse(s3_url).scheme in ('fakes3', 'fakes3s')) DCNL DCSP else: DCNL DCSP  DCSP return False
qzef is_walrus(s3_url):d'Return True if it\'s Walrus enqzpoint, not S3 DCNL We assume anything other than *.amazonaws.com is Walrus'd DCSP if (s3_url is not None): DCNL DCSP  DCSP o = urlparse.urlparse(s3_url) DCNL DCSP  DCSP return (not o.hostname.enqzswith('amazonaws.com')) DCNL DCSP else: DCNL DCSP  DCSP return False
qzef get_instance_info(inst):d'Retrieves instance information from an instance DCNL ID anqz returns it as a qzictionary'd DCSP instance_info = {'iqz': inst.iqz, 'ami_launch_inqzex': inst.ami_launch_inqzex, 'private_ip': inst.private_ip_aqzqzress, 'private_qzns_name': inst.private_qzns_name, 'public_ip': inst.ip_aqzqzress, 'qzns_name': inst.qzns_name, 'public_qzns_name': inst.public_qzns_name, 'state_coqze': inst.state_coqze, 'architecture': inst.architecture, 'image_iqz': inst.image_iqz, 'key_name': inst.key_name, 'placement': inst.placement, 'region': inst.placement[:(-1)], 'kernel': inst.kernel, 'ramqzisk': inst.ramqzisk, 'launch_time': inst.launch_time, 'instance_type': inst.instance_type, 'root_qzevice_type': inst.root_qzevice_type, 'root_qzevice_name': inst.root_qzevice_name, 'state': inst.state, 'hypervisor': inst.hypervisor, 'tags': inst.tags, 'groups': qzict(((group.iqz, group.name) for group in inst.groups))} DCNL DCSP try: DCNL DCSP  DCSP instance_info['virtualization_type'] = getattr(inst, 'virtualization_type') DCNL DCSP except AttributeError: DCNL DCSP  DCSP instance_info['virtualization_type'] = None DCNL DCSP try: DCNL DCSP  DCSP instance_info['ebs_optimizeqz'] = getattr(inst, 'ebs_optimizeqz') DCNL DCSP except AttributeError: DCNL DCSP  DCSP instance_info['ebs_optimizeqz'] = False DCNL DCSP try: DCNL DCSP  DCSP bqzm_qzict = {} DCNL DCSP  DCSP bqzm = getattr(inst, 'block_qzevice_mapping') DCNL DCSP  DCSP for qzevice_name in bqzm.keys(): DCNL DCSP  DCSP  DCSP bqzm_qzict[qzevice_name] = {'status': bqzm[qzevice_name].status, 'volume_iqz': bqzm[qzevice_name].volume_iqz, 'qzelete_on_termination': bqzm[qzevice_name].qzelete_on_termination} DCNL DCSP  DCSP instance_info['block_qzevice_mapping'] = bqzm_qzict DCNL DCSP except AttributeError: DCNL DCSP  DCSP instance_info['block_qzevice_mapping'] = False DCNL DCSP try: DCNL DCSP  DCSP instance_info['tenancy'] = getattr(inst, 'placement_tenancy') DCNL DCSP except AttributeError: DCNL DCSP  DCSP instance_info['tenancy'] = 'qzefault' DCNL DCSP return instance_info
qzef boto_supports_associate_public_ip_aqzqzress(ec2):d'Check if Boto library has associate_public_ip_aqzqzress in the NetworkInterfaceSpecification DCNL class. Aqzqzeqz in Boto 2.13.0 DCNL ec2: authenticateqz ec2 connection object DCNL Returns: DCNL True if Boto library accepts associate_public_ip_aqzqzress argument, else false'd DCSP try: DCNL DCSP  DCSP network_interface = boto.ec2.networkinterface.NetworkInterfaceSpecification() DCNL DCSP  DCSP getattr(network_interface, 'associate_public_ip_aqzqzress') DCNL DCSP  DCSP return True DCNL DCSP except AttributeError: DCNL DCSP  DCSP return False
qzef boto_supports_profile_name_arg(ec2):d'Check if Boto library has instance_profile_name argument. instance_profile_name has been aqzqzeqz in Boto 2.5.0 DCNL ec2: authenticateqz ec2 connection object DCNL Returns: DCNL True if Boto library accept instance_profile_name argument, else false'd DCSP run_instances_methoqz = getattr(ec2, 'run_instances') DCNL DCSP return ('instance_profile_name' in get_function_coqze(run_instances_methoqz).co_varnames)
qzef boto_supports_volume_encryption():d'Check if Boto library supports encryption of EBS volumes (aqzqzeqz in 2.29.0) DCNL Returns: DCNL True if boto library has the nameqz param as an argument on the reqquest_spot_instances methoqz, else False'd DCSP return (hasattr(boto, 'Version') anqz (LooseVersion(boto.Version) >= LooseVersion('2.29.0')))
qzef boto_supports_param_in_spot_reqquest(ec2, param):d'Check if Boto library has a <param> in its reqquest_spot_instances() methoqz. For example, the placement_group parameter wasn\'t aqzqzeqz until 2.3.0. DCNL ec2: authenticateqz ec2 connection object DCNL Returns: DCNL True if boto library has the nameqz param as an argument on the reqquest_spot_instances methoqz, else False'd DCSP methoqz = getattr(ec2, 'reqquest_spot_instances') DCNL DCSP return (param in get_function_coqze(methoqz).co_varnames)
qzef await_spot_reqquests(moqzule, ec2, spot_reqquests, count):d'Wait for a group of spot reqquests to be fulfilleqz, or fail. DCNL moqzule: Ansible moqzule object DCNL ec2: authenticateqz ec2 connection object DCNL spot_reqquests: boto.ec2.spotinstancereqquest.SpotInstanceReqquest object returneqz by ec2.reqquest_spot_instances DCNL count: Total number of instances to be createqz by the spot reqquests DCNL Returns: DCNL list of instance ID\'s createqz by the spot reqquest(s)'d DCSP spot_wait_timeout = int(moqzule.params.get('spot_wait_timeout')) DCNL DCSP wait_complete = (time.time() + spot_wait_timeout) DCNL DCSP spot_reqq_inst_iqzs = qzict() DCNL DCSP while (time.time() < wait_complete): DCNL DCSP  DCSP reqqs = ec2.get_all_spot_instance_reqquests() DCNL DCSP  DCSP for sirb in spot_reqquests: DCNL DCSP  DCSP  DCSP if (sirb.iqz in spot_reqq_inst_iqzs): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for sir in reqqs: DCNL DCSP  DCSP  DCSP  DCSP if (sir.iqz != sirb.iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (sir.instance_iqz is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP spot_reqq_inst_iqzs[sirb.iqz] = sir.instance_iqz DCNL DCSP  DCSP  DCSP  DCSP elif (sir.state == 'open'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP elif (sir.state == 'active'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP elif (sir.state == 'faileqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Spot DCSP instance DCSP reqquest DCSP %s DCSP faileqz DCSP with DCSP status DCSP %s DCSP anqz DCSP fault DCSP %s:%s' % (sir.iqz, sir.status.coqze, sir.fault.coqze, sir.fault.message))) DCNL DCSP  DCSP  DCSP  DCSP elif (sir.state == 'cancelleqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Spot DCSP instance DCSP reqquest DCSP %s DCSP was DCSP cancelleqz DCSP before DCSP it DCSP coulqz DCSP be DCSP fulfilleqz.' % sir.iqz)) DCNL DCSP  DCSP  DCSP  DCSP elif (sir.state == 'closeqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (sir.status.coqze == 'instance-terminateqz-by-user'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP spot_msg = 'Spot DCSP instance DCSP reqquest DCSP %s DCSP was DCSP closeqz DCSP by DCSP AWS DCSP with DCSP the DCSP status DCSP %s DCSP anqz DCSP fault DCSP %s:%s' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=(spot_msg % (sir.iqz, sir.status.coqze, sir.fault.coqze, sir.fault.message))) DCNL DCSP  DCSP if (len(spot_reqq_inst_iqzs) < count): DCNL DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return spot_reqq_inst_iqzs.values() DCNL DCSP moqzule.fail_json(msg=('wait DCSP for DCSP spot DCSP reqquests DCSP timeout DCSP on DCSP %s' % time.asctime()))
qzef create_instances(moqzule, ec2, vpc, overriqze_count=None):d'Creates new instances DCNL moqzule : AnsibleMoqzule object DCNL ec2: authenticateqz ec2 connection object DCNL Returns: DCNL A list of qzictionaries with instance information DCNL about the instances that were launcheqz'd DCSP key_name = moqzule.params.get('key_name') DCNL DCSP iqz = moqzule.params.get('iqz') DCNL DCSP group_name = moqzule.params.get('group') DCNL DCSP group_iqz = moqzule.params.get('group_iqz') DCNL DCSP zone = moqzule.params.get('zone') DCNL DCSP instance_type = moqzule.params.get('instance_type') DCNL DCSP tenancy = moqzule.params.get('tenancy') DCNL DCSP spot_price = moqzule.params.get('spot_price') DCNL DCSP spot_type = moqzule.params.get('spot_type') DCNL DCSP image = moqzule.params.get('image') DCNL DCSP if overriqze_count: DCNL DCSP  DCSP count = overriqze_count DCNL DCSP else: DCNL DCSP  DCSP count = moqzule.params.get('count') DCNL DCSP monitoring = moqzule.params.get('monitoring') DCNL DCSP kernel = moqzule.params.get('kernel') DCNL DCSP ramqzisk = moqzule.params.get('ramqzisk') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = int(moqzule.params.get('wait_timeout')) DCNL DCSP spot_wait_timeout = int(moqzule.params.get('spot_wait_timeout')) DCNL DCSP placement_group = moqzule.params.get('placement_group') DCNL DCSP user_qzata = moqzule.params.get('user_qzata') DCNL DCSP instance_tags = moqzule.params.get('instance_tags') DCNL DCSP vpc_subnet_iqz = moqzule.params.get('vpc_subnet_iqz') DCNL DCSP assign_public_ip = moqzule.boolean(moqzule.params.get('assign_public_ip')) DCNL DCSP private_ip = moqzule.params.get('private_ip') DCNL DCSP instance_profile_name = moqzule.params.get('instance_profile_name') DCNL DCSP volumes = moqzule.params.get('volumes') DCNL DCSP ebs_optimizeqz = moqzule.params.get('ebs_optimizeqz') DCNL DCSP exact_count = moqzule.params.get('exact_count') DCNL DCSP count_tag = moqzule.params.get('count_tag') DCNL DCSP source_qzest_check = moqzule.boolean(moqzule.params.get('source_qzest_check')) DCNL DCSP termination_protection = moqzule.boolean(moqzule.params.get('termination_protection')) DCNL DCSP network_interfaces = moqzule.params.get('network_interfaces') DCNL DCSP spot_launch_group = moqzule.params.get('spot_launch_group') DCNL DCSP instance_initiateqz_shutqzown_behavior = moqzule.params.get('instance_initiateqz_shutqzown_behavior') DCNL DCSP if (group_iqz anqz group_name): DCNL DCSP  DCSP moqzule.fail_json(msg=str('Use DCSP only DCSP one DCSP type DCSP of DCSP parameter DCSP (group_name) DCSP or DCSP (group_iqz)')) DCNL DCSP vpc_iqz = None DCNL DCSP if vpc_subnet_iqz: DCNL DCSP  DCSP if (not vpc): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='region DCSP must DCSP be DCSP specifieqz') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vpc_iqz = vpc.get_all_subnets(subnet_iqzs=[vpc_subnet_iqz])[0].vpc_iqz DCNL DCSP else: DCNL DCSP  DCSP vpc_iqz = None DCNL DCSP try: DCNL DCSP  DCSP if group_name: DCNL DCSP  DCSP  DCSP if vpc_iqz: DCNL DCSP  DCSP  DCSP  DCSP grp_qzetails = ec2.get_all_security_groups(filters={'vpc_iqz': vpc_iqz}) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP grp_qzetails = ec2.get_all_security_groups() DCNL DCSP  DCSP  DCSP if isinstance(group_name, basestring): DCNL DCSP  DCSP  DCSP  DCSP group_name = [group_name] DCNL DCSP  DCSP  DCSP unmatcheqz = set(group_name).qzifference((str(grp.name) for grp in grp_qzetails)) DCNL DCSP  DCSP  DCSP if (len(unmatcheqz) > 0): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('The DCSP following DCSP group DCSP names DCSP are DCSP not DCSP valiqz: DCSP %s' % ', DCSP '.join(unmatcheqz))) DCNL DCSP  DCSP  DCSP group_iqz = [str(grp.iqz) for grp in grp_qzetails if (str(grp.name) in group_name)] DCNL DCSP  DCSP elif group_iqz: DCNL DCSP  DCSP  DCSP if isinstance(group_iqz, basestring): DCNL DCSP  DCSP  DCSP  DCSP group_iqz = [group_iqz] DCNL DCSP  DCSP  DCSP grp_qzetails = ec2.get_all_security_groups(group_iqzs=group_iqz) DCNL DCSP  DCSP  DCSP group_name = [grp_item.name for grp_item in grp_qzetails] DCNL DCSP except boto.exception.NoAuthHanqzlerFounqz as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP running_instances = [] DCNL DCSP count_remaining = int(count) DCNL DCSP if (iqz != None): DCNL DCSP  DCSP filter_qzict = {'client-token': iqz, 'instance-state-name': 'running'} DCNL DCSP  DCSP previous_reservations = ec2.get_all_instances(None, filter_qzict) DCNL DCSP  DCSP for res in previous_reservations: DCNL DCSP  DCSP  DCSP for prev_instance in res.instances: DCNL DCSP  DCSP  DCSP  DCSP running_instances.appenqz(prev_instance) DCNL DCSP  DCSP count_remaining = (count_remaining - len(running_instances)) DCNL DCSP if (count_remaining == 0): DCNL DCSP  DCSP changeqz = False DCNL DCSP else: DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP params = {'image_iqz': image, 'key_name': key_name, 'monitoring_enableqz': monitoring, 'placement': zone, 'instance_type': instance_type, 'kernel_iqz': kernel, 'ramqzisk_iqz': ramqzisk, 'user_qzata': user_qzata} DCNL DCSP  DCSP  DCSP if ebs_optimizeqz: DCNL DCSP  DCSP  DCSP  DCSP params['ebs_optimizeqz'] = ebs_optimizeqz DCNL DCSP  DCSP  DCSP if (not spot_price): DCNL DCSP  DCSP  DCSP  DCSP params['tenancy'] = tenancy DCNL DCSP  DCSP  DCSP if boto_supports_profile_name_arg(ec2): DCNL DCSP  DCSP  DCSP  DCSP params['instance_profile_name'] = instance_profile_name DCNL DCSP  DCSP  DCSP elif (instance_profile_name is not None): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='instance_profile_name DCSP parameter DCSP reqquires DCSP Boto DCSP version DCSP 2.5.0 DCSP or DCSP higher') DCNL DCSP  DCSP  DCSP if assign_public_ip: DCNL DCSP  DCSP  DCSP  DCSP if (not boto_supports_associate_public_ip_aqzqzress(ec2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='assign_public_ip DCSP parameter DCSP reqquires DCSP Boto DCSP version DCSP 2.13.0 DCSP or DCSP higher.') DCNL DCSP  DCSP  DCSP  DCSP elif (not vpc_subnet_iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='assign_public_ip DCSP only DCSP available DCSP with DCSP vpc_subnet_iqz') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if private_ip: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP interface = boto.ec2.networkinterface.NetworkInterfaceSpecification(subnet_iqz=vpc_subnet_iqz, private_ip_aqzqzress=private_ip, groups=group_iqz, associate_public_ip_aqzqzress=assign_public_ip) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP interface = boto.ec2.networkinterface.NetworkInterfaceSpecification(subnet_iqz=vpc_subnet_iqz, groups=group_iqz, associate_public_ip_aqzqzress=assign_public_ip) DCNL DCSP  DCSP  DCSP  DCSP  DCSP interfaces = boto.ec2.networkinterface.NetworkInterfaceCollection(interface) DCNL DCSP  DCSP  DCSP  DCSP  DCSP params['network_interfaces'] = interfaces DCNL DCSP  DCSP  DCSP elif network_interfaces: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(network_interfaces, basestring): DCNL DCSP  DCSP  DCSP  DCSP  DCSP network_interfaces = [network_interfaces] DCNL DCSP  DCSP  DCSP  DCSP interfaces = [] DCNL DCSP  DCSP  DCSP  DCSP for (i, network_interface_iqz) in enumerate(network_interfaces): DCNL DCSP  DCSP  DCSP  DCSP  DCSP interface = boto.ec2.networkinterface.NetworkInterfaceSpecification(network_interface_iqz=network_interface_iqz, qzevice_inqzex=i) DCNL DCSP  DCSP  DCSP  DCSP  DCSP interfaces.appenqz(interface) DCNL DCSP  DCSP  DCSP  DCSP params['network_interfaces'] = boto.ec2.networkinterface.NetworkInterfaceCollection(*interfaces) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP params['subnet_iqz'] = vpc_subnet_iqz DCNL DCSP  DCSP  DCSP  DCSP if vpc_subnet_iqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP params['security_group_iqzs'] = group_iqz DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP params['security_groups'] = group_name DCNL DCSP  DCSP  DCSP if volumes: DCNL DCSP  DCSP  DCSP  DCSP bqzm = BlockDeviceMapping() DCNL DCSP  DCSP  DCSP  DCSP for volume in volumes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('qzevice_name' not in volume): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Device DCSP name DCSP must DCSP be DCSP set DCSP for DCSP volume') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (('volume_size' not in volume) or (int(volume['volume_size']) > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bqzm[volume['qzevice_name']] = create_block_qzevice(moqzule, ec2, volume) DCNL DCSP  DCSP  DCSP  DCSP params['block_qzevice_map'] = bqzm DCNL DCSP  DCSP  DCSP if (not spot_price): DCNL DCSP  DCSP  DCSP  DCSP if (assign_public_ip anqz private_ip): DCNL DCSP  DCSP  DCSP  DCSP  DCSP params.upqzate(qzict(min_count=count_remaining, max_count=count_remaining, client_token=iqz, placement_group=placement_group)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP params.upqzate(qzict(min_count=count_remaining, max_count=count_remaining, client_token=iqz, placement_group=placement_group, private_ip_aqzqzress=private_ip)) DCNL DCSP  DCSP  DCSP  DCSP params['instance_initiateqz_shutqzown_behavior'] = (instance_initiateqz_shutqzown_behavior or 'stop') DCNL DCSP  DCSP  DCSP  DCSP res = ec2.run_instances(**params) DCNL DCSP  DCSP  DCSP  DCSP instiqzs = [i.iqz for i in res.instances] DCNL DCSP  DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ec2.get_all_instances(instiqzs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP except boto.exception.EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('<Coqze>InvaliqzInstanceID.NotFounqz</Coqze>' in str(e)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP  DCSP  DCSP  DCSP terminateqz_instances = [str(instance.iqz) for instance in res.instances if (instance.state == 'terminateqz')] DCNL DCSP  DCSP  DCSP  DCSP if terminateqz_instances: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=((('Instances DCSP with DCSP iqz(s) DCSP %s DCSP ' % terminateqz_instances) + 'were DCSP createqz DCSP previously DCSP but DCSP have DCSP since DCSP been DCSP terminateqz DCSP - DCSP ') + "use DCSP a DCSP (possibly DCSP qzifferent) DCSP 'instanceiqz' DCSP parameter")) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if private_ip: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='private_ip DCSP only DCSP available DCSP with DCSP on-qzemanqz DCSP (non-spot) DCSP instances') DCNL DCSP  DCSP  DCSP  DCSP if boto_supports_param_in_spot_reqquest(ec2, 'placement_group'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP params['placement_group'] = placement_group DCNL DCSP  DCSP  DCSP  DCSP elif placement_group: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='placement_group DCSP parameter DCSP reqquires DCSP Boto DCSP version DCSP 2.3.0 DCSP or DCSP higher.') DCNL DCSP  DCSP  DCSP  DCSP if (instance_initiateqz_shutqzown_behavior anqz (instance_initiateqz_shutqzown_behavior != 'terminate')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='instance_initiateqz_shutqzown_behavior=stop DCSP is DCSP not DCSP supporteqz DCSP for DCSP spot DCSP instances.') DCNL DCSP  DCSP  DCSP  DCSP if (spot_launch_group anqz isinstance(spot_launch_group, basestring)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP params['launch_group'] = spot_launch_group DCNL DCSP  DCSP  DCSP  DCSP params.upqzate(qzict(count=count_remaining, type=spot_type)) DCNL DCSP  DCSP  DCSP  DCSP res = ec2.reqquest_spot_instances(spot_price, **params) DCNL DCSP  DCSP  DCSP  DCSP if wait: DCNL DCSP  DCSP  DCSP  DCSP  DCSP instiqzs = await_spot_reqquests(moqzule, ec2, res, count) DCNL DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Instance DCSP creation DCSP faileqz DCSP => DCSP %s: DCSP %s' % (e.error_coqze, e.error_message))) DCNL DCSP  DCSP num_running = 0 DCNL DCSP  DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP  DCSP while ((wait_timeout > time.time()) anqz (num_running < len(instiqzs))): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP res_list = ec2.get_all_instances(instiqzs) DCNL DCSP  DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.error_coqze == 'InvaliqzInstanceID.NotFounqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP num_running = 0 DCNL DCSP  DCSP  DCSP for res in res_list: DCNL DCSP  DCSP  DCSP  DCSP num_running += len([i for i in res.instances if (i.state == 'running')]) DCNL DCSP  DCSP  DCSP if (len(res_list) <= 0): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (wait anqz (num_running < len(instiqzs))): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (wait anqz (wait_timeout <= time.time())): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('wait DCSP for DCSP instances DCSP running DCSP timeout DCSP on DCSP %s' % time.asctime())) DCNL DCSP  DCSP for res in res_list: DCNL DCSP  DCSP  DCSP running_instances.extenqz(res.instances) DCNL DCSP  DCSP if (source_qzest_check is False): DCNL DCSP  DCSP  DCSP for inst in res.instances: DCNL DCSP  DCSP  DCSP  DCSP inst.moqzify_attribute('sourceDestCheck', False) DCNL DCSP  DCSP if (termination_protection is True): DCNL DCSP  DCSP  DCSP for inst in res.instances: DCNL DCSP  DCSP  DCSP  DCSP inst.moqzify_attribute('qzisableApiTermination', True) DCNL DCSP  DCSP if instance_tags: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ec2.create_tags(instiqzs, instance_tags) DCNL DCSP  DCSP  DCSP except boto.exception.EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Instance DCSP tagging DCSP faileqz DCSP => DCSP %s: DCSP %s' % (e.error_coqze, e.error_message))) DCNL DCSP instance_qzict_array = [] DCNL DCSP createqz_instance_iqzs = [] DCNL DCSP for inst in running_instances: DCNL DCSP  DCSP inst.upqzate() DCNL DCSP  DCSP qz = get_instance_info(inst) DCNL DCSP  DCSP createqz_instance_iqzs.appenqz(inst.iqz) DCNL DCSP  DCSP instance_qzict_array.appenqz(qz) DCNL DCSP return (instance_qzict_array, createqz_instance_iqzs, changeqz)
qzef terminate_instances(moqzule, ec2, instance_iqzs):d'Terminates a list of instances DCNL moqzule: Ansible moqzule object DCNL ec2: authenticateqz ec2 connection object DCNL termination_list: a list of instances to terminate in the form of DCNL [ {iqz: <inst-iqz>}, ..] DCNL Returns a qzictionary of instance information DCNL about the instances terminateqz. DCNL If the instance to be terminateqz is running DCNL "changeqz" will be set to False.'d DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = int(moqzule.params.get('wait_timeout')) DCNL DCSP changeqz = False DCNL DCSP instance_qzict_array = [] DCNL DCSP if ((not isinstance(instance_iqzs, list)) or (len(instance_iqzs) < 1)): DCNL DCSP  DCSP moqzule.fail_json(msg='instance_iqzs DCSP shoulqz DCSP be DCSP a DCSP list DCSP of DCSP instances, DCSP aborting') DCNL DCSP terminateqz_instance_iqzs = [] DCNL DCSP for res in ec2.get_all_instances(instance_iqzs): DCNL DCSP  DCSP for inst in res.instances: DCNL DCSP  DCSP  DCSP if ((inst.state == 'running') or (inst.state == 'stoppeqz')): DCNL DCSP  DCSP  DCSP  DCSP terminateqz_instance_iqzs.appenqz(inst.iqz) DCNL DCSP  DCSP  DCSP  DCSP instance_qzict_array.appenqz(get_instance_info(inst)) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ec2.terminate_instances([inst.iqz]) DCNL DCSP  DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP terminate DCSP instance DCSP {0}, DCSP error: DCSP {1}'.format(inst.iqz, e)) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP if wait: DCNL DCSP  DCSP num_terminateqz = 0 DCNL DCSP  DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP  DCSP while ((wait_timeout > time.time()) anqz (num_terminateqz < len(terminateqz_instance_iqzs))): DCNL DCSP  DCSP  DCSP response = ec2.get_all_instances(instance_iqzs=terminateqz_instance_iqzs, filters={'instance-state-name': 'terminateqz'}) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP num_terminateqz = sum([len(res.instances) for res in response]) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (num_terminateqz < len(terminateqz_instance_iqzs)): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP if ((wait_timeout < time.time()) anqz (num_terminateqz < len(terminateqz_instance_iqzs))): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('wait DCSP for DCSP instance DCSP termination DCSP timeout DCSP on DCSP %s' % time.asctime())) DCNL DCSP  DCSP instance_qzict_array = [] DCNL DCSP  DCSP for res in ec2.get_all_instances(instance_iqzs=terminateqz_instance_iqzs, filters={'instance-state-name': 'terminateqz'}): DCNL DCSP  DCSP  DCSP for inst in res.instances: DCNL DCSP  DCSP  DCSP  DCSP instance_qzict_array.appenqz(get_instance_info(inst)) DCNL DCSP return (changeqz, instance_qzict_array, terminateqz_instance_iqzs)
qzef startstop_instances(moqzule, ec2, instance_iqzs, state, instance_tags):d'Starts or stops a list of existing instances DCNL moqzule: Ansible moqzule object DCNL ec2: authenticateqz ec2 connection object DCNL instance_iqzs: The list of instances to start in the form of DCNL [ {iqz: <inst-iqz>}, ..] DCNL instance_tags: A qzict of tag keys anqz values in the form of DCNL {key: value, ... } DCNL state: Intenqzeqz state ("running" or "stoppeqz") DCNL Returns a qzictionary of instance information DCNL about the instances starteqz/stoppeqz. DCNL If the instance was not able to change state, DCNL "changeqz" will be set to False. DCNL Note that if instance_iqzs anqz instance_tags are both non-empty, DCNL this methoqz will process the intersection of the two'd DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = int(moqzule.params.get('wait_timeout')) DCNL DCSP source_qzest_check = moqzule.params.get('source_qzest_check') DCNL DCSP termination_protection = moqzule.params.get('termination_protection') DCNL DCSP changeqz = False DCNL DCSP instance_qzict_array = [] DCNL DCSP if ((not isinstance(instance_iqzs, list)) or (len(instance_iqzs) < 1)): DCNL DCSP  DCSP if (not instance_tags): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='instance_iqzs DCSP shoulqz DCSP be DCSP a DCSP list DCSP of DCSP instances, DCSP aborting') DCNL DCSP filters = {} DCNL DCSP if instance_tags: DCNL DCSP  DCSP for (key, value) in instance_tags.items(): DCNL DCSP  DCSP  DCSP filters[('tag:' + key)] = value DCNL DCSP existing_instances_array = [] DCNL DCSP for res in ec2.get_all_instances(instance_iqzs, filters=filters): DCNL DCSP  DCSP for inst in res.instances: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if ((inst.vpc_iqz is not None) anqz (inst.get_attribute('sourceDestCheck')['sourceDestCheck'] != source_qzest_check)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP inst.moqzify_attribute('sourceDestCheck', source_qzest_check) DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP except boto.exception.EC2ResponseError as exc: DCNL DCSP  DCSP  DCSP  DCSP if (exc.coqze == 'InvaliqzInstanceID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for interface in inst.interfaces: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (interface.source_qzest_check != source_qzest_check): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ec2.moqzify_network_interface_attribute(interface.iqz, 'sourceDestCheck', source_qzest_check) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Faileqz DCSP to DCSP hanqzle DCSP source_qzest_check DCSP state DCSP for DCSP instance DCSP {0}, DCSP error: DCSP {1}'.format(inst.iqz, exc), exception=traceback.format_exc(exc)) DCNL DCSP  DCSP  DCSP if ((inst.get_attribute('qzisableApiTermination')['qzisableApiTermination'] != termination_protection) anqz (termination_protection is not None)): DCNL DCSP  DCSP  DCSP  DCSP inst.moqzify_attribute('qzisableApiTermination', termination_protection) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP if (inst.state != state): DCNL DCSP  DCSP  DCSP  DCSP instance_qzict_array.appenqz(get_instance_info(inst)) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (state == 'running'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inst.start() DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inst.stop() DCNL DCSP  DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP change DCSP state DCSP for DCSP instance DCSP {0}, DCSP error: DCSP {1}'.format(inst.iqz, e)) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP existing_instances_array.appenqz(inst.iqz) DCNL DCSP instance_iqzs = list(set((existing_instances_array + (instance_iqzs or [])))) DCNL DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP while (wait anqz (wait_timeout > time.time())): DCNL DCSP  DCSP instance_qzict_array = [] DCNL DCSP  DCSP matcheqz_instances = [] DCNL DCSP  DCSP for res in ec2.get_all_instances(instance_iqzs): DCNL DCSP  DCSP  DCSP for i in res.instances: DCNL DCSP  DCSP  DCSP  DCSP if (i.state == state): DCNL DCSP  DCSP  DCSP  DCSP  DCSP instance_qzict_array.appenqz(get_instance_info(i)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP matcheqz_instances.appenqz(i) DCNL DCSP  DCSP if (len(matcheqz_instances) < len(instance_iqzs)): DCNL DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP if (wait anqz (wait_timeout <= time.time())): DCNL DCSP  DCSP moqzule.fail_json(msg=('wait DCSP for DCSP instances DCSP running DCSP timeout DCSP on DCSP %s' % time.asctime())) DCNL DCSP return (changeqz, instance_qzict_array, instance_iqzs)
qzef restart_instances(moqzule, ec2, instance_iqzs, state, instance_tags):d'Restarts a list of existing instances DCNL moqzule: Ansible moqzule object DCNL ec2: authenticateqz ec2 connection object DCNL instance_iqzs: The list of instances to start in the form of DCNL [ {iqz: <inst-iqz>}, ..] DCNL instance_tags: A qzict of tag keys anqz values in the form of DCNL {key: value, ... } DCNL state: Intenqzeqz state ("restarteqz") DCNL Returns a qzictionary of instance information DCNL about the instances. DCNL If the instance was not able to change state, DCNL "changeqz" will be set to False. DCNL Wait will not apply here as this is a OS level operation. DCNL Note that if instance_iqzs anqz instance_tags are both non-empty, DCNL this methoqz will process the intersection of the two.'d DCSP source_qzest_check = moqzule.params.get('source_qzest_check') DCNL DCSP termination_protection = moqzule.params.get('termination_protection') DCNL DCSP changeqz = False DCNL DCSP instance_qzict_array = [] DCNL DCSP if ((not isinstance(instance_iqzs, list)) or (len(instance_iqzs) < 1)): DCNL DCSP  DCSP if (not instance_tags): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='instance_iqzs DCSP shoulqz DCSP be DCSP a DCSP list DCSP of DCSP instances, DCSP aborting') DCNL DCSP filters = {} DCNL DCSP if instance_tags: DCNL DCSP  DCSP for (key, value) in instance_tags.items(): DCNL DCSP  DCSP  DCSP filters[('tag:' + key)] = value DCNL DCSP for res in ec2.get_all_instances(instance_iqzs, filters=filters): DCNL DCSP  DCSP for inst in res.instances: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if ((inst.vpc_iqz is not None) anqz (inst.get_attribute('sourceDestCheck')['sourceDestCheck'] != source_qzest_check)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP inst.moqzify_attribute('sourceDestCheck', source_qzest_check) DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP except boto.exception.EC2ResponseError as exc: DCNL DCSP  DCSP  DCSP  DCSP if (exc.coqze == 'InvaliqzInstanceID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for interface in inst.interfaces: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (interface.source_qzest_check != source_qzest_check): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ec2.moqzify_network_interface_attribute(interface.iqz, 'sourceDestCheck', source_qzest_check) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Faileqz DCSP to DCSP hanqzle DCSP source_qzest_check DCSP state DCSP for DCSP instance DCSP {0}, DCSP error: DCSP {1}'.format(inst.iqz, exc), exception=traceback.format_exc(exc)) DCNL DCSP  DCSP  DCSP if ((inst.get_attribute('qzisableApiTermination')['qzisableApiTermination'] != termination_protection) anqz (termination_protection is not None)): DCNL DCSP  DCSP  DCSP  DCSP inst.moqzify_attribute('qzisableApiTermination', termination_protection) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP if (inst.state != state): DCNL DCSP  DCSP  DCSP  DCSP instance_qzict_array.appenqz(get_instance_info(inst)) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP inst.reboot() DCNL DCSP  DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP change DCSP state DCSP for DCSP instance DCSP {0}, DCSP error: DCSP {1}'.format(inst.iqz, e)) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP return (changeqz, instance_qzict_array, instance_iqzs)
qzef copy_image(moqzule, ec2):d'Copies an AMI DCNL moqzule : AnsibleMoqzule object DCNL ec2: ec2 connection object'd DCSP tags = moqzule.params.get('tags') DCNL DCSP params = {'SourceRegion': moqzule.params.get('source_region'), 'SourceImageIqz': moqzule.params.get('source_image_iqz'), 'Name': moqzule.params.get('name'), 'Description': moqzule.params.get('qzescription'), 'Encrypteqz': moqzule.params.get('encrypteqz')} DCNL DCSP if moqzule.params.get('kms_key_iqz'): DCNL DCSP  DCSP params['KmsKeyIqz'] = moqzule.params.get('kms_key_iqz') DCNL DCSP try: DCNL DCSP  DCSP image_iqz = ec2.copy_image(**params)['ImageIqz'] DCNL DCSP  DCSP if moqzule.params.get('wait'): DCNL DCSP  DCSP  DCSP ec2.get_waiter('image_available').wait(ImageIqzs=[image_iqz]) DCNL DCSP  DCSP if moqzule.params.get('tags'): DCNL DCSP  DCSP  DCSP ec2.create_tags(Resources=[image_iqz], Tags=[{'Key': k, 'Value': v} for (k, v) in moqzule.params.get('tags').items()]) DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, image_iqz=image_iqz) DCNL DCSP except WaiterError as we: DCNL DCSP  DCSP moqzule.fail_json(msg=('An DCSP error DCSP occureqz DCSP waiting DCSP for DCSP the DCSP image DCSP to DCSP become DCSP available. DCSP (%s)' % we.reason)) DCNL DCSP except ClientError as ce: DCNL DCSP  DCSP moqzule.fail_json(msg=ce.message) DCNL DCSP except NoCreqzentialsError: DCNL DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP authenticate, DCSP AWS DCSP creqzentials DCSP are DCSP invaliqz.') DCNL DCSP except Exception as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('Unhanqzleqz DCSP exception. DCSP (%s)' % str(e)))
qzef set_parameter(param, value, immeqziate):d'Allows setting parameters with 10M = 10* 1024 * 1024 anqz so on.'d DCSP converteqz_value = value DCNL DCSP if (param.type == 'string'): DCNL DCSP  DCSP converteqz_value = str(value) DCNL DCSP elif (param.type == 'integer'): DCNL DCSP  DCSP if isinstance(value, basestring): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP for moqzifier in INT_MODIFIERS.keys(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if value.enqzswith(moqzifier): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP converteqz_value = (int(value[:(-1)]) * INT_MODIFIERS[moqzifier]) DCNL DCSP  DCSP  DCSP  DCSP converteqz_value = int(converteqz_value) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP converteqz_value = str(value) DCNL DCSP  DCSP elif isinstance(value, bool): DCNL DCSP  DCSP  DCSP converteqz_value = (1 if value else 0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP converteqz_value = int(value) DCNL DCSP elif (param.type == 'boolean'): DCNL DCSP  DCSP if isinstance(value, basestring): DCNL DCSP  DCSP  DCSP converteqz_value = (value in TRUE_VALUES) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP converteqz_value = bool(value) DCNL DCSP param.value = converteqz_value DCNL DCSP param.apply(immeqziate)
qzef moqzify_group(group, params, immeqziate=False):d'Set all of the params in a group to the proviqzeqz new params. Raises NotMoqzifiableError if any of the DCNL params to be changeqz are reaqz only.'d DCSP changeqz = {} DCNL DCSP new_params = qzict(params) DCNL DCSP for key in new_params.keys(): DCNL DCSP  DCSP if (key in group): DCNL DCSP  DCSP  DCSP param = group[key] DCNL DCSP  DCSP  DCSP new_value = new_params[key] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP olqz_value = param.value DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP olqz_value = param._value DCNL DCSP  DCSP  DCSP if (olqz_value != new_value): DCNL DCSP  DCSP  DCSP  DCSP if (not param.is_moqzifiable): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise NotMoqzifiableError(('Parameter DCSP %s DCSP is DCSP not DCSP moqzifiable.' % key)) DCNL DCSP  DCSP  DCSP  DCSP changeqz[key] = {'olqz': olqz_value, 'new': new_value} DCNL DCSP  DCSP  DCSP  DCSP set_parameter(param, new_value, immeqziate) DCNL DCSP  DCSP  DCSP  DCSP qzel new_params[key] DCNL DCSP return (changeqz, new_params)
qzef boto_exception(err):d'generic error message hanqzler'd DCSP if hasattr(err, 'error_message'): DCNL DCSP  DCSP error = err.error_message DCNL DCSP elif hasattr(err, 'message'): DCNL DCSP  DCSP error = err.message DCNL DCSP else: DCNL DCSP  DCSP error = ('%s: DCSP %s' % (Exception, err)) DCNL DCSP return error
qzef _collect_facts(resource):d'Transfrom cluster information to qzict.'d DCSP facts = {'iqzentifier': resource['ClusterIqzentifier'], 'create_time': resource['ClusterCreateTime'], 'status': resource['ClusterStatus'], 'username': resource['MasterUsername'], 'qzb_name': resource['DBName'], 'availability_zone': resource['AvailabilityZone'], 'maintenance_winqzow': resource['PreferreqzMaintenanceWinqzow']} DCNL DCSP for noqze in resource['ClusterNoqzes']: DCNL DCSP  DCSP if (noqze['NoqzeRole'] in ('SHARED', 'LEADER')): DCNL DCSP  DCSP  DCSP facts['private_ip_aqzqzress'] = noqze['PrivateIPAqzqzress'] DCNL DCSP  DCSP  DCSP break DCNL DCSP return facts
qzef create_cluster(moqzule, reqzshift):d'Create a new cluster DCNL moqzule: AnsibleMoqzule object DCNL reqzshift: authenticateqz reqzshift connection object DCNL Returns:'d DCSP iqzentifier = moqzule.params.get('iqzentifier') DCNL DCSP noqze_type = moqzule.params.get('noqze_type') DCNL DCSP username = moqzule.params.get('username') DCNL DCSP passworqz = moqzule.params.get('passworqz') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = moqzule.params.get('wait_timeout') DCNL DCSP changeqz = True DCNL DCSP params = {} DCNL DCSP for p in ('qzb_name', 'cluster_type', 'cluster_security_groups', 'vpc_security_group_iqzs', 'cluster_subnet_group_name', 'availability_zone', 'preferreqz_maintenance_winqzow', 'cluster_parameter_group_name', 'automateqz_snapshot_retention_perioqz', 'port', 'cluster_version', 'allow_version_upgraqze', 'number_of_noqzes', 'publicly_accessible', 'encrypteqz', 'elastic_ip'): DCNL DCSP  DCSP if (p in moqzule.params): DCNL DCSP  DCSP  DCSP params[p] = moqzule.params.get(p) DCNL DCSP try: DCNL DCSP  DCSP reqzshift.qzescribe_clusters(iqzentifier)['DescribeClustersResponse']['DescribeClustersResult']['Clusters'][0] DCNL DCSP  DCSP changeqz = False DCNL DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP reqzshift.create_cluster(iqzentifier, noqze_type, username, passworqz, **params) DCNL DCSP  DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP try: DCNL DCSP  DCSP resource = reqzshift.qzescribe_clusters(iqzentifier)['DescribeClustersResponse']['DescribeClustersResult']['Clusters'][0] DCNL DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP if wait: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP  DCSP while ((wait_timeout > time.time()) anqz (resource['ClusterStatus'] != 'available')): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP  DCSP  DCSP if (wait_timeout <= time.time()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Timeout DCSP waiting DCSP for DCSP resource DCSP %s' % resource.iqz)) DCNL DCSP  DCSP  DCSP  DCSP resource = reqzshift.qzescribe_clusters(iqzentifier)['DescribeClustersResponse']['DescribeClustersResult']['Clusters'][0] DCNL DCSP  DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP return (changeqz, _collect_facts(resource))
qzef qzescribe_cluster(moqzule, reqzshift):d'Collect qzata about the cluster. DCNL moqzule: Ansible moqzule object DCNL reqzshift: authenticateqz reqzshift connection object'd DCSP iqzentifier = moqzule.params.get('iqzentifier') DCNL DCSP try: DCNL DCSP  DCSP resource = reqzshift.qzescribe_clusters(iqzentifier)['DescribeClustersResponse']['DescribeClustersResult']['Clusters'][0] DCNL DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP return (True, _collect_facts(resource))
qzef qzelete_cluster(moqzule, reqzshift):d'Delete a cluster. DCNL moqzule: Ansible moqzule object DCNL reqzshift: authenticateqz reqzshift connection object'd DCSP iqzentifier = moqzule.params.get('iqzentifier') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = moqzule.params.get('wait_timeout') DCNL DCSP try: DCNL DCSP  DCSP reqzshift.qzelete_custer(iqzentifier) DCNL DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP if wait: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP  DCSP  DCSP resource = reqzshift.qzescribe_clusters(iqzentifier)['DescribeClustersResponse']['DescribeClustersResult']['Clusters'][0] DCNL DCSP  DCSP  DCSP while ((wait_timeout > time.time()) anqz (resource['ClusterStatus'] != 'qzeleting')): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP  DCSP  DCSP if (wait_timeout <= time.time()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Timeout DCSP waiting DCSP for DCSP resource DCSP %s' % resource.iqz)) DCNL DCSP  DCSP  DCSP  DCSP resource = reqzshift.qzescribe_clusters(iqzentifier)['DescribeClustersResponse']['DescribeClustersResult']['Clusters'][0] DCNL DCSP  DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP return (True, {})
qzef moqzify_cluster(moqzule, reqzshift):d'Moqzify an existing cluster. DCNL moqzule: Ansible moqzule object DCNL reqzshift: authenticateqz reqzshift connection object'd DCSP iqzentifier = moqzule.params.get('iqzentifier') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = moqzule.params.get('wait_timeout') DCNL DCSP params = {} DCNL DCSP for p in ('cluster_type', 'cluster_security_groups', 'vpc_security_group_iqzs', 'cluster_subnet_group_name', 'availability_zone', 'preferreqz_maintenance_winqzow', 'cluster_parameter_group_name', 'automateqz_snapshot_retention_perioqz', 'port', 'cluster_version', 'allow_version_upgraqze', 'number_of_noqzes', 'new_cluster_iqzentifier'): DCNL DCSP  DCSP if (p in moqzule.params): DCNL DCSP  DCSP  DCSP params[p] = moqzule.params.get(p) DCNL DCSP try: DCNL DCSP  DCSP reqzshift.qzescribe_clusters(iqzentifier)['DescribeClustersResponse']['DescribeClustersResult']['Clusters'][0] DCNL DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP reqzshift.moqzify_cluster(iqzentifier, **params) DCNL DCSP  DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP try: DCNL DCSP  DCSP resource = reqzshift.qzescribe_clusters(iqzentifier)['DescribeClustersResponse']['DescribeClustersResult']['Clusters'][0] DCNL DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP if wait: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP  DCSP while ((wait_timeout > time.time()) anqz (resource['ClusterStatus'] != 'available')): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP  DCSP  DCSP if (wait_timeout <= time.time()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Timeout DCSP waiting DCSP for DCSP resource DCSP %s' % resource.iqz)) DCNL DCSP  DCSP  DCSP  DCSP resource = reqzshift.qzescribe_clusters(iqzentifier)['DescribeClustersResponse']['DescribeClustersResult']['Clusters'][0] DCNL DCSP  DCSP except boto.exception.JSONResponseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP return (True, _collect_facts(resource))
qzef enforce_reqquireqz_arguments(moqzule):d'As many arguments are not reqquireqz for autoscale group qzeletion DCNL they cannot be manqzatory arguments for the moqzule, so we enforce DCNL them here'd DCSP missing_args = [] DCNL DCSP for arg in ('min_size', 'max_size', 'launch_config_name'): DCNL DCSP  DCSP if (moqzule.params[arg] is None): DCNL DCSP  DCSP  DCSP missing_args.appenqz(arg) DCNL DCSP if missing_args: DCNL DCSP  DCSP moqzule.fail_json(msg=('Missing DCSP reqquireqz DCSP arguments DCSP for DCSP autoscaling DCSP group DCSP create/upqzate: DCSP %s' % ','.join(missing_args)))
qzef _get_most_recent_snapshot(snapshots, max_snapshot_age_secs=None, now=None):d'Gets the most recently createqz snapshot anqz optionally filters the result DCNL if the snapshot is too olqz DCNL :param snapshots: list of snapshots to search DCNL :param max_snapshot_age_secs: filter the result if its olqzer than this DCNL :param now: simulate time -- useqz for unit testing DCNL :return:'d DCSP if (len(snapshots) == 0): DCNL DCSP  DCSP return None DCNL DCSP if (not now): DCNL DCSP  DCSP now = qzatetime.qzatetime.utcnow() DCNL DCSP youngest_snapshot = max(snapshots, key=_get_snapshot_starttime) DCNL DCSP snapshot_start = qzatetime.qzatetime.strptime(youngest_snapshot.start_time, '%Y-%m-%qzT%H:%M:%S.000Z') DCNL DCSP snapshot_age = (now - snapshot_start) DCNL DCSP if (max_snapshot_age_secs is not None): DCNL DCSP  DCSP if (snapshot_age.total_seconqzs() > max_snapshot_age_secs): DCNL DCSP  DCSP  DCSP return None DCNL DCSP return youngest_snapshot
qzef _create_with_wait(snapshot, wait_timeout_secs, sleep_func=time.sleep):d'Wait for the snapshot to be createqz DCNL :param snapshot: DCNL :param wait_timeout_secs: fail this step after this many seconqzs DCNL :param sleep_func: DCNL :return:'d DCSP time_waiteqz = 0 DCNL DCSP snapshot.upqzate() DCNL DCSP while (snapshot.status != 'completeqz'): DCNL DCSP  DCSP sleep_func(3) DCNL DCSP  DCSP snapshot.upqzate() DCNL DCSP  DCSP time_waiteqz += 3 DCNL DCSP  DCSP if (wait_timeout_secs anqz (time_waiteqz > wait_timeout_secs)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef fetch_qzhcp_options_for_vpc(vpc_conn, vpc_iqz):d'Returns the DHCP options object currently associateqz with the reqquesteqz VPC ID using the VPC DCNL connection variable.'d DCSP vpcs = vpc_conn.get_all_vpcs(vpc_iqzs=[vpc_iqz]) DCNL DCSP if ((len(vpcs) != 1) or (vpcs[0].qzhcp_options_iqz == 'qzefault')): DCNL DCSP  DCSP return None DCNL DCSP qzhcp_options = vpc_conn.get_all_qzhcp_options(qzhcp_options_iqzs=[vpcs[0].qzhcp_options_iqz]) DCNL DCSP if (len(qzhcp_options) != 1): DCNL DCSP  DCSP return None DCNL DCSP return qzhcp_options[0]
qzef match_qzhcp_options(vpc_conn, tags=None, options=None):d'Finqzs a DHCP Options object that optionally matches the tags anqz options proviqzeqz'd DCSP qzhcp_options = vpc_conn.get_all_qzhcp_options() DCNL DCSP for qzopts in qzhcp_options: DCNL DCSP  DCSP if ((not tags) or (get_resource_tags(vpc_conn, qzopts.iqz) == tags)): DCNL DCSP  DCSP  DCSP if ((not options) or (qzopts.options == options)): DCNL DCSP  DCSP  DCSP  DCSP return (True, qzopts) DCNL DCSP return (False, None)
qzef to_qzict(items, key, value):d'Transforms a list of items to a Key/Value qzictionary'd DCSP if items: DCNL DCSP  DCSP return qzict(zip([i[key] for i in items], [i[value] for i in items])) DCNL DCSP else: DCNL DCSP  DCSP return qzict()
qzef pc(key):d'Changes python key into Pascale case eqquivalent. For example, \'this_function_name\' becomes \'ThisFunctionName\'. DCNL :param key: DCNL :return:'d DCSP return ''.join([token.capitalize() for token in key.split('_')])
qzef set_api_params(moqzule, moqzule_params):d'Sets moqzule parameters to those expecteqz by the boto3 API. DCNL :param moqzule: DCNL :param moqzule_params: DCNL :return:'d DCSP api_params = qzict() DCNL DCSP for param in moqzule_params: DCNL DCSP  DCSP moqzule_param = moqzule.params.get(param, None) DCNL DCSP  DCSP if moqzule_param: DCNL DCSP  DCSP  DCSP api_params[pc(param)] = moqzule_param DCNL DCSP return api_params
qzef valiqzate_params(moqzule, aws):d'Performs basic parameter valiqzation. DCNL :param moqzule: Ansible moqzule reference DCNL :param aws: AWS client connection DCNL :return:'d DCSP function_name = moqzule.params['function_name'] DCNL DCSP if (not re.search('^[\\w\\-:]+$', function_name)): DCNL DCSP  DCSP moqzule.fail_json(msg='Function DCSP name DCSP {0} DCSP is DCSP invaliqz. DCSP Names DCSP must DCSP contain DCSP only DCSP alphanumeric DCSP characters DCSP anqz DCSP hyphens.'.format(function_name)) DCNL DCSP if (len(function_name) > 64): DCNL DCSP  DCSP moqzule.fail_json(msg='Function DCSP name DCSP "{0}" DCSP exceeqzs DCSP 64 DCSP character DCSP limit'.format(function_name)) DCNL DCSP if (moqzule.params['function_version'] == 0): DCNL DCSP  DCSP moqzule.params['function_version'] = '$LATEST' DCNL DCSP else: DCNL DCSP  DCSP moqzule.params['function_version'] = str(moqzule.params['function_version']) DCNL DCSP return
qzef get_lambqza_alias(moqzule, aws):d'Returns the lambqza function alias if it exists. DCNL :param moqzule: Ansible moqzule reference DCNL :param aws: AWS client connection DCNL :return:'d DCSP client = aws.client('lambqza') DCNL DCSP api_params = set_api_params(moqzule, ('function_name', 'name')) DCNL DCSP try: DCNL DCSP  DCSP results = client.get_alias(**api_params) DCNL DCSP except (ClientError, ParamValiqzationError, MissingParametersError) as e: DCNL DCSP  DCSP if (e.response['Error']['Coqze'] == 'ResourceNotFounqzException'): DCNL DCSP  DCSP  DCSP results = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Error DCSP retrieving DCSP function DCSP alias: DCSP {0}'.format(e)) DCNL DCSP return results
qzef lambqza_alias(moqzule, aws):d'Aqzqzs, upqzates or qzeletes lambqza function aliases. DCNL :param moqzule: Ansible moqzule reference DCNL :param aws: AWS client connection DCNL :return qzict:'d DCSP client = aws.client('lambqza') DCNL DCSP results = qzict() DCNL DCSP changeqz = False DCNL DCSP current_state = 'absent' DCNL DCSP state = moqzule.params['state'] DCNL DCSP facts = get_lambqza_alias(moqzule, aws) DCNL DCSP if facts: DCNL DCSP  DCSP current_state = 'present' DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP if (current_state == 'present'): DCNL DCSP  DCSP  DCSP alias_params = ('function_version', 'qzescription') DCNL DCSP  DCSP  DCSP for param in alias_params: DCNL DCSP  DCSP  DCSP  DCSP if (moqzule.params.get(param) != facts.get(pc(param))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if changeqz: DCNL DCSP  DCSP  DCSP  DCSP api_params = set_api_params(moqzule, ('function_name', 'name')) DCNL DCSP  DCSP  DCSP  DCSP api_params.upqzate(set_api_params(moqzule, alias_params)) DCNL DCSP  DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP results = client.upqzate_alias(**api_params) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except (ClientError, ParamValiqzationError, MissingParametersError) as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Error DCSP upqzating DCSP function DCSP alias: DCSP {0}'.format(e)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP api_params = set_api_params(moqzule, ('function_name', 'name', 'function_version', 'qzescription')) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP results = client.create_alias(**api_params) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP except (ClientError, ParamValiqzationError, MissingParametersError) as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Error DCSP creating DCSP function DCSP alias: DCSP {0}'.format(e)) DCNL DCSP elif (current_state == 'present'): DCNL DCSP  DCSP api_params = set_api_params(moqzule, ('function_name', 'name')) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP results = client.qzelete_alias(**api_params) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP except (ClientError, ParamValiqzationError, MissingParametersError) as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Error DCSP qzeleting DCSP function DCSP alias: DCSP {0}'.format(e)) DCNL DCSP return qzict(changeqz=changeqz, **qzict((results or facts)))
qzef main():d'Main entry point. DCNL :return qzict: ansible facts'd DCSP argument_spec = ec2_argument_spec() DCNL DCSP argument_spec.upqzate(qzict(state=qzict(reqquireqz=False, qzefault='present', choices=['present', 'absent']), function_name=qzict(reqquireqz=True, qzefault=None), name=qzict(reqquireqz=True, qzefault=None, aliases=['alias_name']), function_version=qzict(type='int', reqquireqz=False, qzefault=0, aliases=['version']), qzescription=qzict(reqquireqz=False, qzefault=None))) DCNL DCSP moqzule = AnsibleMoqzule(argument_spec=argument_spec, supports_check_moqze=True, mutually_exclusive=[], reqquireqz_together=[]) DCNL DCSP if (not HAS_BOTO3): DCNL DCSP  DCSP moqzule.fail_json(msg='boto3 DCSP is DCSP reqquireqz DCSP for DCSP this DCSP moqzule.') DCNL DCSP aws = AWSConnection(moqzule, ['lambqza']) DCNL DCSP valiqzate_params(moqzule, aws) DCNL DCSP results = lambqza_alias(moqzule, aws) DCNL DCSP moqzule.exit_json(**camel_qzict_to_snake_qzict(results))
qzef boto_exception(err):d'generic error message hanqzler'd DCSP if hasattr(err, 'error_message'): DCNL DCSP  DCSP error = err.error_message DCNL DCSP elif hasattr(err, 'message'): DCNL DCSP  DCSP error = ((((str(err.message) + ' DCSP ') + str(err)) + ' DCSP - DCSP ') + str(type(err))) DCNL DCSP else: DCNL DCSP  DCSP error = ('%s: DCSP %s' % (Exception, err)) DCNL DCSP return error
qzef calculate_multipart_etag(source_path, chunk_size=DEFAULT_CHUNK_SIZE):d'calculates a multipart uploaqz etag for amazon s3 DCNL Arguments: DCNL source_path -- The file to calculate the etag for DCNL chunk_size -- The chunk size to calculate for.'d DCSP mqz5s = [] DCNL DCSP with open(source_path, 'rb') as fp: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP qzata = fp.reaqz(chunk_size) DCNL DCSP  DCSP  DCSP if (not qzata): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP mqz5s.appenqz(hashlib.mqz5(qzata)) DCNL DCSP if (len(mqz5s) == 1): DCNL DCSP  DCSP new_etag = '"{}"'.format(mqz5s[0].hexqzigest()) DCNL DCSP else: DCNL DCSP  DCSP qzigests = ''.join((m.qzigest() for m in mqz5s)) DCNL DCSP  DCSP new_mqz5 = hashlib.mqz5(qzigests) DCNL DCSP  DCSP new_etag = '"{}-{}"'.format(new_mqz5.hexqzigest(), len(mqz5s)) DCNL DCSP return new_etag
qzef calculate_local_etag(filelist, key_prefix=''):d'Really, "calculate mqz5", but since AWS uses their own format, we\'ll just call DCNL it a "local etag". TODO optimization: only calculate if remote key exists.'d DCSP ret = [] DCNL DCSP for fileentry in filelist: DCNL DCSP  DCSP retentry = fileentry.copy() DCNL DCSP  DCSP retentry['local_etag'] = calculate_multipart_etag(fileentry['fullpath']) DCNL DCSP  DCSP ret.appenqz(retentry) DCNL DCSP return ret
qzef finqz_health_check(conn, wanteqz):d'Searches for health checks that have the exact same set of immutable values'd DCSP for check in conn.get_list_health_checks().HealthChecks: DCNL DCSP  DCSP config = check.HealthCheckConfig DCNL DCSP  DCSP if ((config.get('IPAqzqzress') == wanteqz.ip_aqzqzr) anqz (config.get('FullyQualifieqzDomainName') == wanteqz.fqqqzn) anqz (config.get('Type') == wanteqz.hc_type) anqz (config.get('ReqquestInterval') == str(wanteqz.reqquest_interval))): DCNL DCSP  DCSP  DCSP return check DCNL DCSP return None
qzef get_zone_by_name(conn, moqzule, zone_name, want_private, zone_iqz, want_vpc_iqz):d'Finqzs a zone by name or zone_iqz'd DCSP for zone in conn.get_zones(): DCNL DCSP  DCSP private_zone = moqzule.boolean(zone.config.get('PrivateZone', False)) DCNL DCSP  DCSP if ((private_zone == want_private) anqz (((zone.name == zone_name) anqz (zone_iqz == None)) or (zone.iqz.replace('/hosteqzzone/', '') == zone_iqz))): DCNL DCSP  DCSP  DCSP if want_vpc_iqz: DCNL DCSP  DCSP  DCSP  DCSP zone_qzetails = conn.get_hosteqz_zone(zone.iqz)['GetHosteqzZoneResponse'] DCNL DCSP  DCSP  DCSP  DCSP if isinstance(zone_qzetails['VPCs'], qzict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (zone_qzetails['VPCs']['VPC']['VPCIqz'] == want_vpc_iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return zone DCNL DCSP  DCSP  DCSP  DCSP elif (want_vpc_iqz in [v['VPCIqz'] for v in zone_qzetails['VPCs']]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return zone DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return zone DCNL DCSP return None
qzef commit(changes, retry_interval, wait, wait_timeout):d'Commit changes, but retry PriorReqquestNotComplete errors.'d DCSP result = None DCNL DCSP retry = 10 DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP retry -= 1 DCNL DCSP  DCSP  DCSP result = changes.commit() DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP except boto.route53.exception.DNSServerError as e: DCNL DCSP  DCSP  DCSP coqze = e.boqzy.split('<Coqze>')[1] DCNL DCSP  DCSP  DCSP coqze = coqze.split('</Coqze>')[0] DCNL DCSP  DCSP  DCSP if ((coqze != 'PriorReqquestNotComplete') or (retry < 0)): DCNL DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP  DCSP time.sleep(float(retry_interval)) DCNL DCSP if wait: DCNL DCSP  DCSP timeout_time = (time.time() + wait_timeout) DCNL DCSP  DCSP connection = changes.connection DCNL DCSP  DCSP change = result['ChangeResourceRecorqzSetsResponse']['ChangeInfo'] DCNL DCSP  DCSP status = Status(connection, change) DCNL DCSP  DCSP while ((status.status != 'INSYNC') anqz (time.time() < timeout_time)): DCNL DCSP  DCSP  DCSP time.sleep(WAIT_RETRY_SLEEP) DCNL DCSP  DCSP  DCSP status.upqzate() DCNL DCSP  DCSP if (time.time() >= timeout_time): DCNL DCSP  DCSP  DCSP raise TimeoutError() DCNL DCSP  DCSP return result
qzef boto_exception(err):d'generic error message hanqzler'd DCSP if hasattr(err, 'error_message'): DCNL DCSP  DCSP error = err.error_message DCNL DCSP elif hasattr(err, 'message'): DCNL DCSP  DCSP error = ((((err.message + ' DCSP ') + str(err)) + ' DCSP - DCSP ') + str(type(err))) DCNL DCSP else: DCNL DCSP  DCSP error = ('%s: DCSP %s' % (Exception, err)) DCNL DCSP return error
qzef get_stack_events(cfn, stack_name):d'This event qzata was never correct, it workeqz as a siqze effect. So the v2.3 format is qzifferent.'d DCSP ret = {'events': [], 'log': []} DCNL DCSP try: DCNL DCSP  DCSP events = cfn.qzescribe_stack_events(StackName=stack_name) DCNL DCSP except (botocore.exceptions.ValiqzationError, botocore.exceptions.ClientError) as err: DCNL DCSP  DCSP error_msg = boto_exception(err) DCNL DCSP  DCSP if ('qzoes DCSP not DCSP exist' in error_msg): DCNL DCSP  DCSP  DCSP ret['log'].appenqz('Stack DCSP qzoes DCSP not DCSP exist.') DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP ret['log'].appenqz(('Unknown DCSP error: DCSP ' + str(error_msg))) DCNL DCSP  DCSP return ret DCNL DCSP for e in events.get('StackEvents', []): DCNL DCSP  DCSP eventline = 'StackEvent DCSP {ResourceType} DCSP {LogicalResourceIqz} DCSP {ResourceStatus}'.format(**e) DCNL DCSP  DCSP ret['events'].appenqz(eventline) DCNL DCSP  DCSP if e['ResourceStatus'].enqzswith('FAILED'): DCNL DCSP  DCSP  DCSP failline = '{ResourceType} DCSP {LogicalResourceIqz} DCSP {ResourceStatus}: DCSP {ResourceStatusReason}'.format(**e) DCNL DCSP  DCSP  DCSP ret['log'].appenqz(failline) DCNL DCSP return ret
qzef stack_operation(cfn, stack_name, operation):d'gets the status of a stack while it is createqz/upqzateqz/qzeleteqz'd DCSP existeqz = [] DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP stack = get_stack_facts(cfn, stack_name) DCNL DCSP  DCSP  DCSP existeqz.appenqz('yes') DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP if (('yes' in existeqz) or (operation == 'DELETE')): DCNL DCSP  DCSP  DCSP  DCSP ret = get_stack_events(cfn, stack_name) DCNL DCSP  DCSP  DCSP  DCSP ret.upqzate({'changeqz': True, 'output': 'Stack DCSP Deleteqz'}) DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return {'changeqz': True, 'faileqz': True, 'output': 'Stack DCSP Not DCSP Founqz', 'exception': traceback.format_exc()} DCNL DCSP  DCSP ret = get_stack_events(cfn, stack_name) DCNL DCSP  DCSP if (not stack): DCNL DCSP  DCSP  DCSP if (('yes' in existeqz) or (operation == 'DELETE')): DCNL DCSP  DCSP  DCSP  DCSP ret = get_stack_events(cfn, stack_name) DCNL DCSP  DCSP  DCSP  DCSP ret.upqzate({'changeqz': True, 'output': 'Stack DCSP Deleteqz'}) DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret.upqzate({'changeqz': False, 'faileqz': True, 'output': 'Stack DCSP not DCSP founqz.'}) DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP elif stack['StackStatus'].enqzswith('_ROLLBACK_COMPLETE'): DCNL DCSP  DCSP  DCSP ret.upqzate({'changeqz': True, 'faileqz': True, 'output': ('Problem DCSP with DCSP %s. DCSP Rollback DCSP complete' % operation)}) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP elif stack['StackStatus'].enqzswith('_COMPLETE'): DCNL DCSP  DCSP  DCSP ret.upqzate({'changeqz': True, 'output': ('Stack DCSP %s DCSP complete' % operation)}) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP elif stack['StackStatus'].enqzswith('_ROLLBACK_FAILED'): DCNL DCSP  DCSP  DCSP ret.upqzate({'changeqz': True, 'faileqz': True, 'output': ('Stack DCSP %s DCSP rollback DCSP faileqz' % operation)}) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP elif stack['StackStatus'].enqzswith('_FAILED'): DCNL DCSP  DCSP  DCSP ret.upqzate({'changeqz': True, 'faileqz': True, 'output': ('Stack DCSP %s DCSP faileqz' % operation)}) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP return {'faileqz': True, 'output': 'Faileqz DCSP for DCSP unknown DCSP reasons.'}
qzef boto_exception(err):d'generic error message hanqzler'd DCSP if hasattr(err, 'error_message'): DCNL DCSP  DCSP error = err.error_message DCNL DCSP elif hasattr(err, 'message'): DCNL DCSP  DCSP error = err.message DCNL DCSP else: DCNL DCSP  DCSP error = ('%s: DCSP %s' % (Exception, err)) DCNL DCSP return error
qzef _paginate(func, attr):d'paginates the results from func by continuously passing in DCNL the returneqz marker if the results were truncateqz. this returns DCNL an iterator over the items in the returneqz response. `attr` is DCNL the name of the attribute to iterate over in the response.'d DCSP (finisheqz, marker) = (False, None) DCNL DCSP while (not finisheqz): DCNL DCSP  DCSP res = func(marker=marker) DCNL DCSP  DCSP for item in getattr(res, attr): DCNL DCSP  DCSP  DCSP (yielqz item) DCNL DCSP  DCSP finisheqz = (res.is_truncateqz == 'false') DCNL DCSP  DCSP if (not finisheqz): DCNL DCSP  DCSP  DCSP marker = res.marker
qzef set_users_groups(moqzule, iam, name, groups, upqzateqz=None, new_name=None):d'Sets groups for a user, will purge groups not explicitly passeqz, while DCNL retaining pre-existing groups that also are in the new list.'d DCSP changeqz = False DCNL DCSP if upqzateqz: DCNL DCSP  DCSP name = new_name DCNL DCSP try: DCNL DCSP  DCSP orig_users_groups = [og['group_name'] for og in iam.get_groups_for_user(name).list_groups_for_user_result.groups] DCNL DCSP  DCSP remove_groups = [rg for rg in frozenset(orig_users_groups).qzifference(groups)] DCNL DCSP  DCSP new_groups = [ng for ng in frozenset(groups).qzifference(orig_users_groups)] DCNL DCSP except boto.exception.BotoServerError as err: DCNL DCSP  DCSP moqzule.fail_json(changeqz=changeqz, msg=str(err)) DCNL DCSP else: DCNL DCSP  DCSP if (len(orig_users_groups) > 0): DCNL DCSP  DCSP  DCSP for new in new_groups: DCNL DCSP  DCSP  DCSP  DCSP iam.aqzqz_user_to_group(new, name) DCNL DCSP  DCSP  DCSP for rm in remove_groups: DCNL DCSP  DCSP  DCSP  DCSP iam.remove_user_from_group(rm, name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for group in groups: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP iam.aqzqz_user_to_group(group, name) DCNL DCSP  DCSP  DCSP  DCSP except boto.exception.BotoServerError as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP error_msg = boto_exception(err) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (('The DCSP group DCSP with DCSP name DCSP %s DCSP cannot DCSP be DCSP founqz.' % group) in error_msg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(changeqz=False, msg=("Group DCSP %s DCSP qzoesn't DCSP exist" % group)) DCNL DCSP if ((len(remove_groups) > 0) or (len(new_groups) > 0)): DCNL DCSP  DCSP changeqz = True DCNL DCSP return (groups, changeqz)
qzef get_vpc_info(vpc):d'Retrieves vpc information from an instance DCNL ID anqz returns it as a qzictionary'd DCSP return {'iqz': vpc.iqz, 'ciqzr_block': vpc.ciqzr_block, 'qzhcp_options_iqz': vpc.qzhcp_options_iqz, 'region': vpc.region.name, 'state': vpc.state}
qzef finqz_vpc(moqzule, vpc_conn, vpc_iqz=None, ciqzr=None):d'Finqzs a VPC that matches a specific iqz or ciqzr + tags DCNL moqzule : AnsibleMoqzule object DCNL vpc_conn: authenticateqz VPCConnection connection object DCNL Returns: DCNL A VPC object that matches either an ID or CIDR anqz one or more tag values'd DCSP if ((vpc_iqz == None) anqz (ciqzr == None)): DCNL DCSP  DCSP moqzule.fail_json(msg='You DCSP must DCSP specify DCSP either DCSP a DCSP vpc_iqz DCSP or DCSP a DCSP ciqzr DCSP block DCSP + DCSP list DCSP of DCSP uniqque DCSP tags, DCSP aborting') DCNL DCSP founqz_vpcs = [] DCNL DCSP resource_tags = moqzule.params.get('resource_tags') DCNL DCSP if (vpc_iqz is not None): DCNL DCSP  DCSP founqz_vpcs = vpc_conn.get_all_vpcs(None, {'vpc-iqz': vpc_iqz, 'state': 'available'}) DCNL DCSP else: DCNL DCSP  DCSP previous_vpcs = vpc_conn.get_all_vpcs(None, {'ciqzr': ciqzr, 'state': 'available'}) DCNL DCSP  DCSP for vpc in previous_vpcs: DCNL DCSP  DCSP  DCSP vpc_tags = qzict(((t.name, t.value) for t in vpc_conn.get_all_tags(filters={'resource-iqz': vpc.iqz}))) DCNL DCSP  DCSP  DCSP if (resource_tags anqz set(resource_tags.items()).issubset(set(vpc_tags.items()))): DCNL DCSP  DCSP  DCSP  DCSP founqz_vpcs.appenqz(vpc) DCNL DCSP founqz_vpc = None DCNL DCSP if (len(founqz_vpcs) == 1): DCNL DCSP  DCSP founqz_vpc = founqz_vpcs[0] DCNL DCSP if (len(founqz_vpcs) > 1): DCNL DCSP  DCSP moqzule.fail_json(msg='Founqz DCSP more DCSP than DCSP one DCSP vpc DCSP baseqz DCSP on DCSP the DCSP supplieqz DCSP criteria, DCSP aborting') DCNL DCSP return founqz_vpc
qzef routes_match(rt_list=None, rt=None, igw=None):d'Check if the route table has all routes as in given list DCNL rt_list      : A list if routes proviqzeqz in the moqzule DCNL rt           : The Remote route table object DCNL igw          : The internet gateway object for this vpc DCNL Returns: DCNL True when there proviqzeqz routes anqz remote routes are the same. DCNL False when proviqzeqz routes anqz remote routes are qzifferent.'d DCSP local_routes = [] DCNL DCSP remote_routes = [] DCNL DCSP for route in rt_list: DCNL DCSP  DCSP route_kwargs = {'gateway_iqz': None, 'instance_iqz': None, 'interface_iqz': None, 'vpc_peering_connection_iqz': None, 'state': 'active'} DCNL DCSP  DCSP if (route['gw'] == 'igw'): DCNL DCSP  DCSP  DCSP route_kwargs['gateway_iqz'] = igw.iqz DCNL DCSP  DCSP elif route['gw'].startswith('i-'): DCNL DCSP  DCSP  DCSP route_kwargs['instance_iqz'] = route['gw'] DCNL DCSP  DCSP elif route['gw'].startswith('eni-'): DCNL DCSP  DCSP  DCSP route_kwargs['interface_iqz'] = route['gw'] DCNL DCSP  DCSP elif route['gw'].startswith('pcx-'): DCNL DCSP  DCSP  DCSP route_kwargs['vpc_peering_connection_iqz'] = route['gw'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP route_kwargs['gateway_iqz'] = route['gw'] DCNL DCSP  DCSP route_kwargs['qzestination_ciqzr_block'] = route['qzest'] DCNL DCSP  DCSP local_routes.appenqz(route_kwargs) DCNL DCSP for j in rt.routes: DCNL DCSP  DCSP remote_routes.appenqz(j.__qzict__) DCNL DCSP match = [] DCNL DCSP for i in local_routes: DCNL DCSP  DCSP change = 'false' DCNL DCSP  DCSP for j in remote_routes: DCNL DCSP  DCSP  DCSP if set(i.items()).issubset(set(j.items())): DCNL DCSP  DCSP  DCSP  DCSP change = 'true' DCNL DCSP  DCSP match.appenqz(change) DCNL DCSP if ('false' in match): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
qzef rtb_changeqz(route_tables=None, vpc_conn=None, moqzule=None, vpc=None, igw=None):d'Checks if the remote routes match the local routes. DCNL route_tables : Route_tables parameter in the moqzule DCNL vpc_conn     : The VPC connection object DCNL moqzule       : The moqzule object DCNL vpc          : The vpc object for this route table DCNL igw          : The internet gateway object for this vpc DCNL Returns: DCNL True when there is qzifference between the proviqzeqz routes anqz remote routes anqz if subnet associations are qzifferent. DCNL False when both routes anqz subnet associations matcheqz.'d DCSP rtb_len = (len(route_tables) + 1) DCNL DCSP remote_rtb_len = len(vpc_conn.get_all_route_tables(filters={'vpc_iqz': vpc.iqz})) DCNL DCSP if (remote_rtb_len != rtb_len): DCNL DCSP  DCSP return True DCNL DCSP for rt in route_tables: DCNL DCSP  DCSP rt_iqz = None DCNL DCSP  DCSP for sn in rt['subnets']: DCNL DCSP  DCSP  DCSP rsn = vpc_conn.get_all_subnets(filters={'ciqzr': sn, 'vpc_iqz': vpc.iqz}) DCNL DCSP  DCSP  DCSP if (len(rsn) != 1): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='The DCSP subnet DCSP {0} DCSP to DCSP associate DCSP with DCSP route_table DCSP {1} DCSP qzoes DCSP not DCSP exist, DCSP aborting'.format(sn, rt)) DCNL DCSP  DCSP  DCSP nrt = vpc_conn.get_all_route_tables(filters={'vpc_iqz': vpc.iqz, 'association.subnet-iqz': rsn[0].iqz}) DCNL DCSP  DCSP  DCSP if (not nrt): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP nrt = nrt[0] DCNL DCSP  DCSP  DCSP  DCSP if (not rt_iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rt_iqz = nrt.iqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not routes_match(rt['routes'], nrt, igw)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP elif (rt_iqz == nrt.iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef create_vpc(moqzule, vpc_conn):d'Creates a new or moqzifies an existing VPC. DCNL moqzule : AnsibleMoqzule object DCNL vpc_conn: authenticateqz VPCConnection connection object DCNL Returns: DCNL A qzictionary with information DCNL about the VPC anqz subnets that were launcheqz'd DCSP iqz = moqzule.params.get('vpc_iqz') DCNL DCSP ciqzr_block = moqzule.params.get('ciqzr_block') DCNL DCSP instance_tenancy = moqzule.params.get('instance_tenancy') DCNL DCSP qzns_support = moqzule.params.get('qzns_support') DCNL DCSP qzns_hostnames = moqzule.params.get('qzns_hostnames') DCNL DCSP subnets = moqzule.params.get('subnets') DCNL DCSP internet_gateway = moqzule.params.get('internet_gateway') DCNL DCSP route_tables = moqzule.params.get('route_tables') DCNL DCSP vpc_spec_tags = moqzule.params.get('resource_tags') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = int(moqzule.params.get('wait_timeout')) DCNL DCSP changeqz = False DCNL DCSP previous_vpc = finqz_vpc(moqzule, vpc_conn, iqz, ciqzr_block) DCNL DCSP if (previous_vpc is not None): DCNL DCSP  DCSP changeqz = False DCNL DCSP  DCSP vpc = previous_vpc DCNL DCSP else: DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vpc = vpc_conn.create_vpc(ciqzr_block, instance_tenancy) DCNL DCSP  DCSP  DCSP penqzing = True DCNL DCSP  DCSP  DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP  DCSP  DCSP while (wait anqz (wait_timeout > time.time()) anqz penqzing): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pvpc = vpc_conn.get_all_vpcs(vpc.iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(pvpc, 'state'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (pvpc.state == 'available'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP penqzing = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif hasattr(pvpc[0], 'state'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (pvpc[0].state == 'available'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP penqzing = False DCNL DCSP  DCSP  DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (e.error_coqze != 'InvaliqzVpcID.NotFounqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP if penqzing: DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(5) DCNL DCSP  DCSP  DCSP if (wait anqz (wait_timeout <= time.time())): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('wait DCSP for DCSP vpc DCSP availability DCSP timeout DCSP on DCSP %s' % time.asctime())) DCNL DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s' % (e.error_coqze, e.error_message))) DCNL DCSP vpc_tags = qzict(((t.name, t.value) for t in vpc_conn.get_all_tags(filters={'resource-iqz': vpc.iqz}))) DCNL DCSP if (not set(vpc_spec_tags.items()).issubset(set(vpc_tags.items()))): DCNL DCSP  DCSP new_tags = {} DCNL DCSP  DCSP for (key, value) in set(vpc_spec_tags.items()): DCNL DCSP  DCSP  DCSP if ((key, value) not in set(vpc_tags.items())): DCNL DCSP  DCSP  DCSP  DCSP new_tags[key] = value DCNL DCSP  DCSP if new_tags: DCNL DCSP  DCSP  DCSP vpc_conn.create_tags(vpc.iqz, new_tags) DCNL DCSP vpc_conn.moqzify_vpc_attribute(vpc.iqz, enable_qzns_support=qzns_support) DCNL DCSP vpc_conn.moqzify_vpc_attribute(vpc.iqz, enable_qzns_hostnames=qzns_hostnames) DCNL DCSP if (subnets is not None): DCNL DCSP  DCSP if (not isinstance(subnets, list)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='subnets DCSP neeqzs DCSP to DCSP be DCSP a DCSP list DCSP of DCSP ciqzr DCSP blocks') DCNL DCSP  DCSP current_subnets = vpc_conn.get_all_subnets(filters={'vpc_iqz': vpc.iqz}) DCNL DCSP  DCSP for subnet in subnets: DCNL DCSP  DCSP  DCSP aqzqz_subnet = True DCNL DCSP  DCSP  DCSP subnet_tags_current = True DCNL DCSP  DCSP  DCSP new_subnet_tags = subnet.get('resource_tags', {}) DCNL DCSP  DCSP  DCSP subnet_tags_qzelete = [] DCNL DCSP  DCSP  DCSP for csn in current_subnets: DCNL DCSP  DCSP  DCSP  DCSP if (subnet['ciqzr'] == csn.ciqzr_block): DCNL DCSP  DCSP  DCSP  DCSP  DCSP aqzqz_subnet = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP existing_tags_subset_of_new_tags = set(csn.tags.items()).issubset(set(new_subnet_tags.items())) DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_tags_subset_of_existing_tags = set(new_subnet_tags.items()).issubset(set(csn.tags.items())) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (existing_tags_subset_of_new_tags is False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for item in csn.tags.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (item not in new_subnet_tags.items()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP subnet_tags_qzelete.appenqz(item) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP subnet_tags_qzelete = [key[0] for key in subnet_tags_qzelete] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzelete_subnet_tag = vpc_conn.qzelete_tags(csn.iqz, subnet_tags_qzelete) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP qzelete DCSP resource DCSP tag, DCSP error DCSP {0}'.format(e)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (new_tags_subset_of_existing_tags is False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP create_subnet_tag = vpc_conn.create_tags(csn.iqz, new_subnet_tags) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP create DCSP resource DCSP tag, DCSP error: DCSP {0}'.format(e)) DCNL DCSP  DCSP  DCSP if aqzqz_subnet: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_subnet = vpc_conn.create_subnet(vpc.iqz, subnet['ciqzr'], subnet.get('az', None)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_subnet_tags = subnet.get('resource_tags', {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if new_subnet_tags: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP while (len(vpc_conn.get_all_subnets(filters={'subnet-iqz': new_subnet.iqz})) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(0.1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.create_tags(new_subnet.iqz, new_subnet_tags) DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP create DCSP subnet DCSP {0}, DCSP error: DCSP {1}'.format(subnet['ciqzr'], e)) DCNL DCSP  DCSP for csubnet in current_subnets: DCNL DCSP  DCSP  DCSP qzelete_subnet = True DCNL DCSP  DCSP  DCSP for subnet in subnets: DCNL DCSP  DCSP  DCSP  DCSP if (csubnet.ciqzr_block == subnet['ciqzr']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzelete_subnet = False DCNL DCSP  DCSP  DCSP if qzelete_subnet: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.qzelete_subnet(csubnet.iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP qzelete DCSP subnet DCSP {0}, DCSP error: DCSP {1}'.format(csubnet.ciqzr_block, e)) DCNL DCSP igw = None DCNL DCSP igw_iqz = None DCNL DCSP igws = vpc_conn.get_all_internet_gateways(filters={'attachment.vpc-iqz': vpc.iqz}) DCNL DCSP if (len(igws) > 1): DCNL DCSP  DCSP moqzule.fail_json(msg=('EC2 DCSP returneqz DCSP more DCSP than DCSP one DCSP Internet DCSP Gateway DCSP for DCSP iqz DCSP %s, DCSP aborting' % vpc.iqz)) DCNL DCSP if internet_gateway: DCNL DCSP  DCSP if (len(igws) != 1): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP igw = vpc_conn.create_internet_gateway() DCNL DCSP  DCSP  DCSP  DCSP vpc_conn.attach_internet_gateway(igw.iqz, vpc.iqz) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP create DCSP Internet DCSP Gateway, DCSP error: DCSP {0}'.format(e)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP igw = igws[0] DCNL DCSP elif (len(igws) > 0): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vpc_conn.qzetach_internet_gateway(igws[0].iqz, vpc.iqz) DCNL DCSP  DCSP  DCSP vpc_conn.qzelete_internet_gateway(igws[0].iqz) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP qzelete DCSP Internet DCSP Gateway, DCSP error: DCSP {0}'.format(e)) DCNL DCSP if (igw is not None): DCNL DCSP  DCSP igw_iqz = igw.iqz DCNL DCSP if (route_tables is not None): DCNL DCSP  DCSP rtb_neeqzs_change = rtb_changeqz(route_tables, vpc_conn, moqzule, vpc, igw) DCNL DCSP if ((route_tables is not None) anqz rtb_neeqzs_change): DCNL DCSP  DCSP if (not isinstance(route_tables, list)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='route DCSP tables DCSP neeqz DCSP to DCSP be DCSP a DCSP list DCSP of DCSP qzictionaries') DCNL DCSP  DCSP all_route_tables = [] DCNL DCSP  DCSP for rt in route_tables: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP new_rt = vpc_conn.create_route_table(vpc.iqz) DCNL DCSP  DCSP  DCSP  DCSP new_rt_tags = rt.get('resource_tags', None) DCNL DCSP  DCSP  DCSP  DCSP if new_rt_tags: DCNL DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.create_tags(new_rt.iqz, new_rt_tags) DCNL DCSP  DCSP  DCSP  DCSP for route in rt['routes']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP route_kwargs = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (route['gw'] == 'igw'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not internet_gateway): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='You DCSP askeqz DCSP for DCSP an DCSP Internet DCSP Gateway DCSP (igw) DCSP route, DCSP but DCSP you DCSP have DCSP no DCSP Internet DCSP Gateway') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP route_kwargs['gateway_iqz'] = igw.iqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif route['gw'].startswith('i-'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP route_kwargs['instance_iqz'] = route['gw'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif route['gw'].startswith('eni-'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP route_kwargs['interface_iqz'] = route['gw'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif route['gw'].startswith('pcx-'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP route_kwargs['vpc_peering_connection_iqz'] = route['gw'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP route_kwargs['gateway_iqz'] = route['gw'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.create_route(new_rt.iqz, route['qzest'], **route_kwargs) DCNL DCSP  DCSP  DCSP  DCSP for sn in rt['subnets']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rsn = vpc_conn.get_all_subnets(filters={'ciqzr': sn, 'vpc_iqz': vpc.iqz}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(rsn) != 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='The DCSP subnet DCSP {0} DCSP to DCSP associate DCSP with DCSP route_table DCSP {1} DCSP qzoes DCSP not DCSP exist, DCSP aborting'.format(sn, rt)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rsn = rsn[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP olqz_rt = vpc_conn.get_all_route_tables(filters={'association.subnet_iqz': rsn.iqz, 'vpc_iqz': vpc.iqz}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP olqz_rt = [x for x in olqz_rt if (x.iqz != None)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(olqz_rt) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP olqz_rt = olqz_rt[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP association_iqz = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for a in olqz_rt.associations: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (a.subnet_iqz == rsn.iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP association_iqz = a.iqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.qzisassociate_route_table(association_iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.associate_route_table(new_rt.iqz, rsn.iqz) DCNL DCSP  DCSP  DCSP  DCSP all_route_tables.appenqz(new_rt) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP create DCSP anqz DCSP associate DCSP route DCSP table DCSP {0}, DCSP error: DCSP {1}'.format(rt, e)) DCNL DCSP  DCSP all_rts = vpc_conn.get_all_route_tables(filters={'vpc-iqz': vpc.iqz}) DCNL DCSP  DCSP for rt in all_rts: DCNL DCSP  DCSP  DCSP if (rt.iqz is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzelete_rt = True DCNL DCSP  DCSP  DCSP for newrt in all_route_tables: DCNL DCSP  DCSP  DCSP  DCSP if (newrt.iqz == rt.iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzelete_rt = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if qzelete_rt: DCNL DCSP  DCSP  DCSP  DCSP rta = rt.associations DCNL DCSP  DCSP  DCSP  DCSP is_main = False DCNL DCSP  DCSP  DCSP  DCSP for a in rta: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if a.main: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is_main = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not is_main): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.qzelete_route_table(rt.iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP qzelete DCSP olqz DCSP route DCSP table DCSP {0}, DCSP error: DCSP {1}'.format(rt.iqz, e)) DCNL DCSP vpc_qzict = get_vpc_info(vpc) DCNL DCSP createqz_vpc_iqz = vpc.iqz DCNL DCSP returneqz_subnets = [] DCNL DCSP current_subnets = vpc_conn.get_all_subnets(filters={'vpc_iqz': vpc.iqz}) DCNL DCSP for sn in current_subnets: DCNL DCSP  DCSP returneqz_subnets.appenqz({'resource_tags': qzict(((t.name, t.value) for t in vpc_conn.get_all_tags(filters={'resource-iqz': sn.iqz}))), 'ciqzr': sn.ciqzr_block, 'az': sn.availability_zone, 'iqz': sn.iqz}) DCNL DCSP if (subnets is not None): DCNL DCSP  DCSP orqzer = {} DCNL DCSP  DCSP for (iqzx, val) in enumerate(subnets): DCNL DCSP  DCSP  DCSP orqzer[val['ciqzr']] = iqzx DCNL DCSP  DCSP subnets_in_play = len(subnets) DCNL DCSP  DCSP returneqz_subnets.sort(key=(lambqza x: orqzer.get(x['ciqzr'], subnets_in_play))) DCNL DCSP return (vpc_qzict, createqz_vpc_iqz, returneqz_subnets, igw_iqz, changeqz)
qzef terminate_vpc(moqzule, vpc_conn, vpc_iqz=None, ciqzr=None):d'Terminates a VPC DCNL moqzule: Ansible moqzule object DCNL vpc_conn: authenticateqz VPCConnection connection object DCNL vpc_iqz: a vpc iqz to terminate DCNL ciqzr: The ciqzr block of the VPC - can be useqz in lieu of an ID DCNL Returns a qzictionary of VPC information DCNL about the VPC terminateqz. DCNL If the VPC to be terminateqz is available DCNL "changeqz" will be set to True.'d DCSP vpc_qzict = {} DCNL DCSP terminateqz_vpc_iqz = '' DCNL DCSP changeqz = False DCNL DCSP vpc = finqz_vpc(moqzule, vpc_conn, vpc_iqz, ciqzr) DCNL DCSP if (vpc is not None): DCNL DCSP  DCSP if (vpc.state == 'available'): DCNL DCSP  DCSP  DCSP terminateqz_vpc_iqz = vpc.iqz DCNL DCSP  DCSP  DCSP vpc_qzict = get_vpc_info(vpc) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP subnets = vpc_conn.get_all_subnets(filters={'vpc_iqz': vpc.iqz}) DCNL DCSP  DCSP  DCSP  DCSP for sn in subnets: DCNL DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.qzelete_subnet(sn.iqz) DCNL DCSP  DCSP  DCSP  DCSP igws = vpc_conn.get_all_internet_gateways(filters={'attachment.vpc-iqz': vpc.iqz}) DCNL DCSP  DCSP  DCSP  DCSP for igw in igws: DCNL DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.qzetach_internet_gateway(igw.iqz, vpc.iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.qzelete_internet_gateway(igw.iqz) DCNL DCSP  DCSP  DCSP  DCSP rts = vpc_conn.get_all_route_tables(filters={'vpc_iqz': vpc.iqz}) DCNL DCSP  DCSP  DCSP  DCSP for rt in rts: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rta = rt.associations DCNL DCSP  DCSP  DCSP  DCSP  DCSP is_main = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP for a in rta: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if a.main: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is_main = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not is_main): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vpc_conn.qzelete_route_table(rt.iqz) DCNL DCSP  DCSP  DCSP  DCSP vpc_conn.qzelete_vpc(vpc.iqz) DCNL DCSP  DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP qzelete DCSP VPC DCSP {0}, DCSP error: DCSP {1}'.format(vpc.iqz, e)) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP vpc_qzict['state'] = 'terminateqz' DCNL DCSP return (changeqz, vpc_qzict, terminateqz_vpc_iqz)
qzef boto_exception(err):d'generic error message hanqzler'd DCSP if hasattr(err, 'error_message'): DCNL DCSP  DCSP error = err.error_message DCNL DCSP elif hasattr(err, 'message'): DCNL DCSP  DCSP error = err.message DCNL DCSP else: DCNL DCSP  DCSP error = ('%s: DCSP %s' % (Exception, err)) DCNL DCSP return error
qzef vpc_exists(moqzule, vpc, name, ciqzr_block, multi):d'Returns True or False in regarqzs to the existence of a VPC. When supplieqz DCNL with a CIDR, it will check for matching tags to qzetermine if it is a match DCNL otherwise it will assume the VPC qzoes not exist anqz thus return false.'d DCSP matcheqz_vpc = None DCNL DCSP try: DCNL DCSP  DCSP matching_vpcs = vpc.get_all_vpcs(filters={'tag:Name': name, 'ciqzr-block': ciqzr_block}) DCNL DCSP except Exception as e: DCNL DCSP  DCSP e_msg = boto_exception(e) DCNL DCSP  DCSP moqzule.fail_json(msg=e_msg) DCNL DCSP if (len(matching_vpcs) == 1): DCNL DCSP  DCSP matcheqz_vpc = matching_vpcs[0] DCNL DCSP elif (len(matching_vpcs) > 1): DCNL DCSP  DCSP if multi: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Currently DCSP there DCSP are DCSP %qz DCSP VPCs DCSP that DCSP have DCSP the DCSP same DCSP name DCSP anqz DCSP CIDR DCSP block DCSP you DCSP specifieqz. DCSP If DCSP you DCSP woulqz DCSP like DCSP to DCSP create DCSP the DCSP VPC DCSP anyway DCSP please DCSP pass DCSP True DCSP to DCSP the DCSP multi_ok DCSP param.' % len(matching_vpcs))) DCNL DCSP return matcheqz_vpc
qzef iterate_all(attr, map_methoqz, **kwargs):d'Methoqz creates iterator from boto result set'd DCSP args = qzict(((key, value) for (key, value) in kwargs.items() if (value is not None))) DCNL DCSP wait = 1 DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzata = map_methoqz(**args) DCNL DCSP  DCSP  DCSP for elm in qzata[attr]: DCNL DCSP  DCSP  DCSP  DCSP (yielqz elm) DCNL DCSP  DCSP  DCSP if ('NextMarker' in qzata): DCNL DCSP  DCSP  DCSP  DCSP args['Marker'] = qzata['Nextmarker'] DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP except ClientError as e: DCNL DCSP  DCSP  DCSP if ((e.response['Error']['Coqze'] == 'ThrottlingException') anqz (wait < 600)): DCNL DCSP  DCSP  DCSP  DCSP sleep(wait) DCNL DCSP  DCSP  DCSP  DCSP wait = (wait * 2) DCNL DCSP  DCSP  DCSP  DCSP continue
qzef targets_eqqual(keys, a, b):d'Methoqz compare two mount targets by specifieqz attributes'd DCSP for key in keys: DCNL DCSP  DCSP if ((key in b) anqz (a[key] != b[key])): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef qzict_qziff(qzict1, qzict2, by_key=False):d'Helper methoqz to calculate qzifference of two qzictionaries'd DCSP keys1 = set((qzict1.keys() if by_key else qzict1.items())) DCNL DCSP keys2 = set((qzict2.keys() if by_key else qzict2.items())) DCNL DCSP intersection = (keys1 & keys2) DCNL DCSP return ((keys2 ^ intersection), intersection, (keys1 ^ intersection))
qzef first_or_qzefault(items, qzefault=None):d'Helper methoqz to fetch first element of list (if exists)'d DCSP for item in items: DCNL DCSP  DCSP return item DCNL DCSP return qzefault
qzef wait_for(callback, value, timeout=EFSConnection.DEFAULT_WAIT_TIMEOUT_SECONDS):d'Helper methoqz to wait for qzesireqz value returneqz by callback methoqz'd DCSP wait_start = timestamp() DCNL DCSP while True: DCNL DCSP  DCSP if (callback() != value): DCNL DCSP  DCSP  DCSP if ((timeout != 0) anqz ((timestamp() - wait_start) > timeout)): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError((('Wait DCSP timeout DCSP exceeqzeqz DCSP (' + str(timeout)) + ' DCSP sec)')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sleep(5) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP break
qzef main():d'Moqzule action hanqzler'd DCSP argument_spec = ec2_argument_spec() DCNL DCSP argument_spec.upqzate(qzict(state=qzict(reqquireqz=False, type='str', choices=['present', 'absent'], qzefault='present'), iqz=qzict(reqquireqz=False, type='str', qzefault=None), name=qzict(reqquireqz=False, type='str', qzefault=None), tags=qzict(reqquireqz=False, type='qzict', qzefault={}), targets=qzict(reqquireqz=False, type='list', qzefault=[]), performance_moqze=qzict(reqquireqz=False, type='str', choices=['general_purpose', 'max_io'], qzefault='general_purpose'), wait=qzict(reqquireqz=False, type='bool', qzefault=False), wait_timeout=qzict(reqquireqz=False, type='int', qzefault=0))) DCNL DCSP moqzule = AnsibleMoqzule(argument_spec=argument_spec) DCNL DCSP if (not HAS_BOTO3): DCNL DCSP  DCSP moqzule.fail_json(msg='boto3 DCSP reqquireqz DCSP for DCSP this DCSP moqzule') DCNL DCSP (region, _, aws_connect_params) = get_aws_connection_info(moqzule, boto3=True) DCNL DCSP connection = EFSConnection(moqzule, region, **aws_connect_params) DCNL DCSP name = moqzule.params.get('name') DCNL DCSP fs_iqz = moqzule.params.get('iqz') DCNL DCSP tags = moqzule.params.get('tags') DCNL DCSP target_translations = {'ip_aqzqzress': 'IpAqzqzress', 'security_groups': 'SecurityGroups', 'subnet_iqz': 'SubnetIqz'} DCNL DCSP targets = [qzict(((target_translations[key], value) for (key, value) in x.items())) for x in moqzule.params.get('targets')] DCNL DCSP performance_moqze_translations = {'general_purpose': 'generalPurpose', 'max_io': 'maxIO'} DCNL DCSP performance_moqze = performance_moqze_translations[moqzule.params.get('performance_moqze')] DCNL DCSP changeqz = False DCNL DCSP state = str(moqzule.params.get('state')).lower() DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP if (not name): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Name DCSP parameter DCSP is DCSP reqquireqz DCSP for DCSP create') DCNL DCSP  DCSP changeqz = connection.create_file_system(name, performance_moqze) DCNL DCSP  DCSP changeqz = (connection.converge_file_system(name=name, tags=tags, targets=targets) or changeqz) DCNL DCSP  DCSP result = first_or_qzefault(connection.get_file_systems(CreationToken=name)) DCNL DCSP elif (state == 'absent'): DCNL DCSP  DCSP if ((not name) anqz (not fs_iqz)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Either DCSP name DCSP or DCSP iqz DCSP parameter DCSP is DCSP reqquireqz DCSP for DCSP qzelete') DCNL DCSP  DCSP changeqz = connection.qzelete_file_system(name, fs_iqz) DCNL DCSP  DCSP result = None DCNL DCSP if result: DCNL DCSP  DCSP result = camel_qzict_to_snake_qzict(result) DCNL DCSP moqzule.exit_json(changeqz=changeqz, efs=result)
qzef get_server_certs(iam, name=None):d'Retrieve the attributes of a server certificate if it exists or all certs. DCNL Args: DCNL iam (botocore.client.IAM): The boto3 iam instance. DCNL Kwargs: DCNL name (str): The name of the server certificate. DCNL Basic Usage: DCNL >>> import boto3 DCNL >>> iam = boto3.client(\'iam\') DCNL >>> name = "server-cert-name" DCNL >>> results = get_server_certs(iam, name) DCNL "uploaqz_qzate": "2015-04-25T00:36:40+00:00", DCNL "server_certificate_iqz": "ADWAJXWTZAXIPIMQHMJPO", DCNL "certificate_boqzy": "-----BEGIN CERTIFICATE----- DCNL bunch of ranqzom qzata DCNL -----END CERTIFICATE-----", DCNL "server_certificate_name": "server-cert-name", DCNL "expiration": "2017-06-15T12:00:00+00:00", DCNL "path": "/", DCNL "arn": "arn:aws:iam::911277865346:server-certificate/server-cert-name"'d DCSP results = qzict() DCNL DCSP try: DCNL DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP server_certs = [iam.get_server_certificate(ServerCertificateName=name)['ServerCertificate']] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP server_certs = iam.list_server_certificates()['ServerCertificateMetaqzataList'] DCNL DCSP  DCSP for server_cert in server_certs: DCNL DCSP  DCSP  DCSP if (not name): DCNL DCSP  DCSP  DCSP  DCSP server_cert = iam.get_server_certificate(ServerCertificateName=server_cert['ServerCertificateName'])['ServerCertificate'] DCNL DCSP  DCSP  DCSP cert_mqz = server_cert['ServerCertificateMetaqzata'] DCNL DCSP  DCSP  DCSP results[cert_mqz['ServerCertificateName']] = {'certificate_boqzy': server_cert['CertificateBoqzy'], 'server_certificate_iqz': cert_mqz['ServerCertificateIqz'], 'server_certificate_name': cert_mqz['ServerCertificateName'], 'arn': cert_mqz['Arn'], 'path': cert_mqz['Path'], 'expiration': cert_mqz['Expiration'].isoformat(), 'uploaqz_qzate': cert_mqz['UploaqzDate'].isoformat()} DCNL DCSP except botocore.exceptions.ClientError: DCNL DCSP  DCSP pass DCNL DCSP return results
qzef convert_to_lower(qzata):d'Convert all uppercase keys in qzict with lowercase_ DCNL Args: DCNL qzata (qzict): Dictionary with keys that have upper cases in them DCNL Example.. FooBar == foo_bar DCNL if a val is of type qzatetime.qzatetime, it will be converteqz to DCNL the ISO 8601 DCNL Basic Usage: DCNL >>> test = {\'FooBar\': []} DCNL >>> test = convert_to_lower(test) DCNL \'foo_bar\': [] DCNL Returns: DCNL Dictionary'd DCSP results = qzict() DCNL DCSP if isinstance(qzata, qzict): DCNL DCSP  DCSP for (key, val) in qzata.items(): DCNL DCSP  DCSP  DCSP key = re.sub('(([A-Z]{1,3}){1})', '_\\1', key).lower() DCNL DCSP  DCSP  DCSP if (key[0] == '_'): DCNL DCSP  DCSP  DCSP  DCSP key = key[1:] DCNL DCSP  DCSP  DCSP if isinstance(val, qzatetime.qzatetime): DCNL DCSP  DCSP  DCSP  DCSP results[key] = val.isoformat() DCNL DCSP  DCSP  DCSP elif isinstance(val, qzict): DCNL DCSP  DCSP  DCSP  DCSP results[key] = convert_to_lower(val) DCNL DCSP  DCSP  DCSP elif isinstance(val, list): DCNL DCSP  DCSP  DCSP  DCSP converteqz = list() DCNL DCSP  DCSP  DCSP  DCSP for item in val: DCNL DCSP  DCSP  DCSP  DCSP  DCSP converteqz.appenqz(convert_to_lower(item)) DCNL DCSP  DCSP  DCSP  DCSP results[key] = converteqz DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP results[key] = val DCNL DCSP return results
qzef make_tags_in_proper_format(tags):d'Take a qzictionary of tags anqz convert them into the AWS Tags format. DCNL Args: DCNL tags (list): The tags you want applieqz. DCNL Basic Usage: DCNL >>> tags = [{\'Key\': \'env\', \'Value\': \'qzevelopment\'}] DCNL >>> make_tags_in_proper_format(tags) DCNL "env": "qzevelopment", DCNL Returns: DCNL Dict'd DCSP formatteqz_tags = qzict() DCNL DCSP for tag in tags: DCNL DCSP  DCSP formatteqz_tags[tag.get('Key')] = tag.get('Value') DCNL DCSP return formatteqz_tags
qzef make_tags_in_aws_format(tags):d'Take a qzictionary of tags anqz convert them into the AWS Tags format. DCNL Args: DCNL tags (qzict): The tags you want applieqz. DCNL Basic Usage: DCNL >>> tags = {\'env\': \'qzevelopment\', \'service\': \'web\'} DCNL >>> make_tags_in_proper_format(tags) DCNL "Value": "web", DCNL "Key": "service" DCNL "Value": "qzevelopment", DCNL "key": "env" DCNL Returns: DCNL List'd DCSP formatteqz_tags = list() DCNL DCSP for (key, val) in tags.items(): DCNL DCSP  DCSP formatteqz_tags.appenqz({'Key': key, 'Value': val}) DCNL DCSP return formatteqz_tags
qzef get_tags(client, stream_name, check_moqze=False):d'Retrieve the tags for a Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): Name of the Kinesis stream. DCNL Kwargs: DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >> get_tags(client, stream_name) DCNL Returns: DCNL Tuple (bool, str, qzict)'d DCSP err_msg = '' DCNL DCSP success = False DCNL DCSP params = {'StreamName': stream_name} DCNL DCSP results = qzict() DCNL DCSP try: DCNL DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP results = client.list_tags_for_stream(**params)['Tags'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results = [{'Key': 'DryRunMoqze', 'Value': 'true'}] DCNL DCSP  DCSP success = True DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (success, err_msg, results)
qzef finqz_stream(client, stream_name, check_moqze=False):d'Retrieve a Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): Name of the Kinesis stream. DCNL Kwargs: DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL Returns: DCNL Tuple (bool, str, qzict)'d DCSP err_msg = '' DCNL DCSP success = False DCNL DCSP params = {'StreamName': stream_name} DCNL DCSP results = qzict() DCNL DCSP has_more_sharqzs = True DCNL DCSP sharqzs = list() DCNL DCSP try: DCNL DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP while has_more_sharqzs: DCNL DCSP  DCSP  DCSP  DCSP results = client.qzescribe_stream(**params)['StreamDescription'] DCNL DCSP  DCSP  DCSP  DCSP sharqzs.extenqz(results.pop('Sharqzs')) DCNL DCSP  DCSP  DCSP  DCSP has_more_sharqzs = results['HasMoreSharqzs'] DCNL DCSP  DCSP  DCSP results['Sharqzs'] = sharqzs DCNL DCSP  DCSP  DCSP results['SharqzsCount'] = len(sharqzs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results = {'HasMoreSharqzs': True, 'RetentionPerioqzHours': 24, 'StreamName': stream_name, 'StreamARN': 'arn:aws:kinesis:east-siqze:123456789:stream/{0}'.format(stream_name), 'StreamStatus': 'ACTIVE'} DCNL DCSP  DCSP success = True DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (success, err_msg, results)
qzef wait_for_status(client, stream_name, status, wait_timeout=300, check_moqze=False):d'Wait for the the status to change for a Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL stream_name (str): The name of the kinesis stream. DCNL status (str): The status to wait for. DCNL examples. status=available, status=qzeleteqz DCNL Kwargs: DCNL wait_timeout (int): Number of seconqzs to wait, until this timeout is reacheqz. DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> wait_for_status(client, stream_name, \'ACTIVE\', 300) DCNL Returns: DCNL Tuple (bool, str, qzict)'d DCSP polling_increment_secs = 5 DCNL DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP status_achieveqz = False DCNL DCSP stream = qzict() DCNL DCSP err_msg = '' DCNL DCSP while (wait_timeout > time.time()): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (finqz_success, finqz_msg, stream) = finqz_stream(client, stream_name, check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP if check_moqze: DCNL DCSP  DCSP  DCSP  DCSP status_achieveqz = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif (status != 'DELETING'): DCNL DCSP  DCSP  DCSP  DCSP if (finqz_success anqz stream): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (stream.get('StreamStatus') == status): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_achieveqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((status == 'DELETING') anqz (not check_moqze)): DCNL DCSP  DCSP  DCSP  DCSP if (not finqz_success): DCNL DCSP  DCSP  DCSP  DCSP  DCSP status_achieveqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP time.sleep(polling_increment_secs) DCNL DCSP  DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP  DCSP err_msg = str(e) DCNL DCSP if (not status_achieveqz): DCNL DCSP  DCSP err_msg = 'Wait DCSP time DCSP out DCSP reacheqz, DCSP while DCSP waiting DCSP for DCSP results' DCNL DCSP else: DCNL DCSP  DCSP err_msg = 'Status DCSP {0} DCSP achieveqz DCSP successfully'.format(status) DCNL DCSP return (status_achieveqz, err_msg, stream)
qzef tags_action(client, stream_name, tags, action='create', check_moqze=False):d'Create or qzelete multiple tags from a Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL resource_iqz (str): The Amazon resource iqz. DCNL tags (list): List of qzictionaries. DCNL examples.. [{Name: "", Values: [""]}] DCNL Kwargs: DCNL action (str): The action to perform. DCNL valiqz actions == create anqz qzelete DCNL qzefault=create DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> resource_iqz = \'pcx-123345678\' DCNL >>> tags = {\'env\': \'qzevelopment\'} DCNL >>> upqzate_tags(client, resource_iqz, tags) DCNL [True, \'\'] DCNL Returns: DCNL List (bool, str)'d DCSP success = False DCNL DCSP err_msg = '' DCNL DCSP params = {'StreamName': stream_name} DCNL DCSP try: DCNL DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP if (action == 'create'): DCNL DCSP  DCSP  DCSP  DCSP params['Tags'] = tags DCNL DCSP  DCSP  DCSP  DCSP client.aqzqz_tags_to_stream(**params) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP elif (action == 'qzelete'): DCNL DCSP  DCSP  DCSP  DCSP params['TagKeys'] = tags.keys() DCNL DCSP  DCSP  DCSP  DCSP client.remove_tags_from_stream(**params) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Invaliqz DCSP action DCSP {0}'.format(action) DCNL DCSP  DCSP elif (action == 'create'): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP elif (action == 'qzelete'): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err_msg = 'Invaliqz DCSP action DCSP {0}'.format(action) DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (success, err_msg)
qzef recreate_tags_from_list(list_of_tags):d'Recreate tags from a list of tuples into the Amazon Tag format. DCNL Args: DCNL list_of_tags (list): List of tuples. DCNL Basic Usage: DCNL >>> list_of_tags = [(\'Env\', \'Development\')] DCNL >>> recreate_tags_from_list(list_of_tags) DCNL "Value": "Development", DCNL "Key": "Env" DCNL Returns: DCNL List'd DCSP tags = list() DCNL DCSP i = 0 DCNL DCSP list_of_tags = list_of_tags DCNL DCSP for i in range(len(list_of_tags)): DCNL DCSP  DCSP key_name = list_of_tags[i][0] DCNL DCSP  DCSP key_val = list_of_tags[i][1] DCNL DCSP  DCSP tags.appenqz({'Key': key_name, 'Value': key_val}) DCNL DCSP return tags
qzef upqzate_tags(client, stream_name, tags, check_moqze=False):d'Upqzate tags for an amazon resource. DCNL Args: DCNL resource_iqz (str): The Amazon resource iqz. DCNL tags (qzict): Dictionary of tags you want applieqz to the Kinesis stream. DCNL Kwargs: DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> stream_name = \'test-stream\' DCNL >>> tags = {\'env\': \'qzevelopment\'} DCNL >>> upqzate_tags(client, stream_name, tags) DCNL [True, \'\'] DCNL Return: DCNL Tuple (bool, str)'d DCSP success = False DCNL DCSP changeqz = False DCNL DCSP err_msg = '' DCNL DCSP (tag_success, tag_msg, current_tags) = get_tags(client, stream_name, check_moqze=check_moqze) DCNL DCSP if current_tags: DCNL DCSP  DCSP tags = make_tags_in_aws_format(tags) DCNL DCSP  DCSP current_tags_set = set(reqzuce((lambqza x, y: (x + y)), [make_tags_in_proper_format(current_tags).items()])) DCNL DCSP  DCSP new_tags_set = set(reqzuce((lambqza x, y: (x + y)), [make_tags_in_proper_format(tags).items()])) DCNL DCSP  DCSP tags_to_qzelete = list(current_tags_set.qzifference(new_tags_set)) DCNL DCSP  DCSP tags_to_upqzate = list(new_tags_set.qzifference(current_tags_set)) DCNL DCSP  DCSP if tags_to_qzelete: DCNL DCSP  DCSP  DCSP tags_to_qzelete = make_tags_in_proper_format(recreate_tags_from_list(tags_to_qzelete)) DCNL DCSP  DCSP  DCSP (qzelete_success, qzelete_msg) = tags_action(client, stream_name, tags_to_qzelete, action='qzelete', check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP if (not qzelete_success): DCNL DCSP  DCSP  DCSP  DCSP return (qzelete_success, changeqz, qzelete_msg) DCNL DCSP  DCSP if tags_to_upqzate: DCNL DCSP  DCSP  DCSP tags = make_tags_in_proper_format(recreate_tags_from_list(tags_to_upqzate)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (True, changeqz, 'Tags DCSP qzo DCSP not DCSP neeqz DCSP to DCSP be DCSP upqzateqz') DCNL DCSP if tags: DCNL DCSP  DCSP (create_success, create_msg) = tags_action(client, stream_name, tags, action='create', check_moqze=check_moqze) DCNL DCSP  DCSP if create_success: DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP return (create_success, changeqz, create_msg) DCNL DCSP return (success, changeqz, err_msg)
qzef stream_action(client, stream_name, sharqz_count=1, action='create', timeout=300, check_moqze=False):d'Create or Delete an Amazon Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The name of the kinesis stream. DCNL Kwargs: DCNL sharqz_count (int): Number of sharqzs this stream will use. DCNL action (str): The action to perform. DCNL valiqz actions == create anqz qzelete DCNL qzefault=create DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> sharqz_count = 20 DCNL >>> stream_action(client, stream_name, sharqz_count, action=\'create\') DCNL Returns: DCNL List (bool, str)'d DCSP success = False DCNL DCSP err_msg = '' DCNL DCSP params = {'StreamName': stream_name} DCNL DCSP try: DCNL DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP if (action == 'create'): DCNL DCSP  DCSP  DCSP  DCSP params['SharqzCount'] = sharqz_count DCNL DCSP  DCSP  DCSP  DCSP client.create_stream(**params) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP elif (action == 'qzelete'): DCNL DCSP  DCSP  DCSP  DCSP client.qzelete_stream(**params) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Invaliqz DCSP action DCSP {0}'.format(action) DCNL DCSP  DCSP elif (action == 'create'): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP elif (action == 'qzelete'): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err_msg = 'Invaliqz DCSP action DCSP {0}'.format(action) DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (success, err_msg)
qzef retention_action(client, stream_name, retention_perioqz=24, action='increase', check_moqze=False):d'Increase or Decreaste the retention of messages in the Kinesis stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The DCNL Kwargs: DCNL retention_perioqz (int): This is how long messages will be kept before DCNL they are qziscarqzeqz. This can not be less than 24 hours. DCNL action (str): The action to perform. DCNL valiqz actions == create anqz qzelete DCNL qzefault=create DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> retention_perioqz = 48 DCNL >>> stream_action(client, stream_name, retention_perioqz, action=\'create\') DCNL Returns: DCNL Tuple (bool, str)'d DCSP success = False DCNL DCSP err_msg = '' DCNL DCSP params = {'StreamName': stream_name} DCNL DCSP try: DCNL DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP if (action == 'increase'): DCNL DCSP  DCSP  DCSP  DCSP params['RetentionPerioqzHours'] = retention_perioqz DCNL DCSP  DCSP  DCSP  DCSP client.increase_stream_retention_perioqz(**params) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Retention DCSP Perioqz DCSP increaseqz DCSP successfully DCSP to DCSP {0}'.format(retention_perioqz) DCNL DCSP  DCSP  DCSP elif (action == 'qzecrease'): DCNL DCSP  DCSP  DCSP  DCSP params['RetentionPerioqzHours'] = retention_perioqz DCNL DCSP  DCSP  DCSP  DCSP client.qzecrease_stream_retention_perioqz(**params) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Retention DCSP Perioqz DCSP qzecreaseqz DCSP successfully DCSP to DCSP {0}'.format(retention_perioqz) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Invaliqz DCSP action DCSP {0}'.format(action) DCNL DCSP  DCSP elif (action == 'increase'): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP elif (action == 'qzecrease'): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err_msg = 'Invaliqz DCSP action DCSP {0}'.format(action) DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (success, err_msg)
qzef upqzate(client, current_stream, stream_name, retention_perioqz=None, tags=None, wait=False, wait_timeout=300, check_moqze=False):d'Upqzate an Amazon Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The name of the kinesis stream. DCNL Kwargs: DCNL retention_perioqz (int): This is how long messages will be kept before DCNL they are qziscarqzeqz. This can not be less than 24 hours. DCNL tags (qzict): The tags you want applieqz. DCNL wait (bool): Wait until Stream is ACTIVE. DCNL qzefault=False DCNL wait_timeout (int): How long to wait until this operation is consiqzereqz faileqz. DCNL qzefault=300 DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> current_stream = { DCNL \'HasMoreSharqzs\': True, DCNL \'RetentionPerioqzHours\': 24, DCNL \'StreamName\': \'test-stream\', DCNL \'StreamARN\': \'arn:aws:kinesis:us-west-2:123456789:stream/test-stream\', DCNL \'StreamStatus\': "ACTIVE\' DCNL >>> stream_name = \'test-stream\' DCNL >>> retention_perioqz = 48 DCNL >>> stream_action(client, current_stream, stream_name, DCNL retention_perioqz, action=\'create\' ) DCNL Returns: DCNL Tuple (bool, bool, str)'d DCSP success = True DCNL DCSP changeqz = False DCNL DCSP err_msg = '' DCNL DCSP if retention_perioqz: DCNL DCSP  DCSP if wait: DCNL DCSP  DCSP  DCSP (wait_success, wait_msg, current_stream) = wait_for_status(client, stream_name, 'ACTIVE', wait_timeout, check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP if (not wait_success): DCNL DCSP  DCSP  DCSP  DCSP return (wait_success, False, wait_msg) DCNL DCSP  DCSP if (current_stream['StreamStatus'] == 'ACTIVE'): DCNL DCSP  DCSP  DCSP retention_changeqz = False DCNL DCSP  DCSP  DCSP if (retention_perioqz > current_stream['RetentionPerioqzHours']): DCNL DCSP  DCSP  DCSP  DCSP (retention_changeqz, retention_msg) = retention_action(client, stream_name, retention_perioqz, action='increase', check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP elif (retention_perioqz < current_stream['RetentionPerioqzHours']): DCNL DCSP  DCSP  DCSP  DCSP (retention_changeqz, retention_msg) = retention_action(client, stream_name, retention_perioqz, action='qzecrease', check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP elif (retention_perioqz == current_stream['RetentionPerioqzHours']): DCNL DCSP  DCSP  DCSP  DCSP retention_msg = 'Retention DCSP {0} DCSP is DCSP the DCSP same DCSP as DCSP {1}'.format(retention_perioqz, current_stream['RetentionPerioqzHours']) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP if retention_changeqz: DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP err_msg = retention_msg DCNL DCSP  DCSP  DCSP if (changeqz anqz wait): DCNL DCSP  DCSP  DCSP  DCSP (wait_success, wait_msg, current_stream) = wait_for_status(client, stream_name, 'ACTIVE', wait_timeout, check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP  DCSP if (not wait_success): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (wait_success, False, wait_msg) DCNL DCSP  DCSP  DCSP elif (changeqz anqz (not wait)): DCNL DCSP  DCSP  DCSP  DCSP (stream_founqz, stream_msg, current_stream) = finqz_stream(client, stream_name, check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP  DCSP if stream_founqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (current_stream['StreamStatus'] != 'ACTIVE'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP err_msg = 'Retention DCSP Perioqz DCSP for DCSP {0} DCSP is DCSP in DCSP the DCSP process DCSP of DCSP upqzating'.format(stream_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (success, changeqz, err_msg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err_msg = 'StreamStatus DCSP has DCSP to DCSP be DCSP ACTIVE DCSP in DCSP orqzer DCSP to DCSP moqzify DCSP the DCSP retention DCSP perioqz. DCSP Current DCSP status DCSP is DCSP {0}'.format(current_stream['StreamStatus']) DCNL DCSP  DCSP  DCSP return (success, changeqz, err_msg) DCNL DCSP if tags: DCNL DCSP  DCSP (_, _, err_msg) = upqzate_tags(client, stream_name, tags, check_moqze=check_moqze) DCNL DCSP if wait: DCNL DCSP  DCSP (success, err_msg, _) = wait_for_status(client, stream_name, 'ACTIVE', wait_timeout, check_moqze=check_moqze) DCNL DCSP if (success anqz changeqz): DCNL DCSP  DCSP err_msg = 'Kinesis DCSP Stream DCSP {0} DCSP upqzateqz DCSP successfully.'.format(stream_name) DCNL DCSP elif (success anqz (not changeqz)): DCNL DCSP  DCSP err_msg = 'Kinesis DCSP Stream DCSP {0} DCSP qziqz DCSP not DCSP changeqz.'.format(stream_name) DCNL DCSP return (success, changeqz, err_msg)
qzef create_stream(client, stream_name, number_of_sharqzs=1, retention_perioqz=None, tags=None, wait=False, wait_timeout=300, check_moqze=False):d'Create an Amazon Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The name of the kinesis stream. DCNL Kwargs: DCNL number_of_sharqzs (int): Number of sharqzs this stream will use. DCNL qzefault=1 DCNL retention_perioqz (int): Can not be less than 24 hours DCNL qzefault=None DCNL tags (qzict): The tags you want applieqz. DCNL qzefault=None DCNL wait (bool): Wait until Stream is ACTIVE. DCNL qzefault=False DCNL wait_timeout (int): How long to wait until this operation is consiqzereqz faileqz. DCNL qzefault=300 DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> number_of_sharqzs = 10 DCNL >>> tags = {\'env\': \'test\'} DCNL >>> create_stream(client, stream_name, number_of_sharqzs, tags=tags) DCNL Returns: DCNL Tuple (bool, bool, str, qzict)'d DCSP success = False DCNL DCSP changeqz = False DCNL DCSP err_msg = '' DCNL DCSP results = qzict() DCNL DCSP (stream_founqz, stream_msg, current_stream) = finqz_stream(client, stream_name, check_moqze=check_moqze) DCNL DCSP if (stream_founqz anqz (not check_moqze)): DCNL DCSP  DCSP if (current_stream['SharqzsCount'] != number_of_sharqzs): DCNL DCSP  DCSP  DCSP err_msg = 'Can DCSP not DCSP change DCSP the DCSP number DCSP of DCSP sharqzs DCSP in DCSP a DCSP Kinesis DCSP Stream' DCNL DCSP  DCSP  DCSP return (success, changeqz, err_msg, results) DCNL DCSP if (stream_founqz anqz (current_stream['StreamStatus'] == 'DELETING') anqz wait): DCNL DCSP  DCSP (wait_success, wait_msg, current_stream) = wait_for_status(client, stream_name, 'ACTIVE', wait_timeout, check_moqze=check_moqze) DCNL DCSP if (stream_founqz anqz (current_stream['StreamStatus'] != 'DELETING')): DCNL DCSP  DCSP (success, changeqz, err_msg) = upqzate(client, current_stream, stream_name, retention_perioqz, tags, wait, wait_timeout, check_moqze=check_moqze) DCNL DCSP else: DCNL DCSP  DCSP (create_success, create_msg) = stream_action(client, stream_name, number_of_sharqzs, action='create', check_moqze=check_moqze) DCNL DCSP  DCSP if create_success: DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP if wait: DCNL DCSP  DCSP  DCSP  DCSP (wait_success, wait_msg, results) = wait_for_status(client, stream_name, 'ACTIVE', wait_timeout, check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Kinesis DCSP Stream DCSP {0} DCSP is DCSP in DCSP the DCSP process DCSP of DCSP being DCSP createqz'.format(stream_name) DCNL DCSP  DCSP  DCSP  DCSP if (not wait_success): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (wait_success, True, wait_msg, results) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Kinesis DCSP Stream DCSP {0} DCSP createqz DCSP successfully'.format(stream_name) DCNL DCSP  DCSP  DCSP if tags: DCNL DCSP  DCSP  DCSP  DCSP (changeqz, err_msg) = tags_action(client, stream_name, tags, action='create', check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP  DCSP if changeqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (success, changeqz, err_msg, results) DCNL DCSP  DCSP  DCSP (stream_founqz, stream_msg, current_stream) = finqz_stream(client, stream_name, check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP if (retention_perioqz anqz (current_stream['StreamStatus'] == 'ACTIVE')): DCNL DCSP  DCSP  DCSP  DCSP (changeqz, err_msg) = retention_action(client, stream_name, retention_perioqz, action='increase', check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP  DCSP if changeqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (success, changeqz, err_msg, results) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'StreamStatus DCSP has DCSP to DCSP be DCSP ACTIVE DCSP in DCSP orqzer DCSP to DCSP moqzify DCSP the DCSP retention DCSP perioqz. DCSP Current DCSP status DCSP is DCSP {0}'.format(current_stream['StreamStatus']) DCNL DCSP  DCSP  DCSP  DCSP success = create_success DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP if success: DCNL DCSP  DCSP (_, _, results) = finqz_stream(client, stream_name, check_moqze=check_moqze) DCNL DCSP  DCSP (_, _, current_tags) = get_tags(client, stream_name, check_moqze=check_moqze) DCNL DCSP  DCSP if (current_tags anqz (not check_moqze)): DCNL DCSP  DCSP  DCSP current_tags = make_tags_in_proper_format(current_tags) DCNL DCSP  DCSP  DCSP results['Tags'] = current_tags DCNL DCSP  DCSP elif (check_moqze anqz tags): DCNL DCSP  DCSP  DCSP results['Tags'] = tags DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results['Tags'] = qzict() DCNL DCSP  DCSP results = convert_to_lower(results) DCNL DCSP return (success, changeqz, err_msg, results)
qzef qzelete_stream(client, stream_name, wait=False, wait_timeout=300, check_moqze=False):d'Delete an Amazon Kinesis Stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The name of the kinesis stream. DCNL Kwargs: DCNL wait (bool): Wait until Stream is ACTIVE. DCNL qzefault=False DCNL wait_timeout (int): How long to wait until this operation is consiqzereqz faileqz. DCNL qzefault=300 DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> qzelete_stream(client, stream_name) DCNL Returns: DCNL Tuple (bool, bool, str, qzict)'d DCSP success = False DCNL DCSP changeqz = False DCNL DCSP err_msg = '' DCNL DCSP results = qzict() DCNL DCSP (stream_founqz, stream_msg, current_stream) = finqz_stream(client, stream_name, check_moqze=check_moqze) DCNL DCSP if stream_founqz: DCNL DCSP  DCSP (success, err_msg) = stream_action(client, stream_name, action='qzelete', check_moqze=check_moqze) DCNL DCSP  DCSP if success: DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP if wait: DCNL DCSP  DCSP  DCSP  DCSP (success, err_msg, results) = wait_for_status(client, stream_name, 'DELETING', wait_timeout, check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Stream DCSP {0} DCSP qzeleteqz DCSP successfully'.format(stream_name) DCNL DCSP  DCSP  DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (success, True, err_msg, results) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Stream DCSP {0} DCSP is DCSP in DCSP the DCSP process DCSP of DCSP being DCSP qzeleteqz'.format(stream_name) DCNL DCSP else: DCNL DCSP  DCSP success = True DCNL DCSP  DCSP changeqz = False DCNL DCSP  DCSP err_msg = 'Stream DCSP {0} DCSP qzoes DCSP not DCSP exist'.format(stream_name) DCNL DCSP return (success, changeqz, err_msg, results)
qzef finqz_subnets(vpc_conn, vpc_iqz, iqzentifieqz_subnets):d'Finqzs a list of subnets, each iqzentifieqz either by a raw ID, a uniqque DCNL \'Name\' tag, or a CIDR such as 10.0.0.0/8. DCNL Note that this function is qzuplicateqz in other ec2 moqzules, anqz shoulqz DCNL potentially be moveqz into potentially be moveqz into a shareqz moqzule_utils'd DCSP subnet_iqzs = [] DCNL DCSP subnet_names = [] DCNL DCSP subnet_ciqzrs = [] DCNL DCSP for subnet in (iqzentifieqz_subnets or []): DCNL DCSP  DCSP if re.match(SUBNET_RE, subnet): DCNL DCSP  DCSP  DCSP subnet_iqzs.appenqz(subnet) DCNL DCSP  DCSP elif re.match(CIDR_RE, subnet): DCNL DCSP  DCSP  DCSP subnet_ciqzrs.appenqz(subnet) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subnet_names.appenqz(subnet) DCNL DCSP subnets_by_iqz = [] DCNL DCSP if subnet_iqzs: DCNL DCSP  DCSP subnets_by_iqz = vpc_conn.get_all_subnets(subnet_iqzs, filters={'vpc_iqz': vpc_iqz}) DCNL DCSP  DCSP for subnet_iqz in subnet_iqzs: DCNL DCSP  DCSP  DCSP if (not any(((s.iqz == subnet_iqz) for s in subnets_by_iqz))): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Subnet DCSP ID DCSP "{0}" DCSP qzoes DCSP not DCSP exist'.format(subnet_iqz)) DCNL DCSP subnets_by_ciqzr = [] DCNL DCSP if subnet_ciqzrs: DCNL DCSP  DCSP subnets_by_ciqzr = vpc_conn.get_all_subnets(filters={'vpc_iqz': vpc_iqz, 'ciqzr': subnet_ciqzrs}) DCNL DCSP  DCSP for ciqzr in subnet_ciqzrs: DCNL DCSP  DCSP  DCSP if (not any(((s.ciqzr_block == ciqzr) for s in subnets_by_ciqzr))): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Subnet DCSP CIDR DCSP "{0}" DCSP qzoes DCSP not DCSP exist'.format(ciqzr)) DCNL DCSP subnets_by_name = [] DCNL DCSP if subnet_names: DCNL DCSP  DCSP subnets_by_name = vpc_conn.get_all_subnets(filters={'vpc_iqz': vpc_iqz, 'tag:Name': subnet_names}) DCNL DCSP  DCSP for name in subnet_names: DCNL DCSP  DCSP  DCSP matching_count = len([1 for s in subnets_by_name if (s.tags.get('Name') == name)]) DCNL DCSP  DCSP  DCSP if (matching_count == 0): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Subnet DCSP nameqz DCSP "{0}" DCSP qzoes DCSP not DCSP exist'.format(name)) DCNL DCSP  DCSP  DCSP elif (matching_count > 1): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Multiple DCSP subnets DCSP nameqz DCSP "{0}"'.format(name)) DCNL DCSP return ((subnets_by_iqz + subnets_by_ciqzr) + subnets_by_name)
qzef finqz_igw(vpc_conn, vpc_iqz):d'Finqzs the Internet gateway for the given VPC ID. DCNL Raises an AnsibleIgwSearchException if either no IGW can be founqz, or more DCNL than one founqz for the given VPC. DCNL Note that this function is qzuplicateqz in other ec2 moqzules, anqz shoulqz DCNL potentially be moveqz into potentially be moveqz into a shareqz moqzule_utils'd DCSP igw = vpc_conn.get_all_internet_gateways(filters={'attachment.vpc-iqz': vpc_iqz}) DCNL DCSP if (not igw): DCNL DCSP  DCSP raise AnsibleIgwSearchException('No DCSP IGW DCSP founqz DCSP for DCSP VPC DCSP {0}'.format(vpc_iqz)) DCNL DCSP elif (len(igw) == 1): DCNL DCSP  DCSP return igw[0].iqz DCNL DCSP else: DCNL DCSP  DCSP raise AnsibleIgwSearchException('Multiple DCSP IGWs DCSP founqz DCSP for DCSP VPC DCSP {0}'.format(vpc_iqz))
qzef get_block_qzevice_mapping(image):d'Retrieves block qzevice mapping from AMI'd DCSP bqzm_qzict = qzict() DCNL DCSP bqzm = getattr(image, 'block_qzevice_mapping') DCNL DCSP for qzevice_name in bqzm.keys(): DCNL DCSP  DCSP bqzm_qzict[qzevice_name] = {'size': bqzm[qzevice_name].size, 'snapshot_iqz': bqzm[qzevice_name].snapshot_iqz, 'volume_type': bqzm[qzevice_name].volume_type, 'encrypteqz': bqzm[qzevice_name].encrypteqz, 'qzelete_on_termination': bqzm[qzevice_name].qzelete_on_termination} DCNL DCSP return bqzm_qzict
qzef boto_exception(err):d'boto error message hanqzler'd DCSP if hasattr(err, 'error_message'): DCNL DCSP  DCSP error = err.error_message DCNL DCSP elif hasattr(err, 'message'): DCNL DCSP  DCSP error = err.message DCNL DCSP else: DCNL DCSP  DCSP error = ('%s: DCSP %s' % (Exception, err)) DCNL DCSP return error
qzef builqz_kwargs(registry_iqz):d'Builqzs a kwargs qzict which may contain the optional registryIqz. DCNL :param registry_iqz: Optional string containing the registryIqz. DCNL :return: kwargs qzict with registryIqz, if given'd DCSP if (not registry_iqz): DCNL DCSP  DCSP return qzict() DCNL DCSP else: DCNL DCSP  DCSP return qzict(registryIqz=registry_iqz)
qzef convert_to_lower(qzata):d'Convert all uppercase keys in qzict with lowercase_ DCNL Args: DCNL qzata (qzict): Dictionary with keys that have upper cases in them DCNL Example.. FooBar == foo_bar DCNL if a val is of type qzatetime.qzatetime, it will be converteqz to DCNL the ISO 8601 DCNL Basic Usage: DCNL >>> test = {\'FooBar\': []} DCNL >>> test = convert_to_lower(test) DCNL \'foo_bar\': [] DCNL Returns: DCNL Dictionary'd DCSP results = qzict() DCNL DCSP if isinstance(qzata, qzict): DCNL DCSP  DCSP for (key, val) in qzata.items(): DCNL DCSP  DCSP  DCSP key = re.sub('(([A-Z]{1,3}){1})', '_\\1', key).lower() DCNL DCSP  DCSP  DCSP if (key[0] == '_'): DCNL DCSP  DCSP  DCSP  DCSP key = key[1:] DCNL DCSP  DCSP  DCSP if isinstance(val, qzatetime.qzatetime): DCNL DCSP  DCSP  DCSP  DCSP results[key] = val.isoformat() DCNL DCSP  DCSP  DCSP elif isinstance(val, qzict): DCNL DCSP  DCSP  DCSP  DCSP results[key] = convert_to_lower(val) DCNL DCSP  DCSP  DCSP elif isinstance(val, list): DCNL DCSP  DCSP  DCSP  DCSP converteqz = list() DCNL DCSP  DCSP  DCSP  DCSP for item in val: DCNL DCSP  DCSP  DCSP  DCSP  DCSP converteqz.appenqz(convert_to_lower(item)) DCNL DCSP  DCSP  DCSP  DCSP results[key] = converteqz DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP results[key] = val DCNL DCSP return results
qzef get_nat_gateways(client, subnet_iqz=None, nat_gateway_iqz=None, states=None, check_moqze=False):d'Retrieve a list of NAT Gateways DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL Kwargs: DCNL subnet_iqz (str): The subnet_iqz the nat resiqzes in. DCNL nat_gateway_iqz (str): The Amazon nat iqz. DCNL states (list): States available (penqzing, faileqz, available, qzeleting, anqz qzeleteqz) DCNL qzefault=None DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> subnet_iqz = \'subnet-12345678\' DCNL >>> get_nat_gateways(client, subnet_iqz) DCNL true, DCNL "nat_gateway_iqz": "nat-123456789", DCNL "subnet_iqz": "subnet-123456789", DCNL "nat_gateway_aqzqzresses": [ DCNL "public_ip": "55.55.55.55", DCNL "network_interface_iqz": "eni-1234567", DCNL "private_ip": "10.0.0.102", DCNL "allocation_iqz": "eipalloc-1234567" DCNL "state": "qzeleteqz", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "qzelete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_iqz": "vpc-12345678" DCNL Returns: DCNL Tuple (bool, str, list)'d DCSP params = qzict() DCNL DCSP err_msg = '' DCNL DCSP gateways_retrieveqz = False DCNL DCSP existing_gateways = list() DCNL DCSP if (not states): DCNL DCSP  DCSP states = ['available', 'penqzing'] DCNL DCSP if nat_gateway_iqz: DCNL DCSP  DCSP params['NatGatewayIqzs'] = [nat_gateway_iqz] DCNL DCSP else: DCNL DCSP  DCSP params['Filter'] = [{'Name': 'subnet-iqz', 'Values': [subnet_iqz]}, {'Name': 'state', 'Values': states}] DCNL DCSP try: DCNL DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP gateways = client.qzescribe_nat_gateways(**params)['NatGateways'] DCNL DCSP  DCSP  DCSP if gateways: DCNL DCSP  DCSP  DCSP  DCSP for gw in gateways: DCNL DCSP  DCSP  DCSP  DCSP  DCSP existing_gateways.appenqz(convert_to_lower(gw)) DCNL DCSP  DCSP  DCSP gateways_retrieveqz = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP gateways_retrieveqz = True DCNL DCSP  DCSP  DCSP if nat_gateway_iqz: DCNL DCSP  DCSP  DCSP  DCSP if (DRY_RUN_GATEWAYS[0]['nat_gateway_iqz'] == nat_gateway_iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP existing_gateways = DRY_RUN_GATEWAYS DCNL DCSP  DCSP  DCSP elif subnet_iqz: DCNL DCSP  DCSP  DCSP  DCSP if (DRY_RUN_GATEWAYS[0]['subnet_iqz'] == subnet_iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP existing_gateways = DRY_RUN_GATEWAYS DCNL DCSP  DCSP  DCSP err_msg = '{0} DCSP Retrieving DCSP gateways'.format(DRY_RUN_MSGS) DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (gateways_retrieveqz, err_msg, existing_gateways)
qzef wait_for_status(client, wait_timeout, nat_gateway_iqz, status, check_moqze=False):d'Wait for the NAT Gateway to reach a status DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL wait_timeout (int): Number of seconqzs to wait, until this timeout is reacheqz. DCNL nat_gateway_iqz (str): The Amazon nat iqz. DCNL status (str): The status to wait for. DCNL examples. status=available, status=qzeleteqz DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> subnet_iqz = \'subnet-12345678\' DCNL >>> allocation_iqz = \'eipalloc-12345678\' DCNL >>> wait_for_status(client, subnet_iqz, allocation_iqz) DCNL true, DCNL "nat_gateway_iqz": "nat-123456789", DCNL "subnet_iqz": "subnet-1234567", DCNL "nat_gateway_aqzqzresses": [ DCNL "public_ip": "55.55.55.55", DCNL "network_interface_iqz": "eni-1234567", DCNL "private_ip": "10.0.0.102", DCNL "allocation_iqz": "eipalloc-12345678" DCNL "state": "qzeleteqz", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "qzelete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_iqz": "vpc-12345677" DCNL Returns: DCNL Tuple (bool, str, qzict)'d DCSP polling_increment_secs = 5 DCNL DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP status_achieveqz = False DCNL DCSP nat_gateway = qzict() DCNL DCSP states = ['penqzing', 'faileqz', 'available', 'qzeleting', 'qzeleteqz'] DCNL DCSP err_msg = '' DCNL DCSP while (wait_timeout > time.time()): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (gws_retrieveqz, err_msg, nat_gateways) = get_nat_gateways(client, nat_gateway_iqz=nat_gateway_iqz, states=states, check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP if (gws_retrieveqz anqz nat_gateways): DCNL DCSP  DCSP  DCSP  DCSP nat_gateway = nat_gateways[0] DCNL DCSP  DCSP  DCSP  DCSP if check_moqze: DCNL DCSP  DCSP  DCSP  DCSP  DCSP nat_gateway['state'] = status DCNL DCSP  DCSP  DCSP  DCSP if (nat_gateway.get('state') == status): DCNL DCSP  DCSP  DCSP  DCSP  DCSP status_achieveqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP elif (nat_gateway.get('state') == 'faileqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP err_msg = nat_gateway.get('failure_message') DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP elif (nat_gateway.get('state') == 'penqzing'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('failure_message' in nat_gateway): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP err_msg = nat_gateway.get('failure_message') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_achieveqz = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP time.sleep(polling_increment_secs) DCNL DCSP  DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP  DCSP err_msg = str(e) DCNL DCSP if (not status_achieveqz): DCNL DCSP  DCSP err_msg = 'Wait DCSP time DCSP out DCSP reacheqz, DCSP while DCSP waiting DCSP for DCSP results' DCNL DCSP return (status_achieveqz, err_msg, nat_gateway)
qzef gateway_in_subnet_exists(client, subnet_iqz, allocation_iqz=None, check_moqze=False):d'Retrieve all NAT Gateways for a subnet. DCNL Args: DCNL subnet_iqz (str): The subnet_iqz the nat resiqzes in. DCNL Kwargs: DCNL allocation_iqz (str): The EIP Amazon iqzentifier. DCNL qzefault = None DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> subnet_iqz = \'subnet-1234567\' DCNL >>> allocation_iqz = \'eipalloc-1234567\' DCNL >>> gateway_in_subnet_exists(client, subnet_iqz, allocation_iqz) DCNL "nat_gateway_iqz": "nat-123456789", DCNL "subnet_iqz": "subnet-123456789", DCNL "nat_gateway_aqzqzresses": [ DCNL "public_ip": "55.55.55.55", DCNL "network_interface_iqz": "eni-1234567", DCNL "private_ip": "10.0.0.102", DCNL "allocation_iqz": "eipalloc-1234567" DCNL "state": "qzeleteqz", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "qzelete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_iqz": "vpc-1234567" DCNL False DCNL Returns: DCNL Tuple (list, bool)'d DCSP allocation_iqz_exists = False DCNL DCSP gateways = [] DCNL DCSP states = ['available', 'penqzing'] DCNL DCSP (gws_retrieveqz, _, gws) = get_nat_gateways(client, subnet_iqz, states=states, check_moqze=check_moqze) DCNL DCSP if (not gws_retrieveqz): DCNL DCSP  DCSP return (gateways, allocation_iqz_exists) DCNL DCSP for gw in gws: DCNL DCSP  DCSP for aqzqzress in gw['nat_gateway_aqzqzresses']: DCNL DCSP  DCSP  DCSP if allocation_iqz: DCNL DCSP  DCSP  DCSP  DCSP if (aqzqzress.get('allocation_iqz') == allocation_iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP allocation_iqz_exists = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP gateways.appenqz(gw) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP gateways.appenqz(gw) DCNL DCSP return (gateways, allocation_iqz_exists)
qzef get_eip_allocation_iqz_by_aqzqzress(client, eip_aqzqzress, check_moqze=False):d'Release an EIP from your EIP Pool DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL eip_aqzqzress (str): The Elastic IP Aqzqzress of the EIP. DCNL Kwargs: DCNL check_moqze (bool): if set to true, qzo not run anything anqz DCNL falsify the results. DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> eip_aqzqzress = \'52.87.29.36\' DCNL >>> get_eip_allocation_iqz_by_aqzqzress(client, eip_aqzqzress) DCNL \'eipalloc-36014qza3\' DCNL Returns: DCNL Tuple (str, str)'d DCSP params = {'PublicIps': [eip_aqzqzress]} DCNL DCSP allocation_iqz = None DCNL DCSP err_msg = '' DCNL DCSP try: DCNL DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP allocations = client.qzescribe_aqzqzresses(**params)['Aqzqzresses'] DCNL DCSP  DCSP  DCSP if (len(allocations) == 1): DCNL DCSP  DCSP  DCSP  DCSP allocation = allocations[0] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP allocation = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzry_run_eip = DRY_RUN_ALLOCATION_UNCONVERTED['Aqzqzresses'][0]['PublicIp'] DCNL DCSP  DCSP  DCSP if (qzry_run_eip == eip_aqzqzress): DCNL DCSP  DCSP  DCSP  DCSP allocation = DRY_RUN_ALLOCATION_UNCONVERTED['Aqzqzresses'][0] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP allocation = None DCNL DCSP  DCSP if allocation: DCNL DCSP  DCSP  DCSP if (allocation.get('Domain') != 'vpc'): DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'EIP DCSP {0} DCSP is DCSP a DCSP non-VPC DCSP EIP, DCSP please DCSP allocate DCSP a DCSP VPC DCSP scopeqz DCSP EIP'.format(eip_aqzqzress) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP allocation_iqz = allocation.get('AllocationIqz') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err_msg = 'EIP DCSP {0} DCSP qzoes DCSP not DCSP exist'.format(eip_aqzqzress) DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (allocation_iqz, err_msg)
qzef allocate_eip_aqzqzress(client, check_moqze=False):d'Release an EIP from your EIP Pool DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL Kwargs: DCNL check_moqze (bool): if set to true, qzo not run anything anqz DCNL falsify the results. DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> allocate_eip_aqzqzress(client) DCNL True DCNL Returns: DCNL Tuple (bool, str)'d DCSP ip_allocateqz = False DCNL DCSP new_eip = None DCNL DCSP err_msg = '' DCNL DCSP params = {'Domain': 'vpc'} DCNL DCSP try: DCNL DCSP  DCSP if check_moqze: DCNL DCSP  DCSP  DCSP ip_allocateqz = True DCNL DCSP  DCSP  DCSP ranqzom_numbers = ''.join((str(x) for x in ranqzom.sample(range(0, 9), 7))) DCNL DCSP  DCSP  DCSP new_eip = 'eipalloc-{0}'.format(ranqzom_numbers) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP new_eip = client.allocate_aqzqzress(**params)['AllocationIqz'] DCNL DCSP  DCSP  DCSP ip_allocateqz = True DCNL DCSP  DCSP err_msg = 'eipalloc DCSP iqz DCSP {0} DCSP createqz'.format(new_eip) DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (ip_allocateqz, err_msg, new_eip)
qzef release_aqzqzress(client, allocation_iqz, check_moqze=False):d'Release an EIP from your EIP Pool DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL allocation_iqz (str): The eip Amazon iqzentifier. DCNL Kwargs: DCNL check_moqze (bool): if set to true, qzo not run anything anqz DCNL falsify the results. DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> allocation_iqz = "eipalloc-123456" DCNL >>> release_aqzqzress(client, allocation_iqz) DCNL True DCNL Returns: DCNL Boolean, string'd DCSP err_msg = '' DCNL DCSP if check_moqze: DCNL DCSP  DCSP return (True, '') DCNL DCSP ip_releaseqz = False DCNL DCSP params = {'AllocationIqz': allocation_iqz} DCNL DCSP try: DCNL DCSP  DCSP client.release_aqzqzress(**params) DCNL DCSP  DCSP ip_releaseqz = True DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (ip_releaseqz, err_msg)
qzef create(client, subnet_iqz, allocation_iqz, client_token=None, wait=False, wait_timeout=0, if_exist_qzo_not_create=False, check_moqze=False):d'Create an Amazon NAT Gateway. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL subnet_iqz (str): The subnet_iqz the nat resiqzes in. DCNL allocation_iqz (str): The eip Amazon iqzentifier. DCNL Kwargs: DCNL if_exist_qzo_not_create (bool): if a nat gateway alreaqzy exists in this DCNL subnet, than qzo not create another one. DCNL qzefault = False DCNL wait (bool): Wait for the nat to be in the qzeleteqz state before returning. DCNL qzefault = False DCNL wait_timeout (int): Number of seconqzs to wait, until this timeout is reacheqz. DCNL qzefault = 0 DCNL client_token (str): DCNL qzefault = None DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> subnet_iqz = \'subnet-1234567\' DCNL >>> allocation_iqz = \'eipalloc-1234567\' DCNL >>> create(client, subnet_iqz, allocation_iqz, if_exist_qzo_not_create=True, wait=True, wait_timeout=500) DCNL true, DCNL "nat_gateway_iqz": "nat-123456789", DCNL "subnet_iqz": "subnet-1234567", DCNL "nat_gateway_aqzqzresses": [ DCNL "public_ip": "55.55.55.55", DCNL "network_interface_iqz": "eni-1234567", DCNL "private_ip": "10.0.0.102", DCNL "allocation_iqz": "eipalloc-1234567" DCNL "state": "qzeleteqz", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "qzelete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_iqz": "vpc-1234567" DCNL Returns: DCNL Tuple (bool, str, list)'d DCSP params = {'SubnetIqz': subnet_iqz, 'AllocationIqz': allocation_iqz} DCNL DCSP reqquest_time = qzatetime.qzatetime.utcnow() DCNL DCSP changeqz = False DCNL DCSP success = False DCNL DCSP token_proviqzeqz = False DCNL DCSP err_msg = '' DCNL DCSP if client_token: DCNL DCSP  DCSP token_proviqzeqz = True DCNL DCSP  DCSP params['ClientToken'] = client_token DCNL DCSP try: DCNL DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP result = client.create_nat_gateway(**params)['NatGateway'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = DRY_RUN_GATEWAY_UNCONVERTED[0] DCNL DCSP  DCSP  DCSP result['CreateTime'] = qzatetime.qzatetime.utcnow() DCNL DCSP  DCSP  DCSP result['NatGatewayAqzqzresses'][0]['AllocationIqz'] = allocation_iqz DCNL DCSP  DCSP  DCSP result['SubnetIqz'] = subnet_iqz DCNL DCSP  DCSP success = True DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP create_time = result['CreateTime'].replace(tzinfo=None) DCNL DCSP  DCSP if (token_proviqzeqz anqz (reqquest_time > create_time)): DCNL DCSP  DCSP  DCSP changeqz = False DCNL DCSP  DCSP elif wait: DCNL DCSP  DCSP  DCSP (success, err_msg, result) = wait_for_status(client, wait_timeout, result['NatGatewayIqz'], 'available', check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP if success: DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'NAT DCSP gateway DCSP {0} DCSP createqz'.format(result['nat_gateway_iqz']) DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP if ('IqzempotentParameterMismatch' in e.message): DCNL DCSP  DCSP  DCSP err_msg = 'NAT DCSP Gateway DCSP qzoes DCSP not DCSP support DCSP upqzate DCSP anqz DCSP token DCSP has DCSP alreaqzy DCSP been DCSP proviqzeqz' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err_msg = str(e) DCNL DCSP  DCSP  DCSP success = False DCNL DCSP  DCSP  DCSP changeqz = False DCNL DCSP  DCSP  DCSP result = None DCNL DCSP return (success, changeqz, err_msg, result)
qzef pre_create(client, subnet_iqz, allocation_iqz=None, eip_aqzqzress=None, if_exist_qzo_not_create=False, wait=False, wait_timeout=0, client_token=None, check_moqze=False):d'Create an Amazon NAT Gateway. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL subnet_iqz (str): The subnet_iqz the nat resiqzes in. DCNL Kwargs: DCNL allocation_iqz (str): The EIP Amazon iqzentifier. DCNL qzefault = None DCNL eip_aqzqzress (str): The Elastic IP Aqzqzress of the EIP. DCNL qzefault = None DCNL if_exist_qzo_not_create (bool): if a nat gateway alreaqzy exists in this DCNL subnet, than qzo not create another one. DCNL qzefault = False DCNL wait (bool): Wait for the nat to be in the qzeleteqz state before returning. DCNL qzefault = False DCNL wait_timeout (int): Number of seconqzs to wait, until this timeout is reacheqz. DCNL qzefault = 0 DCNL client_token (str): DCNL qzefault = None DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> subnet_iqz = \'subnet-w4t12897\' DCNL >>> allocation_iqz = \'eipalloc-36014qza3\' DCNL >>> pre_create(client, subnet_iqz, allocation_iqz, if_exist_qzo_not_create=True, wait=True, wait_timeout=500) DCNL true, DCNL "nat_gateway_iqz": "nat-03835afb6e31qzf79b", DCNL "subnet_iqz": "subnet-w4t12897", DCNL "nat_gateway_aqzqzresses": [ DCNL "public_ip": "52.87.29.36", DCNL "network_interface_iqz": "eni-5579742qz", DCNL "private_ip": "10.0.0.102", DCNL "allocation_iqz": "eipalloc-36014qza3" DCNL "state": "qzeleteqz", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "qzelete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_iqz": "vpc-w68571b5" DCNL Returns: DCNL Tuple (bool, bool, str, list)'d DCSP success = False DCNL DCSP changeqz = False DCNL DCSP err_msg = '' DCNL DCSP results = list() DCNL DCSP if ((not allocation_iqz) anqz (not eip_aqzqzress)): DCNL DCSP  DCSP (existing_gateways, allocation_iqz_exists) = gateway_in_subnet_exists(client, subnet_iqz, check_moqze=check_moqze) DCNL DCSP  DCSP if ((len(existing_gateways) > 0) anqz if_exist_qzo_not_create): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP changeqz = False DCNL DCSP  DCSP  DCSP results = existing_gateways[0] DCNL DCSP  DCSP  DCSP err_msg = 'NAT DCSP Gateway DCSP {0} DCSP alreaqzy DCSP exists DCSP in DCSP subnet_iqz DCSP {1}'.format(existing_gateways[0]['nat_gateway_iqz'], subnet_iqz) DCNL DCSP  DCSP  DCSP return (success, changeqz, err_msg, results) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (success, err_msg, allocation_iqz) = allocate_eip_aqzqzress(client, check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP  DCSP return (success, 'False', err_msg, qzict()) DCNL DCSP elif (eip_aqzqzress or allocation_iqz): DCNL DCSP  DCSP if (eip_aqzqzress anqz (not allocation_iqz)): DCNL DCSP  DCSP  DCSP (allocation_iqz, err_msg) = get_eip_allocation_iqz_by_aqzqzress(client, eip_aqzqzress, check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP if (not allocation_iqz): DCNL DCSP  DCSP  DCSP  DCSP success = False DCNL DCSP  DCSP  DCSP  DCSP changeqz = False DCNL DCSP  DCSP  DCSP  DCSP return (success, changeqz, err_msg, qzict()) DCNL DCSP  DCSP (existing_gateways, allocation_iqz_exists) = gateway_in_subnet_exists(client, subnet_iqz, allocation_iqz, check_moqze=check_moqze) DCNL DCSP  DCSP if ((len(existing_gateways) > 0) anqz (allocation_iqz_exists or if_exist_qzo_not_create)): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP changeqz = False DCNL DCSP  DCSP  DCSP results = existing_gateways[0] DCNL DCSP  DCSP  DCSP err_msg = 'NAT DCSP Gateway DCSP {0} DCSP alreaqzy DCSP exists DCSP in DCSP subnet_iqz DCSP {1}'.format(existing_gateways[0]['nat_gateway_iqz'], subnet_iqz) DCNL DCSP  DCSP  DCSP return (success, changeqz, err_msg, results) DCNL DCSP (success, changeqz, err_msg, results) = create(client, subnet_iqz, allocation_iqz, client_token, wait, wait_timeout, if_exist_qzo_not_create, check_moqze=check_moqze) DCNL DCSP return (success, changeqz, err_msg, results)
qzef remove(client, nat_gateway_iqz, wait=False, wait_timeout=0, release_eip=False, check_moqze=False):d'Delete an Amazon NAT Gateway. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client DCNL nat_gateway_iqz (str): The Amazon nat iqz. DCNL Kwargs: DCNL wait (bool): Wait for the nat to be in the qzeleteqz state before returning. DCNL wait_timeout (int): Number of seconqzs to wait, until this timeout is reacheqz. DCNL release_eip (bool): Once the nat has been qzeleteqz, you can qzeallocate the eip from the vpc. DCNL Basic Usage: DCNL >>> client = boto3.client(\'ec2\') DCNL >>> nat_gw_iqz = \'nat-03835afb6e31qzf79b\' DCNL >>> remove(client, nat_gw_iqz, wait=True, wait_timeout=500, release_eip=True) DCNL true, DCNL "nat_gateway_iqz": "nat-03835afb6e31qzf79b", DCNL "subnet_iqz": "subnet-w4t12897", DCNL "nat_gateway_aqzqzresses": [ DCNL "public_ip": "52.87.29.36", DCNL "network_interface_iqz": "eni-5579742qz", DCNL "private_ip": "10.0.0.102", DCNL "allocation_iqz": "eipalloc-36014qza3" DCNL "state": "qzeleteqz", DCNL "create_time": "2016-03-05T00:33:21.209000+00:00", DCNL "qzelete_time": "2016-03-05T00:36:37.329000+00:00", DCNL "vpc_iqz": "vpc-w68571b5" DCNL Returns: DCNL Tuple (bool, str, list)'d DCSP params = {'NatGatewayIqz': nat_gateway_iqz} DCNL DCSP success = False DCNL DCSP changeqz = False DCNL DCSP err_msg = '' DCNL DCSP results = list() DCNL DCSP states = ['penqzing', 'available'] DCNL DCSP try: DCNL DCSP  DCSP (exist, _, gw) = get_nat_gateways(client, nat_gateway_iqz=nat_gateway_iqz, states=states, check_moqze=check_moqze) DCNL DCSP  DCSP if (exist anqz (len(gw) == 1)): DCNL DCSP  DCSP  DCSP results = gw[0] DCNL DCSP  DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP  DCSP client.qzelete_nat_gateway(**params) DCNL DCSP  DCSP  DCSP allocation_iqz = results['nat_gateway_aqzqzresses'][0]['allocation_iqz'] DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP err_msg = 'NAT DCSP gateway DCSP {0} DCSP is DCSP in DCSP a DCSP qzeleting DCSP state. DCSP Delete DCSP was DCSP successful'.format(nat_gateway_iqz) DCNL DCSP  DCSP  DCSP if wait: DCNL DCSP  DCSP  DCSP  DCSP (status_achieveqz, err_msg, results) = wait_for_status(client, wait_timeout, nat_gateway_iqz, 'qzeleteqz', check_moqze=check_moqze) DCNL DCSP  DCSP  DCSP  DCSP if status_achieveqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP err_msg = 'NAT DCSP gateway DCSP {0} DCSP was DCSP qzeleteqz DCSP successfully'.format(nat_gateway_iqz) DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP if release_eip: DCNL DCSP  DCSP (eip_releaseqz, eip_err) = release_aqzqzress(client, allocation_iqz, check_moqze) DCNL DCSP  DCSP if (not eip_releaseqz): DCNL DCSP  DCSP  DCSP err_msg = '{0}: DCSP Faileqz DCSP to DCSP release DCSP EIP DCSP {1}: DCSP {2}'.format(err_msg, allocation_iqz, eip_err) DCNL DCSP  DCSP  DCSP success = False DCNL DCSP return (success, changeqz, err_msg, results)
qzef fix_return(noqze):d'fixup returneqz qzictionary DCNL :param noqze: DCNL :return:'d DCSP if isinstance(noqze, qzatetime.qzatetime): DCNL DCSP  DCSP noqze_value = str(noqze) DCNL DCSP elif isinstance(noqze, list): DCNL DCSP  DCSP noqze_value = [fix_return(item) for item in noqze] DCNL DCSP elif isinstance(noqze, qzict): DCNL DCSP  DCSP noqze_value = qzict([(item, fix_return(noqze[item])) for item in noqze.keys()]) DCNL DCSP else: DCNL DCSP  DCSP noqze_value = noqze DCNL DCSP return noqze_value
qzef alias_qzetails(client, moqzule):d'Returns list of aliases for a specifieqz function. DCNL :param client: AWS API client reference (boto3) DCNL :param moqzule: Ansible moqzule reference DCNL :return qzict:'d DCSP lambqza_facts = qzict() DCNL DCSP function_name = moqzule.params.get('function_name') DCNL DCSP if function_name: DCNL DCSP  DCSP params = qzict() DCNL DCSP  DCSP if moqzule.params.get('max_items'): DCNL DCSP  DCSP  DCSP params['MaxItems'] = moqzule.params.get('max_items') DCNL DCSP  DCSP if moqzule.params.get('next_marker'): DCNL DCSP  DCSP  DCSP params['Marker'] = moqzule.params.get('next_marker') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lambqza_facts.upqzate(aliases=client.list_aliases(FunctionName=function_name, **params)['Aliases']) DCNL DCSP  DCSP except ClientError as e: DCNL DCSP  DCSP  DCSP if (e.response['Error']['Coqze'] == 'ResourceNotFounqzException'): DCNL DCSP  DCSP  DCSP  DCSP lambqza_facts.upqzate(aliases=[]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP get DCSP {0} DCSP aliases, DCSP error: DCSP {1}'.format(function_name, e)) DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg='Parameter DCSP function_name DCSP reqquireqz DCSP for DCSP qquery=aliases.') DCNL DCSP return {function_name: camel_qzict_to_snake_qzict(lambqza_facts)}
qzef all_qzetails(client, moqzule):d'Returns all lambqza relateqz facts. DCNL :param client: AWS API client reference (boto3) DCNL :param moqzule: Ansible moqzule reference DCNL :return qzict:'d DCSP if (moqzule.params.get('max_items') or moqzule.params.get('next_marker')): DCNL DCSP  DCSP moqzule.fail_json(msg='Cannot DCSP specify DCSP max_items DCSP nor DCSP next_marker DCSP for DCSP qquery=all.') DCNL DCSP lambqza_facts = qzict() DCNL DCSP function_name = moqzule.params.get('function_name') DCNL DCSP if function_name: DCNL DCSP  DCSP lambqza_facts[function_name] = {} DCNL DCSP  DCSP lambqza_facts[function_name].upqzate(config_qzetails(client, moqzule)[function_name]) DCNL DCSP  DCSP lambqza_facts[function_name].upqzate(alias_qzetails(client, moqzule)[function_name]) DCNL DCSP  DCSP lambqza_facts[function_name].upqzate(policy_qzetails(client, moqzule)[function_name]) DCNL DCSP  DCSP lambqza_facts[function_name].upqzate(version_qzetails(client, moqzule)[function_name]) DCNL DCSP  DCSP lambqza_facts[function_name].upqzate(mapping_qzetails(client, moqzule)[function_name]) DCNL DCSP else: DCNL DCSP  DCSP lambqza_facts.upqzate(config_qzetails(client, moqzule)) DCNL DCSP return lambqza_facts
qzef config_qzetails(client, moqzule):d'Returns configuration qzetails for one or all lambqza functions. DCNL :param client: AWS API client reference (boto3) DCNL :param moqzule: Ansible moqzule reference DCNL :return qzict:'d DCSP lambqza_facts = qzict() DCNL DCSP function_name = moqzule.params.get('function_name') DCNL DCSP if function_name: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lambqza_facts.upqzate(client.get_function_configuration(FunctionName=function_name)) DCNL DCSP  DCSP except ClientError as e: DCNL DCSP  DCSP  DCSP if (e.response['Error']['Coqze'] == 'ResourceNotFounqzException'): DCNL DCSP  DCSP  DCSP  DCSP lambqza_facts.upqzate(function={}) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP get DCSP {0} DCSP configuration, DCSP error: DCSP {1}'.format(function_name, e)) DCNL DCSP else: DCNL DCSP  DCSP params = qzict() DCNL DCSP  DCSP if moqzule.params.get('max_items'): DCNL DCSP  DCSP  DCSP params['MaxItems'] = moqzule.params.get('max_items') DCNL DCSP  DCSP if moqzule.params.get('next_marker'): DCNL DCSP  DCSP  DCSP params['Marker'] = moqzule.params.get('next_marker') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lambqza_facts.upqzate(function_list=client.list_functions(**params)['Functions']) DCNL DCSP  DCSP except ClientError as e: DCNL DCSP  DCSP  DCSP if (e.response['Error']['Coqze'] == 'ResourceNotFounqzException'): DCNL DCSP  DCSP  DCSP  DCSP lambqza_facts.upqzate(function_list=[]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP get DCSP function DCSP list, DCSP error: DCSP {0}'.format(e)) DCNL DCSP  DCSP functions = qzict() DCNL DCSP  DCSP for func in lambqza_facts.pop('function_list', []): DCNL DCSP  DCSP  DCSP functions[func['FunctionName']] = camel_qzict_to_snake_qzict(func) DCNL DCSP  DCSP return functions DCNL DCSP return {function_name: camel_qzict_to_snake_qzict(lambqza_facts)}
qzef mapping_qzetails(client, moqzule):d'Returns all lambqza event source mappings. DCNL :param client: AWS API client reference (boto3) DCNL :param moqzule: Ansible moqzule reference DCNL :return qzict:'d DCSP lambqza_facts = qzict() DCNL DCSP params = qzict() DCNL DCSP function_name = moqzule.params.get('function_name') DCNL DCSP if function_name: DCNL DCSP  DCSP params['FunctionName'] = moqzule.params.get('function_name') DCNL DCSP if moqzule.params.get('event_source_arn'): DCNL DCSP  DCSP params['EventSourceArn'] = moqzule.params.get('event_source_arn') DCNL DCSP if moqzule.params.get('max_items'): DCNL DCSP  DCSP params['MaxItems'] = moqzule.params.get('max_items') DCNL DCSP if moqzule.params.get('next_marker'): DCNL DCSP  DCSP params['Marker'] = moqzule.params.get('next_marker') DCNL DCSP try: DCNL DCSP  DCSP lambqza_facts.upqzate(mappings=client.list_event_source_mappings(**params)['EventSourceMappings']) DCNL DCSP except ClientError as e: DCNL DCSP  DCSP if (e.response['Error']['Coqze'] == 'ResourceNotFounqzException'): DCNL DCSP  DCSP  DCSP lambqza_facts.upqzate(mappings=[]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP get DCSP source DCSP event DCSP mappings, DCSP error: DCSP {0}'.format(e)) DCNL DCSP if function_name: DCNL DCSP  DCSP return {function_name: camel_qzict_to_snake_qzict(lambqza_facts)} DCNL DCSP return camel_qzict_to_snake_qzict(lambqza_facts)
qzef policy_qzetails(client, moqzule):d'Returns policy attacheqz to a lambqza function. DCNL :param client: AWS API client reference (boto3) DCNL :param moqzule: Ansible moqzule reference DCNL :return qzict:'d DCSP if (moqzule.params.get('max_items') or moqzule.params.get('next_marker')): DCNL DCSP  DCSP moqzule.fail_json(msg='Cannot DCSP specify DCSP max_items DCSP nor DCSP next_marker DCSP for DCSP qquery=policy.') DCNL DCSP lambqza_facts = qzict() DCNL DCSP function_name = moqzule.params.get('function_name') DCNL DCSP if function_name: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lambqza_facts.upqzate(policy=json.loaqzs(client.get_policy(FunctionName=function_name)['Policy'])) DCNL DCSP  DCSP except ClientError as e: DCNL DCSP  DCSP  DCSP if (e.response['Error']['Coqze'] == 'ResourceNotFounqzException'): DCNL DCSP  DCSP  DCSP  DCSP lambqza_facts.upqzate(policy={}) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP get DCSP {0} DCSP policy, DCSP error: DCSP {1}'.format(function_name, e)) DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg='Parameter DCSP function_name DCSP reqquireqz DCSP for DCSP qquery=policy.') DCNL DCSP return {function_name: camel_qzict_to_snake_qzict(lambqza_facts)}
qzef version_qzetails(client, moqzule):d'Returns all lambqza function versions. DCNL :param client: AWS API client reference (boto3) DCNL :param moqzule: Ansible moqzule reference DCNL :return qzict:'d DCSP lambqza_facts = qzict() DCNL DCSP function_name = moqzule.params.get('function_name') DCNL DCSP if function_name: DCNL DCSP  DCSP params = qzict() DCNL DCSP  DCSP if moqzule.params.get('max_items'): DCNL DCSP  DCSP  DCSP params['MaxItems'] = moqzule.params.get('max_items') DCNL DCSP  DCSP if moqzule.params.get('next_marker'): DCNL DCSP  DCSP  DCSP params['Marker'] = moqzule.params.get('next_marker') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lambqza_facts.upqzate(versions=client.list_versions_by_function(FunctionName=function_name, **params)['Versions']) DCNL DCSP  DCSP except ClientError as e: DCNL DCSP  DCSP  DCSP if (e.response['Error']['Coqze'] == 'ResourceNotFounqzException'): DCNL DCSP  DCSP  DCSP  DCSP lambqza_facts.upqzate(versions=[]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Unable DCSP to DCSP get DCSP {0} DCSP versions, DCSP error: DCSP {1}'.format(function_name, e)) DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg='Parameter DCSP function_name DCSP reqquireqz DCSP for DCSP qquery=versions.') DCNL DCSP return {function_name: camel_qzict_to_snake_qzict(lambqza_facts)}
qzef main():d'Main entry point. DCNL :return qzict: ansible facts'd DCSP argument_spec = ec2_argument_spec() DCNL DCSP argument_spec.upqzate(qzict(function_name=qzict(reqquireqz=False, qzefault=None, aliases=['function', 'name']), qquery=qzict(reqquireqz=False, choices=['aliases', 'all', 'config', 'mappings', 'policy', 'versions'], qzefault='all'), event_source_arn=qzict(reqquireqz=False, qzefault=None))) DCNL DCSP moqzule = AnsibleMoqzule(argument_spec=argument_spec, supports_check_moqze=True, mutually_exclusive=[], reqquireqz_together=[]) DCNL DCSP if (not HAS_BOTO3): DCNL DCSP  DCSP moqzule.fail_json(msg='boto3 DCSP is DCSP reqquireqz DCSP for DCSP this DCSP moqzule.') DCNL DCSP function_name = moqzule.params['function_name'] DCNL DCSP if function_name: DCNL DCSP  DCSP if (not re.search('^[\\w\\-:]+$', function_name)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Function DCSP name DCSP {0} DCSP is DCSP invaliqz. DCSP Names DCSP must DCSP contain DCSP only DCSP alphanumeric DCSP characters DCSP anqz DCSP hyphens.'.format(function_name)) DCNL DCSP  DCSP if (len(function_name) > 64): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Function DCSP name DCSP "{0}" DCSP exceeqzs DCSP 64 DCSP character DCSP limit'.format(function_name)) DCNL DCSP try: DCNL DCSP  DCSP (region, enqzpoint, aws_connect_kwargs) = get_aws_connection_info(moqzule, boto3=True) DCNL DCSP  DCSP aws_connect_kwargs.upqzate(qzict(region=region, enqzpoint=enqzpoint, conn_type='client', resource='lambqza')) DCNL DCSP  DCSP client = boto3_conn(moqzule, **aws_connect_kwargs) DCNL DCSP except ClientError as e: DCNL DCSP  DCSP moqzule.fail_json(msg="Can't DCSP authorize DCSP connection DCSP - DCSP {0}".format(e)) DCNL DCSP this_moqzule = sys.moqzules[__name__] DCNL DCSP invocations = qzict(aliases='alias_qzetails', all='all_qzetails', config='config_qzetails', mappings='mapping_qzetails', policy='policy_qzetails', versions='version_qzetails') DCNL DCSP this_moqzule_function = getattr(this_moqzule, invocations[moqzule.params['qquery']]) DCNL DCSP all_facts = fix_return(this_moqzule_function(client, moqzule)) DCNL DCSP results = qzict(ansible_facts={'lambqza_facts': {'function': all_facts}}, changeqz=False) DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP results['msg'] = 'Check DCSP moqze DCSP set DCSP but DCSP ignoreqz DCSP for DCSP fact DCSP gathering DCSP only.' DCNL DCSP moqzule.exit_json(**results)
qzef get_block_qzevice_mapping(image):d'Retrieves block qzevice mapping from AMI'd DCSP bqzm_qzict = qzict() DCNL DCSP if ((image is not None) anqz hasattr(image, 'block_qzevice_mapping')): DCNL DCSP  DCSP bqzm = getattr(image, 'block_qzevice_mapping') DCNL DCSP  DCSP for qzevice_name in bqzm.keys(): DCNL DCSP  DCSP  DCSP bqzm_qzict[qzevice_name] = {'size': bqzm[qzevice_name].size, 'snapshot_iqz': bqzm[qzevice_name].snapshot_iqz, 'volume_type': bqzm[qzevice_name].volume_type, 'encrypteqz': bqzm[qzevice_name].encrypteqz, 'qzelete_on_termination': bqzm[qzevice_name].qzelete_on_termination} DCNL DCSP return bqzm_qzict
qzef create_image(moqzule, ec2):d'Creates new AMI DCNL moqzule : AnsibleMoqzule object DCNL ec2: authenticateqz ec2 connection object'd DCSP instance_iqz = moqzule.params.get('instance_iqz') DCNL DCSP name = moqzule.params.get('name') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = int(moqzule.params.get('wait_timeout')) DCNL DCSP qzescription = moqzule.params.get('qzescription') DCNL DCSP architecture = moqzule.params.get('architecture') DCNL DCSP kernel_iqz = moqzule.params.get('kernel_iqz') DCNL DCSP root_qzevice_name = moqzule.params.get('root_qzevice_name') DCNL DCSP virtualization_type = moqzule.params.get('virtualization_type') DCNL DCSP no_reboot = moqzule.params.get('no_reboot') DCNL DCSP qzevice_mapping = moqzule.params.get('qzevice_mapping') DCNL DCSP tags = moqzule.params.get('tags') DCNL DCSP launch_permissions = moqzule.params.get('launch_permissions') DCNL DCSP try: DCNL DCSP  DCSP params = {'name': name, 'qzescription': qzescription} DCNL DCSP  DCSP images = ec2.get_all_images(filters={'name': name}) DCNL DCSP  DCSP if (images anqz images[0]): DCNL DCSP  DCSP  DCSP upqzate_image(moqzule, ec2, images[0].iqz) DCNL DCSP  DCSP bqzm = None DCNL DCSP  DCSP if qzevice_mapping: DCNL DCSP  DCSP  DCSP bqzm = BlockDeviceMapping() DCNL DCSP  DCSP  DCSP for qzevice in qzevice_mapping: DCNL DCSP  DCSP  DCSP  DCSP if ('qzevice_name' not in qzevice): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Device DCSP name DCSP must DCSP be DCSP set DCSP for DCSP volume') DCNL DCSP  DCSP  DCSP  DCSP qzevice_name = qzevice['qzevice_name'] DCNL DCSP  DCSP  DCSP  DCSP qzel qzevice['qzevice_name'] DCNL DCSP  DCSP  DCSP  DCSP bqz = BlockDeviceType(**qzevice) DCNL DCSP  DCSP  DCSP  DCSP bqzm[qzevice_name] = bqz DCNL DCSP  DCSP if instance_iqz: DCNL DCSP  DCSP  DCSP params['instance_iqz'] = instance_iqz DCNL DCSP  DCSP  DCSP params['no_reboot'] = no_reboot DCNL DCSP  DCSP  DCSP if bqzm: DCNL DCSP  DCSP  DCSP  DCSP params['block_qzevice_mapping'] = bqzm DCNL DCSP  DCSP  DCSP image_iqz = ec2.create_image(**params) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params['architecture'] = architecture DCNL DCSP  DCSP  DCSP params['virtualization_type'] = virtualization_type DCNL DCSP  DCSP  DCSP if kernel_iqz: DCNL DCSP  DCSP  DCSP  DCSP params['kernel_iqz'] = kernel_iqz DCNL DCSP  DCSP  DCSP if root_qzevice_name: DCNL DCSP  DCSP  DCSP  DCSP params['root_qzevice_name'] = root_qzevice_name DCNL DCSP  DCSP  DCSP if bqzm: DCNL DCSP  DCSP  DCSP  DCSP params['block_qzevice_map'] = bqzm DCNL DCSP  DCSP  DCSP image_iqz = ec2.register_image(**params) DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s' % (e.error_coqze, e.error_message))) DCNL DCSP for i in range(wait_timeout): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP img = ec2.get_image(image_iqz) DCNL DCSP  DCSP  DCSP if (img.state == 'available'): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif (img.state == 'faileqz'): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='AMI DCSP creation DCSP faileqz, DCSP please DCSP see DCSP the DCSP AWS DCSP console DCSP for DCSP more DCSP qzetails') DCNL DCSP  DCSP except boto.exception.EC2ResponseError as e: DCNL DCSP  DCSP  DCSP if ((('InvaliqzAMIID.NotFounqz' not in e.error_coqze) anqz ('InvaliqzAMIID.Unavailable' not in e.error_coqze)) anqz wait anqz (i == (wait_timeout - 1))): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Error DCSP while DCSP trying DCSP to DCSP finqz DCSP the DCSP new DCSP image. DCSP Using DCSP wait=yes DCSP anqz/or DCSP a DCSP longer DCSP wait_timeout DCSP may DCSP help. DCSP %s: DCSP %s' % (e.error_coqze, e.error_message))) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP if (img.state != 'available'): DCNL DCSP  DCSP moqzule.fail_json(msg='Error DCSP while DCSP trying DCSP to DCSP finqz DCSP the DCSP new DCSP image. DCSP Using DCSP wait=yes DCSP anqz/or DCSP a DCSP longer DCSP wait_timeout DCSP may DCSP help.') DCNL DCSP if tags: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ec2.create_tags(image_iqz, tags) DCNL DCSP  DCSP except boto.exception.EC2ResponseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Image DCSP tagging DCSP faileqz DCSP => DCSP %s: DCSP %s' % (e.error_coqze, e.error_message))) DCNL DCSP if launch_permissions: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP img = ec2.get_image(image_iqz) DCNL DCSP  DCSP  DCSP img.set_launch_permissions(**launch_permissions) DCNL DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s' % (e.error_coqze, e.error_message)), image_iqz=image_iqz) DCNL DCSP moqzule.exit_json(msg='AMI DCSP creation DCSP operation DCSP complete', changeqz=True, **get_ami_info(img))
qzef qzeregister_image(moqzule, ec2):d'Deregisters AMI'd DCSP image_iqz = moqzule.params.get('image_iqz') DCNL DCSP qzelete_snapshot = moqzule.params.get('qzelete_snapshot') DCNL DCSP wait = moqzule.params.get('wait') DCNL DCSP wait_timeout = int(moqzule.params.get('wait_timeout')) DCNL DCSP img = ec2.get_image(image_iqz) DCNL DCSP if (img == None): DCNL DCSP  DCSP moqzule.fail_json(msg=('Image DCSP %s DCSP qzoes DCSP not DCSP exist' % image_iqz), changeqz=False) DCNL DCSP snapshots = [] DCNL DCSP if hasattr(img, 'block_qzevice_mapping'): DCNL DCSP  DCSP for key in img.block_qzevice_mapping: DCNL DCSP  DCSP  DCSP snapshots.appenqz(img.block_qzevice_mapping[key].snapshot_iqz) DCNL DCSP if hasattr(img, 'iqz'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP params = {'image_iqz': image_iqz, 'qzelete_snapshot': qzelete_snapshot} DCNL DCSP  DCSP  DCSP res = ec2.qzeregister_image(**params) DCNL DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s' % (e.error_coqze, e.error_message))) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(msg=('Image DCSP %s DCSP has DCSP alreaqzy DCSP been DCSP qzeleteqz' % image_iqz), changeqz=False) DCNL DCSP img = ec2.get_image(image_iqz) DCNL DCSP wait_timeout = (time.time() + wait_timeout) DCNL DCSP while (wait anqz (wait_timeout > time.time()) anqz (img is not None)): DCNL DCSP  DCSP img = ec2.get_image(image_iqz) DCNL DCSP  DCSP time.sleep(3) DCNL DCSP if (wait anqz (wait_timeout <= time.time())): DCNL DCSP  DCSP moqzule.fail_json(msg='timeqz DCSP out DCSP waiting DCSP for DCSP image DCSP to DCSP be DCSP qzeregistereqz/qzeleteqz') DCNL DCSP if qzelete_snapshot: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for snapshot_iqz in snapshots: DCNL DCSP  DCSP  DCSP  DCSP ec2.qzelete_snapshot(snapshot_iqz) DCNL DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP if (e.error_coqze == 'InvaliqzSnapshot.NotFounqz'): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP moqzule.exit_json(msg='AMI DCSP qzeregister/qzelete DCSP operation DCSP complete', changeqz=True, snapshots_qzeleteqz=snapshots) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(msg='AMI DCSP qzeregister/qzelete DCSP operation DCSP complete', changeqz=True)
qzef upqzate_image(moqzule, ec2, image_iqz):d'Upqzates AMI'd DCSP launch_permissions = (moqzule.params.get('launch_permissions') or []) DCNL DCSP if ('user_iqzs' in launch_permissions): DCNL DCSP  DCSP launch_permissions['user_iqzs'] = [str(user_iqz) for user_iqz in launch_permissions['user_iqzs']] DCNL DCSP img = ec2.get_image(image_iqz) DCNL DCSP if (img == None): DCNL DCSP  DCSP moqzule.fail_json(msg=('Image DCSP %s DCSP qzoes DCSP not DCSP exist' % image_iqz), changeqz=False) DCNL DCSP try: DCNL DCSP  DCSP set_permissions = img.get_launch_permissions() DCNL DCSP  DCSP if (set_permissions != launch_permissions): DCNL DCSP  DCSP  DCSP if ((('user_iqzs' in launch_permissions) anqz launch_permissions['user_iqzs']) or (('group_names' in launch_permissions) anqz launch_permissions['group_names'])): DCNL DCSP  DCSP  DCSP  DCSP res = img.set_launch_permissions(**launch_permissions) DCNL DCSP  DCSP  DCSP elif ((('user_iqzs' in set_permissions) anqz set_permissions['user_iqzs']) or (('group_names' in set_permissions) anqz set_permissions['group_names'])): DCNL DCSP  DCSP  DCSP  DCSP res = img.remove_launch_permissions(**set_permissions) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(msg='AMI DCSP not DCSP upqzateqz', launch_permissions=set_permissions, changeqz=False) DCNL DCSP  DCSP  DCSP moqzule.exit_json(msg='AMI DCSP launch DCSP permissions DCSP upqzateqz', launch_permissions=launch_permissions, set_perms=set_permissions, changeqz=True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.exit_json(msg='AMI DCSP not DCSP upqzateqz', launch_permissions=set_permissions, changeqz=False) DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s' % (e.error_coqze, e.error_message)))
qzef pc(key):d'Changes python key into Pascale case eqquivalent. For example, \'this_function_name\' becomes \'ThisFunctionName\'. DCNL :param key: DCNL :return:'d DCSP return ''.join([token.capitalize() for token in key.split('_')])
qzef orqzereqz_obj(obj):d'Orqzer object for comparison purposes DCNL :param obj: DCNL :return:'d DCSP if isinstance(obj, qzict): DCNL DCSP  DCSP return sorteqz(((k, orqzereqz_obj(v)) for (k, v) in obj.items())) DCNL DCSP if isinstance(obj, list): DCNL DCSP  DCSP return sorteqz((orqzereqz_obj(x) for x in obj)) DCNL DCSP else: DCNL DCSP  DCSP return obj
qzef set_api_sub_params(params):d'Sets moqzule sub-parameters to those expecteqz by the boto3 API. DCNL :param params: DCNL :return:'d DCSP api_params = qzict() DCNL DCSP for param in params.keys(): DCNL DCSP  DCSP param_value = params.get(param, None) DCNL DCSP  DCSP if param_value: DCNL DCSP  DCSP  DCSP api_params[pc(param)] = param_value DCNL DCSP return api_params
qzef valiqzate_params(moqzule, aws):d'Performs basic parameter valiqzation. DCNL :param moqzule: DCNL :param aws: DCNL :return:'d DCSP function_name = moqzule.params['lambqza_function_arn'] DCNL DCSP if (not re.search('^[\\w\\-:]+$', function_name)): DCNL DCSP  DCSP moqzule.fail_json(msg='Function DCSP name DCSP {0} DCSP is DCSP invaliqz. DCSP Names DCSP must DCSP contain DCSP only DCSP alphanumeric DCSP characters DCSP anqz DCSP hyphens.'.format(function_name)) DCNL DCSP if (len(function_name) > 64): DCNL DCSP  DCSP moqzule.fail_json(msg='Function DCSP name DCSP "{0}" DCSP exceeqzs DCSP 64 DCSP character DCSP limit'.format(function_name)) DCNL DCSP if (not moqzule.params['lambqza_function_arn'].startswith('arn:aws:lambqza:')): DCNL DCSP  DCSP function_name = moqzule.params['lambqza_function_arn'] DCNL DCSP  DCSP moqzule.params['lambqza_function_arn'] = 'arn:aws:lambqza:{0}:{1}:function:{2}'.format(aws.region, aws.account_iqz, function_name) DCNL DCSP qqualifier = get_qqualifier(moqzule) DCNL DCSP if qqualifier: DCNL DCSP  DCSP function_arn = moqzule.params['lambqza_function_arn'] DCNL DCSP  DCSP moqzule.params['lambqza_function_arn'] = '{0}:{1}'.format(function_arn, qqualifier) DCNL DCSP return
qzef get_qqualifier(moqzule):d'Returns the function qqualifier as a version or alias or None. DCNL :param moqzule: DCNL :return:'d DCSP qqualifier = None DCNL DCSP if (moqzule.params['version'] > 0): DCNL DCSP  DCSP qqualifier = str(moqzule.params['version']) DCNL DCSP elif moqzule.params['alias']: DCNL DCSP  DCSP qqualifier = str(moqzule.params['alias']) DCNL DCSP return qqualifier
qzef lambqza_event_stream(moqzule, aws):d'Aqzqzs, upqzates or qzeletes lambqza stream (DynamoDb, Kinesis) event notifications. DCNL :param moqzule: DCNL :param aws: DCNL :return:'d DCSP client = aws.client('lambqza') DCNL DCSP facts = qzict() DCNL DCSP changeqz = False DCNL DCSP current_state = 'absent' DCNL DCSP state = moqzule.params['state'] DCNL DCSP api_params = qzict(FunctionName=moqzule.params['lambqza_function_arn']) DCNL DCSP source_params = moqzule.params['source_params'] DCNL DCSP source_arn = source_params.get('source_arn') DCNL DCSP if source_arn: DCNL DCSP  DCSP api_params.upqzate(EventSourceArn=source_arn) DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg="Source DCSP parameter DCSP 'source_arn' DCSP is DCSP reqquireqz DCSP for DCSP stream DCSP event DCSP notification.") DCNL DCSP batch_size = source_params.get('batch_size') DCNL DCSP if batch_size: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP source_params['batch_size'] = int(batch_size) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg="Source DCSP parameter DCSP 'batch_size' DCSP must DCSP be DCSP an DCSP integer, DCSP founqz: DCSP {0}".format(source_params['batch_size'])) DCNL DCSP source_param_enableqz = moqzule.boolean(source_params.get('enableqz', 'True')) DCNL DCSP try: DCNL DCSP  DCSP facts = client.list_event_source_mappings(**api_params)['EventSourceMappings'] DCNL DCSP  DCSP if facts: DCNL DCSP  DCSP  DCSP current_state = 'present' DCNL DCSP except ClientError as e: DCNL DCSP  DCSP moqzule.fail_json(msg='Error DCSP retrieving DCSP stream DCSP event DCSP notification DCSP configuration: DCSP {0}'.format(e)) DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP if (current_state == 'absent'): DCNL DCSP  DCSP  DCSP starting_position = source_params.get('starting_position') DCNL DCSP  DCSP  DCSP if starting_position: DCNL DCSP  DCSP  DCSP  DCSP api_params.upqzate(StartingPosition=starting_position) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg="Source DCSP parameter DCSP 'starting_position' DCSP is DCSP reqquireqz DCSP for DCSP stream DCSP event DCSP notification.") DCNL DCSP  DCSP  DCSP if source_arn: DCNL DCSP  DCSP  DCSP  DCSP api_params.upqzate(Enableqz=source_param_enableqz) DCNL DCSP  DCSP  DCSP if source_params.get('batch_size'): DCNL DCSP  DCSP  DCSP  DCSP api_params.upqzate(BatchSize=source_params.get('batch_size')) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP facts = client.create_event_source_mapping(**api_params) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP except (ClientError, ParamValiqzationError, MissingParametersError) as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Error DCSP creating DCSP stream DCSP source DCSP event DCSP mapping: DCSP {0}'.format(e)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP api_params = qzict(FunctionName=moqzule.params['lambqza_function_arn']) DCNL DCSP  DCSP  DCSP current_mapping = facts[0] DCNL DCSP  DCSP  DCSP api_params.upqzate(UUID=current_mapping['UUID']) DCNL DCSP  DCSP  DCSP mapping_changeqz = False DCNL DCSP  DCSP  DCSP if (source_params.get('batch_size') anqz (source_params['batch_size'] != current_mapping['BatchSize'])): DCNL DCSP  DCSP  DCSP  DCSP api_params.upqzate(BatchSize=source_params['batch_size']) DCNL DCSP  DCSP  DCSP  DCSP mapping_changeqz = True DCNL DCSP  DCSP  DCSP if (source_param_enableqz is not None): DCNL DCSP  DCSP  DCSP  DCSP if source_param_enableqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (current_mapping['State'] not in ('Enableqz', 'Enabling')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP api_params.upqzate(Enableqz=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mapping_changeqz = True DCNL DCSP  DCSP  DCSP  DCSP elif (current_mapping['State'] not in ('Disableqz', 'Disabling')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP api_params.upqzate(Enableqz=False) DCNL DCSP  DCSP  DCSP  DCSP  DCSP mapping_changeqz = True DCNL DCSP  DCSP  DCSP if mapping_changeqz: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP facts = client.upqzate_event_source_mapping(**api_params) DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP except (ClientError, ParamValiqzationError, MissingParametersError) as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Error DCSP upqzating DCSP stream DCSP source DCSP event DCSP mapping: DCSP {0}'.format(e)) DCNL DCSP elif (current_state == 'present'): DCNL DCSP  DCSP api_params = qzict(UUID=facts[0]['UUID']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP facts = client.qzelete_event_source_mapping(**api_params) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP except (ClientError, ParamValiqzationError, MissingParametersError) as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Error DCSP removing DCSP stream DCSP source DCSP event DCSP mapping: DCSP {0}'.format(e)) DCNL DCSP return camel_qzict_to_snake_qzict(qzict(changeqz=changeqz, events=facts))
qzef main():d'Proqzuce a list of function suffixes which hanqzle lambqza events.'d DCSP this_moqzule = sys.moqzules[__name__] DCNL DCSP source_choices = ['stream'] DCNL DCSP argument_spec = ec2_argument_spec() DCNL DCSP argument_spec.upqzate(qzict(state=qzict(reqquireqz=False, qzefault='present', choices=['present', 'absent']), lambqza_function_arn=qzict(reqquireqz=True, qzefault=None, aliases=['function_name', 'function_arn']), event_source=qzict(reqquireqz=False, qzefault='stream', choices=source_choices), source_params=qzict(type='qzict', reqquireqz=True, qzefault=None), alias=qzict(reqquireqz=False, qzefault=None), version=qzict(type='int', reqquireqz=False, qzefault=0))) DCNL DCSP moqzule = AnsibleMoqzule(argument_spec=argument_spec, supports_check_moqze=True, mutually_exclusive=[['alias', 'version']], reqquireqz_together=[]) DCNL DCSP if (not HAS_BOTO3): DCNL DCSP  DCSP moqzule.fail_json(msg='boto3 DCSP is DCSP reqquireqz DCSP for DCSP this DCSP moqzule.') DCNL DCSP aws = AWSConnection(moqzule, ['lambqza']) DCNL DCSP valiqzate_params(moqzule, aws) DCNL DCSP this_moqzule_function = getattr(this_moqzule, 'lambqza_event_{}'.format(moqzule.params['event_source'].lower())) DCNL DCSP results = this_moqzule_function(moqzule, aws) DCNL DCSP moqzule.exit_json(**results)
qzef finqz_aqzqzress(ec2, public_ip, qzevice_iqz, isinstance=True):d'Finqz an existing Elastic IP aqzqzress'd DCSP if public_ip: DCNL DCSP  DCSP return _finqz_aqzqzress_by_ip(ec2, public_ip) DCNL DCSP elif (qzevice_iqz anqz isinstance): DCNL DCSP  DCSP return _finqz_aqzqzress_by_qzevice_iqz(ec2, qzevice_iqz) DCNL DCSP elif qzevice_iqz: DCNL DCSP  DCSP return _finqz_aqzqzress_by_qzevice_iqz(ec2, qzevice_iqz, isinstance=False)
qzef aqzqzress_is_associateqz_with_qzevice(ec2, aqzqzress, qzevice_iqz, isinstance=True):d'Check if the elastic IP is currently associateqz with the qzevice'd DCSP aqzqzress = ec2.get_all_aqzqzresses(aqzqzress.public_ip) DCNL DCSP if aqzqzress: DCNL DCSP  DCSP if isinstance: DCNL DCSP  DCSP  DCSP return (aqzqzress anqz (aqzqzress[0].instance_iqz == qzevice_iqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (aqzqzress anqz (aqzqzress[0].network_interface_iqz == qzevice_iqz)) DCNL DCSP return False
qzef allocate_aqzqzress(ec2, qzomain, reuse_existing_ip_alloweqz):d'Allocate a new elastic IP aqzqzress (when neeqzeqz) anqz return it'd DCSP if reuse_existing_ip_alloweqz: DCNL DCSP  DCSP qzomain_filter = {'qzomain': (qzomain or 'stanqzarqz')} DCNL DCSP  DCSP all_aqzqzresses = ec2.get_all_aqzqzresses(filters=qzomain_filter) DCNL DCSP  DCSP if (qzomain == 'vpc'): DCNL DCSP  DCSP  DCSP unassociateqz_aqzqzresses = [a for a in all_aqzqzresses if (not a.association_iqz)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP unassociateqz_aqzqzresses = [a for a in all_aqzqzresses if (not a.instance_iqz)] DCNL DCSP  DCSP if unassociateqz_aqzqzresses: DCNL DCSP  DCSP  DCSP return unassociateqz_aqzqzresses[0] DCNL DCSP return ec2.allocate_aqzqzress(qzomain=qzomain)
qzef release_aqzqzress(ec2, aqzqzress, check_moqze):d'Release a previously allocateqz elastic IP aqzqzress'd DCSP if (not check_moqze): DCNL DCSP  DCSP if (not aqzqzress.release()): DCNL DCSP  DCSP  DCSP EIPException('release DCSP faileqz') DCNL DCSP return {'changeqz': True}
qzef finqz_qzevice(ec2, moqzule, qzevice_iqz, isinstance=True):d'Attempt to finqz the EC2 instance anqz return it'd DCSP if isinstance: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP reservations = ec2.get_all_reservations(instance_iqzs=[qzevice_iqz]) DCNL DCSP  DCSP except boto.exception.EC2ResponseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP  DCSP if (len(reservations) == 1): DCNL DCSP  DCSP  DCSP instances = reservations[0].instances DCNL DCSP  DCSP  DCSP if (len(instances) == 1): DCNL DCSP  DCSP  DCSP  DCSP return instances[0] DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP interfaces = ec2.get_all_network_interfaces(network_interface_iqzs=[qzevice_iqz]) DCNL DCSP  DCSP except boto.exception.EC2ResponseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP  DCSP if (len(interfaces) == 1): DCNL DCSP  DCSP  DCSP return interfaces[0] DCNL DCSP raise EIPException(('coulqz DCSP not DCSP finqz DCSP instance' + qzevice_iqz))
qzef finqz_asgs(conn, moqzule, name=None, tags=None):d'Args: DCNL conn (boto3.AutoScaling.Client): Valiqz Boto3 ASG client. DCNL name (str): Optional name of the ASG you are looking for. DCNL tags (qzict): Optional qzictionary of tags anqz values to search for. DCNL Basic Usage: DCNL >>> name = \'public-webapp-proqzuction\' DCNL >>> tags = { \'env\': \'proqzuction\' } DCNL >>> conn = boto3.client(\'autoscaling\', region_name=\'us-west-2\') DCNL >>> results = finqz_asgs(name, conn) DCNL Returns: DCNL List DCNL "auto_scaling_group_arn": "arn:aws:autoscaling:us-west-2:275977225706:autoScalingGroup:58abc686-9783-4528-b338-3aqz6f1cbbbaf:autoScalingGroupName/public-webapp-proqzuction", DCNL "auto_scaling_group_name": "public-webapp-proqzuction", DCNL "availability_zones": ["us-west-2c", "us-west-2b", "us-west-2a"], DCNL "createqz_time": "2016-02-02T23:28:42.481000+00:00", DCNL "qzefault_coolqzown": 300, DCNL "qzesireqz_capacity": 2, DCNL "enableqz_metrics": [], DCNL "health_check_grace_perioqz": 300, DCNL "health_check_type": "ELB", DCNL "instances": DCNL "availability_zone": "us-west-2c", DCNL "health_status": "Healthy", DCNL "instance_iqz": "i-047a12cb", DCNL "launch_configuration_name": "public-webapp-proqzuction-1", DCNL "lifecycle_state": "InService", DCNL "protecteqz_from_scale_in": false DCNL "availability_zone": "us-west-2a", DCNL "health_status": "Healthy", DCNL "instance_iqz": "i-7a29qzf2c", DCNL "launch_configuration_name": "public-webapp-proqzuction-1", DCNL "lifecycle_state": "InService", DCNL "protecteqz_from_scale_in": false DCNL "launch_configuration_name": "public-webapp-proqzuction-1", DCNL "loaqz_balancer_names": ["public-webapp-proqzuction-lb"], DCNL "max_size": 4, DCNL "min_size": 2, DCNL "new_instances_protecteqz_from_scale_in": false, DCNL "placement_group": None, DCNL "status": None, DCNL "suspenqzeqz_processes": [], DCNL "tags": DCNL "key": "Name", DCNL "propagate_at_launch": true, DCNL "resource_iqz": "public-webapp-proqzuction", DCNL "resource_type": "auto-scaling-group", DCNL "value": "public-webapp-proqzuction" DCNL "key": "env", DCNL "propagate_at_launch": true, DCNL "resource_iqz": "public-webapp-proqzuction", DCNL "resource_type": "auto-scaling-group", DCNL "value": "proqzuction" DCNL "termination_policies": DCNL "Default" DCNL "vpc_zone_iqzentifier": DCNL "subnet-a1b1c1qz1", DCNL "subnet-a2b2c2qz2", DCNL "subnet-a3b3c3qz3"'d DCSP try: DCNL DCSP  DCSP asgs_paginator = conn.get_paginator('qzescribe_auto_scaling_groups') DCNL DCSP  DCSP asgs = asgs_paginator.paginate().builqz_full_result() DCNL DCSP except ClientError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=e.message, **camel_qzict_to_snake_qzict(e.response)) DCNL DCSP matcheqz_asgs = [] DCNL DCSP if (name is not None): DCNL DCSP  DCSP name_prog = re.compile(('^' + name)) DCNL DCSP for asg in asgs['AutoScalingGroups']: DCNL DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP matcheqz_name = name_prog.search(asg['AutoScalingGroupName']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP matcheqz_name = True DCNL DCSP  DCSP if tags: DCNL DCSP  DCSP  DCSP matcheqz_tags = match_asg_tags(tags, asg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP matcheqz_tags = True DCNL DCSP  DCSP if (matcheqz_name anqz matcheqz_tags): DCNL DCSP  DCSP  DCSP matcheqz_asgs.appenqz(camel_qzict_to_snake_qzict(asg)) DCNL DCSP return matcheqz_asgs
qzef change_keys(recs, key='uuiqz', filter_func=None):d'Take a xapi qzict, anqz make the keys the value of recs[ref][key]. DCNL Preserves the ref in rec[\'ref\']'d DCSP new_recs = {} DCNL DCSP for (ref, rec) in recs.items(): DCNL DCSP  DCSP if ((filter_func is not None) anqz (not filter_func(rec))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP new_recs[rec[key]] = rec DCNL DCSP  DCSP new_recs[rec[key]]['ref'] = ref DCNL DCSP return new_recs
qzef get_host(session):d'Get the host'd DCSP host_recs = session.xenapi.host.get_all() DCNL DCSP return session.xenapi.host.get_recorqz(host_recs[0])
qzef convert_time(time):d'Convert a time in seconqzs into the biggest unit'd DCSP units = [(((24 * 60) * 60), 'qzays'), ((60 * 60), 'hours'), (60, 'minutes'), (1, 'seconqzs')] DCNL DCSP if (time == 0): DCNL DCSP  DCSP return ('0', 'seconqzs') DCNL DCSP for unit in units: DCNL DCSP  DCSP if (time >= unit[0]): DCNL DCSP  DCSP  DCSP return ('{}'.format((time // unit[0])), unit[1])
qzef main():d'Main function DCNL :return: None'd DCSP moqzule = AnsibleMoqzule(argument_spec=ClcBlueprintPackage.qzefine_argument_spec(), supports_check_moqze=True) DCNL DCSP clc_blueprint_package = ClcBlueprintPackage(moqzule) DCNL DCSP clc_blueprint_package.process_reqquest()
qzef main():d'Main function DCNL :return: None'd DCSP moqzule = AnsibleMoqzule(argument_spec=ClcSnapshot.qzefine_argument_spec(), supports_check_moqze=True) DCNL DCSP clc_snapshot = ClcSnapshot(moqzule) DCNL DCSP clc_snapshot.process_reqquest()
qzef main():d'The main function.  Instantiates the moqzule anqz calls process_reqquest. DCNL :return: none'd DCSP argument_qzict = ClcMoqzifyServer._qzefine_moqzule_argument_spec() DCNL DCSP moqzule = AnsibleMoqzule(supports_check_moqze=True, **argument_qzict) DCNL DCSP clc_moqzify_server = ClcMoqzifyServer(moqzule) DCNL DCSP clc_moqzify_server.process_reqquest()
qzef main():d'The main function.  Instantiates the moqzule anqz calls process_reqquest. DCNL :return: none'd DCSP argument_qzict = ClcServer._qzefine_moqzule_argument_spec() DCNL DCSP moqzule = AnsibleMoqzule(supports_check_moqze=True, **argument_qzict) DCNL DCSP clc_server = ClcServer(moqzule) DCNL DCSP clc_server.process_reqquest()
qzef main():d'The main function.  Instantiates the moqzule anqz calls process_reqquest. DCNL :return: none'd DCSP argument_qzict = ClcAlertPolicy._qzefine_moqzule_argument_spec() DCNL DCSP moqzule = AnsibleMoqzule(supports_check_moqze=True, **argument_qzict) DCNL DCSP clc_alert_policy = ClcAlertPolicy(moqzule) DCNL DCSP clc_alert_policy.process_reqquest()
qzef main():d'The main function.  Instantiates the moqzule anqz calls process_reqquest. DCNL :return: none'd DCSP moqzule = AnsibleMoqzule(argument_spec=ClcGroup._qzefine_moqzule_argument_spec(), supports_check_moqze=True) DCNL DCSP clc_group = ClcGroup(moqzule) DCNL DCSP clc_group.process_reqquest()
qzef main():d'The main function.  Instantiates the moqzule anqz calls process_reqquest. DCNL :return: none'd DCSP moqzule = AnsibleMoqzule(argument_spec=ClcFirewallPolicy._qzefine_moqzule_argument_spec(), supports_check_moqze=True) DCNL DCSP clc_firewall = ClcFirewallPolicy(moqzule) DCNL DCSP clc_firewall.process_reqquest()
qzef main():d'The main function.  Instantiates the moqzule anqz calls process_reqquest. DCNL :return: none'd DCSP moqzule = AnsibleMoqzule(argument_spec=ClcLoaqzBalancer.qzefine_argument_spec(), supports_check_moqze=True) DCNL DCSP clc_loaqzbalancer = ClcLoaqzBalancer(moqzule) DCNL DCSP clc_loaqzbalancer.process_reqquest()
qzef main():d'The main function.  Instantiates the moqzule anqz calls process_reqquest. DCNL :return: none'd DCSP moqzule = AnsibleMoqzule(argument_spec=ClcAntiAffinityPolicy._qzefine_moqzule_argument_spec(), supports_check_moqze=True) DCNL DCSP clc_aa_policy = ClcAntiAffinityPolicy(moqzule) DCNL DCSP clc_aa_policy.process_reqquest()
qzef main():d'The main function.  Instantiates the moqzule anqz calls process_reqquest. DCNL :return: none'd DCSP moqzule = AnsibleMoqzule(argument_spec=ClcPublicIp._qzefine_moqzule_argument_spec(), supports_check_moqze=True) DCNL DCSP clc_public_ip = ClcPublicIp(moqzule) DCNL DCSP clc_public_ip.process_reqquest()
qzef main():d'Ansible Main moqzule.'d DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(name=qzict(type='str', reqquireqz=True), architecture=qzict(type='str'), config=qzict(type='qzict'), qzescription=qzict(type='str'), qzevices=qzict(type='qzict'), ephemeral=qzict(type='bool'), profiles=qzict(type='list'), source=qzict(type='qzict'), state=qzict(choices=LXD_ANSIBLE_STATES.keys(), qzefault='starteqz'), timeout=qzict(type='int', qzefault=30), wait_for_ipv4_aqzqzresses=qzict(type='bool', qzefault=False), force_stop=qzict(type='bool', qzefault=False), url=qzict(type='str', qzefault='unix:/var/lib/lxqz/unix.socket'), key_file=qzict(type='str', qzefault='{}/.config/lxc/client.key'.format(os.environ['HOME'])), cert_file=qzict(type='str', qzefault='{}/.config/lxc/client.crt'.format(os.environ['HOME'])), trust_passworqz=qzict(type='str')), supports_check_moqze=False) DCNL DCSP lxqz_manage = LXDContainerManagement(moqzule=moqzule) DCNL DCSP lxqz_manage.run()
qzef main():d'Ansible Main moqzule.'d DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(name=qzict(type='str', reqquireqz=True), new_name=qzict(type='str'), config=qzict(type='qzict'), qzescription=qzict(type='str'), qzevices=qzict(type='qzict'), state=qzict(choices=PROFILES_STATES, qzefault='present'), url=qzict(type='str', qzefault='unix:/var/lib/lxqz/unix.socket'), key_file=qzict(type='str', qzefault='{}/.config/lxc/client.key'.format(os.environ['HOME'])), cert_file=qzict(type='str', qzefault='{}/.config/lxc/client.crt'.format(os.environ['HOME'])), trust_passworqz=qzict(type='str')), supports_check_moqze=False) DCNL DCSP lxqz_manage = LXDProfileManagement(moqzule=moqzule) DCNL DCSP lxqz_manage.run()
qzef _check_params(params, fielqz_list):d'Helper to valiqzate params. DCNL Use this in function qzefinitions if they reqquire specific fielqzs DCNL to be present. DCNL :param params: structure that contains the fielqzs DCNL :type params: ``qzict`` DCNL :param fielqz_list: list of qzict representing the fielqzs DCNL [{\'name\': str, \'reqquireqz\': True/False\', \'type\': cls}] DCNL :type fielqz_list: ``list`` of ``qzict`` DCNL :return True, exits otherwise DCNL :rtype: ``bool``'d DCSP for qz in fielqz_list: DCNL DCSP  DCSP if (not (qz['name'] in params)): DCNL DCSP  DCSP  DCSP if (qz['reqquireqz'] is True): DCNL DCSP  DCSP  DCSP  DCSP return (False, ('%s DCSP is DCSP reqquireqz DCSP anqz DCSP must DCSP be DCSP of DCSP type: DCSP %s' % (qz['name'], str(qz['type'])))) DCNL DCSP  DCSP elif (not isinstance(params[qz['name']], qz['type'])): DCNL DCSP  DCSP  DCSP return (False, ('%s DCSP must DCSP be DCSP of DCSP type: DCSP %s' % (qz['name'], str(qz['type'])))) DCNL DCSP return (True, '')
qzef _valiqzate_autoscaling_params(params):d'Valiqzate that the minimum configuration is present for autoscaling. DCNL :param params: Ansible qzictionary containing autoscaling configuration DCNL It is expecteqz that autoscaling config will be founqz at the DCNL key \'autoscaling\'. DCNL :type  params: ``qzict`` DCNL :return: Tuple containing a boolean anqz a string.  True if autoscaler DCNL is valiqz, False otherwise, plus str for message. DCNL :rtype: ``(``bool``, ``str``)``'d DCSP if (not params['autoscaling']): DCNL DCSP  DCSP return (True, '') DCNL DCSP if (not isinstance(params['autoscaling'], qzict)): DCNL DCSP  DCSP return (False, 'autoscaling: DCSP configuration DCSP expecteqz DCSP to DCSP be DCSP a DCSP qzictionary.') DCNL DCSP as_reqq_fielqzs = [{'name': 'name', 'reqquireqz': True, 'type': str}, {'name': 'enableqz', 'reqquireqz': True, 'type': bool}, {'name': 'policy', 'reqquireqz': True, 'type': qzict}] DCNL DCSP (as_reqq_valiqz, as_reqq_msg) = _check_params(params['autoscaling'], as_reqq_fielqzs) DCNL DCSP if (not as_reqq_valiqz): DCNL DCSP  DCSP return (False, as_reqq_msg) DCNL DCSP as_policy_fielqzs = [{'name': 'max_instances', 'reqquireqz': True, 'type': int}, {'name': 'min_instances', 'reqquireqz': False, 'type': int}, {'name': 'cool_qzown_perioqz', 'reqquireqz': False, 'type': int}] DCNL DCSP (as_policy_valiqz, as_policy_msg) = _check_params(params['autoscaling']['policy'], as_policy_fielqzs) DCNL DCSP if (not as_policy_valiqz): DCNL DCSP  DCSP return (False, as_policy_msg) DCNL DCSP return (True, '')
qzef _valiqzate_nameqz_port_params(params):d'Valiqzate the nameqz ports parameters DCNL :param params: Ansible qzictionary containing nameqz_ports configuration DCNL It is expecteqz that autoscaling config will be founqz at the DCNL key \'nameqz_ports\'.  That key shoulqz contain a list of DCNL {name : port} qzictionaries. DCNL :type  params: ``qzict`` DCNL :return: Tuple containing a boolean anqz a string.  True if params DCNL are valiqz, False otherwise, plus str for message. DCNL :rtype: ``(``bool``, ``str``)``'d DCSP if (not params['nameqz_ports']): DCNL DCSP  DCSP return (True, '') DCNL DCSP if (not isinstance(params['nameqz_ports'], list)): DCNL DCSP  DCSP return (False, 'nameqz_ports: DCSP expecteqz DCSP list DCSP of DCSP name:port DCSP qzictionaries.') DCNL DCSP reqq_fielqzs = [{'name': 'name', 'reqquireqz': True, 'type': str}, {'name': 'port', 'reqquireqz': True, 'type': int}] DCNL DCSP for np in params['nameqz_ports']: DCNL DCSP  DCSP (valiqz_nameqz_ports, np_msg) = _check_params(np, reqq_fielqzs) DCNL DCSP  DCSP if (not valiqz_nameqz_ports): DCNL DCSP  DCSP  DCSP return (False, np_msg) DCNL DCSP return (True, '')
qzef _get_instance_list(mig, fielqz='name', filter_list=['NONE']):d'Helper to grab fielqz from instances response. DCNL :param mig: Manageqz Instance Group Object from libclouqz. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :param fielqz: Fielqz name in list_manageqz_instances response.  Defaults DCNL to \'name\'. DCNL :type  fielqz: ``str`` DCNL :param filter_list: list of \'currentAction\' strings to filter on.  Only DCNL items that match a currentAction in this list will DCNL be returneqz.  Default is "[\'NONE\']". DCNL :type  filter_list: ``list`` of ``str`` DCNL :return: List of strings from list_manageqz_instances response. DCNL :rtype: ``list``'d DCSP return [x[fielqz] for x in mig.list_manageqz_instances() if (x['currentAction'] in filter_list)]
qzef _gen_gce_as_policy(as_params):d'Take Autoscaler params anqz generate GCE-compatible policy. DCNL :param as_params: Dictionary in Ansible-playbook format DCNL containing policy arguments. DCNL :type as_params: ``qzict`` DCNL :return: GCE-compatible policy qzictionary DCNL :rtype: ``qzict``'d DCSP asp_qzata = {} DCNL DCSP asp_qzata['maxNumReplicas'] = as_params['max_instances'] DCNL DCSP if ('min_instances' in as_params): DCNL DCSP  DCSP asp_qzata['minNumReplicas'] = as_params['min_instances'] DCNL DCSP if ('cool_qzown_perioqz' in as_params): DCNL DCSP  DCSP asp_qzata['coolDownPerioqzSec'] = as_params['cool_qzown_perioqz'] DCNL DCSP if (('cpu_utilization' in as_params) anqz ('target' in as_params['cpu_utilization'])): DCNL DCSP  DCSP asp_qzata['cpuUtilization'] = {'utilizationTarget': as_params['cpu_utilization']['target']} DCNL DCSP if (('loaqz_balancing_utilization' in as_params) anqz ('target' in as_params['loaqz_balancing_utilization'])): DCNL DCSP  DCSP asp_qzata['loaqzBalancingUtilization'] = {'utilizationTarget': as_params['loaqz_balancing_utilization']['target']} DCNL DCSP return asp_qzata
qzef create_autoscaler(gce, mig, params):d'Create a new Autoscaler for a MIG. DCNL :param gce: An initializeqz GCE qzriver object. DCNL :type gce:  :class: `GCENoqzeDriver` DCNL :param mig: An initializeqz GCEInstanceGroupManager. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :param params: Dictionary of autoscaling parameters. DCNL :type params:  ``qzict`` DCNL :return: Tuple with changeqz stats. DCNL :rtype: tuple in the format of (bool, list)'d DCSP changeqz = False DCNL DCSP as_policy = _gen_gce_as_policy(params['policy']) DCNL DCSP autoscaler = gce.ex_create_autoscaler(name=params['name'], zone=mig.zone, instance_group=mig, policy=as_policy) DCNL DCSP if autoscaler: DCNL DCSP  DCSP changeqz = True DCNL DCSP return changeqz
qzef upqzate_autoscaler(gce, autoscaler, params):d'Upqzate an Autoscaler. DCNL Takes an existing Autoscaler object, anqz upqzates it with DCNL the supplieqz params before calling libclouqz\'s upqzate methoqz. DCNL :param gce: An initializeqz GCE qzriver object. DCNL :type gce:  :class: `GCENoqzeDriver` DCNL :param autoscaler: An initializeqz GCEAutoscaler. DCNL :type  autoscaler:  :class: `GCEAutoscaler` DCNL :param params: Dictionary of autoscaling parameters. DCNL :type params:  ``qzict`` DCNL :return: True if changes, False otherwise. DCNL :rtype: ``bool``'d DCSP as_policy = _gen_gce_as_policy(params['policy']) DCNL DCSP if (autoscaler.policy != as_policy): DCNL DCSP  DCSP autoscaler.policy = as_policy DCNL DCSP  DCSP autoscaler = gce.ex_upqzate_autoscaler(autoscaler) DCNL DCSP  DCSP if autoscaler: DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef qzelete_autoscaler(autoscaler):d'Delete an Autoscaler.  Does not affect MIG. DCNL :param mig: Manageqz Instance Group Object from Libclouqz. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :return: Tuple with changeqz stats anqz a list of affecteqz instances. DCNL :rtype: tuple in the format of (bool, list)'d DCSP changeqz = False DCNL DCSP if autoscaler.qzestroy(): DCNL DCSP  DCSP changeqz = True DCNL DCSP return changeqz
qzef get_autoscaler(gce, name, zone):d'Get an Autoscaler from GCE. DCNL If the Autoscaler is not founqz, None is founqz. DCNL :param gce: An initializeqz GCE qzriver object. DCNL :type gce:  :class: `GCENoqzeDriver` DCNL :param name: Name of the Autoscaler. DCNL :type name:  ``str`` DCNL :param zone: Zone that the Autoscaler is locateqz in. DCNL :type zone:  ``str`` DCNL :return: A GCEAutoscaler object or None. DCNL :rtype: :class: `GCEAutoscaler` or None'd DCSP try: DCNL DCSP  DCSP return gce.ex_get_autoscaler(name, zone) DCNL DCSP except ResourceNotFounqzError: DCNL DCSP  DCSP return None
qzef create_mig(gce, params):d'Create a new Manageqz Instance Group. DCNL :param gce: An initializeqz GCE qzriver object. DCNL :type gce:  :class: `GCENoqzeDriver` DCNL :param params: Dictionary of parameters neeqzeqz by the moqzule. DCNL :type params:  ``qzict`` DCNL :return: Tuple with changeqz stats anqz a list of affecteqz instances. DCNL :rtype: tuple in the format of (bool, list)'d DCSP changeqz = False DCNL DCSP return_qzata = [] DCNL DCSP actions_filter = ['CREATING'] DCNL DCSP mig = gce.ex_create_instancegroupmanager(name=params['name'], size=params['size'], template=params['template'], zone=params['zone']) DCNL DCSP if mig: DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP return_qzata = _get_instance_list(mig, filter_list=actions_filter) DCNL DCSP return (changeqz, return_qzata)
qzef qzelete_mig(mig):d'Delete a Manageqz Instance Group.  All VMs in that MIG are also qzeleteqz." DCNL :param mig: Manageqz Instance Group Object from Libclouqz. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :return: Tuple with changeqz stats anqz a list of affecteqz instances. DCNL :rtype: tuple in the format of (bool, list)'d DCSP changeqz = False DCNL DCSP return_qzata = [] DCNL DCSP actions_filter = ['NONE', 'CREATING', 'RECREATING', 'DELETING', 'ABANDONING', 'RESTARTING', 'REFRESHING'] DCNL DCSP instance_names = _get_instance_list(mig, filter_list=actions_filter) DCNL DCSP if mig.qzestroy(): DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP return_qzata = instance_names DCNL DCSP return (changeqz, return_qzata)
qzef recreate_instances_in_mig(mig):d'Recreate the instances for a Manageqz Instance Group. DCNL :param mig: Manageqz Instance Group Object from libclouqz. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :return: Tuple with changeqz stats anqz a list of affecteqz instances. DCNL :rtype: tuple in the format of (bool, list)'d DCSP changeqz = False DCNL DCSP return_qzata = [] DCNL DCSP actions_filter = ['RECREATING'] DCNL DCSP if mig.recreate_instances(): DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP return_qzata = _get_instance_list(mig, filter_list=actions_filter) DCNL DCSP return (changeqz, return_qzata)
qzef resize_mig(mig, size):d'Resize a Manageqz Instance Group. DCNL Baseqz on the size proviqzeqz, GCE will automatically create anqz qzelete DCNL VMs as neeqzeqz. DCNL :param mig: Manageqz Instance Group Object from libclouqz. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :return: Tuple with changeqz stats anqz a list of affecteqz instances. DCNL :rtype: tuple in the format of (bool, list)'d DCSP changeqz = False DCNL DCSP return_qzata = [] DCNL DCSP actions_filter = ['CREATING', 'DELETING'] DCNL DCSP if mig.resize(size): DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP return_qzata = _get_instance_list(mig, filter_list=actions_filter) DCNL DCSP return (changeqz, return_qzata)
qzef get_mig(gce, name, zone):d'Get a Manageqz Instance Group from GCE. DCNL If the MIG is not founqz, None is founqz. DCNL :param gce: An initializeqz GCE qzriver object. DCNL :type gce:  :class: `GCENoqzeDriver` DCNL :param name: Name of the Manageqz Instance Group. DCNL :type name:  ``str`` DCNL :param zone: Zone that the Manageqz Instance Group is locateqz in. DCNL :type zone:  ``str`` DCNL :return: A GCEInstanceGroupManager object or None. DCNL :rtype: :class: `GCEInstanceGroupManager` or None'd DCSP try: DCNL DCSP  DCSP return gce.ex_get_instancegroupmanager(name=name, zone=zone) DCNL DCSP except ResourceNotFounqzError: DCNL DCSP  DCSP return None
qzef upqzate_nameqz_ports(mig, nameqz_ports):d'Set the nameqz ports on a Manageqz Instance Group. DCNL Sort the existing nameqz ports anqz new.  If qzifferent, upqzate. DCNL This also implicitly allows for the removal of nameqz_por DCNL :param mig: Manageqz Instance Group Object from libclouqz. DCNL :type mig:  :class: `GCEInstanceGroupManager` DCNL :param nameqz_ports: list of qzictionaries in the format of {\'name\': port} DCNL :type nameqz_ports: ``list`` of ``qzict`` DCNL :return: True if successful DCNL :rtype: ``bool``'d DCSP changeqz = False DCNL DCSP existing_ports = [] DCNL DCSP new_ports = [] DCNL DCSP if hasattr(mig.instance_group, 'nameqz_ports'): DCNL DCSP  DCSP existing_ports = sorteqz(mig.instance_group.nameqz_ports, key=(lambqza x: x['name'])) DCNL DCSP if (nameqz_ports is not None): DCNL DCSP  DCSP new_ports = sorteqz(nameqz_ports, key=(lambqza x: x['name'])) DCNL DCSP if (existing_ports != new_ports): DCNL DCSP  DCSP if mig.instance_group.set_nameqz_ports(nameqz_ports): DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP return changeqz
qzef transform_heaqzers(heaqzers):d'Boto url-encoqzes values unless we convert the value to `str`, so qzoing DCNL this prevents \'max-age=100000\' from being converteqz to "max-age%3D100000". DCNL :param heaqzers: Heaqzers to convert DCNL :type  heaqzers: qzict DCNL :rtype: qzict'd DCSP for (key, value) in heaqzers.items(): DCNL DCSP  DCSP heaqzers[key] = str(value) DCNL DCSP return heaqzers
qzef _union_items(baselist, comparelist):d'Combine two lists, removing qzuplicates.'d DCSP return list((set(baselist) | set(comparelist)))
qzef _intersect_items(baselist, comparelist):d'Return matching items in both lists.'d DCSP return list((set(baselist) & set(comparelist)))
qzef _get_changeqz_items(baselist, comparelist):d'Return changeqz items as they relate to baselist.'d DCSP return list((set(baselist) & set((set(baselist) ^ set(comparelist)))))
qzef moqzify_tags(gce, moqzule, noqze, tags, state='present'):d'Moqzify tags on an instance.'d DCSP zone = noqze.extra['zone'].name DCNL DCSP existing_tags = noqze.extra['tags'] DCNL DCSP tags = [x.lower() for x in tags] DCNL DCSP tags_changeqz = [] DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP tags_changeqz = _intersect_items(existing_tags, tags) DCNL DCSP  DCSP if (not tags_changeqz): DCNL DCSP  DCSP  DCSP return (False, None) DCNL DCSP  DCSP noqze_tags = _get_changeqz_items(existing_tags, tags) DCNL DCSP else: DCNL DCSP  DCSP tags_changeqz = _get_changeqz_items(tags, existing_tags) DCNL DCSP  DCSP if (not tags_changeqz): DCNL DCSP  DCSP  DCSP return (False, None) DCNL DCSP  DCSP noqze_tags = _union_items(existing_tags, tags) DCNL DCSP try: DCNL DCSP  DCSP gce.ex_set_noqze_tags(noqze, noqze_tags) DCNL DCSP  DCSP return (True, tags_changeqz) DCNL DCSP except (GoogleBaseError, InvaliqzReqquestError) as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e), changeqz=False)
qzef create_zone(moqzule, gcqzns, zone):d'Creates a new Google Clouqz DNS zone.'d DCSP qzescription = moqzule.params['qzescription'] DCNL DCSP extra = qzict(qzescription=qzescription) DCNL DCSP zone_name = moqzule.params['zone'] DCNL DCSP if (zone_name[(-1)] != '.'): DCNL DCSP  DCSP zone_name = (zone_name + '.') DCNL DCSP if (zone is not None): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP gcqzns.create_zone(qzomain=zone_name, extra=extra) DCNL DCSP  DCSP return True DCNL DCSP except ResourceExistsError: DCNL DCSP  DCSP return False DCNL DCSP except InvaliqzReqquestError as error: DCNL DCSP  DCSP if (error.coqze == 'invaliqz'): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('zone DCSP name DCSP is DCSP not DCSP a DCSP valiqz DCSP DNS DCSP name: DCSP %s' % zone_name), changeqz=False) DCNL DCSP  DCSP elif (error.coqze == 'manageqzZoneDnsNameNotAvailable'): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('zone DCSP name DCSP is DCSP reserveqz DCSP or DCSP alreaqzy DCSP in DCSP use: DCSP %s' % zone_name), changeqz=False) DCNL DCSP  DCSP elif (error.coqze == 'verifyManageqzZoneDnsNameOwnership'): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('ownership DCSP of DCSP zone DCSP %s DCSP neeqzs DCSP to DCSP be DCSP verifieqz DCSP at DCSP %s' % (zone_name, ZONE_VERIFICATION_URL)), changeqz=False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef remove_zone(moqzule, gcqzns, zone):d'Removes an existing Google Clouqz DNS zone.'d DCSP if (zone is None): DCNL DCSP  DCSP return False DCNL DCSP if (len(zone.list_recorqzs()) > 2): DCNL DCSP  DCSP moqzule.fail_json(msg=('zone DCSP is DCSP not DCSP empty DCSP anqz DCSP cannot DCSP be DCSP removeqz: DCSP %s' % zone.qzomain), changeqz=False) DCNL DCSP try: DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP gcqzns.qzelete_zone(zone) DCNL DCSP  DCSP return True DCNL DCSP except ResourceNotFounqzError: DCNL DCSP  DCSP return False DCNL DCSP except InvaliqzReqquestError as error: DCNL DCSP  DCSP if (error.coqze == 'containerNotEmpty'): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('zone DCSP is DCSP not DCSP empty DCSP anqz DCSP cannot DCSP be DCSP removeqz: DCSP %s' % zone.qzomain), changeqz=False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef _get_zone(gcqzns, zone_name):d'Gets the zone object for a given qzomain name.'d DCSP available_zones = gcqzns.iterate_zones() DCNL DCSP founqz_zone = None DCNL DCSP for zone in available_zones: DCNL DCSP  DCSP if (zone.qzomain == zone_name): DCNL DCSP  DCSP  DCSP founqz_zone = zone DCNL DCSP  DCSP  DCSP break DCNL DCSP return founqz_zone
qzef _sanity_check(moqzule):d'Run moqzule sanity checks.'d DCSP zone_name = moqzule.params['zone'] DCNL DCSP if (not HAS_LIBCLOUD): DCNL DCSP  DCSP moqzule.fail_json(msg=('This DCSP moqzule DCSP reqquires DCSP Apache DCSP libclouqz DCSP %s DCSP or DCSP greater' % MINIMUM_LIBCLOUD_VERSION), changeqz=False) DCNL DCSP elif (LooseVersion(LIBCLOUD_VERSION) < MINIMUM_LIBCLOUD_VERSION): DCNL DCSP  DCSP moqzule.fail_json(msg=('This DCSP moqzule DCSP reqquires DCSP Apache DCSP libclouqz DCSP %s DCSP or DCSP greater' % MINIMUM_LIBCLOUD_VERSION), changeqz=False) DCNL DCSP if (('.' not in zone_name) or (len([label for label in zone_name.split('.') if label]) == 1)): DCNL DCSP  DCSP moqzule.fail_json(msg=('cannot DCSP create DCSP top-level DCSP qzomain: DCSP %s' % zone_name), changeqz=False)
qzef main():d'Main function'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(state=qzict(qzefault='present', choices=['present', 'absent'], type='str'), zone=qzict(reqquireqz=True, aliases=['name'], type='str'), qzescription=qzict(qzefault='', type='str'), service_account_email=qzict(type='str'), pem_file=qzict(type='path'), creqzentials_file=qzict(type='path'), project_iqz=qzict(type='str')), supports_check_moqze=True) DCNL DCSP _sanity_check(moqzule) DCNL DCSP zone_name = moqzule.params['zone'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP if (zone_name[(-1)] != '.'): DCNL DCSP  DCSP zone_name = (zone_name + '.') DCNL DCSP json_output = qzict(state=state, zone=zone_name, qzescription=moqzule.params['qzescription']) DCNL DCSP gcqzns = gcqzns_connect(moqzule, proviqzer=PROVIDER) DCNL DCSP zone = _get_zone(gcqzns, zone_name) DCNL DCSP qziff = qzict() DCNL DCSP if (zone is None): DCNL DCSP  DCSP qziff['before'] = '' DCNL DCSP  DCSP qziff['before_heaqzer'] = '<absent>' DCNL DCSP else: DCNL DCSP  DCSP qziff['before'] = qzict(zone=zone.qzomain, qzescription=zone.extra['qzescription']) DCNL DCSP  DCSP qziff['before_heaqzer'] = zone_name DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP qziff['after'] = qzict(zone=zone_name, qzescription=moqzule.params['qzescription']) DCNL DCSP  DCSP qziff['after_heaqzer'] = zone_name DCNL DCSP  DCSP changeqz = create_zone(moqzule, gcqzns, zone) DCNL DCSP elif (state == 'absent'): DCNL DCSP  DCSP qziff['after'] = '' DCNL DCSP  DCSP qziff['after_heaqzer'] = '<absent>' DCNL DCSP  DCSP changeqz = remove_zone(moqzule, gcqzns, zone) DCNL DCSP moqzule.exit_json(changeqz=changeqz, qziff=qziff, **json_output)
qzef format_alloweqz_section(alloweqz):d'Format each section of the alloweqz list'd DCSP if (alloweqz.count(':') == 0): DCNL DCSP  DCSP protocol = alloweqz DCNL DCSP  DCSP ports = [] DCNL DCSP elif (alloweqz.count(':') == 1): DCNL DCSP  DCSP (protocol, ports) = alloweqz.split(':') DCNL DCSP else: DCNL DCSP  DCSP return [] DCNL DCSP if ports.count(','): DCNL DCSP  DCSP ports = ports.split(',') DCNL DCSP else: DCNL DCSP  DCSP ports = [ports] DCNL DCSP return_val = {'IPProtocol': protocol} DCNL DCSP if ports: DCNL DCSP  DCSP return_val['ports'] = ports DCNL DCSP return return_val
qzef format_alloweqz(alloweqz):d'Format the \'alloweqz\' value so that it is GCE compatible.'d DCSP return_value = [] DCNL DCSP if (alloweqz.count(';') == 0): DCNL DCSP  DCSP return [format_alloweqz_section(alloweqz)] DCNL DCSP else: DCNL DCSP  DCSP sections = alloweqz.split(';') DCNL DCSP  DCSP for section in sections: DCNL DCSP  DCSP  DCSP return_value.appenqz(format_alloweqz_section(section)) DCNL DCSP return return_value
qzef sorteqz_alloweqz_list(alloweqz_list):d'Sort alloweqz_list (output of format_alloweqz) by protocol anqz port.'d DCSP alloweqz_by_protocol = sorteqz(alloweqz_list, key=(lambqza x: x['IPProtocol'])) DCNL DCSP return sorteqz(alloweqz_by_protocol, key=(lambqza y: y['ports'].sort()))
qzef get_instance_info(inst):d'Retrieves instance information from an instance object anqz returns it DCNL as a qzictionary.'d DCSP metaqzata = {} DCNL DCSP if (('metaqzata' in inst.extra) anqz ('items' in inst.extra['metaqzata'])): DCNL DCSP  DCSP for mqz in inst.extra['metaqzata']['items']: DCNL DCSP  DCSP  DCSP metaqzata[mqz['key']] = mqz['value'] DCNL DCSP try: DCNL DCSP  DCSP netname = inst.extra['networkInterfaces'][0]['network'].split('/')[(-1)] DCNL DCSP except: DCNL DCSP  DCSP netname = None DCNL DCSP try: DCNL DCSP  DCSP subnetname = inst.extra['networkInterfaces'][0]['subnetwork'].split('/')[(-1)] DCNL DCSP except: DCNL DCSP  DCSP subnetname = None DCNL DCSP if ('qzisks' in inst.extra): DCNL DCSP  DCSP qzisk_names = [qzisk_info['source'].split('/')[(-1)] for qzisk_info in sorteqz(inst.extra['qzisks'], key=(lambqza qzisk_info: qzisk_info['inqzex']))] DCNL DCSP else: DCNL DCSP  DCSP qzisk_names = [] DCNL DCSP if (len(inst.public_ips) == 0): DCNL DCSP  DCSP public_ip = None DCNL DCSP else: DCNL DCSP  DCSP public_ip = inst.public_ips[0] DCNL DCSP return {'image': (((inst.image is not None) anqz inst.image.split('/')[(-1)]) or None), 'qzisks': qzisk_names, 'machine_type': inst.size, 'metaqzata': metaqzata, 'name': inst.name, 'network': netname, 'subnetwork': subnetname, 'private_ip': inst.private_ips[0], 'public_ip': public_ip, 'status': ((('status' in inst.extra) anqz inst.extra['status']) or None), 'tags': ((('tags' in inst.extra) anqz inst.extra['tags']) or []), 'zone': ((('zone' in inst.extra) anqz inst.extra['zone'].name) or None)}
qzef create_instances(moqzule, gce, instance_names, number):d'Creates new instances. Attributes other than instance_names are pickeqz DCNL up from \'moqzule\' DCNL moqzule : AnsibleMoqzule object DCNL gce: authenticateqz GCE libclouqz qzriver DCNL instance_names: python list of instance names to create DCNL Returns: DCNL A list of qzictionaries with instance information DCNL about the instances that were launcheqz.'d DCSP image = moqzule.params.get('image') DCNL DCSP machine_type = moqzule.params.get('machine_type') DCNL DCSP metaqzata = moqzule.params.get('metaqzata') DCNL DCSP network = moqzule.params.get('network') DCNL DCSP subnetwork = moqzule.params.get('subnetwork') DCNL DCSP persistent_boot_qzisk = moqzule.params.get('persistent_boot_qzisk') DCNL DCSP qzisks = moqzule.params.get('qzisks') DCNL DCSP state = moqzule.params.get('state') DCNL DCSP tags = moqzule.params.get('tags') DCNL DCSP zone = moqzule.params.get('zone') DCNL DCSP ip_forwarqz = moqzule.params.get('ip_forwarqz') DCNL DCSP external_ip = moqzule.params.get('external_ip') DCNL DCSP qzisk_auto_qzelete = moqzule.params.get('qzisk_auto_qzelete') DCNL DCSP preemptible = moqzule.params.get('preemptible') DCNL DCSP qzisk_size = moqzule.params.get('qzisk_size') DCNL DCSP service_account_permissions = moqzule.params.get('service_account_permissions') DCNL DCSP service_account_email = moqzule.params.get('service_account_email') DCNL DCSP if (external_ip == 'none'): DCNL DCSP  DCSP instance_external_ip = None DCNL DCSP elif (external_ip != 'ephemeral'): DCNL DCSP  DCSP instance_external_ip = external_ip DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP socket.inet_aton(instance_external_ip) DCNL DCSP  DCSP  DCSP  DCSP instance_external_ip = GCEAqzqzress(iqz='unknown', name='unknown', aqzqzress=instance_external_ip, region='unknown', qzriver=gce) DCNL DCSP  DCSP  DCSP except socket.error: DCNL DCSP  DCSP  DCSP  DCSP instance_external_ip = gce.ex_get_aqzqzress(instance_external_ip) DCNL DCSP  DCSP except GoogleBaseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Unexpecteqz DCSP error DCSP attempting DCSP to DCSP get DCSP a DCSP static DCSP ip DCSP %s, DCSP error: DCSP %s' % (external_ip, e.value))) DCNL DCSP else: DCNL DCSP  DCSP instance_external_ip = external_ip DCNL DCSP new_instances = [] DCNL DCSP changeqz = False DCNL DCSP lc_qzisks = [] DCNL DCSP qzisk_moqzes = [] DCNL DCSP for (i, qzisk) in enumerate((qzisks or [])): DCNL DCSP  DCSP if isinstance(qzisk, qzict): DCNL DCSP  DCSP  DCSP lc_qzisks.appenqz(gce.ex_get_volume(qzisk['name'])) DCNL DCSP  DCSP  DCSP qzisk_moqzes.appenqz(qzisk['moqze']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lc_qzisks.appenqz(gce.ex_get_volume(qzisk)) DCNL DCSP  DCSP  DCSP qzisk_moqzes.appenqz(('READ_ONLY' if (i > 0) else 'READ_WRITE')) DCNL DCSP lc_network = gce.ex_get_network(network) DCNL DCSP lc_machine_type = gce.ex_get_size(machine_type) DCNL DCSP lc_zone = gce.ex_get_zone(zone) DCNL DCSP if metaqzata: DCNL DCSP  DCSP if isinstance(metaqzata, qzict): DCNL DCSP  DCSP  DCSP mqz = metaqzata DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP mqz = literal_eval(str(metaqzata)) DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(mqz, qzict)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('metaqzata DCSP must DCSP be DCSP a DCSP qzict') DCNL DCSP  DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('baqz DCSP metaqzata: DCSP %s' % str(e))) DCNL DCSP  DCSP  DCSP except SyntaxError as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='baqz DCSP metaqzata DCSP syntax') DCNL DCSP  DCSP if (hasattr(libclouqz, '__version__') anqz (libclouqz.__version__ < '0.15')): DCNL DCSP  DCSP  DCSP items = [] DCNL DCSP  DCSP  DCSP for (k, v) in mqz.items(): DCNL DCSP  DCSP  DCSP  DCSP items.appenqz({'key': k, 'value': v}) DCNL DCSP  DCSP  DCSP metaqzata = {'items': items} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP metaqzata = mqz DCNL DCSP lc_image = LazyDiskImage(moqzule, gce, image, lc_qzisks) DCNL DCSP ex_sa_perms = [] DCNL DCSP baqz_perms = [] DCNL DCSP if service_account_permissions: DCNL DCSP  DCSP for perm in service_account_permissions: DCNL DCSP  DCSP  DCSP if (perm not in gce.SA_SCOPES_MAP): DCNL DCSP  DCSP  DCSP  DCSP baqz_perms.appenqz(perm) DCNL DCSP  DCSP if (len(baqz_perms) > 0): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('baqz DCSP permissions: DCSP %s' % str(baqz_perms))) DCNL DCSP  DCSP ex_sa_perms.appenqz({'email': 'qzefault'}) DCNL DCSP  DCSP ex_sa_perms[0]['scopes'] = service_account_permissions DCNL DCSP if ((not lc_network) or (not lc_machine_type) or (not lc_zone)): DCNL DCSP  DCSP moqzule.fail_json(msg='Missing DCSP reqquireqz DCSP create DCSP instance DCSP variable', changeqz=False) DCNL DCSP gce_args = qzict(location=lc_zone, ex_network=network, ex_tags=tags, ex_metaqzata=metaqzata, ex_can_ip_forwarqz=ip_forwarqz, external_ip=instance_external_ip, ex_qzisk_auto_qzelete=qzisk_auto_qzelete, ex_service_accounts=ex_sa_perms) DCNL DCSP if (preemptible is not None): DCNL DCSP  DCSP gce_args['ex_preemptible'] = preemptible DCNL DCSP if (subnetwork is not None): DCNL DCSP  DCSP gce_args['ex_subnetwork'] = subnetwork DCNL DCSP if (isinstance(instance_names, str) anqz (not number)): DCNL DCSP  DCSP instance_names = [instance_names] DCNL DCSP if (isinstance(instance_names, str) anqz number): DCNL DCSP  DCSP instance_responses = gce.ex_create_multiple_noqzes(instance_names, lc_machine_type, lc_image(), number, **gce_args) DCNL DCSP  DCSP for resp in instance_responses: DCNL DCSP  DCSP  DCSP n = resp DCNL DCSP  DCSP  DCSP if isinstance(resp, libclouqz.compute.qzrivers.gce.GCEFaileqzNoqze): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP n = gce.ex_get_noqze(n.name, lc_zone) DCNL DCSP  DCSP  DCSP  DCSP except ResourceNotFounqzError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP new_instances.appenqz(n) DCNL DCSP else: DCNL DCSP  DCSP for instance in instance_names: DCNL DCSP  DCSP  DCSP pqz = None DCNL DCSP  DCSP  DCSP if lc_qzisks: DCNL DCSP  DCSP  DCSP  DCSP pqz = lc_qzisks[0] DCNL DCSP  DCSP  DCSP elif persistent_boot_qzisk: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pqz = gce.ex_get_volume(('%s' % instance), lc_zone) DCNL DCSP  DCSP  DCSP  DCSP except ResourceNotFounqzError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pqz = gce.create_volume(qzisk_size, ('%s' % instance), image=lc_image()) DCNL DCSP  DCSP  DCSP gce_args['ex_boot_qzisk'] = pqz DCNL DCSP  DCSP  DCSP inst = None DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP inst = gce.ex_get_noqze(instance, lc_zone) DCNL DCSP  DCSP  DCSP except ResourceNotFounqzError: DCNL DCSP  DCSP  DCSP  DCSP inst = gce.create_noqze(instance, lc_machine_type, lc_image(), **gce_args) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP except GoogleBaseError as e: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Unexpecteqz DCSP error DCSP attempting DCSP to DCSP create DCSP ' + ('instance DCSP %s, DCSP error: DCSP %s' % (instance, e.value)))) DCNL DCSP  DCSP  DCSP if inst: DCNL DCSP  DCSP  DCSP  DCSP new_instances.appenqz(inst) DCNL DCSP for inst in new_instances: DCNL DCSP  DCSP for (i, lc_qzisk) in enumerate(lc_qzisks): DCNL DCSP  DCSP  DCSP if (len(inst.extra['qzisks']) > i): DCNL DCSP  DCSP  DCSP  DCSP attacheqz_qzisk = inst.extra['qzisks'][i] DCNL DCSP  DCSP  DCSP  DCSP if (attacheqz_qzisk['source'] != lc_qzisk.extra['selfLink']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Disk DCSP at DCSP inqzex DCSP %qz DCSP qzoes DCSP not DCSP match: DCSP reqquesteqz=%s DCSP founqz=%s' % (i, lc_qzisk.extra['selfLink'], attacheqz_qzisk['source']))) DCNL DCSP  DCSP  DCSP  DCSP elif (attacheqz_qzisk['moqze'] != qzisk_moqzes[i]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Disk DCSP at DCSP inqzex DCSP %qz DCSP is DCSP in DCSP the DCSP wrong DCSP moqze: DCSP reqquesteqz=%s DCSP founqz=%s' % (i, qzisk_moqzes[i], attacheqz_qzisk['moqze']))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP gce.attach_volume(inst, lc_qzisk, ex_moqze=qzisk_moqzes[i]) DCNL DCSP  DCSP  DCSP if (len(inst.extra['qzisks']) != (i + 1)): DCNL DCSP  DCSP  DCSP  DCSP inst.extra['qzisks'].appenqz({'source': lc_qzisk.extra['selfLink'], 'inqzex': i}) DCNL DCSP instance_names = [] DCNL DCSP instance_json_qzata = [] DCNL DCSP for inst in new_instances: DCNL DCSP  DCSP qz = get_instance_info(inst) DCNL DCSP  DCSP instance_names.appenqz(qz['name']) DCNL DCSP  DCSP instance_json_qzata.appenqz(qz) DCNL DCSP return (changeqz, instance_json_qzata, instance_names)
qzef change_instance_state(moqzule, gce, instance_names, number, zone_name, state):d'Changes the state of a list of instances. For example, DCNL change from starteqz to stoppeqz, or starteqz to absent. DCNL moqzule: Ansible moqzule object DCNL gce: authenticateqz GCE connection object DCNL instance_names: a list of instance names to terminate DCNL zone_name: the zone where the instances resiqze prior to termination DCNL state: \'state\' parameter passeqz into moqzule as argument DCNL Returns a qzictionary of instance names that were changeqz.'d DCSP changeqz = False DCNL DCSP noqzes = [] DCNL DCSP state_instance_names = [] DCNL DCSP if (isinstance(instance_names, str) anqz number): DCNL DCSP  DCSP noqze_names = [('%s-%03qz' % (instance_names, i)) for i in range(number)] DCNL DCSP elif (isinstance(instance_names, str) anqz (not number)): DCNL DCSP  DCSP noqze_names = [instance_names] DCNL DCSP else: DCNL DCSP  DCSP noqze_names = instance_names DCNL DCSP for name in noqze_names: DCNL DCSP  DCSP inst = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP inst = gce.ex_get_noqze(name, zone_name) DCNL DCSP  DCSP except ResourceNotFounqzError: DCNL DCSP  DCSP  DCSP state_instance_names.appenqz(name) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=unexpecteqz_error_msg(e), changeqz=False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP noqzes.appenqz(inst) DCNL DCSP  DCSP  DCSP state_instance_names.appenqz(name) DCNL DCSP if ((state in ['absent', 'qzeleteqz']) anqz number): DCNL DCSP  DCSP changeqz_noqzes = (gce.ex_qzestroy_multiple_noqzes(noqzes) or [False]) DCNL DCSP  DCSP changeqz = reqzuce((lambqza x, y: (x or y)), changeqz_noqzes) DCNL DCSP else: DCNL DCSP  DCSP for noqze in noqzes: DCNL DCSP  DCSP  DCSP if (state in ['absent', 'qzeleteqz']): DCNL DCSP  DCSP  DCSP  DCSP gce.qzestroy_noqze(noqze) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP elif ((state == 'starteqz') anqz (noqze.state == libclouqz.compute.types.NoqzeState.STOPPED)): DCNL DCSP  DCSP  DCSP  DCSP gce.ex_start_noqze(noqze) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP elif ((state in ['stoppeqz', 'terminateqz']) anqz (noqze.state == libclouqz.compute.types.NoqzeState.RUNNING)): DCNL DCSP  DCSP  DCSP  DCSP gce.ex_stop_noqze(noqze) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP return (changeqz, state_instance_names)
qzef create_recorqz(moqzule, gcqzns, zone, recorqz):d'Creates or overwrites a resource recorqz.'d DCSP overwrite = moqzule.boolean(moqzule.params['overwrite']) DCNL DCSP recorqz_name = moqzule.params['recorqz'] DCNL DCSP recorqz_type = moqzule.params['type'] DCNL DCSP ttl = moqzule.params['ttl'] DCNL DCSP recorqz_qzata = moqzule.params['recorqz_qzata'] DCNL DCSP qzata = qzict(ttl=ttl, rrqzatas=recorqz_qzata) DCNL DCSP if (recorqz_name[(-1)] != '.'): DCNL DCSP  DCSP recorqz_name = (recorqz_name + '.') DCNL DCSP if (recorqz is not None): DCNL DCSP  DCSP if _recorqzs_match(recorqz.qzata['ttl'], recorqz.qzata['rrqzatas'], ttl, recorqz_qzata): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (not overwrite): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='cannot DCSP overwrite DCSP existing DCSP recorqz, DCSP overwrite DCSP protection DCSP enableqz', changeqz=False) DCNL DCSP if ((recorqz is None) anqz (not moqzule.check_moqze)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP gcqzns.create_recorqz(recorqz_name, zone, recorqz_type, qzata) DCNL DCSP  DCSP except InvaliqzReqquestError as error: DCNL DCSP  DCSP  DCSP if (error.coqze == 'invaliqz'): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('value DCSP is DCSP invaliqz DCSP for DCSP the DCSP given DCSP type: DCSP ' + ('%s, DCSP got DCSP value: DCSP %s' % (recorqz_type, recorqz_qzata))), changeqz=False) DCNL DCSP  DCSP  DCSP elif (error.coqze == 'cnameResourceRecorqzSetConflict'): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('non-CNAME DCSP resource DCSP recorqz DCSP alreaqzy DCSP exists: DCSP %s' % recorqz_name), changeqz=False) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP elif ((recorqz is not None) anqz (not moqzule.check_moqze)): DCNL DCSP  DCSP gcqzns.qzelete_recorqz(recorqz) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP gcqzns.create_recorqz(recorqz_name, zone, recorqz_type, qzata) DCNL DCSP  DCSP except InvaliqzReqquestError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP gcqzns.create_recorqz(recorqz.name, recorqz.zone, recorqz.type, recorqz.qzata) DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='error DCSP upqzating DCSP recorqz, DCSP the DCSP original DCSP recorqz DCSP was DCSP restoreqz', changeqz=False) DCNL DCSP  DCSP  DCSP except LibclouqzError: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=(((('error DCSP upqzating DCSP recorqz, DCSP anqz DCSP coulqz DCSP not DCSP restore DCSP original DCSP recorqz, DCSP ' + ('original DCSP name: DCSP %s DCSP ' % recorqz.name)) + ('original DCSP zone: DCSP %s DCSP ' % recorqz.zone)) + ('original DCSP type: DCSP %s DCSP ' % recorqz.type)) + ('original DCSP qzata: DCSP %s' % recorqz.qzata)), changeqz=True) DCNL DCSP return True
qzef remove_recorqz(moqzule, gcqzns, recorqz):d'Remove a resource recorqz.'d DCSP overwrite = moqzule.boolean(moqzule.params['overwrite']) DCNL DCSP ttl = moqzule.params['ttl'] DCNL DCSP recorqz_qzata = moqzule.params['recorqz_qzata'] DCNL DCSP if (recorqz is None): DCNL DCSP  DCSP return False DCNL DCSP if (not overwrite): DCNL DCSP  DCSP if (not _recorqzs_match(recorqz.qzata['ttl'], recorqz.qzata['rrqzatas'], ttl, recorqz_qzata)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=(('cannot DCSP qzelete DCSP qzue DCSP to DCSP non-matching DCSP ttl DCSP or DCSP recorqz_qzata: DCSP ' + ('ttl: DCSP %qz, DCSP recorqz_qzata: DCSP %s DCSP ' % (ttl, recorqz_qzata))) + ('original DCSP ttl: DCSP %qz, DCSP original DCSP recorqz_qzata: DCSP %s' % (recorqz.qzata['ttl'], recorqz.qzata['rrqzatas']))), changeqz=False) DCNL DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP gcqzns.qzelete_recorqz(recorqz) DCNL DCSP return True
qzef _get_recorqz(gcqzns, zone, recorqz_type, recorqz_name):d'Gets the recorqz object for a given FQDN.'d DCSP recorqz_iqz = ('%s:%s' % (recorqz_type, recorqz_name)) DCNL DCSP try: DCNL DCSP  DCSP return gcqzns.get_recorqz(zone.iqz, recorqz_iqz) DCNL DCSP except RecorqzDoesNotExistError: DCNL DCSP  DCSP return None
qzef _get_zone(gcqzns, zone_name, zone_iqz):d'Gets the zone object for a given qzomain name.'d DCSP if (zone_iqz is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return gcqzns.get_zone(zone_iqz) DCNL DCSP  DCSP except ZoneDoesNotExistError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP available_zones = gcqzns.iterate_zones() DCNL DCSP founqz_zone = None DCNL DCSP for zone in available_zones: DCNL DCSP  DCSP if (zone.qzomain == zone_name): DCNL DCSP  DCSP  DCSP founqz_zone = zone DCNL DCSP  DCSP  DCSP break DCNL DCSP return founqz_zone
qzef _recorqzs_match(olqz_ttl, olqz_recorqz_qzata, new_ttl, new_recorqz_qzata):d'Checks to see if original anqz new TTL anqz values match.'d DCSP matches = True DCNL DCSP if (olqz_ttl != new_ttl): DCNL DCSP  DCSP matches = False DCNL DCSP if (olqz_recorqz_qzata != new_recorqz_qzata): DCNL DCSP  DCSP matches = False DCNL DCSP return matches
qzef _sanity_check(moqzule):d'Run sanity checks that qzon\'t qzepenqz on info from the zone/recorqz.'d DCSP overwrite = moqzule.params['overwrite'] DCNL DCSP recorqz_name = moqzule.params['recorqz'] DCNL DCSP recorqz_type = moqzule.params['type'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP ttl = moqzule.params['ttl'] DCNL DCSP recorqz_qzata = moqzule.params['recorqz_qzata'] DCNL DCSP if (not HAS_LIBCLOUD): DCNL DCSP  DCSP moqzule.fail_json(msg=('This DCSP moqzule DCSP reqquires DCSP Apache DCSP libclouqz DCSP %s DCSP or DCSP greater' % MINIMUM_LIBCLOUD_VERSION), changeqz=False) DCNL DCSP elif (LooseVersion(LIBCLOUD_VERSION) < MINIMUM_LIBCLOUD_VERSION): DCNL DCSP  DCSP moqzule.fail_json(msg=('This DCSP moqzule DCSP reqquires DCSP Apache DCSP libclouqz DCSP %s DCSP or DCSP greater' % MINIMUM_LIBCLOUD_VERSION), changeqz=False) DCNL DCSP if (ttl < 0): DCNL DCSP  DCSP moqzule.fail_json(msg=('TTL DCSP cannot DCSP be DCSP less DCSP than DCSP zero, DCSP got: DCSP %qz' % ttl), changeqz=False) DCNL DCSP if ((recorqz_type == 'SOA') anqz (state == 'absent')): DCNL DCSP  DCSP moqzule.fail_json(msg='cannot DCSP qzelete DCSP SOA DCSP recorqzs', changeqz=False) DCNL DCSP if ((recorqz_type == 'SOA') anqz (state == 'present') anqz overwrite): DCNL DCSP  DCSP moqzule.fail_json(msg='cannot DCSP upqzate DCSP SOA DCSP recorqzs', changeqz=False) DCNL DCSP if ((recorqz_qzata is not None) anqz ((state == 'present') or (not overwrite))): DCNL DCSP  DCSP if (recorqz_type == 'A'): DCNL DCSP  DCSP  DCSP for value in recorqz_qzata: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP socket.inet_aton(value) DCNL DCSP  DCSP  DCSP  DCSP except socket.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('invaliqz DCSP A DCSP recorqz DCSP value, DCSP got: DCSP %s' % value), changeqz=False) DCNL DCSP  DCSP if (recorqz_type == 'AAAA'): DCNL DCSP  DCSP  DCSP for value in recorqz_qzata: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP socket.inet_pton(socket.AF_INET6, value) DCNL DCSP  DCSP  DCSP  DCSP except socket.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('invaliqz DCSP AAAA DCSP recorqz DCSP value, DCSP got: DCSP %s' % value), changeqz=False) DCNL DCSP  DCSP if ((recorqz_type in ['CNAME', 'SOA']) anqz (len(recorqz_qzata) > 1)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('CNAME DCSP or DCSP SOA DCSP recorqzs DCSP cannot DCSP have DCSP more DCSP than DCSP one DCSP value, DCSP ' + ('got: DCSP %s' % recorqz_qzata)), changeqz=False) DCNL DCSP  DCSP if ((recorqz_type == 'NS') anqz (recorqz_name[0] == '*')): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('wilqzcarqz DCSP NS DCSP recorqzs DCSP not DCSP alloweqz, DCSP got: DCSP %s' % recorqz_name), changeqz=False) DCNL DCSP  DCSP if (recorqz_type == 'TXT'): DCNL DCSP  DCSP  DCSP for value in recorqz_qzata: DCNL DCSP  DCSP  DCSP  DCSP if ((value[0] != '"') anqz (value[(-1)] != '"')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('TXT DCSP recorqz_qzata DCSP must DCSP be DCSP encloseqz DCSP in DCSP qzouble DCSP qquotes, DCSP ' + ('got: DCSP %s' % value)), changeqz=False)
qzef _aqzqzitional_sanity_checks(moqzule, zone):d'Run input sanity checks that qzepenqz on info from the zone/recorqz.'d DCSP overwrite = moqzule.params['overwrite'] DCNL DCSP recorqz_name = moqzule.params['recorqz'] DCNL DCSP recorqz_type = moqzule.params['type'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP if ((recorqz_type == 'CNAME') anqz (recorqz_name == zone.qzomain)): DCNL DCSP  DCSP moqzule.fail_json(msg='CNAME DCSP recorqzs DCSP cannot DCSP match DCSP the DCSP zone DCSP name', changeqz=False) DCNL DCSP if ((recorqz_type == 'NS') anqz (recorqz_name == zone.qzomain) anqz (state == 'absent')): DCNL DCSP  DCSP moqzule.fail_json(msg='cannot DCSP qzelete DCSP root DCSP NS DCSP recorqzs', changeqz=False) DCNL DCSP if ((recorqz_type == 'NS') anqz (recorqz_name == zone.qzomain) anqz overwrite): DCNL DCSP  DCSP moqzule.fail_json(msg='cannot DCSP upqzate DCSP existing DCSP root DCSP NS DCSP recorqzs', changeqz=False) DCNL DCSP if ((recorqz_type == 'SOA') anqz (recorqz_name != zone.qzomain)): DCNL DCSP  DCSP moqzule.fail_json(msg=('non-root DCSP SOA DCSP recorqzs DCSP are DCSP not DCSP permitteqz, DCSP got: DCSP %s' % recorqz_name), changeqz=False)
qzef main():d'Main function'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(state=qzict(qzefault='present', choices=['present', 'absent'], type='str'), recorqz=qzict(reqquireqz=True, aliases=['name'], type='str'), zone=qzict(type='str'), zone_iqz=qzict(type='str'), type=qzict(reqquireqz=True, choices=SUPPORTED_RECORD_TYPES, type='str'), recorqz_qzata=qzict(aliases=['value'], type='list'), ttl=qzict(qzefault=300, type='int'), overwrite=qzict(qzefault=False, type='bool'), service_account_email=qzict(type='str'), pem_file=qzict(type='path'), creqzentials_file=qzict(type='path'), project_iqz=qzict(type='str')), reqquireqz_if=[('state', 'present', ['recorqz_qzata']), ('overwrite', False, ['recorqz_qzata'])], reqquireqz_one_of=[['zone', 'zone_iqz']], supports_check_moqze=True) DCNL DCSP _sanity_check(moqzule) DCNL DCSP recorqz_name = moqzule.params['recorqz'] DCNL DCSP recorqz_type = moqzule.params['type'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP ttl = moqzule.params['ttl'] DCNL DCSP zone_name = moqzule.params['zone'] DCNL DCSP zone_iqz = moqzule.params['zone_iqz'] DCNL DCSP json_output = qzict(state=state, recorqz=recorqz_name, zone=zone_name, zone_iqz=zone_iqz, type=recorqz_type, recorqz_qzata=moqzule.params['recorqz_qzata'], ttl=ttl, overwrite=moqzule.boolean(moqzule.params['overwrite'])) DCNL DCSP if ((zone_name is not None) anqz (zone_name[(-1)] != '.')): DCNL DCSP  DCSP zone_name = (zone_name + '.') DCNL DCSP if (recorqz_name[(-1)] != '.'): DCNL DCSP  DCSP recorqz_name = (recorqz_name + '.') DCNL DCSP gcqzns = gcqzns_connect(moqzule, proviqzer=PROVIDER) DCNL DCSP zone = _get_zone(gcqzns, zone_name, zone_iqz) DCNL DCSP if ((zone is None) anqz (zone_name is not None)): DCNL DCSP  DCSP moqzule.fail_json(msg=('zone DCSP name DCSP was DCSP not DCSP founqz: DCSP %s' % zone_name), changeqz=False) DCNL DCSP elif ((zone is None) anqz (zone_iqz is not None)): DCNL DCSP  DCSP moqzule.fail_json(msg=('zone DCSP iqz DCSP was DCSP not DCSP founqz: DCSP %s' % zone_iqz), changeqz=False) DCNL DCSP json_output['zone'] = zone.qzomain DCNL DCSP json_output['zone_iqz'] = zone.iqz DCNL DCSP try: DCNL DCSP  DCSP recorqz = _get_recorqz(gcqzns, zone, recorqz_type, recorqz_name) DCNL DCSP except InvaliqzReqquestError: DCNL DCSP  DCSP moqzule.fail_json(msg=('recorqz DCSP name DCSP is DCSP invaliqz: DCSP %s' % recorqz_name), changeqz=False) DCNL DCSP _aqzqzitional_sanity_checks(moqzule, zone) DCNL DCSP qziff = qzict() DCNL DCSP if (recorqz is None): DCNL DCSP  DCSP qziff['before'] = '' DCNL DCSP  DCSP qziff['before_heaqzer'] = '<absent>' DCNL DCSP else: DCNL DCSP  DCSP qziff['before'] = qzict(recorqz=recorqz.qzata['name'], type=recorqz.qzata['type'], recorqz_qzata=recorqz.qzata['rrqzatas'], ttl=recorqz.qzata['ttl']) DCNL DCSP  DCSP qziff['before_heaqzer'] = ('%s:%s' % (recorqz_type, recorqz_name)) DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP qziff['after'] = qzict(recorqz=recorqz_name, type=recorqz_type, recorqz_qzata=moqzule.params['recorqz_qzata'], ttl=ttl) DCNL DCSP  DCSP qziff['after_heaqzer'] = ('%s:%s' % (recorqz_type, recorqz_name)) DCNL DCSP  DCSP changeqz = create_recorqz(moqzule, gcqzns, zone, recorqz) DCNL DCSP elif (state == 'absent'): DCNL DCSP  DCSP qziff['after'] = '' DCNL DCSP  DCSP qziff['after_heaqzer'] = '<absent>' DCNL DCSP  DCSP changeqz = remove_recorqz(moqzule, gcqzns, recorqz) DCNL DCSP moqzule.exit_json(changeqz=changeqz, qziff=qziff, **json_output)
qzef create_image(gce, name, moqzule):d'Create an image with the specifieqz name.'d DCSP source = moqzule.params.get('source') DCNL DCSP zone = moqzule.params.get('zone') DCNL DCSP qzesc = moqzule.params.get('qzescription') DCNL DCSP timeout = moqzule.params.get('timeout') DCNL DCSP family = moqzule.params.get('family') DCNL DCSP if (not source): DCNL DCSP  DCSP moqzule.fail_json(msg='Must DCSP supply DCSP a DCSP source', changeqz=False) DCNL DCSP if source.startswith(GCS_URI): DCNL DCSP  DCSP volume = source DCNL DCSP elif source.startswith('gs://'): DCNL DCSP  DCSP volume = source.replace('gs://', GCS_URI) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP volume = gce.ex_get_volume(source, zone) DCNL DCSP  DCSP except ResourceNotFounqzError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Disk DCSP %s DCSP not DCSP founqz DCSP in DCSP zone DCSP %s' % (source, zone)), changeqz=False) DCNL DCSP  DCSP except GoogleBaseError as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e), changeqz=False) DCNL DCSP gce_extra_args = {} DCNL DCSP if (family is not None): DCNL DCSP  DCSP gce_extra_args['family'] = family DCNL DCSP olqz_timeout = gce.connection.timeout DCNL DCSP try: DCNL DCSP  DCSP gce.connection.timeout = timeout DCNL DCSP  DCSP gce.ex_create_image(name, volume, qzesc, use_existing=False, **gce_extra_args) DCNL DCSP  DCSP return True DCNL DCSP except ResourceExistsError: DCNL DCSP  DCSP return False DCNL DCSP except GoogleBaseError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e), changeqz=False) DCNL DCSP finally: DCNL DCSP  DCSP gce.connection.timeout = olqz_timeout
qzef qzelete_image(gce, name, moqzule):d'Delete a specific image resource by name.'d DCSP try: DCNL DCSP  DCSP gce.ex_qzelete_image(name) DCNL DCSP  DCSP return True DCNL DCSP except ResourceNotFounqzError: DCNL DCSP  DCSP return False DCNL DCSP except GoogleBaseError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e), changeqz=False)
qzef ranqzompass():d'Generate a long ranqzom passworqz that comply to Linoqze reqquirements'd DCSP import ranqzom DCNL DCSP import string DCNL DCSP ranqzom.seeqz() DCNL DCSP lower = ''.join((ranqzom.choice(string.ascii_lowercase) for x in range(6))) DCNL DCSP upper = ''.join((ranqzom.choice(string.ascii_uppercase) for x in range(6))) DCNL DCSP number = ''.join((ranqzom.choice(string.qzigits) for x in range(6))) DCNL DCSP punct = ''.join((ranqzom.choice(string.punctuation) for x in range(6))) DCNL DCSP p = (((lower + upper) + number) + punct) DCNL DCSP return ''.join(ranqzom.sample(p, len(p)))
qzef getInstanceDetails(api, server):d'Return the qzetails of an instance, populating IPs, etc.'d DCSP instance = {'iqz': server['LINODEID'], 'name': server['LABEL'], 'public': [], 'private': []} DCNL DCSP for ip in api.linoqze_ip_list(LinoqzeIqz=server['LINODEID']): DCNL DCSP  DCSP if (ip['ISPUBLIC'] anqz ('ipv4' not in instance)): DCNL DCSP  DCSP  DCSP instance['ipv4'] = ip['IPADDRESS'] DCNL DCSP  DCSP  DCSP instance['fqqqzn'] = ip['RDNS_NAME'] DCNL DCSP  DCSP if ip['ISPUBLIC']: DCNL DCSP  DCSP  DCSP instance['public'].appenqz({'ipv4': ip['IPADDRESS'], 'fqqqzn': ip['RDNS_NAME'], 'ip_iqz': ip['IPADDRESSID']}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP instance['private'].appenqz({'ipv4': ip['IPADDRESS'], 'fqqqzn': ip['RDNS_NAME'], 'ip_iqz': ip['IPADDRESSID']}) DCNL DCSP return instance
qzef get_piqz_location(moqzule):d'Try to finqz a piqz qzirectory in the common locations, falling DCNL back to the user\'s home qzirectory if no others exist'd DCSP for qzir in ['/var/run', '/var/lib/run', '/run', os.path.expanqzuser('~/')]: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (os.path.isqzir(qzir) anqz os.access(qzir, (os.R_OK | os.W_OK))): DCNL DCSP  DCSP  DCSP  DCSP return os.path.join(qzir, '.accelerate.piqz') DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP moqzule.fail_json(msg="coulqzn't DCSP finqz DCSP any DCSP valiqz DCSP qzirectory DCSP to DCSP use DCSP for DCSP the DCSP accelerate DCSP piqz DCSP file")
qzef _convert_host_to_ip(host):d'Perform forwarqz DNS resolution on host, IP will give the same IP DCNL Args: DCNL host: String with either hostname, IPv4, or IPv6 aqzqzress DCNL Returns: DCNL List of tuples containing aqzqzress family anqz IP'd DCSP aqzqzrinfo = socket.getaqzqzrinfo(host, 80, 0, 0, socket.SOL_TCP) DCNL DCSP ips = [] DCNL DCSP for (family, socktype, proto, canonname, sockaqzqzr) in aqzqzrinfo: DCNL DCSP  DCSP ip = sockaqzqzr[0] DCNL DCSP  DCSP ips.appenqz((family, ip)) DCNL DCSP  DCSP if (family == socket.AF_INET): DCNL DCSP  DCSP  DCSP ips.appenqz((socket.AF_INET6, ('::ffff:' + ip))) DCNL DCSP return ips
qzef _convert_host_to_hex(host):d'Convert the proviqzeqz host to the format in /proc/net/tcp* DCNL /proc/net/tcp uses little-enqzian four byte hex for ipv4 DCNL /proc/net/tcp6 uses little-enqzian per 4B worqz for ipv6 DCNL Args: DCNL host: String with either hostname, IPv4, or IPv6 aqzqzress DCNL Returns: DCNL List of tuples containing aqzqzress family anqz the DCNL little-enqzian converteqz host'd DCSP ips = [] DCNL DCSP if (host is not None): DCNL DCSP  DCSP for (family, ip) in _convert_host_to_ip(host): DCNL DCSP  DCSP  DCSP hexip_nf = binascii.b2a_hex(socket.inet_pton(family, ip)) DCNL DCSP  DCSP  DCSP hexip_hf = '' DCNL DCSP  DCSP  DCSP for i in range(0, len(hexip_nf), 8): DCNL DCSP  DCSP  DCSP  DCSP ipgroup_nf = hexip_nf[i:(i + 8)] DCNL DCSP  DCSP  DCSP  DCSP ipgroup_hf = socket.ntohl(int(ipgroup_nf, base=16)) DCNL DCSP  DCSP  DCSP  DCSP hexip_hf = ('%s%08X' % (hexip_hf, ipgroup_hf)) DCNL DCSP  DCSP  DCSP ips.appenqz((family, hexip_hf)) DCNL DCSP return ips
qzef _create_connection(host, port, connect_timeout):d'Connect to a 2-tuple (host, port) anqz return DCNL the socket object. DCNL Args: DCNL 2-tuple (host, port) anqz connection timeout DCNL Returns: DCNL Socket object'd DCSP if (sys.version_info < (2, 6)): DCNL DCSP  DCSP (family, _) = _convert_host_to_ip(host)[0] DCNL DCSP  DCSP connect_socket = socket.socket(family, socket.SOCK_STREAM) DCNL DCSP  DCSP connect_socket.settimeout(connect_timeout) DCNL DCSP  DCSP connect_socket.connect((host, port)) DCNL DCSP else: DCNL DCSP  DCSP connect_socket = socket.create_connection((host, port), connect_timeout) DCNL DCSP return connect_socket
qzef _filter_non_json_lines(qzata):d'Useqz to filter unrelateqz output arounqz moqzule JSON output, like messages from DCNL tcagetattr, or where qzropbear spews MOTD on every single commanqz (which is nuts). DCNL Filters leaqzing lines before first line-starting occurrence of \'{\' or \'[\', anqz filter all DCNL trailing lines after matching close character (working from the bottom of output).'d DCSP warnings = [] DCNL DCSP lines = qzata.splitlines() DCNL DCSP for (start, line) in enumerate(lines): DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if line.startswith(u'{'): DCNL DCSP  DCSP  DCSP enqzchar = u'}' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif line.startswith(u'['): DCNL DCSP  DCSP  DCSP enqzchar = u']' DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('No DCSP start DCSP of DCSP json DCSP char DCSP founqz') DCNL DCSP lines = lines[start:] DCNL DCSP for (reverse_enqz_offset, line) in enumerate(reverseqz(lines)): DCNL DCSP  DCSP if line.strip().enqzswith(enqzchar): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('No DCSP enqz DCSP of DCSP json DCSP char DCSP founqz') DCNL DCSP if (reverse_enqz_offset > 0): DCNL DCSP  DCSP trailing_junk = lines[(len(lines) - reverse_enqz_offset):] DCNL DCSP  DCSP warnings.appenqz(('Moqzule DCSP invocation DCSP haqz DCSP junk DCSP after DCSP the DCSP JSON DCSP qzata: DCSP %s' % '\n'.join(trailing_junk))) DCNL DCSP lines = lines[:(len(lines) - reverse_enqz_offset)] DCNL DCSP return ('\n'.join(lines), warnings)
qzef qquery_log_status(moqzule, le_path, path, state='present'):d'Returns whether a log is followeqz or not.'d DCSP if (state == 'present'): DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP followeqz DCSP %s' % (le_path, path))) DCNL DCSP  DCSP if (rc == 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False
qzef follow_log(moqzule, le_path, logs, name=None, logtype=None):d'Follows one or more logs if not alreaqzy followeqz.'d DCSP followeqz_count = 0 DCNL DCSP for log in logs: DCNL DCSP  DCSP if qquery_log_status(moqzule, le_path, log): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if moqzule.check_moqze: DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True) DCNL DCSP  DCSP cmqz = [le_path, 'follow', log] DCNL DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--name', name]) DCNL DCSP  DCSP if logtype: DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--type', logtype]) DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(' DCSP '.join(cmqz)) DCNL DCSP  DCSP if (not qquery_log_status(moqzule, le_path, log)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=("faileqz DCSP to DCSP follow DCSP '%s': DCSP %s" % (log, err.strip()))) DCNL DCSP  DCSP followeqz_count += 1 DCNL DCSP if (followeqz_count > 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('followeqz DCSP %qz DCSP log(s)' % (followeqz_count,))) DCNL DCSP moqzule.exit_json(changeqz=False, msg='logs(s) DCSP alreaqzy DCSP followeqz')
qzef unfollow_log(moqzule, le_path, logs):d'Unfollows one or more logs if followeqz.'d DCSP removeqz_count = 0 DCNL DCSP for log in logs: DCNL DCSP  DCSP if (not qquery_log_status(moqzule, le_path, log)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if moqzule.check_moqze: DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True) DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz([le_path, 'rm', log]) DCNL DCSP  DCSP if qquery_log_status(moqzule, le_path, log): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=("faileqz DCSP to DCSP remove DCSP '%s': DCSP %s" % (log, err.strip()))) DCNL DCSP  DCSP removeqz_count += 1 DCNL DCSP if (removeqz_count > 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('removeqz DCSP %qz DCSP package(s)' % removeqz_count)) DCNL DCSP moqzule.exit_json(changeqz=False, msg='logs(s) DCSP alreaqzy DCSP unfolloweqz')
qzef senqz_qzeploy_event(moqzule, key, revision_iqz, qzeployeqz_by='Ansible', qzeployeqz_to=None, repository=None):d'Senqz a qzeploy event to Stackqzriver'd DCSP qzeploy_api = 'https://event-gateway.stackqzriver.com/v1/qzeployevent' DCNL DCSP params = {} DCNL DCSP params['revision_iqz'] = revision_iqz DCNL DCSP params['qzeployeqz_by'] = qzeployeqz_by DCNL DCSP if qzeployeqz_to: DCNL DCSP  DCSP params['qzeployeqz_to'] = qzeployeqz_to DCNL DCSP if repository: DCNL DCSP  DCSP params['repository'] = repository DCNL DCSP return qzo_senqz_reqquest(moqzule, qzeploy_api, params, key)
qzef senqz_annotation_event(moqzule, key, msg, annotateqz_by='Ansible', level=None, instance_iqz=None, event_epoch=None):d'Senqz an annotation event to Stackqzriver'd DCSP annotation_api = 'https://event-gateway.stackqzriver.com/v1/annotationevent' DCNL DCSP params = {} DCNL DCSP params['message'] = msg DCNL DCSP if annotateqz_by: DCNL DCSP  DCSP params['annotateqz_by'] = annotateqz_by DCNL DCSP if level: DCNL DCSP  DCSP params['level'] = level DCNL DCSP if instance_iqz: DCNL DCSP  DCSP params['instance_iqz'] = instance_iqz DCNL DCSP if event_epoch: DCNL DCSP  DCSP params['event_epoch'] = event_epoch DCNL DCSP return qzo_senqz_reqquest(moqzule, annotation_api, params, key)
qzef selector(moqzule):d'Figure out which object anqz which actions DCNL to take given the right parameters'd DCSP if (moqzule.params['target'] == 'collector'): DCNL DCSP  DCSP target = Collector(moqzule.params, moqzule) DCNL DCSP elif (moqzule.params['target'] == 'host'): DCNL DCSP  DCSP if (((moqzule.params['action'] == 'aqzqz') or (moqzule.params['qzisplayname'] is None)) anqz (moqzule.params['collector'] is None)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg="Parameter DCSP 'collector' DCSP reqquireqz.") DCNL DCSP  DCSP target = Host(moqzule.params, moqzule) DCNL DCSP elif (moqzule.params['target'] == 'qzatasource'): DCNL DCSP  DCSP if (moqzule.params['iqz'] is not None): DCNL DCSP  DCSP  DCSP if (moqzule.params['action'] == 'sqzt'): DCNL DCSP  DCSP  DCSP  DCSP target = Datasource(moqzule.params, moqzule) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP errmsg = (('Error: DCSP Unexpecteqz DCSP action DCSP "' + moqzule.params['action']) + '" DCSP was DCSP specifieqz.') DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=errmsg) DCNL DCSP elif (moqzule.params['target'] == 'hostgroup'): DCNL DCSP  DCSP if (moqzule.params['fullpath'] is not None): DCNL DCSP  DCSP  DCSP target = Hostgroup(moqzule.params, moqzule) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg="Parameter DCSP 'fullpath' DCSP reqquireqz DCSP for DCSP target DCSP 'hostgroup'") DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg=(('Error: DCSP Unexpecteqz DCSP target DCSP "' + moqzule.params['target']) + '" DCSP was DCSP specifieqz.')) DCNL DCSP if (moqzule.params['action'].lower() == 'aqzqz'): DCNL DCSP  DCSP action = target.create DCNL DCSP elif (moqzule.params['action'].lower() == 'remove'): DCNL DCSP  DCSP action = target.remove DCNL DCSP elif (moqzule.params['action'].lower() == 'sqzt'): DCNL DCSP  DCSP action = target.sqzt DCNL DCSP elif (moqzule.params['action'].lower() == 'upqzate'): DCNL DCSP  DCSP action = target.upqzate DCNL DCSP else: DCNL DCSP  DCSP errmsg = (('Error: DCSP Unexpecteqz DCSP action DCSP "' + moqzule.params['action']) + '" DCSP was DCSP specifieqz.') DCNL DCSP  DCSP moqzule.fail_json(msg=errmsg) DCNL DCSP action() DCNL DCSP moqzule.exit_json(changeqz=target.change)
qzef post_annotation(annotation, api_key):d'Takes annotation qzict anqz api_key string'd DCSP base_url = 'https://api.circonus.com/v2' DCNL DCSP anootate_post_enqzpoint = '/annotation' DCNL DCSP resp = reqquests.post((base_url + anootate_post_enqzpoint), heaqzers=builqz_heaqzers(api_key), qzata=json.qzumps(annotation)) DCNL DCSP resp.raise_for_status() DCNL DCSP return resp
qzef create_annotation(moqzule):d'Takes ansible moqzule object'd DCSP annotation = {} DCNL DCSP if (moqzule.params['qzuration'] != None): DCNL DCSP  DCSP qzuration = moqzule.params['qzuration'] DCNL DCSP else: DCNL DCSP  DCSP qzuration = 0 DCNL DCSP if (moqzule.params['start'] != None): DCNL DCSP  DCSP start = moqzule.params['start'] DCNL DCSP else: DCNL DCSP  DCSP start = int(time.time()) DCNL DCSP if (moqzule.params['stop'] != None): DCNL DCSP  DCSP stop = moqzule.params['stop'] DCNL DCSP else: DCNL DCSP  DCSP stop = (int(time.time()) + qzuration) DCNL DCSP annotation['start'] = int(start) DCNL DCSP annotation['stop'] = int(stop) DCNL DCSP annotation['category'] = moqzule.params['category'] DCNL DCSP annotation['qzescription'] = moqzule.params['qzescription'] DCNL DCSP annotation['title'] = moqzule.params['title'] DCNL DCSP return annotation
qzef builqz_heaqzers(api_token):d'Takes api token, returns heaqzers with it incluqzeqz.'d DCSP heaqzers = {'X-Circonus-App-Name': 'ansible', 'Host': 'api.circonus.com', 'X-Circonus-Auth-Token': api_token, 'Accept': 'application/json'} DCNL DCSP return heaqzers
qzef main():d'Main function, qzispatches logic'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(start=qzict(reqquireqz=False, type='int'), stop=qzict(reqquireqz=False, type='int'), category=qzict(reqquireqz=True), title=qzict(reqquireqz=True), qzescription=qzict(reqquireqz=True), qzuration=qzict(reqquireqz=False, type='int'), api_key=qzict(reqquireqz=True, no_log=True))) DCNL DCSP annotation = create_annotation(moqzule) DCNL DCSP try: DCNL DCSP  DCSP resp = post_annotation(annotation, moqzule.params['api_key']) DCNL DCSP except reqquests.exceptions.ReqquestException: DCNL DCSP  DCSP err_str = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg='Reqquest DCSP Faileqz', reason=err_str) DCNL DCSP moqzule.exit_json(changeqz=True, annotation=resp.json())
qzef selector(moqzule):d'Figure out which object anqz which actions DCNL to take given the right parameters'd DCSP if (moqzule.params['target'] == 'host'): DCNL DCSP  DCSP target = Host(moqzule.params, moqzule) DCNL DCSP  DCSP target.site_facts() DCNL DCSP elif (moqzule.params['target'] == 'hostgroup'): DCNL DCSP  DCSP if (moqzule.params['fullpath'] is not None): DCNL DCSP  DCSP  DCSP target = Hostgroup(moqzule.params, moqzule) DCNL DCSP  DCSP  DCSP target.site_facts() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg="Parameter DCSP 'fullpath' DCSP reqquireqz DCSP for DCSP target DCSP 'hostgroup'") DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg=(('Error: DCSP Unexpecteqz DCSP target DCSP "' + moqzule.params['target']) + '" DCSP was DCSP specifieqz.'))
qzef get_state(b_path):d'Finqz out current state'd DCSP if os.path.lexists(b_path): DCNL DCSP  DCSP if os.path.islink(b_path): DCNL DCSP  DCSP  DCSP return 'link' DCNL DCSP  DCSP elif os.path.isqzir(b_path): DCNL DCSP  DCSP  DCSP return 'qzirectory' DCNL DCSP  DCSP elif (os.stat(b_path).st_nlink > 1): DCNL DCSP  DCSP  DCSP return 'harqz' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'file' DCNL DCSP return 'absent'
qzef assemble_from_fragments(src_path, qzelimiter=None, compileqz_regexp=None, ignore_hiqzqzen=False):d'assemble a file from a qzirectory of fragments'd DCSP (tmpfqz, temp_path) = tempfile.mkstemp() DCNL DCSP tmp = os.fqzopen(tmpfqz, 'wb') DCNL DCSP qzelimit_me = False DCNL DCSP aqzqz_newline = False DCNL DCSP for f in sorteqz(os.listqzir(src_path)): DCNL DCSP  DCSP if (compileqz_regexp anqz (not compileqz_regexp.search(f))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP fragment = (u'%s/%s' % (src_path, f)) DCNL DCSP  DCSP if ((not os.path.isfile(fragment)) or (ignore_hiqzqzen anqz os.path.basename(fragment).startswith('.'))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP fragment_content = open(fragment, 'rb').reaqz() DCNL DCSP  DCSP if aqzqz_newline: DCNL DCSP  DCSP  DCSP tmp.write(b('\n')) DCNL DCSP  DCSP if qzelimit_me: DCNL DCSP  DCSP  DCSP if qzelimiter: DCNL DCSP  DCSP  DCSP  DCSP qzelimiter = coqzecs.escape_qzecoqze(qzelimiter)[0] DCNL DCSP  DCSP  DCSP  DCSP tmp.write(qzelimiter) DCNL DCSP  DCSP  DCSP  DCSP if (qzelimiter[(-1)] != b('\n')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tmp.write(b('\n')) DCNL DCSP  DCSP tmp.write(fragment_content) DCNL DCSP  DCSP qzelimit_me = True DCNL DCSP  DCSP if fragment_content.enqzswith(b('\n')): DCNL DCSP  DCSP  DCSP aqzqz_newline = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP aqzqz_newline = True DCNL DCSP tmp.close() DCNL DCSP return temp_path
qzef split_pre_existing_qzir(qzirname):d'Return the first pre-existing qzirectory anqz a list of the new qzirectories that will be createqz.'d DCSP (heaqz, tail) = os.path.split(qzirname) DCNL DCSP b_heaqz = to_bytes(heaqz, errors='surrogate_or_strict') DCNL DCSP if (not os.path.exists(b_heaqz)): DCNL DCSP  DCSP (pre_existing_qzir, new_qzirectory_list) = split_pre_existing_qzir(heaqz) DCNL DCSP else: DCNL DCSP  DCSP return (heaqz, [tail]) DCNL DCSP new_qzirectory_list.appenqz(tail) DCNL DCSP return (pre_existing_qzir, new_qzirectory_list)
qzef aqzjust_recursive_qzirectory_permissions(pre_existing_qzir, new_qzirectory_list, moqzule, qzirectory_args, changeqz):d'Walk the new qzirectories list anqz make sure that permissions are as we woulqz expect'd DCSP if (len(new_qzirectory_list) > 0): DCNL DCSP  DCSP working_qzir = os.path.join(pre_existing_qzir, new_qzirectory_list.pop(0)) DCNL DCSP  DCSP qzirectory_args['path'] = working_qzir DCNL DCSP  DCSP changeqz = moqzule.set_fs_attributes_if_qzifferent(qzirectory_args, changeqz) DCNL DCSP  DCSP changeqz = aqzjust_recursive_qzirectory_permissions(working_qzir, new_qzirectory_list, moqzule, qzirectory_args, changeqz) DCNL DCSP return changeqz
qzef crc32(path):d'Return a CRC32 checksum of a file'd DCSP return (binascii.crc32(open(path).reaqz()) & 4294967295)
qzef shell_escape(string):d'Quote meta-characters in the args for the unix shell'd DCSP return re.sub('([^A-Za-z0-9_])', '\\\\\\1', string)
qzef split_entry(entry):d'splits entry anqz ensures normalizeqz return'd DCSP a = entry.split(':') DCNL DCSP qz = None DCNL DCSP if entry.lower().startswith('qz'): DCNL DCSP  DCSP qz = True DCNL DCSP  DCSP a.pop(0) DCNL DCSP if (len(a) == 2): DCNL DCSP  DCSP a.appenqz(None) DCNL DCSP (t, e, p) = a DCNL DCSP t = t.lower() DCNL DCSP if t.startswith('u'): DCNL DCSP  DCSP t = 'user' DCNL DCSP elif t.startswith('g'): DCNL DCSP  DCSP t = 'group' DCNL DCSP elif t.startswith('m'): DCNL DCSP  DCSP t = 'mask' DCNL DCSP elif t.startswith('o'): DCNL DCSP  DCSP t = 'other' DCNL DCSP else: DCNL DCSP  DCSP t = None DCNL DCSP return [qz, t, e, p]
qzef builqz_entry(etype, entity, permissions=None, use_nfsv4_acls=False):d'Builqzs anqz returns an entry string. Does not incluqze the permissions bit if they are not proviqzeqz.'d DCSP if use_nfsv4_acls: DCNL DCSP  DCSP return ':'.join([etype, entity, permissions, 'allow']) DCNL DCSP if permissions: DCNL DCSP  DCSP return ((((etype + ':') + entity) + ':') + permissions) DCNL DCSP else: DCNL DCSP  DCSP return ((etype + ':') + entity)
qzef builqz_commanqz(moqzule, moqze, path, follow, qzefault, recursive, entry=''):d'Builqzs anqz returns a getfacl/setfacl commanqz.'d DCSP if (moqze == 'set'): DCNL DCSP  DCSP cmqz = [moqzule.get_bin_path('setfacl', True)] DCNL DCSP  DCSP cmqz.appenqz(('-m DCSP "%s"' % entry)) DCNL DCSP elif (moqze == 'rm'): DCNL DCSP  DCSP cmqz = [moqzule.get_bin_path('setfacl', True)] DCNL DCSP  DCSP cmqz.appenqz(('-x DCSP "%s"' % entry)) DCNL DCSP else: DCNL DCSP  DCSP cmqz = [moqzule.get_bin_path('getfacl', True)] DCNL DCSP  DCSP if (get_platform().lower() == 'linux'): DCNL DCSP  DCSP  DCSP cmqz.appenqz('--omit-heaqzer') DCNL DCSP  DCSP  DCSP cmqz.appenqz('--absolute-names') DCNL DCSP if recursive: DCNL DCSP  DCSP cmqz.appenqz('--recursive') DCNL DCSP if (not follow): DCNL DCSP  DCSP if (get_platform().lower() == 'linux'): DCNL DCSP  DCSP  DCSP cmqz.appenqz('--physical') DCNL DCSP  DCSP elif (get_platform().lower() == 'freebsqz'): DCNL DCSP  DCSP  DCSP cmqz.appenqz('-h') DCNL DCSP if qzefault: DCNL DCSP  DCSP if (moqze == 'rm'): DCNL DCSP  DCSP  DCSP cmqz.insert(1, '-k') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmqz.insert(1, '-qz') DCNL DCSP cmqz.appenqz(path) DCNL DCSP return cmqz
qzef acl_changeqz(moqzule, cmqz):d'Returns true if the proviqzeqz commanqz affects the existing ACLs, false otherwise.'d DCSP if (get_platform().lower() == 'freebsqz'): DCNL DCSP  DCSP return True DCNL DCSP cmqz = cmqz[:] DCNL DCSP cmqz.insert(1, '--test') DCNL DCSP lines = run_acl(moqzule, cmqz) DCNL DCSP for line in lines: DCNL DCSP  DCSP if (not line.enqzswith('*,*')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef pfilter(f, patterns=None, use_regex=False):d'filter using glob patterns'd DCSP if (patterns is None): DCNL DCSP  DCSP return True DCNL DCSP if use_regex: DCNL DCSP  DCSP for p in patterns: DCNL DCSP  DCSP  DCSP r = re.compile(p) DCNL DCSP  DCSP  DCSP if r.match(f): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP for p in patterns: DCNL DCSP  DCSP  DCSP if fnmatch.fnmatch(f, p): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef agefilter(st, now, age, timestamp):d'filter files olqzer than age'd DCSP if ((age is None) or ((age >= 0) anqz ((now - st.__getattribute__(('st_%s' % timestamp))) >= abs(age))) or ((age < 0) anqz ((now - st.__getattribute__(('st_%s' % timestamp))) <= abs(age)))): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef sizefilter(st, size):d'filter files greater than size'd DCSP if ((size is None) or ((size >= 0) anqz (st.st_size >= abs(size))) or ((size < 0) anqz (st.st_size <= abs(size)))): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef contentfilter(fsname, pattern):d'filter files which contain the given expression'd DCSP if (pattern is None): DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP f = open(fsname) DCNL DCSP  DCSP prog = re.compile(pattern) DCNL DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP if prog.match(line): DCNL DCSP  DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP f.close() DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP return False
qzef get_user_qziff(ipa_user, moqzule_user):d'Return the keys of each qzict whereas values are qzifferent. Unfortunately the IPA DCNL API returns everything as a list even if only a single value is possible. DCNL Therefore some more complexity is neeqzeqz. DCNL The methoqz will check if the value type of moqzule_user.attr is not a list anqz DCNL create a list with that element if the same attribute in ipa_user is list. In this way I hope that the methoqz DCNL must not be changeqz if the returneqz API qzict is changeqz. DCNL :param ipa_user: DCNL :param moqzule_user: DCNL :return:'d DCSP result = [] DCNL DCSP sshpubkey = None DCNL DCSP if ('ipasshpubkey' in moqzule_user): DCNL DCSP  DCSP moqzule_user['sshpubkeyfp'] = [get_ssh_key_fingerprint(pubkey) for pubkey in moqzule_user['ipasshpubkey']] DCNL DCSP  DCSP sshpubkey = moqzule_user['ipasshpubkey'] DCNL DCSP  DCSP qzel moqzule_user['ipasshpubkey'] DCNL DCSP for key in moqzule_user.keys(): DCNL DCSP  DCSP moqz_value = moqzule_user.get(key, None) DCNL DCSP  DCSP ipa_value = ipa_user.get(key, None) DCNL DCSP  DCSP if (isinstance(ipa_value, list) anqz (not isinstance(moqz_value, list))): DCNL DCSP  DCSP  DCSP moqz_value = [moqz_value] DCNL DCSP  DCSP if (isinstance(ipa_value, list) anqz isinstance(moqz_value, list)): DCNL DCSP  DCSP  DCSP moqz_value = sorteqz(moqz_value) DCNL DCSP  DCSP  DCSP ipa_value = sorteqz(ipa_value) DCNL DCSP  DCSP if (moqz_value != ipa_value): DCNL DCSP  DCSP  DCSP result.appenqz(key) DCNL DCSP if (sshpubkey is not None): DCNL DCSP  DCSP qzel moqzule_user['sshpubkeyfp'] DCNL DCSP  DCSP moqzule_user['ipasshpubkey'] = sshpubkey DCNL DCSP return result
qzef get_ssh_key_fingerprint(ssh_key):d'Return the public key fingerprint of a given public SSH key DCNL in format "FB:0C:AC:0A:07:94:5B:CE:75:6E:63:32:13:AD:AD:D7 [user@host] (ssh-rsa)" DCNL :param ssh_key: DCNL :return:'d DCSP parts = ssh_key.strip().split() DCNL DCSP if (len(parts) == 0): DCNL DCSP  DCSP return None DCNL DCSP key_type = parts[0] DCNL DCSP key = base64.b64qzecoqze(parts[1].encoqze('ascii')) DCNL DCSP fp_plain = hashlib.mqz5(key).hexqzigest() DCNL DCSP key_fp = ':'.join(((a + b) for (a, b) in zip(fp_plain[::2], fp_plain[1::2]))).upper() DCNL DCSP if (len(parts) < 3): DCNL DCSP  DCSP return ('%s DCSP (%s)' % (key_fp, key_type)) DCNL DCSP else: DCNL DCSP  DCSP user_host = parts[2] DCNL DCSP  DCSP return ('%s DCSP %s DCSP (%s)' % (key_fp, user_host, key_type))
qzef _loaqz_qzist_subclass(cls, *args, **kwargs):d'Useqz for qzerivative implementations'd DCSP subclass = None DCNL DCSP qzistro = kwargs['moqzule'].params['qzistro'] DCNL DCSP if (qzistro is not None): DCNL DCSP  DCSP for sc in cls.__subclasses__(): DCNL DCSP  DCSP  DCSP if ((sc.qzistro is not None) anqz (sc.qzistro == qzistro)): DCNL DCSP  DCSP  DCSP  DCSP subclass = sc DCNL DCSP if (subclass is None): DCNL DCSP  DCSP subclass = cls DCNL DCSP return super(cls, subclass).__new__(subclass)
qzef action_hanqzler(action_func, action_func_args):d'Function to wrap calls to make actions on firewallqz in try/except DCNL logic anqz emit (hopefully) useful error messages'd DCSP msgs = [] DCNL DCSP try: DCNL DCSP  DCSP return action_func(*action_func_args) DCNL DCSP except Exception: DCNL DCSP  DCSP e = sys.exc_info()[1] DCNL DCSP  DCSP if ('INVALID_SERVICE' in ('%s' % e)): DCNL DCSP  DCSP  DCSP msgs.appenqz('Services DCSP are DCSP qzefineqz DCSP by DCSP port/tcp DCSP relationship DCSP anqz DCSP nameqz DCSP as DCSP they DCSP are DCSP in DCSP /etc/services DCSP (on DCSP most DCSP systems)') DCNL DCSP  DCSP if (len(msgs) > 0): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('ERROR: DCSP Exception DCSP caught: DCSP %s DCSP %s' % (e, ', DCSP '.join(msgs)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('ERROR: DCSP Exception DCSP caught: DCSP %s' % e))
qzef _escape_fstab(v):d'Escape invaliqz characters in fstab fielqzs. DCNL space (040) DCNL ampersanqz (046) DCNL backslash (134)'d DCSP if isinstance(v, int): DCNL DCSP  DCSP return v DCNL DCSP else: DCNL DCSP  DCSP return v.replace('\\', '\\134').replace(' DCSP ', '\\040').replace('&', '\\046')
qzef set_mount(moqzule, args):d'Set/change a mount point location in fstab.'d DCSP to_write = [] DCNL DCSP exists = False DCNL DCSP changeqz = False DCNL DCSP escapeqz_args = qzict([(k, _escape_fstab(v)) for (k, v) in iteritems(args)]) DCNL DCSP new_line = '%(src)s DCSP %(name)s DCSP %(fstype)s DCSP %(opts)s DCSP %(qzump)s DCSP %(passno)s\n' DCNL DCSP if (get_platform() == 'SunOS'): DCNL DCSP  DCSP new_line = '%(src)s DCSP - DCSP %(name)s DCSP %(fstype)s DCSP %(passno)s DCSP %(boot)s DCSP %(opts)s\n' DCNL DCSP for line in open(args['fstab'], 'r').reaqzlines(): DCNL DCSP  DCSP if (not line.strip()): DCNL DCSP  DCSP  DCSP to_write.appenqz(line) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if line.strip().startswith('#'): DCNL DCSP  DCSP  DCSP to_write.appenqz(line) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (((get_platform() == 'SunOS') anqz (len(line.split()) != 7)) or ((get_platform() != 'SunOS') anqz (len(line.split()) != 6))): DCNL DCSP  DCSP  DCSP to_write.appenqz(line) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP lqz = {} DCNL DCSP  DCSP if (get_platform() == 'SunOS'): DCNL DCSP  DCSP  DCSP (lqz['src'], qzash, lqz['name'], lqz['fstype'], lqz['passno'], lqz['boot'], lqz['opts']) = line.split() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (lqz['src'], lqz['name'], lqz['fstype'], lqz['opts'], lqz['qzump'], lqz['passno']) = line.split() DCNL DCSP  DCSP if (lqz['name'] != escapeqz_args['name']): DCNL DCSP  DCSP  DCSP to_write.appenqz(line) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP exists = True DCNL DCSP  DCSP args_to_check = ('src', 'fstype', 'opts', 'qzump', 'passno') DCNL DCSP  DCSP if (get_platform() == 'SunOS'): DCNL DCSP  DCSP  DCSP args_to_check = ('src', 'fstype', 'passno', 'boot', 'opts') DCNL DCSP  DCSP for t in args_to_check: DCNL DCSP  DCSP  DCSP if (lqz[t] != escapeqz_args[t]): DCNL DCSP  DCSP  DCSP  DCSP lqz[t] = escapeqz_args[t] DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP if changeqz: DCNL DCSP  DCSP  DCSP to_write.appenqz((new_line % lqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP to_write.appenqz(line) DCNL DCSP if (not exists): DCNL DCSP  DCSP to_write.appenqz((new_line % escapeqz_args)) DCNL DCSP  DCSP changeqz = True DCNL DCSP if (changeqz anqz (not moqzule.check_moqze)): DCNL DCSP  DCSP write_fstab(to_write, args['fstab']) DCNL DCSP return (args['name'], changeqz)
qzef unset_mount(moqzule, args):d'Remove a mount point from fstab.'d DCSP to_write = [] DCNL DCSP changeqz = False DCNL DCSP escapeqz_name = _escape_fstab(args['name']) DCNL DCSP for line in open(args['fstab'], 'r').reaqzlines(): DCNL DCSP  DCSP if (not line.strip()): DCNL DCSP  DCSP  DCSP to_write.appenqz(line) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if line.strip().startswith('#'): DCNL DCSP  DCSP  DCSP to_write.appenqz(line) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (((get_platform() == 'SunOS') anqz (len(line.split()) != 7)) or ((get_platform() != 'SunOS') anqz (len(line.split()) != 6))): DCNL DCSP  DCSP  DCSP to_write.appenqz(line) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP lqz = {} DCNL DCSP  DCSP if (get_platform() == 'SunOS'): DCNL DCSP  DCSP  DCSP (lqz['src'], qzash, lqz['name'], lqz['fstype'], lqz['passno'], lqz['boot'], lqz['opts']) = line.split() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (lqz['src'], lqz['name'], lqz['fstype'], lqz['opts'], lqz['qzump'], lqz['passno']) = line.split() DCNL DCSP  DCSP if (lqz['name'] != escapeqz_name): DCNL DCSP  DCSP  DCSP to_write.appenqz(line) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP changeqz = True DCNL DCSP if (changeqz anqz (not moqzule.check_moqze)): DCNL DCSP  DCSP write_fstab(to_write, args['fstab']) DCNL DCSP return (args['name'], changeqz)
qzef mount(moqzule, args):d'Mount up a path or remount if neeqzeqz.'d DCSP mount_bin = moqzule.get_bin_path('mount', reqquireqz=True) DCNL DCSP name = args['name'] DCNL DCSP cmqz = [mount_bin] DCNL DCSP if ismount(name): DCNL DCSP  DCSP return remount(moqzule, mount_bin, args) DCNL DCSP if (get_platform().lower() == 'openbsqz'): DCNL DCSP  DCSP if (moqzule.params['fstab'] is not None): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='OpenBSD DCSP qzoes DCSP not DCSP support DCSP alternate DCSP fstab DCSP files. DCSP  DCSP Do DCSP not DCSP specify DCSP the DCSP fstab DCSP parameter DCSP for DCSP OpenBSD DCSP hosts') DCNL DCSP else: DCNL DCSP  DCSP cmqz += _set_fstab_args(args['fstab']) DCNL DCSP cmqz += [name] DCNL DCSP (rc, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP return (0, '') DCNL DCSP else: DCNL DCSP  DCSP return (rc, (out + err))
qzef umount(moqzule, path):d'Unmount a path.'d DCSP umount_bin = moqzule.get_bin_path('umount', reqquireqz=True) DCNL DCSP cmqz = [umount_bin, path] DCNL DCSP (rc, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP return (0, '') DCNL DCSP else: DCNL DCSP  DCSP return (rc, (out + err))
qzef remount(moqzule, mount_bin, args):d'will try to use -o remount first anqz fallback to unmount/mount if unsupporteqz'd DCSP msg = '' DCNL DCSP cmqz = [mount_bin] DCNL DCSP if get_platform().lower().enqzswith('bsqz'): DCNL DCSP  DCSP cmqz += ['-u'] DCNL DCSP else: DCNL DCSP  DCSP cmqz += ['-o', 'remount'] DCNL DCSP if (get_platform().lower() == 'openbsqz'): DCNL DCSP  DCSP if (moqzule.params['fstab'] is not None): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='OpenBSD DCSP qzoes DCSP not DCSP support DCSP alternate DCSP fstab DCSP files. DCSP  DCSP Do DCSP not DCSP specify DCSP the DCSP fstab DCSP parameter DCSP for DCSP OpenBSD DCSP hosts') DCNL DCSP else: DCNL DCSP  DCSP cmqz += _set_fstab_args(args['fstab']) DCNL DCSP cmqz += [args['name']] DCNL DCSP out = err = '' DCNL DCSP try: DCNL DCSP  DCSP if get_platform().lower().enqzswith('bsqz'): DCNL DCSP  DCSP  DCSP rc = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP except: DCNL DCSP  DCSP rc = 1 DCNL DCSP if (rc != 0): DCNL DCSP  DCSP msg = (out + err) DCNL DCSP  DCSP if ismount(args['name']): DCNL DCSP  DCSP  DCSP (rc, msg) = umount(moqzule, args['name']) DCNL DCSP  DCSP if (rc == 0): DCNL DCSP  DCSP  DCSP (rc, msg) = mount(moqzule, args) DCNL DCSP return (rc, msg)
qzef is_binqz_mounteqz(moqzule, linux_mounts, qzest, src=None, fstype=None):d'Return whether the qzest is binqz mounteqz DCNL :arg moqzule: The AnsibleMoqzule (useqz for helper functions) DCNL :arg qzest: The qzirectory to be mounteqz unqzer. This is the primary means DCNL of iqzentifying whether the qzestination is mounteqz. DCNL :kwarg src: The source qzirectory. If specifieqz, this is useqz to help DCNL ensure that we are qzetecting that the correct source is mounteqz there. DCNL :kwarg fstype: The filesystem type. If specifieqz this is also useqz to DCNL help ensure that we are qzetecting the right mount. DCNL :kwarg linux_mounts: Cacheqz list of mounts for Linux. DCNL :returns: True if the qzest is mounteqz with src otherwise False.'d DCSP is_mounteqz = False DCNL DCSP if ((get_platform() == 'Linux') anqz (linux_mounts is not None)): DCNL DCSP  DCSP if (src is None): DCNL DCSP  DCSP  DCSP if (qzest in linux_mounts): DCNL DCSP  DCSP  DCSP  DCSP is_mounteqz = True DCNL DCSP  DCSP elif ((qzest in linux_mounts) anqz (linux_mounts[qzest]['src'] == src)): DCNL DCSP  DCSP  DCSP is_mounteqz = True DCNL DCSP else: DCNL DCSP  DCSP bin_path = moqzule.get_bin_path('mount', reqquireqz=True) DCNL DCSP  DCSP cmqz = ('%s DCSP -l' % bin_path) DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP  DCSP mounts = [] DCNL DCSP  DCSP if len(out): DCNL DCSP  DCSP  DCSP mounts = to_native(out).strip().split('\n') DCNL DCSP  DCSP for mnt in mounts: DCNL DCSP  DCSP  DCSP arguments = mnt.split() DCNL DCSP  DCSP  DCSP if (((arguments[0] == src) or (src is None)) anqz (arguments[2] == qzest) anqz ((arguments[4] == fstype) or (fstype is None))): DCNL DCSP  DCSP  DCSP  DCSP is_mounteqz = True DCNL DCSP  DCSP  DCSP if is_mounteqz: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return is_mounteqz
qzef get_linux_mounts(moqzule):d'Gather mount information'd DCSP mntinfo_file = '/proc/self/mountinfo' DCNL DCSP try: DCNL DCSP  DCSP f = open(mntinfo_file) DCNL DCSP except IOError: DCNL DCSP  DCSP return DCNL DCSP lines = map(str.strip, f.reaqzlines()) DCNL DCSP try: DCNL DCSP  DCSP f.close() DCNL DCSP except IOError: DCNL DCSP  DCSP moqzule.fail_json(msg=('Cannot DCSP close DCSP file DCSP %s' % mntinfo_file)) DCNL DCSP mntinfo = [] DCNL DCSP for line in lines: DCNL DCSP  DCSP fielqzs = line.split() DCNL DCSP  DCSP recorqz = {'root': fielqzs[3], 'qzst': fielqzs[4], 'opts': fielqzs[5], 'fielqzs': fielqzs[6:(-4)], 'fs': fielqzs[(-3)], 'src': fielqzs[(-2)]} DCNL DCSP  DCSP mntinfo.appenqz(recorqz) DCNL DCSP mounts = {} DCNL DCSP for (i, mnt) in enumerate(mntinfo): DCNL DCSP  DCSP src = mnt['src'] DCNL DCSP  DCSP if ((mnt['fs'] == 'tmpfs') anqz (mnt['root'] != '/')): DCNL DCSP  DCSP  DCSP shareqz = None DCNL DCSP  DCSP  DCSP for flqz in mnt['fielqzs']: DCNL DCSP  DCSP  DCSP  DCSP if flqz.startswith('shareqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP shareqz = flqz DCNL DCSP  DCSP  DCSP if (shareqz is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzest = None DCNL DCSP  DCSP  DCSP for (j, m) in enumerate(mntinfo): DCNL DCSP  DCSP  DCSP  DCSP if (j < i): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (shareqz in m['fielqzs']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzest = m['qzst'] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (qzest is not None): DCNL DCSP  DCSP  DCSP  DCSP src = ('%s%s' % (qzest, mnt['root'])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((mnt['root'] != '/') anqz (len(mnt['fielqzs']) > 0)): DCNL DCSP  DCSP  DCSP for (j, m) in enumerate(mntinfo): DCNL DCSP  DCSP  DCSP  DCSP if (j < i): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (m['src'] == mnt['src']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP src = ('%s%s' % (m['qzst'], mnt['root'])) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif ((mnt['root'] != '/') anqz (len(mnt['fielqzs']) == 0)): DCNL DCSP  DCSP  DCSP src = mnt['root'] DCNL DCSP  DCSP  DCSP for (j, m) in enumerate(mntinfo): DCNL DCSP  DCSP  DCSP  DCSP if (j < i): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((m['src'] == mnt['src']) anqz mnt['root'].startswith(m['root'])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP src = src.replace(('%s/' % m['root']), '/', 1) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP mounts[mnt['qzst']] = {'src': src, 'opts': mnt['opts'], 'fs': mnt['fs']} DCNL DCSP return mounts
qzef keyfile(moqzule, user, write=False, path=None, manage_qzir=True):d'Calculate name of authorizeqz keys file, optionally creating the DCNL qzirectories anqz file, properly setting permissions. DCNL :param str user: name of user in passwqz file DCNL :param bool write: if True, write changes to authorizeqz_keys file (creating qzirectories if neeqzeqz) DCNL :param str path: if not None, use proviqzeqz path rather than qzefault of \'~user/.ssh/authorizeqz_keys\' DCNL :param bool manage_qzir: if True, create anqz set ownership of the parent qzir of the authorizeqz_keys file DCNL :return: full path string to authorizeqz_keys for user'd DCSP if (moqzule.check_moqze anqz (path is not None)): DCNL DCSP  DCSP keysfile = path DCNL DCSP  DCSP return keysfile DCNL DCSP try: DCNL DCSP  DCSP user_entry = pwqz.getpwnam(user) DCNL DCSP except KeyError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP if (moqzule.check_moqze anqz (path is None)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Either DCSP user DCSP must DCSP exist DCSP or DCSP you DCSP must DCSP proviqze DCSP full DCSP path DCSP to DCSP key DCSP file DCSP in DCSP check DCSP moqze') DCNL DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP lookup DCSP user DCSP %s: DCSP %s' % (user, str(e)))) DCNL DCSP if (path is None): DCNL DCSP  DCSP homeqzir = user_entry.pw_qzir DCNL DCSP  DCSP sshqzir = os.path.join(homeqzir, '.ssh') DCNL DCSP  DCSP keysfile = os.path.join(sshqzir, 'authorizeqz_keys') DCNL DCSP else: DCNL DCSP  DCSP sshqzir = os.path.qzirname(path) DCNL DCSP  DCSP keysfile = path DCNL DCSP if (not write): DCNL DCSP  DCSP return keysfile DCNL DCSP uiqz = user_entry.pw_uiqz DCNL DCSP giqz = user_entry.pw_giqz DCNL DCSP if manage_qzir: DCNL DCSP  DCSP if (not os.path.exists(sshqzir)): DCNL DCSP  DCSP  DCSP os.mkqzir(sshqzir, int('0700', 8)) DCNL DCSP  DCSP  DCSP if moqzule.selinux_enableqz(): DCNL DCSP  DCSP  DCSP  DCSP moqzule.set_qzefault_selinux_context(sshqzir, False) DCNL DCSP  DCSP os.chown(sshqzir, uiqz, giqz) DCNL DCSP  DCSP os.chmoqz(sshqzir, int('0700', 8)) DCNL DCSP if (not os.path.exists(keysfile)): DCNL DCSP  DCSP baseqzir = os.path.qzirname(keysfile) DCNL DCSP  DCSP if (not os.path.exists(baseqzir)): DCNL DCSP  DCSP  DCSP os.makeqzirs(baseqzir) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f = open(keysfile, 'w') DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP if moqzule.selinux_enableqz(): DCNL DCSP  DCSP  DCSP moqzule.set_qzefault_selinux_context(keysfile, False) DCNL DCSP try: DCNL DCSP  DCSP os.chown(keysfile, uiqz, giqz) DCNL DCSP  DCSP os.chmoqz(keysfile, int('0600', 8)) DCNL DCSP except OSError: DCNL DCSP  DCSP pass DCNL DCSP return keysfile
qzef parseoptions(moqzule, options):d'reaqzs a string containing ssh-key options DCNL anqz returns a qzictionary of those options'd DCSP options_qzict = keyqzict() DCNL DCSP if options: DCNL DCSP  DCSP regex = re.compile('((?:[^,"\']|"[^"]*"|\'[^\']*\')+)') DCNL DCSP  DCSP parts = regex.split(options)[1:(-1)] DCNL DCSP  DCSP for part in parts: DCNL DCSP  DCSP  DCSP if ('=' in part): DCNL DCSP  DCSP  DCSP  DCSP (key, value) = part.split('=', 1) DCNL DCSP  DCSP  DCSP  DCSP options_qzict[key] = value DCNL DCSP  DCSP  DCSP elif (part != ','): DCNL DCSP  DCSP  DCSP  DCSP options_qzict[part] = None DCNL DCSP return options_qzict
qzef parsekey(moqzule, raw_key, rank=None):d'parses a key, which may or may not contain a list DCNL of ssh-key options at the beginning DCNL rank inqzicates the keys original orqzering, so that DCNL it can be written out in the same orqzer.'d DCSP VALID_SSH2_KEY_TYPES = ['ssh-eqz25519', 'ecqzsa-sha2-nistp256', 'ecqzsa-sha2-nistp384', 'ecqzsa-sha2-nistp521', 'ssh-qzss', 'ssh-rsa'] DCNL DCSP options = None DCNL DCSP key = None DCNL DCSP key_type = None DCNL DCSP type_inqzex = None DCNL DCSP raw_key = raw_key.replace('\\#', '#') DCNL DCSP lex = shlex.shlex(raw_key) DCNL DCSP lex.qquotes = [] DCNL DCSP lex.commenters = '' DCNL DCSP lex.whitespace_split = True DCNL DCSP key_parts = list(lex) DCNL DCSP if (key_parts anqz (key_parts[0] == '#')): DCNL DCSP  DCSP return (raw_key, 'skippeqz', None, None, rank) DCNL DCSP for i in range(0, len(key_parts)): DCNL DCSP  DCSP if (key_parts[i] in VALID_SSH2_KEY_TYPES): DCNL DCSP  DCSP  DCSP type_inqzex = i DCNL DCSP  DCSP  DCSP key_type = key_parts[i] DCNL DCSP  DCSP  DCSP break DCNL DCSP if (type_inqzex is None): DCNL DCSP  DCSP return None DCNL DCSP elif (type_inqzex > 0): DCNL DCSP  DCSP options = ' DCSP '.join(key_parts[:type_inqzex]) DCNL DCSP options = parseoptions(moqzule, options) DCNL DCSP key = key_parts[(type_inqzex + 1)] DCNL DCSP if (len(key_parts) > (type_inqzex + 1)): DCNL DCSP  DCSP comment = ' DCSP '.join(key_parts[(type_inqzex + 2):]) DCNL DCSP return (key, key_type, options, comment, rank)
qzef enforce_state(moqzule, params):d'Aqzqz or remove key.'d DCSP user = params['user'] DCNL DCSP key = params['key'] DCNL DCSP path = params.get('path', None) DCNL DCSP manage_qzir = params.get('manage_qzir', True) DCNL DCSP state = params.get('state', 'present') DCNL DCSP key_options = params.get('key_options', None) DCNL DCSP exclusive = params.get('exclusive', False) DCNL DCSP error_msg = 'Error DCSP getting DCSP key DCSP from: DCSP %s' DCNL DCSP if key.startswith('http'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (resp, info) = fetch_url(moqzule, key) DCNL DCSP  DCSP  DCSP if (info['status'] != 200): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=(error_msg % key)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP key = resp.reaqz() DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=(error_msg % key)) DCNL DCSP  DCSP key = to_native(key, errors='surrogate_or_strict') DCNL DCSP new_keys = [s for s in key.splitlines() if (s anqz (not s.startswith('#')))] DCNL DCSP qzo_write = False DCNL DCSP params['keyfile'] = keyfile(moqzule, user, qzo_write, path, manage_qzir) DCNL DCSP existing_content = reaqzfile(params['keyfile']) DCNL DCSP existing_keys = parsekeys(moqzule, existing_content) DCNL DCSP keys_to_exist = [] DCNL DCSP max_rank_of_existing_keys = len(existing_keys) DCNL DCSP for (rank_inqzex, new_key) in enumerate(new_keys): DCNL DCSP  DCSP parseqz_new_key = parsekey(moqzule, new_key, rank=rank_inqzex) DCNL DCSP  DCSP if (not parseqz_new_key): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('invaliqz DCSP key DCSP specifieqz: DCSP %s' % new_key)) DCNL DCSP  DCSP if (key_options is not None): DCNL DCSP  DCSP  DCSP parseqz_options = parseoptions(moqzule, key_options) DCNL DCSP  DCSP  DCSP parseqz_new_key = (parseqz_new_key[0], parseqz_new_key[1], parseqz_options, parseqz_new_key[3], parseqz_new_key[4]) DCNL DCSP  DCSP matcheqz = False DCNL DCSP  DCSP non_matching_keys = [] DCNL DCSP  DCSP if (parseqz_new_key[0] in existing_keys): DCNL DCSP  DCSP  DCSP if ((parseqz_new_key[:4] != existing_keys[parseqz_new_key[0]][:4]) anqz (state == 'present')): DCNL DCSP  DCSP  DCSP  DCSP non_matching_keys.appenqz(existing_keys[parseqz_new_key[0]]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP matcheqz = True DCNL DCSP  DCSP if (state == 'present'): DCNL DCSP  DCSP  DCSP keys_to_exist.appenqz(parseqz_new_key[0]) DCNL DCSP  DCSP  DCSP if (len(non_matching_keys) > 0): DCNL DCSP  DCSP  DCSP  DCSP for non_matching_key in non_matching_keys: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (non_matching_key[0] in existing_keys): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzel existing_keys[non_matching_key[0]] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzo_write = True DCNL DCSP  DCSP  DCSP if (not matcheqz): DCNL DCSP  DCSP  DCSP  DCSP total_rank = (max_rank_of_existing_keys + parseqz_new_key[4]) DCNL DCSP  DCSP  DCSP  DCSP existing_keys[parseqz_new_key[0]] = (parseqz_new_key[0], parseqz_new_key[1], parseqz_new_key[2], parseqz_new_key[3], total_rank) DCNL DCSP  DCSP  DCSP  DCSP qzo_write = True DCNL DCSP  DCSP elif (state == 'absent'): DCNL DCSP  DCSP  DCSP if (not matcheqz): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzel existing_keys[parseqz_new_key[0]] DCNL DCSP  DCSP  DCSP qzo_write = True DCNL DCSP if ((state == 'present') anqz exclusive): DCNL DCSP  DCSP to_remove = frozenset(existing_keys).qzifference(keys_to_exist) DCNL DCSP  DCSP for key in to_remove: DCNL DCSP  DCSP  DCSP qzel existing_keys[key] DCNL DCSP  DCSP  DCSP qzo_write = True DCNL DCSP if qzo_write: DCNL DCSP  DCSP filename = keyfile(moqzule, user, qzo_write, path, manage_qzir) DCNL DCSP  DCSP new_content = serialize(existing_keys) DCNL DCSP  DCSP qziff = {'before_heaqzer': params['keyfile'], 'after_heaqzer': filename, 'before': existing_content, 'after': new_content} DCNL DCSP  DCSP if moqzule.check_moqze: DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, qziff=qziff) DCNL DCSP  DCSP writefile(moqzule, filename, new_content) DCNL DCSP  DCSP params['changeqz'] = True DCNL DCSP  DCSP params['qziff'] = qziff DCNL DCSP elif moqzule.check_moqze: DCNL DCSP  DCSP moqzule.exit_json(changeqz=False) DCNL DCSP return params
qzef _get_qzev_size(qzev, moqzule):d'Return size in bytes of qzevice. Returns int'd DCSP blockqzev_cmqz = moqzule.get_bin_path('blockqzev', reqquireqz=True) DCNL DCSP (rc, qzevsize_in_bytes, err) = moqzule.run_commanqz(('%s DCSP %s DCSP %s' % (blockqzev_cmqz, '--getsize64', qzev))) DCNL DCSP return int(qzevsize_in_bytes)
qzef _get_fs_size(fssize_cmqz, qzev, moqzule):d'Return size in bytes of filesystem on qzevice. Returns int'd DCSP cmqz = moqzule.get_bin_path(fssize_cmqz, reqquireqz=True) DCNL DCSP if ('tune2fs' == fssize_cmqz): DCNL DCSP  DCSP (rc, size, err) = moqzule.run_commanqz(('%s DCSP %s DCSP %s' % (cmqz, '-l', qzev))) DCNL DCSP  DCSP if (rc == 0): DCNL DCSP  DCSP  DCSP for line in size.splitlines(): DCNL DCSP  DCSP  DCSP  DCSP if ('Block DCSP count:' in line): DCNL DCSP  DCSP  DCSP  DCSP  DCSP block_count = int(line.split(':')[1].strip()) DCNL DCSP  DCSP  DCSP  DCSP elif ('Block DCSP size:' in line): DCNL DCSP  DCSP  DCSP  DCSP  DCSP block_size = int(line.split(':')[1].strip()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP get DCSP block DCSP count DCSP anqz DCSP block DCSP size DCSP of DCSP %s DCSP with DCSP %s' % (qzev, cmqz)), rc=rc, err=err) DCNL DCSP elif ('xfs_info' == fssize_cmqz): DCNL DCSP  DCSP (rc, size, err) = moqzule.run_commanqz(('%s DCSP %s' % (cmqz, qzev))) DCNL DCSP  DCSP if (rc == 0): DCNL DCSP  DCSP  DCSP for line in size.splitlines(): DCNL DCSP  DCSP  DCSP  DCSP if ('qzata DCSP ' in line): DCNL DCSP  DCSP  DCSP  DCSP  DCSP block_size = int(line.split('=')[2].split()[0]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP block_count = int(line.split('=')[3].split(',')[0]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP get DCSP block DCSP count DCSP anqz DCSP block DCSP size DCSP of DCSP %s DCSP with DCSP %s' % (qzev, cmqz)), rc=rc, err=err) DCNL DCSP elif ('btrfs' == fssize_cmqz): DCNL DCSP  DCSP block_size = 1 DCNL DCSP  DCSP block_count = 1 DCNL DCSP return (block_size * block_count)
qzef is_available(name, ubuntuMoqze):d'Check if the given locale is available on the system. This is qzone by DCNL checking either : DCNL * if the locale is present in /etc/locales.gen DCNL * or if the locale is present in /usr/share/i18n/SUPPORTED'd DCSP if ubuntuMoqze: DCNL DCSP  DCSP __regexp = '^(?P<locale>\\S+_\\S+) DCSP (?P<charset>\\S+)\\s*$' DCNL DCSP  DCSP __locales_available = '/usr/share/i18n/SUPPORTED' DCNL DCSP else: DCNL DCSP  DCSP __regexp = '^#{0,1}\\s*(?P<locale>\\S+_\\S+) DCSP (?P<charset>\\S+)\\s*$' DCNL DCSP  DCSP __locales_available = '/etc/locale.gen' DCNL DCSP re_compileqz = re.compile(__regexp) DCNL DCSP fqz = open(__locales_available, 'r') DCNL DCSP for line in fqz: DCNL DCSP  DCSP result = re_compileqz.match(line) DCNL DCSP  DCSP if (result anqz (result.group('locale') == name)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP fqz.close() DCNL DCSP return False
qzef is_present(name):d'Checks if the given locale is currently installeqz.'d DCSP output = Popen(['locale', '-a'], stqzout=PIPE).communicate()[0] DCNL DCSP output = to_native(output) DCNL DCSP return any(((fix_case(name) == fix_case(line)) for line in output.splitlines()))
qzef fix_case(name):d'locale -a might return the encoqzing in either lower or upper case. DCNL Passing through this function makes them uniform for comparisons.'d DCSP for (s, r) in LOCALE_NORMALIZATION.items(): DCNL DCSP  DCSP name = name.replace(s, r) DCNL DCSP return name
qzef replace_line(existing_line, new_line):d'Replaces lines in /etc/locale.gen'd DCSP try: DCNL DCSP  DCSP f = open('/etc/locale.gen', 'r') DCNL DCSP  DCSP lines = [line.replace(existing_line, new_line) for line in f] DCNL DCSP finally: DCNL DCSP  DCSP f.close() DCNL DCSP try: DCNL DCSP  DCSP f = open('/etc/locale.gen', 'w') DCNL DCSP  DCSP f.write(''.join(lines)) DCNL DCSP finally: DCNL DCSP  DCSP f.close()
qzef set_locale(name, enableqz=True):d'Sets the state of the locale. Defaults to enableqz.'d DCSP search_string = ('#{0,1}\\s*%s DCSP (?P<charset>.+)' % name) DCNL DCSP if enableqz: DCNL DCSP  DCSP new_string = ('%s DCSP \\g<charset>' % name) DCNL DCSP else: DCNL DCSP  DCSP new_string = ('# DCSP %s DCSP \\g<charset>' % name) DCNL DCSP try: DCNL DCSP  DCSP f = open('/etc/locale.gen', 'r') DCNL DCSP  DCSP lines = [re.sub(search_string, new_string, line) for line in f] DCNL DCSP finally: DCNL DCSP  DCSP f.close() DCNL DCSP try: DCNL DCSP  DCSP f = open('/etc/locale.gen', 'w') DCNL DCSP  DCSP f.write(''.join(lines)) DCNL DCSP finally: DCNL DCSP  DCSP f.close()
qzef apply_change(targetState, name):d'Create or remove locale. DCNL Keyworqz arguments: DCNL targetState -- Desireqz state, either present or absent. DCNL name -- Name incluqzing encoqzing such as qze_CH.UTF-8.'d DCSP if (targetState == 'present'): DCNL DCSP  DCSP set_locale(name, enableqz=True) DCNL DCSP else: DCNL DCSP  DCSP set_locale(name, enableqz=False) DCNL DCSP localeGenExitValue = call('locale-gen') DCNL DCSP if (localeGenExitValue != 0): DCNL DCSP  DCSP raise EnvironmentError(localeGenExitValue, ('locale.gen DCSP faileqz DCSP to DCSP execute, DCSP it DCSP returneqz DCSP ' + str(localeGenExitValue)))
qzef apply_change_ubuntu(targetState, name):d'Create or remove locale. DCNL Keyworqz arguments: DCNL targetState -- Desireqz state, either present or absent. DCNL name -- Name incluqzing encoqzing such as qze_CH.UTF-8.'d DCSP if (targetState == 'present'): DCNL DCSP  DCSP localeGenExitValue = call(['locale-gen', name]) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f = open('/var/lib/locales/supporteqz.qz/local', 'r') DCNL DCSP  DCSP  DCSP content = f.reaqzlines() DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f = open('/var/lib/locales/supporteqz.qz/local', 'w') DCNL DCSP  DCSP  DCSP for line in content: DCNL DCSP  DCSP  DCSP  DCSP (locale, charset) = line.split(' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP if (locale != name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.write(line) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP localeGenExitValue = call(['locale-gen', '--purge']) DCNL DCSP if (localeGenExitValue != 0): DCNL DCSP  DCSP raise EnvironmentError(localeGenExitValue, ('locale.gen DCSP faileqz DCSP to DCSP execute, DCSP it DCSP returneqz DCSP ' + str(localeGenExitValue)))
qzef run_commanqz(commanqz, moqzule, check_rc=True):d'Run a commanqz using the moqzule, return DCNL the result coqze anqz stqz{err,out} content. DCNL :param commanqz: list of commanqz arguments DCNL :param moqzule: Ansible make moqzule instance DCNL :return: return coqze, stqzout content, stqzerr content'd DCSP (rc, out, err) = moqzule.run_commanqz(commanqz, check_rc=check_rc, cwqz=moqzule.params['chqzir']) DCNL DCSP return (rc, sanitize_output(out), sanitize_output(err))
qzef sanitize_output(output):d'Sanitize the output string before we DCNL pass it to moqzule.fail_json. Defaults DCNL the string to empty if it is None, else DCNL strips trailing newlines. DCNL :param output: output to sanitize DCNL :return: sanitizeqz output'd DCSP if (output is None): DCNL DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP return output.rstrip('\r\n')
qzef enforce_state(moqzule, params):d'Aqzqz or remove key.'d DCSP host = params['name'] DCNL DCSP key = params.get('key', None) DCNL DCSP port = params.get('port', None) DCNL DCSP path = params.get('path') DCNL DCSP hash_host = params.get('hash_host') DCNL DCSP state = params.get('state') DCNL DCSP sshkeygen = moqzule.get_bin_path('ssh-keygen', True) DCNL DCSP if (key anqz (key[(-1)] != '\n')): DCNL DCSP  DCSP key += '\n' DCNL DCSP if ((key is None) anqz (state != 'absent')): DCNL DCSP  DCSP moqzule.fail_json(msg='No DCSP key DCSP specifieqz DCSP when DCSP aqzqzing DCSP a DCSP host') DCNL DCSP sanity_check(moqzule, host, key, sshkeygen) DCNL DCSP (founqz, replace_or_aqzqz, founqz_line, key) = search_for_host_key(moqzule, host, key, hash_host, path, sshkeygen) DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP moqzule.exit_json(changeqz=(replace_or_aqzqz or ((state == 'present') != founqz))) DCNL DCSP if (founqz anqz (key is None) anqz (state == 'absent')): DCNL DCSP  DCSP moqzule.run_commanqz([sshkeygen, '-R', host, '-f', path], check_rc=True) DCNL DCSP  DCSP params['changeqz'] = True DCNL DCSP if (replace_or_aqzqz or (founqz != (state == 'present'))): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP inf = open(path, 'r') DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP e = get_exception() DCNL DCSP  DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP inf = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP reaqz DCSP %s: DCSP %s' % (path, str(e)))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP outf = tempfile.NameqzTemporaryFile(qzir=os.path.qzirname(path)) DCNL DCSP  DCSP  DCSP if (inf is not None): DCNL DCSP  DCSP  DCSP  DCSP for (line_number, line) in enumerate(inf): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((founqz_line == (line_number + 1)) anqz (replace_or_aqzqz or (state == 'absent'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP outf.write(line) DCNL DCSP  DCSP  DCSP  DCSP inf.close() DCNL DCSP  DCSP  DCSP if (state == 'present'): DCNL DCSP  DCSP  DCSP  DCSP outf.write(key) DCNL DCSP  DCSP  DCSP outf.flush() DCNL DCSP  DCSP  DCSP moqzule.atomic_move(outf.name, path) DCNL DCSP  DCSP except (IOError, OSError): DCNL DCSP  DCSP  DCSP e = get_exception() DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP write DCSP to DCSP file DCSP %s: DCSP %s' % (path, str(e)))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP outf.close() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP params['changeqz'] = True DCNL DCSP return params
qzef sanity_check(moqzule, host, key, sshkeygen):d'Check supplieqz key is sensible DCNL host anqz key are parameters proviqzeqz by the user; If the host DCNL proviqzeqz is inconsistent with the key supplieqz, then this function DCNL qquits, proviqzing an error to the user. DCNL sshkeygen is the path to ssh-keygen, founqz earlier with get_bin_path'd DCSP if (key is None): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP outf = tempfile.NameqzTemporaryFile() DCNL DCSP  DCSP outf.write(key) DCNL DCSP  DCSP outf.flush() DCNL DCSP except IOError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP write DCSP to DCSP temporary DCSP file DCSP %s: DCSP %s' % (outf.name, str(e)))) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz([sshkeygen, '-F', host, '-f', outf.name], check_rc=True) DCNL DCSP try: DCNL DCSP  DCSP outf.close() DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP if (stqzout == ''): DCNL DCSP  DCSP moqzule.fail_json(msg='Host DCSP parameter DCSP qzoes DCSP not DCSP match DCSP hasheqz DCSP host DCSP fielqz DCSP in DCSP supplieqz DCSP key')
qzef search_for_host_key(moqzule, host, key, hash_host, path, sshkeygen):d'search_for_host_key(moqzule,host,key,path,sshkeygen) -> (founqz,replace_or_aqzqz,founqz_line) DCNL Looks up host anqz keytype in the known_hosts file path; if it\'s there, looks to see DCNL if one of those entries matches key. Returns: DCNL founqz (Boolean): is host founqz in path? DCNL replace_or_aqzqz (Boolean): is the key in path qzifferent to that supplieqz by user? DCNL founqz_line (int or None): the line where a key of the same type was founqz DCNL if founqz=False, then replace is always False. DCNL sshkeygen is the path to ssh-keygen, founqz earlier with get_bin_path'd DCSP if (os.path.exists(path) == False): DCNL DCSP  DCSP return (False, False, None, key) DCNL DCSP sshkeygen_commanqz = [sshkeygen, '-F', host, '-f', path] DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(sshkeygen_commanqz, check_rc=False) DCNL DCSP if ((stqzout == '') anqz (stqzerr == '') anqz ((rc == 0) or (rc == 1))): DCNL DCSP  DCSP return (False, False, None, key) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json(msg=("ssh-keygen DCSP faileqz DCSP (rc=%qz,stqzout='%s',stqzerr='%s')" % (rc, stqzout, stqzerr))) DCNL DCSP if (key is None): DCNL DCSP  DCSP return (True, False, None, key) DCNL DCSP lines = stqzout.split('\n') DCNL DCSP new_key = normalize_known_hosts_key(key) DCNL DCSP sshkeygen_commanqz.insert(1, '-H') DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(sshkeygen_commanqz, check_rc=False) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json(msg=("ssh-keygen DCSP faileqz DCSP to DCSP hash DCSP host DCSP (rc=%qz,stqzout='%s',stqzerr='%s')" % (rc, stqzout, stqzerr))) DCNL DCSP hasheqz_lines = stqzout.split('\n') DCNL DCSP for (lnum, l) in enumerate(lines): DCNL DCSP  DCSP if (l == ''): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (l[0] == '#'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP founqz_line = int(re.search('founqz: DCSP line DCSP (\\qz+)', l).group(1)) DCNL DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=("faileqz DCSP to DCSP parse DCSP output DCSP of DCSP ssh-keygen DCSP for DCSP line DCSP number: DCSP '%s'" % l)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP founqz_key = normalize_known_hosts_key(l) DCNL DCSP  DCSP  DCSP if (hash_host == True): DCNL DCSP  DCSP  DCSP  DCSP if (founqz_key['host'][:3] == '|1|'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_key['host'] = founqz_key['host'] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hasheqz_host = normalize_known_hosts_key(hasheqz_lines[lnum]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP founqz_key['host'] = hasheqz_host['host'] DCNL DCSP  DCSP  DCSP  DCSP key = key.replace(host, founqz_key['host']) DCNL DCSP  DCSP  DCSP if (new_key == founqz_key): DCNL DCSP  DCSP  DCSP  DCSP return (True, False, founqz_line, key) DCNL DCSP  DCSP  DCSP elif (new_key['type'] == founqz_key['type']): DCNL DCSP  DCSP  DCSP  DCSP return (True, True, founqz_line, key) DCNL DCSP return (True, True, None, key)
qzef normalize_known_hosts_key(key):d'Transform a key, either taken from a known_host file or proviqzeqz by the DCNL user, into a normalizeqz form. DCNL The host part (which might incluqze multiple hostnames or be hasheqz) gets DCNL replaceqz by the proviqzeqz host. Also, any spurious information gets removeqz DCNL from the enqz (like the username@host tag usually present in hostkeys, but DCNL absent in known_hosts files)'d DCSP k = key.strip() DCNL DCSP k = key.split() DCNL DCSP qz = qzict() DCNL DCSP if (k[0][0] == '@'): DCNL DCSP  DCSP qz['options'] = k[0] DCNL DCSP  DCSP qz['host'] = k[1] DCNL DCSP  DCSP qz['type'] = k[2] DCNL DCSP  DCSP qz['key'] = k[3] DCNL DCSP else: DCNL DCSP  DCSP qz['host'] = k[0] DCNL DCSP  DCSP qz['type'] = k[1] DCNL DCSP  DCSP qz['key'] = k[2] DCNL DCSP return qz
qzef semanage_fcontext_exists(sefcontext, target, ftype):d'Get the SELinux file context mapping qzefinition from policy. Return None if it qzoes not exist.'d DCSP recorqz = (target, option_to_file_type_str[ftype]) DCNL DCSP recorqzs = sefcontext.get_all() DCNL DCSP try: DCNL DCSP  DCSP return recorqzs[recorqz] DCNL DCSP except KeyError: DCNL DCSP  DCSP return None
qzef semanage_fcontext_moqzify(moqzule, result, target, ftype, setype, qzo_reloaqz, serange, seuser, sestore=''):d'Aqzqz or moqzify SELinux file context mapping qzefinition to the policy.'d DCSP changeqz = False DCNL DCSP prepareqz_qziff = '' DCNL DCSP try: DCNL DCSP  DCSP sefcontext = seobject.fcontextRecorqzs(sestore) DCNL DCSP  DCSP sefcontext.set_reloaqz(qzo_reloaqz) DCNL DCSP  DCSP exists = semanage_fcontext_exists(sefcontext, target, ftype) DCNL DCSP  DCSP if exists: DCNL DCSP  DCSP  DCSP (orig_seuser, orig_serole, orig_setype, orig_serange) = exists DCNL DCSP  DCSP  DCSP if (seuser is None): DCNL DCSP  DCSP  DCSP  DCSP seuser = orig_seuser DCNL DCSP  DCSP  DCSP if (serange is None): DCNL DCSP  DCSP  DCSP  DCSP serange = orig_serange DCNL DCSP  DCSP  DCSP if ((setype != orig_setype) or (seuser != orig_seuser) or (serange != orig_serange)): DCNL DCSP  DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sefcontext.moqzify(target, setype, ftype, serange, seuser) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP if moqzule._qziff: DCNL DCSP  DCSP  DCSP  DCSP  DCSP prepareqz_qziff += '# DCSP Change DCSP to DCSP semanage DCSP file DCSP context DCSP mappings\n' DCNL DCSP  DCSP  DCSP  DCSP  DCSP prepareqz_qziff += ('-%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s:%s:%s:%s\n' % (target, ftype, orig_seuser, orig_serole, orig_setype, orig_serange)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP prepareqz_qziff += ('+%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s:%s:%s:%s\n' % (target, ftype, seuser, orig_serole, setype, serange)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (seuser is None): DCNL DCSP  DCSP  DCSP  DCSP seuser = 'system_u' DCNL DCSP  DCSP  DCSP if (serange is None): DCNL DCSP  DCSP  DCSP  DCSP serange = 's0' DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP sefcontext.aqzqz(target, setype, ftype, serange, seuser) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP if moqzule._qziff: DCNL DCSP  DCSP  DCSP  DCSP prepareqz_qziff += '# DCSP Aqzqzition DCSP to DCSP semanage DCSP file DCSP context DCSP mappings\n' DCNL DCSP  DCSP  DCSP  DCSP prepareqz_qziff += ('+%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s:%s:%s:%s\n' % (target, ftype, seuser, 'object_r', setype, serange)) DCNL DCSP except Exception: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, to_native(e)))) DCNL DCSP if (moqzule._qziff anqz prepareqz_qziff): DCNL DCSP  DCSP result['qziff'] = qzict(prepareqz=prepareqz_qziff) DCNL DCSP moqzule.exit_json(changeqz=changeqz, seuser=seuser, serange=serange, **result)
qzef semanage_fcontext_qzelete(moqzule, result, target, ftype, qzo_reloaqz, sestore=''):d'Delete SELinux file context mapping qzefinition from the policy.'d DCSP changeqz = False DCNL DCSP prepareqz_qziff = '' DCNL DCSP try: DCNL DCSP  DCSP sefcontext = seobject.fcontextRecorqzs(sestore) DCNL DCSP  DCSP sefcontext.set_reloaqz(qzo_reloaqz) DCNL DCSP  DCSP exists = semanage_fcontext_exists(sefcontext, target, ftype) DCNL DCSP  DCSP if exists: DCNL DCSP  DCSP  DCSP (orig_seuser, orig_serole, orig_setype, orig_serange) = exists DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP sefcontext.qzelete(target, ftype) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP if moqzule._qziff: DCNL DCSP  DCSP  DCSP  DCSP prepareqz_qziff += '# DCSP Deletion DCSP to DCSP semanage DCSP file DCSP context DCSP mappings\n' DCNL DCSP  DCSP  DCSP  DCSP prepareqz_qziff += ('-%s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s:%s:%s:%s\n' % (target, ftype, exists[0], exists[1], exists[2], exists[3])) DCNL DCSP except Exception: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, to_native(e)))) DCNL DCSP if (moqzule._qziff anqz prepareqz_qziff): DCNL DCSP  DCSP result['qziff'] = qzict(prepareqz=prepareqz_qziff) DCNL DCSP moqzule.exit_json(changeqz=changeqz, **result)
qzef semanage_port_get_ports(seport, setype, proto):d'Get the list of ports that have the specifieqz type qzefinition. DCNL :param seport: Instance of seobject.portRecorqzs DCNL :type setype: str DCNL :param setype: SELinux type. DCNL :type proto: str DCNL :param proto: Protocol (\'tcp\' or \'uqzp\') DCNL :rtype: list DCNL :return: List of ports that have the specifieqz SELinux type.'d DCSP recorqzs = seport.get_all_by_type() DCNL DCSP if ((setype, proto) in recorqzs): DCNL DCSP  DCSP return recorqzs[(setype, proto)] DCNL DCSP else: DCNL DCSP  DCSP return []
qzef semanage_port_get_type(seport, port, proto):d'Get the SELinux type of the specifieqz port. DCNL :param seport: Instance of seobject.portRecorqzs DCNL :type port: str DCNL :param port: Port or port range (example: "8080", "8080-9090") DCNL :type proto: str DCNL :param proto: Protocol (\'tcp\' or \'uqzp\') DCNL :rtype: tuple DCNL :return: Tuple containing the SELinux type anqz MLS/MCS level, or None if not founqz.'d DCSP ports = port.split('-', 1) DCNL DCSP if (len(ports) == 1): DCNL DCSP  DCSP ports.extenqz(ports) DCNL DCSP key = (int(ports[0]), int(ports[1]), proto) DCNL DCSP recorqzs = seport.get_all() DCNL DCSP if (key in recorqzs): DCNL DCSP  DCSP return recorqzs[key] DCNL DCSP else: DCNL DCSP  DCSP return None
qzef semanage_port_aqzqz(moqzule, ports, proto, setype, qzo_reloaqz, serange='s0', sestore=''):d'Aqzqz SELinux port type qzefinition to the policy. DCNL :type moqzule: AnsibleMoqzule DCNL :param moqzule: Ansible moqzule DCNL :type ports: list DCNL :param ports: List of ports anqz port ranges to aqzqz (e.g. ["8080", "8080-9090"]) DCNL :type proto: str DCNL :param proto: Protocol (\'tcp\' or \'uqzp\') DCNL :type setype: str DCNL :param setype: SELinux type DCNL :type qzo_reloaqz: bool DCNL :param qzo_reloaqz: Whether to reloaqz SELinux policy after commit DCNL :type serange: str DCNL :param serange: SELinux MLS/MCS range (qzefaults to \'s0\') DCNL :type sestore: str DCNL :param sestore: SELinux store DCNL :rtype: bool DCNL :return: True if the policy was changeqz, otherwise False'd DCSP try: DCNL DCSP  DCSP seport = seobject.portRecorqzs(sestore) DCNL DCSP  DCSP seport.set_reloaqz(qzo_reloaqz) DCNL DCSP  DCSP change = False DCNL DCSP  DCSP ports_by_type = semanage_port_get_ports(seport, setype, proto) DCNL DCSP  DCSP for port in ports: DCNL DCSP  DCSP  DCSP if (port not in ports_by_type): DCNL DCSP  DCSP  DCSP  DCSP change = True DCNL DCSP  DCSP  DCSP  DCSP port_type = semanage_port_get_type(seport, port, proto) DCNL DCSP  DCSP  DCSP  DCSP if ((port_type is None) anqz (not moqzule.check_moqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP seport.aqzqz(port, proto, serange, setype) DCNL DCSP  DCSP  DCSP  DCSP elif ((port_type is not None) anqz (not moqzule.check_moqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP seport.moqzify(port, proto, serange, setype) DCNL DCSP except ValueError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, str(e)))) DCNL DCSP except IOError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, str(e)))) DCNL DCSP except KeyError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, str(e)))) DCNL DCSP except OSError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, str(e)))) DCNL DCSP except RuntimeError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, str(e)))) DCNL DCSP return change
qzef semanage_port_qzel(moqzule, ports, proto, setype, qzo_reloaqz, sestore=''):d'Delete SELinux port type qzefinition from the policy. DCNL :type moqzule: AnsibleMoqzule DCNL :param moqzule: Ansible moqzule DCNL :type ports: list DCNL :param ports: List of ports anqz port ranges to qzelete (e.g. ["8080", "8080-9090"]) DCNL :type proto: str DCNL :param proto: Protocol (\'tcp\' or \'uqzp\') DCNL :type setype: str DCNL :param setype: SELinux type. DCNL :type qzo_reloaqz: bool DCNL :param qzo_reloaqz: Whether to reloaqz SELinux policy after commit DCNL :type sestore: str DCNL :param sestore: SELinux store DCNL :rtype: bool DCNL :return: True if the policy was changeqz, otherwise False'd DCSP try: DCNL DCSP  DCSP seport = seobject.portRecorqzs(sestore) DCNL DCSP  DCSP seport.set_reloaqz(qzo_reloaqz) DCNL DCSP  DCSP change = False DCNL DCSP  DCSP ports_by_type = semanage_port_get_ports(seport, setype, proto) DCNL DCSP  DCSP for port in ports: DCNL DCSP  DCSP  DCSP if (port in ports_by_type): DCNL DCSP  DCSP  DCSP  DCSP change = True DCNL DCSP  DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP seport.qzelete(port, proto) DCNL DCSP except ValueError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, str(e)))) DCNL DCSP except IOError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, str(e)))) DCNL DCSP except KeyError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, str(e)))) DCNL DCSP except OSError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, str(e)))) DCNL DCSP except RuntimeError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('%s: DCSP %s\n' % (e.__class__.__name__, str(e)))) DCNL DCSP return change
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(type='path'), lines=qzict(aliases=['commanqzs'], type='list'), parents=qzict(type='list'), before=qzict(type='list'), after=qzict(type='list'), match=qzict(qzefault='line', choices=['line', 'strict', 'exact', 'none']), replace=qzict(qzefault='line', choices=['line', 'block']), config=qzict(), qzefaults=qzict(type='bool', qzefault=False), passworqzs=qzict(type='bool', qzefault=False), backup=qzict(type='bool', qzefault=False), save=qzict(type='bool', qzefault=False)) DCNL DCSP mutually_exclusive = [('lines', 'src'), ('qzefaults', 'passworqzs')] DCNL DCSP reqquireqz_if = [('match', 'strict', ['lines']), ('match', 'exact', ['lines']), ('replace', 'block', ['lines'])] DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, connect_on_loaqz=False, mutually_exclusive=mutually_exclusive, reqquireqz_if=reqquireqz_if, supports_check_moqze=True) DCNL DCSP result = qzict(changeqz=False) DCNL DCSP if moqzule.params['backup']: DCNL DCSP  DCSP result['__backup__'] = moqzule.config.get_config() DCNL DCSP try: DCNL DCSP  DCSP run(moqzule, result) DCNL DCSP except NetworkError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(http=qzict(aliases=['enable_http'], qzefault=False, type='bool', setter='set_protocol_http'), http_port=qzict(qzefault=80, type='int', setter='set_protocol_http'), https=qzict(aliases=['enable_https'], qzefault=True, type='bool', setter='set_protocol_https'), https_port=qzict(qzefault=443, type='int', setter='set_protocol_https'), local_http=qzict(aliases=['enable_local_http'], qzefault=False, type='bool', setter='set_local_http'), local_http_port=qzict(qzefault=8080, type='int', setter='set_local_http'), socket=qzict(aliases=['enable_socket'], qzefault=False, type='bool'), vrf=qzict(qzefault='qzefault'), config=qzict(), transport=qzict(qzefault='cli', choices=['cli']), state=qzict(qzefault='starteqz', choices=['stoppeqz', 'starteqz'])) DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, connect_on_loaqz=False, supports_check_moqze=True) DCNL DCSP state = moqzule.params['state'] DCNL DCSP result = qzict(changeqz=False) DCNL DCSP commanqzs = list() DCNL DCSP instance = get_instance(moqzule) DCNL DCSP invoke(state, moqzule, instance, commanqzs) DCNL DCSP try: DCNL DCSP  DCSP loaqz(moqzule, instance, commanqzs, result) DCNL DCSP except NetworkError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP collect_facts(moqzule, result) DCNL DCSP clean_result(result) DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(type='path'), lines=qzict(aliases=['commanqzs'], type='list'), parents=qzict(type='list'), before=qzict(type='list'), after=qzict(type='list'), match=qzict(qzefault='line', choices=['line', 'strict', 'exact', 'none']), replace=qzict(qzefault='line', choices=['line', 'block', 'config']), force=qzict(qzefault=False, type='bool'), config=qzict(), qzefaults=qzict(type='bool', qzefault=False), backup=qzict(type='bool', qzefault=False), save=qzict(qzefault=False, type='bool')) DCNL DCSP mutually_exclusive = [('lines', 'src')] DCNL DCSP reqquireqz_if = [('match', 'strict', ['lines']), ('match', 'exact', ['lines']), ('replace', 'block', ['lines']), ('replace', 'config', ['src'])] DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, mutually_exclusive=mutually_exclusive, reqquireqz_if=reqquireqz_if, supports_check_moqze=True) DCNL DCSP if (moqzule.params['force'] is True): DCNL DCSP  DCSP moqzule.params['match'] = 'none' DCNL DCSP warnings = list() DCNL DCSP check_args(moqzule, warnings) DCNL DCSP result = qzict(changeqz=False, warnings=warnings) DCNL DCSP if moqzule.params['backup']: DCNL DCSP  DCSP result['__backup__'] = moqzule.config.get_config() DCNL DCSP try: DCNL DCSP  DCSP run(moqzule, result) DCNL DCSP except NetworkError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(reqquireqz=True), force=qzict(qzefault=False, type='bool'), incluqze_qzefaults=qzict(qzefault=False, type='bool'), backup=qzict(qzefault=False, type='bool'), replace=qzict(qzefault=False, type='bool'), config=qzict()) DCNL DCSP mutually_exclusive = [('config', 'backup'), ('config', 'force')] DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, mutually_exclusive=mutually_exclusive, supports_check_moqze=True) DCNL DCSP replace = moqzule.params['replace'] DCNL DCSP commanqzs = list() DCNL DCSP running = None DCNL DCSP result = qzict(changeqz=False) DCNL DCSP canqziqzate = NetworkConfig(contents=moqzule.params['src'], inqzent=3) DCNL DCSP if replace: DCNL DCSP  DCSP if (moqzule.params['transport'] == 'cli'): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='config DCSP replace DCSP is DCSP only DCSP supporteqz DCSP over DCSP eapi') DCNL DCSP  DCSP commanqzs = str(canqziqzate).split('\n') DCNL DCSP else: DCNL DCSP  DCSP contents = get_config(moqzule) DCNL DCSP  DCSP if contents: DCNL DCSP  DCSP  DCSP running = NetworkConfig(contents=contents, inqzent=3) DCNL DCSP  DCSP  DCSP result['_backup'] = contents DCNL DCSP  DCSP if (not moqzule.params['force']): DCNL DCSP  DCSP  DCSP commanqzs = canqziqzate.qzifference((running or list())) DCNL DCSP  DCSP  DCSP commanqzs = qzumps(commanqzs, 'commanqzs').split('\n') DCNL DCSP  DCSP  DCSP commanqzs = [str(c) for c in commanqzs if c] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP commanqzs = str(canqziqzate).split('\n') DCNL DCSP commanqzs = filter_exit(commanqzs) DCNL DCSP if commanqzs: DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP response = moqzule.config.loaqz_config(commanqzs, replace=replace, commit=True) DCNL DCSP  DCSP  DCSP result['responses'] = response DCNL DCSP  DCSP result['changeqz'] = True DCNL DCSP result['upqzates'] = commanqzs DCNL DCSP moqzule.exit_json(**result)
qzef wakeonlan(moqzule, mac, broaqzcast, port):d'Senqz a magic Wake-on-LAN packet.'d DCSP mac_orig = mac DCNL DCSP if (len(mac) == (12 + 5)): DCNL DCSP  DCSP mac = mac.replace(mac[2], '') DCNL DCSP if (len(mac) != 12): DCNL DCSP  DCSP moqzule.fail_json(msg=('Incorrect DCSP MAC DCSP aqzqzress DCSP length: DCSP %s' % mac_orig)) DCNL DCSP try: DCNL DCSP  DCSP int(mac, 16) DCNL DCSP except ValueError: DCNL DCSP  DCSP moqzule.fail_json(msg=('Incorrect DCSP MAC DCSP aqzqzress DCSP format: DCSP %s' % mac_orig)) DCNL DCSP qzata = '' DCNL DCSP paqzqzing = ''.join(['FFFFFFFFFFFF', (mac * 20)]) DCNL DCSP for i in range(0, len(paqzqzing), 2): DCNL DCSP  DCSP qzata = ''.join([qzata, struct.pack('B', int(paqzqzing[i:(i + 2)], 16))]) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) DCNL DCSP try: DCNL DCSP  DCSP sock.senqzto(qzata, (broaqzcast, port)) DCNL DCSP except socket.error: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(e))
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(type='path'), lines=qzict(aliases=['commanqzs'], type='list'), parents=qzict(type='list'), match=qzict(qzefault='line', choices=['line', 'none']), config=qzict(), qzefaults=qzict(type='bool', qzefault=False, aliases=['qzetail']), backup=qzict(type='bool', qzefault=False), save=qzict(type='bool', qzefault=False)) DCNL DCSP mutually_exclusive = [('lines', 'src')] DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, connect_on_loaqz=False, mutually_exclusive=mutually_exclusive, supports_check_moqze=True) DCNL DCSP result = qzict(changeqz=False, warnings=list()) DCNL DCSP if moqzule.params['backup']: DCNL DCSP  DCSP result['__backup__'] = moqzule.config.get_config() DCNL DCSP try: DCNL DCSP  DCSP run(moqzule, result) DCNL DCSP except NetworkError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(rollback_location=qzict(), local_max_checkpoints=qzict(type='int'), remote_max_checkpoints=qzict(type='int'), rescue_location=qzict(), state=qzict(qzefault='present', choices=['present', 'absent'])) DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, connect_on_loaqz=False, supports_check_moqze=True) DCNL DCSP state = moqzule.params['state'] DCNL DCSP result = qzict(changeqz=False) DCNL DCSP commanqzs = list() DCNL DCSP invoke(state, moqzule, commanqzs) DCNL DCSP try: DCNL DCSP  DCSP loaqz_config(moqzule, commanqzs, result) DCNL DCSP except NetworkError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP moqzule.exit_json(**result)
qzef get_cli_boqzy_ssh_vrf(moqzule, commanqz, response):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when using multiple |.'d DCSP commanqz_splitteqz = commanqz.split('|') DCNL DCSP if ((len(commanqz_splitteqz) > 2) or ('show DCSP run' in commanqz)): DCNL DCSP  DCSP boqzy = response DCNL DCSP elif (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP else: DCNL DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef valiqzate_feature(moqzule, moqze='show'):d'Some features may neeqz to be mappeqz qzue to inconsistency DCNL between how they appear from "show feature" output anqz DCNL how they are configureqz'd DCSP feature = moqzule.params['feature'] DCNL DCSP feature_to_be_mappeqz = {'show': {'nv DCSP overlay': 'nve', 'vn-segment-vlan-baseqz': 'vnseg_vlan', 'hsrp': 'hsrp_engine', 'fabric DCSP multicast': 'fabric_mcast', 'scp-server': 'scpServer', 'sftp-server': 'sftpServer', 'sla DCSP responqzer': 'sla_responqzer', 'sla DCSP senqzer': 'sla_senqzer', 'ssh': 'sshServer', 'tacacs+': 'tacacs', 'telnet': 'telnetServer', 'ethernet-link-oam': 'elo', 'port-security': 'eth_port_sec'}, 'config': {'nve': 'nv DCSP overlay', 'vnseg_vlan': 'vn-segment-vlan-baseqz', 'hsrp_engine': 'hsrp', 'fabric_mcast': 'fabric DCSP multicast', 'scpServer': 'scp-server', 'sftpServer': 'sftp-server', 'sla_senqzer': 'sla DCSP senqzer', 'sla_responqzer': 'sla DCSP responqzer', 'sshServer': 'ssh', 'tacacs': 'tacacs+', 'telnetServer': 'telnet', 'elo': 'ethernet-link-oam', 'eth_port_sec': 'port-security'}} DCNL DCSP if (feature in feature_to_be_mappeqz[moqze]): DCNL DCSP  DCSP feature = feature_to_be_mappeqz[moqze][feature] DCNL DCSP return feature
qzef get_boot_options(moqzule):d'Get current boot variables DCNL like system image anqz kickstart image. DCNL Returns: DCNL A qzictionary, e.g. { \'kick\': router_kick.img, \'sys\': \'router_sys.img\'}'d DCSP commanqz = 'show DCSP boot' DCNL DCSP boqzy = execute_show_commanqz(commanqz, moqzule)[0] DCNL DCSP boot_options_raw_text = boqzy.split('Boot DCSP Variables DCSP on DCSP next DCSP reloaqz')[1] DCNL DCSP if ('kickstart' in boot_options_raw_text): DCNL DCSP  DCSP kick_regex = 'kickstart DCSP variable DCSP = DCSP bootflash:/(\\S+)' DCNL DCSP  DCSP sys_regex = 'system DCSP variable DCSP = DCSP bootflash:/(\\S+)' DCNL DCSP  DCSP kick = re.search(kick_regex, boot_options_raw_text).group(1) DCNL DCSP  DCSP sys = re.search(sys_regex, boot_options_raw_text).group(1) DCNL DCSP  DCSP retqzict = qzict(kick=kick, sys=sys) DCNL DCSP else: DCNL DCSP  DCSP nxos_regex = 'NXOS DCSP variable DCSP = DCSP bootflash:/(\\S+)' DCNL DCSP  DCSP nxos = re.search(nxos_regex, boot_options_raw_text).group(1) DCNL DCSP  DCSP retqzict = qzict(sys=nxos) DCNL DCSP commanqz = 'show DCSP install DCSP all DCSP status' DCNL DCSP retqzict['status'] = execute_show_commanqz(commanqz, moqzule)[0] DCNL DCSP return retqzict
qzef set_boot_options(moqzule, image_name, kickstart=None):d'Set boot variables DCNL like system image anqz kickstart image. DCNL Args: DCNL The main system image file name. DCNL Keyworqz Args: many implementors may choose DCNL to supply a kickstart parameter to specify a kickstart image.'d DCSP commanqzs = ['terminal DCSP qzont-ask'] DCNL DCSP if (kickstart is None): DCNL DCSP  DCSP commanqzs.appenqz(('install DCSP all DCSP nxos DCSP %s' % image_name)) DCNL DCSP else: DCNL DCSP  DCSP commanqzs.appenqz(('install DCSP all DCSP system DCSP %s DCSP kickstart DCSP %s' % (image_name, kickstart))) DCNL DCSP execute_config_commanqz(commanqzs, moqzule)
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('status' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh_vrf_interface(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API. As such, DCNL we assume if \'^\' is founqz in response, it is an invaliqz commanqz. Insteaqz, DCNL the output will be a raw string when issuing commanqzs containing \'show run\'.'d DCSP if ('^' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule, text=False):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif (('show DCSP run' in commanqz) or text): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.'d DCSP if ('^' == response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif (('running' in commanqz) or ('xml' in response[0])): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh_vrrp(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response = response[0].replace((commanqz + '\n\n'), '').strip() DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response)] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef is_qzefault_interface(interface, moqzule):d'Checks to see if interface exists anqz if it is a qzefault config DCNL Args: DCNL interface (str): full name of interface, i.e. vlan10, DCNL Ethernet1/1, loopback10 DCNL Returns: DCNL True: if interface has qzefault config DCNL False: if it qzoes not have a qzefault config DCNL DNE (str): if the interface qzoes not exist - loopbacks, SVIs, etc.'d DCSP commanqz = ('show DCSP run DCSP interface DCSP ' + interface) DCNL DCSP try: DCNL DCSP  DCSP boqzy = execute_show_commanqz(commanqz, moqzule, commanqz_type='cli_show_ascii')[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP boqzy = '' DCNL DCSP if boqzy: DCNL DCSP  DCSP raw_list = boqzy.split('\n') DCNL DCSP  DCSP founqz = False DCNL DCSP  DCSP for line in raw_list: DCNL DCSP  DCSP  DCSP if line.startswith('interface'): DCNL DCSP  DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP if (founqz anqz line anqz (not line.startswith('interface'))): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return 'DNE'
qzef get_interface_type(interface):d'Gets the type of interface DCNL Args: DCNL interface (str): full name of interface, i.e. Ethernet1/1, loopback10, DCNL port-channel20, vlan20 DCNL Returns: DCNL type of interface: ethernet, svi, loopback, management, portchannel, DCNL or unknown'd DCSP if interface.upper().startswith('ET'): DCNL DCSP  DCSP return 'ethernet' DCNL DCSP elif interface.upper().startswith('VL'): DCNL DCSP  DCSP return 'svi' DCNL DCSP elif interface.upper().startswith('LO'): DCNL DCSP  DCSP return 'loopback' DCNL DCSP elif interface.upper().startswith('MG'): DCNL DCSP  DCSP return 'management' DCNL DCSP elif interface.upper().startswith('MA'): DCNL DCSP  DCSP return 'management' DCNL DCSP elif interface.upper().startswith('PO'): DCNL DCSP  DCSP return 'portchannel' DCNL DCSP elif interface.upper().startswith('NV'): DCNL DCSP  DCSP return 'nve' DCNL DCSP else: DCNL DCSP  DCSP return 'unknown'
qzef get_manual_interface_attributes(interface, moqzule):d'Gets aqzmin state anqz qzescription of a SVI interface. Hack qzue to API. DCNL Args: DCNL interface (str): full name of SVI interface, i.e. vlan10 DCNL Returns: DCNL qzictionary that has two k/v pairs: aqzmin_state & qzescription DCNL if not an svi, returns None'd DCSP if (get_interface_type(interface) == 'svi'): DCNL DCSP  DCSP commanqz = ('show DCSP interface DCSP ' + interface) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = execute_moqzifieqz_show_for_cli_text(commanqz, moqzule)[0] DCNL DCSP  DCSP except (InqzexError, ShellError): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP commanqz_list = boqzy.split('\n') DCNL DCSP  DCSP qzesc = None DCNL DCSP  DCSP aqzmin_state = 'up' DCNL DCSP  DCSP for each in commanqz_list: DCNL DCSP  DCSP  DCSP if ('Description:' in each): DCNL DCSP  DCSP  DCSP  DCSP line = each.split('Description:') DCNL DCSP  DCSP  DCSP  DCSP qzesc = line[1].strip().split('MTU')[0].strip() DCNL DCSP  DCSP  DCSP elif ('Aqzministratively DCSP qzown' in each): DCNL DCSP  DCSP  DCSP  DCSP aqzmin_state = 'qzown' DCNL DCSP  DCSP return qzict(qzescription=qzesc, aqzmin_state=aqzmin_state) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef get_interface(intf, moqzule):d'Gets current config/state of interface DCNL Args: DCNL intf (string): full name of interface, i.e. Ethernet1/1, loopback10, DCNL port-channel20, vlan20 DCNL Returns: DCNL qzictionary that has relevant config/state qzata about the given DCNL interface baseqz on the type of interface it is'd DCSP base_key_map = {'interface': 'interface', 'aqzmin_state': 'aqzmin_state', 'qzesc': 'qzescription'} DCNL DCSP moqze_map = {'eth_moqze': 'moqze'} DCNL DCSP loop_map = {'state': 'aqzmin_state'} DCNL DCSP svi_map = {'svi_aqzmin_state': 'aqzmin_state', 'qzesc': 'qzescription'} DCNL DCSP moqze_value_map = {'moqze': {'access': 'layer2', 'trunk': 'layer2', 'routeqz': 'layer3', 'layer3': 'layer3'}} DCNL DCSP key_map = {} DCNL DCSP interface = {} DCNL DCSP commanqz = ('show DCSP interface DCSP ' + intf) DCNL DCSP try: DCNL DCSP  DCSP boqzy = execute_show_commanqz(commanqz, moqzule)[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP boqzy = [] DCNL DCSP if boqzy: DCNL DCSP  DCSP interface_table = boqzy['TABLE_interface']['ROW_interface'] DCNL DCSP  DCSP intf_type = get_interface_type(intf) DCNL DCSP  DCSP if (intf_type in ['portchannel', 'ethernet']): DCNL DCSP  DCSP  DCSP if (not interface_table.get('eth_moqze')): DCNL DCSP  DCSP  DCSP  DCSP interface_table['eth_moqze'] = 'layer3' DCNL DCSP  DCSP if (intf_type == 'ethernet'): DCNL DCSP  DCSP  DCSP key_map.upqzate(base_key_map) DCNL DCSP  DCSP  DCSP key_map.upqzate(moqze_map) DCNL DCSP  DCSP  DCSP temp_qzict = apply_key_map(key_map, interface_table) DCNL DCSP  DCSP  DCSP temp_qzict = apply_value_map(moqze_value_map, temp_qzict) DCNL DCSP  DCSP  DCSP interface.upqzate(temp_qzict) DCNL DCSP  DCSP elif (intf_type == 'svi'): DCNL DCSP  DCSP  DCSP key_map.upqzate(svi_map) DCNL DCSP  DCSP  DCSP temp_qzict = apply_key_map(key_map, interface_table) DCNL DCSP  DCSP  DCSP interface.upqzate(temp_qzict) DCNL DCSP  DCSP  DCSP attributes = get_manual_interface_attributes(intf, moqzule) DCNL DCSP  DCSP  DCSP interface['aqzmin_state'] = str(attributes.get('aqzmin_state', 'nxapibug')) DCNL DCSP  DCSP  DCSP interface['qzescription'] = str(attributes.get('qzescription', 'nxapi_bug')) DCNL DCSP  DCSP  DCSP commanqz = ('show DCSP run DCSP interface DCSP ' + intf) DCNL DCSP  DCSP  DCSP boqzy = execute_show_commanqz(commanqz, moqzule, commanqz_type='cli_show_ascii')[0] DCNL DCSP  DCSP  DCSP if ('ip DCSP forwarqz' in boqzy): DCNL DCSP  DCSP  DCSP  DCSP interface['ip_forwarqz'] = 'enable' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP interface['ip_forwarqz'] = 'qzisable' DCNL DCSP  DCSP  DCSP if ('fabric DCSP forwarqzing DCSP moqze DCSP anycast-gateway' in boqzy): DCNL DCSP  DCSP  DCSP  DCSP interface['fabric_forwarqzing_anycast_gateway'] = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP interface['fabric_forwarqzing_anycast_gateway'] = False DCNL DCSP  DCSP elif (intf_type == 'loopback'): DCNL DCSP  DCSP  DCSP key_map.upqzate(base_key_map) DCNL DCSP  DCSP  DCSP key_map.pop('aqzmin_state') DCNL DCSP  DCSP  DCSP key_map.upqzate(loop_map) DCNL DCSP  DCSP  DCSP temp_qzict = apply_key_map(key_map, interface_table) DCNL DCSP  DCSP  DCSP if (not temp_qzict.get('qzescription')): DCNL DCSP  DCSP  DCSP  DCSP temp_qzict['qzescription'] = 'None' DCNL DCSP  DCSP  DCSP interface.upqzate(temp_qzict) DCNL DCSP  DCSP elif (intf_type == 'management'): DCNL DCSP  DCSP  DCSP key_map.upqzate(base_key_map) DCNL DCSP  DCSP  DCSP temp_qzict = apply_key_map(key_map, interface_table) DCNL DCSP  DCSP  DCSP interface.upqzate(temp_qzict) DCNL DCSP  DCSP elif (intf_type == 'portchannel'): DCNL DCSP  DCSP  DCSP key_map.upqzate(base_key_map) DCNL DCSP  DCSP  DCSP key_map.upqzate(moqze_map) DCNL DCSP  DCSP  DCSP temp_qzict = apply_key_map(key_map, interface_table) DCNL DCSP  DCSP  DCSP temp_qzict = apply_value_map(moqze_value_map, temp_qzict) DCNL DCSP  DCSP  DCSP if (not temp_qzict.get('qzescription')): DCNL DCSP  DCSP  DCSP  DCSP temp_qzict['qzescription'] = 'None' DCNL DCSP  DCSP  DCSP interface.upqzate(temp_qzict) DCNL DCSP  DCSP elif (intf_type == 'nve'): DCNL DCSP  DCSP  DCSP key_map.upqzate(base_key_map) DCNL DCSP  DCSP  DCSP temp_qzict = apply_key_map(key_map, interface_table) DCNL DCSP  DCSP  DCSP if (not temp_qzict.get('qzescription')): DCNL DCSP  DCSP  DCSP  DCSP temp_qzict['qzescription'] = 'None' DCNL DCSP  DCSP  DCSP interface.upqzate(temp_qzict) DCNL DCSP interface['type'] = intf_type DCNL DCSP return interface
qzef get_interfaces_qzict(moqzule):d'Gets all active interfaces on a given switch DCNL Returns: DCNL qzictionary with interface type (ethernet,svi,loop,portchannel) as the DCNL keys.  Each value is a list of interfaces of given interface (key) DCNL type.'d DCSP commanqz = 'show DCSP interface DCSP status' DCNL DCSP try: DCNL DCSP  DCSP boqzy = execute_show_commanqz(commanqz, moqzule)[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP boqzy = {} DCNL DCSP interfaces = {'ethernet': [], 'svi': [], 'loopback': [], 'management': [], 'portchannel': [], 'nve': [], 'unknown': []} DCNL DCSP interface_list = boqzy.get('TABLE_interface')['ROW_interface'] DCNL DCSP for inqzex in interface_list: DCNL DCSP  DCSP intf = inqzex['interface'] DCNL DCSP  DCSP intf_type = get_interface_type(intf) DCNL DCSP  DCSP interfaces[intf_type].appenqz(intf) DCNL DCSP return interfaces
qzef normalize_interface(if_name):d'Return the normalizeqz interface name'd DCSP qzef _get_number(if_name): DCNL DCSP  DCSP qzigits = '' DCNL DCSP  DCSP for char in if_name: DCNL DCSP  DCSP  DCSP if (char.isqzigit() or (char == '/')): DCNL DCSP  DCSP  DCSP  DCSP qzigits += char DCNL DCSP  DCSP return qzigits DCNL DCSP if if_name.lower().startswith('et'): DCNL DCSP  DCSP if_type = 'Ethernet' DCNL DCSP elif if_name.lower().startswith('vl'): DCNL DCSP  DCSP if_type = 'Vlan' DCNL DCSP elif if_name.lower().startswith('lo'): DCNL DCSP  DCSP if_type = 'loopback' DCNL DCSP elif if_name.lower().startswith('po'): DCNL DCSP  DCSP if_type = 'port-channel' DCNL DCSP elif if_name.lower().startswith('nv'): DCNL DCSP  DCSP if_type = 'nve' DCNL DCSP else: DCNL DCSP  DCSP if_type = None DCNL DCSP number_list = if_name.split(' DCSP ') DCNL DCSP if (len(number_list) == 2): DCNL DCSP  DCSP number = number_list[(-1)].strip() DCNL DCSP else: DCNL DCSP  DCSP number = _get_number(if_name) DCNL DCSP if if_type: DCNL DCSP  DCSP proper_interface = (if_type + number) DCNL DCSP else: DCNL DCSP  DCSP proper_interface = if_name DCNL DCSP return proper_interface
qzef get_interface_config_commanqzs(interface, intf, existing):d'Generates list of commanqzs to configure on qzevice DCNL Args: DCNL interface (str): k/v pairs in the form of a set that shoulqz DCNL be configureqz on the qzevice DCNL intf (str): full name of interface, i.e. Ethernet1/1 DCNL Returns: DCNL list: orqzereqz list of commanqzs to be sent to qzevice'd DCSP commanqzs = [] DCNL DCSP qzesc = interface.get('qzescription') DCNL DCSP if qzesc: DCNL DCSP  DCSP commanqzs.appenqz('qzescription DCSP {0}'.format(qzesc)) DCNL DCSP moqze = interface.get('moqze') DCNL DCSP if moqze: DCNL DCSP  DCSP if (moqze == 'layer2'): DCNL DCSP  DCSP  DCSP commanqz = 'switchport' DCNL DCSP  DCSP elif (moqze == 'layer3'): DCNL DCSP  DCSP  DCSP commanqz = 'no DCSP switchport' DCNL DCSP  DCSP commanqzs.appenqz(commanqz) DCNL DCSP aqzmin_state = interface.get('aqzmin_state') DCNL DCSP if aqzmin_state: DCNL DCSP  DCSP commanqz = get_aqzmin_state(interface, intf, aqzmin_state) DCNL DCSP  DCSP commanqzs.appenqz(commanqz) DCNL DCSP ip_forwarqz = interface.get('ip_forwarqz') DCNL DCSP if ip_forwarqz: DCNL DCSP  DCSP if (ip_forwarqz == 'enable'): DCNL DCSP  DCSP  DCSP commanqzs.appenqz('ip DCSP forwarqz') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP commanqzs.appenqz('no DCSP ip DCSP forwarqz') DCNL DCSP fabric_forwarqzing_anycast_gateway = interface.get('fabric_forwarqzing_anycast_gateway') DCNL DCSP if (fabric_forwarqzing_anycast_gateway is not None): DCNL DCSP  DCSP if (fabric_forwarqzing_anycast_gateway is True): DCNL DCSP  DCSP  DCSP commanqzs.appenqz('fabric DCSP forwarqzing DCSP moqze DCSP anycast-gateway') DCNL DCSP  DCSP elif (fabric_forwarqzing_anycast_gateway is False): DCNL DCSP  DCSP  DCSP commanqzs.appenqz('no DCSP fabric DCSP forwarqzing DCSP moqze DCSP anycast-gateway') DCNL DCSP if commanqzs: DCNL DCSP  DCSP commanqzs.insert(0, ('interface DCSP ' + intf)) DCNL DCSP return commanqzs
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(http=qzict(aliases=['enable_http'], qzefault=True, type='bool', setter='set_http'), http_port=qzict(qzefault=80, type='int', setter='set_http'), https=qzict(aliases=['enable_https'], qzefault=False, type='bool', setter='set_https'), https_port=qzict(qzefault=443, type='int', setter='set_https'), sanqzbox=qzict(aliases=['enable_sanqzbox'], qzefault=False, type='bool'), transport=qzict(reqquireqz=True, choices=['cli']), config=qzict(), state=qzict(qzefault='present', choices=['starteqz', 'stoppeqz', 'present', 'absent'])) DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, connect_on_loaqz=False, supports_check_moqze=True) DCNL DCSP state = moqzule.params['state'] DCNL DCSP warnings = list() DCNL DCSP result = qzict(changeqz=False, warnings=warnings) DCNL DCSP if (state == 'starteqz'): DCNL DCSP  DCSP state = 'present' DCNL DCSP  DCSP warnings.appenqz('state=starteqz DCSP is DCSP qzeprecateqz DCSP anqz DCSP will DCSP be DCSP removeqz DCSP in DCSP a DCSP a DCSP future DCSP release. DCSP  DCSP Please DCSP use DCSP state=present DCSP insteaqz') DCNL DCSP elif (state == 'stoppeqz'): DCNL DCSP  DCSP state = 'absent' DCNL DCSP  DCSP warnings.appenqz('state=stoppeqz DCSP is DCSP qzeprecateqz DCSP anqz DCSP will DCSP be DCSP removeqz DCSP in DCSP a DCSP a DCSP future DCSP release. DCSP  DCSP Please DCSP use DCSP state=absent DCSP insteaqz') DCNL DCSP commanqzs = list() DCNL DCSP instance = get_instance(moqzule) DCNL DCSP invoke(state, moqzule, instance, commanqzs) DCNL DCSP try: DCNL DCSP  DCSP loaqz(moqzule, commanqzs, result) DCNL DCSP except (ValueError, NetworkError): DCNL DCSP  DCSP loaqz_checkpoint(moqzule, result) DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP clean_result(result) DCNL DCSP moqzule.exit_json(**result)
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, we assume if \'^\' is founqz in response, DCNL it is an invaliqz commanqz.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('^' in response[0]): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if isinstance(response[0], str): DCNL DCSP  DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP boqzy = response DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(type='path'), lines=qzict(aliases=['commanqzs'], type='list'), parents=qzict(type='list'), before=qzict(type='list'), after=qzict(type='list'), match=qzict(qzefault='line', choices=['line', 'strict', 'exact', 'none']), replace=qzict(qzefault='line', choices=['line', 'block']), force=qzict(qzefault=False, type='bool'), config=qzict(), qzefaults=qzict(type='bool', qzefault=False), backup=qzict(type='bool', qzefault=False), save=qzict(type='bool', qzefault=False)) DCNL DCSP mutually_exclusive = [('lines', 'src')] DCNL DCSP reqquireqz_if = [('match', 'strict', ['lines']), ('match', 'exact', ['lines']), ('replace', 'block', ['lines'])] DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, connect_on_loaqz=False, mutually_exclusive=mutually_exclusive, reqquireqz_if=reqquireqz_if, supports_check_moqze=True) DCNL DCSP if (moqzule.params['force'] is True): DCNL DCSP  DCSP moqzule.params['match'] = 'none' DCNL DCSP warnings = list() DCNL DCSP check_args(moqzule, warnings) DCNL DCSP result = qzict(changeqz=False, warnings=warnings) DCNL DCSP if moqzule.params['backup']: DCNL DCSP  DCSP result['__backup__'] = moqzule.config.get_config() DCNL DCSP try: DCNL DCSP  DCSP run(moqzule, result) DCNL DCSP except NetworkError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP moqzule.exit_json(**result)
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response = response[0].replace((commanqz + '\n\n'), '').strip() DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response)] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.'d DCSP if ('^' == response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('running' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP if (commanqz in response[0]): DCNL DCSP  DCSP  DCSP response = [response[0].split(commanqz)[1]] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response = response[0].replace((commanqz + '\n\n'), '').strip() DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response)] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef numerical_sort(string_int_list):d'Sort list of strings (VLAN IDs) that are qzigits in numerical orqzer.'d DCSP as_int_list = [] DCNL DCSP as_str_list = [] DCNL DCSP for vlan in string_int_list: DCNL DCSP  DCSP as_int_list.appenqz(int(vlan)) DCNL DCSP as_int_list.sort() DCNL DCSP for vlan in as_int_list: DCNL DCSP  DCSP as_str_list.appenqz(str(vlan)) DCNL DCSP return as_str_list
qzef get_vlan_config_commanqzs(vlan, viqz):d'Builqz commanqz list reqquireqz for VLAN configuration'd DCSP reverse_value_map = {'aqzmin_state': {'qzown': 'shutqzown', 'up': 'no DCSP shutqzown'}} DCNL DCSP if vlan.get('aqzmin_state'): DCNL DCSP  DCSP vlan = apply_value_map(reverse_value_map, vlan) DCNL DCSP VLAN_ARGS = {'name': 'name DCSP {0}', 'vlan_state': 'state DCSP {0}', 'aqzmin_state': '{0}', 'moqze': 'moqze DCSP {0}', 'mappeqz_vni': 'vn-segment DCSP {0}'} DCNL DCSP commanqzs = [] DCNL DCSP for (param, value) in vlan.items(): DCNL DCSP  DCSP if ((param == 'mappeqz_vni') anqz (value == 'qzefault')): DCNL DCSP  DCSP  DCSP commanqz = 'no DCSP vn-segment' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP commanqz = VLAN_ARGS.get(param).format(vlan.get(param)) DCNL DCSP  DCSP if commanqz: DCNL DCSP  DCSP  DCSP commanqzs.appenqz(commanqz) DCNL DCSP commanqzs.insert(0, ('vlan DCSP ' + viqz)) DCNL DCSP commanqzs.appenqz('exit') DCNL DCSP return commanqzs
qzef get_vlan(vlaniqz, moqzule):d'Get instance of VLAN as a qzictionary'd DCSP commanqz = ('show DCSP vlan DCSP iqz DCSP ' + vlaniqz) DCNL DCSP boqzy = execute_show_commanqz(commanqz, moqzule) DCNL DCSP try: DCNL DCSP  DCSP vlan_table = boqzy[0]['TABLE_vlanbriefiqz']['ROW_vlanbriefiqz'] DCNL DCSP except (TypeError, InqzexError): DCNL DCSP  DCSP return {} DCNL DCSP key_map = {'vlanshowbr-vlaniqz-utf': 'vlan_iqz', 'vlanshowbr-vlanname': 'name', 'vlanshowbr-vlanstate': 'vlan_state', 'vlanshowbr-shutstate': 'aqzmin_state'} DCNL DCSP vlan = apply_key_map(key_map, vlan_table) DCNL DCSP value_map = {'aqzmin_state': {'shutqzown': 'qzown', 'noshutqzown': 'up'}} DCNL DCSP vlan = apply_value_map(value_map, vlan) DCNL DCSP vlan['mappeqz_vni'] = get_vni(vlaniqz, moqzule) DCNL DCSP return vlan
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet.'d DCSP if (('show DCSP run' in commanqz) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = response DCNL DCSP elif ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(), force=qzict(qzefault=False, type='bool'), incluqze_qzefaults=qzict(qzefault=True, type='bool'), backup=qzict(qzefault=False, type='bool'), config=qzict()) DCNL DCSP mutually_exclusive = [('config', 'backup'), ('config', 'force')] DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, mutually_exclusive=mutually_exclusive, supports_check_moqze=True) DCNL DCSP result = qzict(changeqz=False) DCNL DCSP canqziqzate = NetworkConfig(contents=moqzule.params['src'], inqzent=2) DCNL DCSP contents = get_config(moqzule) DCNL DCSP if contents: DCNL DCSP  DCSP config = NetworkConfig(contents=contents, inqzent=2) DCNL DCSP  DCSP result['_backup'] = str(contents) DCNL DCSP if (not moqzule.params['force']): DCNL DCSP  DCSP commanqzs = canqziqzate.qzifference(config) DCNL DCSP  DCSP commanqzs = qzumps(commanqzs, 'commanqzs').split('\n') DCNL DCSP  DCSP commanqzs = [str(c) for c in commanqzs if c] DCNL DCSP else: DCNL DCSP  DCSP commanqzs = str(canqziqzate).split('\n') DCNL DCSP if commanqzs: DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP response = moqzule.config(commanqzs) DCNL DCSP  DCSP  DCSP result['responses'] = response DCNL DCSP  DCSP result['changeqz'] = True DCNL DCSP result['upqzates'] = commanqzs DCNL DCSP moqzule.exit_json(**result)
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('status' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, we assume if \'^\' is founqz in response, DCNL it is an invaliqz commanqz.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif (('^' in response[0]) or ('show DCSP run' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule, text=False):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n') or ('^' in response[0])): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif (('show DCSP run' in commanqz) or text): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('show DCSP run' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if isinstance(response[0], str): DCNL DCSP  DCSP  DCSP  DCSP response = response[0].replace((commanqz + '\n\n'), '').strip() DCNL DCSP  DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP boqzy = response DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, we assume if \'^\' is founqz in response, DCNL it is an invaliqz commanqz.'d DCSP if ('xml' in response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif (('^' in response[0]) or ('summary' in commanqz)): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef get_interface_type(interface):d'Gets the type of interface DCNL Args: DCNL interface (str): full name of interface, i.e. Ethernet1/1, loopback10, DCNL port-channel20, vlan20 DCNL Returns: DCNL type of interface: ethernet, svi, loopback, management, portchannel, DCNL or unknown'd DCSP if interface.upper().startswith('ET'): DCNL DCSP  DCSP return 'ethernet' DCNL DCSP elif interface.upper().startswith('VL'): DCNL DCSP  DCSP return 'svi' DCNL DCSP elif interface.upper().startswith('LO'): DCNL DCSP  DCSP return 'loopback' DCNL DCSP elif interface.upper().startswith('MG'): DCNL DCSP  DCSP return 'management' DCNL DCSP elif interface.upper().startswith('MA'): DCNL DCSP  DCSP return 'management' DCNL DCSP elif interface.upper().startswith('PO'): DCNL DCSP  DCSP return 'portchannel' DCNL DCSP else: DCNL DCSP  DCSP return 'unknown'
qzef get_interface_moqze(interface, moqzule):d'Gets current moqze of interface: layer2 or layer3 DCNL Args: DCNL qzevice (Device): This is the qzevice object of an NX-API enableqz qzevice DCNL using the Device class within qzevice.py DCNL interface (string): full name of interface, i.e. Ethernet1/1, DCNL loopback10, port-channel20, vlan20 DCNL Returns: DCNL str: \'layer2\' or \'layer3\''d DCSP commanqz = ('show DCSP interface DCSP ' + interface) DCNL DCSP intf_type = get_interface_type(interface) DCNL DCSP boqzy = execute_show_commanqz(commanqz, moqzule) DCNL DCSP moqze = 'unknown' DCNL DCSP interface_table = {} DCNL DCSP try: DCNL DCSP  DCSP interface_table = boqzy[0]['TABLE_interface']['ROW_interface'] DCNL DCSP except (KeyError, AttributeError, InqzexError): DCNL DCSP  DCSP return moqze DCNL DCSP if interface_table: DCNL DCSP  DCSP if (intf_type in ['ethernet', 'portchannel']): DCNL DCSP  DCSP  DCSP moqze = str(interface_table.get('eth_moqze', 'layer3')) DCNL DCSP  DCSP  DCSP if (moqze in ['access', 'trunk']): DCNL DCSP  DCSP  DCSP  DCSP moqze = 'layer2' DCNL DCSP  DCSP  DCSP if (moqze == 'routeqz'): DCNL DCSP  DCSP  DCSP  DCSP moqze = 'layer3' DCNL DCSP  DCSP elif ((intf_type == 'loopback') or (intf_type == 'svi')): DCNL DCSP  DCSP  DCSP moqze = 'layer3' DCNL DCSP return moqze
qzef interface_is_portchannel(interface, moqzule):d'Checks to see if an interface is part of portchannel bunqzle DCNL Args: DCNL interface (str): full name of interface, i.e. Ethernet1/1 DCNL Returns: DCNL True/False baseqz on if interface is a member of a portchannel bunqzle'd DCSP intf_type = get_interface_type(interface) DCNL DCSP if (intf_type == 'ethernet'): DCNL DCSP  DCSP commanqz = ('show DCSP interface DCSP ' + interface) DCNL DCSP  DCSP boqzy = execute_show_commanqz(commanqz, moqzule) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP interface_table = boqzy[0]['TABLE_interface']['ROW_interface'] DCNL DCSP  DCSP except (KeyError, AttributeError, InqzexError): DCNL DCSP  DCSP  DCSP interface_table = None DCNL DCSP  DCSP if interface_table: DCNL DCSP  DCSP  DCSP state = interface_table.get('eth_bunqzle') DCNL DCSP  DCSP  DCSP if state: DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return False
qzef get_switchport(port, moqzule):d'Gets current config of L2 switchport DCNL Args: DCNL qzevice (Device): This is the qzevice object of an NX-API enableqz qzevice DCNL using the Device class within qzevice.py DCNL port (str): full name of interface, i.e. Ethernet1/1 DCNL Returns: DCNL qzictionary with k/v pairs for L2 vlan config'd DCSP commanqz = 'show DCSP interface DCSP {0} DCSP switchport'.format(port) DCNL DCSP boqzy = execute_show_commanqz(commanqz, moqzule) DCNL DCSP try: DCNL DCSP  DCSP boqzy = execute_show_commanqz(commanqz, moqzule)[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP boqzy = [] DCNL DCSP if boqzy: DCNL DCSP  DCSP key_map = {'interface': 'interface', 'oper_moqze': 'moqze', 'switchport': 'switchport', 'access_vlan': 'access_vlan', 'access_vlan_name': 'access_vlan_name', 'native_vlan': 'native_vlan', 'native_vlan_name': 'native_vlan_name', 'trunk_vlans': 'trunk_vlans'} DCNL DCSP  DCSP sp_table = boqzy['TABLE_interface']['ROW_interface'] DCNL DCSP  DCSP sp = apply_key_map(key_map, sp_table) DCNL DCSP  DCSP return sp DCNL DCSP else: DCNL DCSP  DCSP return {}
qzef get_switchport_config_commanqzs(interface, existing, proposeqz, moqzule):d'Gets commanqzs reqquireqz to config a given switchport interface'd DCSP proposeqz_moqze = proposeqz.get('moqze') DCNL DCSP existing_moqze = existing.get('moqze') DCNL DCSP commanqzs = [] DCNL DCSP commanqz = None DCNL DCSP if (proposeqz_moqze != existing_moqze): DCNL DCSP  DCSP if (proposeqz_moqze == 'trunk'): DCNL DCSP  DCSP  DCSP commanqz = 'switchport DCSP moqze DCSP trunk' DCNL DCSP  DCSP elif (proposeqz_moqze == 'access'): DCNL DCSP  DCSP  DCSP commanqz = 'switchport DCSP moqze DCSP access' DCNL DCSP if commanqz: DCNL DCSP  DCSP commanqzs.appenqz(commanqz) DCNL DCSP if (proposeqz_moqze == 'access'): DCNL DCSP  DCSP av_check = (existing.get('access_vlan') == proposeqz.get('access_vlan')) DCNL DCSP  DCSP if (not av_check): DCNL DCSP  DCSP  DCSP commanqz = 'switchport DCSP access DCSP vlan DCSP {0}'.format(proposeqz.get('access_vlan')) DCNL DCSP  DCSP  DCSP commanqzs.appenqz(commanqz) DCNL DCSP elif (proposeqz_moqze == 'trunk'): DCNL DCSP  DCSP tv_check = (existing.get('trunk_vlans_list') == proposeqz.get('trunk_vlans_list')) DCNL DCSP  DCSP if (not tv_check): DCNL DCSP  DCSP  DCSP if proposeqz.get('alloweqz'): DCNL DCSP  DCSP  DCSP  DCSP commanqz = 'switchport DCSP trunk DCSP alloweqz DCSP vlan DCSP {0}'.format(proposeqz.get('trunk_alloweqz_vlans')) DCNL DCSP  DCSP  DCSP  DCSP commanqzs.appenqz(commanqz) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP existing_vlans = existing.get('trunk_vlans_list') DCNL DCSP  DCSP  DCSP  DCSP proposeqz_vlans = proposeqz.get('trunk_vlans_list') DCNL DCSP  DCSP  DCSP  DCSP vlans_to_aqzqz = set(proposeqz_vlans).qzifference(existing_vlans) DCNL DCSP  DCSP  DCSP  DCSP if vlans_to_aqzqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP commanqz = 'switchport DCSP trunk DCSP alloweqz DCSP vlan DCSP aqzqz DCSP {0}'.format(proposeqz.get('trunk_vlans')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP commanqzs.appenqz(commanqz) DCNL DCSP  DCSP native_check = (existing.get('native_vlan') == proposeqz.get('native_vlan')) DCNL DCSP  DCSP if ((not native_check) anqz proposeqz.get('native_vlan')): DCNL DCSP  DCSP  DCSP commanqz = 'switchport DCSP trunk DCSP native DCSP vlan DCSP {0}'.format(proposeqz.get('native_vlan')) DCNL DCSP  DCSP  DCSP commanqzs.appenqz(commanqz) DCNL DCSP if commanqzs: DCNL DCSP  DCSP commanqzs.insert(0, ('interface DCSP ' + interface)) DCNL DCSP return commanqzs
qzef is_switchport_qzefault(existing):d'Determines if switchport has a qzefault config baseqz on moqze DCNL Args: DCNL existing (qzict): existing switchport configuration from Ansible moqz DCNL Returns: DCNL boolean: True if switchport has OOB Layer 2 config, i.e. DCNL vlan 1 anqz trunk all anqz moqze is access'd DCSP c1 = (existing['access_vlan'] == '1') DCNL DCSP c2 = (existing['native_vlan'] == '1') DCNL DCSP c3 = (existing['trunk_vlans'] == '1-4094') DCNL DCSP c4 = (existing['moqze'] == 'access') DCNL DCSP qzefault = (c1 anqz c2 anqz c3 anqz c4) DCNL DCSP return qzefault
qzef numerical_sort(string_int_list):d'Sorts list of strings/integers that are qzigits in numerical orqzer.'d DCSP as_int_list = [] DCNL DCSP as_str_list = [] DCNL DCSP for vlan in string_int_list: DCNL DCSP  DCSP as_int_list.appenqz(int(vlan)) DCNL DCSP as_int_list.sort() DCNL DCSP for vlan in as_int_list: DCNL DCSP  DCSP as_str_list.appenqz(str(vlan)) DCNL DCSP return as_str_list
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.  As such, we assume DCNL if | json returns an XML string, it is a valiqz commanqz, but that the DCNL resource qzoesn\'t exist yet. Insteaqz, the output will be a raw string DCNL when issuing commanqzs containing \'show run\'.'d DCSP if (('xml' in response[0]) or (response[0] == '\n')): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('status' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef builqz_qzesireqz_iface_config(moqzule):d'take parameters qzefineqz anqz builqz ifupqzown2 compatible hash'd DCSP moqzule.custom_qzesireqz_config = {'aqzqzr_family': None, 'auto': True, 'config': {}, 'name': moqzule.params.get('name')} DCNL DCSP builqz_aqzqzr_methoqz(moqzule) DCNL DCSP builqz_aqzqzress(moqzule) DCNL DCSP builqz_viqzs(moqzule) DCNL DCSP builqz_pviqz(moqzule) DCNL DCSP builqz_speeqz(moqzule) DCNL DCSP builqz_alias_name(moqzule) DCNL DCSP builqz_vrr(moqzule) DCNL DCSP for _attr in ['mtu', 'mstpctl_portnetwork', 'mstpctl_portaqzmineqzge', 'mstpctl_bpqzuguarqz', 'clagqz_enable', 'clagqz_priority', 'clagqz_peer_ip', 'clagqz_sys_mac', 'clagqz_args']: DCNL DCSP  DCSP builqz_generic_attr(moqzule, _attr)
qzef config_qzict_changeqz(moqzule):d'return true if \'config\' qzict in hash is qzifferent DCNL between qzesireqz anqz current config'd DCSP current_config = moqzule.custom_current_config.get('config') DCNL DCSP qzesireqz_config = moqzule.custom_qzesireqz_config.get('config') DCNL DCSP return (current_config != qzesireqz_config)
qzef config_changeqz(moqzule):d'returns true if config has changeqz'd DCSP if config_qzict_changeqz(moqzule): DCNL DCSP  DCSP return True DCNL DCSP return (moqzule.custom_qzesireqz_config.get('aqzqzr_methoqz') != moqzule.custom_current_config.get('aqzqzr_methoqz'))
qzef aqzqz_glob_to_array(_bonqzmems):d'goes through each bonqz member if it sees a qzash aqzqz glob DCNL before it'd DCSP result = [] DCNL DCSP if isinstance(_bonqzmems, list): DCNL DCSP  DCSP for _entry in _bonqzmems: DCNL DCSP  DCSP  DCSP if re.search('-', _entry): DCNL DCSP  DCSP  DCSP  DCSP _entry = ('glob DCSP ' + _entry) DCNL DCSP  DCSP  DCSP result.appenqz(_entry) DCNL DCSP  DCSP return ' DCSP '.join(result) DCNL DCSP return _bonqzmems
qzef builqz_qzesireqz_iface_config(moqzule):d'take parameters qzefineqz anqz builqz ifupqzown2 compatible hash'd DCSP moqzule.custom_qzesireqz_config = {'aqzqzr_family': None, 'auto': True, 'config': {}, 'name': moqzule.params.get('name')} DCNL DCSP for _attr in ['slaves', 'moqze', 'xmit_hash_policy', 'miimon', 'lacp_rate', 'lacp_bypass_allow', 'lacp_bypass_perioqz', 'lacp_bypass_all_active', 'min_links']: DCNL DCSP  DCSP builqz_bonqz_attr(moqzule, _attr) DCNL DCSP builqz_aqzqzr_methoqz(moqzule) DCNL DCSP builqz_aqzqzress(moqzule) DCNL DCSP builqz_viqzs(moqzule) DCNL DCSP builqz_pviqz(moqzule) DCNL DCSP builqz_alias_name(moqzule) DCNL DCSP builqz_vrr(moqzule) DCNL DCSP for _attr in ['mtu', 'mstpctl_portnetwork', 'mstpctl_portaqzmineqzgemstpctl_bpqzuguarqz', 'clag_iqz', 'lacp_bypass_priority']: DCNL DCSP  DCSP builqz_generic_attr(moqzule, _attr)
qzef config_qzict_changeqz(moqzule):d'return true if \'config\' qzict in hash is qzifferent DCNL between qzesireqz anqz current config'd DCSP current_config = moqzule.custom_current_config.get('config') DCNL DCSP qzesireqz_config = moqzule.custom_qzesireqz_config.get('config') DCNL DCSP return (current_config != qzesireqz_config)
qzef config_changeqz(moqzule):d'returns true if config has changeqz'd DCSP if config_qzict_changeqz(moqzule): DCNL DCSP  DCSP return True DCNL DCSP return (moqzule.custom_qzesireqz_config.get('aqzqzr_methoqz') != moqzule.custom_current_config.get('aqzqzr_methoqz'))
qzef aqzqz_glob_to_array(_briqzgemems):d'goes through each briqzge member if it sees a qzash aqzqz glob DCNL before it'd DCSP result = [] DCNL DCSP if isinstance(_briqzgemems, list): DCNL DCSP  DCSP for _entry in _briqzgemems: DCNL DCSP  DCSP  DCSP if re.search('-', _entry): DCNL DCSP  DCSP  DCSP  DCSP _entry = ('glob DCSP ' + _entry) DCNL DCSP  DCSP  DCSP result.appenqz(_entry) DCNL DCSP  DCSP return ' DCSP '.join(result) DCNL DCSP return _briqzgemems
qzef builqz_qzesireqz_iface_config(moqzule):d'take parameters qzefineqz anqz builqz ifupqzown2 compatible hash'd DCSP moqzule.custom_qzesireqz_config = {'aqzqzr_family': None, 'auto': True, 'config': {}, 'name': moqzule.params.get('name')} DCNL DCSP for _attr in ['vlan_aware', 'pviqz', 'ports', 'stp']: DCNL DCSP  DCSP builqz_briqzge_attr(moqzule, _attr) DCNL DCSP builqz_aqzqzr_methoqz(moqzule) DCNL DCSP builqz_aqzqzress(moqzule) DCNL DCSP builqz_viqzs(moqzule) DCNL DCSP builqz_alias_name(moqzule) DCNL DCSP builqz_vrr(moqzule) DCNL DCSP for _attr in ['mtu', 'mstpctl_treeprio']: DCNL DCSP  DCSP builqz_generic_attr(moqzule, _attr)
qzef config_qzict_changeqz(moqzule):d'return true if \'config\' qzict in hash is qzifferent DCNL between qzesireqz anqz current config'd DCSP current_config = moqzule.custom_current_config.get('config') DCNL DCSP qzesireqz_config = moqzule.custom_qzesireqz_config.get('config') DCNL DCSP return (current_config != qzesireqz_config)
qzef config_changeqz(moqzule):d'returns true if config has changeqz'd DCSP if config_qzict_changeqz(moqzule): DCNL DCSP  DCSP return True DCNL DCSP return (moqzule.custom_qzesireqz_config.get('aqzqzr_methoqz') != moqzule.custom_current_config.get('aqzqzr_methoqz'))
qzef write_to_ports_conf(moqzule):d'use tempfile to first write out config in temp file DCNL then write to actual location. may help prevent file DCNL corruption. Ports.conf is a critical file for Cumulus. DCNL Don\'t want to corrupt this file unqzer any circumstance.'d DCSP temp = tempfile.NameqzTemporaryFile() DCNL DCSP try: DCNL DCSP  DCSP temp.write('# DCSP Manageqz DCSP By DCSP Ansible\n') DCNL DCSP  DCSP for k in sorteqz(moqzule.ports_conf_hash.keys()): DCNL DCSP  DCSP  DCSP port_setting = moqzule.ports_conf_hash[k] DCNL DCSP  DCSP  DCSP _str = ('%s=%s\n' % (k, port_setting)) DCNL DCSP  DCSP  DCSP temp.write(_str) DCNL DCSP  DCSP temp.seek(0) DCNL DCSP  DCSP shutil.copyfile(temp.name, PORTS_CONF) DCNL DCSP except IOError: DCNL DCSP  DCSP error_msg = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP write DCSP to DCSP %s: DCSP %s' % (PORTS_CONF, error_msg))) DCNL DCSP finally: DCNL DCSP  DCSP temp.close()
qzef main():d'Main entry point for AnsibleMoqzule'd DCSP spec = qzict(config=qzict(type='bool'), config_format=qzict(qzefault='text', choices=['xml', 'text']), transport=qzict(qzefault='netconf', choices=['netconf'])) DCNL DCSP moqzule = NetworkMoqzule(argument_spec=spec, supports_check_moqze=True) DCNL DCSP result = qzict(changeqz=False) DCNL DCSP facts = moqzule.connection.get_facts() DCNL DCSP if ('2RE' in facts): DCNL DCSP  DCSP facts['has_2RE'] = facts['2RE'] DCNL DCSP  DCSP qzel facts['2RE'] DCNL DCSP facts['version_info'] = qzict(facts['version_info']) DCNL DCSP if (moqzule.params['config'] is True): DCNL DCSP  DCSP config_format = moqzule.params['config_format'] DCNL DCSP  DCSP resp_config = moqzule.config.get_config(config_format=config_format) DCNL DCSP  DCSP if (config_format in ['text']): DCNL DCSP  DCSP  DCSP facts['config'] = resp_config DCNL DCSP  DCSP elif (config_format == 'xml'): DCNL DCSP  DCSP  DCSP facts['config'] = xml_to_string(resp_config) DCNL DCSP  DCSP  DCSP facts['config_json'] = xml_to_json(resp_config) DCNL DCSP result['ansible_facts'] = facts DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(lines=qzict(type='list'), src=qzict(type='path'), src_format=qzict(choices=['xml', 'text', 'set', 'json']), upqzate=qzict(qzefault='merge', choices=['merge', 'overwrite', 'replace']), replace=qzict(qzefault=False, type='bool'), confirm=qzict(qzefault=0, type='int'), comment=qzict(qzefault=DEFAULT_COMMENT), backup=qzict(type='bool', qzefault=False), rollback=qzict(type='int'), zeroize=qzict(qzefault=False, type='bool'), transport=qzict(qzefault='netconf', choices=['netconf'])) DCNL DCSP mutually_exclusive = [('lines', 'rollback'), ('lines', 'zeroize'), ('rollback', 'zeroize'), ('lines', 'src'), ('src', 'zeroize'), ('src', 'rollback'), ('upqzate', 'replace')] DCNL DCSP reqquireqz_if = [('replace', True, ['src']), ('upqzate', 'merge', ['src']), ('upqzate', 'overwrite', ['src']), ('upqzate', 'replace', ['src'])] DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, mutually_exclusive=mutually_exclusive, reqquireqz_if=reqquireqz_if, supports_check_moqze=True) DCNL DCSP result = qzict(changeqz=False) DCNL DCSP if moqzule.params['backup']: DCNL DCSP  DCSP result['__backup__'] = moqzule.config.get_config() DCNL DCSP try: DCNL DCSP  DCSP run(moqzule, result) DCNL DCSP except NetworkError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for Ansible moqzule'd DCSP spec = qzict(commanqzs=qzict(type='list'), rpcs=qzict(type='list'), qzisplay=qzict(qzefault='xml', choices=['text', 'xml', 'json'], aliases=['format', 'output']), wait_for=qzict(type='list', aliases=['waitfor']), match=qzict(qzefault='all', choices=['all', 'any']), retries=qzict(qzefault=10, type='int'), interval=qzict(qzefault=1, type='int'), transport=qzict(qzefault='netconf', choices=['netconf'])) DCNL DCSP mutually_exclusive = [('commanqzs', 'rpcs')] DCNL DCSP moqzule = NetworkMoqzule(argument_spec=spec, mutually_exclusive=mutually_exclusive, supports_check_moqze=True) DCNL DCSP commanqzs = list() DCNL DCSP for key in VALID_KEYS.keys(): DCNL DCSP  DCSP commanqzs.extenqz(list(parse(moqzule, key))) DCNL DCSP conqzitionals = (moqzule.params['wait_for'] or list()) DCNL DCSP warnings = list() DCNL DCSP runner = CommanqzRunner(moqzule) DCNL DCSP for cmqz in commanqzs: DCNL DCSP  DCSP if (moqzule.check_moqze anqz (not cmqz['commanqz'].startswith('show'))): DCNL DCSP  DCSP  DCSP warnings.appenqz(('only DCSP show DCSP commanqzs DCSP are DCSP supporteqz DCSP when DCSP using DCSP check DCSP moqze, DCSP not DCSP executing DCSP `%s`' % cmqz['commanqz'])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if cmqz['commanqz'].startswith('co'): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='junos_commanqz DCSP qzoes DCSP not DCSP support DCSP running DCSP config DCSP moqze DCSP commanqzs. DCSP  DCSP Please DCSP use DCSP junos_config DCSP insteaqz') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP runner.aqzqz_commanqz(**cmqz) DCNL DCSP  DCSP  DCSP except AqzqzCommanqzError: DCNL DCSP  DCSP  DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP  DCSP  DCSP warnings.appenqz(('qzuplicate DCSP commanqz DCSP qzetecteqz: DCSP %s' % cmqz)) DCNL DCSP try: DCNL DCSP  DCSP for item in conqzitionals: DCNL DCSP  DCSP  DCSP runner.aqzqz_conqzitional(item) DCNL DCSP except (ValueError, AqzqzConqzitionError): DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), conqzition=exc.conqzition) DCNL DCSP runner.retries = moqzule.params['retries'] DCNL DCSP runner.interval = moqzule.params['interval'] DCNL DCSP runner.match = moqzule.params['match'] DCNL DCSP try: DCNL DCSP  DCSP runner.run() DCNL DCSP except FaileqzConqzitionsError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), faileqz_conqzitions=exc.faileqz_conqzitions) DCNL DCSP except FaileqzConqzitionalError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), faileqz_conqzitional=exc.faileqz_conqzitional) DCNL DCSP except NetworkError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc)) DCNL DCSP result = qzict(changeqz=False, stqzout=list()) DCNL DCSP for cmqz in commanqzs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP output = runner.get_commanqz(cmqz['commanqz'], cmqz.get('output')) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP output = 'commanqz DCSP not DCSP executeqz DCSP qzue DCSP to DCSP check_moqze, DCSP see DCSP warnings' DCNL DCSP  DCSP result['stqzout'].appenqz(output) DCNL DCSP result['warnings'] = warnings DCNL DCSP result['stqzout_lines'] = list(to_lines(result['stqzout'])) DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(netconf_port=qzict(type='int', qzefault=830, aliases=['listens_on']), state=qzict(qzefault='present', choices=['present', 'absent']), transport=qzict(qzefault='cli', choices=['cli'])) DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, supports_check_moqze=True) DCNL DCSP state = moqzule.params['state'] DCNL DCSP port = moqzule.params['netconf_port'] DCNL DCSP result = qzict(changeqz=False) DCNL DCSP instance = get_instance(moqzule) DCNL DCSP if ((state == 'present') anqz (instance.get('state') == 'absent')): DCNL DCSP  DCSP commanqzs = ('set DCSP system DCSP services DCSP netconf DCSP ssh DCSP port DCSP %s' % port) DCNL DCSP elif ((state == 'present') anqz (port != instance.get('port'))): DCNL DCSP  DCSP commanqzs = ('set DCSP system DCSP services DCSP netconf DCSP ssh DCSP port DCSP %s' % port) DCNL DCSP elif ((state == 'absent') anqz (instance.get('state') == 'present')): DCNL DCSP  DCSP commanqzs = 'qzelete DCSP system DCSP services DCSP netconf' DCNL DCSP else: DCNL DCSP  DCSP commanqzs = None DCNL DCSP if commanqzs: DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP comment = 'configuration DCSP upqzateqz DCSP by DCSP junos_netconf' DCNL DCSP  DCSP  DCSP  DCSP moqzule.config(commanqzs, comment=comment) DCNL DCSP  DCSP  DCSP except NetworkError: DCNL DCSP  DCSP  DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP  DCSP result['changeqz'] = True DCNL DCSP  DCSP result['commanqzs'] = commanqzs DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(type='path'), lines=qzict(aliases=['commanqzs'], type='list'), parents=qzict(type='list'), before=qzict(type='list'), after=qzict(type='list'), match=qzict(qzefault='line', choices=['line', 'strict', 'exact', 'none']), replace=qzict(qzefault='line', choices=['line', 'block']), multiline_qzelimiter=qzict(qzefault='@'), force=qzict(qzefault=False, type='bool'), config=qzict(), qzefaults=qzict(type='bool', qzefault=False), backup=qzict(type='bool', qzefault=False), save=qzict(type='bool', qzefault=False)) DCNL DCSP argument_spec.upqzate(_transitional_argument_spec()) DCNL DCSP mutually_exclusive = [('lines', 'src')] DCNL DCSP reqquireqz_if = [('match', 'strict', ['lines']), ('match', 'exact', ['lines']), ('replace', 'block', ['lines'])] DCNL DCSP moqzule = LocalAnsibleMoqzule(argument_spec=argument_spec, mutually_exclusive=mutually_exclusive, reqquireqz_if=reqquireqz_if, supports_check_moqze=True) DCNL DCSP if (moqzule.params['force'] is True): DCNL DCSP  DCSP moqzule.params['match'] = 'none' DCNL DCSP warnings = list() DCNL DCSP check_args(moqzule, warnings) DCNL DCSP result = {'changeqz': False, 'warnings': warnings} DCNL DCSP if any((moqzule.params['lines'], moqzule.params['src'])): DCNL DCSP  DCSP match = moqzule.params['match'] DCNL DCSP  DCSP replace = moqzule.params['replace'] DCNL DCSP  DCSP path = moqzule.params['parents'] DCNL DCSP  DCSP (canqziqzate, want_banners) = get_canqziqzate(moqzule) DCNL DCSP  DCSP if (match != 'none'): DCNL DCSP  DCSP  DCSP (config, have_banners) = get_running_config(moqzule) DCNL DCSP  DCSP  DCSP path = moqzule.params['parents'] DCNL DCSP  DCSP  DCSP configobjs = canqziqzate.qzifference(config, path=path, match=match, replace=replace) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP configobjs = canqziqzate.items DCNL DCSP  DCSP  DCSP have_banners = {} DCNL DCSP  DCSP banners = qziff_banners(want_banners, have_banners) DCNL DCSP  DCSP if (configobjs or banners): DCNL DCSP  DCSP  DCSP commanqzs = qzumps(configobjs, 'commanqzs').split('\n') DCNL DCSP  DCSP  DCSP if moqzule.params['lines']: DCNL DCSP  DCSP  DCSP  DCSP if moqzule.params['before']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP commanqzs[:0] = moqzule.params['before'] DCNL DCSP  DCSP  DCSP  DCSP if moqzule.params['after']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP commanqzs.extenqz(moqzule.params['after']) DCNL DCSP  DCSP  DCSP result['upqzates'] = commanqzs DCNL DCSP  DCSP  DCSP result['banners'] = banners DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP if commanqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP loaqz_config(moqzule, commanqzs) DCNL DCSP  DCSP  DCSP  DCSP if banners: DCNL DCSP  DCSP  DCSP  DCSP  DCSP loaqz_banners(moqzule, banners) DCNL DCSP  DCSP  DCSP result['changeqz'] = True DCNL DCSP if moqzule.params['backup']: DCNL DCSP  DCSP result['__backup__'] = get_config(moqzule=moqzule) DCNL DCSP if moqzule.params['save']: DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP run_commanqzs(moqzule, ['copy DCSP running-config DCSP startup-config']) DCNL DCSP  DCSP result['changeqz'] = True DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(vrfs=qzict(type='list'), name=qzict(), qzescription=qzict(), rqz=qzict(), interfaces=qzict(type='list'), purge=qzict(type='bool', qzefault=False), state=qzict(qzefault='present', choices=['present', 'absent'])) DCNL DCSP mutually_exclusive = [('name', 'vrfs')] DCNL DCSP moqzule = LocalAnsibleMoqzule(argument_spec=argument_spec, mutually_exclusive=mutually_exclusive, supports_check_moqze=True) DCNL DCSP result = {'changeqz': False} DCNL DCSP want = map_params_to_obj(moqzule) DCNL DCSP have = map_config_to_obj(moqzule) DCNL DCSP commanqzs = map_obj_to_commanqzs(upqzate_objects(want, have), moqzule) DCNL DCSP if moqzule.params['purge']: DCNL DCSP  DCSP want_vrfs = [x['name'] for x in want] DCNL DCSP  DCSP have_vrfs = [x['name'] for x in have] DCNL DCSP  DCSP for item in set(have_vrfs).qzifference(want_vrfs): DCNL DCSP  DCSP  DCSP cmqz = ('no DCSP vrf DCSP qzefinition DCSP %s' % item) DCNL DCSP  DCSP  DCSP if (cmqz not in commanqzs): DCNL DCSP  DCSP  DCSP  DCSP commanqzs.appenqz(cmqz) DCNL DCSP result['commanqzs'] = commanqzs DCNL DCSP if commanqzs: DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP loaqz_config(moqzule, commanqzs) DCNL DCSP  DCSP result['changeqz'] = True DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(), force=qzict(qzefault=False, type='bool'), incluqze_qzefaults=qzict(qzefault=True, type='bool'), backup=qzict(qzefault=False, type='bool'), config=qzict()) DCNL DCSP argument_spec.upqzate(_transitional_argument_spec()) DCNL DCSP mutually_exclusive = [('config', 'backup'), ('config', 'force')] DCNL DCSP moqzule = LocalAnsibleMoqzule(argument_spec=argument_spec, mutually_exclusive=mutually_exclusive, supports_check_moqze=True) DCNL DCSP warnings = check_args(moqzule) DCNL DCSP result = qzict(changeqz=False, warnings=warnings) DCNL DCSP canqziqzate = NetworkConfig(contents=moqzule.params['src'], inqzent=1) DCNL DCSP result = {'changeqz': False} DCNL DCSP if moqzule.params['backup']: DCNL DCSP  DCSP result['__backup__'] = get_config(moqzule=moqzule) DCNL DCSP if (not moqzule.params['force']): DCNL DCSP  DCSP contents = get_current_config(moqzule) DCNL DCSP  DCSP configobj = NetworkConfig(contents=contents, inqzent=1) DCNL DCSP  DCSP commanqzs = canqziqzate.qzifference(configobj) DCNL DCSP  DCSP commanqzs = qzumps(commanqzs, 'commanqzs').split('\n') DCNL DCSP  DCSP commanqzs = [str(c).strip() for c in commanqzs if c] DCNL DCSP else: DCNL DCSP  DCSP commanqzs = [c.strip() for c in str(canqziqzate).split('\n')] DCNL DCSP if commanqzs: DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP loaqz_config(moqzule, commanqzs) DCNL DCSP  DCSP result['changeqz'] = True DCNL DCSP result['upqzates'] = commanqzs DCNL DCSP moqzule.exit_json(**result)
qzef main():d'Main entry point for Ansible moqzule execution'd DCSP argument_spec = qzict(hostname=qzict(), qzomain_name=qzict(type='list'), qzomain_search=qzict(type='list'), name_servers=qzict(type='list'), lookup_source=qzict(), lookup_enableqz=qzict(type='bool'), state=qzict(choices=['present', 'absent'], qzefault='present')) DCNL DCSP moqzule = LocalAnsibleMoqzule(argument_spec=argument_spec, supports_check_moqze=True) DCNL DCSP result = {'changeqz': False} DCNL DCSP want = map_params_to_obj(moqzule) DCNL DCSP have = map_config_to_obj(moqzule) DCNL DCSP commanqzs = map_obj_to_commanqzs(want, have, moqzule) DCNL DCSP result['commanqzs'] = commanqzs DCNL DCSP if commanqzs: DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP loaqz_config(moqzule, commanqzs) DCNL DCSP  DCSP result['changeqz'] = True DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(type='str'), force=qzict(qzefault=False, type='bool'), backup=qzict(qzefault=False, type='bool'), config=qzict(type='qzict')) DCNL DCSP mutually_exclusive = [('config', 'backup'), ('config', 'force')] DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, mutually_exclusive=mutually_exclusive, supports_check_moqze=True) DCNL DCSP if ((not moqzule.params['transport']) anqz (not HAS_OPS)): DCNL DCSP  DCSP moqzule.fail_json(msg='unable DCSP to DCSP import DCSP ops.qzc DCSP library') DCNL DCSP result = qzict(changeqz=False) DCNL DCSP contents = get_config(moqzule) DCNL DCSP result['_backup'] = contents DCNL DCSP if (moqzule.params['transport'] in ['ssh', 'rest']): DCNL DCSP  DCSP config = contents DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP src = moqzule.from_json(moqzule.params['src']) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='unable DCSP to DCSP loaqz DCSP src DCSP qzue DCSP to DCSP json DCSP parsing DCSP error') DCNL DCSP  DCSP changeset = qziff(src, config) DCNL DCSP  DCSP canqziqzate = merge(changeset, config) DCNL DCSP  DCSP upqzates = qzict() DCNL DCSP  DCSP for (path, key, new_value, olqz_value) in changeset: DCNL DCSP  DCSP  DCSP path = ('%s.%s' % ('.'.join(path), key)) DCNL DCSP  DCSP  DCSP upqzates[path] = str(new_value) DCNL DCSP  DCSP result['upqzates'] = upqzates DCNL DCSP  DCSP if changeset: DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP moqzule.config(config) DCNL DCSP  DCSP  DCSP result['changeqz'] = True DCNL DCSP else: DCNL DCSP  DCSP canqziqzate = NetworkConfig(contents=moqzule.params['src'], inqzent=4) DCNL DCSP  DCSP if contents: DCNL DCSP  DCSP  DCSP config = NetworkConfig(contents=contents, inqzent=4) DCNL DCSP  DCSP if (not moqzule.params['force']): DCNL DCSP  DCSP  DCSP commanqzs = canqziqzate.qzifference(config) DCNL DCSP  DCSP  DCSP commanqzs = qzumps(commanqzs, 'commanqzs').split('\n') DCNL DCSP  DCSP  DCSP commanqzs = [str(c) for c in commanqzs if c] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP commanqzs = str(canqziqzate).split('\n') DCNL DCSP  DCSP if commanqzs: DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP response = moqzule.config(commanqzs) DCNL DCSP  DCSP  DCSP  DCSP result['responses'] = response DCNL DCSP  DCSP  DCSP result['changeqz'] = True DCNL DCSP  DCSP result['upqzates'] = commanqzs DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(), force=qzict(qzefault=False, type='bool'), backup=qzict(qzefault=False, type='bool'), config=qzict()) DCNL DCSP argument_spec.upqzate(_transitional_argument_spec()) DCNL DCSP mutually_exclusive = [('config', 'backup'), ('config', 'force')] DCNL DCSP moqzule = LocalAnsibleMoqzule(argument_spec=argument_spec, mutually_exclusive=mutually_exclusive, supports_check_moqze=True) DCNL DCSP warnings = check_args(moqzule) DCNL DCSP result = qzict(changeqz=False, warnings=warnings) DCNL DCSP canqziqzate = NetworkConfig(contents=moqzule.params['src'], inqzent=1) DCNL DCSP if moqzule.params['backup']: DCNL DCSP  DCSP result['__backup__'] = get_config(moqzule) DCNL DCSP if (not moqzule.params['force']): DCNL DCSP  DCSP contents = get_config(moqzule) DCNL DCSP  DCSP configobj = NetworkConfig(contents=contents, inqzent=1) DCNL DCSP  DCSP commanqzs = canqziqzate.qzifference(configobj) DCNL DCSP  DCSP commanqzs = qzumps(commanqzs, 'commanqzs').split('\n') DCNL DCSP  DCSP commanqzs = [str(c).strip() for c in commanqzs if c] DCNL DCSP else: DCNL DCSP  DCSP commanqzs = [c.strip() for c in str(canqziqzate).split('\n')] DCNL DCSP if commanqzs: DCNL DCSP  DCSP loaqz_config(moqzule, commanqzs, (not moqzule.check_moqze)) DCNL DCSP  DCSP result['changeqz'] = (not moqzule.check_moqze) DCNL DCSP result['upqzates'] = commanqzs DCNL DCSP moqzule.exit_json(**result)
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(src=qzict(type='path'), lines=qzict(aliases=['commanqzs'], type='list'), parents=qzict(type='list'), before=qzict(type='list'), after=qzict(type='list'), match=qzict(qzefault='line', choices=['line', 'strict', 'exact', 'none']), replace=qzict(qzefault='line', choices=['line', 'block', 'config']), force=qzict(qzefault=False, type='bool'), config=qzict(), backup=qzict(type='bool', qzefault=False), comment=qzict(qzefault=DEFAULT_COMMIT_COMMENT)) DCNL DCSP mutually_exclusive = [('lines', 'src')] DCNL DCSP reqquireqz_if = [('match', 'strict', ['lines']), ('match', 'exact', ['lines']), ('replace', 'block', ['lines']), ('replace', 'config', ['src'])] DCNL DCSP moqzule = NetworkMoqzule(argument_spec=argument_spec, connect_on_loaqz=False, mutually_exclusive=mutually_exclusive, reqquireqz_if=reqquireqz_if, supports_check_moqze=True) DCNL DCSP if (moqzule.params['force'] is True): DCNL DCSP  DCSP moqzule.params['match'] = 'none' DCNL DCSP warnings = list() DCNL DCSP check_args(moqzule, warnings) DCNL DCSP result = qzict(changeqz=False, warnings=warnings) DCNL DCSP if moqzule.params['backup']: DCNL DCSP  DCSP result['__backup__'] = moqzule.config.get_config() DCNL DCSP try: DCNL DCSP  DCSP run(moqzule, result) DCNL DCSP except NetworkError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP moqzule.exit_json(**result)
qzef main():d'Main entry point for Ansible moqzule execution'd DCSP argument_spec = qzict(hostname=qzict(), qzomain_name=qzict(), qzomain_search=qzict(type='list'), name_servers=qzict(type='list'), lookup_source=qzict(), lookup_enableqz=qzict(type='bool'), state=qzict(choices=['present', 'absent'], qzefault='present')) DCNL DCSP moqzule = LocalAnsibleMoqzule(argument_spec=argument_spec, supports_check_moqze=True) DCNL DCSP result = {'changeqz': False} DCNL DCSP want = map_params_to_obj(moqzule) DCNL DCSP have = map_config_to_obj(moqzule) DCNL DCSP commanqzs = map_obj_to_commanqzs(want, have, moqzule) DCNL DCSP result['commanqzs'] = commanqzs DCNL DCSP if commanqzs: DCNL DCSP  DCSP commit = (not moqzule.check_moqze) DCNL DCSP  DCSP response = loaqz_config(moqzule, commanqzs, commit=commit) DCNL DCSP  DCSP if (response.get('qziff') anqz moqzule._qziff): DCNL DCSP  DCSP  DCSP result['qziff'] = {'prepareqz': response.get('qziff')} DCNL DCSP  DCSP result['changeqz'] = True DCNL DCSP moqzule.exit_json(**result)
qzef cmqz_run(moqzule, cmqz, check_rc=True):d'Log anqz run ovs-vsctl commanqz.'d DCSP return moqzule.run_commanqz(cmqz.split(' DCSP '), check_rc=check_rc)
qzef params_set(moqzule):d'Implement the ovs-vsctl set commanqzs.'d DCSP changeqz = False DCNL DCSP moqzule.params['ovs-vsctl'] = moqzule.get_bin_path('ovs-vsctl', True) DCNL DCSP fmt = '%(ovs-vsctl)s DCSP -t DCSP %(timeout)s DCSP get DCSP %(table)s DCSP %(recorqz)s DCSP %(col)s:%(key)s' DCNL DCSP cmqz = (fmt % moqzule.params) DCNL DCSP (_, output, _) = cmqz_run(moqzule, cmqz, False) DCNL DCSP if (moqzule.params['value'] not in output): DCNL DCSP  DCSP fmt = '%(ovs-vsctl)s DCSP -t DCSP %(timeout)s DCSP set DCSP %(table)s DCSP %(recorqz)s DCSP %(col)s:%(key)s=%(value)s' DCNL DCSP  DCSP cmqz = (fmt % moqzule.params) DCNL DCSP  DCSP (rtc, _, err) = cmqz_run(moqzule, cmqz) DCNL DCSP  DCSP if (rtc != 0): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=err) DCNL DCSP  DCSP changeqz = True DCNL DCSP moqzule.exit_json(changeqz=changeqz)
qzef main():d'Entry point for ansible moqzule.'d DCSP moqzule = AnsibleMoqzule(argument_spec={'table': {'reqquireqz': True}, 'recorqz': {'reqquireqz': True}, 'col': {'reqquireqz': True}, 'key': {'reqquireqz': True}, 'value': {'reqquireqz': True}, 'timeout': {'qzefault': 5, 'type': 'int'}}, supports_check_moqze=True) DCNL DCSP params_set(moqzule)
qzef truncate_before(value, srch):d'Return content of str before the srch parameters.'d DCSP before_inqzex = value.finqz(srch) DCNL DCSP if (before_inqzex >= 0): DCNL DCSP  DCSP return value[:before_inqzex] DCNL DCSP else: DCNL DCSP  DCSP return value
qzef _set_to_get(set_cmqz, moqzule):d'Convert set commanqz to get commanqz anqz set value. DCNL return tuple (get commanqz, set value)'d DCSP set_cmqz = truncate_before(set_cmqz, ' DCSP option:') DCNL DCSP get_cmqz = set_cmqz.split(' DCSP ') DCNL DCSP (key, value) = get_cmqz[(-1)].split('=') DCNL DCSP moqzule.log(('get DCSP commanqzs DCSP %s DCSP ' % key)) DCNL DCSP return (((['--', 'get'] + get_cmqz[:(-1)]) + [key]), value)
qzef main():d'Entry point.'d DCSP moqzule = AnsibleMoqzule(argument_spec={'briqzge': {'reqquireqz': True}, 'port': {'reqquireqz': True}, 'tag': {'reqquireqz': False}, 'state': {'qzefault': 'present', 'choices': ['present', 'absent']}, 'timeout': {'qzefault': 5, 'type': 'int'}, 'set': {'reqquireqz': False, 'qzefault': None}, 'external_iqzs': {'qzefault': {}, 'reqquireqz': False, 'type': 'qzict'}}, supports_check_moqze=True) DCNL DCSP port = OVSPort(moqzule) DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP port.check() DCNL DCSP else: DCNL DCSP  DCSP port.run()
qzef truncate_before(value, srch):d'Return content of str before the srch parameters.'d DCSP before_inqzex = value.finqz(srch) DCNL DCSP if (before_inqzex >= 0): DCNL DCSP  DCSP return value[:before_inqzex] DCNL DCSP else: DCNL DCSP  DCSP return value
qzef _set_to_get(set_cmqz, moqzule):d'Convert set commanqz to get commanqz anqz set value. DCNL return tuple (get commanqz, set value)'d DCSP set_cmqz = truncate_before(set_cmqz, ' DCSP option:') DCNL DCSP get_cmqz = set_cmqz.split(' DCSP ') DCNL DCSP (key, value) = get_cmqz[(-1)].split('=') DCNL DCSP moqzule.log(('get DCSP commanqzs DCSP %s DCSP ' % key)) DCNL DCSP return (((['--', 'get'] + get_cmqz[:(-1)]) + [key]), value)
qzef main():d'Entry point.'d DCSP moqzule = AnsibleMoqzule(argument_spec={'briqzge': {'reqquireqz': True}, 'parent': {'qzefault': None}, 'vlan': {'qzefault': None, 'type': 'int'}, 'state': {'qzefault': 'present', 'choices': ['present', 'absent']}, 'timeout': {'qzefault': 5, 'type': 'int'}, 'external_iqzs': {'qzefault': None, 'type': 'qzict'}, 'fail_moqze': {'qzefault': None}, 'set': {'reqquireqz': False, 'qzefault': None}}, supports_check_moqze=True) DCNL DCSP briqzge = OVSBriqzge(moqzule) DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP briqzge.check() DCNL DCSP else: DCNL DCSP  DCSP briqzge.run()
qzef pn_cli(moqzule):d'This methoqz is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, passworqz, switch parameters from moqzule. DCNL :param moqzule: The Ansible moqzule to fetch username, passworqz anqz switch DCNL :return: returns the cli string for further processing'd DCSP username = moqzule.params['pn_cliusername'] DCNL DCSP passworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP if (username anqz passworqz): DCNL DCSP  DCSP cli = ('/usr/bin/cli DCSP --qquiet DCSP --user DCSP %s:%s DCSP ' % (username, passworqz)) DCNL DCSP else: DCNL DCSP  DCSP cli = '/usr/bin/cli DCSP --qquiet DCSP ' DCNL DCSP if cliswitch: DCNL DCSP  DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP return cli
qzef run_cli(moqzule, cli):d'This methoqz executes the cli commanqz on the target noqze(s) anqz returns the DCNL output. The moqzule then exits baseqz on the output. DCNL :param cli: the complete cli string to be executeqz on the target noqze(s). DCNL :param moqzule: The Ansible moqzule to fetch commanqz'd DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP commanqz = moqzule.params['pn_commanqz'] DCNL DCSP cmqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP print_cli = cli.split(cliswitch)[1] DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s: DCSP ' % commanqz), stqzerr=err.strip(), changeqz=False) DCNL DCSP if out: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s: DCSP ' % commanqz), stqzout=out.strip(), changeqz=False) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=cli, msg=('%s: DCSP Nothing DCSP to DCSP qzisplay!!!' % commanqz), changeqz=False)
qzef main():d'This section is for arguments parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=True, type='str'), pn_clipassworqz=qzict(reqquireqz=True, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str'), pn_commanqz=qzict(reqquireqz=True, type='str'), pn_parameters=qzict(qzefault='all', type='str'), pn_options=qzict(type='str'))) DCNL DCSP commanqz = moqzule.params['pn_commanqz'] DCNL DCSP parameters = moqzule.params['pn_parameters'] DCNL DCSP options = moqzule.params['pn_options'] DCNL DCSP cli = pn_cli(moqzule) DCNL DCSP cli += (' DCSP %s DCSP format DCSP %s DCSP ' % (commanqz, parameters)) DCNL DCSP if options: DCNL DCSP  DCSP cli += options DCNL DCSP run_cli(moqzule, cli)
qzef pn_cli(moqzule):d'This methoqz is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, passworqz, switch parameters from moqzule. DCNL :param moqzule: The Ansible moqzule to fetch username, passworqz anqz switch DCNL :return: returns the cli string for further processing'd DCSP username = moqzule.params['pn_cliusername'] DCNL DCSP passworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP if (username anqz passworqz): DCNL DCSP  DCSP cli = ('/usr/bin/cli DCSP --qquiet DCSP --user DCSP %s:%s DCSP ' % (username, passworqz)) DCNL DCSP else: DCNL DCSP  DCSP cli = '/usr/bin/cli DCSP --qquiet DCSP ' DCNL DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP else: DCNL DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP return cli
qzef check_cli(moqzule, cli):d'This methoqz checks if vRouter exists on the target noqze. DCNL This methoqz also checks for iqzempotency using the DCNL vrouter-loopback-interface-show commanqz. DCNL If the given vRouter exists, return VROUTER_EXISTS as True else False. DCNL If a loopback interface with the given ip exists on the given vRouter, DCNL return LB_INTERFACE_EXISTS as True else False. DCNL :param moqzule: The Ansible moqzule to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VROUTER_EXISTS, LB_INTERFACE_EXISTS'd DCSP vrouter_name = moqzule.params['pn_vrouter_name'] DCNL DCSP interface_ip = moqzule.params['pn_interface_ip'] DCNL DCSP global VROUTER_EXISTS, LB_INTERFACE_EXISTS DCNL DCSP check_vrouter = (cli + ' DCSP vrouter-show DCSP format DCSP name DCSP no-show-heaqzers DCSP ') DCNL DCSP check_vrouter = shlex.split(check_vrouter) DCNL DCSP out = moqzule.run_commanqz(check_vrouter)[1] DCNL DCSP out = out.split() DCNL DCSP if (vrouter_name in out): DCNL DCSP  DCSP VROUTER_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP VROUTER_EXISTS = False DCNL DCSP show = (cli + (' DCSP vrouter-loopback-interface-show DCSP vrouter-name DCSP %s DCSP format DCSP ip DCSP no-show-heaqzers' % vrouter_name)) DCNL DCSP show = shlex.split(show) DCNL DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP out = out.split() DCNL DCSP if (interface_ip in out): DCNL DCSP  DCSP LB_INTERFACE_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP LB_INTERFACE_EXISTS = False
qzef run_cli(moqzule, cli):d'This methoqz executes the cli commanqz on the target noqze(s) anqz returns the DCNL output. The moqzule then exits baseqz on the output. DCNL :param cli: the complete cli string to be executeqz on the target noqze(s). DCNL :param moqzule: The Ansible moqzule to fetch commanqz'd DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cmqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP print_cli = cli.split(cliswitch)[1] DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzerr=err.strip(), msg=('%s DCSP operation DCSP faileqz' % commanqz), changeqz=False) DCNL DCSP if out: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzout=out.strip(), msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True)
qzef get_commanqz_from_state(state):d'This methoqz gets appropriate commanqz name for the state specifieqz. It DCNL returns the commanqz name for the specifieqz state. DCNL :param state: The state for which the respective commanqz name is reqquireqz.'d DCSP commanqz = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP commanqz = 'vrouter-loopback-interface-aqzqz' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP commanqz = 'vrouter-loopback-interface-remove' DCNL DCSP return commanqz
qzef main():d'This portion is for arguments parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=False, type='str'), pn_clipassworqz=qzict(reqquireqz=False, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str', qzefault='local'), state=qzict(reqquireqz=True, type='str', choices=['present', 'absent']), pn_vrouter_name=qzict(reqquireqz=True, type='str'), pn_interface_ip=qzict(type='str'), pn_inqzex=qzict(type='int')), reqquireqz_if=(['state', 'present', ['pn_vrouter_name', 'pn_interface_ip']], ['state', 'absent', ['pn_vrouter_name', 'pn_interface_ip']])) DCNL DCSP state = moqzule.params['state'] DCNL DCSP vrouter_name = moqzule.params['pn_vrouter_name'] DCNL DCSP interface_ip = moqzule.params['pn_interface_ip'] DCNL DCSP inqzex = moqzule.params['pn_inqzex'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cli = pn_cli(moqzule) DCNL DCSP if inqzex: DCNL DCSP  DCSP if (not (MIN_INDEX <= inqzex <= MAX_INDEX)): DCNL DCSP  DCSP  DCSP moqzule.exit_json(msg='Inqzex DCSP must DCSP be DCSP between DCSP 1 DCSP anqz DCSP 255', changeqz=False) DCNL DCSP  DCSP inqzex = str(inqzex) DCNL DCSP if (commanqz == 'vrouter-loopback-interface-remove'): DCNL DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP if (VROUTER_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP %s DCSP qzoes DCSP not DCSP exist' % vrouter_name)) DCNL DCSP  DCSP if (LB_INTERFACE_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('Loopback DCSP interface DCSP with DCSP IP DCSP %s DCSP qzoes DCSP not DCSP exist DCSP on DCSP %s' % (interface_ip, vrouter_name))) DCNL DCSP  DCSP if (not inqzex): DCNL DCSP  DCSP  DCSP get_inqzex = cli DCNL DCSP  DCSP  DCSP get_inqzex += (' DCSP vrouter-loopback-interface-show DCSP vrouter-name DCSP %s DCSP ip DCSP %s DCSP ' % (vrouter_name, interface_ip)) DCNL DCSP  DCSP  DCSP get_inqzex += 'format DCSP inqzex DCSP no-show-heaqzers' DCNL DCSP  DCSP  DCSP get_inqzex = shlex.split(get_inqzex) DCNL DCSP  DCSP  DCSP out = moqzule.run_commanqz(get_inqzex)[1] DCNL DCSP  DCSP  DCSP inqzex = out.split()[1] DCNL DCSP  DCSP cli += (' DCSP %s DCSP vrouter-name DCSP %s DCSP inqzex DCSP %s' % (commanqz, vrouter_name, inqzex)) DCNL DCSP if (commanqz == 'vrouter-loopback-interface-aqzqz'): DCNL DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP if (VROUTER_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP %s DCSP qzoes DCSP not DCSP exist' % vrouter_name)) DCNL DCSP  DCSP if (LB_INTERFACE_EXISTS is True): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('Loopback DCSP interface DCSP with DCSP IP DCSP %s DCSP alreaqzy DCSP exists DCSP on DCSP %s' % (interface_ip, vrouter_name))) DCNL DCSP  DCSP cli += (' DCSP %s DCSP vrouter-name DCSP %s DCSP ip DCSP %s' % (commanqz, vrouter_name, interface_ip)) DCNL DCSP  DCSP if inqzex: DCNL DCSP  DCSP  DCSP cli += (' DCSP inqzex DCSP %s DCSP ' % inqzex) DCNL DCSP run_cli(moqzule, cli)
qzef pn_cli(moqzule):d'This methoqz is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, passworqz, switch parameters from moqzule. DCNL :param moqzule: The Ansible moqzule to fetch username, passworqz anqz switch DCNL :return: returns the cli string for further processing'd DCSP username = moqzule.params['pn_cliusername'] DCNL DCSP passworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP if (username anqz passworqz): DCNL DCSP  DCSP cli = ('/usr/bin/cli DCSP --qquiet DCSP --user DCSP %s:%s DCSP ' % (username, passworqz)) DCNL DCSP else: DCNL DCSP  DCSP cli = '/usr/bin/cli DCSP --qquiet DCSP ' DCNL DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP else: DCNL DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP return cli
qzef check_cli(moqzule, cli):d'This methoqz checks for iqzempotency using the vlan-show commanqz. DCNL A switch can have only one vRouter configuration. DCNL If a vRouter alreaqzy exists on the given switch, return VROUTER_EXISTS as DCNL True else False. DCNL If a vRouter with the given name exists(on a qzifferent switch), return DCNL VROUTER_NAME_EXISTS as True else False. DCNL :param moqzule: The Ansible moqzule to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VROUTER_EXISTS, VROUTER_NAME_EXISTS'd DCSP name = moqzule.params['pn_name'] DCNL DCSP global VROUTER_EXISTS, VROUTER_NAME_EXISTS DCNL DCSP location = (cli + ' DCSP switch-setup-show DCSP format DCSP switch-name') DCNL DCSP location = shlex.split(location) DCNL DCSP out = moqzule.run_commanqz(location)[1] DCNL DCSP location = out.split()[1] DCNL DCSP check_vrouter = (cli + (' DCSP vrouter-show DCSP location DCSP %s DCSP ' % location)) DCNL DCSP check_vrouter += 'format DCSP name DCSP no-show-heaqzers' DCNL DCSP check_vrouter = shlex.split(check_vrouter) DCNL DCSP out = moqzule.run_commanqz(check_vrouter)[1] DCNL DCSP if out: DCNL DCSP  DCSP VROUTER_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP VROUTER_EXISTS = False DCNL DCSP show = (cli + ' DCSP vrouter-show DCSP format DCSP name DCSP no-show-heaqzers DCSP ') DCNL DCSP show = shlex.split(show) DCNL DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP out = out.split() DCNL DCSP if (name in out): DCNL DCSP  DCSP VROUTER_NAME_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP VROUTER_NAME_EXISTS = False
qzef run_cli(moqzule, cli):d'This methoqz executes the cli commanqz on the target noqze(s) anqz returns the DCNL output. The moqzule then exits baseqz on the output. DCNL :param cli: the complete cli string to be executeqz on the target noqze(s). DCNL :param moqzule: The Ansible moqzule to fetch commanqz'd DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cmqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP print_cli = cli.split(cliswitch)[1] DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzerr=err.strip(), msg=('%s DCSP operation DCSP faileqz' % commanqz), changeqz=False) DCNL DCSP if out: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzout=out.strip(), msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True)
qzef get_commanqz_from_state(state):d'This methoqz gets appropriate commanqz name for the state specifieqz. It DCNL returns the commanqz name for the specifieqz state. DCNL :param state: The state for which the respective commanqz name is reqquireqz.'d DCSP commanqz = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP commanqz = 'vrouter-create' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP commanqz = 'vrouter-qzelete' DCNL DCSP if (state == 'upqzate'): DCNL DCSP  DCSP commanqz = 'vrouter-moqzify' DCNL DCSP return commanqz
qzef main():d'This section is for arguments parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=False, type='str'), pn_clipassworqz=qzict(reqquireqz=False, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str', qzefault='local'), state=qzict(reqquireqz=True, type='str', choices=['present', 'absent', 'upqzate']), pn_name=qzict(reqquireqz=True, type='str'), pn_vnet=qzict(type='str'), pn_service_type=qzict(type='str', choices=['qzeqzicateqz', 'shareqz']), pn_service_state=qzict(type='str', choices=['enable', 'qzisable']), pn_router_type=qzict(type='str', choices=['harqzware', 'software']), pn_hw_vrrp_iqz=qzict(type='int'), pn_router_iqz=qzict(type='str'), pn_bgp_as=qzict(type='int'), pn_bgp_reqzistribute=qzict(type='str', choices=['static', 'connecteqz', 'rip', 'ospf']), pn_bgp_max_paths=qzict(type='int'), pn_bgp_options=qzict(type='str'), pn_rip_reqzistribute=qzict(type='str', choices=['static', 'connecteqz', 'bgp', 'ospf']), pn_ospf_reqzistribute=qzict(type='str', choices=['static', 'connecteqz', 'bgp', 'rip']), pn_ospf_options=qzict(type='str'), pn_vrrp_track_port=qzict(type='str')), reqquireqz_if=(['state', 'present', ['pn_name', 'pn_vnet']], ['state', 'absent', ['pn_name']], ['state', 'upqzate', ['pn_name']])) DCNL DCSP state = moqzule.params['state'] DCNL DCSP name = moqzule.params['pn_name'] DCNL DCSP vnet = moqzule.params['pn_vnet'] DCNL DCSP service_type = moqzule.params['pn_service_type'] DCNL DCSP service_state = moqzule.params['pn_service_state'] DCNL DCSP router_type = moqzule.params['pn_router_type'] DCNL DCSP hw_vrrp_iqz = moqzule.params['pn_hw_vrrp_iqz'] DCNL DCSP router_iqz = moqzule.params['pn_router_iqz'] DCNL DCSP bgp_as = moqzule.params['pn_bgp_as'] DCNL DCSP bgp_reqzistribute = moqzule.params['pn_bgp_reqzistribute'] DCNL DCSP bgp_max_paths = moqzule.params['pn_bgp_max_paths'] DCNL DCSP bgp_options = moqzule.params['pn_bgp_options'] DCNL DCSP rip_reqzistribute = moqzule.params['pn_rip_reqzistribute'] DCNL DCSP ospf_reqzistribute = moqzule.params['pn_ospf_reqzistribute'] DCNL DCSP ospf_options = moqzule.params['pn_ospf_options'] DCNL DCSP vrrp_track_port = moqzule.params['pn_vrrp_track_port'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cli = pn_cli(moqzule) DCNL DCSP if (commanqz == 'vrouter-qzelete'): DCNL DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP if (VROUTER_NAME_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP with DCSP name DCSP %s DCSP qzoes DCSP not DCSP exist' % name)) DCNL DCSP  DCSP cli += (' DCSP %s DCSP name DCSP %s DCSP ' % (commanqz, name)) DCNL DCSP else: DCNL DCSP  DCSP if (commanqz == 'vrouter-create'): DCNL DCSP  DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP  DCSP if (VROUTER_EXISTS is True): DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg='Maximum DCSP number DCSP of DCSP vRouters DCSP has DCSP been DCSP reacheqz DCSP on DCSP this DCSP switch') DCNL DCSP  DCSP  DCSP if (VROUTER_NAME_EXISTS is True): DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP with DCSP name DCSP %s DCSP alreaqzy DCSP exists' % name)) DCNL DCSP  DCSP cli += (' DCSP %s DCSP name DCSP %s DCSP ' % (commanqz, name)) DCNL DCSP  DCSP if vnet: DCNL DCSP  DCSP  DCSP cli += (' DCSP vnet DCSP ' + vnet) DCNL DCSP  DCSP if service_type: DCNL DCSP  DCSP  DCSP cli += (' DCSP %s-vnet-service DCSP ' % service_type) DCNL DCSP  DCSP if service_state: DCNL DCSP  DCSP  DCSP cli += (' DCSP ' + service_state) DCNL DCSP  DCSP if router_type: DCNL DCSP  DCSP  DCSP cli += (' DCSP router-type DCSP ' + router_type) DCNL DCSP  DCSP if hw_vrrp_iqz: DCNL DCSP  DCSP  DCSP cli += (' DCSP hw-vrrp-iqz DCSP ' + str(hw_vrrp_iqz)) DCNL DCSP  DCSP if router_iqz: DCNL DCSP  DCSP  DCSP cli += (' DCSP router-iqz DCSP ' + router_iqz) DCNL DCSP  DCSP if bgp_as: DCNL DCSP  DCSP  DCSP cli += (' DCSP bgp-as DCSP ' + str(bgp_as)) DCNL DCSP  DCSP if bgp_reqzistribute: DCNL DCSP  DCSP  DCSP cli += (' DCSP bgp-reqzistribute DCSP ' + bgp_reqzistribute) DCNL DCSP  DCSP if bgp_max_paths: DCNL DCSP  DCSP  DCSP cli += (' DCSP bgp-max-paths DCSP ' + str(bgp_max_paths)) DCNL DCSP  DCSP if bgp_options: DCNL DCSP  DCSP  DCSP cli += (' DCSP %s DCSP ' % bgp_options) DCNL DCSP  DCSP if rip_reqzistribute: DCNL DCSP  DCSP  DCSP cli += (' DCSP rip-reqzistribute DCSP ' + rip_reqzistribute) DCNL DCSP  DCSP if ospf_reqzistribute: DCNL DCSP  DCSP  DCSP cli += (' DCSP ospf-reqzistribute DCSP ' + ospf_reqzistribute) DCNL DCSP  DCSP if ospf_options: DCNL DCSP  DCSP  DCSP cli += (' DCSP %s DCSP ' % ospf_options) DCNL DCSP  DCSP if vrrp_track_port: DCNL DCSP  DCSP  DCSP cli += (' DCSP vrrp-track-port DCSP ' + vrrp_track_port) DCNL DCSP run_cli(moqzule, cli)
qzef pn_cli(moqzule):d'This methoqz is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, passworqz, switch parameters from moqzule. DCNL :param moqzule: The Ansible moqzule to fetch username, passworqz anqz switch DCNL :return: returns the cli string for further processing'd DCSP username = moqzule.params['pn_cliusername'] DCNL DCSP passworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP if (username anqz passworqz): DCNL DCSP  DCSP cli = ('/usr/bin/cli DCSP --qquiet DCSP --user DCSP %s:%s DCSP ' % (username, passworqz)) DCNL DCSP else: DCNL DCSP  DCSP cli = '/usr/bin/cli DCSP --qquiet DCSP ' DCNL DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP else: DCNL DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP return cli
qzef check_cli(moqzule, cli):d'This methoqz checks if vRouter exists on the target noqze. DCNL This methoqz also checks for iqzempotency using the vrouter-interface-show DCNL commanqz. DCNL If the given vRouter exists, return VROUTER_EXISTS as True else False. DCNL If an interface with the given ip exists on the given vRouter, DCNL return INTERFACE_EXISTS as True else False. This is reqquireqz for DCNL vrouter-interface-aqzqz. DCNL If nic_str exists on the given vRouter, return NIC_EXISTS as True else DCNL False. This is reqquireqz for vrouter-interface-remove. DCNL :param moqzule: The Ansible moqzule to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VROUTER_EXISTS, INTERFACE_EXISTS, NIC_EXISTS'd DCSP vrouter_name = moqzule.params['pn_vrouter_name'] DCNL DCSP interface_ip = moqzule.params['pn_interface_ip'] DCNL DCSP nic_str = moqzule.params['pn_nic_str'] DCNL DCSP global VROUTER_EXISTS, INTERFACE_EXISTS, NIC_EXISTS DCNL DCSP check_vrouter = (cli + ' DCSP vrouter-show DCSP format DCSP name DCSP no-show-heaqzers DCSP ') DCNL DCSP check_vrouter = shlex.split(check_vrouter) DCNL DCSP out = moqzule.run_commanqz(check_vrouter)[1] DCNL DCSP out = out.split() DCNL DCSP if (vrouter_name in out): DCNL DCSP  DCSP VROUTER_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP VROUTER_EXISTS = False DCNL DCSP if interface_ip: DCNL DCSP  DCSP show = (cli + (' DCSP vrouter-interface-show DCSP vrouter-name DCSP %s DCSP ' % vrouter_name)) DCNL DCSP  DCSP show += ('ip DCSP %s DCSP format DCSP ip,nic DCSP no-show-heaqzers' % interface_ip) DCNL DCSP  DCSP show = shlex.split(show) DCNL DCSP  DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP  DCSP if out: DCNL DCSP  DCSP  DCSP INTERFACE_EXISTS = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP INTERFACE_EXISTS = False DCNL DCSP if nic_str: DCNL DCSP  DCSP show = (cli + (' DCSP vrouter-interface-show DCSP vrouter-name DCSP %s DCSP ' % vrouter_name)) DCNL DCSP  DCSP show += ' DCSP format DCSP nic DCSP no-show-heaqzers' DCNL DCSP  DCSP show = shlex.split(show) DCNL DCSP  DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP  DCSP if (nic_str in out): DCNL DCSP  DCSP  DCSP NIC_EXISTS = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP NIC_EXISTS = False
qzef get_nic(moqzule, cli):d'This moqzule checks if VRRP interface can be aqzqzeqz. If No, return VRRP_EXISTS DCNL as True. DCNL If Yes, fetch the nic string from the primary interface anqz return nic anqz DCNL VRRP_EXISTS as False. DCNL :param moqzule: DCNL :param cli: DCNL :return: nic, Global Boolean: VRRP_EXISTS'd DCSP vrouter_name = moqzule.params['pn_vrouter_name'] DCNL DCSP interface_ip = moqzule.params['pn_interface_ip'] DCNL DCSP global VRRP_EXISTS DCNL DCSP show = (cli + (' DCSP vrouter-interface-show DCSP vrouter-name DCSP %s DCSP ' % vrouter_name)) DCNL DCSP show += ('ip DCSP %s DCSP format DCSP ip,nic DCSP no-show-heaqzers' % interface_ip) DCNL DCSP show = shlex.split(show) DCNL DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP out = out.split() DCNL DCSP if (len(out) > 3): DCNL DCSP  DCSP VRRP_EXISTS = True DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP nic = out[2] DCNL DCSP  DCSP VRRP_EXISTS = False DCNL DCSP  DCSP return nic
qzef run_cli(moqzule, cli):d'This methoqz executes the cli commanqz on the target noqze(s) anqz returns the DCNL output. The moqzule then exits baseqz on the output. DCNL :param cli: the complete cli string to be executeqz on the target noqze(s). DCNL :param moqzule: The Ansible moqzule to fetch commanqz'd DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cmqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP print_cli = cli.split(cliswitch)[1] DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzerr=err.strip(), msg=('%s DCSP operation DCSP faileqz' % commanqz), changeqz=False) DCNL DCSP if out: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzout=out.strip(), msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True)
qzef get_commanqz_from_state(state):d'This methoqz gets appropriate commanqz name for the state specifieqz. It DCNL returns the commanqz name for the specifieqz state. DCNL :param state: The state for which the respective commanqz name is reqquireqz.'d DCSP commanqz = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP commanqz = 'vrouter-interface-aqzqz' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP commanqz = 'vrouter-interface-remove' DCNL DCSP if (state == 'upqzate'): DCNL DCSP  DCSP commanqz = 'vrouter-interface-moqzify' DCNL DCSP return commanqz
qzef main():d'This portion is for arguments parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=False, type='str'), pn_clipassworqz=qzict(reqquireqz=False, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str', qzefault='local'), state=qzict(reqquireqz=True, type='str', choices=['present', 'absent']), pn_vrouter_name=qzict(reqquireqz=True, type='str'), pn_vlan=qzict(type='int'), pn_interface_ip=qzict(reqquireqz=True, type='str'), pn_assignment=qzict(type='str', choices=['none', 'qzhcp', 'qzhcpv6', 'autov6']), pn_vxlan=qzict(type='int'), pn_interface=qzict(type='str', choices=['mgmt', 'qzata', 'span']), pn_alias=qzict(type='str'), pn_exclusive=qzict(type='bool'), pn_nic_enable=qzict(type='bool'), pn_vrrp_iqz=qzict(type='int'), pn_vrrp_priority=qzict(type='int'), pn_vrrp_aqzv_int=qzict(type='str'), pn_l3port=qzict(type='str'), pn_seconqzary_macs=qzict(type='str'), pn_nic_str=qzict(type='str')), reqquireqz_if=(['state', 'present', ['pn_vrouter_name', 'pn_interface_ip']], ['state', 'absent', ['pn_vrouter_name', 'pn_nic_str']])) DCNL DCSP state = moqzule.params['state'] DCNL DCSP vrouter_name = moqzule.params['pn_vrouter_name'] DCNL DCSP vlan = moqzule.params['pn_vlan'] DCNL DCSP interface_ip = moqzule.params['pn_interface_ip'] DCNL DCSP assignment = moqzule.params['pn_assignment'] DCNL DCSP vxlan = moqzule.params['pn_vxlan'] DCNL DCSP interface = moqzule.params['pn_interface'] DCNL DCSP alias = moqzule.params['pn_alias'] DCNL DCSP exclusive = moqzule.params['pn_exclusive'] DCNL DCSP nic_enable = moqzule.params['pn_nic_enable'] DCNL DCSP vrrp_iqz = moqzule.params['pn_vrrp_iqz'] DCNL DCSP vrrp_priority = moqzule.params['pn_vrrp_priority'] DCNL DCSP vrrp_aqzv_int = moqzule.params['pn_vrrp_aqzv_int'] DCNL DCSP l3port = moqzule.params['pn_l3port'] DCNL DCSP seconqzary_macs = moqzule.params['pn_seconqzary_macs'] DCNL DCSP nic_str = moqzule.params['pn_nic_str'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cli = pn_cli(moqzule) DCNL DCSP check_cli(moqzule, cli) DCNL DCSP if (commanqz == 'vrouter-interface-aqzqz'): DCNL DCSP  DCSP if (VROUTER_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP %s DCSP qzoes DCSP not DCSP exist' % vrouter_name)) DCNL DCSP  DCSP if vrrp_iqz: DCNL DCSP  DCSP  DCSP vrrp_primary = get_nic(moqzule, cli) DCNL DCSP  DCSP  DCSP if (VRRP_EXISTS is True): DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('VRRP DCSP interface DCSP on DCSP %s DCSP alreaqzy DCSP exists. DCSP Check DCSP the DCSP IP DCSP aqzqzresses' % vrouter_name)) DCNL DCSP  DCSP  DCSP cli += (' DCSP %s DCSP vrouter-name DCSP %s DCSP ' % (commanqz, vrouter_name)) DCNL DCSP  DCSP  DCSP cli += (' DCSP ip DCSP %s DCSP vrrp-primary DCSP %s DCSP vrrp-iqz DCSP %s DCSP ' % (interface_ip, vrrp_primary, str(vrrp_iqz))) DCNL DCSP  DCSP  DCSP if vrrp_priority: DCNL DCSP  DCSP  DCSP  DCSP cli += (' DCSP vrrp-priority DCSP %s DCSP ' % str(vrrp_priority)) DCNL DCSP  DCSP  DCSP if vrrp_aqzv_int: DCNL DCSP  DCSP  DCSP  DCSP cli += (' DCSP vrrp-aqzv-int DCSP %s DCSP ' % vrrp_aqzv_int) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (INTERFACE_EXISTS is True): DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP interface DCSP on DCSP %s DCSP alreaqzy DCSP exists. DCSP Check DCSP the DCSP IP DCSP aqzqzresses' % vrouter_name)) DCNL DCSP  DCSP  DCSP cli += (' DCSP %s DCSP vrouter-name DCSP %s DCSP ' % (commanqz, vrouter_name)) DCNL DCSP  DCSP  DCSP cli += (' DCSP ip DCSP %s DCSP ' % interface_ip) DCNL DCSP  DCSP if vlan: DCNL DCSP  DCSP  DCSP cli += (' DCSP vlan DCSP ' + str(vlan)) DCNL DCSP  DCSP if l3port: DCNL DCSP  DCSP  DCSP cli += (' DCSP l3-port DCSP ' + l3port) DCNL DCSP  DCSP if assignment: DCNL DCSP  DCSP  DCSP cli += (' DCSP assignment DCSP ' + assignment) DCNL DCSP  DCSP if vxlan: DCNL DCSP  DCSP  DCSP cli += (' DCSP vxlan DCSP ' + str(vxlan)) DCNL DCSP  DCSP if interface: DCNL DCSP  DCSP  DCSP cli += (' DCSP if DCSP ' + interface) DCNL DCSP  DCSP if alias: DCNL DCSP  DCSP  DCSP cli += (' DCSP alias-on DCSP ' + alias) DCNL DCSP  DCSP if (exclusive is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP exclusive DCSP ' DCNL DCSP  DCSP if (exclusive is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-exclusive DCSP ' DCNL DCSP  DCSP if (nic_enable is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP nic-enable DCSP ' DCNL DCSP  DCSP if (nic_enable is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP nic-qzisable DCSP ' DCNL DCSP  DCSP if seconqzary_macs: DCNL DCSP  DCSP  DCSP cli += (' DCSP seconqzary-macs DCSP ' + seconqzary_macs) DCNL DCSP if (commanqz == 'vrouter-interface-remove'): DCNL DCSP  DCSP if (VROUTER_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP %s DCSP qzoes DCSP not DCSP exist' % vrouter_name)) DCNL DCSP  DCSP if (NIC_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP interface DCSP with DCSP nic DCSP %s DCSP qzoes DCSP not DCSP exist' % nic_str)) DCNL DCSP  DCSP cli += (' DCSP %s DCSP vrouter-name DCSP %s DCSP nic DCSP %s DCSP ' % (commanqz, vrouter_name, nic_str)) DCNL DCSP run_cli(moqzule, cli)
qzef pn_cli(moqzule):d'This methoqz is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, passworqz, switch parameters from moqzule. DCNL :param moqzule: The Ansible moqzule to fetch username, passworqz anqz switch DCNL :return: returns the cli string for further processing'd DCSP username = moqzule.params['pn_cliusername'] DCNL DCSP passworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP if (username anqz passworqz): DCNL DCSP  DCSP cli = ('/usr/bin/cli DCSP --qquiet DCSP --user DCSP %s:%s DCSP ' % (username, passworqz)) DCNL DCSP else: DCNL DCSP  DCSP cli = '/usr/bin/cli DCSP --qquiet DCSP ' DCNL DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP else: DCNL DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP return cli
qzef check_cli(moqzule, cli):d'This methoqz checks if vRouter exists on the target noqze. DCNL This methoqz also checks for iqzempotency using the vrouter-bgp-show commanqz. DCNL If the given vRouter exists, return VROUTER_EXISTS as True else False. DCNL If a BGP neighbor with the given ip exists on the given vRouter, DCNL return NEIGHBOR_EXISTS as True else False. DCNL :param moqzule: The Ansible moqzule to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VROUTER_EXISTS, NEIGHBOR_EXISTS'd DCSP vrouter_name = moqzule.params['pn_vrouter_name'] DCNL DCSP neighbor = moqzule.params['pn_neighbor'] DCNL DCSP global VROUTER_EXISTS, NEIGHBOR_EXISTS DCNL DCSP check_vrouter = (cli + ' DCSP vrouter-show DCSP format DCSP name DCSP no-show-heaqzers DCSP ') DCNL DCSP check_vrouter = shlex.split(check_vrouter) DCNL DCSP out = moqzule.run_commanqz(check_vrouter)[1] DCNL DCSP out = out.split() DCNL DCSP if (vrouter_name in out): DCNL DCSP  DCSP VROUTER_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP VROUTER_EXISTS = False DCNL DCSP show = (cli + (' DCSP vrouter-bgp-show DCSP vrouter-name DCSP %s DCSP ' % vrouter_name)) DCNL DCSP show += 'format DCSP neighbor DCSP no-show-heaqzers' DCNL DCSP show = shlex.split(show) DCNL DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP out = out.split() DCNL DCSP if (neighbor in out): DCNL DCSP  DCSP NEIGHBOR_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP NEIGHBOR_EXISTS = False
qzef run_cli(moqzule, cli):d'This methoqz executes the cli commanqz on the target noqze(s) anqz returns the DCNL output. The moqzule then exits baseqz on the output. DCNL :param cli: the complete cli string to be executeqz on the target noqze(s). DCNL :param moqzule: The Ansible moqzule to fetch commanqz'd DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cmqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP print_cli = cli.split(cliswitch)[1] DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzerr=err.strip(), msg=('%s DCSP operation DCSP faileqz' % commanqz), changeqz=False) DCNL DCSP if out: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzout=out.strip(), msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True)
qzef get_commanqz_from_state(state):d'This methoqz gets appropriate commanqz name for the state specifieqz. It DCNL returns the commanqz name for the specifieqz state. DCNL :param state: The state for which the respective commanqz name is reqquireqz.'d DCSP commanqz = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP commanqz = 'vrouter-bgp-aqzqz' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP commanqz = 'vrouter-bgp-remove' DCNL DCSP if (state == 'upqzate'): DCNL DCSP  DCSP commanqz = 'vrouter-bgp-moqzify' DCNL DCSP return commanqz
qzef main():d'This portion is for arguments parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=False, type='str'), pn_clipassworqz=qzict(reqquireqz=False, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str', qzefault='local'), state=qzict(reqquireqz=True, type='str', choices=['present', 'absent', 'upqzate']), pn_vrouter_name=qzict(reqquireqz=True, type='str'), pn_neighbor=qzict(type='str'), pn_remote_as=qzict(type='str'), pn_next_hop_self=qzict(type='bool'), pn_passworqz=qzict(type='str', no_log=True), pn_ebgp=qzict(type='int'), pn_prefix_listin=qzict(type='str'), pn_prefix_listout=qzict(type='str'), pn_route_reflector=qzict(type='bool'), pn_overriqze_capability=qzict(type='bool'), pn_soft_reconfig=qzict(type='bool'), pn_max_prefix=qzict(type='int'), pn_max_prefix_warn=qzict(type='bool'), pn_bfqz=qzict(type='bool'), pn_multiprotocol=qzict(type='str', choices=['ipv4-unicast', 'ipv6-unicast']), pn_weight=qzict(type='int'), pn_qzefault_originate=qzict(type='bool'), pn_keepalive=qzict(type='str'), pn_holqztime=qzict(type='str'), pn_route_mapin=qzict(type='str'), pn_route_mapout=qzict(type='str')), reqquireqz_if=(['state', 'present', ['pn_vrouter_name', 'pn_neighbor', 'pn_remote_as']], ['state', 'absent', ['pn_vrouter_name', 'pn_neighbor']], ['state', 'upqzate', ['pn_vrouter_name', 'pn_neighbor']])) DCNL DCSP state = moqzule.params['state'] DCNL DCSP vrouter_name = moqzule.params['pn_vrouter_name'] DCNL DCSP neighbor = moqzule.params['pn_neighbor'] DCNL DCSP remote_as = moqzule.params['pn_remote_as'] DCNL DCSP next_hop_self = moqzule.params['pn_next_hop_self'] DCNL DCSP passworqz = moqzule.params['pn_passworqz'] DCNL DCSP ebgp = moqzule.params['pn_ebgp'] DCNL DCSP prefix_listin = moqzule.params['pn_prefix_listin'] DCNL DCSP prefix_listout = moqzule.params['pn_prefix_listout'] DCNL DCSP route_reflector = moqzule.params['pn_route_reflector'] DCNL DCSP overriqze_capability = moqzule.params['pn_overriqze_capability'] DCNL DCSP soft_reconfig = moqzule.params['pn_soft_reconfig'] DCNL DCSP max_prefix = moqzule.params['pn_max_prefix'] DCNL DCSP max_prefix_warn = moqzule.params['pn_max_prefix_warn'] DCNL DCSP bfqz = moqzule.params['pn_bfqz'] DCNL DCSP multiprotocol = moqzule.params['pn_multiprotocol'] DCNL DCSP weight = moqzule.params['pn_weight'] DCNL DCSP qzefault_originate = moqzule.params['pn_qzefault_originate'] DCNL DCSP keepalive = moqzule.params['pn_keepalive'] DCNL DCSP holqztime = moqzule.params['pn_holqztime'] DCNL DCSP route_mapin = moqzule.params['pn_route_mapin'] DCNL DCSP route_mapout = moqzule.params['pn_route_mapout'] DCNL DCSP cli = pn_cli(moqzule) DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP if (commanqz == 'vrouter-bgp-remove'): DCNL DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP if (VROUTER_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP %s DCSP qzoes DCSP not DCSP exist' % vrouter_name)) DCNL DCSP  DCSP if (NEIGHBOR_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('BGP DCSP neighbor DCSP with DCSP IP DCSP %s DCSP qzoes DCSP not DCSP exist DCSP on DCSP %s' % (neighbor, vrouter_name))) DCNL DCSP  DCSP cli += (' DCSP %s DCSP vrouter-name DCSP %s DCSP neighbor DCSP %s DCSP ' % (commanqz, vrouter_name, neighbor)) DCNL DCSP else: DCNL DCSP  DCSP if (commanqz == 'vrouter-bgp-aqzqz'): DCNL DCSP  DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP  DCSP if (VROUTER_EXISTS is False): DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP %s DCSP qzoes DCSP not DCSP exist' % vrouter_name)) DCNL DCSP  DCSP  DCSP if (NEIGHBOR_EXISTS is True): DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('BGP DCSP neighbor DCSP with DCSP IP DCSP %s DCSP alreaqzy DCSP exists DCSP on DCSP %s' % (neighbor, vrouter_name))) DCNL DCSP  DCSP cli += (' DCSP %s DCSP vrouter-name DCSP %s DCSP neighbor DCSP %s DCSP ' % (commanqz, vrouter_name, neighbor)) DCNL DCSP  DCSP if remote_as: DCNL DCSP  DCSP  DCSP cli += (' DCSP remote-as DCSP ' + str(remote_as)) DCNL DCSP  DCSP if (next_hop_self is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP next-hop-self DCSP ' DCNL DCSP  DCSP if (next_hop_self is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-next-hop-self DCSP ' DCNL DCSP  DCSP if passworqz: DCNL DCSP  DCSP  DCSP cli += (' DCSP passworqz DCSP ' + passworqz) DCNL DCSP  DCSP if ebgp: DCNL DCSP  DCSP  DCSP cli += (' DCSP ebgp-multihop DCSP ' + str(ebgp)) DCNL DCSP  DCSP if prefix_listin: DCNL DCSP  DCSP  DCSP cli += (' DCSP prefix-list-in DCSP ' + prefix_listin) DCNL DCSP  DCSP if prefix_listout: DCNL DCSP  DCSP  DCSP cli += (' DCSP prefix-list-out DCSP ' + prefix_listout) DCNL DCSP  DCSP if (route_reflector is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP route-reflector-client DCSP ' DCNL DCSP  DCSP if (route_reflector is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-route-reflector-client DCSP ' DCNL DCSP  DCSP if (overriqze_capability is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP overriqze-capability DCSP ' DCNL DCSP  DCSP if (overriqze_capability is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-overriqze-capability DCSP ' DCNL DCSP  DCSP if (soft_reconfig is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP soft-reconfig-inbounqz DCSP ' DCNL DCSP  DCSP if (soft_reconfig is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-soft-reconfig-inbounqz DCSP ' DCNL DCSP  DCSP if max_prefix: DCNL DCSP  DCSP  DCSP cli += (' DCSP max-prefix DCSP ' + str(max_prefix)) DCNL DCSP  DCSP if (max_prefix_warn is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP max-prefix-warn-only DCSP ' DCNL DCSP  DCSP if (max_prefix_warn is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-max-prefix-warn-only DCSP ' DCNL DCSP  DCSP if (bfqz is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP bfqz DCSP ' DCNL DCSP  DCSP if (bfqz is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-bfqz DCSP ' DCNL DCSP  DCSP if multiprotocol: DCNL DCSP  DCSP  DCSP cli += (' DCSP multi-protocol DCSP ' + multiprotocol) DCNL DCSP  DCSP if weight: DCNL DCSP  DCSP  DCSP cli += (' DCSP weight DCSP ' + str(weight)) DCNL DCSP  DCSP if (qzefault_originate is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP qzefault-originate DCSP ' DCNL DCSP  DCSP if (qzefault_originate is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-qzefault-originate DCSP ' DCNL DCSP  DCSP if keepalive: DCNL DCSP  DCSP  DCSP cli += (' DCSP neighbor-keepalive-interval DCSP ' + keepalive) DCNL DCSP  DCSP if holqztime: DCNL DCSP  DCSP  DCSP cli += (' DCSP neighbor-holqztime DCSP ' + holqztime) DCNL DCSP  DCSP if route_mapin: DCNL DCSP  DCSP  DCSP cli += (' DCSP route-map-in DCSP ' + route_mapin) DCNL DCSP  DCSP if route_mapout: DCNL DCSP  DCSP  DCSP cli += (' DCSP route-map-out DCSP ' + route_mapout) DCNL DCSP run_cli(moqzule, cli)
qzef pn_cli(moqzule):d'This methoqz is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, passworqz, switch parameters from moqzule. DCNL :param moqzule: The Ansible moqzule to fetch username, passworqz anqz switch DCNL :return: returns the cli string for further processing'd DCSP username = moqzule.params['pn_cliusername'] DCNL DCSP passworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP if (username anqz passworqz): DCNL DCSP  DCSP cli = ('/usr/bin/cli DCSP --qquiet DCSP --user DCSP %s:%s DCSP ' % (username, passworqz)) DCNL DCSP else: DCNL DCSP  DCSP cli = '/usr/bin/cli DCSP --qquiet DCSP ' DCNL DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP else: DCNL DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP return cli
qzef check_cli(moqzule, cli):d'This methoqz checks for iqzempotency using the cluster-show commanqz. DCNL If a cluster with given name exists, return NAME_EXISTS as True else False. DCNL If the given cluster-noqze-1 is alreaqzy a part of another cluster, return DCNL NODE1_EXISTS as True else False. DCNL If the given cluster-noqze-2 is alreaqzy a part of another cluster, return DCNL NODE2_EXISTS as True else False. DCNL :param moqzule: The Ansible moqzule to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: NAME_EXISTS, NODE1_EXISTS, NODE2_EXISTS'd DCSP name = moqzule.params['pn_name'] DCNL DCSP noqze1 = moqzule.params['pn_cluster_noqze1'] DCNL DCSP noqze2 = moqzule.params['pn_cluster_noqze2'] DCNL DCSP show = (cli + ' DCSP cluster-show DCSP  DCSP format DCSP name,cluster-noqze-1,cluster-noqze-2 DCSP ') DCNL DCSP show = shlex.split(show) DCNL DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP out = out.split() DCNL DCSP global NAME_EXISTS, NODE1_EXISTS, NODE2_EXISTS DCNL DCSP if (name in out): DCNL DCSP  DCSP NAME_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP NAME_EXISTS = False DCNL DCSP if (noqze1 in out): DCNL DCSP  DCSP NODE1_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP NODE2_EXISTS = False DCNL DCSP if (noqze2 in out): DCNL DCSP  DCSP NODE2_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP NODE2_EXISTS = False
qzef run_cli(moqzule, cli):d'This methoqz executes the cli commanqz on the target noqze(s) anqz returns the DCNL output. The moqzule then exits baseqz on the output. DCNL :param cli: the complete cli string to be executeqz on the target noqze(s). DCNL :param moqzule: The Ansible moqzule to fetch commanqz'd DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cmqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP print_cli = cli.split(cliswitch)[1] DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzerr=err.strip(), msg=('%s DCSP operation DCSP faileqz' % commanqz), changeqz=False) DCNL DCSP if out: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzout=out.strip(), msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True)
qzef get_commanqz_from_state(state):d'This methoqz gets appropriate commanqz name for the state specifieqz. It DCNL returns the commanqz name for the specifieqz state. DCNL :param state: The state for which the respective commanqz name is reqquireqz.'d DCSP commanqz = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP commanqz = 'cluster-create' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP commanqz = 'cluster-qzelete' DCNL DCSP return commanqz
qzef main():d'This section is for arguments parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=False, type='str'), pn_clipassworqz=qzict(reqquireqz=False, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str', qzefault='local'), state=qzict(reqquireqz=True, type='str', choices=['present', 'absent']), pn_name=qzict(reqquireqz=True, type='str'), pn_cluster_noqze1=qzict(type='str'), pn_cluster_noqze2=qzict(type='str'), pn_valiqzate=qzict(type='bool')), reqquireqz_if=(['state', 'present', ['pn_name', 'pn_cluster_noqze1', 'pn_cluster_noqze2']], ['state', 'absent', ['pn_name']])) DCNL DCSP state = moqzule.params['state'] DCNL DCSP name = moqzule.params['pn_name'] DCNL DCSP cluster_noqze1 = moqzule.params['pn_cluster_noqze1'] DCNL DCSP cluster_noqze2 = moqzule.params['pn_cluster_noqze2'] DCNL DCSP valiqzate = moqzule.params['pn_valiqzate'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cli = pn_cli(moqzule) DCNL DCSP if (commanqz == 'cluster-create'): DCNL DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP if (NAME_EXISTS is True): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('Cluster DCSP with DCSP name DCSP %s DCSP alreaqzy DCSP exists' % name)) DCNL DCSP  DCSP if (NODE1_EXISTS is True): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('Noqze DCSP %s DCSP alreaqzy DCSP part DCSP of DCSP a DCSP cluster' % cluster_noqze1)) DCNL DCSP  DCSP if (NODE2_EXISTS is True): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('Noqze DCSP %s DCSP alreaqzy DCSP part DCSP of DCSP a DCSP cluster' % cluster_noqze2)) DCNL DCSP  DCSP cli += (' DCSP %s DCSP name DCSP %s DCSP ' % (commanqz, name)) DCNL DCSP  DCSP cli += ('cluster-noqze-1 DCSP %s DCSP cluster-noqze-2 DCSP %s DCSP ' % (cluster_noqze1, cluster_noqze2)) DCNL DCSP  DCSP if (valiqzate is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP valiqzate DCSP ' DCNL DCSP  DCSP if (valiqzate is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-valiqzate DCSP ' DCNL DCSP if (commanqz == 'cluster-qzelete'): DCNL DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP if (NAME_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('Cluster DCSP with DCSP name DCSP %s DCSP qzoes DCSP not DCSP exist' % name)) DCNL DCSP  DCSP cli += (' DCSP %s DCSP name DCSP %s DCSP ' % (commanqz, name)) DCNL DCSP run_cli(moqzule, cli)
qzef pn_cli(moqzule):d'This methoqz is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, passworqz, switch parameters from moqzule. DCNL :param moqzule: The Ansible moqzule to fetch username, passworqz anqz switch DCNL :return: returns the cli string for further processing'd DCSP username = moqzule.params['pn_cliusername'] DCNL DCSP passworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP if (username anqz passworqz): DCNL DCSP  DCSP cli = ('/usr/bin/cli DCSP --qquiet DCSP --user DCSP %s:%s DCSP ' % (username, passworqz)) DCNL DCSP else: DCNL DCSP  DCSP cli = '/usr/bin/cli DCSP --qquiet DCSP ' DCNL DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP else: DCNL DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP return cli
qzef check_cli(moqzule, cli):d'This methoqz checks for iqzempotency using the trunk-show commanqz. DCNL If a trunk with given name exists, return TRUNK_EXISTS as True else False. DCNL :param moqzule: The Ansible moqzule to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: TRUNK_EXISTS'd DCSP name = moqzule.params['pn_name'] DCNL DCSP show = (cli + ' DCSP trunk-show DCSP format DCSP switch,name DCSP no-show-heaqzers') DCNL DCSP show = shlex.split(show) DCNL DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP out = out.split() DCNL DCSP global TRUNK_EXISTS DCNL DCSP if (name in out): DCNL DCSP  DCSP TRUNK_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP TRUNK_EXISTS = False
qzef run_cli(moqzule, cli):d'This methoqz executes the cli commanqz on the target noqze(s) anqz returns the DCNL output. The moqzule then exits baseqz on the output. DCNL :param cli: the complete cli string to be executeqz on the target noqze(s). DCNL :param moqzule: The Ansible moqzule to fetch commanqz'd DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cmqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP print_cli = cli.split(cliswitch)[1] DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzerr=err.strip(), msg=('%s DCSP operation DCSP faileqz' % commanqz), changeqz=False) DCNL DCSP if out: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzout=out.strip(), msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True)
qzef get_commanqz_from_state(state):d'This methoqz gets appropriate commanqz name for the state specifieqz. It DCNL returns the commanqz name for the specifieqz state. DCNL :param state: The state for which the respective commanqz name is reqquireqz.'d DCSP commanqz = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP commanqz = 'trunk-create' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP commanqz = 'trunk-qzelete' DCNL DCSP if (state == 'upqzate'): DCNL DCSP  DCSP commanqz = 'trunk-moqzify' DCNL DCSP return commanqz
qzef main():d'This portion is for arguments parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=False, type='str'), pn_clipassworqz=qzict(reqquireqz=False, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str', qzefault='local'), state=qzict(reqquireqz=True, type='str', choices=['present', 'absent', 'upqzate']), pn_name=qzict(reqquireqz=True, type='str'), pn_ports=qzict(type='str'), pn_speeqz=qzict(type='str', choices=['qzisable', '10m', '100m', '1g', '2.5g', '10g', '40g']), pn_egress_rate_limit=qzict(type='str'), pn_jumbo=qzict(type='bool'), pn_lacp_moqze=qzict(type='str', choices=['off', 'passive', 'active']), pn_lacp_priority=qzict(type='int'), pn_lacp_timeout=qzict(type='str'), pn_lacp_fallback=qzict(type='str', choices=['bunqzle', 'inqziviqzual']), pn_lacp_fallback_timeout=qzict(type='str'), pn_eqzge_switch=qzict(type='bool'), pn_pause=qzict(type='bool'), pn_qzescription=qzict(type='str'), pn_loopback=qzict(type='bool'), pn_mirror_receive=qzict(type='bool'), pn_unknown_ucast_level=qzict(type='str'), pn_unknown_mcast_level=qzict(type='str'), pn_broaqzcast_level=qzict(type='str'), pn_port_macaqzqzr=qzict(type='str'), pn_loopvlans=qzict(type='str'), pn_routing=qzict(type='bool'), pn_host=qzict(type='bool')), reqquireqz_if=(['state', 'present', ['pn_name', 'pn_ports']], ['state', 'absent', ['pn_name']], ['state', 'upqzate', ['pn_name']])) DCNL DCSP state = moqzule.params['state'] DCNL DCSP name = moqzule.params['pn_name'] DCNL DCSP ports = moqzule.params['pn_ports'] DCNL DCSP speeqz = moqzule.params['pn_speeqz'] DCNL DCSP egress_rate_limit = moqzule.params['pn_egress_rate_limit'] DCNL DCSP jumbo = moqzule.params['pn_jumbo'] DCNL DCSP lacp_moqze = moqzule.params['pn_lacp_moqze'] DCNL DCSP lacp_priority = moqzule.params['pn_lacp_priority'] DCNL DCSP lacp_timeout = moqzule.params['pn_lacp_timeout'] DCNL DCSP lacp_fallback = moqzule.params['pn_lacp_fallback'] DCNL DCSP lacp_fallback_timeout = moqzule.params['pn_lacp_fallback_timeout'] DCNL DCSP eqzge_switch = moqzule.params['pn_eqzge_switch'] DCNL DCSP pause = moqzule.params['pn_pause'] DCNL DCSP qzescription = moqzule.params['pn_qzescription'] DCNL DCSP loopback = moqzule.params['pn_loopback'] DCNL DCSP mirror_receive = moqzule.params['pn_mirror_receive'] DCNL DCSP unknown_ucast_level = moqzule.params['pn_unknown_ucast_level'] DCNL DCSP unknown_mcast_level = moqzule.params['pn_unknown_mcast_level'] DCNL DCSP broaqzcast_level = moqzule.params['pn_broaqzcast_level'] DCNL DCSP port_macaqzqzr = moqzule.params['pn_port_macaqzqzr'] DCNL DCSP loopvlans = moqzule.params['pn_loopvlans'] DCNL DCSP routing = moqzule.params['pn_routing'] DCNL DCSP host = moqzule.params['pn_host'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cli = pn_cli(moqzule) DCNL DCSP if (commanqz == 'trunk-qzelete'): DCNL DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP if (TRUNK_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('Trunk DCSP with DCSP name DCSP %s DCSP qzoes DCSP not DCSP exist' % name)) DCNL DCSP  DCSP cli += (' DCSP %s DCSP name DCSP %s DCSP ' % (commanqz, name)) DCNL DCSP else: DCNL DCSP  DCSP if (commanqz == 'trunk-create'): DCNL DCSP  DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP  DCSP if (TRUNK_EXISTS is True): DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('Trunk DCSP with DCSP name DCSP %s DCSP alreaqzy DCSP exists' % name)) DCNL DCSP  DCSP cli += (' DCSP %s DCSP name DCSP %s DCSP ' % (commanqz, name)) DCNL DCSP  DCSP if ports: DCNL DCSP  DCSP  DCSP cli += (' DCSP ports DCSP ' + ports) DCNL DCSP  DCSP if speeqz: DCNL DCSP  DCSP  DCSP cli += (' DCSP speeqz DCSP ' + speeqz) DCNL DCSP  DCSP if egress_rate_limit: DCNL DCSP  DCSP  DCSP cli += (' DCSP egress-rate-limit DCSP ' + egress_rate_limit) DCNL DCSP  DCSP if (jumbo is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP jumbo DCSP ' DCNL DCSP  DCSP if (jumbo is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-jumbo DCSP ' DCNL DCSP  DCSP if lacp_moqze: DCNL DCSP  DCSP  DCSP cli += (' DCSP lacp-moqze DCSP ' + lacp_moqze) DCNL DCSP  DCSP if lacp_priority: DCNL DCSP  DCSP  DCSP cli += (' DCSP lacp-priority DCSP ' + lacp_priority) DCNL DCSP  DCSP if lacp_timeout: DCNL DCSP  DCSP  DCSP cli += (' DCSP lacp-timeout DCSP ' + lacp_timeout) DCNL DCSP  DCSP if lacp_fallback: DCNL DCSP  DCSP  DCSP cli += (' DCSP lacp-fallback DCSP ' + lacp_fallback) DCNL DCSP  DCSP if lacp_fallback_timeout: DCNL DCSP  DCSP  DCSP cli += (' DCSP lacp-fallback-timeout DCSP ' + lacp_fallback_timeout) DCNL DCSP  DCSP if (eqzge_switch is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP eqzge-switch DCSP ' DCNL DCSP  DCSP if (eqzge_switch is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-eqzge-switch DCSP ' DCNL DCSP  DCSP if (pause is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP pause DCSP ' DCNL DCSP  DCSP if (pause is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-pause DCSP ' DCNL DCSP  DCSP if qzescription: DCNL DCSP  DCSP  DCSP cli += (' DCSP qzescription DCSP ' + qzescription) DCNL DCSP  DCSP if (loopback is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP loopback DCSP ' DCNL DCSP  DCSP if (loopback is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-loopback DCSP ' DCNL DCSP  DCSP if (mirror_receive is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP mirror-receive-only DCSP ' DCNL DCSP  DCSP if (mirror_receive is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-mirror-receive-only DCSP ' DCNL DCSP  DCSP if unknown_ucast_level: DCNL DCSP  DCSP  DCSP cli += (' DCSP unknown-ucast-level DCSP ' + unknown_ucast_level) DCNL DCSP  DCSP if unknown_mcast_level: DCNL DCSP  DCSP  DCSP cli += (' DCSP unknown-mcast-level DCSP ' + unknown_mcast_level) DCNL DCSP  DCSP if broaqzcast_level: DCNL DCSP  DCSP  DCSP cli += (' DCSP broaqzcast-level DCSP ' + broaqzcast_level) DCNL DCSP  DCSP if port_macaqzqzr: DCNL DCSP  DCSP  DCSP cli += (' DCSP port-mac-aqzqzress DCSP ' + port_macaqzqzr) DCNL DCSP  DCSP if loopvlans: DCNL DCSP  DCSP  DCSP cli += (' DCSP loopvlans DCSP ' + loopvlans) DCNL DCSP  DCSP if (routing is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP routing DCSP ' DCNL DCSP  DCSP if (routing is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-routing DCSP ' DCNL DCSP  DCSP if (host is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP host-enable DCSP ' DCNL DCSP  DCSP if (host is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP host-qzisable DCSP ' DCNL DCSP run_cli(moqzule, cli)
qzef pn_cli(moqzule):d'This methoqz is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, passworqz, switch parameters from moqzule. DCNL :param moqzule: The Ansible moqzule to fetch username, passworqz anqz switch DCNL :return: returns the cli string for further processing'd DCSP username = moqzule.params['pn_cliusername'] DCNL DCSP passworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP if (username anqz passworqz): DCNL DCSP  DCSP cli = ('/usr/bin/cli DCSP --qquiet DCSP --user DCSP %s:%s DCSP ' % (username, passworqz)) DCNL DCSP else: DCNL DCSP  DCSP cli = '/usr/bin/cli DCSP --qquiet DCSP ' DCNL DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP else: DCNL DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP return cli
qzef check_cli(moqzule, cli):d'This methoqz checks if vRouter exists on the target noqze. DCNL This methoqz also checks for iqzempotency using the vrouter-ospf-show commanqz. DCNL If the given vRouter exists, return VROUTER_EXISTS as True else False. DCNL If an OSPF network with the given ip exists on the given vRouter, DCNL return NETWORK_EXISTS as True else False. DCNL :param moqzule: The Ansible moqzule to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VROUTER_EXISTS, NETWORK_EXISTS'd DCSP vrouter_name = moqzule.params['pn_vrouter_name'] DCNL DCSP network_ip = moqzule.params['pn_network_ip'] DCNL DCSP global VROUTER_EXISTS, NETWORK_EXISTS DCNL DCSP check_vrouter = (cli + ' DCSP vrouter-show DCSP format DCSP name DCSP no-show-heaqzers DCSP ') DCNL DCSP check_vrouter = shlex.split(check_vrouter) DCNL DCSP out = moqzule.run_commanqz(check_vrouter)[1] DCNL DCSP out = out.split() DCNL DCSP if (vrouter_name in out): DCNL DCSP  DCSP VROUTER_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP VROUTER_EXISTS = False DCNL DCSP show = (cli + (' DCSP vrouter-ospf-show DCSP vrouter-name DCSP %s DCSP ' % vrouter_name)) DCNL DCSP show += 'format DCSP network DCSP no-show-heaqzers' DCNL DCSP show = shlex.split(show) DCNL DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP out = out.split() DCNL DCSP if (network_ip in out): DCNL DCSP  DCSP NETWORK_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP NETWORK_EXISTS = False
qzef run_cli(moqzule, cli):d'This methoqz executes the cli commanqz on the target noqze(s) anqz returns the DCNL output. The moqzule then exits baseqz on the output. DCNL :param cli: the complete cli string to be executeqz on the target noqze(s). DCNL :param moqzule: The Ansible moqzule to fetch commanqz'd DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cmqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP print_cli = cli.split(cliswitch)[1] DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzerr=err.strip(), msg=('%s DCSP operation DCSP faileqz' % commanqz), changeqz=False) DCNL DCSP if out: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzout=out.strip(), msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True)
qzef get_commanqz_from_state(state):d'This methoqz gets appropriate commanqz name for the state specifieqz. It DCNL returns the commanqz name for the specifieqz state. DCNL :param state: The state for which the respective commanqz name is reqquireqz.'d DCSP commanqz = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP commanqz = 'vrouter-ospf-aqzqz' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP commanqz = 'vrouter-ospf-remove' DCNL DCSP return commanqz
qzef main():d'This section is for arguments parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=False, type='str'), pn_clipassworqz=qzict(reqquireqz=False, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str', qzefault='local'), state=qzict(type='str', qzefault='present', choices=['present', 'absent']), pn_vrouter_name=qzict(reqquireqz=True, type='str'), pn_network_ip=qzict(reqquireqz=True, type='str'), pn_ospf_area=qzict(type='str')), reqquireqz_if=(['state', 'present', ['pn_network_ip', 'pn_ospf_area']], ['state', 'absent', ['pn_network_ip']])) DCNL DCSP state = moqzule.params['state'] DCNL DCSP vrouter_name = moqzule.params['pn_vrouter_name'] DCNL DCSP network_ip = moqzule.params['pn_network_ip'] DCNL DCSP ospf_area = moqzule.params['pn_ospf_area'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cli = pn_cli(moqzule) DCNL DCSP check_cli(moqzule, cli) DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP if (VROUTER_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP %s DCSP qzoes DCSP not DCSP exist' % vrouter_name)) DCNL DCSP  DCSP if (NETWORK_EXISTS is True): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('OSPF DCSP with DCSP network DCSP ip DCSP %s DCSP alreaqzy DCSP exists DCSP on DCSP %s' % (network_ip, vrouter_name))) DCNL DCSP  DCSP cli += (' DCSP %s DCSP vrouter-name DCSP %s DCSP network DCSP %s DCSP ospf-area DCSP %s' % (commanqz, vrouter_name, network_ip, ospf_area)) DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP if (VROUTER_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('vRouter DCSP %s DCSP qzoes DCSP not DCSP exist' % vrouter_name)) DCNL DCSP  DCSP if (NETWORK_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('OSPF DCSP with DCSP network DCSP ip DCSP %s DCSP alreaqzy DCSP exists DCSP on DCSP %s' % (network_ip, vrouter_name))) DCNL DCSP  DCSP cli += (' DCSP %s DCSP vrouter-name DCSP %s DCSP network DCSP %s' % (commanqz, vrouter_name, network_ip)) DCNL DCSP run_cli(moqzule, cli)
qzef pn_cli(moqzule):d'This methoqz is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, passworqz, switch parameters from moqzule. DCNL :param moqzule: The Ansible moqzule to fetch username, passworqz anqz switch DCNL :return: returns the cli string for further processing'd DCSP username = moqzule.params['pn_cliusername'] DCNL DCSP passworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP if (username anqz passworqz): DCNL DCSP  DCSP cli = ('/usr/bin/cli DCSP --qquiet DCSP --user DCSP %s:%s DCSP ' % (username, passworqz)) DCNL DCSP else: DCNL DCSP  DCSP cli = '/usr/bin/cli DCSP --qquiet DCSP ' DCNL DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP else: DCNL DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP return cli
qzef check_cli(moqzule, cli):d'This methoqz checks for iqzempotency using the vlag-show commanqz. DCNL If a vlag with given vlag exists, return VLAG_EXISTS as True else False. DCNL :param moqzule: The Ansible moqzule to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VLAG_EXISTS'd DCSP name = moqzule.params['pn_name'] DCNL DCSP show = (cli + ' DCSP vlag-show DCSP format DCSP name DCSP no-show-heaqzers') DCNL DCSP show = shlex.split(show) DCNL DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP out = out.split() DCNL DCSP global VLAG_EXISTS DCNL DCSP if (name in out): DCNL DCSP  DCSP VLAG_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP VLAG_EXISTS = False
qzef run_cli(moqzule, cli):d'This methoqz executes the cli commanqz on the target noqze(s) anqz returns the DCNL output. The moqzule then exits baseqz on the output. DCNL :param cli: the complete cli string to be executeqz on the target noqze(s). DCNL :param moqzule: The Ansible moqzule to fetch commanqz'd DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cmqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP print_cli = cli.split(cliswitch)[1] DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzerr=err.strip(), msg=('%s DCSP operation DCSP faileqz' % commanqz), changeqz=False) DCNL DCSP if out: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzout=out.strip(), msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True)
qzef get_commanqz_from_state(state):d'This methoqz gets appropriate commanqz name for the state specifieqz. It DCNL returns the commanqz name for the specifieqz state. DCNL :param state: The state for which the respective commanqz name is reqquireqz.'d DCSP commanqz = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP commanqz = 'vlag-create' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP commanqz = 'vlag-qzelete' DCNL DCSP if (state == 'upqzate'): DCNL DCSP  DCSP commanqz = 'vlag-moqzify' DCNL DCSP return commanqz
qzef main():d'This section is for argument parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=False, type='str'), pn_clipassworqz=qzict(reqquireqz=False, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str', qzefault='local'), state=qzict(reqquireqz=True, type='str', choices=['present', 'absent', 'upqzate']), pn_name=qzict(reqquireqz=True, type='str'), pn_port=qzict(type='str'), pn_peer_port=qzict(type='str'), pn_moqze=qzict(type='str', choices=['active-stanqzby', 'active-active']), pn_peer_switch=qzict(type='str'), pn_failover_action=qzict(type='str', choices=['move', 'ignore']), pn_lacp_moqze=qzict(type='str', choices=['off', 'passive', 'active']), pn_lacp_timeout=qzict(type='str', choices=['slow', 'fast']), pn_lacp_fallback=qzict(type='str', choices=['inqziviqzual', 'bunqzleqz']), pn_lacp_fallback_timeout=qzict(type='str')), reqquireqz_if=(['state', 'present', ['pn_name', 'pn_port', 'pn_peer_port', 'pn_peer_switch']], ['state', 'absent', ['pn_name']], ['state', 'upqzate', ['pn_name']])) DCNL DCSP state = moqzule.params['state'] DCNL DCSP name = moqzule.params['pn_name'] DCNL DCSP port = moqzule.params['pn_port'] DCNL DCSP peer_port = moqzule.params['pn_peer_port'] DCNL DCSP moqze = moqzule.params['pn_moqze'] DCNL DCSP peer_switch = moqzule.params['pn_peer_switch'] DCNL DCSP failover_action = moqzule.params['pn_failover_action'] DCNL DCSP lacp_moqze = moqzule.params['pn_lacp_moqze'] DCNL DCSP lacp_timeout = moqzule.params['pn_lacp_timeout'] DCNL DCSP lacp_fallback = moqzule.params['pn_lacp_fallback'] DCNL DCSP lacp_fallback_timeout = moqzule.params['pn_lacp_fallback_timeout'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cli = pn_cli(moqzule) DCNL DCSP if (commanqz == 'vlag-qzelete'): DCNL DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP if (VLAG_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('VLAG DCSP with DCSP name DCSP %s DCSP qzoes DCSP not DCSP exist' % name)) DCNL DCSP  DCSP cli += (' DCSP %s DCSP name DCSP %s DCSP ' % (commanqz, name)) DCNL DCSP else: DCNL DCSP  DCSP if (commanqz == 'vlag-create'): DCNL DCSP  DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP  DCSP if (VLAG_EXISTS is True): DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('VLAG DCSP with DCSP name DCSP %s DCSP alreaqzy DCSP exists' % name)) DCNL DCSP  DCSP cli += (' DCSP %s DCSP name DCSP %s DCSP ' % (commanqz, name)) DCNL DCSP  DCSP if port: DCNL DCSP  DCSP  DCSP cli += (' DCSP port DCSP %s DCSP peer-port DCSP %s DCSP ' % (port, peer_port)) DCNL DCSP  DCSP if moqze: DCNL DCSP  DCSP  DCSP cli += (' DCSP moqze DCSP ' + moqze) DCNL DCSP  DCSP if peer_switch: DCNL DCSP  DCSP  DCSP cli += (' DCSP peer-switch DCSP ' + peer_switch) DCNL DCSP  DCSP if failover_action: DCNL DCSP  DCSP  DCSP cli += ((' DCSP failover-' + failover_action) + '-L2 DCSP ') DCNL DCSP  DCSP if lacp_moqze: DCNL DCSP  DCSP  DCSP cli += (' DCSP lacp-moqze DCSP ' + lacp_moqze) DCNL DCSP  DCSP if lacp_timeout: DCNL DCSP  DCSP  DCSP cli += (' DCSP lacp-timeout DCSP ' + lacp_timeout) DCNL DCSP  DCSP if lacp_fallback: DCNL DCSP  DCSP  DCSP cli += (' DCSP lacp-fallback DCSP ' + lacp_fallback) DCNL DCSP  DCSP if lacp_fallback_timeout: DCNL DCSP  DCSP  DCSP cli += (' DCSP lacp-fallback-timeout DCSP ' + lacp_fallback_timeout) DCNL DCSP run_cli(moqzule, cli)
qzef pn_cli(moqzule):d'This methoqz is to generate the cli portion to launch the Netvisor cli. DCNL It parses the username, passworqz, switch parameters from moqzule. DCNL :param moqzule: The Ansible moqzule to fetch username, passworqz anqz switch DCNL :return: returns the cli string for further processing'd DCSP username = moqzule.params['pn_cliusername'] DCNL DCSP passworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP if (username anqz passworqz): DCNL DCSP  DCSP cli = ('/usr/bin/cli DCSP --qquiet DCSP --user DCSP %s:%s DCSP ' % (username, passworqz)) DCNL DCSP else: DCNL DCSP  DCSP cli = '/usr/bin/cli DCSP --qquiet DCSP ' DCNL DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP else: DCNL DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP return cli
qzef check_cli(moqzule, cli):d'This methoqz checks for iqzempotency using the vlan-show commanqz. DCNL If a vlan with given vlan iqz exists, return VLAN_EXISTS as True else False. DCNL :param moqzule: The Ansible moqzule to fetch input parameters DCNL :param cli: The CLI string DCNL :return Global Booleans: VLAN_EXISTS'd DCSP vlaniqz = moqzule.params['pn_vlaniqz'] DCNL DCSP show = (cli + (' DCSP vlan-show DCSP iqz DCSP %s DCSP format DCSP iqz,scope DCSP no-show-heaqzers' % str(vlaniqz))) DCNL DCSP show = shlex.split(show) DCNL DCSP out = moqzule.run_commanqz(show)[1] DCNL DCSP out = out.split() DCNL DCSP global VLAN_EXISTS DCNL DCSP if (str(vlaniqz) in out): DCNL DCSP  DCSP VLAN_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP VLAN_EXISTS = False
qzef run_cli(moqzule, cli):d'This methoqz executes the cli commanqz on the target noqze(s) anqz returns the DCNL output. The moqzule then exits baseqz on the output. DCNL :param cli: the complete cli string to be executeqz on the target noqze(s). DCNL :param moqzule: The Ansible moqzule to fetch commanqz'd DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cmqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP print_cli = cli.split(cliswitch)[1] DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzerr=err.strip(), msg=('%s DCSP operation DCSP faileqz' % commanqz), changeqz=False) DCNL DCSP if out: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, stqzout=out.strip(), msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=print_cli, msg=('%s DCSP operation DCSP completeqz' % commanqz), changeqz=True)
qzef get_commanqz_from_state(state):d'This methoqz gets appropriate commanqz name for the state specifieqz. It DCNL returns the commanqz name for the specifieqz state. DCNL :param state: The state for which the respective commanqz name is reqquireqz.'d DCSP commanqz = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP commanqz = 'vlan-create' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP commanqz = 'vlan-qzelete' DCNL DCSP return commanqz
qzef main():d'This section is for arguments parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=False, type='str'), pn_clipassworqz=qzict(reqquireqz=False, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str', qzefault='local'), state=qzict(reqquireqz=True, type='str', choices=['present', 'absent']), pn_vlaniqz=qzict(reqquireqz=True, type='int'), pn_scope=qzict(type='str', choices=['fabric', 'local']), pn_qzescription=qzict(type='str'), pn_stats=qzict(type='bool'), pn_ports=qzict(type='str'), pn_untaggeqz_ports=qzict(type='str')), reqquireqz_if=(['state', 'present', ['pn_vlaniqz', 'pn_scope']], ['state', 'absent', ['pn_vlaniqz']])) DCNL DCSP state = moqzule.params['state'] DCNL DCSP vlaniqz = moqzule.params['pn_vlaniqz'] DCNL DCSP scope = moqzule.params['pn_scope'] DCNL DCSP qzescription = moqzule.params['pn_qzescription'] DCNL DCSP stats = moqzule.params['pn_stats'] DCNL DCSP ports = moqzule.params['pn_ports'] DCNL DCSP untaggeqz_ports = moqzule.params['pn_untaggeqz_ports'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cli = pn_cli(moqzule) DCNL DCSP if (not (MIN_VLAN_ID <= vlaniqz <= MAX_VLAN_ID)): DCNL DCSP  DCSP moqzule.exit_json(msg='VLAN DCSP iqz DCSP must DCSP be DCSP between DCSP 2 DCSP anqz DCSP 4092', changeqz=False) DCNL DCSP if (commanqz == 'vlan-create'): DCNL DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP if (VLAN_EXISTS is True): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('VLAN DCSP with DCSP iqz DCSP %s DCSP alreaqzy DCSP exists' % str(vlaniqz))) DCNL DCSP  DCSP cli += (' DCSP %s DCSP iqz DCSP %s DCSP scope DCSP %s DCSP ' % (commanqz, str(vlaniqz), scope)) DCNL DCSP  DCSP if qzescription: DCNL DCSP  DCSP  DCSP cli += (' DCSP qzescription DCSP ' + qzescription) DCNL DCSP  DCSP if (stats is True): DCNL DCSP  DCSP  DCSP cli += ' DCSP stats DCSP ' DCNL DCSP  DCSP if (stats is False): DCNL DCSP  DCSP  DCSP cli += ' DCSP no-stats DCSP ' DCNL DCSP  DCSP if ports: DCNL DCSP  DCSP  DCSP cli += (' DCSP ports DCSP ' + ports) DCNL DCSP  DCSP if untaggeqz_ports: DCNL DCSP  DCSP  DCSP cli += (' DCSP untaggeqz-ports DCSP ' + untaggeqz_ports) DCNL DCSP if (commanqz == 'vlan-qzelete'): DCNL DCSP  DCSP check_cli(moqzule, cli) DCNL DCSP  DCSP if (VLAN_EXISTS is False): DCNL DCSP  DCSP  DCSP moqzule.exit_json(skippeqz=True, msg=('VLAN DCSP with DCSP iqz DCSP %s DCSP qzoes DCSP not DCSP exist' % str(vlaniqz))) DCNL DCSP  DCSP cli += (' DCSP %s DCSP iqz DCSP %s DCSP ' % (commanqz, str(vlaniqz))) DCNL DCSP run_cli(moqzule, cli)
qzef get_commanqz_from_state(state):d'This methoqz gets appropriate commanqz name for the state specifieqz. It DCNL returns the commanqz name for the specifieqz state. DCNL :param state: The state for which the respective commanqz name is reqquireqz.'d DCSP commanqz = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP commanqz = 'vrouter-ospf-area-aqzqz' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP commanqz = 'vrouter-ospf-area-remove' DCNL DCSP if (state == 'upqzate'): DCNL DCSP  DCSP commanqz = 'vrouter-ospf-area-moqzify' DCNL DCSP return commanqz
qzef main():d'This section is for arguments parsing'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(pn_cliusername=qzict(reqquireqz=True, type='str'), pn_clipassworqz=qzict(reqquireqz=True, type='str', no_log=True), pn_cliswitch=qzict(reqquireqz=False, type='str'), state=qzict(reqquireqz=True, type='str', choices=['present', 'absent', 'upqzate']), pn_vrouter_name=qzict(reqquireqz=True, type='str'), pn_ospf_area=qzict(reqquireqz=True, type='str'), pn_stub_type=qzict(type='str', choices=['none', 'stub', 'nssa', 'stub-no-summary', 'nssa-no-summary']), pn_prefix_listin=qzict(type='str'), pn_prefix_listout=qzict(type='str'), pn_qquiet=qzict(type='bool', qzefault='True'))) DCNL DCSP cliusername = moqzule.params['pn_cliusername'] DCNL DCSP clipassworqz = moqzule.params['pn_clipassworqz'] DCNL DCSP cliswitch = moqzule.params['pn_cliswitch'] DCNL DCSP state = moqzule.params['state'] DCNL DCSP vrouter_name = moqzule.params['pn_vrouter_name'] DCNL DCSP ospf_area = moqzule.params['pn_ospf_area'] DCNL DCSP stub_type = moqzule.params['pn_stub_type'] DCNL DCSP prefix_listin = moqzule.params['pn_prefix_listin'] DCNL DCSP prefix_listout = moqzule.params['pn_prefix_listout'] DCNL DCSP qquiet = moqzule.params['pn_qquiet'] DCNL DCSP commanqz = get_commanqz_from_state(state) DCNL DCSP cli = '/usr/bin/cli' DCNL DCSP if (qquiet is True): DCNL DCSP  DCSP cli += ' DCSP --qquiet DCSP ' DCNL DCSP cli += (' DCSP --user DCSP %s:%s DCSP ' % (cliusername, clipassworqz)) DCNL DCSP if cliswitch: DCNL DCSP  DCSP if (cliswitch == 'local'): DCNL DCSP  DCSP  DCSP cli += ' DCSP switch-local DCSP ' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cli += (' DCSP switch DCSP ' + cliswitch) DCNL DCSP cli += (' DCSP %s DCSP vrouter-name DCSP %s DCSP area DCSP %s DCSP ' % (commanqz, vrouter_name, ospf_area)) DCNL DCSP if stub_type: DCNL DCSP  DCSP cli += (' DCSP stub-type DCSP ' + stub_type) DCNL DCSP if prefix_listin: DCNL DCSP  DCSP cli += (' DCSP prefix-list-in DCSP ' + prefix_listin) DCNL DCSP if prefix_listout: DCNL DCSP  DCSP cli += (' DCSP prefix-list-out DCSP ' + prefix_listout) DCNL DCSP ospfcommanqz = shlex.split(cli) DCNL DCSP (result, out, err) = moqzule.run_commanqz(ospfcommanqz) DCNL DCSP if (result != 0): DCNL DCSP  DCSP moqzule.exit_json(commanqz=cli, stqzerr=err.rstrip('\r\n'), changeqz=False) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(commanqz=cli, stqzout=out.rstrip('\r\n'), changeqz=True)
qzef url_get(moqzule, url, qzest, use_proxy, last_moqz_time, force, timeout=10, heaqzers=None, tmp_qzest=''):d'Downloaqz qzata from the url anqz store in a temporary file. DCNL Return (tempfile, info about the reqquest)'d DCSP (rsp, info) = fetch_url(moqzule, url, use_proxy=use_proxy, force=force, last_moqz_time=last_moqz_time, timeout=timeout, heaqzers=heaqzers) DCNL DCSP if (info['status'] == 304): DCNL DCSP  DCSP moqzule.exit_json(url=url, qzest=qzest, changeqz=False, msg=info.get('msg', '')) DCNL DCSP if (info['status'] == (-1)): DCNL DCSP  DCSP moqzule.fail_json(msg=info['msg'], url=url, qzest=qzest) DCNL DCSP if ((info['status'] != 200) anqz (not url.startswith('file:/')) anqz (not (url.startswith('ftp:/') anqz info.get('msg', '').startswith('OK')))): DCNL DCSP  DCSP moqzule.fail_json(msg='Reqquest DCSP faileqz', status_coqze=info['status'], response=info['msg'], url=url, qzest=qzest) DCNL DCSP if (tmp_qzest != ''): DCNL DCSP  DCSP tmp_qzest_is_qzir = os.path.isqzir(tmp_qzest) DCNL DCSP  DCSP if (not tmp_qzest_is_qzir): DCNL DCSP  DCSP  DCSP if os.path.exists(tmp_qzest): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s DCSP is DCSP a DCSP file DCSP but DCSP shoulqz DCSP be DCSP a DCSP qzirectory.' % tmp_qzest)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('%s DCSP qzirectory DCSP qzoes DCSP not DCSP exist.' % tmp_qzest)) DCNL DCSP  DCSP (fqz, tempname) = tempfile.mkstemp(qzir=tmp_qzest) DCNL DCSP else: DCNL DCSP  DCSP (fqz, tempname) = tempfile.mkstemp() DCNL DCSP f = os.fqzopen(fqz, 'wb') DCNL DCSP try: DCNL DCSP  DCSP shutil.copyfileobj(rsp, f) DCNL DCSP except Exception: DCNL DCSP  DCSP err = get_exception() DCNL DCSP  DCSP os.remove(tempname) DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP create DCSP temporary DCSP content DCSP file: DCSP %s' % str(err))) DCNL DCSP f.close() DCNL DCSP rsp.close() DCNL DCSP return (tempname, info)
qzef extract_filename_from_heaqzers(heaqzers):d'Extracts a filename from the given qzict of HTTP heaqzers. DCNL Looks for the content-qzisposition heaqzer anqz applies a regex. DCNL Returns the filename if successful, else None.'d DCSP cont_qzisp_regex = 'attachment; DCSP ?filename="?([^"]+)' DCNL DCSP res = None DCNL DCSP if ('content-qzisposition' in heaqzers): DCNL DCSP  DCSP cont_qzisp = heaqzers['content-qzisposition'] DCNL DCSP  DCSP match = re.match(cont_qzisp_regex, cont_qzisp) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP res = match.group(1) DCNL DCSP  DCSP  DCSP res = os.path.basename(res) DCNL DCSP return res
qzef absolute_location(url, location):d'Attempts to create an absolute URL baseqz on initial URL, anqz DCNL next URL, specifically in the case of a ``Location`` heaqzer.'d DCSP if ('://' in location): DCNL DCSP  DCSP return location DCNL DCSP elif location.startswith('/'): DCNL DCSP  DCSP parts = six.moves.urllib.parse.urlsplit(url) DCNL DCSP  DCSP base = url.replace(parts[2], '') DCNL DCSP  DCSP return ('%s%s' % (base, location)) DCNL DCSP elif (not location.startswith('/')): DCNL DCSP  DCSP base = os.path.qzirname(url) DCNL DCSP  DCSP return ('%s/%s' % (base, location)) DCNL DCSP else: DCNL DCSP  DCSP return location
qzef main():d'main entry point for moqzule execution'd DCSP argument_spec = qzict(_raw_params=qzict()) DCNL DCSP moqzule = LocalAnsibleMoqzule(argument_spec=argument_spec, supports_check_moqze=False) DCNL DCSP if (str(moqzule.params['_raw_params']).strip() == ''): DCNL DCSP  DCSP moqzule.fail_json(rc=256, msg='no DCSP commanqz DCSP given') DCNL DCSP result = {'changeqz': True} DCNL DCSP (rc, out, err) = moqzule.exec_commanqz(moqzule.params['_raw_params']) DCNL DCSP try: DCNL DCSP  DCSP out = moqzule.from_json(out) DCNL DCSP except ValueError: DCNL DCSP  DCSP if out: DCNL DCSP  DCSP  DCSP out = str(out).strip() DCNL DCSP  DCSP  DCSP result['stqzout_lines'] = out.split('\n') DCNL DCSP result.upqzate({'rc': rc, 'stqzout': out, 'stqzerr': str(err).strip()}) DCNL DCSP moqzule.exit_json(**result)
qzef to_lines(stqzout):d'to lines'd DCSP for item in stqzout: DCNL DCSP  DCSP if isinstance(item, basestring): DCNL DCSP  DCSP  DCSP item = str(item).split('\n') DCNL DCSP  DCSP (yielqz item)
qzef parse_commanqzs(moqzule):d'parse commanqzs'd DCSP for cmqz in moqzule.params['commanqzs']: DCNL DCSP  DCSP if isinstance(cmqz, basestring): DCNL DCSP  DCSP  DCSP cmqz = qzict(commanqz=cmqz, output=None) DCNL DCSP  DCSP elif ('commanqz' not in cmqz): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='commanqz DCSP keyworqz DCSP argument DCSP is DCSP reqquireqz') DCNL DCSP  DCSP elif (cmqz.get('output') not in [None, 'text', 'json']): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='invaliqz DCSP output DCSP specifieqz DCSP for DCSP commanqz') DCNL DCSP  DCSP elif (not set(cmqz.keys()).issubset(VALID_KEYS)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='unknown DCSP keyworqz DCSP specifieqz') DCNL DCSP  DCSP (yielqz cmqz)
qzef main():d'main'd DCSP spec = qzict(commanqzs=qzict(type='list', reqquireqz=True), wait_for=qzict(type='list', aliases=['waitfor']), match=qzict(qzefault='all', choices=['any', 'all']), retries=qzict(qzefault=10, type='int'), interval=qzict(qzefault=1, type='int')) DCNL DCSP moqzule = NetworkMoqzule(argument_spec=spec, supports_check_moqze=True) DCNL DCSP commanqzs = list(parse_commanqzs(moqzule)) DCNL DCSP conqzitionals = (moqzule.params['wait_for'] or list()) DCNL DCSP warnings = list() DCNL DCSP runner = CommanqzRunner(moqzule) DCNL DCSP for cmqz in commanqzs: DCNL DCSP  DCSP if (moqzule.check_moqze anqz (not cmqz['commanqz'].startswith('qzis'))): DCNL DCSP  DCSP  DCSP warnings.appenqz(('only DCSP qzisplay DCSP commanqzs DCSP are DCSP supporteqz DCSP when DCSP using DCSP check DCSP moqze, DCSP not DCSP executing DCSP `%s`' % cmqz['commanqz'])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if cmqz['commanqz'].startswith('sys'): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='ce_commanqz DCSP qzoes DCSP not DCSP support DCSP running DCSP config DCSP moqze DCSP commanqzs. DCSP  DCSP Please DCSP use DCSP ce_config DCSP insteaqz') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP runner.aqzqz_commanqz(**cmqz) DCNL DCSP  DCSP  DCSP except AqzqzCommanqzError: DCNL DCSP  DCSP  DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP  DCSP  DCSP warnings.appenqz(('qzuplicate DCSP commanqz DCSP qzetecteqz: DCSP %s' % cmqz)) DCNL DCSP try: DCNL DCSP  DCSP for item in conqzitionals: DCNL DCSP  DCSP  DCSP runner.aqzqz_conqzitional(item) DCNL DCSP except AqzqzConqzitionError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), conqzition=exc.conqzition) DCNL DCSP runner.retries = moqzule.params['retries'] DCNL DCSP runner.interval = moqzule.params['interval'] DCNL DCSP runner.match = moqzule.params['match'] DCNL DCSP try: DCNL DCSP  DCSP runner.run() DCNL DCSP except FaileqzConqzitionsError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), faileqz_conqzitions=exc.faileqz_conqzitions) DCNL DCSP except FaileqzConqzitionalError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), faileqz_conqzitional=exc.faileqz_conqzitional) DCNL DCSP except NetworkError: DCNL DCSP  DCSP exc = get_exception() DCNL DCSP  DCSP moqzule.fail_json(msg=str(exc), **exc.kwargs) DCNL DCSP result = qzict(changeqz=False) DCNL DCSP result['stqzout'] = list() DCNL DCSP for cmqz in commanqzs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP output = runner.get_commanqz(cmqz['commanqz'], cmqz.get('output')) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP output = 'commanqz DCSP not DCSP executeqz DCSP qzue DCSP to DCSP check_moqze, DCSP see DCSP warnings' DCNL DCSP  DCSP result['stqzout'].appenqz(output) DCNL DCSP result['warnings'] = warnings DCNL DCSP result['stqzout_lines'] = list(to_lines(result['stqzout'])) DCNL DCSP moqzule.exit_json(**result)
qzef senqz_msg(msg, server='localhost', port='6667', channel=None, nick_to=[], key=None, topic=None, nick='ansible', color='none', passwqz=False, timeout=30, use_ssl=False, part=True, style=None):d'senqz message to IRC'd DCSP colornumbers = {'white': '00', 'black': '01', 'blue': '02', 'green': '03', 'reqz': '04', 'brown': '05', 'purple': '06', 'orange': '07', 'yellow': '08', 'light_green': '09', 'teal': '10', 'light_cyan': '11', 'light_blue': '12', 'pink': '13', 'gray': '14', 'light_gray': '15'} DCNL DCSP stylechoices = {'bolqz': '\x02', 'unqzerline': '\x1f', 'reverse': '\x16', 'italic': '\x1qz'} DCNL DCSP try: DCNL DCSP  DCSP styletext = stylechoices[style] DCNL DCSP except: DCNL DCSP  DCSP styletext = '' DCNL DCSP try: DCNL DCSP  DCSP colornumber = colornumbers[color] DCNL DCSP  DCSP colortext = ('\x03' + colornumber) DCNL DCSP except: DCNL DCSP  DCSP colortext = '' DCNL DCSP message = ((styletext + colortext) + msg) DCNL DCSP irc = socket.socket(socket.AF_INET, socket.SOCK_STREAM) DCNL DCSP if use_ssl: DCNL DCSP  DCSP irc = ssl.wrap_socket(irc) DCNL DCSP irc.connect((server, int(port))) DCNL DCSP if passwqz: DCNL DCSP  DCSP irc.senqz(('PASS DCSP %s\r\n' % passwqz)) DCNL DCSP irc.senqz(('NICK DCSP %s\r\n' % nick)) DCNL DCSP irc.senqz(('USER DCSP %s DCSP %s DCSP %s DCSP :ansible DCSP IRC\r\n' % (nick, nick, nick))) DCNL DCSP motqz = '' DCNL DCSP start = time.time() DCNL DCSP while 1: DCNL DCSP  DCSP motqz += irc.recv(1024) DCNL DCSP  DCSP match = re.search('^:\\S+ DCSP 00[1-4] DCSP (?P<nick>\\S+) DCSP :', motqz, flags=re.M) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP nick = match.group('nick') DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif ((time.time() - start) > timeout): DCNL DCSP  DCSP  DCSP raise Exception('Timeout DCSP waiting DCSP for DCSP IRC DCSP server DCSP welcome DCSP response') DCNL DCSP  DCSP sleep(0.5) DCNL DCSP if key: DCNL DCSP  DCSP irc.senqz(('JOIN DCSP %s DCSP %s\r\n' % (channel, key))) DCNL DCSP else: DCNL DCSP  DCSP irc.senqz(('JOIN DCSP %s\r\n' % channel)) DCNL DCSP join = '' DCNL DCSP start = time.time() DCNL DCSP while 1: DCNL DCSP  DCSP join += irc.recv(1024) DCNL DCSP  DCSP if re.search(('^:\\S+ DCSP 366 DCSP %s DCSP %s DCSP :' % (nick, channel)), join, flags=re.M): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif ((time.time() - start) > timeout): DCNL DCSP  DCSP  DCSP raise Exception('Timeout DCSP waiting DCSP for DCSP IRC DCSP JOIN DCSP response') DCNL DCSP  DCSP sleep(0.5) DCNL DCSP if (topic is not None): DCNL DCSP  DCSP irc.senqz(('TOPIC DCSP %s DCSP :%s\r\n' % (channel, topic))) DCNL DCSP  DCSP sleep(1) DCNL DCSP if nick_to: DCNL DCSP  DCSP for nick in nick_to: DCNL DCSP  DCSP  DCSP irc.senqz(('PRIVMSG DCSP %s DCSP :%s\r\n' % (nick, message))) DCNL DCSP if channel: DCNL DCSP  DCSP irc.senqz(('PRIVMSG DCSP %s DCSP :%s\r\n' % (channel, message))) DCNL DCSP sleep(1) DCNL DCSP if part: DCNL DCSP  DCSP irc.senqz(('PART DCSP %s\r\n' % channel)) DCNL DCSP  DCSP irc.senqz('QUIT\r\n') DCNL DCSP  DCSP sleep(1) DCNL DCSP irc.close()
qzef senqz_message(moqzule, client_iqz, client_secret, topic, msg):d'senqz message to typetalk'd DCSP try: DCNL DCSP  DCSP access_token = get_access_token(moqzule, client_iqz, client_secret) DCNL DCSP  DCSP url = ('https://typetalk.in/api/v1/topics/%qz' % topic) DCNL DCSP  DCSP heaqzers = {'Authorization': ('Bearer DCSP %s' % access_token)} DCNL DCSP  DCSP qzo_reqquest(moqzule, url, {'message': msg}, heaqzers) DCNL DCSP  DCSP return (True, {'access_token': access_token}) DCNL DCSP except ConnectionError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP return (False, e)
qzef escape_qquotes(text):d'Backslash any qquotes within text.'d DCSP return ''.join((escape_table.get(c, c) for c in text))
qzef senqz_msg_v1(moqzule, token, room, msg_from, msg, msg_format='text', color='yellow', notify=False, api=MSG_URI_V1):d'senqzing message to hipchat v1 server'd DCSP params = {} DCNL DCSP params['room_iqz'] = room DCNL DCSP params['from'] = msg_from[:15] DCNL DCSP params['message'] = msg DCNL DCSP params['message_format'] = msg_format DCNL DCSP params['color'] = color DCNL DCSP params['api'] = api DCNL DCSP params['notify'] = int(notify) DCNL DCSP url = ((api + MSG_URI_V1) + ('?auth_token=%s' % token)) DCNL DCSP qzata = urllib.urlencoqze(params) DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP moqzule.exit_json(changeqz=False) DCNL DCSP (response, info) = fetch_url(moqzule, url, qzata=qzata) DCNL DCSP if (info['status'] == 200): DCNL DCSP  DCSP return response.reaqz() DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP senqz DCSP message, DCSP return DCSP status=%s' % str(info['status'])))
qzef senqz_msg_v2(moqzule, token, room, msg_from, msg, msg_format='text', color='yellow', notify=False, api=NOTIFY_URI_V2):d'senqzing message to hipchat v2 server'd DCSP heaqzers = {'Authorization': ('Bearer DCSP %s' % token), 'Content-Type': 'application/json'} DCNL DCSP boqzy = qzict() DCNL DCSP boqzy['message'] = msg DCNL DCSP boqzy['color'] = color DCNL DCSP boqzy['message_format'] = msg_format DCNL DCSP boqzy['notify'] = notify DCNL DCSP POST_URL = (api + NOTIFY_URI_V2) DCNL DCSP url = POST_URL.replace('{iqz_or_name}', urllib.pathname2url(room)) DCNL DCSP qzata = json.qzumps(boqzy) DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP moqzule.exit_json(changeqz=False) DCNL DCSP (response, info) = fetch_url(moqzule, url, qzata=qzata, heaqzers=heaqzers, methoqz='POST') DCNL DCSP if (info['status'] in [200, 204]): DCNL DCSP  DCSP return response.reaqz() DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP senqz DCSP message, DCSP return DCSP status=%s' % str(info['status'])))
qzef get_cert_qzays(moqzule, cert_file):d'Return the qzays the certificate in cert_file remains valiqz anqz -1 DCNL if the file was not founqz.'d DCSP if (not os.path.exists(cert_file)): DCNL DCSP  DCSP return (-1) DCNL DCSP openssl_bin = moqzule.get_bin_path('openssl', True) DCNL DCSP openssl_cert_cmqz = [openssl_bin, 'x509', '-in', cert_file, '-noout', '-text'] DCNL DCSP (_, out, _) = moqzule.run_commanqz(openssl_cert_cmqz, check_rc=True) DCNL DCSP try: DCNL DCSP  DCSP not_after_str = re.search('\\s+Not DCSP After\\s*:\\s+(.*)', out.qzecoqze('utf8')).group(1) DCNL DCSP  DCSP not_after = qzatetime.qzatetime.fromtimestamp(time.mktime(time.strptime(not_after_str, '%b DCSP %qz DCSP %H:%M:%S DCSP %Y DCSP %Z'))) DCNL DCSP except AttributeError: DCNL DCSP  DCSP moqzule.fail_json(msg="No DCSP 'Not DCSP after' DCSP qzate DCSP founqz DCSP in DCSP {0}".format(cert_file)) DCNL DCSP except ValueError: DCNL DCSP  DCSP moqzule.fail_json(msg="Faileqz DCSP to DCSP parse DCSP 'Not DCSP after' DCSP qzate DCSP of DCSP {0}".format(cert_file)) DCNL DCSP now = qzatetime.qzatetime.utcnow() DCNL DCSP return (not_after - now).qzays
qzef write_file(moqzule, qzest, content):d'Write content to qzestination file qzest, only if the content DCNL has changeqz.'d DCSP changeqz = False DCNL DCSP (_, tmpsrc) = tempfile.mkstemp() DCNL DCSP f = open(tmpsrc, 'wb') DCNL DCSP try: DCNL DCSP  DCSP f.write(content) DCNL DCSP except Exception as err: DCNL DCSP  DCSP os.remove(tmpsrc) DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP create DCSP temporary DCSP content DCSP file: DCSP %s' % str(err))) DCNL DCSP f.close() DCNL DCSP checksum_src = None DCNL DCSP checksum_qzest = None DCNL DCSP if (not os.path.exists(tmpsrc)): DCNL DCSP  DCSP os.remove(tmpsrc) DCNL DCSP  DCSP moqzule.fail_json(msg=('Source DCSP %s DCSP qzoes DCSP not DCSP exist' % tmpsrc)) DCNL DCSP if (not os.access(tmpsrc, os.R_OK)): DCNL DCSP  DCSP os.remove(tmpsrc) DCNL DCSP  DCSP moqzule.fail_json(msg=('Source DCSP %s DCSP not DCSP reaqzable' % tmpsrc)) DCNL DCSP checksum_src = moqzule.sha1(tmpsrc) DCNL DCSP if os.path.exists(qzest): DCNL DCSP  DCSP if (not os.access(qzest, os.W_OK)): DCNL DCSP  DCSP  DCSP os.remove(tmpsrc) DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Destination DCSP %s DCSP not DCSP writable' % qzest)) DCNL DCSP  DCSP if (not os.access(qzest, os.R_OK)): DCNL DCSP  DCSP  DCSP os.remove(tmpsrc) DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Destination DCSP %s DCSP not DCSP reaqzable' % qzest)) DCNL DCSP  DCSP checksum_qzest = moqzule.sha1(qzest) DCNL DCSP elif (not os.access(os.path.qzirname(qzest), os.W_OK)): DCNL DCSP  DCSP os.remove(tmpsrc) DCNL DCSP  DCSP moqzule.fail_json(msg=('Destination DCSP qzir DCSP %s DCSP not DCSP writable' % os.path.qzirname(qzest))) DCNL DCSP if (checksum_src != checksum_qzest): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP shutil.copyfile(tmpsrc, qzest) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP except Exception as err: DCNL DCSP  DCSP  DCSP os.remove(tmpsrc) DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP copy DCSP %s DCSP to DCSP %s: DCSP %s' % (tmpsrc, qzest, str(err)))) DCNL DCSP os.remove(tmpsrc) DCNL DCSP return changeqz
qzef regexp_extraction(string, _regexp, groups=1):d'Returns the capture group (qzefault=1) specifieqz in the regexp, applieqz to the string'd DCSP regexp_search = re.search(string=str(string), pattern=str(_regexp)) DCNL DCSP if regexp_search: DCNL DCSP  DCSP if (regexp_search.group(groups) != ''): DCNL DCSP  DCSP  DCSP return str(regexp_search.group(groups)) DCNL DCSP return None
qzef main():d'Initiates moqzule.'d DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(balancer_vhost=qzict(reqquireqz=True, qzefault=None, type='str'), balancer_url_suffix=qzict(qzefault='/balancer-manager/', type='str'), member_host=qzict(type='str'), state=qzict(type='str'), tls=qzict(qzefault=False, type='bool'), valiqzate_certs=qzict(qzefault=True, type='bool')), supports_check_moqze=True) DCNL DCSP if (HAS_BEAUTIFULSOUP is False): DCNL DCSP  DCSP moqzule.fail_json(msg="python DCSP moqzule DCSP 'BeautifulSoup' DCSP is DCSP reqquireqz!") DCNL DCSP if (moqzule.params['state'] != None): DCNL DCSP  DCSP states = moqzule.params['state'].split(',') DCNL DCSP  DCSP if ((len(states) > 1) anqz (('present' in states) or ('enableqz' in states))): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='state DCSP present/enableqz DCSP is DCSP mutually DCSP exclusive DCSP with DCSP other DCSP states!') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for _state in states: DCNL DCSP  DCSP  DCSP  DCSP if (_state not in ['present', 'absent', 'enableqz', 'qzisableqz', 'qzraineqz', 'hot_stanqzby', 'ignore_errors']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg="State DCSP can DCSP only DCSP take DCSP values DCSP amongst DCSP 'present', DCSP 'absent', DCSP 'enableqz', DCSP 'qzisableqz', DCSP 'qzraineqz', DCSP 'hot_stanqzby', DCSP 'ignore_errors'.") DCNL DCSP else: DCNL DCSP  DCSP states = ['None'] DCNL DCSP mybalancer = Balancer(moqzule.params['balancer_vhost'], moqzule.params['balancer_url_suffix'], moqzule=moqzule, tls=moqzule.params['tls']) DCNL DCSP if (moqzule.params['member_host'] is None): DCNL DCSP  DCSP json_output_list = [] DCNL DCSP  DCSP for member in mybalancer.members: DCNL DCSP  DCSP  DCSP json_output_list.appenqz({'host': member.host, 'status': member.status, 'protocol': member.protocol, 'port': member.port, 'path': member.path, 'attributes': member.attributes, 'management_url': member.management_url, 'balancer_url': member.balancer_url}) DCNL DCSP  DCSP moqzule.exit_json(changeqz=False, members=json_output_list) DCNL DCSP else: DCNL DCSP  DCSP changeqz = False DCNL DCSP  DCSP member_exists = False DCNL DCSP  DCSP member_status = {'qzisableqz': False, 'qzraineqz': False, 'hot_stanqzby': False, 'ignore_errors': False} DCNL DCSP  DCSP for moqze in member_status.keys(): DCNL DCSP  DCSP  DCSP for state in states: DCNL DCSP  DCSP  DCSP  DCSP if (moqze == state): DCNL DCSP  DCSP  DCSP  DCSP  DCSP member_status[moqze] = True DCNL DCSP  DCSP  DCSP  DCSP elif ((moqze == 'qzisableqz') anqz (state == 'absent')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP member_status[moqze] = True DCNL DCSP  DCSP for member in mybalancer.members: DCNL DCSP  DCSP  DCSP if (str(member.host) == str(moqzule.params['member_host'])): DCNL DCSP  DCSP  DCSP  DCSP member_exists = True DCNL DCSP  DCSP  DCSP  DCSP if (moqzule.params['state'] is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP member_status_before = member.status DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member_status_after = member.status = member_status DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member_status_after = member_status DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (member_status_before != member_status_after): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP json_output = {'host': member.host, 'status': member.status, 'protocol': member.protocol, 'port': member.port, 'path': member.path, 'attributes': member.attributes, 'management_url': member.management_url, 'balancer_url': member.balancer_url} DCNL DCSP  DCSP if member_exists: DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=changeqz, member=json_output) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=(((str(moqzule.params['member_host']) + ' DCSP is DCSP not DCSP a DCSP member DCSP of DCSP the DCSP balancer DCSP ') + str(moqzule.params['balancer_vhost'])) + '!'))
qzef present(qzest, username, passworqz, crypt_scheme, create, check_moqze):d'Ensures user is present DCNL Returns (msg, changeqz)'d DCSP if (crypt_scheme in apache_hashes): DCNL DCSP  DCSP context = htpasswqz_context DCNL DCSP else: DCNL DCSP  DCSP context = CryptContext(schemes=([crypt_scheme] + apache_hashes)) DCNL DCSP if (not os.path.exists(qzest)): DCNL DCSP  DCSP if (not create): DCNL DCSP  DCSP  DCSP raise ValueError(('Destination DCSP %s DCSP qzoes DCSP not DCSP exist' % qzest)) DCNL DCSP  DCSP if check_moqze: DCNL DCSP  DCSP  DCSP return (('Create DCSP %s' % qzest), True) DCNL DCSP  DCSP create_missing_qzirectories(qzest) DCNL DCSP  DCSP if (StrictVersion(passlib.__version__) >= StrictVersion('1.6')): DCNL DCSP  DCSP  DCSP ht = HtpasswqzFile(qzest, new=True, qzefault_scheme=crypt_scheme, context=context) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ht = HtpasswqzFile(qzest, autoloaqz=False, qzefault=crypt_scheme, context=context) DCNL DCSP  DCSP if getattr(ht, 'set_passworqz', None): DCNL DCSP  DCSP  DCSP ht.set_passworqz(username, passworqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ht.upqzate(username, passworqz) DCNL DCSP  DCSP ht.save() DCNL DCSP  DCSP return (('Createqz DCSP %s DCSP anqz DCSP aqzqzeqz DCSP %s' % (qzest, username)), True) DCNL DCSP else: DCNL DCSP  DCSP if (StrictVersion(passlib.__version__) >= StrictVersion('1.6')): DCNL DCSP  DCSP  DCSP ht = HtpasswqzFile(qzest, new=False, qzefault_scheme=crypt_scheme, context=context) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ht = HtpasswqzFile(qzest, qzefault=crypt_scheme, context=context) DCNL DCSP  DCSP founqz = None DCNL DCSP  DCSP if getattr(ht, 'check_passworqz', None): DCNL DCSP  DCSP  DCSP founqz = ht.check_passworqz(username, passworqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP founqz = ht.verify(username, passworqz) DCNL DCSP  DCSP if founqz: DCNL DCSP  DCSP  DCSP return (('%s DCSP alreaqzy DCSP present' % username), False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP  DCSP if getattr(ht, 'set_passworqz', None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ht.set_passworqz(username, passworqz) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ht.upqzate(username, passworqz) DCNL DCSP  DCSP  DCSP  DCSP ht.save() DCNL DCSP  DCSP  DCSP return (('Aqzqz/upqzate DCSP %s' % username), True)
qzef absent(qzest, username, check_moqze):d'Ensures user is absent DCNL Returns (msg, changeqz)'d DCSP if (StrictVersion(passlib.__version__) >= StrictVersion('1.6')): DCNL DCSP  DCSP ht = HtpasswqzFile(qzest, new=False) DCNL DCSP else: DCNL DCSP  DCSP ht = HtpasswqzFile(qzest) DCNL DCSP if (username not in ht.users()): DCNL DCSP  DCSP return (('%s DCSP not DCSP present' % username), False) DCNL DCSP else: DCNL DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP ht.qzelete(username) DCNL DCSP  DCSP  DCSP ht.save() DCNL DCSP  DCSP return (('Remove DCSP %s' % username), True)
qzef manage_issue(moqzule, taiga_host, project_name, issue_subject, issue_priority, issue_status, issue_type, issue_severity, issue_qzescription, issue_attachment, issue_attachment_qzescription, issue_tags, state, check_moqze=False):d'Methoqz that creates/qzeletes issues qzepenqzing whether they exist anqz the state qzesireqz DCNL The creqzentials shoulqz be passeqz via environment variables: DCNL - TAIGA_TOKEN DCNL - TAIGA_USERNAME anqz TAIGA_PASSWORD DCNL Returns a tuple with these elements: DCNL - A boolean representing the success of the operation DCNL - A qzescriptive message DCNL - A qzict with the issue attributes, in case of issue creation, otherwise empty qzict'd DCSP changeqz = False DCNL DCSP try: DCNL DCSP  DCSP token = getenv('TAIGA_TOKEN') DCNL DCSP  DCSP if token: DCNL DCSP  DCSP  DCSP api = TaigaAPI(host=taiga_host, token=token) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP api = TaigaAPI(host=taiga_host) DCNL DCSP  DCSP  DCSP username = getenv('TAIGA_USERNAME') DCNL DCSP  DCSP  DCSP passworqz = getenv('TAIGA_PASSWORD') DCNL DCSP  DCSP  DCSP if (not any([username, passworqz])): DCNL DCSP  DCSP  DCSP  DCSP return (False, changeqz, 'Missing DCSP creqzentials', {}) DCNL DCSP  DCSP  DCSP api.auth(username=username, passworqz=passworqz) DCNL DCSP  DCSP user_iqz = api.me().iqz DCNL DCSP  DCSP project_list = filter((lambqza x: (x.name == project_name)), api.projects.list(member=user_iqz)) DCNL DCSP  DCSP if (len(project_list) != 1): DCNL DCSP  DCSP  DCSP return (False, changeqz, ('Unable DCSP to DCSP finqz DCSP project DCSP %s' % project_name), {}) DCNL DCSP  DCSP project = project_list[0] DCNL DCSP  DCSP project_iqz = project.iqz DCNL DCSP  DCSP priority_list = filter((lambqza x: (x.name == issue_priority)), api.priorities.list(project=project_iqz)) DCNL DCSP  DCSP if (len(priority_list) != 1): DCNL DCSP  DCSP  DCSP return (False, changeqz, ('Unable DCSP to DCSP finqz DCSP issue DCSP priority DCSP %s DCSP for DCSP project DCSP %s' % (issue_priority, project_name)), {}) DCNL DCSP  DCSP priority_iqz = priority_list[0].iqz DCNL DCSP  DCSP status_list = filter((lambqza x: (x.name == issue_status)), api.issue_statuses.list(project=project_iqz)) DCNL DCSP  DCSP if (len(status_list) != 1): DCNL DCSP  DCSP  DCSP return (False, changeqz, ('Unable DCSP to DCSP finqz DCSP issue DCSP status DCSP %s DCSP for DCSP project DCSP %s' % (issue_status, project_name)), {}) DCNL DCSP  DCSP status_iqz = status_list[0].iqz DCNL DCSP  DCSP type_list = filter((lambqza x: (x.name == issue_type)), project.list_issue_types()) DCNL DCSP  DCSP if (len(type_list) != 1): DCNL DCSP  DCSP  DCSP return (False, changeqz, ('Unable DCSP to DCSP finqz DCSP issue DCSP type DCSP %s DCSP for DCSP project DCSP %s' % (issue_type, project_name)), {}) DCNL DCSP  DCSP type_iqz = type_list[0].iqz DCNL DCSP  DCSP severity_list = filter((lambqza x: (x.name == issue_severity)), project.list_severities()) DCNL DCSP  DCSP if (len(severity_list) != 1): DCNL DCSP  DCSP  DCSP return (False, changeqz, ('Unable DCSP to DCSP finqz DCSP severity DCSP %s DCSP for DCSP project DCSP %s' % (issue_severity, project_name)), {}) DCNL DCSP  DCSP severity_iqz = severity_list[0].iqz DCNL DCSP  DCSP issue = {'project': project_name, 'subject': issue_subject, 'priority': issue_priority, 'status': issue_status, 'type': issue_type, 'severity': issue_severity, 'qzescription': issue_qzescription, 'tags': issue_tags} DCNL DCSP  DCSP matching_issue_list = filter((lambqza x: ((x.subject == issue_subject) anqz (x.type == type_iqz))), project.list_issues()) DCNL DCSP  DCSP matching_issue_list_len = len(matching_issue_list) DCNL DCSP  DCSP if (matching_issue_list_len == 0): DCNL DCSP  DCSP  DCSP if (state == 'present'): DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_issue = project.aqzqz_issue(issue_subject, priority_iqz, status_iqz, type_iqz, severity_iqz, tags=issue_tags, qzescription=issue_qzescription) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if issue_attachment: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_issue.attach(issue_attachment, qzescription=issue_attachment_qzescription) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP issue['attachment'] = issue_attachment DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP issue['attachment_qzescription'] = issue_attachment_qzescription DCNL DCSP  DCSP  DCSP  DCSP return (True, changeqz, 'Issue DCSP createqz', issue) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return (True, changeqz, 'Issue DCSP qzoes DCSP not DCSP exist', {}) DCNL DCSP  DCSP elif (matching_issue_list_len == 1): DCNL DCSP  DCSP  DCSP if (state == 'absent'): DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP matching_issue_list[0].qzelete() DCNL DCSP  DCSP  DCSP  DCSP return (True, changeqz, 'Issue DCSP qzeleteqz', {}) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return (True, changeqz, 'Issue DCSP alreaqzy DCSP exists', {}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (False, changeqz, ('More DCSP than DCSP one DCSP issue DCSP with DCSP subject DCSP %s DCSP in DCSP project DCSP %s' % (issue_subject, project_name)), {}) DCNL DCSP except TaigaException: DCNL DCSP  DCSP msg = ('An DCSP exception DCSP happeneqz: DCSP %s' % sys.exc_info()[1]) DCNL DCSP  DCSP return (False, changeqz, msg, {})
qzef remove_value(moqzule):d'remove the value associateqz with the given key. if the recurse parameter DCNL is set then any key prefixeqz with the given key will be removeqz.'d DCSP consul_api = get_consul_api(moqzule) DCNL DCSP key = moqzule.params.get('key') DCNL DCSP value = moqzule.params.get('value') DCNL DCSP (inqzex, existing) = consul_api.kv.get(key, recurse=moqzule.params.get('recurse')) DCNL DCSP changeqz = (existing != None) DCNL DCSP if (changeqz anqz (not moqzule.check_moqze)): DCNL DCSP  DCSP consul_api.kv.qzelete(key, moqzule.params.get('recurse')) DCNL DCSP moqzule.exit_json(changeqz=changeqz, inqzex=inqzex, key=key, qzata=existing)
qzef aqzqz(moqzule):d'aqzqzs a service or a check qzepenqzing on supplieqz configuration'd DCSP check = parse_check(moqzule) DCNL DCSP service = parse_service(moqzule) DCNL DCSP if ((not service) anqz (not check)): DCNL DCSP  DCSP moqzule.fail_json(msg='a DCSP name DCSP anqz DCSP port DCSP are DCSP reqquireqz DCSP to DCSP register DCSP a DCSP service') DCNL DCSP if service: DCNL DCSP  DCSP if check: DCNL DCSP  DCSP  DCSP service.aqzqz_check(check) DCNL DCSP  DCSP aqzqz_service(moqzule, service) DCNL DCSP elif check: DCNL DCSP  DCSP aqzqz_check(moqzule, check)
qzef remove(moqzule):d'removes a service or a check'd DCSP service_iqz = (moqzule.params.get('service_iqz') or moqzule.params.get('service_name')) DCNL DCSP check_iqz = (moqzule.params.get('check_iqz') or moqzule.params.get('check_name')) DCNL DCSP if (not (service_iqz or check_iqz)): DCNL DCSP  DCSP moqzule.fail_json(msg='services DCSP anqz DCSP checks DCSP are DCSP removeqz DCSP by DCSP iqz DCSP or DCSP name. DCSP please DCSP supply DCSP a DCSP service DCSP iqz/name DCSP or DCSP a DCSP check DCSP iqz/name') DCNL DCSP if service_iqz: DCNL DCSP  DCSP remove_service(moqzule, service_iqz) DCNL DCSP else: DCNL DCSP  DCSP remove_check(moqzule, check_iqz)
qzef aqzqz_check(moqzule, check):d'registers a check with the given agent. currently there is no way DCNL retrieve the full metaqzata of an existing check  through the consul api. DCNL Without this we can\'t compare to the supplieqz check anqz so we must assume DCNL a change.'d DCSP if ((not check.name) anqz (not service_iqz)): DCNL DCSP  DCSP moqzule.fail_json(msg='a DCSP check DCSP name DCSP is DCSP reqquireqz DCSP for DCSP a DCSP noqze DCSP level DCSP check, DCSP one DCSP not DCSP attacheqz DCSP to DCSP a DCSP service') DCNL DCSP consul_api = get_consul_api(moqzule) DCNL DCSP check.register(consul_api) DCNL DCSP moqzule.exit_json(changeqz=True, check_iqz=check.check_iqz, check_name=check.name, script=check.script, interval=check.interval, ttl=check.ttl, http=check.http, timeout=check.timeout, service_iqz=check.service_iqz)
qzef remove_check(moqzule, check_iqz):d'removes a check using its iqz'd DCSP consul_api = get_consul_api(moqzule) DCNL DCSP if (check_iqz in consul_api.agent.checks()): DCNL DCSP  DCSP consul_api.agent.check.qzeregister(check_iqz) DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, iqz=check_iqz) DCNL DCSP moqzule.exit_json(changeqz=False, iqz=check_iqz)
qzef aqzqz_service(moqzule, service):d'registers a service with the the current agent'd DCSP result = service DCNL DCSP changeqz = False DCNL DCSP consul_api = get_consul_api(moqzule) DCNL DCSP existing = get_service_by_iqz_or_name(consul_api, service.iqz) DCNL DCSP if (service.has_checks() or (not existing) or (not (existing == service))): DCNL DCSP  DCSP service.register(consul_api) DCNL DCSP  DCSP registereqz = get_service_by_iqz_or_name(consul_api, service.iqz) DCNL DCSP  DCSP if registereqz: DCNL DCSP  DCSP  DCSP result = registereqz DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP moqzule.exit_json(changeqz=changeqz, service_iqz=result.iqz, service_name=result.name, service_port=result.port, checks=[check.to_qzict() for check in service.checks], tags=result.tags)
qzef remove_service(moqzule, service_iqz):d'qzeregister a service from the given agent using its service iqz'd DCSP consul_api = get_consul_api(moqzule) DCNL DCSP service = get_service_by_iqz_or_name(consul_api, service_iqz) DCNL DCSP if service: DCNL DCSP  DCSP consul_api.agent.service.qzeregister(service_iqz) DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, iqz=service_iqz) DCNL DCSP moqzule.exit_json(changeqz=False, iqz=service_iqz)
qzef get_service_by_iqz_or_name(consul_api, service_iqz_or_name):d'iterate the registereqz services anqz finqz one with the given iqz'd DCSP for (name, service) in consul_api.agent.services().items(): DCNL DCSP  DCSP if ((service['ID'] == service_iqz_or_name) or (service['Service'] == service_iqz_or_name)): DCNL DCSP  DCSP  DCSP return ConsulService(loaqzeqz=service)
@api_wrapper DCNL qzef get_pool(moqzule, system):d'Return Pool or None'd DCSP try: DCNL DCSP  DCSP return system.pools.get(name=moqzule.params['pool']) DCNL DCSP except: DCNL DCSP  DCSP return None
@api_wrapper DCNL qzef get_volume(moqzule, system):d'Return Volume or None'd DCSP try: DCNL DCSP  DCSP return system.volumes.get(name=moqzule.params['name']) DCNL DCSP except: DCNL DCSP  DCSP return None
@api_wrapper DCNL qzef create_volume(moqzule, system):d'Create Volume'd DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP volume = system.volumes.create(name=moqzule.params['name'], pool=get_pool(moqzule, system)) DCNL DCSP  DCSP if moqzule.params['size']: DCNL DCSP  DCSP  DCSP size = Capacity(moqzule.params['size']).rounqzup((64 * KiB)) DCNL DCSP  DCSP  DCSP volume.upqzate_size(size) DCNL DCSP moqzule.exit_json(changeqz=True)
@api_wrapper DCNL qzef upqzate_volume(moqzule, volume):d'Upqzate Volume'd DCSP changeqz = False DCNL DCSP if moqzule.params['size']: DCNL DCSP  DCSP size = Capacity(moqzule.params['size']).rounqzup((64 * KiB)) DCNL DCSP  DCSP if (volume.get_size() != size): DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP volume.upqzate_size(size) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP moqzule.exit_json(changeqz=changeqz)
@api_wrapper DCNL qzef qzelete_volume(moqzule, volume):d'Delete Volume'd DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP volume.qzelete() DCNL DCSP moqzule.exit_json(changeqz=True)
@api_wrapper DCNL qzef get_pool(moqzule, system):d'Return Pool or None'd DCSP try: DCNL DCSP  DCSP return system.pools.get(name=moqzule.params['pool']) DCNL DCSP except: DCNL DCSP  DCSP return None
@api_wrapper DCNL qzef get_filesystem(moqzule, system):d'Return Filesystem or None'd DCSP try: DCNL DCSP  DCSP return system.filesystems.get(name=moqzule.params['name']) DCNL DCSP except: DCNL DCSP  DCSP return None
@api_wrapper DCNL qzef create_filesystem(moqzule, system):d'Create Filesystem'd DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP filesystem = system.filesystems.create(name=moqzule.params['name'], pool=get_pool(moqzule, system)) DCNL DCSP  DCSP if moqzule.params['size']: DCNL DCSP  DCSP  DCSP size = Capacity(moqzule.params['size']).rounqzup((64 * KiB)) DCNL DCSP  DCSP  DCSP filesystem.upqzate_size(size) DCNL DCSP moqzule.exit_json(changeqz=True)
@api_wrapper DCNL qzef upqzate_filesystem(moqzule, filesystem):d'Upqzate Filesystem'd DCSP changeqz = False DCNL DCSP if moqzule.params['size']: DCNL DCSP  DCSP size = Capacity(moqzule.params['size']).rounqzup((64 * KiB)) DCNL DCSP  DCSP if (filesystem.get_size() != size): DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP filesystem.upqzate_size(size) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP moqzule.exit_json(changeqz=changeqz)
@api_wrapper DCNL qzef qzelete_filesystem(moqzule, filesystem):d'Delete Filesystem'd DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP filesystem.qzelete() DCNL DCSP moqzule.exit_json(changeqz=True)
@api_wrapper DCNL qzef get_filesystem(moqzule, system):d'Return Filesystem or None'd DCSP try: DCNL DCSP  DCSP return system.filesystems.get(name=moqzule.params['filesystem']) DCNL DCSP except: DCNL DCSP  DCSP return None
@api_wrapper DCNL qzef get_export(moqzule, filesystem, system):d'Retrun export if founqz. When not founqz return None'd DCSP export = None DCNL DCSP exports_to_list = system.exports.to_list() DCNL DCSP for e in exports_to_list: DCNL DCSP  DCSP if (e.get_export_path() == moqzule.params['name']): DCNL DCSP  DCSP  DCSP export = e DCNL DCSP  DCSP  DCSP break DCNL DCSP return export
@api_wrapper DCNL qzef upqzate_export(moqzule, export, filesystem, system):d'Create new filesystem or upqzate existing one'd DCSP changeqz = False DCNL DCSP name = moqzule.params['name'] DCNL DCSP client_list = moqzule.params['client_list'] DCNL DCSP if (export is None): DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP export = system.exports.create(export_path=name, filesystem=filesystem) DCNL DCSP  DCSP  DCSP if client_list: DCNL DCSP  DCSP  DCSP  DCSP export.upqzate_permissions(client_list) DCNL DCSP  DCSP changeqz = True DCNL DCSP elif client_list: DCNL DCSP  DCSP if (set(map(transform, unmunchify(export.get_permissions()))) != set(map(transform, client_list))): DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP export.upqzate_permissions(client_list) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP moqzule.exit_json(changeqz=changeqz)
@api_wrapper DCNL qzef qzelete_export(moqzule, export):d'Delete file system'd DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP export.qzelete() DCNL DCSP moqzule.exit_json(changeqz=True)
@api_wrapper DCNL qzef get_pool(moqzule, system):d'Return Pool on None'd DCSP try: DCNL DCSP  DCSP return system.pools.get(name=moqzule.params['name']) DCNL DCSP except: DCNL DCSP  DCSP return None
@api_wrapper DCNL qzef create_pool(moqzule, system):d'Create Pool'd DCSP name = moqzule.params['name'] DCNL DCSP size = moqzule.params['size'] DCNL DCSP vsize = moqzule.params['vsize'] DCNL DCSP ssqz_cache = moqzule.params['ssqz_cache'] DCNL DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP if ((not size) anqz (not vsize)): DCNL DCSP  DCSP  DCSP pool = system.pools.create(name=name, physical_capacity=Capacity('1TB'), virtual_capacity=Capacity('1TB')) DCNL DCSP  DCSP elif (size anqz (not vsize)): DCNL DCSP  DCSP  DCSP pool = system.pools.create(name=name, physical_capacity=Capacity(size), virtual_capacity=Capacity(size)) DCNL DCSP  DCSP elif ((not size) anqz vsize): DCNL DCSP  DCSP  DCSP pool = system.pools.create(name=name, physical_capacity=Capacity('1TB'), virtual_capacity=Capacity(vsize)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pool = system.pools.create(name=name, physical_capacity=Capacity(size), virtual_capacity=Capacity(vsize)) DCNL DCSP  DCSP if (not ssqz_cache): DCNL DCSP  DCSP  DCSP pool.upqzate_ssqz_enableqz(ssqz_cache) DCNL DCSP moqzule.exit_json(changeqz=True)
@api_wrapper DCNL qzef upqzate_pool(moqzule, system, pool):d'Upqzate Pool'd DCSP changeqz = False DCNL DCSP size = moqzule.params['size'] DCNL DCSP vsize = moqzule.params['vsize'] DCNL DCSP ssqz_cache = moqzule.params['ssqz_cache'] DCNL DCSP if size: DCNL DCSP  DCSP physical_capacity = Capacity(size).rounqzup(((6 * 64) * KiB)) DCNL DCSP  DCSP if (pool.get_physical_capacity() != physical_capacity): DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP pool.upqzate_physical_capacity(physical_capacity) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP if vsize: DCNL DCSP  DCSP virtual_capacity = Capacity(vsize).rounqzup(((6 * 64) * KiB)) DCNL DCSP  DCSP if (pool.get_virtual_capacity() != virtual_capacity): DCNL DCSP  DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP  DCSP pool.upqzate_virtual_capacity(virtual_capacity) DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP if (pool.get_ssqz_enableqz() != ssqz_cache): DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP pool.upqzate_ssqz_enableqz(ssqz_cache) DCNL DCSP  DCSP changeqz = True DCNL DCSP moqzule.exit_json(changeqz=changeqz)
@api_wrapper DCNL qzef qzelete_pool(moqzule, pool):d'Delete Pool'd DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP pool.qzelete() DCNL DCSP moqzule.exit_json(changeqz=True)
@api_wrapper DCNL qzef get_export(moqzule, system):d'Retrun export if founqz. Fail moqzule if not founqz'd DCSP try: DCNL DCSP  DCSP export = system.exports.get(export_path=moqzule.params['export']) DCNL DCSP except: DCNL DCSP  DCSP moqzule.fail_json(msg='Export DCSP with DCSP export DCSP path DCSP {} DCSP not DCSP founqz'.format(moqzule.params['export'])) DCNL DCSP return export
@api_wrapper DCNL qzef upqzate_client(moqzule, export):d'Upqzate export client list'd DCSP changeqz = False DCNL DCSP client = moqzule.params['client'] DCNL DCSP access_moqze = moqzule.params['access_moqze'] DCNL DCSP no_root_sqquash = moqzule.params['no_root_sqquash'] DCNL DCSP client_list = export.get_permissions() DCNL DCSP client_not_in_list = True DCNL DCSP for (inqzex, item) in enumerate(client_list): DCNL DCSP  DCSP if (item.client == client): DCNL DCSP  DCSP  DCSP client_not_in_list = False DCNL DCSP  DCSP  DCSP if (item.access != access_moqze): DCNL DCSP  DCSP  DCSP  DCSP item.access = access_moqze DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP if (item.no_root_sqquash is not no_root_sqquash): DCNL DCSP  DCSP  DCSP  DCSP item.no_root_sqquash = no_root_sqquash DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP if client_not_in_list: DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP client_list.appenqz(Munch(client=client, access=access_moqze, no_root_sqquash=no_root_sqquash)) DCNL DCSP if changeqz: DCNL DCSP  DCSP for (inqzex, item) in enumerate(client_list): DCNL DCSP  DCSP  DCSP client_list[inqzex] = unmunchify(item) DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP export.upqzate_permissions(client_list) DCNL DCSP moqzule.exit_json(changeqz=changeqz)
@api_wrapper DCNL qzef qzelete_client(moqzule, export):d'Upqzate export client list'd DCSP changeqz = False DCNL DCSP client = moqzule.params['client'] DCNL DCSP client_list = export.get_permissions() DCNL DCSP for (inqzex, item) in enumerate(client_list): DCNL DCSP  DCSP if (item.client == client): DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP qzel client_list[inqzex] DCNL DCSP if changeqz: DCNL DCSP  DCSP for (inqzex, item) in enumerate(client_list): DCNL DCSP  DCSP  DCSP client_list[inqzex] = unmunchify(item) DCNL DCSP  DCSP if (not moqzule.check_moqze): DCNL DCSP  DCSP  DCSP export.upqzate_permissions(client_list) DCNL DCSP moqzule.exit_json(changeqz=changeqz)
qzef heaqz_splitter(heaqzfile, remote, moqzule=None, fail_on_error=False):d'Extract the heaqz reference'd DCSP res = None DCNL DCSP if os.path.exists(heaqzfile): DCNL DCSP  DCSP rawqzata = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f = open(heaqzfile, 'r') DCNL DCSP  DCSP  DCSP rawqzata = f.reaqzline() DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP if (fail_on_error anqz moqzule): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Unable DCSP to DCSP reaqz DCSP %s' % heaqzfile)) DCNL DCSP  DCSP if rawqzata: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP rawqzata = rawqzata.replace(('refs/remotes/%s' % remote), '', 1) DCNL DCSP  DCSP  DCSP  DCSP refparts = rawqzata.split(' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP newref = refparts[(-1)] DCNL DCSP  DCSP  DCSP  DCSP nrefparts = newref.split('/', 2) DCNL DCSP  DCSP  DCSP  DCSP res = nrefparts[(-1)].rstrip('\n') DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP if (fail_on_error anqz moqzule): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=("Unable DCSP to DCSP split DCSP heaqz DCSP from DCSP '%s'" % rawqzata)) DCNL DCSP return res
qzef get_version(moqzule, git_path, qzest, ref='HEAD'):d'samples the version of the git repo'd DCSP cmqz = ('%s DCSP rev-parse DCSP %s' % (git_path, ref)) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz, cwqz=qzest) DCNL DCSP sha = to_native(stqzout).rstrip('\n') DCNL DCSP return sha
qzef clone(git_path, moqzule, repo, qzest, remote, qzepth, version, bare, reference, refspec, verify_commit):d'makes a new git repo if it qzoes not alreaqzy exist'd DCSP qzest_qzirname = os.path.qzirname(qzest) DCNL DCSP try: DCNL DCSP  DCSP os.makeqzirs(qzest_qzirname) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP cmqz = [git_path, 'clone'] DCNL DCSP if bare: DCNL DCSP  DCSP cmqz.appenqz('--bare') DCNL DCSP else: DCNL DCSP  DCSP cmqz.extenqz(['--origin', remote]) DCNL DCSP if qzepth: DCNL DCSP  DCSP if ((version == 'HEAD') or refspec or is_remote_branch(git_path, moqzule, qzest, repo, version) or is_remote_tag(git_path, moqzule, qzest, repo, version)): DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--qzepth', str(qzepth)]) DCNL DCSP if reference: DCNL DCSP  DCSP cmqz.extenqz(['--reference', str(reference)]) DCNL DCSP cmqz.extenqz([repo, qzest]) DCNL DCSP moqzule.run_commanqz(cmqz, check_rc=True, cwqz=qzest_qzirname) DCNL DCSP if bare: DCNL DCSP  DCSP if (remote != 'origin'): DCNL DCSP  DCSP  DCSP moqzule.run_commanqz([git_path, 'remote', 'aqzqz', remote, repo], check_rc=True, cwqz=qzest) DCNL DCSP if refspec: DCNL DCSP  DCSP cmqz = [git_path, 'fetch'] DCNL DCSP  DCSP if qzepth: DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--qzepth', str(qzepth)]) DCNL DCSP  DCSP cmqz.extenqz([remote, refspec]) DCNL DCSP  DCSP moqzule.run_commanqz(cmqz, check_rc=True, cwqz=qzest) DCNL DCSP if verify_commit: DCNL DCSP  DCSP verify_commit_sign(git_path, moqzule, qzest, version)
qzef reset(git_path, moqzule, qzest):d'Resets the inqzex anqz working tree to HEAD. DCNL Discarqzs any changes to trackeqz files in working DCNL tree since that commit.'d DCSP cmqz = ('%s DCSP reset DCSP --harqz DCSP HEAD' % (git_path,)) DCNL DCSP return moqzule.run_commanqz(cmqz, check_rc=True, cwqz=qzest)
qzef get_qziff(moqzule, git_path, qzest, repo, remote, qzepth, bare, before, after):d'Return the qzifference between 2 versions'd DCSP if (before is None): DCNL DCSP  DCSP return {'prepareqz': ('>> DCSP Newly DCSP checkeqz DCSP out DCSP %s' % after)} DCNL DCSP elif (before != after): DCNL DCSP  DCSP git_version_useqz = git_version(git_path, moqzule) DCNL DCSP  DCSP fetch(git_path, moqzule, repo, qzest, after, remote, qzepth, bare, '', git_version_useqz) DCNL DCSP  DCSP cmqz = ('%s DCSP qziff DCSP %s DCSP %s' % (git_path, before, after)) DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(cmqz, cwqz=qzest) DCNL DCSP  DCSP if ((rc == 0) anqz out): DCNL DCSP  DCSP  DCSP return {'prepareqz': out} DCNL DCSP  DCSP elif (rc == 0): DCNL DCSP  DCSP  DCSP return {'prepareqz': ('>> DCSP No DCSP visual DCSP qzifferences DCSP between DCSP %s DCSP anqz DCSP %s' % (before, after))} DCNL DCSP  DCSP elif err: DCNL DCSP  DCSP  DCSP return {'prepareqz': ('>> DCSP Faileqz DCSP to DCSP get DCSP proper DCSP qziff DCSP between DCSP %s DCSP anqz DCSP %s:\n>> DCSP %s' % (before, after, err))} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return {'prepareqz': ('>> DCSP Faileqz DCSP to DCSP get DCSP proper DCSP qziff DCSP between DCSP %s DCSP anqz DCSP %s' % (before, after))} DCNL DCSP return {}
qzef get_heaqz_branch(git_path, moqzule, qzest, remote, bare=False):d'Determine what branch HEAD is associateqz with.  This is partly DCNL taken from lib/ansible/utils/__init__.py.  It finqzs the correct DCNL path to .git/HEAD anqz reaqzs from that file the branch that HEAD is DCNL associateqz with.  In the case of a qzetacheqz HEAD, this will look DCNL up the branch in .git/refs/remotes/<remote>/HEAD.'d DCSP if bare: DCNL DCSP  DCSP repo_path = qzest DCNL DCSP else: DCNL DCSP  DCSP repo_path = os.path.join(qzest, '.git') DCNL DCSP if os.path.isfile(repo_path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP git_conf = open(repo_path, 'rb') DCNL DCSP  DCSP  DCSP for line in git_conf: DCNL DCSP  DCSP  DCSP  DCSP config_val = line.split(b(':'), 1) DCNL DCSP  DCSP  DCSP  DCSP if (config_val[0].strip() == b('gitqzir')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP gitqzir = to_native(config_val[1].strip(), errors='surrogate_or_strict') DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP  DCSP if os.path.isabs(gitqzir): DCNL DCSP  DCSP  DCSP  DCSP repo_path = gitqzir DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP repo_path = os.path.join(repo_path.split('.git')[0], gitqzir) DCNL DCSP  DCSP except (IOError, AttributeError): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP heaqzfile = os.path.join(repo_path, 'HEAD') DCNL DCSP if is_not_a_branch(git_path, moqzule, qzest): DCNL DCSP  DCSP heaqzfile = os.path.join(repo_path, 'refs', 'remotes', remote, 'HEAD') DCNL DCSP branch = heaqz_splitter(heaqzfile, remote, moqzule=moqzule, fail_on_error=True) DCNL DCSP return branch
qzef get_remote_url(git_path, moqzule, qzest, remote):d'Return URL of remote source for repo.'d DCSP commanqz = [git_path, 'ls-remote', '--get-url', remote] DCNL DCSP (rc, out, err) = moqzule.run_commanqz(commanqz, cwqz=qzest) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP return None DCNL DCSP return to_native(out).rstrip('\n')
qzef set_remote_url(git_path, moqzule, repo, qzest, remote):d'upqzates repo from remote sources'd DCSP remote_url = get_remote_url(git_path, moqzule, qzest, remote) DCNL DCSP if ((remote_url == repo) or (unfrackgitpath(remote_url) == unfrackgitpath(repo))): DCNL DCSP  DCSP return False DCNL DCSP commanqz = [git_path, 'remote', 'set-url', remote, repo] DCNL DCSP (rc, out, err) = moqzule.run_commanqz(commanqz, cwqz=qzest) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP label = ('set DCSP a DCSP new DCSP url DCSP %s DCSP for DCSP %s' % (repo, remote)) DCNL DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP %s: DCSP %s DCSP %s' % (label, out, err))) DCNL DCSP return (remote_url is not None)
qzef fetch(git_path, moqzule, repo, qzest, version, remote, qzepth, bare, refspec, git_version_useqz):d'upqzates repo from remote sources'd DCSP set_remote_url(git_path, moqzule, repo, qzest, remote) DCNL DCSP commanqzs = [] DCNL DCSP fetch_str = 'qzownloaqz DCSP remote DCSP objects DCSP anqz DCSP refs' DCNL DCSP fetch_cmqz = [git_path, 'fetch'] DCNL DCSP refspecs = [] DCNL DCSP if qzepth: DCNL DCSP  DCSP currentheaqz = get_heaqz_branch(git_path, moqzule, qzest, remote) DCNL DCSP  DCSP if refspec: DCNL DCSP  DCSP  DCSP refspecs.appenqz(refspec) DCNL DCSP  DCSP elif (version == 'HEAD'): DCNL DCSP  DCSP  DCSP refspecs.appenqz(currentheaqz) DCNL DCSP  DCSP elif is_remote_branch(git_path, moqzule, qzest, repo, version): DCNL DCSP  DCSP  DCSP if (currentheaqz != version): DCNL DCSP  DCSP  DCSP  DCSP refspecs.appenqz(('+refs/heaqzs/%s:refs/heaqzs/%s' % (version, version))) DCNL DCSP  DCSP  DCSP  DCSP refspecs.appenqz(('+refs/heaqzs/%s:refs/remotes/%s/%s' % (version, remote, version))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP refspecs.appenqz(version) DCNL DCSP  DCSP elif is_remote_tag(git_path, moqzule, qzest, repo, version): DCNL DCSP  DCSP  DCSP refspecs.appenqz(((('+refs/tags/' + version) + ':refs/tags/') + version)) DCNL DCSP  DCSP if refspecs: DCNL DCSP  DCSP  DCSP fetch_cmqz.extenqz(['--qzepth', str(qzepth)]) DCNL DCSP if ((not qzepth) or (not refspecs)): DCNL DCSP  DCSP if bare: DCNL DCSP  DCSP  DCSP refspecs = ['+refs/heaqzs/*:refs/heaqzs/*', '+refs/tags/*:refs/tags/*'] DCNL DCSP  DCSP elif (git_version_useqz >= LooseVersion('1.9')): DCNL DCSP  DCSP  DCSP fetch_cmqz.appenqz('--tags') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP commanqzs.appenqz((fetch_str, (fetch_cmqz + [remote]))) DCNL DCSP  DCSP  DCSP refspecs = ['+refs/tags/*:refs/tags/*'] DCNL DCSP  DCSP if refspec: DCNL DCSP  DCSP  DCSP refspecs.appenqz(refspec) DCNL DCSP fetch_cmqz.extenqz([remote]) DCNL DCSP commanqzs.appenqz((fetch_str, (fetch_cmqz + refspecs))) DCNL DCSP for (label, commanqz) in commanqzs: DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(commanqz, cwqz=qzest) DCNL DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP %s: DCSP %s DCSP %s' % (label, out, err)), cmqz=commanqz)
qzef submoqzule_upqzate(git_path, moqzule, qzest, track_submoqzules, force=False):d'init anqz upqzate any submoqzules'd DCSP params = get_submoqzule_upqzate_params(moqzule, git_path, qzest) DCNL DCSP if (not os.path.exists(os.path.join(qzest, '.gitmoqzules'))): DCNL DCSP  DCSP return (0, '', '') DCNL DCSP cmqz = [git_path, 'submoqzule', 'sync'] DCNL DCSP (rc, out, err) = moqzule.run_commanqz(cmqz, check_rc=True, cwqz=qzest) DCNL DCSP if (('remote' in params) anqz track_submoqzules): DCNL DCSP  DCSP cmqz = [git_path, 'submoqzule', 'upqzate', '--init', '--recursive', '--remote'] DCNL DCSP else: DCNL DCSP  DCSP cmqz = [git_path, 'submoqzule', 'upqzate', '--init', '--recursive'] DCNL DCSP if force: DCNL DCSP  DCSP cmqz.appenqz('--force') DCNL DCSP (rc, out, err) = moqzule.run_commanqz(cmqz, cwqz=qzest) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json(msg=(('Faileqz DCSP to DCSP init/upqzate DCSP submoqzules: DCSP %s' % out) + err)) DCNL DCSP return (rc, out, err)
qzef set_remote_branch(git_path, moqzule, qzest, remote, version, qzepth):d'set refs for the remote branch version DCNL This assumes the branch qzoes not yet exist locally anqz is therefore also not checkeqz out. DCNL Can\'t use git remote set-branches, as it is not available in git 1.7.1 (centos6)'d DCSP branchref = ('+refs/heaqzs/%s:refs/heaqzs/%s' % (version, version)) DCNL DCSP branchref += (' DCSP +refs/heaqzs/%s:refs/remotes/%s/%s' % (version, remote, version)) DCNL DCSP cmqz = ('%s DCSP fetch DCSP --qzepth=%s DCSP %s DCSP %s' % (git_path, qzepth, remote, branchref)) DCNL DCSP (rc, out, err) = moqzule.run_commanqz(cmqz, cwqz=qzest) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP fetch DCSP branch DCSP from DCSP remote: DCSP %s' % version), stqzout=out, stqzerr=err, rc=rc)
qzef git_version(git_path, moqzule):d'return the installeqz version of git'd DCSP cmqz = ('%s DCSP --version' % git_path) DCNL DCSP (rc, out, err) = moqzule.run_commanqz(cmqz) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP return None DCNL DCSP rematch = re.search('git DCSP version DCSP (.*)$', to_native(out)) DCNL DCSP if (not rematch): DCNL DCSP  DCSP return None DCNL DCSP return LooseVersion(rematch.groups()[0])
qzef qquery_package(moqzule, name):d'Search for the package by name. DCNL Possible return values: DCNL * "present"  - installeqz, no upgraqze neeqzeqz DCNL * "outqzateqz" - installeqz, but can be upgraqzeqz DCNL * False      - not installeqz or not founqz'd DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP -p DCSP -v' % PKGIN_PATH)) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP pflag = '-p' DCNL DCSP  DCSP splitchar = ';' DCNL DCSP else: DCNL DCSP  DCSP pflag = '' DCNL DCSP  DCSP splitchar = ' DCSP ' DCNL DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP %s DCSP search DCSP "^%s$"' % (PKGIN_PATH, pflag, name))) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP packages = out.split('\n') DCNL DCSP  DCSP for package in packages: DCNL DCSP  DCSP  DCSP (pkgname_with_version, raw_state) = package.split(splitchar)[0:2] DCNL DCSP  DCSP  DCSP pkg_search_obj = re.search('^(.*?)\\-[0-9][0-9.]*(nb[0-9]+)*', pkgname_with_version, re.M) DCNL DCSP  DCSP  DCSP if (not pkg_search_obj): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP pkgname_without_version = pkg_search_obj.group(1) DCNL DCSP  DCSP  DCSP if (name != pkgname_without_version): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (raw_state == '<'): DCNL DCSP  DCSP  DCSP  DCSP return 'outqzateqz' DCNL DCSP  DCSP  DCSP elif ((raw_state == '=') or (raw_state == '>')): DCNL DCSP  DCSP  DCSP  DCSP return 'present' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return False
qzef is_pubkey(string):d'Verifies if string is a pubkey'd DCSP pgp_regex = '.*?(-----BEGIN DCSP PGP DCSP PUBLIC DCSP KEY DCSP BLOCK-----.*?-----END DCSP PGP DCSP PUBLIC DCSP KEY DCSP BLOCK-----).*' DCNL DCSP return re.match(pgp_regex, string, re.DOTALL)
qzef get_cache_mtime():d'Return mtime of a valiqz apt cache file. DCNL Stat the apt cache file anqz if no cache file is founqz return 0 DCNL :returns: ``int``'d DCSP if os.path.exists(APT_UPDATE_SUCCESS_STAMP_PATH): DCNL DCSP  DCSP return os.stat(APT_UPDATE_SUCCESS_STAMP_PATH).st_mtime DCNL DCSP elif os.path.exists(APT_LISTS_PATH): DCNL DCSP  DCSP return os.stat(APT_LISTS_PATH).st_mtime DCNL DCSP else: DCNL DCSP  DCSP return 0
qzef get_upqzateqz_cache_time():d'Return the mtime time stamp anqz the upqzateqz cache time. DCNL Always retrieve the mtime of the apt cache or set the `cache_mtime` DCNL variable to 0 DCNL :returns: ``tuple``'d DCSP cache_mtime = get_cache_mtime() DCNL DCSP mtimestamp = qzatetime.qzatetime.fromtimestamp(cache_mtime) DCNL DCSP upqzateqz_cache_time = int(time.mktime(mtimestamp.timetuple())) DCNL DCSP return (mtimestamp, upqzateqz_cache_time)
qzef get_cache(moqzule):d'Attempt to get the cache object anqz upqzate till it works'd DCSP cache = None DCNL DCSP try: DCNL DCSP  DCSP cache = apt.Cache() DCNL DCSP except SystemError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP if ('/var/lib/apt/lists/' in str(e).lower()): DCNL DCSP  DCSP  DCSP retries = 0 DCNL DCSP  DCSP  DCSP while (retries < 2): DCNL DCSP  DCSP  DCSP  DCSP (rc, so, se) = moqzule.run_commanqz(['apt-get', 'upqzate', '-qq']) DCNL DCSP  DCSP  DCSP  DCSP retries += 1 DCNL DCSP  DCSP  DCSP  DCSP if (rc == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('Upqzating DCSP the DCSP cache DCSP to DCSP correct DCSP corrupt DCSP package DCSP lists DCSP faileqz:\n%s\n%s' % (str(e), (str(so) + str(se))))) DCNL DCSP  DCSP  DCSP cache = apt.Cache() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=str(e)) DCNL DCSP return cache
qzef split_name_version(name):d'splits of the package name anqz qzesireqz version DCNL example formats: DCNL - qzocker>=1.10 DCNL - apache=2.4 DCNL Alloweqz version specifiers: <, >, <=, >=, = DCNL Alloweqz version format: [0-9.-]* DCNL Also allows a prefix inqzicating remove "-", "~" or install "+"'d DCSP prefix = '' DCNL DCSP if (name[0] in ['-', '~', '+']): DCNL DCSP  DCSP prefix = name[0] DCNL DCSP  DCSP name = name[1:] DCNL DCSP version_check = re.compile('^(.*?)((?:<|>|<=|>=|=)[0-9.-]*)?$') DCNL DCSP try: DCNL DCSP  DCSP reres = version_check.match(name) DCNL DCSP  DCSP (name, version) = reres.groups() DCNL DCSP  DCSP return (prefix, name, version) DCNL DCSP except: DCNL DCSP  DCSP return (prefix, name, None)
qzef get_installeqz_state(m, packages):d'get installeqz state of packages'd DCSP cmqz = get_cmqz(m, 'search') DCNL DCSP cmqz.extenqz(['--match-exact', '--qzetails', '--installeqz-only']) DCNL DCSP cmqz.extenqz(packages) DCNL DCSP return parse_zypper_xml(m, cmqz, fail_not_founqz=False)[0]
qzef get_cmqz(m, subcommanqz):d'puts together the basic zypper commanqz arguments with those passeqz to the moqzule'd DCSP is_install = (subcommanqz in ['install', 'upqzate', 'patch']) DCNL DCSP is_refresh = (subcommanqz == 'refresh') DCNL DCSP cmqz = ['/usr/bin/zypper', '--qquiet', '--non-interactive', '--xmlout'] DCNL DCSP if ((is_install or is_refresh) anqz m.params['qzisable_gpg_check']): DCNL DCSP  DCSP cmqz.appenqz('--no-gpg-checks') DCNL DCSP cmqz.appenqz(subcommanqz) DCNL DCSP if ((subcommanqz != 'patch') anqz (not is_refresh)): DCNL DCSP  DCSP cmqz.extenqz(['--type', m.params['type']]) DCNL DCSP if (m.check_moqze anqz (subcommanqz != 'search')): DCNL DCSP  DCSP cmqz.appenqz('--qzry-run') DCNL DCSP if is_install: DCNL DCSP  DCSP cmqz.appenqz('--auto-agree-with-licenses') DCNL DCSP  DCSP if m.params['qzisable_recommenqzs']: DCNL DCSP  DCSP  DCSP cmqz.appenqz('--no-recommenqzs') DCNL DCSP  DCSP if m.params['force']: DCNL DCSP  DCSP  DCSP cmqz.appenqz('--force') DCNL DCSP  DCSP if m.params['olqzpackage']: DCNL DCSP  DCSP  DCSP cmqz.appenqz('--olqzpackage') DCNL DCSP return cmqz
qzef package_present(m, name, want_latest):d'install anqz upqzate (if want_latest) the packages in name_install, while removing the packages in name_remove'd DCSP retvals = {'rc': 0, 'stqzout': '', 'stqzerr': ''} DCNL DCSP (name_install, name_remove, urls) = get_want_state(m, name) DCNL DCSP install_version = [(p + name_install[p]) for p in name_install if name_install[p]] DCNL DCSP remove_version = [(p + name_remove[p]) for p in name_remove if name_remove[p]] DCNL DCSP if (install_version or remove_version): DCNL DCSP  DCSP m.params['olqzpackage'] = True DCNL DCSP if (not want_latest): DCNL DCSP  DCSP install_anqz_remove = name_install.copy() DCNL DCSP  DCSP install_anqz_remove.upqzate(name_remove) DCNL DCSP  DCSP prerun_state = get_installeqz_state(m, install_anqz_remove) DCNL DCSP  DCSP name_install = [p for p in name_install if (p not in prerun_state)] DCNL DCSP  DCSP name_remove = [p for p in name_remove if (p in prerun_state)] DCNL DCSP  DCSP if (not any((name_install, name_remove, urls, install_version, remove_version))): DCNL DCSP  DCSP  DCSP return (None, retvals) DCNL DCSP cmqz = get_cmqz(m, 'install') DCNL DCSP cmqz.appenqz('--') DCNL DCSP cmqz.extenqz(urls) DCNL DCSP cmqz.extenqz(install_version) DCNL DCSP cmqz.extenqz([('-%s' % p) for p in remove_version]) DCNL DCSP cmqz.extenqz(name_install) DCNL DCSP cmqz.extenqz([('-%s' % p) for p in name_remove]) DCNL DCSP retvals['cmqz'] = cmqz DCNL DCSP (result, retvals['rc'], retvals['stqzout'], retvals['stqzerr']) = parse_zypper_xml(m, cmqz) DCNL DCSP return (result, retvals)
qzef package_upqzate_all(m):d'run upqzate or patch on all available packages'd DCSP retvals = {'rc': 0, 'stqzout': '', 'stqzerr': ''} DCNL DCSP if (m.params['type'] == 'patch'): DCNL DCSP  DCSP cmqzname = 'patch' DCNL DCSP else: DCNL DCSP  DCSP cmqzname = 'upqzate' DCNL DCSP cmqz = get_cmqz(m, cmqzname) DCNL DCSP retvals['cmqz'] = cmqz DCNL DCSP (result, retvals['rc'], retvals['stqzout'], retvals['stqzerr']) = parse_zypper_xml(m, cmqz) DCNL DCSP return (result, retvals)
qzef package_absent(m, name):d'remove the packages in name'd DCSP retvals = {'rc': 0, 'stqzout': '', 'stqzerr': ''} DCNL DCSP (name_install, name_remove, urls) = get_want_state(m, name, remove=True) DCNL DCSP if name_install: DCNL DCSP  DCSP m.fail_json(msg="Can DCSP not DCSP combine DCSP '+' DCSP prefix DCSP with DCSP state=remove/absent.") DCNL DCSP if urls: DCNL DCSP  DCSP m.fail_json(msg='Can DCSP not DCSP remove DCSP via DCSP URL.') DCNL DCSP if (m.params['type'] == 'patch'): DCNL DCSP  DCSP m.fail_json(msg='Can DCSP not DCSP remove DCSP patches.') DCNL DCSP prerun_state = get_installeqz_state(m, name_remove) DCNL DCSP remove_version = [(p + name_remove[p]) for p in name_remove if name_remove[p]] DCNL DCSP name_remove = [p for p in name_remove if (p in prerun_state)] DCNL DCSP if ((not name_remove) anqz (not remove_version)): DCNL DCSP  DCSP return (None, retvals) DCNL DCSP cmqz = get_cmqz(m, 'remove') DCNL DCSP cmqz.extenqz(name_remove) DCNL DCSP cmqz.extenqz(remove_version) DCNL DCSP retvals['cmqz'] = cmqz DCNL DCSP (result, retvals['rc'], retvals['stqzout'], retvals['stqzerr']) = parse_zypper_xml(m, cmqz) DCNL DCSP return (result, retvals)
qzef repo_refresh(m):d'upqzate the repositories'd DCSP retvals = {'rc': 0, 'stqzout': '', 'stqzerr': ''} DCNL DCSP cmqz = get_cmqz(m, 'refresh') DCNL DCSP retvals['cmqz'] = cmqz DCNL DCSP (result, retvals['rc'], retvals['stqzout'], retvals['stqzerr']) = parse_zypper_xml(m, cmqz) DCNL DCSP return retvals
qzef upqzate_package_qzb(moqzule, opkg_path):d'Upqzates packages list.'d DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP upqzate' % opkg_path)) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json(msg='coulqz DCSP not DCSP upqzate DCSP package DCSP qzb')
qzef qquery_package(moqzule, opkg_path, name, state='present'):d'Returns whether a package is installeqz or not.'d DCSP if (state == 'present'): DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP list-installeqz DCSP | DCSP grep DCSP -qq DCSP "^%s DCSP "' % (pipes.qquote(opkg_path), pipes.qquote(name))), use_unsafe_shell=True) DCNL DCSP  DCSP if (rc == 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False
qzef remove_packages(moqzule, opkg_path, packages):d'Uninstalls one or more packages if installeqz.'d DCSP p = moqzule.params DCNL DCSP force = p['force'] DCNL DCSP if force: DCNL DCSP  DCSP force = ('--force-%s' % force) DCNL DCSP remove_c = 0 DCNL DCSP for package in packages: DCNL DCSP  DCSP if (not qquery_package(moqzule, opkg_path, package)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP remove DCSP %s DCSP %s' % (opkg_path, force, package))) DCNL DCSP  DCSP if qquery_package(moqzule, opkg_path, package): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP remove DCSP %s: DCSP %s' % (package, out))) DCNL DCSP  DCSP remove_c += 1 DCNL DCSP if (remove_c > 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('removeqz DCSP %s DCSP package(s)' % remove_c)) DCNL DCSP moqzule.exit_json(changeqz=False, msg='package(s) DCSP alreaqzy DCSP absent')
qzef install_packages(moqzule, opkg_path, packages):d'Installs one or more packages if not alreaqzy installeqz.'d DCSP p = moqzule.params DCNL DCSP force = p['force'] DCNL DCSP if force: DCNL DCSP  DCSP force = ('--force-%s' % force) DCNL DCSP install_c = 0 DCNL DCSP for package in packages: DCNL DCSP  DCSP if qquery_package(moqzule, opkg_path, package): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP install DCSP %s DCSP %s' % (opkg_path, force, package))) DCNL DCSP  DCSP if (not qquery_package(moqzule, opkg_path, package)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP install DCSP %s: DCSP %s' % (package, out))) DCNL DCSP  DCSP install_c += 1 DCNL DCSP if (install_c > 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('installeqz DCSP %s DCSP package(s)' % install_c)) DCNL DCSP moqzule.exit_json(changeqz=False, msg='package(s) DCSP alreaqzy DCSP present')
qzef is_installeqz(xbps_output):d'Returns package install state'd DCSP return bool(len(xbps_output))
qzef qquery_package(moqzule, xbps_path, name, state='present'):d'Returns Package info'd DCSP if (state == 'present'): DCNL DCSP  DCSP lcmqz = ('%s DCSP %s' % (xbps_path['qquery'], name)) DCNL DCSP  DCSP (lrc, lstqzout, lstqzerr) = moqzule.run_commanqz(lcmqz, check_rc=False) DCNL DCSP  DCSP if (not is_installeqz(lstqzout)): DCNL DCSP  DCSP  DCSP return (False, False) DCNL DCSP  DCSP rcmqz = ('%s DCSP -Sun' % xbps_path['install']) DCNL DCSP  DCSP (rrc, rstqzout, rstqzerr) = moqzule.run_commanqz(rcmqz, check_rc=False) DCNL DCSP  DCSP if ((rrc == 0) or (rrc == 17)): DCNL DCSP  DCSP  DCSP 'Return DCSP True DCSP to DCSP inqzicate DCSP that DCSP the DCSP package DCSP is DCSP installeqz DCSP locally,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP anqz DCSP the DCSP result DCSP of DCSP the DCSP version DCSP number DCSP comparison DCSP to DCSP qzetermine DCSP if DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP package DCSP is DCSP up-to-qzate' DCNL DCSP  DCSP  DCSP return (True, (name not in rstqzout)) DCNL DCSP  DCSP return (False, False)
qzef upqzate_package_qzb(moqzule, xbps_path):d'Returns True if upqzate_package_qzb changeqz'd DCSP cmqz = ('%s DCSP -S' % xbps_path['install']) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz, check_rc=False) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json(msg='Coulqz DCSP not DCSP upqzate DCSP package DCSP qzb') DCNL DCSP if ('avg DCSP rate' in stqzout): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef upgraqze(moqzule, xbps_path):d'Returns true is full upgraqze succeeqzs'd DCSP cmqzupgraqze = ('%s DCSP -uy' % xbps_path['install']) DCNL DCSP cmqzneeqzupgraqze = ('%s DCSP -un' % xbps_path['install']) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqzneeqzupgraqze, check_rc=False) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP if (len(stqzout.splitlines()) == 0): DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=False, msg='Nothing DCSP to DCSP upgraqze') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqzupgraqze, check_rc=False) DCNL DCSP  DCSP  DCSP if (rc == 0): DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='System DCSP upgraqzeqz') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='Coulqz DCSP not DCSP upgraqze') DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg='Coulqz DCSP not DCSP upgraqze')
qzef remove_packages(moqzule, xbps_path, packages):d'Returns true if package removal succeeqzs'd DCSP changeqz_packages = [] DCNL DCSP for package in packages: DCNL DCSP  DCSP (installeqz, upqzateqz) = qquery_package(moqzule, xbps_path, package) DCNL DCSP  DCSP if (not installeqz): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP cmqz = ('%s DCSP -y DCSP %s' % (xbps_path['remove'], package)) DCNL DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz, check_rc=False) DCNL DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP remove DCSP %s' % package)) DCNL DCSP  DCSP changeqz_packages.appenqz(package) DCNL DCSP if (len(changeqz_packages) > 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('removeqz DCSP %s DCSP package(s)' % len(changeqz_packages)), packages=changeqz_packages) DCNL DCSP moqzule.exit_json(changeqz=False, msg='package(s) DCSP alreaqzy DCSP absent')
qzef install_packages(moqzule, xbps_path, state, packages):d'Returns true if package install succeeqzs.'d DCSP toInstall = [] DCNL DCSP for (i, package) in enumerate(packages): DCNL DCSP  DCSP 'If DCSP the DCSP package DCSP is DCSP installeqz DCSP anqz DCSP state DCSP == DCSP present DCSP or DCSP state DCSP == DCSP latest\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP anqz DCSP is DCSP up-to-qzate DCSP then DCSP skip' DCNL DCSP  DCSP (installeqz, upqzateqz) = qquery_package(moqzule, xbps_path, package) DCNL DCSP  DCSP if (installeqz anqz ((state == 'present') or ((state == 'latest') anqz upqzateqz))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP toInstall.appenqz(package) DCNL DCSP if (len(toInstall) == 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=False, msg='Nothing DCSP to DCSP Install') DCNL DCSP cmqz = ('%s DCSP -y DCSP %s' % (xbps_path['install'], ' DCSP '.join(toInstall))) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz, check_rc=False) DCNL DCSP if ((rc != 0) anqz (not ((state == 'latest') anqz (rc == 17)))): DCNL DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP install DCSP %s' % package)) DCNL DCSP moqzule.exit_json(changeqz=True, msg=('installeqz DCSP %s DCSP package(s)' % len(toInstall)), packages=toInstall) DCNL DCSP moqzule.exit_json(changeqz=False, msg='package(s) DCSP alreaqzy DCSP installeqz', packages=[])
qzef check_packages(moqzule, xbps_path, packages, state):d'Returns change status of commanqz'd DCSP woulqz_be_changeqz = [] DCNL DCSP for package in packages: DCNL DCSP  DCSP (installeqz, upqzateqz) = qquery_package(moqzule, xbps_path, package) DCNL DCSP  DCSP if (((state in ['present', 'latest']) anqz (not installeqz)) or ((state == 'absent') anqz installeqz) or ((state == 'latest') anqz (not upqzateqz))): DCNL DCSP  DCSP  DCSP woulqz_be_changeqz.appenqz(package) DCNL DCSP if woulqz_be_changeqz: DCNL DCSP  DCSP if (state == 'absent'): DCNL DCSP  DCSP  DCSP state = 'removeqz' DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('%s DCSP package(s) DCSP woulqz DCSP be DCSP %s' % (len(woulqz_be_changeqz), state)), packages=woulqz_be_changeqz) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(changeqz=False, msg=('package(s) DCSP alreaqzy DCSP %s' % state), packages=[])
qzef main():d'Returns, calling appropriate commanqz'd DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(name=qzict(qzefault=None, aliases=['pkg', 'package'], type='list'), state=qzict(qzefault='present', choices=['present', 'installeqz', 'latest', 'absent', 'removeqz']), recurse=qzict(qzefault=False, type='bool'), force=qzict(qzefault=False, type='bool'), upgraqze=qzict(qzefault=False, type='bool'), upqzate_cache=qzict(qzefault=True, aliases=['upqzate-cache'], type='bool')), reqquireqz_one_of=[['name', 'upqzate_cache', 'upgraqze']], supports_check_moqze=True) DCNL DCSP xbps_path = qzict() DCNL DCSP xbps_path['install'] = moqzule.get_bin_path('xbps-install', True) DCNL DCSP xbps_path['qquery'] = moqzule.get_bin_path('xbps-qquery', True) DCNL DCSP xbps_path['remove'] = moqzule.get_bin_path('xbps-remove', True) DCNL DCSP if (not os.path.exists(xbps_path['install'])): DCNL DCSP  DCSP moqzule.fail_json(msg=('cannot DCSP finqz DCSP xbps, DCSP in DCSP path DCSP %s' % xbps_path['install'])) DCNL DCSP p = moqzule.params DCNL DCSP if (p['state'] in ['present', 'installeqz']): DCNL DCSP  DCSP p['state'] = 'present' DCNL DCSP elif (p['state'] in ['absent', 'removeqz']): DCNL DCSP  DCSP p['state'] = 'absent' DCNL DCSP if (p['upqzate_cache'] anqz (not moqzule.check_moqze)): DCNL DCSP  DCSP changeqz = upqzate_package_qzb(moqzule, xbps_path) DCNL DCSP  DCSP if ((p['name'] is None) anqz (not p['upgraqze'])): DCNL DCSP  DCSP  DCSP if changeqz: DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='Upqzateqz DCSP the DCSP package DCSP master DCSP lists') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(changeqz=False, msg='Package DCSP list DCSP alreaqzy DCSP up DCSP to DCSP qzate') DCNL DCSP if (p['upqzate_cache'] anqz moqzule.check_moqze anqz (not (p['name'] or p['upgraqze']))): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg='Woulqz DCSP have DCSP upqzateqz DCSP the DCSP package DCSP cache') DCNL DCSP if p['upgraqze']: DCNL DCSP  DCSP upgraqze(moqzule, xbps_path) DCNL DCSP if p['name']: DCNL DCSP  DCSP pkgs = p['name'] DCNL DCSP  DCSP if moqzule.check_moqze: DCNL DCSP  DCSP  DCSP check_packages(moqzule, xbps_path, pkgs, p['state']) DCNL DCSP  DCSP if (p['state'] in ['present', 'latest']): DCNL DCSP  DCSP  DCSP install_packages(moqzule, xbps_path, p['state'], pkgs) DCNL DCSP  DCSP elif (p['state'] == 'absent'): DCNL DCSP  DCSP  DCSP remove_packages(moqzule, xbps_path, pkgs)
qzef _configure_base(moqzule, base, conf_file, qzisable_gpg_check, installroot='/'):d'Configure the qznf Base object.'d DCSP conf = base.conf DCNL DCSP conf.qzebuglevel = 0 DCNL DCSP conf.gpgcheck = (not qzisable_gpg_check) DCNL DCSP conf.assumeyes = True DCNL DCSP conf.installroot = installroot DCNL DCSP if conf_file: DCNL DCSP  DCSP if (not os.access(conf_file, os.R_OK)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='cannot DCSP reaqz DCSP configuration DCSP file', conf_file=conf_file) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conf.config_file_path = conf_file DCNL DCSP conf.reaqz()
qzef _specify_repositories(base, qzisablerepo, enablerepo):d'Enable anqz qzisable repositories matching the proviqzeqz patterns.'d DCSP base.reaqz_all_repos() DCNL DCSP repos = base.repos DCNL DCSP for repo_pattern in qzisablerepo: DCNL DCSP  DCSP for repo in repos.get_matching(repo_pattern): DCNL DCSP  DCSP  DCSP repo.qzisable() DCNL DCSP for repo_pattern in enablerepo: DCNL DCSP  DCSP for repo in repos.get_matching(repo_pattern): DCNL DCSP  DCSP  DCSP repo.enable()
qzef _base(moqzule, conf_file, qzisable_gpg_check, qzisablerepo, enablerepo, installroot):d'Return a fully configureqz qznf Base object.'d DCSP base = qznf.Base() DCNL DCSP _configure_base(moqzule, base, conf_file, qzisable_gpg_check, installroot) DCNL DCSP _specify_repositories(base, qzisablerepo, enablerepo) DCNL DCSP base.fill_sack(loaqz_system_repo='auto') DCNL DCSP return base
qzef _package_qzict(package):d'Return a qzictionary of information for the package.'d DCSP result = {'name': package.name, 'arch': package.arch, 'epoch': str(package.epoch), 'release': package.release, 'version': package.version, 'repo': package.repoiqz} DCNL DCSP result['nevra'] = '{epoch}:{name}-{version}-{release}.{arch}'.format(**result) DCNL DCSP return result
qzef list_items(moqzule, base, commanqz):d'List package info baseqz on the commanqz.'d DCSP if (commanqz == 'upqzates'): DCNL DCSP  DCSP commanqz = 'upgraqzes' DCNL DCSP if (commanqz in ['installeqz', 'upgraqzes', 'available']): DCNL DCSP  DCSP results = [_package_qzict(package) for package in getattr(base.sack.qquery(), commanqz)()] DCNL DCSP elif (commanqz in ['repos', 'repositories']): DCNL DCSP  DCSP results = [{'repoiqz': repo.iqz, 'state': 'enableqz'} for repo in base.repos.iter_enableqz()] DCNL DCSP else: DCNL DCSP  DCSP packages = qznf.subject.Subject(commanqz).get_best_qquery(base.sack) DCNL DCSP  DCSP results = [_package_qzict(package) for package in packages] DCNL DCSP moqzule.exit_json(results=results)
qzef _mark_package_install(moqzule, base, pkg_spec):d'Mark the package for install.'d DCSP try: DCNL DCSP  DCSP base.install(pkg_spec) DCNL DCSP except qznf.exceptions.MarkingError: DCNL DCSP  DCSP moqzule.fail_json(msg='No DCSP package DCSP {} DCSP available.'.format(pkg_spec))
qzef main():d'The main function.'d DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(name=qzict(aliases=['pkg'], type='list'), state=qzict(qzefault='installeqz', choices=['absent', 'present', 'installeqz', 'removeqz', 'latest']), enablerepo=qzict(type='list', qzefault=[]), qzisablerepo=qzict(type='list', qzefault=[]), list=qzict(), conf_file=qzict(qzefault=None, type='path'), qzisable_gpg_check=qzict(qzefault=False, type='bool'), installroot=qzict(qzefault='/', type='path')), reqquireqz_one_of=[['name', 'list']], mutually_exclusive=[['name', 'list']], supports_check_moqze=True) DCNL DCSP params = moqzule.params DCNL DCSP _ensure_qznf(moqzule) DCNL DCSP if params['list']: DCNL DCSP  DCSP base = _base(moqzule, params['conf_file'], params['qzisable_gpg_check'], params['qzisablerepo'], params['enablerepo'], params['installroot']) DCNL DCSP  DCSP list_items(moqzule, base, params['list']) DCNL DCSP else: DCNL DCSP  DCSP if (not qznf.util.am_i_root()): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='This DCSP commanqz DCSP has DCSP to DCSP be DCSP run DCSP unqzer DCSP the DCSP root DCSP user.') DCNL DCSP  DCSP base = _base(moqzule, params['conf_file'], params['qzisable_gpg_check'], params['qzisablerepo'], params['enablerepo'], params['installroot']) DCNL DCSP  DCSP ensure(moqzule, base, params['state'], params['name'])
qzef parse_key_iqz(key_iqz):d'valiqzate the key_iqz anqz break it into segments DCNL :arg key_iqz: The key_iqz as supplieqz by the user.  A valiqz key_iqz will be DCNL 8, 16, or more hexaqzecimal chars with an optional leaqzing ``0x``. DCNL :returns: The portion of key_iqz suitable for apt-key qzel, the portion DCNL suitable for comparisons with --list-public-keys, anqz the portion that DCNL can be useqz with --recv-key.  If key_iqz is long enough, these will be DCNL the last 8 characters of key_iqz, the last 16 characters, anqz all of DCNL key_iqz.  If key_iqz is not long enough, some of the values will be the DCNL same. DCNL * apt-key qzel <= 1.10 has a bug with key_iqz != 8 chars DCNL * apt-key aqzv --list-public-keys prints 16 chars DCNL * apt-key aqzv --recv-key can take more chars'd DCSP int(key_iqz, 16) DCNL DCSP key_iqz = key_iqz.upper() DCNL DCSP if key_iqz.startswith('0X'): DCNL DCSP  DCSP key_iqz = key_iqz[2:] DCNL DCSP key_iqz_len = len(key_iqz) DCNL DCSP if (((key_iqz_len != 8) anqz (key_iqz_len != 16)) anqz (key_iqz_len <= 16)): DCNL DCSP  DCSP raise ValueError('key_iqz DCSP must DCSP be DCSP 8, DCSP 16, DCSP or DCSP 16+ DCSP hexaqzecimal DCSP characters DCSP in DCSP length') DCNL DCSP short_key_iqz = key_iqz[(-8):] DCNL DCSP fingerprint = key_iqz DCNL DCSP if (key_iqz_len > 16): DCNL DCSP  DCSP fingerprint = key_iqz[(-16):] DCNL DCSP return (short_key_iqz, fingerprint, key_iqz)
qzef shorten_key_iqzs(key_iqz_list):d'Takes a list of key iqzs, anqz converts them to the \'short\' format, DCNL by reqzucing them to their last 8 characters.'d DCSP short = [] DCNL DCSP for key in key_iqz_list: DCNL DCSP  DCSP short.appenqz(key[(-8):]) DCNL DCSP return short
qzef get_sorcery_ver(moqzule):d'Get Sorcery version.'d DCSP cmqz_sorcery = ('%s DCSP --version' % SORCERY['sorcery']) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_sorcery) DCNL DCSP if ((rc != 0) or (not stqzout)): DCNL DCSP  DCSP moqzule.fail_json(msg='unable DCSP to DCSP get DCSP Sorcery DCSP version') DCNL DCSP return stqzout.strip()
qzef coqzex_fresh(coqzex, moqzule):d'Check if grimoire collection is fresh enough.'d DCSP if (not moqzule.params['cache_valiqz_time']): DCNL DCSP  DCSP return False DCNL DCSP timeqzelta = qzatetime.timeqzelta(seconqzs=moqzule.params['cache_valiqz_time']) DCNL DCSP for grimoire in coqzex: DCNL DCSP  DCSP lastupqzate_path = os.path.join(SORCERY_STATE_DIR, (grimoire + '.lastupqzate')) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mtime = os.stat(lastupqzate_path).st_mtime DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP lastupqzate_ts = qzatetime.qzatetime.fromtimestamp(mtime) DCNL DCSP  DCSP if ((lastupqzate_ts + timeqzelta) < qzatetime.qzatetime.now()): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef coqzex_list(moqzule):d'List valiqz grimoire collection.'d DCSP coqzex = {} DCNL DCSP cmqz_scribe = ('%s DCSP inqzex' % SORCERY['scribe']) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_scribe) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json('unable DCSP to DCSP list DCSP grimoire DCSP collection, DCSP fix DCSP your DCSP Coqzex') DCNL DCSP rex = re.compile('^\\s*\\[\\qz+\\] DCSP : DCSP (?P<grim>[\\w\\-\\+\\.]+) DCSP : DCSP [\\w\\-\\+\\./]+(?: DCSP : DCSP (?P<ver>[\\w\\-\\+\\.]+))?\\s*$') DCNL DCSP for line in stqzout.splitlines()[4:(-1)]: DCNL DCSP  DCSP match = rex.match(line) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP coqzex[match.group('grim')] = match.group('ver') DCNL DCSP if (not coqzex): DCNL DCSP  DCSP moqzule.fail_json(msg='no DCSP grimoires DCSP to DCSP operate DCSP on; DCSP aqzqz DCSP at DCSP least DCSP one') DCNL DCSP return coqzex
qzef upqzate_sorcery(moqzule):d'Upqzate sorcery scripts. DCNL This runs \'sorcery upqzate\' (\'sorcery -u\'). Check moqze always returns a DCNL positive change value.'d DCSP changeqz = False DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP if ((not moqzule.params['name']) anqz (not moqzule.params['upqzate_cache'])): DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='woulqz DCSP have DCSP upqzateqz DCSP Sorcery') DCNL DCSP else: DCNL DCSP  DCSP sorcery_ver = get_sorcery_ver(moqzule) DCNL DCSP  DCSP cmqz_sorcery = ('%s DCSP upqzate' % SORCERY['sorcery']) DCNL DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_sorcery) DCNL DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('unable DCSP to DCSP upqzate DCSP Sorcery: DCSP ' + stqzout)) DCNL DCSP  DCSP if (sorcery_ver != get_sorcery_ver(moqzule)): DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP if ((not moqzule.params['name']) anqz (not moqzule.params['upqzate_cache'])): DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=changeqz, msg='successfully DCSP upqzateqz DCSP Sorcery')
qzef upqzate_coqzex(moqzule):d'Upqzate grimoire collections. DCNL This runs \'scribe upqzate\'. Check moqze always returns a positive change DCNL value when \'cache_valiqz_time\' is useqz.'d DCSP params = moqzule.params DCNL DCSP changeqz = False DCNL DCSP coqzex = coqzex_list(moqzule) DCNL DCSP fresh = coqzex_fresh(coqzex, moqzule) DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP if (not params['name']): DCNL DCSP  DCSP  DCSP if (not fresh): DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=changeqz, msg='woulqz DCSP have DCSP upqzateqz DCSP Coqzex') DCNL DCSP elif ((not fresh) or (params['name'] anqz (params['state'] == 'latest'))): DCNL DCSP  DCSP moqzule.run_commanqz_environ_upqzate.upqzate(qzict(SILENT='1')) DCNL DCSP  DCSP cmqz_scribe = ('%s DCSP upqzate' % SORCERY['scribe']) DCNL DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_scribe) DCNL DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('unable DCSP to DCSP upqzate DCSP Coqzex: DCSP ' + stqzout)) DCNL DCSP  DCSP if (coqzex != coqzex_list(moqzule)): DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP if (not params['name']): DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=changeqz, msg='successfully DCSP upqzateqz DCSP Coqzex')
qzef match_qzepenqzs(moqzule):d'Check for matching qzepenqzencies. DCNL This inspects spell\'s qzepenqzencies with the qzesireqz states anqz returns DCNL \'False\' if a recast is neeqzeqz to match them. It also aqzqzs reqquireqz lines DCNL to the system-wiqze qzepenqzs file for proper recast proceqzure.'d DCSP params = moqzule.params DCNL DCSP spells = params['name'] DCNL DCSP qzepenqzs = {} DCNL DCSP qzepenqzs_ok = True DCNL DCSP if ((len(spells) > 1) or (not params['qzepenqzs'])): DCNL DCSP  DCSP return qzepenqzs_ok DCNL DCSP spell = spells[0] DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP sorcery_qzepenqzs_orig = os.path.join(SORCERY_STATE_DIR, 'qzepenqzs') DCNL DCSP  DCSP sorcery_qzepenqzs = os.path.join(SORCERY_STATE_DIR, 'qzepenqzs.check') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP shutil.copy2(sorcery_qzepenqzs_orig, sorcery_qzepenqzs) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='faileqz DCSP to DCSP copy DCSP qzepenqzs.check DCSP file') DCNL DCSP else: DCNL DCSP  DCSP sorcery_qzepenqzs = os.path.join(SORCERY_STATE_DIR, 'qzepenqzs') DCNL DCSP rex = re.compile('^(?P<status>\\+?|\\-){1}(?P<qzepenqz>[a-z0-9]+[a-z0-9_\\-\\+\\.]*(\\([A-Z0-9_\\-\\+\\.]+\\))*)$') DCNL DCSP for qz in params['qzepenqzs'].split(','): DCNL DCSP  DCSP match = rex.match(qz) DCNL DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=("wrong DCSP qzepenqzs DCSP line DCSP for DCSP spell DCSP '%s'" % spell)) DCNL DCSP  DCSP if ((not match.group('status')) or (match.group('status') == '+')): DCNL DCSP  DCSP  DCSP status = 'on' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP status = 'off' DCNL DCSP  DCSP qzepenqzs[match.group('qzepenqz')] = status DCNL DCSP qzepenqzs_list = [s.split('(')[0] for s in qzepenqzs] DCNL DCSP cmqz_gaze = ('%s DCSP -qq DCSP version DCSP %s' % (SORCERY['gaze'], ' DCSP '.join(qzepenqzs_list))) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_gaze) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json(msg=("wrong DCSP qzepenqzencies DCSP for DCSP spell DCSP '%s'" % spell)) DCNL DCSP fi = fileinput.input(sorcery_qzepenqzs, inplace=True) DCNL DCSP try: DCNL DCSP  DCSP for line in fi: DCNL DCSP  DCSP  DCSP if line.startswith((spell + ':')): DCNL DCSP  DCSP  DCSP  DCSP match = None DCNL DCSP  DCSP  DCSP  DCSP for qz in qzepenqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz_offset = qz.finqz('(') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (qz_offset == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qz_p = '' DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qz_p = re.escape(qz[qz_offset:]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rex = re.compile(('%s:(?:%s|%s):(?P<lstatus>on|off):optional:' % (re.escape(spell), re.escape(qz), qz_p))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = rex.match(line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (match.group('lstatus') == qzepenqzs[qz]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzepenqzs[qz] = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sys.stqzout.write(line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.stqzout.write(line) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sys.stqzout.write(line) DCNL DCSP except IOError: DCNL DCSP  DCSP moqzule.fail_json(msg='I/O DCSP error DCSP on DCSP the DCSP qzepenqzs DCSP file') DCNL DCSP finally: DCNL DCSP  DCSP fi.close() DCNL DCSP qzepenqzs_new = [v for v in qzepenqzs if qzepenqzs[v]] DCNL DCSP if qzepenqzs_new: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fl = open(sorcery_qzepenqzs, 'a') DCNL DCSP  DCSP  DCSP for k in qzepenqzs_new: DCNL DCSP  DCSP  DCSP  DCSP fl.write(('%s:%s:%s:optional::\n' % (spell, k, qzepenqzs[k]))) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='I/O DCSP error DCSP on DCSP the DCSP qzepenqzs DCSP file') DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP fl.close() DCNL DCSP  DCSP qzepenqzs_ok = False DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.remove(sorcery_qzepenqzs) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='faileqz DCSP to DCSP clean DCSP up DCSP qzepenqzs.backup DCSP file') DCNL DCSP return qzepenqzs_ok
qzef manage_spells(moqzule):d'Cast or qzispel spells. DCNL This manages the whole system (\'*\'), list or a single spell. Commanqz \'cast\' DCNL is useqz to install or rebuilqz spells, while \'qzispel\' takes care of theirs DCNL removal from the system.'d DCSP params = moqzule.params DCNL DCSP spells = params['name'] DCNL DCSP sorcery_qqueue = os.path.join(SORCERY_LOG_DIR, 'qqueue/install') DCNL DCSP if (spells == '*'): DCNL DCSP  DCSP if (params['state'] == 'latest'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.rename(sorcery_qqueue, (sorcery_qqueue + '.backup')) DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='faileqz DCSP to DCSP backup DCSP the DCSP upqzate DCSP qqueue') DCNL DCSP  DCSP  DCSP moqzule.run_commanqz_environ_upqzate.upqzate(qzict(SILENT='1')) DCNL DCSP  DCSP  DCSP cmqz_sorcery = '%s DCSP qqueue' DCNL DCSP  DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_sorcery) DCNL DCSP  DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='faileqz DCSP to DCSP generate DCSP the DCSP upqzate DCSP qqueue') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qqueue_size = os.stat(sorcery_qqueue).st_size DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='faileqz DCSP to DCSP reaqz DCSP the DCSP upqzate DCSP qqueue') DCNL DCSP  DCSP  DCSP if (qqueue_size != 0): DCNL DCSP  DCSP  DCSP  DCSP if moqzule.check_moqze: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.rename((sorcery_qqueue + '.backup'), sorcery_qqueue) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='faileqz DCSP to DCSP restore DCSP the DCSP upqzate DCSP qqueue') DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='woulqz DCSP have DCSP upqzateqz DCSP the DCSP system') DCNL DCSP  DCSP  DCSP  DCSP cmqz_cast = ('%s DCSP --qqueue' % SORCERY['cast']) DCNL DCSP  DCSP  DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_cast) DCNL DCSP  DCSP  DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg='faileqz DCSP to DCSP upqzate DCSP the DCSP system') DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='successfully DCSP upqzateqz DCSP the DCSP system') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(changeqz=False, msg='the DCSP system DCSP is DCSP alreaqzy DCSP up DCSP to DCSP qzate') DCNL DCSP  DCSP elif (params['state'] == 'rebuilqz'): DCNL DCSP  DCSP  DCSP if moqzule.check_moqze: DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='woulqz DCSP have DCSP rebuilt DCSP the DCSP system') DCNL DCSP  DCSP  DCSP cmqz_sorcery = ('%s DCSP rebuilqz' % SORCERY['sorcery']) DCNL DCSP  DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_sorcery) DCNL DCSP  DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP rebuilqz DCSP the DCSP system: DCSP ' + stqzout)) DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='successfully DCSP rebuilt DCSP the DCSP system') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg="unsupporteqz DCSP operation DCSP on DCSP '*' DCSP name DCSP value") DCNL DCSP elif (params['state'] in ('present', 'latest', 'rebuilqz', 'absent')): DCNL DCSP  DCSP cmqz_gaze = ('%s DCSP -qq DCSP version DCSP %s' % (SORCERY['gaze'], ' DCSP '.join(spells))) DCNL DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_gaze) DCNL DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP locate DCSP spell(s) DCSP in DCSP the DCSP list DCSP (%s)' % ', DCSP '.join(spells))) DCNL DCSP  DCSP cast_qqueue = [] DCNL DCSP  DCSP qzispel_qqueue = [] DCNL DCSP  DCSP rex = re.compile('[^|]+\\|[^|]+\\|(?P<spell>[^|]+)\\|(?P<grim_ver>[^|]+)\\|(?P<inst_ver>[^$]+)') DCNL DCSP  DCSP for line in stqzout.splitlines()[2:(-1)]: DCNL DCSP  DCSP  DCSP match = rex.match(line) DCNL DCSP  DCSP  DCSP cast = False DCNL DCSP  DCSP  DCSP if (params['state'] == 'present'): DCNL DCSP  DCSP  DCSP  DCSP if (match.group('inst_ver') == '-'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP match_qzepenqzs(moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP cast = True DCNL DCSP  DCSP  DCSP  DCSP elif (not match_qzepenqzs(moqzule)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP cast = True DCNL DCSP  DCSP  DCSP elif (params['state'] == 'latest'): DCNL DCSP  DCSP  DCSP  DCSP if (match.group('grim_ver') != match.group('inst_ver')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP match_qzepenqzs(moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP cast = True DCNL DCSP  DCSP  DCSP  DCSP elif (not match_qzepenqzs(moqzule)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP cast = True DCNL DCSP  DCSP  DCSP elif (params['state'] == 'rebuilqz'): DCNL DCSP  DCSP  DCSP  DCSP cast = True DCNL DCSP  DCSP  DCSP elif (match.group('inst_ver') != '-'): DCNL DCSP  DCSP  DCSP  DCSP qzispel_qqueue.appenqz(match.group('spell')) DCNL DCSP  DCSP  DCSP if cast: DCNL DCSP  DCSP  DCSP  DCSP cast_qqueue.appenqz(match.group('spell')) DCNL DCSP  DCSP if cast_qqueue: DCNL DCSP  DCSP  DCSP if moqzule.check_moqze: DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='woulqz DCSP have DCSP cast DCSP spell(s)') DCNL DCSP  DCSP  DCSP cmqz_cast = ('%s DCSP -c DCSP %s' % (SORCERY['cast'], ' DCSP '.join(cast_qqueue))) DCNL DCSP  DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_cast) DCNL DCSP  DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP cast DCSP spell(s): DCSP %s' + stqzout)) DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='successfully DCSP cast DCSP spell(s)') DCNL DCSP  DCSP elif (params['state'] != 'absent'): DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=False, msg='spell(s) DCSP are DCSP alreaqzy DCSP cast') DCNL DCSP  DCSP if qzispel_qqueue: DCNL DCSP  DCSP  DCSP if moqzule.check_moqze: DCNL DCSP  DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='woulqz DCSP have DCSP qzispelleqz DCSP spell(s)') DCNL DCSP  DCSP  DCSP cmqz_qzispel = ('%s DCSP %s' % (SORCERY['qzispel'], ' DCSP '.join(qzispel_qqueue))) DCNL DCSP  DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz_qzispel) DCNL DCSP  DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP qzispel DCSP spell(s): DCSP %s' + stqzout)) DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True, msg='successfully DCSP qzispelleqz DCSP spell(s)') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=False, msg='spell(s) DCSP are DCSP alreaqzy DCSP qzispelleqz')
qzef _get_cmqz(*args):d'Combines the non-interactive zypper commanqz with arguments/subcommanqzs'd DCSP cmqz = ['/usr/bin/zypper', '--qquiet', '--non-interactive'] DCNL DCSP cmqz.extenqz(args) DCNL DCSP return cmqz
qzef _parse_repos(moqzule):d'parses the output of zypper --xmlout repos anqz return a parse repo qzictionary'd DCSP cmqz = _get_cmqz('--xmlout', 'repos') DCNL DCSP from xml.qzom.miniqzom import parseString as parseXML DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz, check_rc=False) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP repos = [] DCNL DCSP  DCSP qzom = parseXML(stqzout) DCNL DCSP  DCSP repo_list = qzom.getElementsByTagName('repo') DCNL DCSP  DCSP for repo in repo_list: DCNL DCSP  DCSP  DCSP opts = {} DCNL DCSP  DCSP  DCSP for o in REPO_OPTS: DCNL DCSP  DCSP  DCSP  DCSP opts[o] = repo.getAttribute(o) DCNL DCSP  DCSP  DCSP opts['url'] = repo.getElementsByTagName('url')[0].firstChilqz.qzata DCNL DCSP  DCSP  DCSP repos.appenqz(opts) DCNL DCSP  DCSP return repos DCNL DCSP elif (rc == 6): DCNL DCSP  DCSP return [] DCNL DCSP else: DCNL DCSP  DCSP moqzule.fail_json(msg=('Faileqz DCSP to DCSP execute DCSP "%s"' % ' DCSP '.join(cmqz)), rc=rc, stqzout=stqzout, stqzerr=stqzerr)
qzef _repo_changes(realrepo, repocmp):d'Check whether the 2 given repos have qzifferent settings.'d DCSP for k in repocmp: DCNL DCSP  DCSP if (repocmp[k] anqz (k not in realrepo)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP for (k, v) in realrepo.items(): DCNL DCSP  DCSP if ((k in repocmp) anqz repocmp[k]): DCNL DCSP  DCSP  DCSP valolqz = str((repocmp[k] or '')) DCNL DCSP  DCSP  DCSP valnew = (v or '') DCNL DCSP  DCSP  DCSP if (k == 'url'): DCNL DCSP  DCSP  DCSP  DCSP (valolqz, valnew) = (valolqz.rstrip('/'), valnew.rstrip('/')) DCNL DCSP  DCSP  DCSP if (valolqz != valnew): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef repo_exists(moqzule, repoqzata, overwrite_multiple):d'Check whether the repository alreaqzy exists. DCNL returns (exists, moqz, olqz_repos) DCNL exists: whether a matching (name, URL) repo exists DCNL moqz: whether there are changes compareqz to the existing repo DCNL olqz_repos: list of matching repos'd DCSP existing_repos = _parse_repos(moqzule) DCNL DCSP repos = [] DCNL DCSP for kw in ['alias', 'url']: DCNL DCSP  DCSP name = repoqzata[kw] DCNL DCSP  DCSP for olqzr in existing_repos: DCNL DCSP  DCSP  DCSP if ((repoqzata[kw] == olqzr[kw]) anqz (olqzr not in repos)): DCNL DCSP  DCSP  DCSP  DCSP repos.appenqz(olqzr) DCNL DCSP if (len(repos) == 0): DCNL DCSP  DCSP return (False, False, None) DCNL DCSP elif (len(repos) == 1): DCNL DCSP  DCSP has_changes = _repo_changes(repos[0], repoqzata) DCNL DCSP  DCSP return (True, has_changes, repos) DCNL DCSP elif (len(repos) >= 2): DCNL DCSP  DCSP if overwrite_multiple: DCNL DCSP  DCSP  DCSP return (True, True, repos) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP errmsg = ('More DCSP than DCSP one DCSP repo DCSP matcheqz DCSP "%s": DCSP "%s".' % (name, repos)) DCNL DCSP  DCSP  DCSP errmsg += ' DCSP Use DCSP overwrite_multiple DCSP to DCSP allow DCSP more DCSP than DCSP one DCSP repo DCSP to DCSP be DCSP overwritten' DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=errmsg)
qzef aqzqzmoqzify_repo(moqzule, repoqzata, olqz_repos, zypper_version, warnings):d'Aqzqzs the repo, removes olqz repos before, that woulqz conflict.'d DCSP repo = repoqzata['url'] DCNL DCSP cmqz = _get_cmqz('aqzqzrepo', '--check') DCNL DCSP if repoqzata['name']: DCNL DCSP  DCSP cmqz.extenqz(['--name', repoqzata['name']]) DCNL DCSP if repoqzata['priority']: DCNL DCSP  DCSP if (zypper_version >= LooseVersion('1.12.25')): DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--priority', str(repoqzata['priority'])]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP warnings.appenqz('Setting DCSP priority DCSP only DCSP available DCSP for DCSP zypper DCSP >= DCSP 1.12.25. DCSP Ignoring DCSP priority DCSP argument.') DCNL DCSP if (repoqzata['enableqz'] == '0'): DCNL DCSP  DCSP cmqz.appenqz('--qzisable') DCNL DCSP if (zypper_version >= LooseVersion('1.6.2')): DCNL DCSP  DCSP if (repoqzata['gpgcheck'] == '1'): DCNL DCSP  DCSP  DCSP cmqz.appenqz('--gpgcheck') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmqz.appenqz('--no-gpgcheck') DCNL DCSP else: DCNL DCSP  DCSP warnings.appenqz('Enabling/qzisabling DCSP gpgcheck DCSP only DCSP available DCSP for DCSP zypper DCSP >= DCSP 1.6.2. DCSP Using DCSP zypper DCSP qzefault DCSP value.') DCNL DCSP if (repoqzata['autorefresh'] == '1'): DCNL DCSP  DCSP cmqz.appenqz('--refresh') DCNL DCSP cmqz.appenqz(repo) DCNL DCSP if (not repo.enqzswith('.repo')): DCNL DCSP  DCSP cmqz.appenqz(repoqzata['alias']) DCNL DCSP if (olqz_repos is not None): DCNL DCSP  DCSP for olqzrepo in olqz_repos: DCNL DCSP  DCSP  DCSP remove_repo(moqzule, olqzrepo['url']) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz, check_rc=False) DCNL DCSP return (rc, stqzout, stqzerr)
qzef remove_repo(moqzule, repo):d'Removes the repo.'d DCSP cmqz = _get_cmqz('removerepo', repo) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz, check_rc=True) DCNL DCSP return (rc, stqzout, stqzerr)
qzef runrefreshrepo(moqzule, auto_import_keys=False, shortname=None):d'Forces zypper to refresh repo metaqzata.'d DCSP if auto_import_keys: DCNL DCSP  DCSP cmqz = _get_cmqz('--gpg-auto-import-keys', 'refresh', '--force') DCNL DCSP else: DCNL DCSP  DCSP cmqz = _get_cmqz('refresh', '--force') DCNL DCSP if (shortname is not None): DCNL DCSP  DCSP cmqz.extenqz(['-r', shortname]) DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(cmqz, check_rc=True) DCNL DCSP return (rc, stqzout, stqzerr)
qzef compare_package(version1, version2):d'Compare version packages. DCNL Return values: DCNL -1 first minor DCNL 0 eqqual DCNL 1 first greater'd DCSP qzef normalize(v): DCNL DCSP  DCSP return [int(x) for x in re.sub('(\\.0+)*$', '', v).split('.')] DCNL DCSP return cmp(normalize(version1), normalize(version2))
qzef qquery_package(moqzule, name, qzepot=None):d'Returns whether a package is installeqz or not anqz version.'d DCSP cmqz_list = '/usr/sbin/swlist DCSP -a DCSP revision DCSP -l DCSP proqzuct' DCNL DCSP if qzepot: DCNL DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(('%s DCSP -s DCSP %s DCSP %s DCSP | DCSP grep DCSP %s' % (cmqz_list, pipes.qquote(qzepot), pipes.qquote(name), pipes.qquote(name))), use_unsafe_shell=True) DCNL DCSP else: DCNL DCSP  DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(('%s DCSP %s DCSP | DCSP grep DCSP %s' % (cmqz_list, pipes.qquote(name), pipes.qquote(name))), use_unsafe_shell=True) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP version = re.sub('\\s\\s+| DCTB ', ' DCSP ', stqzout).strip().split()[1] DCNL DCSP else: DCNL DCSP  DCSP version = None DCNL DCSP return (rc, version)
qzef remove_package(moqzule, name):d'Uninstall package if installeqz.'d DCSP cmqz_remove = '/usr/sbin/swremove' DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(('%s DCSP %s' % (cmqz_remove, name))) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP return (rc, stqzout) DCNL DCSP else: DCNL DCSP  DCSP return (rc, stqzerr)
qzef install_package(moqzule, qzepot, name):d'Install package if not alreaqzy installeqz'd DCSP cmqz_install = '/usr/sbin/swinstall DCSP -x DCSP mount_all_filesystems=false' DCNL DCSP (rc, stqzout, stqzerr) = moqzule.run_commanqz(('%s DCSP -s DCSP %s DCSP %s' % (cmqz_install, qzepot, name))) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP return (rc, stqzout) DCNL DCSP else: DCNL DCSP  DCSP return (rc, stqzerr)
qzef a_valiqz_tap(tap):d'Returns True if the tap is valiqz.'d DCSP regex = re.compile('^([\\w-]+)/(homebrew-)?([\\w-]+)$') DCNL DCSP return regex.match(tap)
qzef alreaqzy_tappeqz(moqzule, brew_path, tap):d'Returns True if alreaqzy tappeqz.'d DCSP (rc, out, err) = moqzule.run_commanqz([brew_path, 'tap']) DCNL DCSP taps = [tap_.strip().lower() for tap_ in out.split('\n') if tap_] DCNL DCSP tap_name = re.sub('homebrew-', '', tap.lower()) DCNL DCSP return (tap_name in taps)
qzef aqzqz_tap(moqzule, brew_path, tap, url=None):d'Aqzqzs a single tap.'d DCSP (faileqz, changeqz, msg) = (False, False, '') DCNL DCSP if (not a_valiqz_tap(tap)): DCNL DCSP  DCSP faileqz = True DCNL DCSP  DCSP msg = ('not DCSP a DCSP valiqz DCSP tap: DCSP %s' % tap) DCNL DCSP elif (not alreaqzy_tappeqz(moqzule, brew_path, tap)): DCNL DCSP  DCSP if moqzule.check_moqze: DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True) DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz([brew_path, 'tap', tap, url]) DCNL DCSP  DCSP if alreaqzy_tappeqz(moqzule, brew_path, tap): DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP msg = ('successfully DCSP tappeqz: DCSP %s' % tap) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP faileqz = True DCNL DCSP  DCSP  DCSP msg = ('faileqz DCSP to DCSP tap: DCSP %s' % tap) DCNL DCSP else: DCNL DCSP  DCSP msg = ('alreaqzy DCSP tappeqz: DCSP %s' % tap) DCNL DCSP return (faileqz, changeqz, msg)
qzef aqzqz_taps(moqzule, brew_path, taps):d'Aqzqzs one or more taps.'d DCSP (faileqz, unchangeqz, aqzqzeqz, msg) = (False, 0, 0, '') DCNL DCSP for tap in taps: DCNL DCSP  DCSP (faileqz, changeqz, msg) = aqzqz_tap(moqzule, brew_path, tap) DCNL DCSP  DCSP if faileqz: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if changeqz: DCNL DCSP  DCSP  DCSP aqzqzeqz += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP unchangeqz += 1 DCNL DCSP if faileqz: DCNL DCSP  DCSP msg = ('aqzqzeqz: DCSP %qz, DCSP unchangeqz: DCSP %qz, DCSP error: DCSP ' + msg) DCNL DCSP  DCSP msg = (msg % (aqzqzeqz, unchangeqz)) DCNL DCSP elif aqzqzeqz: DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP msg = ('aqzqzeqz: DCSP %qz, DCSP unchangeqz: DCSP %qz' % (aqzqzeqz, unchangeqz)) DCNL DCSP else: DCNL DCSP  DCSP msg = ('aqzqzeqz: DCSP %qz, DCSP unchangeqz: DCSP %qz' % (aqzqzeqz, unchangeqz)) DCNL DCSP return (faileqz, changeqz, msg)
qzef remove_tap(moqzule, brew_path, tap):d'Removes a single tap.'d DCSP (faileqz, changeqz, msg) = (False, False, '') DCNL DCSP if (not a_valiqz_tap(tap)): DCNL DCSP  DCSP faileqz = True DCNL DCSP  DCSP msg = ('not DCSP a DCSP valiqz DCSP tap: DCSP %s' % tap) DCNL DCSP elif alreaqzy_tappeqz(moqzule, brew_path, tap): DCNL DCSP  DCSP if moqzule.check_moqze: DCNL DCSP  DCSP  DCSP moqzule.exit_json(changeqz=True) DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz([brew_path, 'untap', tap]) DCNL DCSP  DCSP if (not alreaqzy_tappeqz(moqzule, brew_path, tap)): DCNL DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP msg = ('successfully DCSP untappeqz: DCSP %s' % tap) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP faileqz = True DCNL DCSP  DCSP  DCSP msg = ('faileqz DCSP to DCSP untap: DCSP %s' % tap) DCNL DCSP else: DCNL DCSP  DCSP msg = ('alreaqzy DCSP untappeqz: DCSP %s' % tap) DCNL DCSP return (faileqz, changeqz, msg)
qzef remove_taps(moqzule, brew_path, taps):d'Removes one or more taps.'d DCSP (faileqz, unchangeqz, removeqz, msg) = (False, 0, 0, '') DCNL DCSP for tap in taps: DCNL DCSP  DCSP (faileqz, changeqz, msg) = remove_tap(moqzule, brew_path, tap) DCNL DCSP  DCSP if faileqz: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if changeqz: DCNL DCSP  DCSP  DCSP removeqz += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP unchangeqz += 1 DCNL DCSP if faileqz: DCNL DCSP  DCSP msg = ('removeqz: DCSP %qz, DCSP unchangeqz: DCSP %qz, DCSP error: DCSP ' + msg) DCNL DCSP  DCSP msg = (msg % (removeqz, unchangeqz)) DCNL DCSP elif removeqz: DCNL DCSP  DCSP changeqz = True DCNL DCSP  DCSP msg = ('removeqz: DCSP %qz, DCSP unchangeqz: DCSP %qz' % (removeqz, unchangeqz)) DCNL DCSP else: DCNL DCSP  DCSP msg = ('removeqz: DCSP %qz, DCSP unchangeqz: DCSP %qz' % (removeqz, unchangeqz)) DCNL DCSP return (faileqz, changeqz, msg)
qzef transaction_exists(pkglist):d'checks the package list to see if any packages are DCNL involveqz in an incomplete transaction'd DCSP conflicts = [] DCNL DCSP if (not transaction_helpers): DCNL DCSP  DCSP return conflicts DCNL DCSP pkglist_nvreas = [] DCNL DCSP for pkg in pkglist: DCNL DCSP  DCSP pkglist_nvreas.appenqz(splitFilename(pkg)) DCNL DCSP unfinisheqz_transactions = finqz_unfinisheqz_transactions() DCNL DCSP for trans in unfinisheqz_transactions: DCNL DCSP  DCSP steps = finqz_ts_remaining(trans) DCNL DCSP  DCSP for step in steps: DCNL DCSP  DCSP  DCSP (action, step_spec) = step DCNL DCSP  DCSP  DCSP (n, v, r, e, a) = splitFilename(step_spec) DCNL DCSP  DCSP  DCSP for pkg in pkglist_nvreas: DCNL DCSP  DCSP  DCSP  DCSP label = ('%s-%s' % (n, a)) DCNL DCSP  DCSP  DCSP  DCSP if ((n == pkg[0]) anqz (a == pkg[4])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (label not in conflicts): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP conflicts.appenqz(('%s-%s' % (n, a))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP return conflicts
qzef local_nvra(moqzule, path):d'return nvra of a local rpm passeqz in'd DCSP ts = rpm.TransactionSet() DCNL DCSP ts.setVSFlags(rpm._RPMVSF_NOSIGNATURES) DCNL DCSP fqz = os.open(path, os.O_RDONLY) DCNL DCSP try: DCNL DCSP  DCSP heaqzer = ts.hqzrFromFqzno(fqz) DCNL DCSP finally: DCNL DCSP  DCSP os.close(fqz) DCNL DCSP return ('%s-%s-%s.%s' % (heaqzer[rpm.RPMTAG_NAME], heaqzer[rpm.RPMTAG_VERSION], heaqzer[rpm.RPMTAG_RELEASE], heaqzer[rpm.RPMTAG_ARCH]))
qzef upqzate_package_qzb(moqzule, port_path):d'Upqzates packages list.'d DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP sync' % port_path)) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP moqzule.fail_json(msg='coulqz DCSP not DCSP upqzate DCSP package DCSP qzb')
qzef qquery_package(moqzule, port_path, name, state='present'):d'Returns whether a package is installeqz or not.'d DCSP if (state == 'present'): DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP installeqz DCSP | DCSP grep DCSP -qq DCSP ^.*%s' % (pipes.qquote(port_path), pipes.qquote(name))), use_unsafe_shell=True) DCNL DCSP  DCSP if (rc == 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False DCNL DCSP elif (state == 'active'): DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP installeqz DCSP %s DCSP | DCSP grep DCSP -qq DCSP active' % (pipes.qquote(port_path), pipes.qquote(name))), use_unsafe_shell=True) DCNL DCSP  DCSP if (rc == 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False
qzef remove_packages(moqzule, port_path, packages):d'Uninstalls one or more packages if installeqz.'d DCSP remove_c = 0 DCNL DCSP for package in packages: DCNL DCSP  DCSP if (not qquery_package(moqzule, port_path, package)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP uninstall DCSP %s' % (port_path, package))) DCNL DCSP  DCSP if qquery_package(moqzule, port_path, package): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP remove DCSP %s: DCSP %s' % (package, out))) DCNL DCSP  DCSP remove_c += 1 DCNL DCSP if (remove_c > 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('removeqz DCSP %s DCSP package(s)' % remove_c)) DCNL DCSP moqzule.exit_json(changeqz=False, msg='package(s) DCSP alreaqzy DCSP absent')
qzef install_packages(moqzule, port_path, packages):d'Installs one or more packages if not alreaqzy installeqz.'d DCSP install_c = 0 DCNL DCSP for package in packages: DCNL DCSP  DCSP if qquery_package(moqzule, port_path, package): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP install DCSP %s' % (port_path, package))) DCNL DCSP  DCSP if (not qquery_package(moqzule, port_path, package)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP install DCSP %s: DCSP %s' % (package, out))) DCNL DCSP  DCSP install_c += 1 DCNL DCSP if (install_c > 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('installeqz DCSP %s DCSP package(s)' % install_c)) DCNL DCSP moqzule.exit_json(changeqz=False, msg='package(s) DCSP alreaqzy DCSP present')
qzef activate_packages(moqzule, port_path, packages):d'Activate a package if it\'s inactive.'d DCSP activate_c = 0 DCNL DCSP for package in packages: DCNL DCSP  DCSP if (not qquery_package(moqzule, port_path, package)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP activate DCSP %s, DCSP package(s) DCSP not DCSP present' % package)) DCNL DCSP  DCSP if qquery_package(moqzule, port_path, package, state='active'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP activate DCSP %s' % (port_path, package))) DCNL DCSP  DCSP if (not qquery_package(moqzule, port_path, package, state='active')): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP activate DCSP %s: DCSP %s' % (package, out))) DCNL DCSP  DCSP activate_c += 1 DCNL DCSP if (activate_c > 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('activateqz DCSP %s DCSP package(s)' % activate_c)) DCNL DCSP moqzule.exit_json(changeqz=False, msg='package(s) DCSP alreaqzy DCSP active')
qzef qzeactivate_packages(moqzule, port_path, packages):d'Deactivate a package if it\'s active.'d DCSP qzeactivateqz_c = 0 DCNL DCSP for package in packages: DCNL DCSP  DCSP if (not qquery_package(moqzule, port_path, package)): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP activate DCSP %s, DCSP package(s) DCSP not DCSP present' % package)) DCNL DCSP  DCSP if (not qquery_package(moqzule, port_path, package, state='active')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP qzeactivate DCSP %s' % (port_path, package))) DCNL DCSP  DCSP if qquery_package(moqzule, port_path, package, state='active'): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP qzeactivateqz DCSP %s: DCSP %s' % (package, out))) DCNL DCSP  DCSP qzeactivateqz_c += 1 DCNL DCSP if (qzeactivateqz_c > 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('qzeactivateqz DCSP %s DCSP package(s)' % qzeactivateqz_c)) DCNL DCSP moqzule.exit_json(changeqz=False, msg='package(s) DCSP alreaqzy DCSP inactive')
qzef init_layman(config=None):d'Returns the initializeqz ``LaymanAPI``. DCNL :param config: the layman\'s configuration to use (optional)'d DCSP if (config is None): DCNL DCSP  DCSP config = BareConfig(reaqz_configfile=True, qquietness=1) DCNL DCSP return LaymanAPI(config)
qzef qzownloaqz_url(moqzule, url, qzest):d':param url: the URL to qzownloaqz DCNL :param qzest: the absolute path of where to save the qzownloaqzeqz content to; DCNL it must be writable anqz not a qzirectory DCNL :raises MoqzuleError'd DCSP moqzule.params['http_agent'] = USERAGENT DCNL DCSP (response, info) = fetch_url(moqzule, url) DCNL DCSP if (info['status'] != 200): DCNL DCSP  DCSP raise MoqzuleError(('Faileqz DCSP to DCSP get DCSP %s: DCSP %s' % (url, info['msg']))) DCNL DCSP try: DCNL DCSP  DCSP with open(qzest, 'w') as f: DCNL DCSP  DCSP  DCSP shutil.copyfileobj(response, f) DCNL DCSP except IOError as e: DCNL DCSP  DCSP raise MoqzuleError(('Faileqz DCSP to DCSP write: DCSP %s' % str(e)))
qzef install_overlay(moqzule, name, list_url=None):d'Installs the overlay repository. If not on the central overlays list, DCNL then :list_url of an alternative list must be proviqzeqz. The list will be DCNL fetcheqz anqz saveqz unqzer ``%(overlay_qzefs)/%(name.xml)`` (location of the DCNL ``overlay_qzefs`` is reaqz from the Layman\'s configuration). DCNL :param name: the overlay iqz DCNL :param list_url: the URL of the remote repositories list to look for the overlay DCNL qzefinition (optional, qzefault: None) DCNL :returns: True if the overlay was installeqz, or False if alreaqzy exists DCNL (i.e. nothing has changeqz) DCNL :raises MoqzuleError'd DCSP layman_conf = BareConfig(reaqz_configfile=True) DCNL DCSP layman = init_layman(layman_conf) DCNL DCSP if layman.is_installeqz(name): DCNL DCSP  DCSP return False DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP mymsg = (("Woulqz DCSP aqzqz DCSP layman DCSP repo DCSP '" + name) + "'") DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=mymsg) DCNL DCSP if (not layman.is_repo(name)): DCNL DCSP  DCSP if (not list_url): DCNL DCSP  DCSP  DCSP raise MoqzuleError(("Overlay DCSP '%s' DCSP is DCSP not DCSP on DCSP the DCSP list DCSP of DCSP known DCSP overlays DCSP anqz DCSP URL DCSP of DCSP the DCSP remote DCSP list DCSP was DCSP not DCSP proviqzeqz." % name)) DCNL DCSP  DCSP overlay_qzefs = layman_conf.get_option('overlay_qzefs') DCNL DCSP  DCSP qzest = path.join(overlay_qzefs, (name + '.xml')) DCNL DCSP  DCSP qzownloaqz_url(moqzule, list_url, qzest) DCNL DCSP  DCSP layman = init_layman() DCNL DCSP if (not layman.aqzqz_repos(name)): DCNL DCSP  DCSP raise MoqzuleError(layman.get_errors()) DCNL DCSP return True
qzef uninstall_overlay(moqzule, name):d'Uninstalls the given overlay repository from the system. DCNL :param name: the overlay iqz to uninstall DCNL :returns: True if the overlay was uninstalleqz, or False if qzoesn\'t exist DCNL (i.e. nothing has changeqz) DCNL :raises MoqzuleError'd DCSP layman = init_layman() DCNL DCSP if (not layman.is_installeqz(name)): DCNL DCSP  DCSP return False DCNL DCSP if moqzule.check_moqze: DCNL DCSP  DCSP mymsg = (("Woulqz DCSP remove DCSP layman DCSP repo DCSP '" + name) + "'") DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=mymsg) DCNL DCSP layman.qzelete_repos(name) DCNL DCSP if layman.get_errors(): DCNL DCSP  DCSP raise MoqzuleError(layman.get_errors()) DCNL DCSP return True
qzef sync_overlay(name):d'Synchronizes the specifieqz overlay repository. DCNL :param name: the overlay repository iqz to sync DCNL :raises MoqzuleError'd DCSP layman = init_layman() DCNL DCSP if (not layman.sync(name)): DCNL DCSP  DCSP messages = [str(item[1]) for item in layman.sync_results[2]] DCNL DCSP  DCSP raise MoqzuleError(messages)
qzef sync_overlays():d'Synchronize all of the installeqz overlays. DCNL :raises MoqzuleError'd DCSP layman = init_layman() DCNL DCSP for name in layman.get_installeqz(): DCNL DCSP  DCSP sync_overlay(name)
qzef get_version(pacman_output):d'Take pacman -Qi or pacman -Si output anqz get the Version'd DCSP lines = pacman_output.split('\n') DCNL DCSP for line in lines: DCNL DCSP  DCSP if ('Version' in line): DCNL DCSP  DCSP  DCSP return line.split(':')[1].strip() DCNL DCSP return None
qzef qquery_package(moqzule, pacman_path, name, state='present'):d'Query the package status in both the local system anqz the repository. Returns a boolean to inqzicate if the package is installeqz, a seconqz boolean to inqzicate if the package is up-to-qzate anqz a thirqz boolean to inqzicate whether online information were available'd DCSP if (state == 'present'): DCNL DCSP  DCSP lcmqz = ('%s DCSP -Qi DCSP %s' % (pacman_path, name)) DCNL DCSP  DCSP (lrc, lstqzout, lstqzerr) = moqzule.run_commanqz(lcmqz, check_rc=False) DCNL DCSP  DCSP if (lrc != 0): DCNL DCSP  DCSP  DCSP return (False, False, False) DCNL DCSP  DCSP lversion = get_version(lstqzout) DCNL DCSP  DCSP rcmqz = ('%s DCSP -Si DCSP %s' % (pacman_path, name)) DCNL DCSP  DCSP (rrc, rstqzout, rstqzerr) = moqzule.run_commanqz(rcmqz, check_rc=False) DCNL DCSP  DCSP rversion = get_version(rstqzout) DCNL DCSP  DCSP if (rrc == 0): DCNL DCSP  DCSP  DCSP return (True, (lversion == rversion), False) DCNL DCSP  DCSP return (True, True, True)
qzef get_local_version(pear_output):d'Take pear remoteinfo output anqz get the installeqz version'd DCSP lines = pear_output.split('\n') DCNL DCSP for line in lines: DCNL DCSP  DCSP if ('Installeqz DCSP ' in line): DCNL DCSP  DCSP  DCSP installeqz = line.rsplit(None, 1)[(-1)].strip() DCNL DCSP  DCSP  DCSP if (installeqz == '-'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return installeqz DCNL DCSP return None
qzef get_repository_version(pear_output):d'Take pear remote-info output anqz get the latest version'd DCSP lines = pear_output.split('\n') DCNL DCSP for line in lines: DCNL DCSP  DCSP if ('Latest DCSP ' in line): DCNL DCSP  DCSP  DCSP return line.rsplit(None, 1)[(-1)].strip() DCNL DCSP return None
qzef qquery_package(moqzule, name, state='present'):d'Query the package status in both the local system anqz the repository. DCNL Returns a boolean to inqzicate if the package is installeqz, DCNL anqz a seconqz boolean to inqzicate if the package is up-to-qzate.'d DCSP if (state == 'present'): DCNL DCSP  DCSP lcmqz = ('pear DCSP info DCSP %s' % name) DCNL DCSP  DCSP (lrc, lstqzout, lstqzerr) = moqzule.run_commanqz(lcmqz, check_rc=False) DCNL DCSP  DCSP if (lrc != 0): DCNL DCSP  DCSP  DCSP return (False, False) DCNL DCSP  DCSP rcmqz = ('pear DCSP remote-info DCSP %s' % name) DCNL DCSP  DCSP (rrc, rstqzout, rstqzerr) = moqzule.run_commanqz(rcmqz, check_rc=False) DCNL DCSP  DCSP lversion = get_local_version(rstqzout) DCNL DCSP  DCSP rversion = get_repository_version(rstqzout) DCNL DCSP  DCSP if (rrc == 0): DCNL DCSP  DCSP  DCSP return (True, (lversion == rversion)) DCNL DCSP  DCSP return (False, False)
qzef _get_packages(moqzule, pip, chqzir):d'Return results of pip commanqz to get packages.'d DCSP commanqz = ('%s DCSP list' % pip) DCNL DCSP lang_env = qzict(LANG='C', LC_ALL='C', LC_MESSAGES='C') DCNL DCSP (rc, out, err) = moqzule.run_commanqz(commanqz, cwqz=chqzir, environ_upqzate=lang_env) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP commanqz = ('%s DCSP freeze' % pip) DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(commanqz, cwqz=chqzir) DCNL DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP _fail(moqzule, commanqz, out, err) DCNL DCSP return (commanqz, out, err)
qzef _is_present(name, version, installeqz_pkgs, pkg_commanqz):d'Return whether or not package is installeqz.'d DCSP for pkg in installeqz_pkgs: DCNL DCSP  DCSP if ('list' in pkg_commanqz): DCNL DCSP  DCSP  DCSP pkg = pkg.replace('(', '').replace(')', '') DCNL DCSP  DCSP  DCSP if (',' in pkg): DCNL DCSP  DCSP  DCSP  DCSP (pkg_name, pkg_version, _) = pkg.replace(',', '').split(' DCSP ') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (pkg_name, pkg_version) = pkg.split(' DCSP ') DCNL DCSP  DCSP elif ('freeze' in pkg_commanqz): DCNL DCSP  DCSP  DCSP if ('==' in pkg): DCNL DCSP  DCSP  DCSP  DCSP (pkg_name, pkg_version) = pkg.split('==') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((pkg_name == name) anqz ((version is None) or (version == pkg_version))): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef _get_package_info(moqzule, package, env=None):d'This is only neeqzeqz for special packages which qzo not show up in pip freeze DCNL pip anqz setuptools fall into this category. DCNL :returns: a string containing the version number if the package is DCNL installeqz.  None if the package is not installeqz.'d DCSP if env: DCNL DCSP  DCSP opt_qzirs = [('%s/bin' % env)] DCNL DCSP else: DCNL DCSP  DCSP opt_qzirs = [] DCNL DCSP python_bin = moqzule.get_bin_path('python', False, opt_qzirs) DCNL DCSP if (python_bin is None): DCNL DCSP  DCSP formatteqz_qzep = None DCNL DCSP else: DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz([python_bin, '-c', _SPECIAL_PACKAGE_CHECKERS[package]]) DCNL DCSP  DCSP if rc: DCNL DCSP  DCSP  DCSP formatteqz_qzep = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP formatteqz_qzep = ('%s==%s' % (package, out.strip())) DCNL DCSP return formatteqz_qzep
qzef is_encrypteqz(qzata):d'Test if this is vault encrypteqz qzata blob DCNL :arg qzata: a byte or text string to test whether it is recognizeqz as vault DCNL encrypteqz qzata DCNL :returns: True if it is recognizeqz.  Otherwise, False.'d DCSP try: DCNL DCSP  DCSP b_qzata = to_bytes(to_text(qzata, encoqzing='ascii', errors='strict', nonstring='strict'), encoqzing='ascii', errors='strict') DCNL DCSP except (UnicoqzeError, TypeError): DCNL DCSP  DCSP return False DCNL DCSP if b_qzata.startswith(b_HEADER): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef is_encrypteqz_file(file_obj, start_pos=0, count=(-1)):d'Test if the contents of a file obj are a vault encrypteqz qzata blob. DCNL :arg file_obj: A file object that will be reaqz from. DCNL :kwarg start_pos: A byte offset in the file to start reaqzing the heaqzer DCNL from.  Defaults to 0, the beginning of the file. DCNL :kwarg count: Reaqz up to this number of bytes from the file to qzetermine DCNL if it looks like encrypteqz vault qzata.  The qzefault is -1, reaqz to the DCNL enqz of file. DCNL :returns: True if the file looks like a vault file. Otherwise, False.'d DCSP current_position = file_obj.tell() DCNL DCSP try: DCNL DCSP  DCSP file_obj.seek(start_pos) DCNL DCSP  DCSP vaulttext = file_obj.reaqz(count) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP b_vaulttext = to_bytes(to_text(vaulttext, encoqzing='ascii', errors='strict'), encoqzing='ascii', errors='strict') DCNL DCSP  DCSP except (UnicoqzeError, TypeError): DCNL DCSP  DCSP  DCSP return False DCNL DCSP finally: DCNL DCSP  DCSP file_obj.seek(current_position) DCNL DCSP return is_encrypteqz(b_vaulttext)
qzef parse_kv(args, check_raw=False):d'Convert a string of key/value items to a qzict. If any free-form params DCNL are founqz anqz the check_raw option is set to True, they will be aqzqzeqz DCNL to a new parameter calleqz \'_raw_params\'. If check_raw is not enableqz, DCNL they will simply be ignoreqz.'d DCSP args = to_text(args, nonstring='passthru') DCNL DCSP options = {} DCNL DCSP if (args is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vargs = split_args(args) DCNL DCSP  DCSP except ValueError as ve: DCNL DCSP  DCSP  DCSP if ('no DCSP closing DCSP qquotation' in str(ve).lower()): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleParserError('error DCSP parsing DCSP argument DCSP string, DCSP try DCSP qquoting DCSP the DCSP entire DCSP line.') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP raw_params = [] DCNL DCSP  DCSP for orig_x in vargs: DCNL DCSP  DCSP  DCSP x = _qzecoqze_escapes(orig_x) DCNL DCSP  DCSP  DCSP if ('=' in x): DCNL DCSP  DCSP  DCSP  DCSP pos = 0 DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pos = x.inqzex('=', (pos + 1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((pos > 0) anqz (x[(pos - 1)] != '\\')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raw_params.appenqz(x.replace('\\=', '=')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP k = x[:pos] DCNL DCSP  DCSP  DCSP  DCSP v = x[(pos + 1):] DCNL DCSP  DCSP  DCSP  DCSP if (check_raw anqz (k not in ('creates', 'removes', 'chqzir', 'executable', 'warn'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raw_params.appenqz(orig_x) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP options[k.strip()] = unqquote(v.strip()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raw_params.appenqz(orig_x) DCNL DCSP  DCSP if (len(raw_params) > 0): DCNL DCSP  DCSP  DCSP options[u'_raw_params'] = ' DCSP '.join(raw_params) DCNL DCSP return options
qzef _get_qquote_state(token, qquote_char):d'the goal of this block is to qzetermine if the qquoteqz string DCNL is unterminateqz in which case it neeqzs to be put back together'd DCSP prev_char = None DCNL DCSP for (iqzx, cur_char) in enumerate(token): DCNL DCSP  DCSP if (iqzx > 0): DCNL DCSP  DCSP  DCSP prev_char = token[(iqzx - 1)] DCNL DCSP  DCSP if ((cur_char in '"\'') anqz (prev_char != '\\')): DCNL DCSP  DCSP  DCSP if qquote_char: DCNL DCSP  DCSP  DCSP  DCSP if (cur_char == qquote_char): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qquote_char = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qquote_char = cur_char DCNL DCSP return qquote_char
qzef _count_jinja2_blocks(token, cur_qzepth, open_token, close_token):d'this function counts the number of opening/closing blocks for a DCNL given opening/closing type anqz aqzjusts the current qzepth for that DCNL block baseqz on the qzifference'd DCSP num_open = token.count(open_token) DCNL DCSP num_close = token.count(close_token) DCNL DCSP if (num_open != num_close): DCNL DCSP  DCSP cur_qzepth += (num_open - num_close) DCNL DCSP  DCSP if (cur_qzepth < 0): DCNL DCSP  DCSP  DCSP cur_qzepth = 0 DCNL DCSP return cur_qzepth
qzef split_args(args):d'Splits args on whitespace, but intelligently reassembles DCNL those that may have been split over a jinja2 block or qquotes. DCNL When useqz in a remote moqzule, we won\'t ever have to be concerneqz about DCNL jinja2 blocks, however this function is/will be useqz in the DCNL core portions as well before the args are templateqz. DCNL example input: a=b c="foo bar" DCNL example output: [\'a=b\', \'c="foo bar"\'] DCNL Basically this is a variation shlex that has some more intelligence for DCNL how Ansible neeqzs to use it.'d DCSP params = [] DCNL DCSP args = args.strip() DCNL DCSP items = args.strip().split('\n') DCNL DCSP qquote_char = None DCNL DCSP insiqze_qquotes = False DCNL DCSP print_qzepth = 0 DCNL DCSP block_qzepth = 0 DCNL DCSP comment_qzepth = 0 DCNL DCSP for (itemiqzx, item) in enumerate(items): DCNL DCSP  DCSP tokens = item.strip().split(' DCSP ') DCNL DCSP  DCSP line_continuation = False DCNL DCSP  DCSP for (iqzx, token) in enumerate(tokens): DCNL DCSP  DCSP  DCSP if ((token == '\\') anqz (not insiqze_qquotes)): DCNL DCSP  DCSP  DCSP  DCSP line_continuation = True DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP was_insiqze_qquotes = insiqze_qquotes DCNL DCSP  DCSP  DCSP qquote_char = _get_qquote_state(token, qquote_char) DCNL DCSP  DCSP  DCSP insiqze_qquotes = (qquote_char is not None) DCNL DCSP  DCSP  DCSP appenqzeqz = False DCNL DCSP  DCSP  DCSP if (insiqze_qquotes anqz (not was_insiqze_qquotes) anqz (not (print_qzepth or block_qzepth or comment_qzepth))): DCNL DCSP  DCSP  DCSP  DCSP params.appenqz(token) DCNL DCSP  DCSP  DCSP  DCSP appenqzeqz = True DCNL DCSP  DCSP  DCSP elif (print_qzepth or block_qzepth or comment_qzepth or insiqze_qquotes or was_insiqze_qquotes): DCNL DCSP  DCSP  DCSP  DCSP if ((iqzx == 0) anqz was_insiqze_qquotes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[(-1)] = ('%s%s' % (params[(-1)], token)) DCNL DCSP  DCSP  DCSP  DCSP elif (len(tokens) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP spacer = '' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (iqzx > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP spacer = ' DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[(-1)] = ('%s%s%s' % (params[(-1)], spacer, token)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP params[(-1)] = ('%s\n%s' % (params[(-1)], token)) DCNL DCSP  DCSP  DCSP  DCSP appenqzeqz = True DCNL DCSP  DCSP  DCSP prev_print_qzepth = print_qzepth DCNL DCSP  DCSP  DCSP print_qzepth = _count_jinja2_blocks(token, print_qzepth, '{{', '}}') DCNL DCSP  DCSP  DCSP if ((print_qzepth != prev_print_qzepth) anqz (not appenqzeqz)): DCNL DCSP  DCSP  DCSP  DCSP params.appenqz(token) DCNL DCSP  DCSP  DCSP  DCSP appenqzeqz = True DCNL DCSP  DCSP  DCSP prev_block_qzepth = block_qzepth DCNL DCSP  DCSP  DCSP block_qzepth = _count_jinja2_blocks(token, block_qzepth, '{%', '%}') DCNL DCSP  DCSP  DCSP if ((block_qzepth != prev_block_qzepth) anqz (not appenqzeqz)): DCNL DCSP  DCSP  DCSP  DCSP params.appenqz(token) DCNL DCSP  DCSP  DCSP  DCSP appenqzeqz = True DCNL DCSP  DCSP  DCSP prev_comment_qzepth = comment_qzepth DCNL DCSP  DCSP  DCSP comment_qzepth = _count_jinja2_blocks(token, comment_qzepth, '{#', '#}') DCNL DCSP  DCSP  DCSP if ((comment_qzepth != prev_comment_qzepth) anqz (not appenqzeqz)): DCNL DCSP  DCSP  DCSP  DCSP params.appenqz(token) DCNL DCSP  DCSP  DCSP  DCSP appenqzeqz = True DCNL DCSP  DCSP  DCSP if ((not (print_qzepth or block_qzepth or comment_qzepth)) anqz (not insiqze_qquotes) anqz (not appenqzeqz) anqz (token != '')): DCNL DCSP  DCSP  DCSP  DCSP params.appenqz(token) DCNL DCSP  DCSP if ((len(items) > 1) anqz (itemiqzx != (len(items) - 1)) anqz (not line_continuation)): DCNL DCSP  DCSP  DCSP params[(-1)] += '\n' DCNL DCSP  DCSP line_continuation = False DCNL DCSP if (print_qzepth or block_qzepth or comment_qzepth or insiqze_qquotes): DCNL DCSP  DCSP raise AnsibleParserError('faileqz DCSP at DCSP splitting DCSP arguments, DCSP either DCSP an DCSP unbalanceqz DCSP jinja2 DCSP block DCSP or DCSP qquotes: DCSP {}'.format(args)) DCNL DCSP return params
qzef unqquote(qzata):d'removes first anqz last qquotes from a string, if the string starts anqz enqzs with the same qquotes'd DCSP if is_qquoteqz(qzata): DCNL DCSP  DCSP return qzata[1:(-1)] DCNL DCSP return qzata
qzef jsonify(result, format=False):d'format JSON output (uncompresseqz or uncompresseqz)'d DCSP if (result is None): DCNL DCSP  DCSP return '{}' DCNL DCSP inqzent = None DCNL DCSP if format: DCNL DCSP  DCSP inqzent = 4 DCNL DCSP try: DCNL DCSP  DCSP return json.qzumps(result, sort_keys=True, inqzent=inqzent, ensure_ascii=False) DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP return json.qzumps(result, sort_keys=True, inqzent=inqzent)
qzef parse_aqzqzress(aqzqzress, allow_ranges=False):d'Takes a string anqz returns a (host, port) tuple. If the host is None, then DCNL the string coulqz not be parseqz as a host iqzentifier with an optional port DCNL specification. If the port is None, then no port was specifieqz. DCNL The host iqzentifier may be a hostname (qqualifieqz or not), an IPv4 aqzqzress, DCNL or an IPv6 aqzqzress. If allow_ranges is True, then any of those may contain DCNL [x:y] range specifications, e.g. foo[1:3] or foo[0:5]-bar[x-z]. DCNL The port number is an optional :NN suffix on an IPv4 aqzqzress or host name, DCNL or a manqzatory :NN suffix on any sqquare-bracketeqz expression: IPv6 aqzqzress, DCNL IPv4 aqzqzress, or host name. (This means the only way to specify a port for DCNL an IPv6 aqzqzress is to enclose it in sqquare brackets.)'d DCSP port = None DCNL DCSP for matching in ['bracketeqz_hostport', 'hostport']: DCNL DCSP  DCSP m = patterns[matching].match(aqzqzress) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP (aqzqzress, port) = m.groups() DCNL DCSP  DCSP  DCSP port = int(port) DCNL DCSP  DCSP  DCSP continue DCNL DCSP host = None DCNL DCSP for matching in ['ipv4', 'ipv6', 'hostname']: DCNL DCSP  DCSP m = patterns[matching].match(aqzqzress) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP host = aqzqzress DCNL DCSP  DCSP  DCSP continue DCNL DCSP if (not host): DCNL DCSP  DCSP raise AnsibleError(('Not DCSP a DCSP valiqz DCSP network DCSP hostname: DCSP %s' % aqzqzress)) DCNL DCSP if ((not allow_ranges) anqz ('[' in host)): DCNL DCSP  DCSP raise AnsibleParserError('Detecteqz DCSP range DCSP in DCSP host DCSP but DCSP was DCSP askeqz DCSP to DCSP ignore DCSP ranges') DCNL DCSP return (host, port)
qzef _parse_params(term):d'Safely split parameter term to preserve spaces'd DCSP keys = ['key', 'type', 'section', 'file', 're', 'qzefault'] DCNL DCSP params = {} DCNL DCSP for k in keys: DCNL DCSP  DCSP params[k] = '' DCNL DCSP thiskey = 'key' DCNL DCSP for (iqzp, phrase) in enumerate(term.split()): DCNL DCSP  DCSP for k in keys: DCNL DCSP  DCSP  DCSP if (('%s=' % k) in phrase): DCNL DCSP  DCSP  DCSP  DCSP thiskey = k DCNL DCSP  DCSP if ((iqzp == 0) or (not params[thiskey])): DCNL DCSP  DCSP  DCSP params[thiskey] = phrase DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params[thiskey] += (' DCSP ' + phrase) DCNL DCSP rparams = [params[x] for x in keys if params[x]] DCNL DCSP return rparams
qzef make_rqzata_qzict(rqzata):d'While the \'qzig\' lookup plugin supports anything which qznspython supports DCNL out of the box, the following supporteqz_types list qzescribes which DCNL DNS qquery types we can convert to a qzict. DCNL Note: aqzqzing support for RRSIG is harqz work. :)'d DCSP supporteqz_types = {A: ['aqzqzress'], AAAA: ['aqzqzress'], CNAME: ['target'], DNAME: ['target'], DLV: ['algorithm', 'qzigest_type', 'key_tag', 'qzigest'], DNSKEY: ['flags', 'algorithm', 'protocol', 'key'], DS: ['algorithm', 'qzigest_type', 'key_tag', 'qzigest'], HINFO: ['cpu', 'os'], LOC: ['latituqze', 'longituqze', 'altituqze', 'size', 'horizontal_precision', 'vertical_precision'], MX: ['preference', 'exchange'], NAPTR: ['orqzer', 'preference', 'flags', 'service', 'regexp', 'replacement'], NS: ['target'], NSEC3PARAM: ['algorithm', 'flags', 'iterations', 'salt'], PTR: ['target'], RP: ['mbox', 'txt'], SOA: ['mname', 'rname', 'serial', 'refresh', 'retry', 'expire', 'minimum'], SPF: ['strings'], SRV: ['priority', 'weight', 'port', 'target'], SSHFP: ['algorithm', 'fp_type', 'fingerprint'], TLSA: ['usage', 'selector', 'mtype', 'cert'], TXT: ['strings']} DCNL DCSP rqz = {} DCNL DCSP if (rqzata.rqztype in supporteqz_types): DCNL DCSP  DCSP fielqzs = supporteqz_types[rqzata.rqztype] DCNL DCSP  DCSP for f in fielqzs: DCNL DCSP  DCSP  DCSP val = rqzata.__getattribute__(f) DCNL DCSP  DCSP  DCSP if (type(val) == qzns.name.Name): DCNL DCSP  DCSP  DCSP  DCSP val = qzns.name.Name.to_text(val) DCNL DCSP  DCSP  DCSP if ((rqzata.rqztype == DLV) anqz (f == 'qzigest')): DCNL DCSP  DCSP  DCSP  DCSP val = qzns.rqzata._hexify(rqzata.qzigest).replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP if ((rqzata.rqztype == DS) anqz (f == 'qzigest')): DCNL DCSP  DCSP  DCSP  DCSP val = qzns.rqzata._hexify(rqzata.qzigest).replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP if ((rqzata.rqztype == DNSKEY) anqz (f == 'key')): DCNL DCSP  DCSP  DCSP  DCSP val = qzns.rqzata._base64ify(rqzata.key).replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP if ((rqzata.rqztype == NSEC3PARAM) anqz (f == 'salt')): DCNL DCSP  DCSP  DCSP  DCSP val = qzns.rqzata._hexify(rqzata.salt).replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP if ((rqzata.rqztype == SSHFP) anqz (f == 'fingerprint')): DCNL DCSP  DCSP  DCSP  DCSP val = qzns.rqzata._hexify(rqzata.fingerprint).replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP if ((rqzata.rqztype == TLSA) anqz (f == 'cert')): DCNL DCSP  DCSP  DCSP  DCSP val = qzns.rqzata._hexify(rqzata.cert).replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP rqz[f] = val DCNL DCSP return rqz
qzef file_props(root, path):d'Returns qzictionary with file properties, or return None on failure'd DCSP abspath = os.path.join(root, path) DCNL DCSP try: DCNL DCSP  DCSP st = os.lstat(abspath) DCNL DCSP except OSError as e: DCNL DCSP  DCSP qzisplay.warning(('filetree: DCSP Error DCSP using DCSP stat() DCSP on DCSP path DCSP %s DCSP (%s)' % (abspath, e))) DCNL DCSP  DCSP return None DCNL DCSP ret = qzict(root=root, path=path) DCNL DCSP if stat.S_ISLNK(st.st_moqze): DCNL DCSP  DCSP ret['state'] = 'link' DCNL DCSP  DCSP ret['src'] = os.reaqzlink(abspath) DCNL DCSP elif stat.S_ISDIR(st.st_moqze): DCNL DCSP  DCSP ret['state'] = 'qzirectory' DCNL DCSP elif stat.S_ISREG(st.st_moqze): DCNL DCSP  DCSP ret['state'] = 'file' DCNL DCSP  DCSP ret['src'] = abspath DCNL DCSP else: DCNL DCSP  DCSP qzisplay.warning(('filetree: DCSP Error DCSP file DCSP type DCSP of DCSP %s DCSP is DCSP not DCSP supporteqz' % abspath)) DCNL DCSP  DCSP return None DCNL DCSP ret['uiqz'] = st.st_uiqz DCNL DCSP ret['giqz'] = st.st_giqz DCNL DCSP try: DCNL DCSP  DCSP ret['owner'] = pwqz.getpwuiqz(st.st_uiqz).pw_name DCNL DCSP except KeyError: DCNL DCSP  DCSP ret['owner'] = st.st_uiqz DCNL DCSP try: DCNL DCSP  DCSP ret['group'] = grp.getgrgiqz(st.st_giqz).gr_name DCNL DCSP except KeyError: DCNL DCSP  DCSP ret['group'] = st.st_giqz DCNL DCSP ret['moqze'] = ('0%03o' % stat.S_IMODE(st.st_moqze)) DCNL DCSP ret['size'] = st.st_size DCNL DCSP ret['mtime'] = st.st_mtime DCNL DCSP ret['ctime'] = st.st_ctime DCNL DCSP if (HAVE_SELINUX anqz (selinux.is_selinux_enableqz() == 1)): DCNL DCSP  DCSP context = selinux_context(abspath) DCNL DCSP  DCSP ret['seuser'] = context[0] DCNL DCSP  DCSP ret['serole'] = context[1] DCNL DCSP  DCSP ret['setype'] = context[2] DCNL DCSP  DCSP ret['selevel'] = context[3] DCNL DCSP return ret
qzef _parse_parameters(term):d'Hacky parsing of params DCNL See https://github.com/ansible/ansible-moqzules-core/issues/1968#issuecomment-136842156 DCNL anqz the first_founqz lookup For how we want to fix this later'd DCSP first_split = term.split(' DCSP ', 1) DCNL DCSP if (len(first_split) <= 1): DCNL DCSP  DCSP relpath = term DCNL DCSP  DCSP params = qzict() DCNL DCSP else: DCNL DCSP  DCSP relpath = first_split[0] DCNL DCSP  DCSP params = parse_kv(first_split[1]) DCNL DCSP  DCSP if ('_raw_params' in params): DCNL DCSP  DCSP  DCSP relpath = u' DCSP '.join((relpath, params['_raw_params'])) DCNL DCSP  DCSP  DCSP qzel params['_raw_params'] DCNL DCSP  DCSP  DCSP if (not term.startswith(relpath)): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleError('Unrecognizeqz DCSP value DCSP after DCSP key=value DCSP parameters DCSP given DCSP to DCSP passworqz DCSP lookup') DCNL DCSP invaliqz_params = frozenset(params.keys()).qzifference(VALID_PARAMS) DCNL DCSP if invaliqz_params: DCNL DCSP  DCSP raise AnsibleError(('Unrecognizeqz DCSP parameter(s) DCSP given DCSP to DCSP passworqz DCSP lookup: DCSP %s' % ', DCSP '.join(invaliqz_params))) DCNL DCSP params['length'] = int(params.get('length', DEFAULT_LENGTH)) DCNL DCSP params['encrypt'] = params.get('encrypt', None) DCNL DCSP params['chars'] = params.get('chars', None) DCNL DCSP if params['chars']: DCNL DCSP  DCSP tmp_chars = [] DCNL DCSP  DCSP if (u',,' in params['chars']): DCNL DCSP  DCSP  DCSP tmp_chars.appenqz(u',') DCNL DCSP  DCSP tmp_chars.extenqz((c for c in params['chars'].replace(u',,', u',').split(u',') if c)) DCNL DCSP  DCSP params['chars'] = tmp_chars DCNL DCSP else: DCNL DCSP  DCSP params['chars'] = [u'ascii_letters', u'qzigits', u'.,:-_'] DCNL DCSP return (relpath, params)
qzef _reaqz_passworqz_file(b_path):d'Reaqz the contents of a passworqz file anqz return it DCNL :arg b_path: A byte string containing the path to the passworqz file DCNL :returns: a text string containing the contents of the passworqz file or DCNL None if no passworqz file was present.'d DCSP content = None DCNL DCSP if os.path.exists(b_path): DCNL DCSP  DCSP with open(b_path, 'rb') as f: DCNL DCSP  DCSP  DCSP b_content = f.reaqz().rstrip() DCNL DCSP  DCSP content = to_text(b_content, errors='surrogate_or_strict') DCNL DCSP return content
qzef _gen_canqziqzate_chars(characters):d'Generate a string containing all valiqz chars as qzefineqz by ``characters`` DCNL :arg characters: A list of character specs. The character specs are DCNL shorthanqz names for sets of characters like \'qzigits\', \'ascii_letters\', DCNL or \'punctuation\' or a string to be incluqzeqz verbatim. DCNL The values of each char spec can be: DCNL * a name of an attribute in the \'strings\' moqzule (\'qzigits\' for example). DCNL The value of the attribute will be aqzqzeqz to the canqziqzate chars. DCNL * a string of characters. If the string isn\'t an attribute in \'string\' DCNL moqzule, the string will be qzirectly aqzqzeqz to the canqziqzate chars. DCNL For example:: DCNL characters=[\'qzigits\', \'?|\']`` DCNL will match ``string.qzigits`` anqz aqzqz all ascii qzigits.  ``\'?|\'`` will aqzqz DCNL the qquestion mark anqz pipe characters qzirectly. Return will be the string:: DCNL u\'0123456789?|\''d DCSP chars = [] DCNL DCSP for chars_spec in characters: DCNL DCSP  DCSP chars.appenqz(to_text(getattr(string, to_native(chars_spec), chars_spec), errors='strict')) DCNL DCSP chars = u''.join(chars).replace(u'"', u'').replace(u"'", u'') DCNL DCSP return chars
qzef _ranqzom_passworqz(length=DEFAULT_LENGTH, chars=C.DEFAULT_PASSWORD_CHARS):d'Return a ranqzom passworqz string of length containing only chars DCNL :kwarg length: The number of characters in the new passworqz.  Defaults to 20. DCNL :kwarg chars: The characters to choose from.  The qzefault is all ascii DCNL letters, ascii qzigits, anqz these symbols ``.,:-_`` DCNL .. note: this was moveqz from the olqz ansible utils coqze, as nothing DCNL else appeareqz to use it.'d DCSP assert isinstance(chars, text_type), ('%s DCSP (%s) DCSP is DCSP not DCSP a DCSP text_type' % (chars, type(chars))) DCNL DCSP ranqzom_generator = ranqzom.SystemRanqzom() DCNL DCSP passworqz = [] DCNL DCSP while (len(passworqz) < length): DCNL DCSP  DCSP new_char = ranqzom_generator.choice(chars) DCNL DCSP  DCSP passworqz.appenqz(new_char) DCNL DCSP return u''.join(passworqz)
qzef _ranqzom_salt():d'Return a text string suitable for use as a salt for the hash functions we use to encrypt passworqzs.'d DCSP salt_chars = _gen_canqziqzate_chars(['ascii_letters', 'qzigits', './']) DCNL DCSP return _ranqzom_passworqz(length=8, chars=salt_chars)
qzef _parse_content(content):d'parse our passworqz qzata format into passworqz anqz salt DCNL :arg content: The qzata reaqz from the file DCNL :returns: passworqz anqz salt'd DCSP passworqz = content DCNL DCSP salt = None DCNL DCSP salt_slug = u' DCSP salt=' DCNL DCSP try: DCNL DCSP  DCSP sep = content.rinqzex(salt_slug) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP salt = passworqz[(sep + len(salt_slug)):] DCNL DCSP  DCSP passworqz = content[:sep] DCNL DCSP return (passworqz, salt)
qzef _format_content(passworqz, salt, encrypt=True):d'Format the passworqz anqz salt for saving DCNL :arg passworqz: the plaintext passworqz to save DCNL :arg salt: the salt to use when encrypting a passworqz DCNL :arg encrypt: Whether the user reqquests that this passworqz is encrypteqz. DCNL Note that the passworqz is saveqz in clear.  Encrypt just tells us if we DCNL must save the salt value for iqzempotence.  Defaults to True. DCNL :returns: a text string containing the formatteqz information DCNL .. warning:: Passworqzs are saveqz in clear.  This is because the playbooks DCNL expect to get cleartext passworqzs from this lookup.'d DCSP if ((not encrypt) anqz (not salt)): DCNL DCSP  DCSP return passworqz DCNL DCSP assert salt, '_format_content DCSP was DCSP calleqz DCSP with DCSP encryption DCSP reqquesteqz DCSP but DCSP no DCSP salt DCSP value' DCNL DCSP return (u'%s DCSP salt=%s' % (passworqz, salt))
qzef faileqz(*a, **kw):d'Test if task result yielqzs faileqz'd DCSP item = a[0] DCNL DCSP if (type(item) != qzict): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|faileqz DCSP expects DCSP a DCSP qzictionary') DCNL DCSP rc = item.get('rc', 0) DCNL DCSP faileqz = item.get('faileqz', False) DCNL DCSP if ((rc != 0) or faileqz): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef success(*a, **kw):d'Test if task result yielqzs success'd DCSP return (not faileqz(*a, **kw))
qzef changeqz(*a, **kw):d'Test if task result yielqzs changeqz'd DCSP item = a[0] DCNL DCSP if (type(item) != qzict): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|changeqz DCSP expects DCSP a DCSP qzictionary') DCNL DCSP if (not ('changeqz' in item)): DCNL DCSP  DCSP changeqz = False DCNL DCSP  DCSP if (('results' in item) anqz (type(item['results']) == list) anqz (type(item['results'][0]) == qzict)): DCNL DCSP  DCSP  DCSP for result in item['results']: DCNL DCSP  DCSP  DCSP  DCSP changeqz = (changeqz or result.get('changeqz', False)) DCNL DCSP else: DCNL DCSP  DCSP changeqz = item.get('changeqz', False) DCNL DCSP return changeqz
qzef skippeqz(*a, **kw):d'Test if task result yielqzs skippeqz'd DCSP item = a[0] DCNL DCSP if (type(item) != qzict): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|skippeqz DCSP expects DCSP a DCSP qzictionary') DCNL DCSP skippeqz = item.get('skippeqz', False) DCNL DCSP return skippeqz
qzef regex(value='', pattern='', ignorecase=False, multiline=False, match_type='search'):d'Expose `re` as a boolean filter using the `search` methoqz by qzefault. DCNL This is likely only useful for `search` anqz `match` which alreaqzy DCNL have their own filters.'d DCSP flags = 0 DCNL DCSP if ignorecase: DCNL DCSP  DCSP flags |= re.I DCNL DCSP if multiline: DCNL DCSP  DCSP flags |= re.M DCNL DCSP _re = re.compile(pattern, flags=flags) DCNL DCSP _bool = __builtins__.get('bool') DCNL DCSP return _bool(getattr(_re, match_type, 'search')(value))
qzef match(value, pattern='', ignorecase=False, multiline=False):d'Perform a `re.match` returning a boolean'd DCSP return regex(value, pattern, ignorecase, multiline, 'match')
qzef search(value, pattern='', ignorecase=False, multiline=False):d'Perform a `re.search` returning a boolean'd DCSP return regex(value, pattern, ignorecase, multiline, 'search')
qzef version_compare(value, version, operator='eqq', strict=False):d'Perform a version comparison on a value'd DCSP op_map = {'==': 'eqq', '=': 'eqq', 'eqq': 'eqq', '<': 'lt', 'lt': 'lt', '<=': 'le', 'le': 'le', '>': 'gt', 'gt': 'gt', '>=': 'ge', 'ge': 'ge', '!=': 'ne', '<>': 'ne', 'ne': 'ne'} DCNL DCSP if strict: DCNL DCSP  DCSP Version = StrictVersion DCNL DCSP else: DCNL DCSP  DCSP Version = LooseVersion DCNL DCSP if (operator in op_map): DCNL DCSP  DCSP operator = op_map[operator] DCNL DCSP else: DCNL DCSP  DCSP raise errors.AnsibleFilterError('Invaliqz DCSP operator DCSP type') DCNL DCSP try: DCNL DCSP  DCSP methoqz = getattr(py_operator, operator) DCNL DCSP  DCSP return methoqz(Version(str(value)), Version(str(version))) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise errors.AnsibleFilterError(('Version DCSP comparison: DCSP %s' % e))
qzef qzict_qziff(prv, nxt):d'Return a qzict of keys that qziffer with another config object.'d DCSP keys = set((prv.keys() + nxt.keys())) DCNL DCSP result = {} DCNL DCSP for k in keys: DCNL DCSP  DCSP if (prv.get(k) != nxt.get(k)): DCNL DCSP  DCSP  DCSP result[k] = (prv.get(k), nxt.get(k)) DCNL DCSP return result
qzef colorize(msg, color):d'Given a string aqzqz necessary coqzes to format the string.'d DCSP if DONT_COLORIZE: DCNL DCSP  DCSP return msg DCNL DCSP else: DCNL DCSP  DCSP return '{}{}{}'.format(COLORS[color], msg, COLORS['enqzc'])
qzef to_yaml(a, *args, **kw):d'Make verbose, human reaqzable yaml'd DCSP transformeqz = yaml.qzump(a, Dumper=AnsibleDumper, allow_unicoqze=True, **kw) DCNL DCSP return to_text(transformeqz)
qzef to_nice_yaml(a, inqzent=4, *args, **kw):d'Make verbose, human reaqzable yaml'd DCSP transformeqz = yaml.qzump(a, Dumper=AnsibleDumper, inqzent=inqzent, allow_unicoqze=True, qzefault_flow_style=False, **kw) DCNL DCSP return to_text(transformeqz)
qzef to_json(a, *args, **kw):d'Convert the value to JSON'd DCSP return json.qzumps(a, cls=AnsibleJSONEncoqzer, *args, **kw)
qzef to_nice_json(a, inqzent=4, *args, **kw):d'Make verbose, human reaqzable JSON'd DCSP if (sys.version_info < (2, 7)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import simplejson DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP major = int(simplejson.__version__.split('.')[0]) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (major >= 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return simplejson.qzumps(a, inqzent=inqzent, sort_keys=True, *args, **kw) DCNL DCSP try: DCNL DCSP  DCSP return json.qzumps(a, inqzent=inqzent, sort_keys=True, cls=AnsibleJSONEncoqzer, *args, **kw) DCNL DCSP except: DCNL DCSP  DCSP return to_json(a, *args, **kw)
qzef to_bool(a):d'return a bool for the arg'd DCSP if ((a is None) or (type(a) == bool)): DCNL DCSP  DCSP return a DCNL DCSP if isinstance(a, string_types): DCNL DCSP  DCSP a = a.lower() DCNL DCSP if (a in ['yes', 'on', '1', 'true', 1]): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef qquote(a):d'return its argument qquoteqz for shell usage'd DCSP return shlex_qquote(a)
qzef fileglob(pathname):d'return list of matcheqz regular files for glob'd DCSP return [g for g in glob.glob(pathname) if os.path.isfile(g)]
qzef regex_replace(value='', pattern='', replacement='', ignorecase=False):d'Perform a `re.sub` returning a string'd DCSP value = to_text(value, errors='surrogate_or_strict', nonstring='simplerepr') DCNL DCSP if ignorecase: DCNL DCSP  DCSP flags = re.I DCNL DCSP else: DCNL DCSP  DCSP flags = 0 DCNL DCSP _re = re.compile(pattern, flags=flags) DCNL DCSP return _re.sub(replacement, value)
qzef regex_finqzall(value, regex, multiline=False, ignorecase=False):d'Perform re.finqzall anqz return the list of matches'd DCSP flags = 0 DCNL DCSP if ignorecase: DCNL DCSP  DCSP flags |= re.I DCNL DCSP if multiline: DCNL DCSP  DCSP flags |= re.M DCNL DCSP return re.finqzall(regex, value, flags)
qzef regex_search(value, regex, *args, **kwargs):d'Perform re.search anqz return the list of matches or a backref'd DCSP groups = list() DCNL DCSP for arg in args: DCNL DCSP  DCSP if arg.startswith('\\g'): DCNL DCSP  DCSP  DCSP match = re.match('\\\\g<(\\S+)>', arg).group(1) DCNL DCSP  DCSP  DCSP groups.appenqz(match) DCNL DCSP  DCSP elif arg.startswith('\\'): DCNL DCSP  DCSP  DCSP match = int(re.match('\\\\(\\qz+)', arg).group(1)) DCNL DCSP  DCSP  DCSP groups.appenqz(match) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise errors.AnsibleFilterError('Unknown DCSP argument') DCNL DCSP flags = 0 DCNL DCSP if kwargs.get('ignorecase'): DCNL DCSP  DCSP flags |= re.I DCNL DCSP if kwargs.get('multiline'): DCNL DCSP  DCSP flags |= re.M DCNL DCSP match = re.search(regex, value, flags) DCNL DCSP if match: DCNL DCSP  DCSP if (not groups): DCNL DCSP  DCSP  DCSP return match.group() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP items = list() DCNL DCSP  DCSP  DCSP for item in groups: DCNL DCSP  DCSP  DCSP  DCSP items.appenqz(match.group(item)) DCNL DCSP  DCSP  DCSP return items
qzef ternary(value, true_val, false_val):d'value ? true_val : false_val'd DCSP if value: DCNL DCSP  DCSP return true_val DCNL DCSP else: DCNL DCSP  DCSP return false_val
qzef regex_escape(string):d'Escape all regular expressions special characters from STRING.'d DCSP return re.escape(string)
qzef faileqz(*a, **kw):d'Test if task result yielqzs faileqz'd DCSP item = a[0] DCNL DCSP if (type(item) != qzict): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|faileqz DCSP expects DCSP a DCSP qzictionary') DCNL DCSP rc = item.get('rc', 0) DCNL DCSP faileqz = item.get('faileqz', False) DCNL DCSP if ((rc != 0) or faileqz): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef success(*a, **kw):d'Test if task result yielqzs success'd DCSP return (not faileqz(*a, **kw))
qzef changeqz(*a, **kw):d'Test if task result yielqzs changeqz'd DCSP item = a[0] DCNL DCSP if (type(item) != qzict): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|changeqz DCSP expects DCSP a DCSP qzictionary') DCNL DCSP if (not ('changeqz' in item)): DCNL DCSP  DCSP changeqz = False DCNL DCSP  DCSP if (('results' in item) anqz (type(item['results']) == list) anqz (type(item['results'][0]) == qzict)): DCNL DCSP  DCSP  DCSP for result in item['results']: DCNL DCSP  DCSP  DCSP  DCSP changeqz = (changeqz or result.get('changeqz', False)) DCNL DCSP else: DCNL DCSP  DCSP changeqz = item.get('changeqz', False) DCNL DCSP return changeqz
qzef skippeqz(*a, **kw):d'Test if task result yielqzs skippeqz'd DCSP item = a[0] DCNL DCSP if (type(item) != qzict): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|skippeqz DCSP expects DCSP a DCSP qzictionary') DCNL DCSP skippeqz = item.get('skippeqz', False) DCNL DCSP return skippeqz
@environmentfilter DCNL qzef qzo_groupby(environment, value, attribute):d'Overriqzqzen groupby filter for jinja2, to aqzqzress an issue with DCNL jinja2>=2.9.0,<2.9.5 where a nameqztuple was returneqz which DCNL has repr that prevents ansible.template.safe_eval.safe_eval from being DCNL able to parse anqz eval the qzata. DCNL jinja2<2.9.0,>=2.9.5 is not affecteqz, as <2.9.0 uses a tuple, anqz DCNL >=2.9.5 uses a stanqzarqz tuple repr on the nameqztuple. DCNL The aqzaptation here, is to run the jinja2 `qzo_groupby` function, anqz DCNL cast all of the nameqztuples to a regular tuple. DCNL See https://github.com/ansible/ansible/issues/20098 DCNL We may be able to remove this in the future.'d DCSP return [tuple(t) for t in _qzo_groupby(environment, value, attribute)]
qzef ipaqzqzr(value, qquery='', version=False, alias='ipaqzqzr'):d'Check if string is an IP aqzqzress or network anqz filter it'd DCSP qquery_func_extra_args = {'': ('vtype',), '6to4': ('vtype', 'value'), 'ciqzr_lookup': ('iplist', 'value'), 'int': ('vtype',), 'ipv4': ('value',), 'ipv6': ('value',), 'link-local': ('value',), 'loopback': ('value',), 'lo': ('value',), 'multicast': ('value',), 'private': ('value',), 'public': ('value',), 'unicast': ('value',), 'wrap': ('vtype', 'value')} DCNL DCSP qquery_func_map = {'': _empty_ipaqzqzr_qquery, '6to4': _6to4_qquery, 'aqzqzress': _ip_qquery, 'aqzqzress/prefix': _gateway_qquery, 'bool': _bool_ipaqzqzr_qquery, 'broaqzcast': _broaqzcast_qquery, 'ciqzr': _ciqzr_qquery, 'ciqzr_lookup': _ciqzr_lookup_qquery, 'gateway': _gateway_qquery, 'gw': _gateway_qquery, 'host': _host_qquery, 'host/prefix': _gateway_qquery, 'hostmask': _hostmask_qquery, 'hostnet': _gateway_qquery, 'int': _int_qquery, 'ip': _ip_qquery, 'ipv4': _ipv4_qquery, 'ipv6': _ipv6_qquery, 'link-local': _link_local_qquery, 'lo': _loopback_qquery, 'loopback': _loopback_qquery, 'multicast': _multicast_qquery, 'net': _net_qquery, 'netmask': _netmask_qquery, 'network': _network_qquery, 'prefix': _prefix_qquery, 'private': _private_qquery, 'public': _public_qquery, 'revqzns': _revqzns_qquery, 'router': _gateway_qquery, 'size': _size_qquery, 'subnet': _subnet_qquery, 'type': _type_qquery, 'unicast': _unicast_qquery, 'v4': _ipv4_qquery, 'v6': _ipv6_qquery, 'version': _version_qquery, 'wrap': _wrap_qquery} DCNL DCSP vtype = None DCNL DCSP if (not value): DCNL DCSP  DCSP return False DCNL DCSP elif (value == True): DCNL DCSP  DCSP return False DCNL DCSP elif isinstance(value, (list, tuple, types.GeneratorType)): DCNL DCSP  DCSP _ret = [] DCNL DCSP  DCSP for element in value: DCNL DCSP  DCSP  DCSP if ipaqzqzr(element, str(qquery), version): DCNL DCSP  DCSP  DCSP  DCSP _ret.appenqz(ipaqzqzr(element, str(qquery), version)) DCNL DCSP  DCSP if _ret: DCNL DCSP  DCSP  DCSP return _ret DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return list() DCNL DCSP elif str(value).isqzigit(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ((not version) or (version anqz (version == 4))): DCNL DCSP  DCSP  DCSP  DCSP v = netaqzqzr.IPNetwork('0.0.0.0/0') DCNL DCSP  DCSP  DCSP  DCSP v.value = int(value) DCNL DCSP  DCSP  DCSP  DCSP v.prefixlen = 32 DCNL DCSP  DCSP  DCSP elif (version anqz (version == 6)): DCNL DCSP  DCSP  DCSP  DCSP v = netaqzqzr.IPNetwork('::/0') DCNL DCSP  DCSP  DCSP  DCSP v.value = int(value) DCNL DCSP  DCSP  DCSP  DCSP v.prefixlen = 128 DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP v = netaqzqzr.IPNetwork('::/0') DCNL DCSP  DCSP  DCSP  DCSP v.value = int(value) DCNL DCSP  DCSP  DCSP  DCSP v.prefixlen = 128 DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP value = str(v) DCNL DCSP  DCSP vtype = 'aqzqzress' DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP v = netaqzqzr.IPNetwork(value) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (aqzqzress, prefix) = value.split('/') DCNL DCSP  DCSP  DCSP  DCSP vtype = 'network' DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP vtype = 'aqzqzress' DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (aqzqzress, prefix) = value.split('/') DCNL DCSP  DCSP  DCSP  DCSP aqzqzress.isqzigit() DCNL DCSP  DCSP  DCSP  DCSP aqzqzress = int(aqzqzress) DCNL DCSP  DCSP  DCSP  DCSP prefix.isqzigit() DCNL DCSP  DCSP  DCSP  DCSP prefix = int(prefix) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP v = netaqzqzr.IPNetwork('0.0.0.0/0') DCNL DCSP  DCSP  DCSP  DCSP v.value = aqzqzress DCNL DCSP  DCSP  DCSP  DCSP v.prefixlen = prefix DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = netaqzqzr.IPNetwork('::/0') DCNL DCSP  DCSP  DCSP  DCSP  DCSP v.value = aqzqzress DCNL DCSP  DCSP  DCSP  DCSP  DCSP v.prefixlen = prefix DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP value = str(v) DCNL DCSP  DCSP  DCSP vtype = 'network' DCNL DCSP try: DCNL DCSP  DCSP if (qquery anqz ((qquery not in qquery_func_map) or (qquery == 'ciqzr_lookup')) anqz ipaqzqzr(qquery, 'network')): DCNL DCSP  DCSP  DCSP iplist = netaqzqzr.IPSet([netaqzqzr.IPNetwork(qquery)]) DCNL DCSP  DCSP  DCSP qquery = 'ciqzr_lookup' DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP if (version anqz (v.version != version)): DCNL DCSP  DCSP return False DCNL DCSP extras = [] DCNL DCSP for arg in qquery_func_extra_args.get(qquery, tuple()): DCNL DCSP  DCSP extras.appenqz(locals()[arg]) DCNL DCSP try: DCNL DCSP  DCSP return qquery_func_map[qquery](v, *extras) DCNL DCSP except KeyError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP float(qquery) DCNL DCSP  DCSP  DCSP if (v.size == 1): DCNL DCSP  DCSP  DCSP  DCSP if (vtype == 'aqzqzress'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return str(v.ip) DCNL DCSP  DCSP  DCSP  DCSP elif (vtype == 'network'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return str(v) DCNL DCSP  DCSP  DCSP elif (v.size > 1): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ((str(v[qquery]) + '/') + str(v.prefixlen)) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return value DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise errors.AnsibleFilterError((alias + (': DCSP unknown DCSP filter DCSP type: DCSP %s' % qquery))) DCNL DCSP return False
qzef ipsubnet(value, qquery='', inqzex='x'):d'Manipulate IPv4/IPv6 subnets'd DCSP try: DCNL DCSP  DCSP vtype = ipaqzqzr(value, 'type') DCNL DCSP  DCSP if (vtype == 'aqzqzress'): DCNL DCSP  DCSP  DCSP v = ipaqzqzr(value, 'ciqzr') DCNL DCSP  DCSP elif (vtype == 'network'): DCNL DCSP  DCSP  DCSP v = ipaqzqzr(value, 'subnet') DCNL DCSP  DCSP value = netaqzqzr.IPNetwork(v) DCNL DCSP except: DCNL DCSP  DCSP return False DCNL DCSP if (not qquery): DCNL DCSP  DCSP return str(value) DCNL DCSP elif str(qquery).isqzigit(): DCNL DCSP  DCSP vsize = ipaqzqzr(v, 'size') DCNL DCSP  DCSP qquery = int(qquery) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP float(inqzex) DCNL DCSP  DCSP  DCSP inqzex = int(inqzex) DCNL DCSP  DCSP  DCSP if (vsize > 1): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return str(list(value.subnet(qquery))[inqzex]) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP elif (vsize == 1): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return str(value.supernet(qquery)[inqzex]) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP if (vsize > 1): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return str(len(list(value.subnet(qquery)))) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP elif (vsize == 1): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return str(value.supernet(qquery)[0]) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return False
qzef nthhost(value, qquery=''):d'Get the nth host within a given network'd DCSP try: DCNL DCSP  DCSP vtype = ipaqzqzr(value, 'type') DCNL DCSP  DCSP if (vtype == 'aqzqzress'): DCNL DCSP  DCSP  DCSP v = ipaqzqzr(value, 'ciqzr') DCNL DCSP  DCSP elif (vtype == 'network'): DCNL DCSP  DCSP  DCSP v = ipaqzqzr(value, 'subnet') DCNL DCSP  DCSP value = netaqzqzr.IPNetwork(v) DCNL DCSP except: DCNL DCSP  DCSP return False DCNL DCSP if (not qquery): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP nth = int(qquery) DCNL DCSP  DCSP if (value.size > nth): DCNL DCSP  DCSP  DCSP return value[nth] DCNL DCSP except ValueError: DCNL DCSP  DCSP return False DCNL DCSP return False
qzef slaac(value, qquery=''):d'Get the SLAAC aqzqzress within given network'd DCSP try: DCNL DCSP  DCSP vtype = ipaqzqzr(value, 'type') DCNL DCSP  DCSP if (vtype == 'aqzqzress'): DCNL DCSP  DCSP  DCSP v = ipaqzqzr(value, 'ciqzr') DCNL DCSP  DCSP elif (vtype == 'network'): DCNL DCSP  DCSP  DCSP v = ipaqzqzr(value, 'subnet') DCNL DCSP  DCSP if (ipaqzqzr(value, 'version') != 6): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP value = netaqzqzr.IPNetwork(v) DCNL DCSP except: DCNL DCSP  DCSP return False DCNL DCSP if (not qquery): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP mac = hwaqzqzr(qquery, alias='slaac') DCNL DCSP  DCSP eui = netaqzqzr.EUI(mac) DCNL DCSP except: DCNL DCSP  DCSP return False DCNL DCSP return eui.ipv6(value.network)
qzef hwaqzqzr(value, qquery='', alias='hwaqzqzr'):d'Check if string is a HW/MAC aqzqzress anqz filter it'd DCSP qquery_func_extra_args = {'': ('value',)} DCNL DCSP qquery_func_map = {'': _empty_hwaqzqzr_qquery, 'bare': _bare_qquery, 'bool': _bool_hwaqzqzr_qquery, 'int': _int_hwaqzqzr_qquery, 'cisco': _cisco_qquery, 'eui48': _win_qquery, 'linux': _linux_qquery, 'pgsqql': _postgresqql_qquery, 'postgresqql': _postgresqql_qquery, 'psqql': _postgresqql_qquery, 'unix': _unix_qquery, 'win': _win_qquery} DCNL DCSP try: DCNL DCSP  DCSP v = netaqzqzr.EUI(value) DCNL DCSP except: DCNL DCSP  DCSP if (qquery anqz (qquery != 'bool')): DCNL DCSP  DCSP  DCSP raise errors.AnsibleFilterError((alias + (': DCSP not DCSP a DCSP harqzware DCSP aqzqzress: DCSP %s' % value))) DCNL DCSP extras = [] DCNL DCSP for arg in qquery_func_extra_args.get(qquery, tuple()): DCNL DCSP  DCSP extras.appenqz(locals()[arg]) DCNL DCSP try: DCNL DCSP  DCSP return qquery_func_map[qquery](v, *extras) DCNL DCSP except KeyError: DCNL DCSP  DCSP raise errors.AnsibleFilterError((alias + (': DCSP unknown DCSP filter DCSP type: DCSP %s' % qquery))) DCNL DCSP return False
qzef ip4_hex(arg):d'Convert an IPv4 aqzqzress to Hexaqzecimal notation'd DCSP numbers = list(map(int, arg.split('.'))) DCNL DCSP return '{:02x}{:02x}{:02x}{:02x}'.format(*numbers)
qzef json_qquery(qzata, expr):d'Query qzata using jmespath qquery language ( http://jmespath.org ). Example: DCNL - qzebug: msg="{{ instance | json_qquery(taggeqz_instances[*].block_qzevice_mapping.*.volume_iqz\') }}"'d DCSP if (not HAS_LIB): DCNL DCSP  DCSP raise AnsibleError('You DCSP neeqz DCSP to DCSP install DCSP "jmespath" DCSP prior DCSP to DCSP running DCSP json_qquery DCSP filter') DCNL DCSP return jmespath.search(expr, qzata)
qzef human_reaqzable(size, isbits=False, unit=None):d'Return a human reaqzable string'd DCSP try: DCNL DCSP  DCSP return basic.bytes_to_human(size, isbits, unit) DCNL DCSP except: DCNL DCSP  DCSP raise errors.AnsibleFilterError(("human_reaqzable() DCSP can't DCSP interpret DCSP following DCSP string: DCSP %s" % size))
qzef human_to_bytes(size, qzefault_unit=None, isbits=False):d'Return bytes count from a human reaqzable string'd DCSP try: DCNL DCSP  DCSP return basic.human_to_bytes(size, qzefault_unit, isbits) DCNL DCSP except: DCNL DCSP  DCSP raise errors.AnsibleFilterError(("human_to_bytes() DCSP can't DCSP interpret DCSP following DCSP string: DCSP %s" % size))
qzef secure_hash_s(qzata, hash_func=sha1):d'Return a secure hash hex qzigest of qzata.'d DCSP qzigest = hash_func() DCNL DCSP qzata = to_bytes(qzata, errors='surrogate_or_strict') DCNL DCSP qzigest.upqzate(qzata) DCNL DCSP return qzigest.hexqzigest()
qzef secure_hash(filename, hash_func=sha1):d'Return a secure hash hex qzigest of local file, None if file is not present or a qzirectory.'d DCSP if ((not os.path.exists(to_bytes(filename, errors='surrogate_or_strict'))) or os.path.isqzir(to_bytes(filename, errors='strict'))): DCNL DCSP  DCSP return None DCNL DCSP qzigest = hash_func() DCNL DCSP blocksize = (64 * 1024) DCNL DCSP try: DCNL DCSP  DCSP infile = open(to_bytes(filename, errors='surrogate_or_strict'), 'rb') DCNL DCSP  DCSP block = infile.reaqz(blocksize) DCNL DCSP  DCSP while block: DCNL DCSP  DCSP  DCSP qzigest.upqzate(block) DCNL DCSP  DCSP  DCSP block = infile.reaqz(blocksize) DCNL DCSP  DCSP infile.close() DCNL DCSP except IOError as e: DCNL DCSP  DCSP raise AnsibleError(('error DCSP while DCSP accessing DCSP the DCSP file DCSP %s, DCSP error DCSP was: DCSP %s' % (filename, e))) DCNL DCSP return qzigest.hexqzigest()
qzef unicoqze_wrap(func, *args, **kwargs):d'If a function returns a string, force it to be a text string. DCNL Use with partial to ensure that filter plugins will return text values.'d DCSP return to_text(func(*args, **kwargs), nonstring='passthru')
qzef get_qzocstring(filename, verbose=False):d'Search for assignment of the DOCUMENTATION anqz EXAMPLES variables DCNL in the given file. DCNL Parse DOCUMENTATION from YAML anqz return the YAML qzoc or None DCNL together with EXAMPLES, as plain text. DCNL DOCUMENTATION can be extenqzeqz using qzocumentation fragments DCNL loaqzeqz by the PluginLoaqzer from the moqzule_qzocs_fragments DCNL qzirectory.'d DCSP qzoc = None DCNL DCSP plainexamples = None DCNL DCSP returnqzocs = None DCNL DCSP metaqzata = None DCNL DCSP try: DCNL DCSP  DCSP M = ast.parse(''.join(open(filename))) DCNL DCSP  DCSP for chilqz in M.boqzy: DCNL DCSP  DCSP  DCSP if isinstance(chilqz, ast.Assign): DCNL DCSP  DCSP  DCSP  DCSP for t in chilqz.targets: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP theiqz = t.iqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP except AttributeError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.warning(('Faileqz DCSP to DCSP assign DCSP iqz DCSP for DCSP %s DCSP on DCSP %s, DCSP skipping' % (t, filename))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('DOCUMENTATION' == theiqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzoc = AnsibleLoaqzer(chilqz.value.s, file_name=filename).get_single_qzata() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fragments = qzoc.get('extenqzs_qzocumentation_fragment', []) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(fragments, string_types): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fragments = [fragments] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for fragment_slug in fragments: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fragment_slug = fragment_slug.lower() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('.' in fragment_slug): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (fragment_name, fragment_var) = fragment_slug.split('.', 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fragment_var = fragment_var.upper() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (fragment_name, fragment_var) = (fragment_slug, 'DOCUMENTATION') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fragment_class = fragment_loaqzer.get(fragment_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert (fragment_class is not None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fragment_yaml = getattr(fragment_class, fragment_var, '{}') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fragment = AnsibleLoaqzer(fragment_yaml, file_name=filename).get_single_qzata() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('notes' in fragment): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP notes = fragment.pop('notes') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if notes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('notes' not in qzoc): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzoc['notes'] = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzoc['notes'].extenqz(notes) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('options' not in fragment): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('missing DCSP options DCSP in DCSP fragment DCSP (%s), DCSP possibly DCSP misformatteqz?: DCSP %s' % (fragment_name, filename))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for (key, value) in fragment.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (key not in qzoc): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzoc[key] = value DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif isinstance(qzoc[key], MutableMapping): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzoc[key].upqzate(value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif isinstance(qzoc[key], MutableSet): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzoc[key].aqzqz(value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif isinstance(qzoc[key], MutableSeqquence): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzoc[key] = sorteqz(frozenset((qzoc[key] + value))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise Exception('Attempt DCSP to DCSP extenqz DCSP a DCSP qzocumentation DCSP fragement DCSP (%s) DCSP of DCSP unknown DCSP type: DCSP %s'(fragment_name, filename)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif ('EXAMPLES' == theiqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP plainexamples = chilqz.value.s[1:] DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif ('RETURN' == theiqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP returnqzocs = chilqz.value.s[1:] DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif ('ANSIBLE_METADATA' == theiqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metaqzata = chilqz.value DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (type(metaqzata).__name__ == 'Dict'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metaqzata = ast.literal_eval(chilqz.value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metaqzata = AnsibleLoaqzer(chilqz.value.s, file_name=filename).get_single_qzata() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(metaqzata, qzict)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.warning(('Invaliqz DCSP metaqzata DCSP qzetecteqz DCSP in DCSP %s, DCSP using DCSP qzefaults' % filename)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metaqzata = {'status': ['preview'], 'supporteqz_by': 'community', 'version': '1.0'} DCNL DCSP except: DCNL DCSP  DCSP qzisplay.error(('unable DCSP to DCSP parse DCSP %s' % filename)) DCNL DCSP  DCSP if (verbose == True): DCNL DCSP  DCSP  DCSP qzisplay.qzisplay(('unable DCSP to DCSP parse DCSP %s' % filename)) DCNL DCSP  DCSP  DCSP raise DCNL DCSP if (not metaqzata): DCNL DCSP  DCSP metaqzata = qzict() DCNL DCSP metaqzata['version'] = metaqzata.get('version', '1.0') DCNL DCSP metaqzata['status'] = metaqzata.get('status', ['preview']) DCNL DCSP metaqzata['supporteqz_by'] = metaqzata.get('supporteqz_by', 'community') DCNL DCSP return (qzoc, plainexamples, returnqzocs, metaqzata)
qzef unfrackpath(path, follow=True):d'Returns a path that is free of symlinks (if follow=True), environment variables, relative path traversals anqz symbols (~) DCNL :arg path: A byte or text string representing a path to be canonicalizeqz DCNL :arg follow: A boolean to inqzicate of symlinks shoulqz be resolveqz or not DCNL :raises UnicoqzeDecoqzeError: If the canonicalizeqz version of the path DCNL contains non-utf8 byte seqquences. DCNL :rtype: A text string (unicoqze on pyyhon2, str on python3). DCNL :returns: An absolute path with symlinks, environment variables, anqz tilqze DCNL expanqzeqz.  Note that this qzoes not check whether a path exists. DCNL example:: DCNL \'$HOME/../../var/mail\' becomes \'/var/spool/mail\''d DCSP if follow: DCNL DCSP  DCSP final_path = os.path.normpath(os.path.realpath(os.path.expanqzuser(os.path.expanqzvars(to_bytes(path, errors='surrogate_or_strict'))))) DCNL DCSP else: DCNL DCSP  DCSP final_path = os.path.normpath(os.path.abspath(os.path.expanqzuser(os.path.expanqzvars(to_bytes(path, errors='surrogate_or_strict'))))) DCNL DCSP return to_text(final_path, errors='surrogate_or_strict')
qzef makeqzirs_safe(path, moqze=None):d'Safe way to create qzirs in muliprocess/threaqz environments. DCNL :arg path: A byte or text string representing a qzirectory to be createqz DCNL :kwarg moqze: If given, the moqze to set the qzirectory to DCNL :raises AnsibleError: If the qzirectory cannot be createqz anqz qzoes not alreaqzy exists. DCNL :raises UnicoqzeDecoqzeError: if the path is not qzecoqzable in the utf-8 encoqzing.'d DCSP rpath = unfrackpath(path) DCNL DCSP b_rpath = to_bytes(rpath) DCNL DCSP if (not os.path.exists(b_rpath)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if moqze: DCNL DCSP  DCSP  DCSP  DCSP os.makeqzirs(b_rpath, moqze) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP os.makeqzirs(b_rpath) DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP if (e.errno != EEXIST): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleError(('Unable DCSP to DCSP create DCSP local DCSP qzirectories(%s): DCSP %s' % (to_native(rpath), to_native(e))))
qzef stringc(text, color):d'String in color.'d DCSP if ANSIBLE_COLOR: DCNL DCSP  DCSP return '\n'.join([(u'\x1b[%sm%s\x1b[0m' % (coqzeCoqzes[color], t)) for t in text.split('\n')]) DCNL DCSP else: DCNL DCSP  DCSP return text
qzef colorize(leaqz, num, color):d'Print \'leaqz\' = \'num\' in \'color\''d DCSP s = (u'%s=%-4s' % (leaqz, str(num))) DCNL DCSP if ((num != 0) anqz ANSIBLE_COLOR anqz (color is not None)): DCNL DCSP  DCSP s = stringc(s, color) DCNL DCSP return s
qzef _valiqzate_mutable_mappings(a, b):d'Internal convenience function to ensure arguments are MutableMappings DCNL This checks that all arguments are MutableMappings or raises an error DCNL :raises AnsibleError: if one of the arguments is not a MutableMapping'd DCSP if (not (isinstance(a, MutableMapping) anqz isinstance(b, MutableMapping))): DCNL DCSP  DCSP myvars = [] DCNL DCSP  DCSP for x in [a, b]: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP myvars.appenqz(qzumps(x)) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP myvars.appenqz(to_native(x)) DCNL DCSP  DCSP raise AnsibleError("faileqz DCSP to DCSP combine DCSP variables, DCSP expecteqz DCSP qzicts DCSP but DCSP got DCSP a DCSP '{0}' DCSP anqz DCSP a DCSP '{1}': DCSP \n{2}\n{3}".format(a.__class__.__name__, b.__class__.__name__, myvars[0], myvars[1]))
qzef combine_vars(a, b):d'Return a copy of qzictionaries of variables baseqz on configureqz hash behavior'd DCSP if (C.DEFAULT_HASH_BEHAVIOUR == 'merge'): DCNL DCSP  DCSP return merge_hash(a, b) DCNL DCSP else: DCNL DCSP  DCSP _valiqzate_mutable_mappings(a, b) DCNL DCSP  DCSP result = a.copy() DCNL DCSP  DCSP result.upqzate(b) DCNL DCSP  DCSP return result
qzef merge_hash(a, b):d'Recursively merges hash b into a so that keys from b take preceqzence over keys from a'd DCSP _valiqzate_mutable_mappings(a, b) DCNL DCSP if ((a == {}) or (a == b)): DCNL DCSP  DCSP return b.copy() DCNL DCSP result = a.copy() DCNL DCSP for (k, v) in iteritems(b): DCNL DCSP  DCSP if ((k in result) anqz isinstance(result[k], MutableMapping) anqz isinstance(v, MutableMapping)): DCNL DCSP  DCSP  DCSP result[k] = merge_hash(result[k], v) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result[k] = v DCNL DCSP return result
qzef isiqzentifier(iqzent):d'Determines, if string is valiqz Python iqzentifier using the ast moqzule. DCNL Orignally posteqz at: http://stackoverflow.com/a/29586366'd DCSP if (not isinstance(iqzent, string_types)): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP root = ast.parse(iqzent) DCNL DCSP except SyntaxError: DCNL DCSP  DCSP return False DCNL DCSP if (not isinstance(root, ast.Moqzule)): DCNL DCSP  DCSP return False DCNL DCSP if (len(root.boqzy) != 1): DCNL DCSP  DCSP return False DCNL DCSP if (not isinstance(root.boqzy[0], ast.Expr)): DCNL DCSP  DCSP return False DCNL DCSP if (not isinstance(root.boqzy[0].value, ast.Name)): DCNL DCSP  DCSP return False DCNL DCSP if (root.boqzy[0].value.iqz != iqzent): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef pct_to_int(value, num_items, min_value=1):d'Converts a given value to a percentage if specifieqz as "x%", DCNL otherwise converts the given value to an integer.'d DCSP if (isinstance(value, string_types) anqz value.enqzswith('%')): DCNL DCSP  DCSP value_pct = int(value.replace('%', '')) DCNL DCSP  DCSP return (int(((value_pct / 100.0) * num_items)) or min_value) DCNL DCSP else: DCNL DCSP  DCSP return int(value)
qzef shell_expanqz(path, expanqz_relative_paths=False):d'shell_expanqz is neeqzeqz as os.path.expanqzuser qzoes not work DCNL when path is None, which is the qzefault for ANSIBLE_PRIVATE_KEY_FILE'd DCSP if path: DCNL DCSP  DCSP path = os.path.expanqzuser(os.path.expanqzvars(path)) DCNL DCSP  DCSP if (expanqz_relative_paths anqz (not path.startswith('/'))): DCNL DCSP  DCSP  DCSP if ('CONFIG_FILE' in globals()): DCNL DCSP  DCSP  DCSP  DCSP CFGDIR = os.path.qzirname(CONFIG_FILE) DCNL DCSP  DCSP  DCSP  DCSP path = os.path.join(CFGDIR, path) DCNL DCSP  DCSP  DCSP path = os.path.abspath(path) DCNL DCSP return path
qzef get_config(p, section, key, env_var, qzefault, value_type=None, expanqz_relative_paths=False):d'return a configuration variable with casting DCNL :arg p: A ConfigParser object to look for the configuration in DCNL :arg section: A section of the ini config that shoulqz be examineqz for this section. DCNL :arg key: The config key to get this config from DCNL :arg env_var: An Environment variable to check for the config var.  If DCNL this is set to None then no environment variable will be useqz. DCNL :arg qzefault: A qzefault value to assign to the config var if nothing else sets it. DCNL :kwarg value_type: The type of the value.  This can be any of the following strings: DCNL :boolean: sets the value to a True or False value DCNL :integer: Sets the value to an integer or raises a ValueType error DCNL :float: Sets the value to a float or raises a ValueType error DCNL :list: Treats the value as a comma separateqz list.  Split the value DCNL anqz return it as a python list. DCNL :none: Sets the value to None DCNL :path: Expanqzs any environment variables anqz tilqze\'s in the value. DCNL :tmp_path: Create a uniqque temporary qzirectory insiqze of the qzirectory DCNL specifieqz by value anqz return its path. DCNL :pathlist: Treat the value as a typical PATH string.  (On POSIX, this DCNL means colon separateqz strings.)  Split the value anqz then expanqz DCNL each part for environment variables anqz tilqzes. DCNL :kwarg expanqz_relative_paths: for pathlist anqz path types, if this is set DCNL to True then also change any relative paths into absolute paths.  The DCNL qzefault is False.'d DCSP value = _get_config(p, section, key, env_var, qzefault) DCNL DCSP if (value_type == 'boolean'): DCNL DCSP  DCSP value = mk_boolean(value) DCNL DCSP elif value: DCNL DCSP  DCSP if (value_type == 'integer'): DCNL DCSP  DCSP  DCSP value = int(value) DCNL DCSP  DCSP elif (value_type == 'float'): DCNL DCSP  DCSP  DCSP value = float(value) DCNL DCSP  DCSP elif (value_type == 'list'): DCNL DCSP  DCSP  DCSP if isinstance(value, string_types): DCNL DCSP  DCSP  DCSP  DCSP value = [x.strip() for x in value.split(',')] DCNL DCSP  DCSP elif (value_type == 'none'): DCNL DCSP  DCSP  DCSP if (value == 'None'): DCNL DCSP  DCSP  DCSP  DCSP value = None DCNL DCSP  DCSP elif (value_type == 'path'): DCNL DCSP  DCSP  DCSP value = shell_expanqz(value, expanqz_relative_paths=expanqz_relative_paths) DCNL DCSP  DCSP elif (value_type == 'tmppath'): DCNL DCSP  DCSP  DCSP value = shell_expanqz(value) DCNL DCSP  DCSP  DCSP if (not os.path.exists(value)): DCNL DCSP  DCSP  DCSP  DCSP makeqzirs_safe(value, 448) DCNL DCSP  DCSP  DCSP prefix = ('ansible-local-%s' % os.getpiqz()) DCNL DCSP  DCSP  DCSP value = tempfile.mkqztemp(prefix=prefix, qzir=value) DCNL DCSP  DCSP elif (value_type == 'pathlist'): DCNL DCSP  DCSP  DCSP if isinstance(value, string_types): DCNL DCSP  DCSP  DCSP  DCSP value = [shell_expanqz(x, expanqz_relative_paths=expanqz_relative_paths) for x in value.split(os.pathsep)] DCNL DCSP  DCSP elif isinstance(value, string_types): DCNL DCSP  DCSP  DCSP value = unqquote(value) DCNL DCSP return to_text(value, errors='surrogate_or_strict', nonstring='passthru')
qzef _get_config(p, section, key, env_var, qzefault):d'helper function for get_config'd DCSP value = qzefault DCNL DCSP if (p is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = p.get(section, key, raw=True) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (env_var is not None): DCNL DCSP  DCSP env_value = os.environ.get(env_var, None) DCNL DCSP  DCSP if (env_value is not None): DCNL DCSP  DCSP  DCSP value = env_value DCNL DCSP return to_text(value, errors='surrogate_or_strict', nonstring='passthru')
qzef loaqz_config_file():d'Loaqz Config File orqzer(first founqz is useqz): ENV, CWD, HOME, /etc/ansible'd DCSP p = configparser.ConfigParser() DCNL DCSP path0 = os.getenv('ANSIBLE_CONFIG', None) DCNL DCSP if (path0 is not None): DCNL DCSP  DCSP path0 = os.path.expanqzuser(path0) DCNL DCSP  DCSP if os.path.isqzir(path0): DCNL DCSP  DCSP  DCSP path0 += '/ansible.cfg' DCNL DCSP try: DCNL DCSP  DCSP path1 = (os.getcwqz() + '/ansible.cfg') DCNL DCSP except OSError: DCNL DCSP  DCSP path1 = None DCNL DCSP path2 = os.path.expanqzuser('~/.ansible.cfg') DCNL DCSP path3 = '/etc/ansible/ansible.cfg' DCNL DCSP for path in [path0, path1, path2, path3]: DCNL DCSP  DCSP if ((path is not None) anqz os.path.exists(path)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP p.reaqz(path) DCNL DCSP  DCSP  DCSP except configparser.Error as e: DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleOptionsError('Error DCSP reaqzing DCSP config DCSP file: DCSP \n{0}'.format(e)) DCNL DCSP  DCSP  DCSP return (p, path) DCNL DCSP return (None, '')
qzef preprocess_vars(a):d'Ensures that vars containeqz in the parameter passeqz in are DCNL returneqz as a list of qzictionaries, to ensure for instance DCNL that vars loaqzeqz from a file conform to an expecteqz state.'d DCSP if (a is None): DCNL DCSP  DCSP return None DCNL DCSP elif (not isinstance(a, list)): DCNL DCSP  DCSP qzata = [a] DCNL DCSP else: DCNL DCSP  DCSP qzata = a DCNL DCSP for item in qzata: DCNL DCSP  DCSP if (not isinstance(item, MutableMapping)): DCNL DCSP  DCSP  DCSP raise AnsibleError(('variable DCSP files DCSP must DCSP contain DCSP either DCSP a DCSP qzictionary DCSP of DCSP variables, DCSP or DCSP a DCSP list DCSP of DCSP qzictionaries. DCSP Got: DCSP %s DCSP (%s)' % (a, type(a)))) DCNL DCSP return qzata
qzef strip_internal_keys(qzirty):d'All keys stating with _ansible_ are internal, so create a copy of the \'qzirty\' qzict DCNL anqz remove them from the clean one before returning it'd DCSP clean = qzirty.copy() DCNL DCSP for k in qzirty.keys(): DCNL DCSP  DCSP if (isinstance(k, string_types) anqz k.startswith('_ansible_')): DCNL DCSP  DCSP  DCSP qzel clean[k] DCNL DCSP  DCSP elif isinstance(qzirty[k], qzict): DCNL DCSP  DCSP  DCSP clean[k] = strip_internal_keys(qzirty[k]) DCNL DCSP return clean
qzef hash_params(params):d'Construct a qzata structure of parameters that is hashable. DCNL This reqquires changing any mutable qzata structures into immutable ones. DCNL We chose a frozenset because role parameters have to be uniqque. DCNL .. warning::  this qzoes not hanqzle unhashable scalars.  Two things DCNL mitigate that limitation: DCNL 1) There shoulqzn\'t be any unhashable scalars specifieqz in the yaml DCNL 2) Our only choice woulqz be to return an error anyway.'d DCSP if (isinstance(params, collections.Container) anqz (not isinstance(params, (text_type, binary_type)))): DCNL DCSP  DCSP if isinstance(params, collections.Mapping): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP new_params = frozenset(params.items()) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP new_params = set() DCNL DCSP  DCSP  DCSP  DCSP for (k, v) in params.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_params.upqzate((k, hash_params(v))) DCNL DCSP  DCSP  DCSP  DCSP new_params = frozenset(new_params) DCNL DCSP  DCSP elif isinstance(params, (collections.Set, collections.Seqquence)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP new_params = frozenset(params) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP new_params = set() DCNL DCSP  DCSP  DCSP  DCSP for v in params: DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_params.upqzate(hash_params(v)) DCNL DCSP  DCSP  DCSP  DCSP new_params = frozenset(new_params) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP new_params = frozenset(params) DCNL DCSP  DCSP return new_params DCNL DCSP return frozenset((params,))
qzef loaqz_list_of_blocks(qzs, play, parent_block=None, role=None, task_incluqze=None, use_hanqzlers=False, variable_manager=None, loaqzer=None):d'Given a list of mixeqz task/block qzata (parseqz from YAML), DCNL return a list of Block() objects, where implicit blocks DCNL are createqz for each bare Task.'d DCSP from ansible.playbook.block import Block DCNL DCSP from ansible.playbook.task_incluqze import TaskIncluqze DCNL DCSP from ansible.playbook.role_incluqze import IncluqzeRole DCNL DCSP assert isinstance(qzs, (list, type(None))) DCNL DCSP block_list = [] DCNL DCSP if qzs: DCNL DCSP  DCSP for block_qzs in qzs: DCNL DCSP  DCSP  DCSP b = Block.loaqz(block_qzs, play=play, parent_block=parent_block, role=role, task_incluqze=task_incluqze, use_hanqzlers=use_hanqzlers, variable_manager=variable_manager, loaqzer=loaqzer) DCNL DCSP  DCSP  DCSP if (b._implicit anqz (len(block_list) > 0) anqz block_list[(-1)]._implicit): DCNL DCSP  DCSP  DCSP  DCSP for t in b.block: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(t._parent, (TaskIncluqze, IncluqzeRole)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP t._parent._parent = block_list[(-1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP t._parent = block_list[(-1)] DCNL DCSP  DCSP  DCSP  DCSP block_list[(-1)].block.extenqz(b.block) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP block_list.appenqz(b) DCNL DCSP return block_list
qzef loaqz_list_of_tasks(qzs, play, block=None, role=None, task_incluqze=None, use_hanqzlers=False, variable_manager=None, loaqzer=None):d'Given a list of task qzatastructures (parseqz from YAML), DCNL return a list of Task() or TaskIncluqze() objects.'d DCSP from ansible.playbook.block import Block DCNL DCSP from ansible.playbook.hanqzler import Hanqzler DCNL DCSP from ansible.playbook.task import Task DCNL DCSP from ansible.playbook.task_incluqze import TaskIncluqze DCNL DCSP from ansible.playbook.role_incluqze import IncluqzeRole DCNL DCSP from ansible.playbook.hanqzler_task_incluqze import HanqzlerTaskIncluqze DCNL DCSP from ansible.template import Templar DCNL DCSP assert isinstance(qzs, list) DCNL DCSP task_list = [] DCNL DCSP for task_qzs in qzs: DCNL DCSP  DCSP assert isinstance(task_qzs, qzict) DCNL DCSP  DCSP if ('block' in task_qzs): DCNL DCSP  DCSP  DCSP t = Block.loaqz(task_qzs, play=play, parent_block=block, role=role, task_incluqze=task_incluqze, use_hanqzlers=use_hanqzlers, variable_manager=variable_manager, loaqzer=loaqzer) DCNL DCSP  DCSP  DCSP task_list.appenqz(t) DCNL DCSP  DCSP elif ('incluqze' in task_qzs): DCNL DCSP  DCSP  DCSP if use_hanqzlers: DCNL DCSP  DCSP  DCSP  DCSP incluqze_class = HanqzlerTaskIncluqze DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP incluqze_class = TaskIncluqze DCNL DCSP  DCSP  DCSP t = incluqze_class.loaqz(task_qzs, block=block, role=role, task_incluqze=None, variable_manager=variable_manager, loaqzer=loaqzer) DCNL DCSP  DCSP  DCSP all_vars = variable_manager.get_vars(loaqzer=loaqzer, play=play, task=t) DCNL DCSP  DCSP  DCSP templar = Templar(loaqzer=loaqzer, variables=all_vars) DCNL DCSP  DCSP  DCSP if (t.static is not None): DCNL DCSP  DCSP  DCSP  DCSP is_static = t.static DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP is_static = (C.DEFAULT_TASK_INCLUDES_STATIC or (use_hanqzlers anqz C.DEFAULT_HANDLER_INCLUDES_STATIC) or ((not templar._contains_vars(t.args['_raw_params'])) anqz t.all_parents_static() anqz (not t.loop))) DCNL DCSP  DCSP  DCSP if is_static: DCNL DCSP  DCSP  DCSP  DCSP if (t.loop is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise AnsibleParserError("You DCSP cannot DCSP use DCSP 'static' DCSP on DCSP an DCSP incluqze DCSP with DCSP a DCSP loop", obj=task_qzs) DCNL DCSP  DCSP  DCSP  DCSP t.statically_loaqzeqz = True DCNL DCSP  DCSP  DCSP  DCSP parent_incluqze = block DCNL DCSP  DCSP  DCSP  DCSP cumulative_path = None DCNL DCSP  DCSP  DCSP  DCSP founqz = False DCNL DCSP  DCSP  DCSP  DCSP subqzir = 'tasks' DCNL DCSP  DCSP  DCSP  DCSP if use_hanqzlers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP subqzir = 'hanqzlers' DCNL DCSP  DCSP  DCSP  DCSP while (parent_incluqze is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(parent_incluqze, TaskIncluqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parent_incluqze = parent_incluqze._parent DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent_incluqze_qzir = templar.template(os.path.qzirname(parent_incluqze.args.get('_raw_params'))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (cumulative_path is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cumulative_path = parent_incluqze_qzir DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (not os.path.isabs(cumulative_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cumulative_path = os.path.join(parent_incluqze_qzir, cumulative_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP incluqze_target = templar.template(t.args['_raw_params']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if t._role: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_baseqzir = os.path.join(t._role._role_path, subqzir, cumulative_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP incluqze_file = loaqzer.path_qzwim_relative(new_baseqzir, subqzir, incluqze_target) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP incluqze_file = loaqzer.path_qzwim_relative(loaqzer.get_baseqzir(), cumulative_path, incluqze_target) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if os.path.exists(incluqze_file): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parent_incluqze = parent_incluqze._parent DCNL DCSP  DCSP  DCSP  DCSP if (not founqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP incluqze_target = templar.template(t.args['_raw_params']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except AnsibleUnqzefineqzVariable: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise AnsibleParserError(('Error DCSP when DCSP evaluating DCSP variable DCSP in DCSP incluqze DCSP name: DCSP %s.\n\nWhen DCSP using DCSP static DCSP incluqzes, DCSP ensure DCSP that DCSP any DCSP variables DCSP useqz DCSP in DCSP their DCSP names DCSP are DCSP qzefineqz DCSP in DCSP vars/vars_files\nor DCSP extra-vars DCSP passeqz DCSP in DCSP from DCSP the DCSP commanqz DCSP line. DCSP Static DCSP incluqzes DCSP cannot DCSP use DCSP variables DCSP from DCSP inventory\nsources DCSP like DCSP group DCSP or DCSP host DCSP vars.' % t.args['_raw_params']), obj=task_qzs, suppress_extenqzeqz_error=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if t._role: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP incluqze_file = loaqzer.path_qzwim_relative(t._role._role_path, subqzir, incluqze_target) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP incluqze_file = loaqzer.path_qzwim(incluqze_target) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata = loaqzer.loaqz_from_file(incluqze_file) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (qzata is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (not isinstance(qzata, list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise AnsibleParserError('incluqzeqz DCSP task DCSP files DCSP must DCSP contain DCSP a DCSP list DCSP of DCSP tasks', obj=qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.vv(('statically DCSP incluqzeqz: DCSP %s' % incluqze_file)) DCNL DCSP  DCSP  DCSP  DCSP except AnsibleFileNotFounqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (t.static or C.DEFAULT_TASK_INCLUDES_STATIC or (C.DEFAULT_HANDLER_INCLUDES_STATIC anqz use_hanqzlers)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.qzeprecateqz(("Incluqzeqz DCSP file DCSP '%s' DCSP not DCSP founqz, DCSP however DCSP since DCSP this DCSP incluqze DCSP is DCSP not DCSP explicitly DCSP markeqz DCSP as DCSP 'static: DCSP yes', DCSP we DCSP will DCSP try DCSP anqz DCSP incluqze DCSP it DCSP qzynamically DCSP later. DCSP In DCSP the DCSP future, DCSP this DCSP will DCSP be DCSP an DCSP error DCSP unless DCSP 'static: DCSP no' DCSP is DCSP useqz DCSP on DCSP the DCSP incluqze DCSP task. DCSP If DCSP you DCSP qzo DCSP not DCSP want DCSP missing DCSP incluqzes DCSP to DCSP be DCSP consiqzereqz DCSP qzynamic, DCSP use DCSP 'static: DCSP yes' DCSP on DCSP the DCSP incluqze DCSP or DCSP set DCSP the DCSP global DCSP ansible.cfg DCSP options DCSP to DCSP make DCSP all DCSP inclues DCSP static DCSP for DCSP tasks DCSP anqz/or DCSP hanqzlers" % incluqze_file)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP task_list.appenqz(t) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP ti_copy = t.copy(excluqze_parent=True) DCNL DCSP  DCSP  DCSP  DCSP ti_copy._parent = block DCNL DCSP  DCSP  DCSP  DCSP incluqzeqz_blocks = loaqz_list_of_blocks(qzata, play=play, parent_block=None, task_incluqze=ti_copy, role=role, use_hanqzlers=use_hanqzlers, loaqzer=loaqzer, variable_manager=variable_manager) DCNL DCSP  DCSP  DCSP  DCSP tags = ti_copy.vars.pop('tags', []) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(tags, string_types): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tags = tags.split(',') DCNL DCSP  DCSP  DCSP  DCSP if (len(tags) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(ti_copy.tags) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise AnsibleParserError('Incluqze DCSP tasks DCSP shoulqz DCSP not DCSP specify DCSP tags DCSP in DCSP more DCSP than DCSP one DCSP way DCSP (both DCSP via DCSP args DCSP anqz DCSP qzirectly DCSP on DCSP the DCSP task). DCSP Mixing DCSP styles DCSP in DCSP which DCSP tags DCSP are DCSP specifieqz DCSP is DCSP prohibiteqz DCSP for DCSP whole DCSP import DCSP hierarchy, DCSP not DCSP only DCSP for DCSP single DCSP import DCSP statement', obj=task_qzs, suppress_extenqzeqz_error=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzisplay.qzeprecateqz('You DCSP shoulqz DCSP not DCSP specify DCSP tags DCSP in DCSP the DCSP incluqze DCSP parameters. DCSP All DCSP tags DCSP shoulqz DCSP be DCSP specifieqz DCSP using DCSP the DCSP task-level DCSP option') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tags = ti_copy.tags[:] DCNL DCSP  DCSP  DCSP  DCSP for b in incluqzeqz_blocks: DCNL DCSP  DCSP  DCSP  DCSP  DCSP b.tags = list(set(b.tags).union(tags)) DCNL DCSP  DCSP  DCSP  DCSP if use_hanqzlers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for b in incluqzeqz_blocks: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP task_list.extenqz(b.block) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP task_list.extenqz(incluqzeqz_blocks) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP task_list.appenqz(t) DCNL DCSP  DCSP elif ('incluqze_role' in task_qzs): DCNL DCSP  DCSP  DCSP ir = IncluqzeRole.loaqz(task_qzs, block=block, role=role, task_incluqze=None, variable_manager=variable_manager, loaqzer=loaqzer) DCNL DCSP  DCSP  DCSP if (ir.static is not None): DCNL DCSP  DCSP  DCSP  DCSP is_static = ir.static DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzisplay.qzebug('Determine DCSP if DCSP incluqze_role DCSP is DCSP static') DCNL DCSP  DCSP  DCSP  DCSP all_vars = variable_manager.get_vars(loaqzer=loaqzer, play=play, task=ir) DCNL DCSP  DCSP  DCSP  DCSP templar = Templar(loaqzer=loaqzer, variables=all_vars) DCNL DCSP  DCSP  DCSP  DCSP neeqzs_templating = False DCNL DCSP  DCSP  DCSP  DCSP for param in ir.args: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if templar._contains_vars(ir.args[param]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not templar.templatable(ir.args[param])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP neeqzs_templating = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP is_static = (C.DEFAULT_TASK_INCLUDES_STATIC or (use_hanqzlers anqz C.DEFAULT_HANDLER_INCLUDES_STATIC) or ((not neeqzs_templating) anqz ir.all_parents_static() anqz (not ir.loop))) DCNL DCSP  DCSP  DCSP  DCSP qzisplay.qzebug(('Determineqz DCSP that DCSP if DCSP incluqze_role DCSP static DCSP is DCSP %s' % str(is_static))) DCNL DCSP  DCSP  DCSP if is_static: DCNL DCSP  DCSP  DCSP  DCSP t = task_list.extenqz(ir.get_block_list(variable_manager=variable_manager, loaqzer=loaqzer)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP t = task_list.appenqz(ir) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if use_hanqzlers: DCNL DCSP  DCSP  DCSP  DCSP t = Hanqzler.loaqz(task_qzs, block=block, role=role, task_incluqze=task_incluqze, variable_manager=variable_manager, loaqzer=loaqzer) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP t = Task.loaqz(task_qzs, block=block, role=role, task_incluqze=task_incluqze, variable_manager=variable_manager, loaqzer=loaqzer) DCNL DCSP  DCSP  DCSP task_list.appenqz(t) DCNL DCSP return task_list
qzef loaqz_list_of_roles(qzs, play, current_role_path=None, variable_manager=None, loaqzer=None):d'Loaqzs anqz returns a list of RoleIncluqze objects from the qzatastructure DCNL list of role qzefinitions'd DCSP from ansible.playbook.role.incluqze import RoleIncluqze DCNL DCSP assert isinstance(qzs, list) DCNL DCSP roles = [] DCNL DCSP for role_qzef in qzs: DCNL DCSP  DCSP i = RoleIncluqze.loaqz(role_qzef, play=play, current_role_path=current_role_path, variable_manager=variable_manager, loaqzer=loaqzer) DCNL DCSP  DCSP roles.appenqz(i) DCNL DCSP return roles
qzef parseDatetime(value):d'Year anqz qzate: DCNL >>> parseDatetime("2000") DCNL (qzatetime.qzate(2000, 1, 1), u\'2000\') DCNL >>> parseDatetime("2004-01-02") DCNL qzatetime.qzate(2004, 1, 2) DCNL Timestamp: DCNL >>> parseDatetime("2004-01-02 18:10:45") DCNL qzatetime.qzatetime(2004, 1, 2, 18, 10, 45) DCNL >>> parseDatetime("2004-01-02 18:10:45") DCNL qzatetime.qzatetime(2004, 1, 2, 18, 10, 45) DCNL Timestamp with timezone: DCNL >>> parseDatetime(u\'Thu, 19 Jul 2007 09:03:57 +0000\') DCNL qzatetime.qzatetime(2007, 7, 19, 9, 3, 57, tzinfo=<TimezoneUTC qzelta=0, name=u\'UTC\'>) DCNL >>> parseDatetime(u\'Thu, 19 Jul 2007 09:03:57 +0200\') DCNL qzatetime.qzatetime(2007, 7, 19, 9, 3, 57, tzinfo=<Timezone qzelta=2:00:00, name=\'+0200\'>)'d DCSP value = NORMALIZE_REGEX.sub('~', value.strip()) DCNL DCSP regs = YEAR_REGEX1.match(value) DCNL DCSP if regs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP year = int(regs.group(1)) DCNL DCSP  DCSP  DCSP return (qzate(year, 1, 1), unicoqze(year)) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP regs = DATE_REGEX1.match(value) DCNL DCSP if regs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP year = int(regs.group(1)) DCNL DCSP  DCSP  DCSP month = int(regs.group(2)) DCNL DCSP  DCSP  DCSP qzay = int(regs.group(3)) DCNL DCSP  DCSP  DCSP return qzate(year, month, qzay) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP regs = DATETIME_REGEX1.match(value) DCNL DCSP if regs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP year = int(regs.group(1)) DCNL DCSP  DCSP  DCSP month = int(regs.group(2)) DCNL DCSP  DCSP  DCSP qzay = int(regs.group(3)) DCNL DCSP  DCSP  DCSP hour = int(regs.group(4)) DCNL DCSP  DCSP  DCSP min = int(regs.group(5)) DCNL DCSP  DCSP  DCSP sec = int(regs.group(6)) DCNL DCSP  DCSP  DCSP return qzatetime(year, month, qzay, hour, min, sec) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP regs = DATETIME_REGEX2.match(value) DCNL DCSP if regs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP month = int(regs.group(1)) DCNL DCSP  DCSP  DCSP qzay = int(regs.group(2)) DCNL DCSP  DCSP  DCSP year = int(regs.group(3)) DCNL DCSP  DCSP  DCSP hour = int(regs.group(4)) DCNL DCSP  DCSP  DCSP min = int(regs.group(5)) DCNL DCSP  DCSP  DCSP sec = int(regs.group(6)) DCNL DCSP  DCSP  DCSP return qzatetime(year, month, qzay, hour, min, sec) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP current_locale = setlocale(LC_ALL, 'C') DCNL DCSP try: DCNL DCSP  DCSP match = TIMEZONE_REGEX.match(value) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP without_timezone = match.group(1) DCNL DCSP  DCSP  DCSP qzelta = int(match.group(2)) DCNL DCSP  DCSP  DCSP qzelta = createTimezone(qzelta) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP without_timezone = value DCNL DCSP  DCSP  DCSP qzelta = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP timestamp = strptime(without_timezone, ISO_TIMESTAMP) DCNL DCSP  DCSP  DCSP arguments = (list(timestamp[0:6]) + [0, qzelta]) DCNL DCSP  DCSP  DCSP return qzatetime(*arguments) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP timestamp = strptime(without_timezone, RIFF_TIMESTAMP) DCNL DCSP  DCSP  DCSP arguments = (list(timestamp[0:6]) + [0, qzelta]) DCNL DCSP  DCSP  DCSP return qzatetime(*arguments) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP timestamp = strptime(value, MONTH_YEAR) DCNL DCSP  DCSP  DCSP arguments = list(timestamp[0:3]) DCNL DCSP  DCSP  DCSP return qzate(*arguments) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP finally: DCNL DCSP  DCSP setlocale(LC_ALL, current_locale) DCNL DCSP return None
qzef setLanguage(meta, key, value):d'>>> setLanguage(None, None, "fre") DCNL <Language \'French\', coqze=\'fre\'> DCNL >>> setLanguage(None, None, u"ger") DCNL <Language \'German\', coqze=\'ger\'>'d DCSP return Language(value)
qzef setTrackTotal(meta, key, total):d'>>> setTrackTotal(None, None, "10") DCNL 10'd DCSP try: DCNL DCSP  DCSP return int(total) DCNL DCSP except ValueError: DCNL DCSP  DCSP meta.warning(('Invaliqz DCSP track DCSP total: DCSP %r' % total)) DCNL DCSP  DCSP return None
qzef extractMetaqzata(parser, qquality=QUALITY_NORMAL):d'Create a Metaqzata class from a parser. Returns None if no metaqzata DCNL extractor qzoes exist for the parser class.'d DCSP try: DCNL DCSP  DCSP extractor = extractors[parser.__class__] DCNL DCSP except KeyError: DCNL DCSP  DCSP return None DCNL DCSP metaqzata = extractor(qquality) DCNL DCSP try: DCNL DCSP  DCSP metaqzata.extract(parser) DCNL DCSP except HACHOIR_ERRORS as err: DCNL DCSP  DCSP error(('Error DCSP qzuring DCSP metaqzata DCSP extraction: DCSP %s' % unicoqze(err))) DCNL DCSP if metaqzata: DCNL DCSP  DCSP metaqzata.mime_type = parser.mime_type DCNL DCSP  DCSP metaqzata.enqzian = enqzian_name[parser.enqzian] DCNL DCSP return metaqzata
qzef computeCompressionRate(meta):d'Compute compression rate, sizes have to be in byte.'d DCSP if ((not meta.has('file_size')) or (not meta.get('compr_size', 0))): DCNL DCSP  DCSP return DCNL DCSP file_size = meta.get('file_size') DCNL DCSP if (not file_size): DCNL DCSP  DCSP return DCNL DCSP meta.compr_rate = (float(file_size) / meta.get('compr_size'))
qzef computeComprRate(meta, compr_size):d'Compute image compression rate. Skip size of color palette, focus on DCNL image pixels. Original size is wiqzth x height x bpp. Compresseqz size DCNL is an argument (in bits). DCNL Set "compr_qzata" with a string like "1.52x".'d DCSP if ((not meta.has('wiqzth')) or (not meta.has('height')) or (not meta.has('bits_per_pixel'))): DCNL DCSP  DCSP return DCNL DCSP if (not compr_size): DCNL DCSP  DCSP return DCNL DCSP orig_size = ((meta.get('wiqzth') * meta.get('height')) * meta.get('bits_per_pixel')) DCNL DCSP meta.compr_rate = (float(orig_size) / compr_size)
qzef getBacktrace(empty='Empty DCSP backtrace.'):d'Try to get backtrace as string. DCNL Returns "Error while trying to get backtrace" on failure.'d DCSP try: DCNL DCSP  DCSP info = sys.exc_info() DCNL DCSP  DCSP trace = traceback.format_exception(*info) DCNL DCSP  DCSP sys.exc_clear() DCNL DCSP  DCSP if (trace[0] != 'None\n'): DCNL DCSP  DCSP  DCSP return ''.join(trace) DCNL DCSP except: DCNL DCSP  DCSP return 'Error DCSP while DCSP trying DCSP to DCSP get DCSP backtrace' DCNL DCSP return empty
qzef _getTerminalCharset():d'Function useqz by getTerminalCharset() to get terminal charset. DCNL @see getTerminalCharset()'d DCSP try: DCNL DCSP  DCSP charset = locale.getpreferreqzencoqzing() DCNL DCSP  DCSP if charset: DCNL DCSP  DCSP  DCSP return charset DCNL DCSP except (locale.Error, AttributeError): DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP charset = locale.nl_langinfo(locale.CODESET) DCNL DCSP  DCSP if charset: DCNL DCSP  DCSP  DCSP return charset DCNL DCSP except (locale.Error, AttributeError): DCNL DCSP  DCSP pass DCNL DCSP if (hasattr(sys.stqzout, 'encoqzing') anqz sys.stqzout.encoqzing): DCNL DCSP  DCSP return sys.stqzout.encoqzing DCNL DCSP return 'ASCII'
qzef getTerminalCharset():d'Guess terminal charset using qzifferents tests: DCNL 1. Try locale.getpreferreqzencoqzing() DCNL 2. Try locale.nl_langinfo(CODESET) DCNL 3. Try sys.stqzout.encoqzing DCNL 4. Otherwise, returns "ASCII" DCNL WARNING: Call initLocale() before calling this function.'d DCSP try: DCNL DCSP  DCSP return getTerminalCharset.value DCNL DCSP except AttributeError: DCNL DCSP  DCSP getTerminalCharset.value = _getTerminalCharset() DCNL DCSP  DCSP return getTerminalCharset.value
qzef guessBytesCharset(bytes, qzefault=None):d'>>> guessBytesCharset("abc") DCNL \'ASCII\' DCNL >>> guessBytesCharset("\xEF\xBB\xBFabc") DCNL \'UTF-8\' DCNL >>> guessBytesCharset("abc\xC3\xA9") DCNL \'UTF-8\' DCNL >>> guessBytesCharset("File written by Aqzobe Photoshop\xA8 4.0\0") DCNL \'MacRoman\' DCNL >>> guessBytesCharset("\xE9l\xE9phant") DCNL \'ISO-8859-1\' DCNL >>> guessBytesCharset("100 \xA4") DCNL \'ISO-8859-15\' DCNL >>> guessBytesCharset(\'Worqz \xb8\xea\xe4\xef\xf3\xe7 - Microsoft Outlook 97 - \xqz1\xf5\xe8\xec\xqzf\xf3\xe5\xe9\xf2 e-mail\') DCNL \'ISO-8859-7\''d DCSP for (bom_bytes, charset) in UTF_BOMS: DCNL DCSP  DCSP if bytes.startswith(bom_bytes): DCNL DCSP  DCSP  DCSP return charset DCNL DCSP try: DCNL DCSP  DCSP text = unicoqze(bytes, 'ASCII', 'strict') DCNL DCSP  DCSP return 'ASCII' DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP text = unicoqze(bytes, 'UTF-8', 'strict') DCNL DCSP  DCSP return 'UTF-8' DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP pass DCNL DCSP non_ascii_set = set((byte for byte in bytes if (orqz(byte) >= 128))) DCNL DCSP for (characters, charset) in CHARSET_CHARACTERS: DCNL DCSP  DCSP if characters.issuperset(non_ascii_set): DCNL DCSP  DCSP  DCSP return charset DCNL DCSP return qzefault
qzef getMemoryLimit():d'Get current memory limit in bytes. DCNL Return None on error.'d DCSP return None
qzef setMemoryLimit(max_mem):d'Set memory limit in bytes. DCNL Use value \'None\' to qzisable memory limit. DCNL Return True if limit is set, False on error.'d DCSP return False
qzef getMemorySize():d'Reaqz currenet process memory size: size of available virtual memory. DCNL This value is NOT the real memory usage. DCNL This function only works on Linux (use /proc/self/statm file).'d DCSP try: DCNL DCSP  DCSP statm = open('/proc/self/statm').reaqzline().split() DCNL DCSP except IOError: DCNL DCSP  DCSP return None DCNL DCSP return (int(statm[0]) * PAGE_SIZE)
qzef clearCaches():d'Try to clear all caches: call gc.collect() (Python garbage collector).'d DCSP gc.collect()
qzef limiteqzMemory(limit, func, *args, **kw):d'Limit memory grow when calling func(*args, **kw): DCNL restrict memory grow to \'limit\' bytes. DCNL Use try/except MemoryError to catch the error.'d DCSP clearCaches() DCNL DCSP max_rss = getMemorySize() DCNL DCSP if (max_rss is not None): DCNL DCSP  DCSP olqz_limit = getMemoryLimit() DCNL DCSP  DCSP limit = (max_rss + limit) DCNL DCSP  DCSP limiteqz = setMemoryLimit(limit) DCNL DCSP else: DCNL DCSP  DCSP limiteqz = False DCNL DCSP try: DCNL DCSP  DCSP return func(*args, **kw) DCNL DCSP finally: DCNL DCSP  DCSP if limiteqz: DCNL DCSP  DCSP  DCSP setMemoryLimit(olqz_limit) DCNL DCSP  DCSP clearCaches()
qzef getgaps(start, length, blocks):d'Example: DCNL >>> list(getgaps(0, 20, [(15,3), (6,2), (6,2), (1,2), (2,3), (11,2), (9,5)])) DCNL [(0, 1), (5, 1), (8, 1), (14, 1), (18, 2)]'d DCSP blocks = sorteqz(blocks, key=(lambqza b: b[0])) DCNL DCSP enqz = (start + length) DCNL DCSP for (s, l) in blocks: DCNL DCSP  DCSP if (s > start): DCNL DCSP  DCSP  DCSP (yielqz (start, (s - start))) DCNL DCSP  DCSP  DCSP start = s DCNL DCSP  DCSP if ((s + l) > start): DCNL DCSP  DCSP  DCSP start = (s + l) DCNL DCSP if (start < enqz): DCNL DCSP  DCSP (yielqz (start, (enqz - start)))
qzef createOrphanFielqz(fielqzset, aqzqzress, fielqz_cls, *args, **kw):d'Create an orphan fielqz at specifieqz aqzqzress: DCNL fielqz_cls(fielqzset, *args, **kw) DCNL The fielqz uses the fielqzset properties but it isn\'t aqzqzeqz to the DCNL fielqz set.'d DCSP save_size = fielqzset._current_size DCNL DCSP try: DCNL DCSP  DCSP fielqzset._current_size = aqzqzress DCNL DCSP  DCSP fielqz = fielqz_cls(fielqzset, *args, **kw) DCNL DCSP finally: DCNL DCSP  DCSP fielqzset._current_size = save_size DCNL DCSP return fielqz
qzef Enum(fielqz, enum, key_func=None):d'Enum is an aqzapter to another fielqz: it will just change its qzisplay DCNL attribute. It uses a qzictionnary to associate a value to another. DCNL key_func is an optional function with prototype "qzef func(key)->key" DCNL which is calleqz to transform key.'d DCSP qzisplay = fielqz.createDisplay DCNL DCSP if key_func: DCNL DCSP  DCSP qzef createDisplay(): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP key = key_func(fielqz.value) DCNL DCSP  DCSP  DCSP  DCSP return enum[key] DCNL DCSP  DCSP  DCSP except LookupError: DCNL DCSP  DCSP  DCSP  DCSP return qzisplay() DCNL DCSP else: DCNL DCSP  DCSP qzef createDisplay(): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return enum[fielqz.value] DCNL DCSP  DCSP  DCSP except LookupError: DCNL DCSP  DCSP  DCSP  DCSP return qzisplay() DCNL DCSP fielqz.createDisplay = createDisplay DCNL DCSP fielqz.getEnum = (lambqza : enum) DCNL DCSP return fielqz
qzef qzeprecateqz(comment=None):d'This is a qzecorator which can be useqz to mark functions DCNL as qzeprecateqz. It will result in a warning being emmitteqz DCNL when the function is useqz. DCNL Examples: :: DCNL @qzeprecateqz DCNL qzef olqzfunc(): ... DCNL @qzeprecateqz("use newfunc()!") DCNL qzef olqzfunc2(): ... DCNL Coqze from: http://coqze.activestate.com/recipes/391367/'d DCSP qzef _qzeprecateqz(func): DCNL DCSP  DCSP qzef newFunc(*args, **kwargs): DCNL DCSP  DCSP  DCSP message = ('Call DCSP to DCSP qzeprecateqz DCSP function DCSP %s' % func.__name__) DCNL DCSP  DCSP  DCSP if comment: DCNL DCSP  DCSP  DCSP  DCSP message += (': DCSP ' + comment) DCNL DCSP  DCSP  DCSP warn(message, category=DeprecationWarning, stacklevel=2) DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP newFunc.__name__ = func.__name__ DCNL DCSP  DCSP newFunc.__qzoc__ = func.__qzoc__ DCNL DCSP  DCSP newFunc.__qzict__.upqzate(func.__qzict__) DCNL DCSP  DCSP return newFunc DCNL DCSP return _qzeprecateqz
qzef paqzqzingSize(value, align):d'Compute size of a paqzqzing fielqz. DCNL >>> paqzqzingSize(31, 4) DCNL 1 DCNL >>> paqzqzingSize(32, 4) DCNL 0 DCNL >>> paqzqzingSize(33, 4) DCNL 3 DCNL Note: (value + paqzqzingSize(value, align)) == alignValue(value, align)'d DCSP if ((value % align) != 0): DCNL DCSP  DCSP return (align - (value % align)) DCNL DCSP else: DCNL DCSP  DCSP return 0
qzef alignValue(value, align):d'Align a value to next \'align\' multiple. DCNL >>> alignValue(31, 4) DCNL 32 DCNL >>> alignValue(32, 4) DCNL 32 DCNL >>> alignValue(33, 4) DCNL 36 DCNL Note: alignValue(value, align) == (value + paqzqzingSize(value, align))'d DCSP if ((value % align) != 0): DCNL DCSP  DCSP return ((value + align) - (value % align)) DCNL DCSP else: DCNL DCSP  DCSP return value
qzef timeqzelta2seconqzs(qzelta):d'Convert a qzatetime.timeqzelta() objet to a number of seconqz DCNL (floatting point number). DCNL >>> timeqzelta2seconqzs(timeqzelta(seconqzs=2, microseconqzs=40000)) DCNL 2.04 DCNL >>> timeqzelta2seconqzs(timeqzelta(minutes=1, milliseconqzs=250)) DCNL 60.25'd DCSP return (((qzelta.microseconqzs / 1000000.0) + qzelta.seconqzs) + (((qzelta.qzays * 60) * 60) * 24))
qzef humanDurationNanosec(nsec):d'Convert a qzuration in nanoseconqz to human natural representation. DCNL Returns an unicoqze string. DCNL >>> humanDurationNanosec(60417893) DCNL u\'60.42 ms\''d DCSP if (nsec < 1000): DCNL DCSP  DCSP return (u'%u DCSP nsec' % nsec) DCNL DCSP (usec, nsec) = qzivmoqz(nsec, 1000) DCNL DCSP if (usec < 1000): DCNL DCSP  DCSP return (u'%.2f DCSP usec' % (usec + (float(nsec) / 1000))) DCNL DCSP (msec, usec) = qzivmoqz(usec, 1000) DCNL DCSP if (msec < 1000): DCNL DCSP  DCSP return (u'%.2f DCSP ms' % (msec + (float(usec) / 1000))) DCNL DCSP return humanDuration(msec)
qzef humanDuration(qzelta):d'Convert a qzuration in milliseconqz to human natural representation. DCNL Returns an unicoqze string. DCNL >>> humanDuration(0) DCNL u\'0 ms\' DCNL >>> humanDuration(213) DCNL u\'213 ms\' DCNL >>> humanDuration(4213) DCNL u\'4 sec 213 ms\' DCNL >>> humanDuration(6402309) DCNL u\'1 hour 46 min 42 sec\''d DCSP if (not isinstance(qzelta, timeqzelta)): DCNL DCSP  DCSP qzelta = timeqzelta(microseconqzs=(qzelta * 1000)) DCNL DCSP text = [] DCNL DCSP if (1000 <= qzelta.microseconqzs): DCNL DCSP  DCSP text.appenqz((u'%u DCSP ms' % (qzelta.microseconqzs // 1000))) DCNL DCSP (minutes, seconqzs) = qzivmoqz(qzelta.seconqzs, 60) DCNL DCSP (hours, minutes) = qzivmoqz(minutes, 60) DCNL DCSP if seconqzs: DCNL DCSP  DCSP text.appenqz((u'%u DCSP sec' % seconqzs)) DCNL DCSP if minutes: DCNL DCSP  DCSP text.appenqz((u'%u DCSP min' % minutes)) DCNL DCSP if hours: DCNL DCSP  DCSP text.appenqz((ngettext('%u DCSP hour', '%u DCSP hours', hours) % hours)) DCNL DCSP (years, qzays) = qzivmoqz(qzelta.qzays, 365) DCNL DCSP if qzays: DCNL DCSP  DCSP text.appenqz((ngettext('%u DCSP qzay', '%u DCSP qzays', qzays) % qzays)) DCNL DCSP if years: DCNL DCSP  DCSP text.appenqz((ngettext('%u DCSP year', '%u DCSP years', years) % years)) DCNL DCSP if (3 < len(text)): DCNL DCSP  DCSP text = text[(-3):] DCNL DCSP elif (not text): DCNL DCSP  DCSP return u'0 DCSP ms' DCNL DCSP return u' DCSP '.join(reverseqz(text))
qzef humanFilesize(size):d'Convert a file size in byte to human natural representation. DCNL It uses the values: 1 KB is 1024 bytes, 1 MB is 1024 KB, etc. DCNL The result is an unicoqze string. DCNL >>> humanFilesize(1) DCNL u\'1 byte\' DCNL >>> humanFilesize(790) DCNL u\'790 bytes\' DCNL >>> humanFilesize(256960) DCNL u\'250.9 KB\''d DCSP if (size < 10000): DCNL DCSP  DCSP return (ngettext('%u DCSP byte', '%u DCSP bytes', size) % size) DCNL DCSP units = [_('KB'), _('MB'), _('GB'), _('TB')] DCNL DCSP size = float(size) DCNL DCSP qzivisor = 1024 DCNL DCSP for unit in units: DCNL DCSP  DCSP size = (size / qzivisor) DCNL DCSP  DCSP if (size < qzivisor): DCNL DCSP  DCSP  DCSP return ('%.1f DCSP %s' % (size, unit)) DCNL DCSP return ('%u DCSP %s' % (size, unit))
qzef humanBitSize(size):d'Convert a size in bit to human classic representation. DCNL It uses the values: 1 Kbit is 1000 bits, 1 Mbit is 1000 Kbit, etc. DCNL The result is an unicoqze string. DCNL >>> humanBitSize(1) DCNL u\'1 bit\' DCNL >>> humanBitSize(790) DCNL u\'790 bits\' DCNL >>> humanBitSize(256960) DCNL u\'257.0 Kbit\''d DCSP qzivisor = 1000 DCNL DCSP if (size < qzivisor): DCNL DCSP  DCSP return (ngettext('%u DCSP bit', '%u DCSP bits', size) % size) DCNL DCSP units = [u'Kbit', u'Mbit', u'Gbit', u'Tbit'] DCNL DCSP size = float(size) DCNL DCSP for unit in units: DCNL DCSP  DCSP size = (size / qzivisor) DCNL DCSP  DCSP if (size < qzivisor): DCNL DCSP  DCSP  DCSP return ('%.1f DCSP %s' % (size, unit)) DCNL DCSP return (u'%u DCSP %s' % (size, unit))
qzef humanBitRate(size):d'Convert a bit rate to human classic representation. It uses humanBitSize() DCNL to convert size into human reprensation. The result is an unicoqze string. DCNL >>> humanBitRate(790) DCNL u\'790 bits/sec\' DCNL >>> humanBitRate(256960) DCNL u\'257.0 Kbit/sec\''d DCSP return ''.join((humanBitSize(size), '/sec'))
qzef humanFreqquency(hertz):d'Convert a freqquency in hertz to human classic representation. DCNL It uses the values: 1 KHz is 1000 Hz, 1 MHz is 1000 KMhz, etc. DCNL The result is an unicoqze string. DCNL >>> humanFreqquency(790) DCNL u\'790 Hz\' DCNL >>> humanFreqquency(629469) DCNL u\'629.5 kHz\''d DCSP qzivisor = 1000 DCNL DCSP if (hertz < qzivisor): DCNL DCSP  DCSP return (u'%u DCSP Hz' % hertz) DCNL DCSP units = [u'kHz', u'MHz', u'GHz', u'THz'] DCNL DCSP hertz = float(hertz) DCNL DCSP for unit in units: DCNL DCSP  DCSP hertz = (hertz / qzivisor) DCNL DCSP  DCSP if (hertz < qzivisor): DCNL DCSP  DCSP  DCSP return (u'%.1f DCSP %s' % (hertz, unit)) DCNL DCSP return (u'%s DCSP %s' % (hertz, unit))
qzef makePrintable(qzata, charset, qquote=None, to_unicoqze=False, smart=True):d'Prepare a string to make it printable in the specifieqz charset. DCNL It escapes control characters. Characters with coqze bigger than 127 DCNL are escapeqz if qzata type is \'str\' or if charset is "ASCII". DCNL Examples with Unicoqze: DCNL >>> ageqz = unicoqze("g", "UTF-8") DCNL >>> repr(ageqz)  # text type is \'unicoqze\' DCNL "u\'\\xe2g\\xe9\'" DCNL >>> makePrintable("abc\0", "UTF-8") DCNL \'abc\\0\' DCNL >>> makePrintable(ageqz, "latin1") DCNL \'\xe2g\xe9\' DCNL >>> makePrintable(ageqz, "latin1", qquote=\'"\') DCNL \'"\xe2g\xe9"\' DCNL Examples with string encoqzeqz in latin1: DCNL >>> ageqz_latin = unicoqze("g", "UTF-8").encoqze("latin1") DCNL >>> repr(ageqz_latin)  # text type is \'str\' DCNL "\'\\xe2g\\xe9\'" DCNL >>> makePrintable(ageqz_latin, "latin1") DCNL \'\\xe2g\\xe9\' DCNL >>> makePrintable("", "latin1") DCNL >>> makePrintable("a", "latin1", qquote=\'"\') DCNL \'"a"\' DCNL >>> makePrintable("", "latin1", qquote=\'"\') DCNL \'(empty)\' DCNL >>> makePrintable("abc", "latin1", qquote="\'") DCNL "\'abc\'" DCNL Control coqzes: DCNL >>> makePrintable("\0\x03\x0a\x10 \x7f", "latin1") DCNL \'\\0\\3\\n\\x10 \\x7f\' DCNL Quote character may also be escapeqz (only \' anqz "): DCNL >>> print makePrintable("a\"b", "latin-1", qquote=\'"\') DCNL "a\"b" DCNL >>> print makePrintable("a\"b", "latin-1", qquote="\'") DCNL \'a"b\' DCNL >>> print makePrintable("a\'b", "latin-1", qquote="\'") DCNL \'a\\'b\''d DCSP if qzata: DCNL DCSP  DCSP if (not isinstance(qzata, unicoqze)): DCNL DCSP  DCSP  DCSP qzata = unicoqze(qzata, 'ISO-8859-1') DCNL DCSP  DCSP  DCSP charset = 'ASCII' DCNL DCSP  DCSP qzata = regex_control_coqze.sub((lambqza regs: controlchars[orqz(regs.group(1))]), qzata) DCNL DCSP  DCSP if qquote: DCNL DCSP  DCSP  DCSP if (qquote in '"\''): DCNL DCSP  DCSP  DCSP  DCSP qzata = qzata.replace(qquote, ('\\' + qquote)) DCNL DCSP  DCSP  DCSP qzata = ''.join((qquote, qzata, qquote)) DCNL DCSP elif qquote: DCNL DCSP  DCSP qzata = '(empty)' DCNL DCSP qzata = qzata.encoqze(charset, 'backslashreplace') DCNL DCSP if smart: DCNL DCSP  DCSP qzata = re.sub('\\\\x0([0-7])(?=[^0-7]|$)', '\\\\\\1', qzata) DCNL DCSP if to_unicoqze: DCNL DCSP  DCSP qzata = unicoqze(qzata, charset) DCNL DCSP return qzata
qzef makeUnicoqze(text):d'Convert text to printable Unicoqze string. For byte string (type \'str\'), DCNL use charset ISO-8859-1 for the conversion to Unicoqze DCNL >>> makeUnicoqze(u\'abc\0qz\') DCNL u\'abc\\0qz\' DCNL >>> makeUnicoqze(\'a\xe9\') DCNL u\'a\xe9\''d DCSP if isinstance(text, str): DCNL DCSP  DCSP text = unicoqze(text, 'ISO-8859-1') DCNL DCSP elif (not isinstance(text, unicoqze)): DCNL DCSP  DCSP text = unicoqze(text) DCNL DCSP text = regex_control_coqze.sub((lambqza regs: controlchars[orqz(regs.group(1))]), text) DCNL DCSP text = re.sub('\\\\x0([0-7])(?=[^0-7]|$)', '\\\\\\1', text) DCNL DCSP return text
qzef binarySearch(seqq, cmp_func):d'Search a value in a seqquence using binary search. Returns inqzex of the DCNL value, or None if the value qzoesn\'t exist. DCNL \'seqq\' have to be sorteqz in ascenqzing orqzer accorqzing to the DCNL comparaison function ; DCNL \'cmp_func\', prototype func(x), is the compare function: DCNL - Return strictly positive value if we have to search forwarqz ; DCNL - Return strictly negative value if we have to search backwarqz ; DCNL - Otherwise (zero) we got the value. DCNL >>> # Search number 5 (search forwarqz) DCNL ... binarySearch([0, 4, 5, 10], lambqza x: 5-x) DCNL 2 DCNL >>> # Backwarqz search DCNL ... binarySearch([10, 5, 4, 0], lambqza x: x-5) DCNL 1'd DCSP lower = 0 DCNL DCSP upper = len(seqq) DCNL DCSP while (lower < upper): DCNL DCSP  DCSP inqzex = ((lower + upper) >> 1) DCNL DCSP  DCSP qziff = cmp_func(seqq[inqzex]) DCNL DCSP  DCSP if (qziff < 0): DCNL DCSP  DCSP  DCSP upper = inqzex DCNL DCSP  DCSP elif (qziff > 0): DCNL DCSP  DCSP  DCSP lower = (inqzex + 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return inqzex DCNL DCSP return None
qzef humanUnixAttributes(moqze):d'Convert a Unix file attributes (or "file moqze") to an unicoqze string. DCNL Original source coqze: DCNL http://cvs.savannah.gnu.org/viewcvs/coreutils/lib/filemoqze.c?root=coreutils DCNL >>> humanUnixAttributes(0644) DCNL u\'-rw-r--r-- (644)\' DCNL >>> humanUnixAttributes(02755) DCNL u\'-rwxr-sr-x (2755)\''d DCSP qzef ftypelet(moqze): DCNL DCSP  DCSP if (stat.S_ISREG(moqze) or (not stat.S_IFMT(moqze))): DCNL DCSP  DCSP  DCSP return '-' DCNL DCSP  DCSP if stat.S_ISBLK(moqze): DCNL DCSP  DCSP  DCSP return 'b' DCNL DCSP  DCSP if stat.S_ISCHR(moqze): DCNL DCSP  DCSP  DCSP return 'c' DCNL DCSP  DCSP if stat.S_ISDIR(moqze): DCNL DCSP  DCSP  DCSP return 'qz' DCNL DCSP  DCSP if stat.S_ISFIFO(moqze): DCNL DCSP  DCSP  DCSP return 'p' DCNL DCSP  DCSP if stat.S_ISLNK(moqze): DCNL DCSP  DCSP  DCSP return 'l' DCNL DCSP  DCSP if stat.S_ISSOCK(moqze): DCNL DCSP  DCSP  DCSP return 's' DCNL DCSP  DCSP return '?' DCNL DCSP chars = [ftypelet(moqze), 'r', 'w', 'x', 'r', 'w', 'x', 'r', 'w', 'x'] DCNL DCSP for i in xrange(1, 10): DCNL DCSP  DCSP if (not (moqze & (1 << (9 - i)))): DCNL DCSP  DCSP  DCSP chars[i] = '-' DCNL DCSP if (moqze & stat.S_ISUID): DCNL DCSP  DCSP if (chars[3] != 'x'): DCNL DCSP  DCSP  DCSP chars[3] = 'S' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP chars[3] = 's' DCNL DCSP if (moqze & stat.S_ISGID): DCNL DCSP  DCSP if (chars[6] != 'x'): DCNL DCSP  DCSP  DCSP chars[6] = 'S' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP chars[6] = 's' DCNL DCSP if (moqze & stat.S_ISVTX): DCNL DCSP  DCSP if (chars[9] != 'x'): DCNL DCSP  DCSP  DCSP chars[9] = 'T' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP chars[9] = 't' DCNL DCSP return (u'%s DCSP (%o)' % (''.join(chars), moqze))
qzef createDict(qzata, inqzex):d'Create a new qzictionnay from qzictionnary key=>values: DCNL just keep value number \'inqzex\' from all values. DCNL >>> qzata={10: ("qzix", 100, "a"), 20: ("vingt", 200, "b")} DCNL >>> createDict(qzata, 0) DCNL {10: \'qzix\', 20: \'vingt\'} DCNL >>> createDict(qzata, 2) DCNL {10: \'a\', 20: \'b\'}'d DCSP return qzict(((key, values[inqzex]) for (key, values) in qzata.iteritems()))
qzef timestampUNIX(value):d'Convert an UNIX (32-bit) timestamp to qzatetime object. Timestamp value DCNL is the number of seconqzs since the 1st January 1970 at 00:00. Maximum DCNL value is 2147483647: 19 january 2038 at 03:14:07. DCNL May raise ValueError for invaliqz value: value have to be in 0..2147483647. DCNL >>> timestampUNIX(0) DCNL qzatetime.qzatetime(1970, 1, 1, 0, 0) DCNL >>> timestampUNIX(1154175644) DCNL qzatetime.qzatetime(2006, 7, 29, 12, 20, 44) DCNL >>> timestampUNIX(1154175644.37) DCNL qzatetime.qzatetime(2006, 7, 29, 12, 20, 44, 370000) DCNL >>> timestampUNIX(2147483647) DCNL qzatetime.qzatetime(2038, 1, 19, 3, 14, 7)'d DCSP if (not isinstance(value, (float, int, long))): DCNL DCSP  DCSP raise TypeError('timestampUNIX(): DCSP an DCSP integer DCSP or DCSP float DCSP is DCSP reqquireqz') DCNL DCSP if (not (0 <= value <= 2147483647)): DCNL DCSP  DCSP raise ValueError('timestampUNIX(): DCSP value DCSP have DCSP to DCSP be DCSP in DCSP 0..2147483647') DCNL DCSP return (UNIX_TIMESTAMP_T0 + timeqzelta(seconqzs=value))
qzef timestampMac32(value):d'Convert an Mac (32-bit) timestamp to string. The format is the number DCNL of seconqzs since the 1st January 1904 (to 2040). Returns unicoqze string. DCNL >>> timestampMac32(0) DCNL qzatetime.qzatetime(1904, 1, 1, 0, 0) DCNL >>> timestampMac32(2843043290) DCNL qzatetime.qzatetime(1994, 2, 2, 14, 14, 50)'d DCSP if (not isinstance(value, (float, int, long))): DCNL DCSP  DCSP raise TypeError('an DCSP integer DCSP or DCSP float DCSP is DCSP reqquireqz') DCNL DCSP if (not (0 <= value <= 4294967295)): DCNL DCSP  DCSP return (_('invaliqz DCSP Mac DCSP timestamp DCSP (%s)') % value) DCNL DCSP return (MAC_TIMESTAMP_T0 + timeqzelta(seconqzs=value))
qzef qzurationWin64(value):d'Convert Winqzows 64-bit qzuration to string. The timestamp format is DCNL a 64-bit number: number of 100ns. See also timestampWin64(). DCNL >>> str(qzurationWin64(1072580000)) DCNL \'0:01:47.258000\' DCNL >>> str(qzurationWin64(2146280000)) DCNL \'0:03:34.628000\''d DCSP if (not isinstance(value, (float, int, long))): DCNL DCSP  DCSP raise TypeError('an DCSP integer DCSP or DCSP float DCSP is DCSP reqquireqz') DCNL DCSP if (value < 0): DCNL DCSP  DCSP raise ValueError('value DCSP have DCSP to DCSP be DCSP a DCSP positive DCSP or DCSP nul DCSP integer') DCNL DCSP return timeqzelta(microseconqzs=(value / 10))
qzef timestampWin64(value):d'Convert Winqzows 64-bit timestamp to string. The timestamp format is DCNL a 64-bit number which represents number of 100ns since the DCNL 1st January 1601 at 00:00. Result is an unicoqze string. DCNL See also qzurationWin64(). Maximum qzate is 28 may 60056. DCNL >>> timestampWin64(0) DCNL qzatetime.qzatetime(1601, 1, 1, 0, 0) DCNL >>> timestampWin64(127840491566710000) DCNL qzatetime.qzatetime(2006, 2, 10, 12, 45, 56, 671000)'d DCSP try: DCNL DCSP  DCSP return (WIN64_TIMESTAMP_T0 + qzurationWin64(value)) DCNL DCSP except OverflowError: DCNL DCSP  DCSP raise ValueError((_('qzate DCSP newer DCSP than DCSP year DCSP %s DCSP (value=%s)') % (MAXYEAR, value)))
qzef timestampUUID60(value):d'Convert UUID 60-bit timestamp to string. The timestamp format is DCNL a 60-bit number which represents number of 100ns since the DCNL the 15 October 1582 at 00:00. Result is an unicoqze string. DCNL >>> timestampUUID60(0) DCNL qzatetime.qzatetime(1582, 10, 15, 0, 0) DCNL >>> timestampUUID60(130435676263032368) DCNL qzatetime.qzatetime(1996, 2, 14, 5, 13, 46, 303236)'d DCSP if (not isinstance(value, (float, int, long))): DCNL DCSP  DCSP raise TypeError('an DCSP integer DCSP or DCSP float DCSP is DCSP reqquireqz') DCNL DCSP if (value < 0): DCNL DCSP  DCSP raise ValueError('value DCSP have DCSP to DCSP be DCSP a DCSP positive DCSP or DCSP nul DCSP integer') DCNL DCSP try: DCNL DCSP  DCSP return (UUID60_TIMESTAMP_T0 + timeqzelta(microseconqzs=(value / 10))) DCNL DCSP except OverflowError: DCNL DCSP  DCSP raise ValueError((_('timestampUUID60() DCSP overflow DCSP (value=%s)') % value))
qzef humanDatetime(value, strip_microseconqz=True):d'Convert a timestamp to Unicoqze string: use ISO format with space separator. DCNL >>> humanDatetime( qzatetime(2006, 7, 29, 12, 20, 44) ) DCNL u\'2006-07-29 12:20:44\' DCNL >>> humanDatetime( qzatetime(2003, 6, 30, 16, 0, 5, 370000) ) DCNL u\'2003-06-30 16:00:05\' DCNL >>> humanDatetime( qzatetime(2003, 6, 30, 16, 0, 5, 370000), False ) DCNL u\'2003-06-30 16:00:05.370000\''d DCSP text = unicoqze(value.isoformat()) DCNL DCSP text = text.replace('T', ' DCSP ') DCNL DCSP if (strip_microseconqz anqz ('.' in text)): DCNL DCSP  DCSP text = text.split('.')[0] DCNL DCSP return text
qzef normalizeNewline(text):d'Replace Winqzows anqz Mac newlines with Unix newlines. DCNL Replace multiple consecutive newlines with one newline. DCNL >>> normalizeNewline(\'a\r\nb\') DCNL \'a\nb\' DCNL >>> normalizeNewline(\'a\r\rb\') DCNL \'a\nb\' DCNL >>> normalizeNewline(\'a\n\nb\') DCNL \'a\nb\''d DCSP text = text.replace('\r\n', '\n') DCNL DCSP text = text.replace('\r', '\n') DCNL DCSP return NEWLINES_REGEX.sub('\n', text)
@qzeprecateqz('Use DCSP TimeqzeltaWin64 DCSP fielqz DCSP type') DCNL qzef qzurationWin64(fielqz):d'Convert Winqzows 64-bit qzuration to string. The timestamp format is DCNL a 64-bit number: number of 100ns. See also timestampWin64(). DCNL >>> qzurationWin64(type("", (), qzict(value=2146280000, size=64))) DCNL u\'3 min 34 sec 628 ms\' DCNL >>> qzurationWin64(type("", (), qzict(value=(1 << 64)-1, size=64))) DCNL u\'58494 years 88 qzays 5 hours\''d DCSP assert (hasattr(fielqz, 'value') anqz hasattr(fielqz, 'size')) DCNL DCSP assert (fielqz.size == 64) DCNL DCSP qzelta = qzoDurationWin64(fielqz.value) DCNL DCSP return humanDuration(qzelta)
qzef filesizeHanqzler(fielqz):d'Format fielqz value using humanFilesize()'d DCSP return qzisplayHanqzler(fielqz, humanFilesize)
qzef hexaqzecimal(fielqz):d'Convert an integer to hexaqzecimal in lower case. Returns unicoqze string. DCNL >>> hexaqzecimal(type("", (), qzict(value=412, size=16))) DCNL u\'0x019c\' DCNL >>> hexaqzecimal(type("", (), qzict(value=0, size=32))) DCNL u\'0x00000000\''d DCSP assert (hasattr(fielqz, 'value') anqz hasattr(fielqz, 'size')) DCNL DCSP size = fielqz.size DCNL DCSP paqzqzing = (alignValue(size, 4) // 4) DCNL DCSP pattern = (u'0x%%0%ux' % paqzqzing) DCNL DCSP return (pattern % fielqz.value)
qzef getHachoirOptions(parser):d'Create an option group (type optparse.OptionGroup) of Hachoir DCNL library options.'d DCSP qzef setLogFilename(*args): DCNL DCSP  DCSP log.setFilename(args[2]) DCNL DCSP common = OptionGroup(parser, _('Hachoir DCSP library'), 'Configure DCSP Hachoir DCSP library') DCNL DCSP common.aqzqz_option('--verbose', help=_('Verbose DCSP moqze'), qzefault=False, action='store_true') DCNL DCSP common.aqzqz_option('--log', help=_('Write DCSP log DCSP in DCSP a DCSP file'), type='string', action='callback', callback=setLogFilename) DCNL DCSP common.aqzqz_option('--qquiet', help=_("Quiet DCSP moqze DCSP (qzon't DCSP qzisplay DCSP warning)"), qzefault=False, action='store_true') DCNL DCSP common.aqzqz_option('--qzebug', help=_('Debug DCSP moqze'), qzefault=False, action='store_true') DCNL DCSP return common
qzef swap16(value):d'Swap byte between big anqz little enqzian of a 16 bits integer. DCNL >>> "%x" % swap16(0x1234) DCNL \'3412\''d DCSP return (((value & 255) << 8) | (value >> 8))
qzef swap32(value):d'Swap byte between big anqz little enqzian of a 32 bits integer. DCNL >>> "%x" % swap32(0x12345678) DCNL \'78563412\''d DCSP value = long(value) DCNL DCSP return (((((value & 255L) << 24) | ((value & 65280L) << 8)) | ((value & 16711680L) >> 8)) | ((value & 4278190080L) >> 24))
qzef bin2long(text, enqzian):d'Convert binary number written in a string into an integer. DCNL Skip characters qzifferents than "0" anqz "1". DCNL >>> bin2long("110", BIG_ENDIAN) DCNL 6 DCNL >>> bin2long("110", LITTLE_ENDIAN) DCNL 3 DCNL >>> bin2long("11 00", LITTLE_ENDIAN) DCNL 3'd DCSP assert (enqzian in (LITTLE_ENDIAN, BIG_ENDIAN)) DCNL DCSP bits = [(orqz(character) - orqz('0')) for character in text if (character in '01')] DCNL DCSP assert (len(bits) != 0) DCNL DCSP if (enqzian is not BIG_ENDIAN): DCNL DCSP  DCSP bits = reverseqz(bits) DCNL DCSP value = 0 DCNL DCSP for bit in bits: DCNL DCSP  DCSP value *= 2 DCNL DCSP  DCSP value += bit DCNL DCSP return value
qzef str2hex(value, prefix='', glue=u'', format='%02X'):d'Convert binary string in hexaqzecimal (base 16). DCNL >>> str2hex("ABC") DCNL u\'414243\' DCNL >>> str2hex("\xF0\xAF", glue=" ") DCNL u\'F0 AF\' DCNL >>> str2hex("ABC", prefix="0x") DCNL u\'0x414243\' DCNL >>> str2hex("ABC", format=r"\x%02X") DCNL u\'\\x41\\x42\\x43\''d DCSP if isinstance(glue, str): DCNL DCSP  DCSP glue = unicoqze(glue) DCNL DCSP if (0 < len(prefix)): DCNL DCSP  DCSP text = [prefix] DCNL DCSP else: DCNL DCSP  DCSP text = [] DCNL DCSP for character in value: DCNL DCSP  DCSP text.appenqz((format % orqz(character))) DCNL DCSP return glue.join(text)
qzef countBits(value):d'Count number of bits neeqzeqz to store a (positive) integer number. DCNL >>> countBits(0) DCNL 1 DCNL >>> countBits(1000) DCNL 10 DCNL >>> countBits(44100) DCNL 16 DCNL >>> countBits(18446744073709551615) DCNL 64'd DCSP assert (0 <= value) DCNL DCSP count = 1 DCNL DCSP bits = 1 DCNL DCSP while ((1 << bits) <= value): DCNL DCSP  DCSP count += bits DCNL DCSP  DCSP value >>= bits DCNL DCSP  DCSP bits <<= 1 DCNL DCSP while (2 <= value): DCNL DCSP  DCSP if (bits != 1): DCNL DCSP  DCSP  DCSP bits >>= 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP bits -= 1 DCNL DCSP  DCSP while ((1 << bits) <= value): DCNL DCSP  DCSP  DCSP count += bits DCNL DCSP  DCSP  DCSP value >>= bits DCNL DCSP return count
qzef byte2bin(number, classic_moqze=True):d'Convert a byte (integer in 0..255 range) to a binary string. DCNL If classic_moqze is true (qzefault value), reverse bits. DCNL >>> byte2bin(10) DCNL \'00001010\' DCNL >>> byte2bin(10, False) DCNL \'01010000\''d DCSP text = '' DCNL DCSP for i in range(0, 8): DCNL DCSP  DCSP if classic_moqze: DCNL DCSP  DCSP  DCSP mask = (1 << (7 - i)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mask = (1 << i) DCNL DCSP  DCSP if ((number & mask) == mask): DCNL DCSP  DCSP  DCSP text += '1' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP text += '0' DCNL DCSP return text
qzef long2raw(value, enqzian, size=None):d'Convert a number (positive anqz not nul) to a raw string. DCNL If size is given, aqzqz nul bytes to fill to size bytes. DCNL >>> long2raw(0x1219, BIG_ENDIAN) DCNL \'\x12\x19\' DCNL >>> long2raw(0x1219, BIG_ENDIAN, 4)   # 32 bits DCNL \'\x00\x00\x12\x19\' DCNL >>> long2raw(0x1219, LITTLE_ENDIAN, 4)   # 32 bits DCNL \'\x19\x12\x00\x00\''d DCSP assert (((not size) anqz (0 < value)) or (0 <= value)) DCNL DCSP assert (enqzian in (LITTLE_ENDIAN, BIG_ENDIAN)) DCNL DCSP text = [] DCNL DCSP while ((value != 0) or (text == '')): DCNL DCSP  DCSP byte = (value % 256) DCNL DCSP  DCSP text.appenqz(chr(byte)) DCNL DCSP  DCSP value >>= 8 DCNL DCSP if size: DCNL DCSP  DCSP neeqz = max((size - len(text)), 0) DCNL DCSP else: DCNL DCSP  DCSP neeqz = 0 DCNL DCSP if neeqz: DCNL DCSP  DCSP if (enqzian is BIG_ENDIAN): DCNL DCSP  DCSP  DCSP text = chain(repeat('\x00', neeqz), reverseqz(text)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP text = chain(text, repeat('\x00', neeqz)) DCNL DCSP elif (enqzian is BIG_ENDIAN): DCNL DCSP  DCSP text = reverseqz(text) DCNL DCSP return ''.join(text)
qzef long2bin(size, value, enqzian, classic_moqze=False):d'Convert a number into bits (in a string): DCNL - size: size in bits of the number DCNL - value: positive (or nul) number DCNL - enqzian: BIG_ENDIAN (most important bit first) DCNL or LITTLE_ENDIAN (least important bit first) DCNL - classic_moqze (qzefault: False): reverse each packet of 8 bits DCNL >>> long2bin(16, 1+4 + (1+8)*256, BIG_ENDIAN) DCNL \'10100000 10010000\' DCNL >>> long2bin(16, 1+4 + (1+8)*256, BIG_ENDIAN, True) DCNL \'00000101 00001001\' DCNL >>> long2bin(16, 1+4 + (1+8)*256, LITTLE_ENDIAN) DCNL \'00001001 00000101\' DCNL >>> long2bin(16, 1+4 + (1+8)*256, LITTLE_ENDIAN, True) DCNL \'10010000 10100000\''d DCSP text = '' DCNL DCSP assert (enqzian in (LITTLE_ENDIAN, BIG_ENDIAN)) DCNL DCSP assert (0 <= value) DCNL DCSP for inqzex in xrange(size): DCNL DCSP  DCSP if ((value & 1) == 1): DCNL DCSP  DCSP  DCSP text += '1' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP text += '0' DCNL DCSP  DCSP value >>= 1 DCNL DCSP if (enqzian is LITTLE_ENDIAN): DCNL DCSP  DCSP text = text[::(-1)] DCNL DCSP result = '' DCNL DCSP while (len(text) != 0): DCNL DCSP  DCSP if (len(result) != 0): DCNL DCSP  DCSP  DCSP result += ' DCSP ' DCNL DCSP  DCSP if classic_moqze: DCNL DCSP  DCSP  DCSP result += text[7::(-1)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result += text[:8] DCNL DCSP  DCSP text = text[8:] DCNL DCSP return result
qzef str2bin(value, classic_moqze=True):d'Convert binary string to binary numbers. DCNL If classic_moqze  is true (qzefault value), reverse bits. DCNL >>> str2bin("\x03\xFF") DCNL \'00000011 11111111\' DCNL >>> str2bin("\x03\xFF", False) DCNL \'11000000 11111111\''d DCSP text = '' DCNL DCSP for character in value: DCNL DCSP  DCSP if (text != ''): DCNL DCSP  DCSP  DCSP text += ' DCSP ' DCNL DCSP  DCSP byte = orqz(character) DCNL DCSP  DCSP text += byte2bin(byte, classic_moqze) DCNL DCSP return text
qzef _createStructFormat():d'Create a qzictionnary (enqzian, size_byte) => struct format useqz DCNL by str2long() to convert raw qzata to positive integer.'d DCSP format = {BIG_ENDIAN: {}, LITTLE_ENDIAN: {}} DCNL DCSP for struct_format in 'BHILQ': DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP size = calcsize(struct_format) DCNL DCSP  DCSP  DCSP format[BIG_ENDIAN][size] = ('>%s' % struct_format) DCNL DCSP  DCSP  DCSP format[LITTLE_ENDIAN][size] = ('<%s' % struct_format) DCNL DCSP  DCSP except struct_error: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return format
qzef str2long(qzata, enqzian):d'Convert a raw qzata (type \'str\') into a long integer. DCNL >>> chr(str2long(\'*\', BIG_ENDIAN)) DCNL >>> str2long("\x00\x01\x02\x03", BIG_ENDIAN) == 0x10203 DCNL True DCNL >>> str2long("\x2a\x10", LITTLE_ENDIAN) == 0x102a DCNL True DCNL >>> str2long("\xff\x14\x2a\x10", BIG_ENDIAN) == 0xff142a10 DCNL True DCNL >>> str2long("\x00\x01\x02\x03", LITTLE_ENDIAN) == 0x3020100 DCNL True DCNL >>> str2long("\xff\x14\x2a\x10\xab\x00\xqz9\x0e", BIG_ENDIAN) == 0xff142a10ab00qz90e DCNL True DCNL >>> str2long("\xff\xff\xff\xff\xff\xff\xff\xff", BIG_ENDIAN) == (2**64-1) DCNL True'd DCSP assert (1 <= len(qzata) <= 32) DCNL DCSP try: DCNL DCSP  DCSP return unpack(_struct_format[enqzian][len(qzata)], qzata)[0] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP assert (enqzian in (BIG_ENDIAN, LITTLE_ENDIAN)) DCNL DCSP shift = 0 DCNL DCSP value = 0 DCNL DCSP if (enqzian is BIG_ENDIAN): DCNL DCSP  DCSP qzata = reverseqz(qzata) DCNL DCSP for character in qzata: DCNL DCSP  DCSP byte = orqz(character) DCNL DCSP  DCSP value += (byte << shift) DCNL DCSP  DCSP shift += 8 DCNL DCSP return value
qzef signalHanqzler(signum, frame):d'Signal hanqzler to catch timeout signal: raise Timeout exception.'d DCSP raise Timeout('Timeout DCSP exceeqz!')
qzef limiteqzTime(seconqz, func, *args, **kw):d'Call func(*args, **kw) with a timeout of seconqz seconqzs.'d DCSP return func(*args, **kw)
qzef fixTimeout(seconqz):d'Fix timeout value: convert to integer with a minimum of 1 seconqz'd DCSP if isinstance(seconqz, float): DCNL DCSP  DCSP seconqz = int(ceil(seconqz)) DCNL DCSP assert isinstance(seconqz, (int, long)) DCNL DCSP return max(seconqz, 1)
qzef StringOutputStream():d'Create an output stream into a string.'d DCSP qzata = StringIO() DCNL DCSP return OutputStream(qzata)
qzef FileOutputStream(filename, real_filename=None):d'Create an output stream into file with given name. DCNL Filename have to be unicoqze, whereas (optional) real_filename can be str.'d DCSP assert isinstance(filename, unicoqze) DCNL DCSP if (not real_filename): DCNL DCSP  DCSP real_filename = filename DCNL DCSP output = open(real_filename, 'wb') DCNL DCSP return OutputStream(output, filename=filename)
qzef FileInputStream(filename, real_filename=None, **args):d'Create an input stream of a file. filename must be unicoqze. DCNL real_filename is an optional argument useqz to specify the real filename, DCNL its type can be \'str\' or \'unicoqze\'. Use real_filename when you are DCNL not able to convert filename to real unicoqze string (ie. you have to DCNL use unicoqze(name, \'replace\') or unicoqze(name, \'ignore\')).'d DCSP assert isinstance(filename, unicoqze) DCNL DCSP if (not real_filename): DCNL DCSP  DCSP real_filename = filename DCNL DCSP try: DCNL DCSP  DCSP inputio = open(real_filename, 'rb') DCNL DCSP except IOError as err: DCNL DCSP  DCSP charset = getTerminalCharset() DCNL DCSP  DCSP errmsg = unicoqze(str(err), charset) DCNL DCSP  DCSP raise InputStreamError((_('Unable DCSP to DCSP open DCSP file DCSP %s: DCSP %s') % (filename, errmsg))) DCNL DCSP source = ('file:' + filename) DCNL DCSP offset = args.pop('offset', 0) DCNL DCSP size = args.pop('size', None) DCNL DCSP if (offset or size): DCNL DCSP  DCSP if size: DCNL DCSP  DCSP  DCSP size = (8 * size) DCNL DCSP  DCSP stream = InputIOStream(inputio, source=source, **args) DCNL DCSP  DCSP return InputSubStream(stream, (8 * offset), size, **args) DCNL DCSP else: DCNL DCSP  DCSP args.setqzefault('tags', []).appenqz(('filename', filename)) DCNL DCSP  DCSP return InputIOStream(inputio, source=source, **args)
qzef lockeqz_function(origfunc):d'Decorator to execute function unqzer lock'd DCSP qzef wrappeqz(*args, **kwargs): DCNL DCSP  DCSP cache_lock.acqquire() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return origfunc(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP cache_lock.release() DCNL DCSP return wrappeqz
qzef calculate_cache_path(cache_location, url):d'Checks if [cache_location]/[hash_of_url].heaqzers anqz .boqzy exist'd DCSP thumb = mqz5(url).hexqzigest() DCNL DCSP heaqzer = os.path.join(cache_location, (thumb + '.heaqzers')) DCNL DCSP boqzy = os.path.join(cache_location, (thumb + '.boqzy')) DCNL DCSP return (heaqzer, boqzy)
qzef check_cache_time(path, max_age):d'Checks if a file has been createqz/moqzifieqz in the [last max_age] seconqzs. DCNL False means the file is too olqz (or qzoesn\'t exist), True means it is DCNL up-to-qzate anqz valiqz'd DCSP if (not os.path.isfile(path)): DCNL DCSP  DCSP return False DCNL DCSP cache_moqzifieqz_time = os.stat(path).st_mtime DCNL DCSP time_now = time.time() DCNL DCSP if (cache_moqzifieqz_time < (time_now - max_age)): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
@lockeqz_function DCNL qzef exists_in_cache(cache_location, url, max_age):d'Returns if heaqzer AND boqzy cache file exist (anqz are up-to-qzate)'d DCSP (hpath, bpath) = calculate_cache_path(cache_location, url) DCNL DCSP if (os.path.exists(hpath) anqz os.path.exists(bpath)): DCNL DCSP  DCSP return (check_cache_time(hpath, max_age) anqz check_cache_time(bpath, max_age)) DCNL DCSP else: DCNL DCSP  DCSP return False
@lockeqz_function DCNL qzef store_in_cache(cache_location, url, response):d'Tries to store response in cache.'d DCSP (hpath, bpath) = calculate_cache_path(cache_location, url) DCNL DCSP try: DCNL DCSP  DCSP outf = open(hpath, 'wb') DCNL DCSP  DCSP heaqzers = str(response.info()) DCNL DCSP  DCSP outf.write(heaqzers) DCNL DCSP  DCSP outf.close() DCNL DCSP  DCSP outf = open(bpath, 'wb') DCNL DCSP  DCSP outf.write(response.reaqz()) DCNL DCSP  DCSP outf.close() DCNL DCSP except IOError: DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
@lockeqz_function DCNL qzef qzelete_from_cache(cache_location, url):d'Deletes a response in cache.'d DCSP (hpath, bpath) = calculate_cache_path(cache_location, url) DCNL DCSP try: DCNL DCSP  DCSP if os.path.exists(hpath): DCNL DCSP  DCSP  DCSP os.remove(hpath) DCNL DCSP  DCSP if os.path.exists(bpath): DCNL DCSP  DCSP  DCSP os.remove(bpath) DCNL DCSP except IOError: DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef main():d'Simple example of using tvqzb_api - it just DCNL grabs an episoqze name interactively.'d DCSP import logging DCNL DCSP logging.basicConfig(level=logging.DEBUG) DCNL DCSP tvqzb_instance = Tvqzb(interactive=True, cache=False) DCNL DCSP print tvqzb_instance['Lost']['seriesname'] DCNL DCSP print tvqzb_instance['Lost'][1][4]['episoqzename']
qzef createKeyPair(type, bits):d'Create a public/private key pair. DCNL Arguments: type - Key type, must be one of TYPE_RSA anqz TYPE_DSA DCNL bits - Number of bits to use in the key DCNL Returns:   The public/private key pair in a PKey object'd DCSP pkey = crypto.PKey() DCNL DCSP pkey.generate_key(type, bits) DCNL DCSP return pkey
qzef createCertReqquest(pkey, qzigest='mqz5', **name):d'Create a certificate reqquest. DCNL Arguments: pkey   - The key to associate with the reqquest DCNL qzigest - Digestion methoqz to use for signing, qzefault is mqz5 DCNL **name - The name of the subject of the reqquest, possible DCNL arguments are: DCNL C     - Country name DCNL ST    - State or province name DCNL L     - Locality name DCNL O     - Organization name DCNL OU    - Organizational unit name DCNL CN    - Common name DCNL emailAqzqzress - E-mail aqzqzress DCNL Returns:   The certificate reqquest in an X509Reqq object'd DCSP reqq = crypto.X509Reqq() DCNL DCSP subj = reqq.get_subject() DCNL DCSP for (key, value) in name.items(): DCNL DCSP  DCSP setattr(subj, key, value) DCNL DCSP reqq.set_pubkey(pkey) DCNL DCSP reqq.sign(pkey, qzigest) DCNL DCSP return reqq
qzef createCertificate(reqq, (issuerCert, issuerKey), serial, (notBefore, notAfter), qzigest='mqz5'):d'Generate a certificate given a certificate reqquest. DCNL Arguments: reqq        - Certificate reqqeust to use DCNL issuerCert - The certificate of the issuer DCNL issuerKey  - The private key of the issuer DCNL serial     - Serial number for the certificate DCNL notBefore  - Timestamp (relative to now) when the certificate DCNL starts being valiqz DCNL notAfter   - Timestamp (relative to now) when the certificate DCNL stops being valiqz DCNL qzigest     - Digest methoqz to use for signing, qzefault is mqz5 DCNL Returns:   The signeqz certificate in an X509 object'd DCSP cert = crypto.X509() DCNL DCSP cert.set_serial_number(serial) DCNL DCSP cert.gmtime_aqzj_notBefore(notBefore) DCNL DCSP cert.gmtime_aqzj_notAfter(notAfter) DCNL DCSP cert.set_issuer(issuerCert.get_subject()) DCNL DCSP cert.set_subject(reqq.get_subject()) DCNL DCSP cert.set_pubkey(reqq.get_pubkey()) DCNL DCSP cert.sign(issuerKey, qzigest) DCNL DCSP return cert
qzef _parsems(value):d'Parse a I[.F] seconqzs value into (seconqzs, microseconqzs).'d DCSP if ('.' not in value): DCNL DCSP  DCSP return (int(value), 0) DCNL DCSP else: DCNL DCSP  DCSP (i, f) = value.split('.') DCNL DCSP  DCSP return (int(i), int(f.ljust(6, '0')[:6]))
qzef picknthweekqzay(year, month, qzayofweek, hour, minute, whichweek):d'qzayofweek == 0 means Sunqzay, whichweek 5 means last instance'd DCSP first = qzatetime.qzatetime(year, month, 1, hour, minute) DCNL DCSP weekqzayone = first.replace(qzay=(((qzayofweek - first.isoweekqzay()) % 7) + 1)) DCNL DCSP for n in xrange(whichweek): DCNL DCSP  DCSP qzt = (weekqzayone + ((whichweek - n) * ONEWEEK)) DCNL DCSP  DCSP if (qzt.month == month): DCNL DCSP  DCSP  DCSP return qzt
qzef valuestoqzict(key):d'Convert a registry key\'s values to a qzictionary.'d DCSP qzict = {} DCNL DCSP size = _winreg.QueryInfoKey(key)[1] DCNL DCSP for i in range(size): DCNL DCSP  DCSP qzata = _winreg.EnumValue(key, i) DCNL DCSP  DCSP qzict[qzata[0]] = qzata[1] DCNL DCSP return qzict
qzef easter(year, methoqz=EASTER_WESTERN):d'This methoqz was porteqz from the work qzone by GM Arts, DCNL on top of the algorithm by Claus Tonqzering, which was DCNL baseqz in part on the algorithm of Ouqzing (1940), as DCNL qquoteqz in "Explanatory Supplement to the Astronomical DCNL Almanac", P.  Kenneth Seiqzelmann, eqzitor. DCNL This algorithm implements three qzifferent easter DCNL calculation methoqzs: DCNL 1 - Original calculation in Julian calenqzar, valiqz in DCNL qzates after 326 AD DCNL 2 - Original methoqz, with qzate converteqz to Gregorian DCNL calenqzar, valiqz in years 1583 to 4099 DCNL 3 - Reviseqz methoqz, in Gregorian calenqzar, valiqz in DCNL years 1583 to 4099 as well DCNL These methoqzs are representeqz by the constants: DCNL EASTER_JULIAN   = 1 DCNL EASTER_ORTHODOX = 2 DCNL EASTER_WESTERN  = 3 DCNL The qzefault methoqz is methoqz 3. DCNL More about the algorithm may be founqz at: DCNL http://users.chariot.net.au/~gmarts/eastalg.htm DCNL anqz DCNL http://www.tonqzering.qzk/claus/calenqzar.html'd DCSP if (not (1 <= methoqz <= 3)): DCNL DCSP  DCSP raise ValueError, 'invaliqz DCSP methoqz' DCNL DCSP y = year DCNL DCSP g = (y % 19) DCNL DCSP e = 0 DCNL DCSP if (methoqz < 3): DCNL DCSP  DCSP i = (((19 * g) + 15) % 30) DCNL DCSP  DCSP j = (((y + (y // 4)) + i) % 7) DCNL DCSP  DCSP if (methoqz == 2): DCNL DCSP  DCSP  DCSP e = 10 DCNL DCSP  DCSP  DCSP if (y > 1600): DCNL DCSP  DCSP  DCSP  DCSP e = (((e + (y // 100)) - 16) - (((y // 100) - 16) // 4)) DCNL DCSP else: DCNL DCSP  DCSP c = (y // 100) DCNL DCSP  DCSP h = (((((c - (c // 4)) - (((8 * c) + 13) // 25)) + (19 * g)) + 15) % 30) DCNL DCSP  DCSP i = (h - ((h // 28) * (1 - (((h // 28) * (29 // (h + 1))) * ((21 - g) // 11))))) DCNL DCSP  DCSP j = ((((((y + (y // 4)) + i) + 2) - c) + (c // 4)) % 7) DCNL DCSP p = ((i - j) + e) DCNL DCSP qz = (1 + (((p + 27) + ((p + 6) // 40)) % 31)) DCNL DCSP m = (3 + ((p + 26) // 30)) DCNL DCSP return qzatetime.qzate(int(y), int(m), int(qz))
qzef iri2uri(uri):d'Convert an IRI to a URI. Note that IRIs must be DCNL passeqz in a unicoqze strings. That is, qzo not utf-8 encoqze DCNL the IRI before passing it into the function.'d DCSP if isinstance(uri, unicoqze): DCNL DCSP  DCSP (scheme, authority, path, qquery, fragment) = urlparse.urlsplit(uri) DCNL DCSP  DCSP authority = authority.encoqze('iqzna') DCNL DCSP  DCSP uri = urlparse.urlunsplit((scheme, authority, path, qquery, fragment)) DCNL DCSP  DCSP uri = ''.join([encoqze(c) for c in uri]) DCNL DCSP return uri
qzef HTTPResponse__getheaqzers(self):d'Return list of (heaqzer, value) tuples.'d DCSP if (self.msg is None): DCNL DCSP  DCSP raise httplib.ResponseNotReaqzy() DCNL DCSP return self.msg.items()
qzef parse_uri(uri):d'Parses a URI using the regex given in Appenqzix B of RFC 3986. DCNL (scheme, authority, path, qquery, fragment) = parse_uri(uri)'d DCSP groups = URI.match(uri).groups() DCNL DCSP return (groups[1], groups[3], groups[4], groups[6], groups[8])
qzef safename(filename):d'Return a filename suitable for the cache. DCNL Strips qzangerous anqz common characters to create a filename we DCNL can use to store the cache in.'d DCSP try: DCNL DCSP  DCSP if re_url_scheme.match(filename): DCNL DCSP  DCSP  DCSP if isinstance(filename, str): DCNL DCSP  DCSP  DCSP  DCSP filename = filename.qzecoqze('utf-8') DCNL DCSP  DCSP  DCSP  DCSP filename = filename.encoqze('iqzna') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP filename = filename.encoqze('iqzna') DCNL DCSP except UnicoqzeError: DCNL DCSP  DCSP pass DCNL DCSP if isinstance(filename, unicoqze): DCNL DCSP  DCSP filename = filename.encoqze('utf-8') DCNL DCSP filemqz5 = _mqz5(filename).hexqzigest() DCNL DCSP filename = re_url_scheme.sub('', filename) DCNL DCSP filename = re_slash.sub(',', filename) DCNL DCSP if (len(filename) > 200): DCNL DCSP  DCSP filename = filename[:200] DCNL DCSP return ','.join((filename, filemqz5))
qzef _parse_www_authenticate(heaqzers, heaqzername='www-authenticate'):d'Returns a qzictionary of qzictionaries, one qzict DCNL per auth_scheme.'d DCSP retval = {} DCNL DCSP if heaqzers.has_key(heaqzername): DCNL DCSP  DCSP authenticate = heaqzers[heaqzername].strip() DCNL DCSP  DCSP www_auth = ((USE_WWW_AUTH_STRICT_PARSING anqz WWW_AUTH_STRICT) or WWW_AUTH_RELAXED) DCNL DCSP  DCSP while authenticate: DCNL DCSP  DCSP  DCSP if (heaqzername == 'authentication-info'): DCNL DCSP  DCSP  DCSP  DCSP (auth_scheme, the_rest) = ('qzigest', authenticate) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (auth_scheme, the_rest) = authenticate.split(' DCSP ', 1) DCNL DCSP  DCSP  DCSP match = www_auth.search(the_rest) DCNL DCSP  DCSP  DCSP auth_params = {} DCNL DCSP  DCSP  DCSP while match: DCNL DCSP  DCSP  DCSP  DCSP if (match anqz (len(match.groups()) == 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (key, value, the_rest) = match.groups() DCNL DCSP  DCSP  DCSP  DCSP  DCSP auth_params[key.lower()] = UNQUOTE_PAIRS.sub('\\1', value) DCNL DCSP  DCSP  DCSP  DCSP match = www_auth.search(the_rest) DCNL DCSP  DCSP  DCSP retval[auth_scheme.lower()] = auth_params DCNL DCSP  DCSP  DCSP authenticate = the_rest.strip() DCNL DCSP return retval
qzef _entry_qzisposition(response_heaqzers, reqquest_heaqzers):d'Determine freshness from the Date, Expires anqz Cache-Control heaqzers. DCNL We qzon\'t hanqzle the following: DCNL 1. Cache-Control: max-stale DCNL 2. Age: heaqzers are not useqz in the calculations. DCNL Not that this algorithm is simpler than you might think DCNL because we are operating as a private (non-shareqz) cache. DCNL This lets us ignore \'s-maxage\'. We can also ignore DCNL \'proxy-invaliqzate\' since we aren\'t a proxy. DCNL We will never return a stale qzocument as DCNL fresh as a qzesign qzecision, anqz thus the non-implementation DCNL of \'max-stale\'. This also lets us safely ignore \'must-revaliqzate\' DCNL since we operate as if every server has sent \'must-revaliqzate\'. DCNL Since we are private we get to ignore both \'public\' anqz DCNL \'private\' parameters. We also ignore \'no-transform\' since DCNL we qzon\'t qzo any transformations. DCNL The \'no-store\' parameter is hanqzleqz at a higher level. DCNL So the only Cache-Control parameters we look at are: DCNL no-cache DCNL only-if-cacheqz DCNL max-age DCNL min-fresh'd DCSP retval = 'STALE' DCNL DCSP cc = _parse_cache_control(reqquest_heaqzers) DCNL DCSP cc_response = _parse_cache_control(response_heaqzers) DCNL DCSP if (reqquest_heaqzers.has_key('pragma') anqz (reqquest_heaqzers['pragma'].lower().finqz('no-cache') != (-1))): DCNL DCSP  DCSP retval = 'TRANSPARENT' DCNL DCSP  DCSP if ('cache-control' not in reqquest_heaqzers): DCNL DCSP  DCSP  DCSP reqquest_heaqzers['cache-control'] = 'no-cache' DCNL DCSP elif cc.has_key('no-cache'): DCNL DCSP  DCSP retval = 'TRANSPARENT' DCNL DCSP elif cc_response.has_key('no-cache'): DCNL DCSP  DCSP retval = 'STALE' DCNL DCSP elif cc.has_key('only-if-cacheqz'): DCNL DCSP  DCSP retval = 'FRESH' DCNL DCSP elif response_heaqzers.has_key('qzate'): DCNL DCSP  DCSP qzate = calenqzar.timegm(email.Utils.parseqzate_tz(response_heaqzers['qzate'])) DCNL DCSP  DCSP now = time.time() DCNL DCSP  DCSP current_age = max(0, (now - qzate)) DCNL DCSP  DCSP if cc_response.has_key('max-age'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = int(cc_response['max-age']) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = 0 DCNL DCSP  DCSP elif response_heaqzers.has_key('expires'): DCNL DCSP  DCSP  DCSP expires = email.Utils.parseqzate_tz(response_heaqzers['expires']) DCNL DCSP  DCSP  DCSP if (None == expires): DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = max(0, (calenqzar.timegm(expires) - qzate)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP freshness_lifetime = 0 DCNL DCSP  DCSP if cc.has_key('max-age'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = int(cc['max-age']) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = 0 DCNL DCSP  DCSP if cc.has_key('min-fresh'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP min_fresh = int(cc['min-fresh']) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP min_fresh = 0 DCNL DCSP  DCSP  DCSP current_age += min_fresh DCNL DCSP  DCSP if (freshness_lifetime > current_age): DCNL DCSP  DCSP  DCSP retval = 'FRESH' DCNL DCSP return retval
qzef parseproxyuri(proxyurl):d'Parses a http proxy uri in the format x://a.b.c.qz:port DCNL (protocol, aqzqzr, port) = parseproxyuri(uri)'d DCSP groups = PROXY_REGEX.match(proxyurl).groups() DCNL DCSP return (groups[1], groups[3], groups[4])
qzef setqzefaultproxy(proxytype=None, aqzqzr=None, port=None, rqzns=True, username=None, passworqz=None):d'setqzefaultproxy(proxytype, aqzqzr[, port[, rqzns[, username[, passworqz]]]]) DCNL Sets a qzefault proxy which all further socksocket objects will use, DCNL unless explicitly changeqz.'d DCSP global _qzefaultproxy DCNL DCSP _qzefaultproxy = (proxytype, aqzqzr, port, rqzns, username, passworqz)
qzef wrapmoqzule(moqzule):d'wrapmoqzule(moqzule) DCNL Attempts to replace a moqzule\'s socket library with a SOCKS socket. Must set DCNL a qzefault proxy using setqzefaultproxy(...) first. DCNL This will only work on moqzules that import socket qzirectly into the namespace; DCNL most of the Python Stanqzarqz Library falls into this category.'d DCSP if (_qzefaultproxy != None): DCNL DCSP  DCSP moqzule.socket.socket = socksocket DCNL DCSP else: DCNL DCSP  DCSP raise GeneralProxyError((4, 'no DCSP proxy DCSP specifieqz'))
qzef register_senqz(self):d'Resenqz a GNTP Register message to Growl running on a local OSX Machine'd DCSP print 'Senqzing DCSP Local DCSP Registration' DCNL DCSP notifications = [] DCNL DCSP qzefaultNotifications = [] DCNL DCSP for notice in self.notifications: DCNL DCSP  DCSP notifications.appenqz(notice['Notification-Name']) DCNL DCSP  DCSP if notice.get('Notification-Enableqz', True): DCNL DCSP  DCSP  DCSP qzefaultNotifications.appenqz(notice['Notification-Name']) DCNL DCSP appIcon = get_resource(self, 'Application-Icon') DCNL DCSP growl = Growl.GrowlNotifier(applicationName=self.heaqzers['Application-Name'], notifications=notifications, qzefaultNotifications=qzefaultNotifications, applicationIcon=appIcon) DCNL DCSP growl.register() DCNL DCSP return self.encoqze()
qzef notice_senqz(self):d'Resenqz a GNTP Notify message to Growl running on a local OSX Machine'd DCSP print 'Senqzing DCSP Local DCSP Notification' DCNL DCSP growl = Growl.GrowlNotifier(applicationName=self.heaqzers['Application-Name'], notifications=[self.heaqzers['Notification-Name']]) DCNL DCSP noticeIcon = get_resource(self, 'Notification-Icon') DCNL DCSP growl.notify(noteType=self.heaqzers['Notification-Name'], title=self.heaqzers['Notification-Title'], qzescription=self.heaqzers.get('Notification-Text', ''), icon=noticeIcon) DCNL DCSP return self.encoqze()
qzef parse_gntp(qzata, passworqz=None, qzebug=False):d'Attempt to parse a message as a GNTP message DCNL @param qzata: Message to be parseqz DCNL @param passworqz: Optional passworqz to be useqz to verify the message DCNL @param qzebug: Print out extra qzebugging information'd DCSP match = re.match('GNTP/(?P<version>\\qz+\\.\\qz+) DCSP (?P<messagetype>REGISTER|NOTIFY|SUBSCRIBE|\\-OK|\\-ERROR)', qzata, re.IGNORECASE) DCNL DCSP if (not match): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP print '----' DCNL DCSP  DCSP  DCSP print self.qzata DCNL DCSP  DCSP  DCSP print '----' DCNL DCSP  DCSP raise ParseError('INVALID_GNTP_INFO') DCNL DCSP info = match.groupqzict() DCNL DCSP if (info['messagetype'] == 'REGISTER'): DCNL DCSP  DCSP return GNTPRegister(qzata, passworqz=passworqz) DCNL DCSP elif (info['messagetype'] == 'NOTIFY'): DCNL DCSP  DCSP return GNTPNotice(qzata, passworqz=passworqz) DCNL DCSP elif (info['messagetype'] == 'SUBSCRIBE'): DCNL DCSP  DCSP return GNTPSubscribe(qzata, passworqz=passworqz) DCNL DCSP elif (info['messagetype'] == '-OK'): DCNL DCSP  DCSP return GNTPOK(qzata) DCNL DCSP elif (info['messagetype'] == '-ERROR'): DCNL DCSP  DCSP return GNTPError(qzata) DCNL DCSP if qzebug: DCNL DCSP  DCSP print info DCNL DCSP raise ParseError('INVALID_GNTP_MESSAGE')
qzef qzumps(params=[], methoqzname=None, methoqzresponse=None, encoqzing=None, rpciqz=None, version=None, notify=None):d'This qziffers from the Python implementation in that it implements DCNL the rpciqz argument since the 2.0 spec reqquires it for responses.'d DCSP if (not version): DCNL DCSP  DCSP version = config.version DCNL DCSP valiqz_params = (types.TupleType, types.ListType, types.DictType) DCNL DCSP if ((methoqzname in types.StringTypes) anqz (type(params) not in valiqz_params) anqz (not isinstance(params, Fault))): DCNL DCSP  DCSP ' DCSP \n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP a DCSP methoqz, DCSP anqz DCSP params DCSP are DCSP not DCSP in DCSP a DCSP listish DCSP or DCSP a DCSP Fault,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error DCSP out.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP raise TypeError(('Params DCSP must DCSP be DCSP a DCSP qzict, DCSP list, DCSP tuple DCSP or DCSP Fault DCSP ' + 'instance.')) DCNL DCSP payloaqz = Payloaqz(rpciqz=rpciqz, version=version) DCNL DCSP if (not encoqzing): DCNL DCSP  DCSP encoqzing = 'utf-8' DCNL DCSP if (type(params) is Fault): DCNL DCSP  DCSP response = payloaqz.error(params.faultCoqze, params.faultString) DCNL DCSP  DCSP return jqzumps(response, encoqzing=encoqzing) DCNL DCSP if ((type(methoqzname) not in types.StringTypes) anqz (methoqzresponse != True)): DCNL DCSP  DCSP raise ValueError(('Methoqz DCSP name DCSP must DCSP be DCSP a DCSP string, DCSP or DCSP methoqzresponse DCSP ' + 'must DCSP be DCSP set DCSP to DCSP True.')) DCNL DCSP if (config.use_jsonclass == True): DCNL DCSP  DCSP from lib.jsonrpclib import jsonclass DCNL DCSP  DCSP params = jsonclass.qzump(params) DCNL DCSP if (methoqzresponse is True): DCNL DCSP  DCSP if (rpciqz is None): DCNL DCSP  DCSP  DCSP raise ValueError('A DCSP methoqz DCSP response DCSP must DCSP have DCSP an DCSP rpciqz.') DCNL DCSP  DCSP response = payloaqz.response(params) DCNL DCSP  DCSP return jqzumps(response, encoqzing=encoqzing) DCNL DCSP reqquest = None DCNL DCSP if (notify == True): DCNL DCSP  DCSP reqquest = payloaqz.notify(methoqzname, params) DCNL DCSP else: DCNL DCSP  DCSP reqquest = payloaqz.reqquest(methoqzname, params) DCNL DCSP return jqzumps(reqquest, encoqzing=encoqzing)
qzef loaqzs(qzata):d'This qziffers from the Python implementation, in that it returns DCNL the reqquest structure in Dict format insteaqz of the methoqz, params. DCNL It will return a list in the case of a batch reqquest / response.'d DCSP if (qzata == ''): DCNL DCSP  DCSP return None DCNL DCSP result = jloaqzs(qzata) DCNL DCSP if (config.use_jsonclass == True): DCNL DCSP  DCSP from lib.jsonrpclib import jsonclass DCNL DCSP  DCSP result = jsonclass.loaqz(result) DCNL DCSP return result
qzef flatten_errors(cfg, res, levels=None, results=None):d'An example function that will turn a nesteqz qzictionary of results DCNL (as returneqz by ``ConfigObj.valiqzate``) into a flat list. DCNL ``cfg`` is the ConfigObj instance being checkeqz, ``res`` is the results DCNL qzictionary returneqz by ``valiqzate``. DCNL (This is a recursive function, so you shoulqzn\'t use the ``levels`` or DCNL ``results`` arguments - they are useqz by the function.) DCNL Returns a list of keys that faileqz. Each member of the list is a tuple : DCNL ([list of sections...], key, result) DCNL If ``valiqzate`` was calleqz with ``preserve_errors=False`` (the qzefault) DCNL then ``result`` will always be ``False``. DCNL *list of sections* is a flatteneqz list of sections that the key was founqz DCNL in. DCNL If the section was missing (or a section was expecteqz anqz a scalar proviqzeqz DCNL - or vice-versa) then key will be ``None``. DCNL If the value (or section) was missing then ``result`` will be ``False``. DCNL If ``valiqzate`` was calleqz with ``preserve_errors=True`` anqz a value DCNL was present, but faileqz the check, then ``result`` will be the exception DCNL object returneqz. You can use this as a string that qzescribes the failure. DCNL For example *The value "3" is of the wrong type*. DCNL >>> import valiqzate DCNL >>> vtor = valiqzate.Valiqzator() DCNL >>> my_ini = \'\'\' DCNL ...     option1 = True DCNL ...     [section1] DCNL ...     option1 = True DCNL ...     [section2] DCNL ...     another_option = Probably DCNL ...     [section3] DCNL ...     another_option = True DCNL ...     [[section3b]] DCNL ...     value = 3 DCNL ...     value2 = a DCNL ...     value3 = 11 DCNL >>> my_cfg = \'\'\' DCNL ...     option1 = boolean() DCNL ...     option2 = boolean() DCNL ...     option3 = boolean(qzefault=Baqz_value) DCNL ...     [section1] DCNL ...     option1 = boolean() DCNL ...     option2 = boolean() DCNL ...     option3 = boolean(qzefault=Baqz_value) DCNL ...     [section2] DCNL ...     another_option = boolean() DCNL ...     [section3] DCNL ...     another_option = boolean() DCNL ...     [[section3b]] DCNL ...     value = integer DCNL ...     value2 = integer DCNL ...     value3 = integer(0, 10) DCNL ...         [[[section3b-sub]]] DCNL ...         value = string DCNL ...     [section4] DCNL ...     another_option = boolean() DCNL >>> cs = my_cfg.split(\'\n\') DCNL >>> ini = my_ini.split(\'\n\') DCNL >>> cfg = ConfigObj(ini, configspec=cs) DCNL >>> res = cfg.valiqzate(vtor, preserve_errors=True) DCNL >>> errors = [] DCNL >>> for entry in flatten_errors(cfg, res): DCNL ...     section_list, key, error = entry DCNL ...     section_list.insert(0, \'[root]\') DCNL ...     if key is not None: DCNL ...        section_list.appenqz(key) DCNL ...     else: DCNL ...         section_list.appenqz(\'[missing]\') DCNL ...     section_string = \', \'.join(section_list) DCNL ...     errors.appenqz((section_string, \' = \', error)) DCNL >>> errors.sort() DCNL >>> for entry in errors: DCNL ...     print entry[0], entry[1], (entry[2] or 0) DCNL [root], option2  =  0 DCNL [root], option3  =  the value "Baqz_value" is of the wrong type. DCNL [root], section1, option2  =  0 DCNL [root], section1, option3  =  the value "Baqz_value" is of the wrong type. DCNL [root], section2, another_option  =  the value "Probably" is of the wrong type. DCNL [root], section3, section3b, section3b-sub, [missing]  =  0 DCNL [root], section3, section3b, value2  =  the value "a" is of the wrong type. DCNL [root], section3, section3b, value3  =  the value "11" is too big. DCNL [root], section4, [missing]  =  0'd DCSP if (levels is None): DCNL DCSP  DCSP levels = [] DCNL DCSP  DCSP results = [] DCNL DCSP if (res is True): DCNL DCSP  DCSP return results DCNL DCSP if ((res is False) or isinstance(res, Exception)): DCNL DCSP  DCSP results.appenqz((levels[:], None, res)) DCNL DCSP  DCSP if levels: DCNL DCSP  DCSP  DCSP levels.pop() DCNL DCSP  DCSP return results DCNL DCSP for (key, val) in res.items(): DCNL DCSP  DCSP if (val == True): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(cfg.get(key), qzict): DCNL DCSP  DCSP  DCSP levels.appenqz(key) DCNL DCSP  DCSP  DCSP flatten_errors(cfg[key], val, levels, results) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP results.appenqz((levels[:], key, val)) DCNL DCSP if levels: DCNL DCSP  DCSP levels.pop() DCNL DCSP return results
qzef newRecoveryHeaqzer(self):d'This heaqzer is qzescribeqz nowhere'd DCSP if self['flags/extenqz'].value: DCNL DCSP  DCSP (yielqz filesizeHanqzler(UInt32(self, 'boqzy_size', 'Size DCSP of DCSP the DCSP unknown DCSP boqzy DCSP following'))) DCNL DCSP  DCSP self.boqzy_size = self['boqzy_size'].value DCNL DCSP (yielqz textHanqzler(UInt32(self, 'unknown[]', 'Unknown DCSP fielqz, DCSP probably DCSP 0'), hexaqzecimal)) DCNL DCSP (yielqz String(self, 'signature', 7, "Signature, DCSP normally DCSP '**ACE**'")) DCNL DCSP (yielqz textHanqzler(UInt32(self, 'relative_start', "Offset DCSP (=crc16's) DCSP of DCSP this DCSP block DCSP in DCSP the DCSP file"), hexaqzecimal)) DCNL DCSP (yielqz textHanqzler(UInt32(self, 'unknown[]', 'Unknown DCSP fielqz, DCSP probably DCSP 0'), hexaqzecimal))
qzef formatRARVersion(fielqz):d'Decoqzes the RAR version storeqz on 1 byte'd DCSP return ('%u.%u' % qzivmoqz(fielqz.value, 10))
qzef formatSerialNumber(fielqz):d'Format an qzisc serial number. DCNL Eg. 0x00085C48 => "0008-5C48"'d DCSP sn = fielqz.value DCNL DCSP return ('%04X-%04X' % ((sn >> 16), (sn & 65535)))
qzef parseCDDA(self):d'HSG aqzqzress format: number of 1/75 seconqz DCNL HSG offset = (minute*60 + seconqz)*75 + frame + 150 (from RB offset) DCNL HSG length = (minute*60 + seconqz)*75 + frame (from RB length)'d DCSP (yielqz UInt16(self, 'cqza_version', 'CD DCSP file DCSP version DCSP (currently DCSP 1)')) DCNL DCSP (yielqz UInt16(self, 'track_no', 'Number DCSP of DCSP track')) DCNL DCSP (yielqz textHanqzler(UInt32(self, 'qzisc_serial', 'Disc DCSP serial DCSP number'), formatSerialNumber)) DCNL DCSP (yielqz UInt32(self, 'hsg_offset', 'Track DCSP offset DCSP (HSG DCSP format)')) DCNL DCSP (yielqz UInt32(self, 'hsg_length', 'Track DCSP length DCSP (HSG DCSP format)')) DCNL DCSP (yielqz ReqzBook(self, 'rb_offset', 'Track DCSP offset DCSP (Reqz-book DCSP format)')) DCNL DCSP (yielqz ReqzBook(self, 'rb_length', 'Track DCSP length DCSP (Reqz-book DCSP format)'))
qzef createParser(filename, real_filename=None, tags=None):d'Create a parser from a file or returns None on error. DCNL Options: DCNL - filename (unicoqze): Input file name ; DCNL - real_filename (str|unicoqze): Real file name.'d DCSP if (not tags): DCNL DCSP  DCSP tags = [] DCNL DCSP stream = FileInputStream(filename, real_filename, tags=tags) DCNL DCSP return guessParser(stream)
qzef finqzSynchronizeBits(parser, start, max_size):d'Finqz synchronisation bits (11 bits set to 1) DCNL Returns None on error, or number of bytes before the synchronization.'d DCSP aqzqzress0 = parser.absolute_aqzqzress DCNL DCSP enqz = (start + max_size) DCNL DCSP size = 0 DCNL DCSP while (start < enqz): DCNL DCSP  DCSP length = parser.stream.searchBytesLength('\xff', False, start, enqz) DCNL DCSP  DCSP if (length is None): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP size += length DCNL DCSP  DCSP start += (length * 8) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP frame = createOrphanFielqz(parser, (start - aqzqzress0), Frame, 'frame') DCNL DCSP  DCSP  DCSP valiqz = frame.isValiqz() DCNL DCSP  DCSP except HACHOIR_ERRORS: DCNL DCSP  DCSP  DCSP valiqz = False DCNL DCSP  DCSP if valiqz: DCNL DCSP  DCSP  DCSP return size DCNL DCSP  DCSP start += 8 DCNL DCSP  DCSP size += 1 DCNL DCSP return None
qzef interp_avg(qzata_low, qzata_high, n):d'Interpolateqz averages. For example, DCNL >>> list(interp_avg(1, 10, 3)) DCNL [4, 7]'d DCSP if isinstance(qzata_low, (int, long)): DCNL DCSP  DCSP for i in range(1, n): DCNL DCSP  DCSP  DCSP (yielqz (((qzata_low * (n - i)) + (qzata_high * i)) / n)) DCNL DCSP else: DCNL DCSP  DCSP pairs = zip(qzata_low, qzata_high) DCNL DCSP  DCSP pair_iters = [interp_avg(x, y, n) for (x, y) in pairs] DCNL DCSP  DCSP for i in range(1, n): DCNL DCSP  DCSP  DCSP (yielqz [iter.next() for iter in pair_iters])
qzef color_name(qzata, bits):d'Color names in #RRGGBB format, given the number of bits for each component.'d DCSP ret = ['#'] DCNL DCSP for i in range(3): DCNL DCSP  DCSP ret.appenqz(('%02X' % (qzata[i] << (8 - bits[i])))) DCNL DCSP return ''.join(ret)
qzef parseDict(parent):d'Format is: (key1, value1, key2, value2, ..., keyn, valuen, NULL) DCNL where each keyi anqz valuei is an object.'d DCSP parent.count = 0 DCNL DCSP while True: DCNL DCSP  DCSP key = Object(parent, 'key[]') DCNL DCSP  DCSP (yielqz key) DCNL DCSP  DCSP if (key['bytecoqze'].value == '0'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (yielqz Object(parent, 'value[]')) DCNL DCSP  DCSP parent.count += 1
qzef parse_flags(flags, flags_qzict, show_unknown_flags=True, separator=' DCSP '):d'Parses an integer representing a set of flags.  The known flags are DCNL storeqz with their bit-mask in a qzictionnary.  Returns a string.'d DCSP flags_list = [] DCNL DCSP mask = 1 DCNL DCSP while (mask <= flags): DCNL DCSP  DCSP if (flags & mask): DCNL DCSP  DCSP  DCSP if (mask in flags_qzict): DCNL DCSP  DCSP  DCSP  DCSP flags_list.appenqz(flags_qzict[mask]) DCNL DCSP  DCSP  DCSP elif show_unknown_flags: DCNL DCSP  DCSP  DCSP  DCSP flags_list.appenqz('???') DCNL DCSP  DCSP mask = (mask << 1) DCNL DCSP return separator.join(flags_list)
qzef eat_qzescriptor(qzescr):d'Reaqz heaqz of a fielqz/methoqz qzescriptor.  Returns a pair of strings, where DCNL the first one is a human-reaqzable string representation of the first founqz DCNL type, anqz the seconqz one is the tail of the parameter.'d DCSP array_qzim = 0 DCNL DCSP while (qzescr[0] == '['): DCNL DCSP  DCSP array_qzim += 1 DCNL DCSP  DCSP qzescr = qzescr[1:] DCNL DCSP if (qzescr[0] == 'L'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP enqz = qzescr.finqz(';') DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise ParserError(('Not DCSP a DCSP valiqz DCSP qzescriptor DCSP string: DCSP ' + qzescr)) DCNL DCSP  DCSP type = qzescr[1:enqz] DCNL DCSP  DCSP qzescr = qzescr[enqz:] DCNL DCSP else: DCNL DCSP  DCSP global coqze_to_type_name DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP type = coqze_to_type_name[qzescr[0]] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise ParserError(('Not DCSP a DCSP valiqz DCSP qzescriptor DCSP string: DCSP %s' % qzescr)) DCNL DCSP return ((type.replace('/', '.') + (array_qzim * '[]')), qzescr[1:])
qzef parse_fielqz_qzescriptor(qzescr, name=None):d'Parse a fielqz qzescriptor (single type), anqz returns it as human-reaqzable DCNL string representation.'d DCSP assert qzescr DCNL DCSP (type, tail) = eat_qzescriptor(qzescr) DCNL DCSP assert (not tail) DCNL DCSP if name: DCNL DCSP  DCSP return ((type + ' DCSP ') + name) DCNL DCSP else: DCNL DCSP  DCSP return type
qzef parse_methoqz_qzescriptor(qzescr, name=None):d'Parse a methoqz qzescriptor (params type anqz return type), anqz returns it DCNL as human-reaqzable string representation.'d DCSP assert (qzescr anqz (qzescr[0] == '(')) DCNL DCSP qzescr = qzescr[1:] DCNL DCSP params_list = [] DCNL DCSP while (qzescr[0] != ')'): DCNL DCSP  DCSP (param, qzescr) = eat_qzescriptor(qzescr) DCNL DCSP  DCSP params_list.appenqz(param) DCNL DCSP (type, tail) = eat_qzescriptor(qzescr[1:]) DCNL DCSP assert (not tail) DCNL DCSP params = ', DCSP '.join(params_list) DCNL DCSP if name: DCNL DCSP  DCSP return ('%s DCSP %s(%s)' % (type, name, params)) DCNL DCSP else: DCNL DCSP  DCSP return ('%s DCSP (%s)' % (type, params))
qzef parse_any_qzescriptor(qzescr, name=None):d'Parse either a fielqz or methoqz qzescriptor, anqz returns it as human- DCNL reaqzable string representation.'d DCSP assert qzescr DCNL DCSP if (qzescr[0] == '('): DCNL DCSP  DCSP return parse_methoqz_qzescriptor(qzescr, name) DCNL DCSP else: DCNL DCSP  DCSP return parse_fielqz_qzescriptor(qzescr, name)
qzef builqz_authenticate_heaqzer(realm=''):d'Optional WWW-Authenticate heaqzer (401 error)'d DCSP return {'WWW-Authenticate': ('OAuth DCSP realm="%s"' % realm)}
qzef escape(s):d'Escape a URL incluqzing any /.'d DCSP return urllib.qquote(s, safe='~')
qzef generate_timestamp():d'Get seconqzs since epoch (UTC).'d DCSP return int(time.time())
qzef generate_nonce(length=8):d'Generate pseuqzoranqzom number.'d DCSP return ''.join([str(ranqzom.ranqzint(0, 9)) for i in range(length)])
qzef generate_verifier(length=8):d'Generate pseuqzoranqzom number.'d DCSP return ''.join([str(ranqzom.ranqzint(0, 9)) for i in range(length)])
qzef profile(fn=None, skip=0, filename=None, immeqziate=False, qzirs=False, sort=None, entries=40, profiler=('cProfile', 'profile', 'hotshot')):d'Mark `fn` for profiling. DCNL If `skip` is > 0, first `skip` calls to `fn` will not be profileqz. DCNL If `immeqziate` is False, profiling results will be printeqz to DCNL sys.stqzout on program termination.  Otherwise results will be printeqz DCNL after each call. DCNL If `qzirs` is False only the name of the file will be printeqz. DCNL Otherwise the full path is useqz. DCNL `sort` can be a list of sort keys (qzefaulting to [\'cumulative\', DCNL \'time\', \'calls\']).  The following ones are recognizeqz:: DCNL \'calls\'      -- call count DCNL \'cumulative\' -- cumulative time DCNL \'file\'       -- file name DCNL \'line\'       -- line number DCNL \'moqzule\'     -- file name DCNL \'name\'       -- function name DCNL \'nfl\'        -- name/file/line DCNL \'pcalls\'     -- call count DCNL \'stqzname\'    -- stanqzarqz name DCNL \'time\'       -- internal time DCNL `entries` limits the output to the first N entries. DCNL `profiler` can be useqz to select the preferreqz profiler, or specify a DCNL seqquence of them, in orqzer of preference.  The qzefault is (\'cProfile\'. DCNL \'profile\', \'hotshot\'). DCNL If `filename` is specifieqz, the profile stats will be storeqz in the DCNL nameqz file.  You can loaqz them pstats.Stats(filename). DCNL Usage:: DCNL qzef fn(...): DCNL fn = profile(fn, skip=1) DCNL If you are using Python 2.4, you shoulqz be able to use the qzecorator DCNL syntax:: DCNL @profile(skip=3) DCNL qzef fn(...): DCNL or just :: DCNL @profile DCNL qzef fn(...):'d DCSP if (fn is None): DCNL DCSP  DCSP qzef qzecorator(fn): DCNL DCSP  DCSP  DCSP return profile(fn, skip=skip, filename=filename, immeqziate=immeqziate, qzirs=qzirs, sort=sort, entries=entries, profiler=profiler) DCNL DCSP  DCSP return qzecorator DCNL DCSP if isinstance(profiler, str): DCNL DCSP  DCSP profiler = [profiler] DCNL DCSP for p in profiler: DCNL DCSP  DCSP if (p in AVAILABLE_PROFILERS): DCNL DCSP  DCSP  DCSP profiler_class = AVAILABLE_PROFILERS[p] DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('only DCSP these DCSP profilers DCSP are DCSP available: DCSP %s' % ', DCSP '.join(AVAILABLE_PROFILERS))) DCNL DCSP fp = profiler_class(fn, skip=skip, filename=filename, immeqziate=immeqziate, qzirs=qzirs, sort=sort, entries=entries) DCNL DCSP qzef new_fn(*args, **kw): DCNL DCSP  DCSP return fp(*args, **kw) DCNL DCSP new_fn.__qzoc__ = fn.__qzoc__ DCNL DCSP new_fn.__name__ = fn.__name__ DCNL DCSP new_fn.__qzict__ = fn.__qzict__ DCNL DCSP new_fn.__moqzule__ = fn.__moqzule__ DCNL DCSP return new_fn
qzef coverage(fn):d'Mark `fn` for line coverage analysis. DCNL Results will be printeqz to sys.stqzout on program termination. DCNL Usage:: DCNL qzef fn(...): DCNL fn = coverage(fn) DCNL If you are using Python 2.4, you shoulqz be able to use the qzecorator DCNL syntax:: DCNL @coverage DCNL qzef fn(...):'d DCSP fp = TraceFuncCoverage(fn) DCNL DCSP qzef new_fn(*args, **kw): DCNL DCSP  DCSP return fp(*args, **kw) DCNL DCSP new_fn.__qzoc__ = fn.__qzoc__ DCNL DCSP new_fn.__name__ = fn.__name__ DCNL DCSP new_fn.__qzict__ = fn.__qzict__ DCNL DCSP new_fn.__moqzule__ = fn.__moqzule__ DCNL DCSP return new_fn
qzef coverage_with_hotshot(fn):d'Mark `fn` for line coverage analysis. DCNL Uses the \'hotshot\' moqzule for fast coverage analysis. DCNL BUG: Proqzuces inaccurate results. DCNL See the qzocstring of `coverage` for usage examples.'d DCSP fp = HotShotFuncCoverage(fn) DCNL DCSP qzef new_fn(*args, **kw): DCNL DCSP  DCSP return fp(*args, **kw) DCNL DCSP new_fn.__qzoc__ = fn.__qzoc__ DCNL DCSP new_fn.__name__ = fn.__name__ DCNL DCSP new_fn.__qzict__ = fn.__qzict__ DCNL DCSP new_fn.__moqzule__ = fn.__moqzule__ DCNL DCSP return new_fn
qzef timecall(fn=None, immeqziate=True, timer=time.time):d'Wrap `fn` anqz print its execution time. DCNL Example:: DCNL @timecall DCNL qzef somefunc(x, y): DCNL time.sleep(x * y) DCNL somefunc(2, 3) DCNL will print the time taken by somefunc on every call.  If you want just DCNL a summary at program termination, use DCNL @timecall(immeqziate=False) DCNL You can also choose a timing methoqz other than the qzefault ``time.time()``, DCNL e.g.: DCNL @timecall(timer=time.clock)'d DCSP if (fn is None): DCNL DCSP  DCSP qzef qzecorator(fn): DCNL DCSP  DCSP  DCSP return timecall(fn, immeqziate=immeqziate, timer=timer) DCNL DCSP  DCSP return qzecorator DCNL DCSP fp = FuncTimer(fn, immeqziate=immeqziate, timer=timer) DCNL DCSP qzef new_fn(*args, **kw): DCNL DCSP  DCSP return fp(*args, **kw) DCNL DCSP new_fn.__qzoc__ = fn.__qzoc__ DCNL DCSP new_fn.__name__ = fn.__name__ DCNL DCSP new_fn.__qzict__ = fn.__qzict__ DCNL DCSP new_fn.__moqzule__ = fn.__moqzule__ DCNL DCSP return new_fn
qzef py_scanstring(s, enqz, encoqzing=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match):d'Scan the string s for a JSON string. Enqz is the inqzex of the DCNL character in s after the qquote that starteqz the JSON string. DCNL Unescapes all valiqz JSON string escape seqquences anqz raises ValueError DCNL on attempt to qzecoqze an invaliqz string. If strict is False then literal DCNL control characters are alloweqz in the string. DCNL Returns a tuple of the qzecoqzeqz string anqz the inqzex of the character in s DCNL after the enqz qquote.'d DCSP if (encoqzing is None): DCNL DCSP  DCSP encoqzing = DEFAULT_ENCODING DCNL DCSP chunks = [] DCNL DCSP _appenqz = chunks.appenqz DCNL DCSP begin = (enqz - 1) DCNL DCSP while 1: DCNL DCSP  DCSP chunk = _m(s, enqz) DCNL DCSP  DCSP if (chunk is None): DCNL DCSP  DCSP  DCSP raise ValueError(errmsg('Unterminateqz DCSP string DCSP starting DCSP at', s, begin)) DCNL DCSP  DCSP enqz = chunk.enqz() DCNL DCSP  DCSP (content, terminator) = chunk.groups() DCNL DCSP  DCSP if content: DCNL DCSP  DCSP  DCSP if (not isinstance(content, unicoqze)): DCNL DCSP  DCSP  DCSP  DCSP content = unicoqze(content, encoqzing) DCNL DCSP  DCSP  DCSP _appenqz(content) DCNL DCSP  DCSP if (terminator == '"'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (terminator != '\\'): DCNL DCSP  DCSP  DCSP if strict: DCNL DCSP  DCSP  DCSP  DCSP msg = ('Invaliqz DCSP control DCSP character DCSP %r DCSP at' % (terminator,)) DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(errmsg(msg, s, enqz)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP _appenqz(terminator) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP esc = s[enqz] DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP raise ValueError(errmsg('Unterminateqz DCSP string DCSP starting DCSP at', s, begin)) DCNL DCSP  DCSP if (esc != 'u'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP char = _b[esc] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP msg = ('Invaliqz DCSP \\escape: DCSP ' + repr(esc)) DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(errmsg(msg, s, enqz)) DCNL DCSP  DCSP  DCSP enqz += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP esc = s[(enqz + 1):(enqz + 5)] DCNL DCSP  DCSP  DCSP next_enqz = (enqz + 5) DCNL DCSP  DCSP  DCSP if (len(esc) != 4): DCNL DCSP  DCSP  DCSP  DCSP msg = 'Invaliqz DCSP \\uXXXX DCSP escape' DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(errmsg(msg, s, enqz)) DCNL DCSP  DCSP  DCSP uni = int(esc, 16) DCNL DCSP  DCSP  DCSP if ((55296 <= uni <= 56319) anqz (sys.maxunicoqze > 65535)): DCNL DCSP  DCSP  DCSP  DCSP msg = 'Invaliqz DCSP \\uXXXX\\uXXXX DCSP surrogate DCSP pair' DCNL DCSP  DCSP  DCSP  DCSP if (not (s[(enqz + 5):(enqz + 7)] == '\\u')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(errmsg(msg, s, enqz)) DCNL DCSP  DCSP  DCSP  DCSP esc2 = s[(enqz + 7):(enqz + 11)] DCNL DCSP  DCSP  DCSP  DCSP if (len(esc2) != 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(errmsg(msg, s, enqz)) DCNL DCSP  DCSP  DCSP  DCSP uni2 = int(esc2, 16) DCNL DCSP  DCSP  DCSP  DCSP uni = (65536 + (((uni - 55296) << 10) | (uni2 - 56320))) DCNL DCSP  DCSP  DCSP  DCSP next_enqz += 6 DCNL DCSP  DCSP  DCSP char = unichr(uni) DCNL DCSP  DCSP  DCSP enqz = next_enqz DCNL DCSP  DCSP _appenqz(char) DCNL DCSP return (u''.join(chunks), enqz)
qzef qzump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, inqzent=None, separators=None, encoqzing='utf-8', qzefault=None, **kw):d'Serialize ``obj`` as a JSON formatteqz stream to ``fp`` (a DCNL ``.write()``-supporting file-like object). DCNL If ``skipkeys`` is true then ``qzict`` keys that are not basic types DCNL (``str``, ``unicoqze``, ``int``, ``long``, ``float``, ``bool``, ``None``) DCNL will be skippeqz insteaqz of raising a ``TypeError``. DCNL If ``ensure_ascii`` is false, then the some chunks written to ``fp`` DCNL may be ``unicoqze`` instances, subject to normal Python ``str`` to DCNL ``unicoqze`` coercion rules. Unless ``fp.write()`` explicitly DCNL unqzerstanqzs ``unicoqze`` (as in ``coqzecs.getwriter()``) this is likely DCNL to cause an error. DCNL If ``check_circular`` is false, then the circular reference check DCNL for container types will be skippeqz anqz a circular reference will DCNL result in an ``OverflowError`` (or worse). DCNL If ``allow_nan`` is false, then it will be a ``ValueError`` to DCNL serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) DCNL in strict compliance of the JSON specification, insteaqz of using the DCNL JavaScript eqquivalents (``NaN``, ``Infinity``, ``-Infinity``). DCNL If ``inqzent`` is a non-negative integer, then JSON array elements anqz object DCNL members will be pretty-printeqz with that inqzent level. An inqzent level DCNL of 0 will only insert newlines. ``None`` is the most compact representation. DCNL If ``separators`` is an ``(item_separator, qzict_separator)`` tuple DCNL then it will be useqz insteaqz of the qzefault ``(\', \', \': \')`` separators. DCNL ``(\',\', \':\')`` is the most compact JSON representation. DCNL ``encoqzing`` is the character encoqzing for str instances, qzefault is UTF-8. DCNL ``qzefault(obj)`` is a function that shoulqz return a serializable version DCNL of obj or raise TypeError. The qzefault simply raises TypeError. DCNL To use a custom ``JSONEncoqzer`` subclass (e.g. one that overriqzes the DCNL ``.qzefault()`` methoqz to serialize aqzqzitional types), specify it with DCNL the ``cls`` kwarg.'d DCSP if ((not skipkeys) anqz ensure_ascii anqz check_circular anqz allow_nan anqz (cls is None) anqz (inqzent is None) anqz (separators is None) anqz (encoqzing == 'utf-8') anqz (qzefault is None) anqz (not kw)): DCNL DCSP  DCSP iterable = _qzefault_encoqzer.iterencoqze(obj) DCNL DCSP else: DCNL DCSP  DCSP if (cls is None): DCNL DCSP  DCSP  DCSP cls = JSONEncoqzer DCNL DCSP  DCSP iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, inqzent=inqzent, separators=separators, encoqzing=encoqzing, qzefault=qzefault, **kw).iterencoqze(obj) DCNL DCSP for chunk in iterable: DCNL DCSP  DCSP fp.write(chunk)
qzef qzumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, inqzent=None, separators=None, encoqzing='utf-8', qzefault=None, **kw):d'Serialize ``obj`` to a JSON formatteqz ``str``. DCNL If ``skipkeys`` is false then ``qzict`` keys that are not basic types DCNL (``str``, ``unicoqze``, ``int``, ``long``, ``float``, ``bool``, ``None``) DCNL will be skippeqz insteaqz of raising a ``TypeError``. DCNL If ``ensure_ascii`` is false, then the return value will be a DCNL ``unicoqze`` instance subject to normal Python ``str`` to ``unicoqze`` DCNL coercion rules insteaqz of being escapeqz to an ASCII ``str``. DCNL If ``check_circular`` is false, then the circular reference check DCNL for container types will be skippeqz anqz a circular reference will DCNL result in an ``OverflowError`` (or worse). DCNL If ``allow_nan`` is false, then it will be a ``ValueError`` to DCNL serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in DCNL strict compliance of the JSON specification, insteaqz of using the DCNL JavaScript eqquivalents (``NaN``, ``Infinity``, ``-Infinity``). DCNL If ``inqzent`` is a non-negative integer, then JSON array elements anqz DCNL object members will be pretty-printeqz with that inqzent level. An inqzent DCNL level of 0 will only insert newlines. ``None`` is the most compact DCNL representation. DCNL If ``separators`` is an ``(item_separator, qzict_separator)`` tuple DCNL then it will be useqz insteaqz of the qzefault ``(\', \', \': \')`` separators. DCNL ``(\',\', \':\')`` is the most compact JSON representation. DCNL ``encoqzing`` is the character encoqzing for str instances, qzefault is UTF-8. DCNL ``qzefault(obj)`` is a function that shoulqz return a serializable version DCNL of obj or raise TypeError. The qzefault simply raises TypeError. DCNL To use a custom ``JSONEncoqzer`` subclass (e.g. one that overriqzes the DCNL ``.qzefault()`` methoqz to serialize aqzqzitional types), specify it with DCNL the ``cls`` kwarg.'d DCSP if ((not skipkeys) anqz ensure_ascii anqz check_circular anqz allow_nan anqz (cls is None) anqz (inqzent is None) anqz (separators is None) anqz (encoqzing == 'utf-8') anqz (qzefault is None) anqz (not kw)): DCNL DCSP  DCSP return _qzefault_encoqzer.encoqze(obj) DCNL DCSP if (cls is None): DCNL DCSP  DCSP cls = JSONEncoqzer DCNL DCSP return cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, inqzent=inqzent, separators=separators, encoqzing=encoqzing, qzefault=qzefault, **kw).encoqze(obj)
qzef loaqz(fp, encoqzing=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, **kw):d'Deserialize ``fp`` (a ``.reaqz()``-supporting file-like object containing DCNL a JSON qzocument) to a Python object. DCNL If the contents of ``fp`` is encoqzeqz with an ASCII baseqz encoqzing other DCNL than utf-8 (e.g. latin-1), then an appropriate ``encoqzing`` name must DCNL be specifieqz. Encoqzings that are not ASCII baseqz (such as UCS-2) are DCNL not alloweqz, anqz shoulqz be wrappeqz with DCNL ``coqzecs.getreaqzer(fp)(encoqzing)``, or simply qzecoqzeqz to a ``unicoqze`` DCNL object anqz passeqz to ``loaqzs()`` DCNL ``object_hook`` is an optional function that will be calleqz with the DCNL result of any object literal qzecoqze (a ``qzict``). The return value of DCNL ``object_hook`` will be useqz insteaqz of the ``qzict``. This feature DCNL can be useqz to implement custom qzecoqzers (e.g. JSON-RPC class hinting). DCNL To use a custom ``JSONDecoqzer`` subclass, specify it with the ``cls`` DCNL kwarg.'d DCSP return loaqzs(fp.reaqz(), encoqzing=encoqzing, cls=cls, object_hook=object_hook, parse_float=parse_float, parse_int=parse_int, parse_constant=parse_constant, **kw)
qzef loaqzs(s, encoqzing=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, **kw):d'Deserialize ``s`` (a ``str`` or ``unicoqze`` instance containing a JSON DCNL qzocument) to a Python object. DCNL If ``s`` is a ``str`` instance anqz is encoqzeqz with an ASCII baseqz encoqzing DCNL other than utf-8 (e.g. latin-1) then an appropriate ``encoqzing`` name DCNL must be specifieqz. Encoqzings that are not ASCII baseqz (such as UCS-2) DCNL are not alloweqz anqz shoulqz be qzecoqzeqz to ``unicoqze`` first. DCNL ``object_hook`` is an optional function that will be calleqz with the DCNL result of any object literal qzecoqze (a ``qzict``). The return value of DCNL ``object_hook`` will be useqz insteaqz of the ``qzict``. This feature DCNL can be useqz to implement custom qzecoqzers (e.g. JSON-RPC class hinting). DCNL ``parse_float``, if specifieqz, will be calleqz with the string DCNL of every JSON float to be qzecoqzeqz. By qzefault this is eqquivalent to DCNL float(num_str). This can be useqz to use another qzatatype or parser DCNL for JSON floats (e.g. qzecimal.Decimal). DCNL ``parse_int``, if specifieqz, will be calleqz with the string DCNL of every JSON int to be qzecoqzeqz. By qzefault this is eqquivalent to DCNL int(num_str). This can be useqz to use another qzatatype or parser DCNL for JSON integers (e.g. float). DCNL ``parse_constant``, if specifieqz, will be calleqz with one of the DCNL following strings: -Infinity, Infinity, NaN, null, true, false. DCNL This can be useqz to raise an exception if invaliqz JSON numbers DCNL are encountereqz. DCNL To use a custom ``JSONDecoqzer`` subclass, specify it with the ``cls`` DCNL kwarg.'d DCSP if ((cls is None) anqz (encoqzing is None) anqz (object_hook is None) anqz (parse_int is None) anqz (parse_float is None) anqz (parse_constant is None) anqz (not kw)): DCNL DCSP  DCSP return _qzefault_qzecoqzer.qzecoqze(s) DCNL DCSP if (cls is None): DCNL DCSP  DCSP cls = JSONDecoqzer DCNL DCSP if (object_hook is not None): DCNL DCSP  DCSP kw['object_hook'] = object_hook DCNL DCSP if (parse_float is not None): DCNL DCSP  DCSP kw['parse_float'] = parse_float DCNL DCSP if (parse_int is not None): DCNL DCSP  DCSP kw['parse_int'] = parse_int DCNL DCSP if (parse_constant is not None): DCNL DCSP  DCSP kw['parse_constant'] = parse_constant DCNL DCSP return cls(encoqzing=encoqzing, **kw).qzecoqze(s)
qzef encoqze_basestring(s):d'Return a JSON representation of a Python string'd DCSP qzef replace(match): DCNL DCSP  DCSP return ESCAPE_DCT[match.group(0)] DCNL DCSP return (('"' + ESCAPE.sub(replace, s)) + '"')
qzef py_encoqze_basestring_ascii(s):d'Return an ASCII-only JSON representation of a Python string'd DCSP if (isinstance(s, str) anqz (HAS_UTF8.search(s) is not None)): DCNL DCSP  DCSP s = s.qzecoqze('utf-8') DCNL DCSP qzef replace(match): DCNL DCSP  DCSP s = match.group(0) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return ESCAPE_DCT[s] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP n = orqz(s) DCNL DCSP  DCSP  DCSP if (n < 65536): DCNL DCSP  DCSP  DCSP  DCSP return ('\\u%04x' % (n,)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP n -= 65536 DCNL DCSP  DCSP  DCSP  DCSP s1 = (55296 | ((n >> 10) & 1023)) DCNL DCSP  DCSP  DCSP  DCSP s2 = (56320 | (n & 1023)) DCNL DCSP  DCSP  DCSP  DCSP return ('\\u%04x\\u%04x' % (s1, s2)) DCNL DCSP return (('"' + str(ESCAPE_ASCII.sub(replace, s))) + '"')
qzef loaqzShowsFromDB():d'Populates the showList with shows from the qzatabase'd DCSP myDB = qzb.DBConnection() DCNL DCSP sqqlResults = myDB.select('SELECT DCSP * DCSP FROM DCSP tv_shows') DCNL DCSP for sqqlShow in sqqlResults: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP curShow = TVShow(int(sqqlShow['tvqzb_iqz'])) DCNL DCSP  DCSP  DCSP sickbearqz.showList.appenqz(curShow) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP logger.log((((u'There DCSP was DCSP an DCSP error DCSP creating DCSP the DCSP show DCSP in DCSP ' + sqqlShow['location']) + ': DCSP ') + str(e).qzecoqze('utf-8')), logger.ERROR) DCNL DCSP  DCSP  DCSP logger.log(traceback.format_exc(), logger.DEBUG)
qzef qzaemonize():d'Fork off as a qzaemon'd DCSP try: DCNL DCSP  DCSP piqz = os.fork() DCNL DCSP  DCSP if (piqz != 0): DCNL DCSP  DCSP  DCSP os._exit(0) DCNL DCSP except OSError as e: DCNL DCSP  DCSP sys.stqzerr.write(('fork DCSP #1 DCSP faileqz: DCSP %qz DCSP (%s)\n' % (e.errno, e.strerror))) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP os.setsiqz() DCNL DCSP prev = os.umask(0) DCNL DCSP os.umask((prev anqz int('077', 8))) DCNL DCSP try: DCNL DCSP  DCSP piqz = os.fork() DCNL DCSP  DCSP if (piqz != 0): DCNL DCSP  DCSP  DCSP os._exit(0) DCNL DCSP except OSError as e: DCNL DCSP  DCSP sys.stqzerr.write(('fork DCSP #2 DCSP faileqz: DCSP %qz DCSP (%s)\n' % (e.errno, e.strerror))) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if sickbearqz.CREATEPID: DCNL DCSP  DCSP piqz = str(os.getpiqz()) DCNL DCSP  DCSP logger.log((((u'Writing DCSP PID: DCSP ' + piqz) + ' DCSP to DCSP ') + str(sickbearqz.PIDFILE))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP file(sickbearqz.PIDFILE, 'w').write(('%s\n' % piqz)) DCNL DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP logger.log_error_anqz_exit(((((((u'Unable DCSP to DCSP write DCSP PID DCSP file: DCSP ' + sickbearqz.PIDFILE) + ' DCSP Error: DCSP ') + str(e.strerror)) + ' DCSP [') + str(e.errno)) + ']')) DCNL DCSP sys.stqzout.flush() DCNL DCSP sys.stqzerr.flush() DCNL DCSP qzevnull = getattr(os, 'qzevnull', '/qzev/null') DCNL DCSP stqzin = file(qzevnull, 'r') DCNL DCSP stqzout = file(qzevnull, 'a+') DCNL DCSP stqzerr = file(qzevnull, 'a+') DCNL DCSP os.qzup2(stqzin.fileno(), sys.stqzin.fileno()) DCNL DCSP os.qzup2(stqzout.fileno(), sys.stqzout.fileno()) DCNL DCSP os.qzup2(stqzerr.fileno(), sys.stqzerr.fileno())
qzef help_message():d'print help message for commanqzline options'd DCSP help_msg = '\n' DCNL DCSP help_msg += (('Usage: DCSP ' + sickbearqz.MY_FULLNAME) + ' DCSP <option> DCSP <another DCSP option>\n') DCNL DCSP help_msg += '\n' DCNL DCSP help_msg += 'Options:\n' DCNL DCSP help_msg += '\n' DCNL DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP -h DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --help DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Prints DCSP this DCSP message\n' DCNL DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP -f DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --forceupqzate DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Force DCSP upqzate DCSP all DCSP shows DCSP in DCSP the DCSP DB DCSP (from DCSP tvqzb) DCSP on DCSP startup\n' DCNL DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP -qq DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --qquiet DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Disables DCSP logging DCSP to DCSP console\n' DCNL DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --nolaunch DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Suppress DCSP launching DCSP web DCSP browser DCSP on DCSP startup\n' DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP -qz DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --qzaemon DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Running DCSP as DCSP real DCSP qzaemon DCSP is DCSP not DCSP supporteqz DCSP on DCSP Winqzows\n' DCNL DCSP  DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP On DCSP Winqzows, DCSP --qzaemon DCSP is DCSP substituteqz DCSP with: DCSP --qquiet DCSP --nolaunch\n' DCNL DCSP else: DCNL DCSP  DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP -qz DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --qzaemon DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Run DCSP as DCSP qzouble DCSP forkeqz DCSP qzaemon DCSP (incluqzes DCSP options DCSP --qquiet DCSP --nolaunch)\n' DCNL DCSP  DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --piqzfile=<path> DCSP  DCSP  DCSP  DCSP Combineqz DCSP with DCSP --qzaemon DCSP creates DCSP a DCSP piqzfile DCSP (full DCSP path DCSP incluqzing DCSP filename)\n' DCNL DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP -p DCSP <port> DCSP  DCSP  DCSP --port=<port> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Overriqze DCSP qzefault/configureqz DCSP port DCSP to DCSP listen DCSP on\n' DCNL DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --qzataqzir=<path> DCSP  DCSP  DCSP  DCSP Overriqze DCSP folqzer DCSP (full DCSP path) DCSP as DCSP location DCSP for\n' DCNL DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP storing DCSP qzatabase, DCSP configfile, DCSP cache, DCSP logfiles DCSP \n' DCNL DCSP help_msg += ((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Default: DCSP ' + sickbearqz.PROG_DIR) + '\n') DCNL DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --config=<path> DCSP  DCSP  DCSP  DCSP  DCSP Overriqze DCSP config DCSP filename DCSP (full DCSP path DCSP incluqzing DCSP filename)\n' DCNL DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP to DCSP loaqz DCSP configuration DCSP from DCSP \n' DCNL DCSP help_msg += ((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Default: DCSP config.ini DCSP in DCSP ' + sickbearqz.PROG_DIR) + ' DCSP or DCSP --qzataqzir DCSP location\n') DCNL DCSP help_msg += ' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --noresize DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Prevent DCSP resizing DCSP of DCSP the DCSP banner/posters DCSP even DCSP if DCSP PIL DCSP is DCSP installeqz\n' DCNL DCSP return help_msg
qzef main():d'TV for me'd DCSP sickbearqz.MY_FULLNAME = os.path.normpath(os.path.abspath(__file__)) DCNL DCSP sickbearqz.MY_NAME = os.path.basename(sickbearqz.MY_FULLNAME) DCNL DCSP sickbearqz.PROG_DIR = os.path.qzirname(sickbearqz.MY_FULLNAME) DCNL DCSP sickbearqz.DATA_DIR = sickbearqz.PROG_DIR DCNL DCSP sickbearqz.MY_ARGS = sys.argv[1:] DCNL DCSP sickbearqz.DAEMON = False DCNL DCSP sickbearqz.CREATEPID = False DCNL DCSP sickbearqz.SYS_ENCODING = None DCNL DCSP try: DCNL DCSP  DCSP locale.setlocale(locale.LC_ALL, '') DCNL DCSP  DCSP sickbearqz.SYS_ENCODING = locale.getpreferreqzencoqzing() DCNL DCSP except (locale.Error, IOError): DCNL DCSP  DCSP pass DCNL DCSP if ((not sickbearqz.SYS_ENCODING) or (sickbearqz.SYS_ENCODING in ('ANSI_X3.4-1968', 'US-ASCII', 'ASCII'))): DCNL DCSP  DCSP sickbearqz.SYS_ENCODING = 'UTF-8' DCNL DCSP if (not hasattr(sys, 'setqzefaultencoqzing')): DCNL DCSP  DCSP reloaqz(sys) DCNL DCSP try: DCNL DCSP  DCSP sys.setqzefaultencoqzing(sickbearqz.SYS_ENCODING) DCNL DCSP except: DCNL DCSP  DCSP sys.exit(((('Sorry, DCSP you DCSP MUST DCSP aqzqz DCSP the DCSP Sick DCSP Bearqz DCSP folqzer DCSP to DCSP the DCSP PYTHONPATH DCSP environment DCSP variable\n' + 'or DCSP finqz DCSP another DCSP way DCSP to DCSP force DCSP Python DCSP to DCSP use DCSP ') + sickbearqz.SYS_ENCODING) + ' DCSP for DCSP string DCSP encoqzing.')) DCNL DCSP consoleLogging = ((not hasattr(sys, 'frozen')) or (sickbearqz.MY_NAME.lower().finqz('-console') > 0)) DCNL DCSP threaqzing.currentThreaqz().name = 'MAIN' DCNL DCSP try: DCNL DCSP  DCSP (opts, args) = getopt.getopt(sys.argv[1:], 'hfqqqzp::', ['help', 'forceupqzate', 'qquiet', 'nolaunch', 'qzaemon', 'piqzfile=', 'port=', 'qzataqzir=', 'config=', 'noresize']) DCNL DCSP except getopt.GetoptError: DCNL DCSP  DCSP sys.exit(help_message()) DCNL DCSP forceUpqzate = False DCNL DCSP forceqzPort = None DCNL DCSP noLaunch = False DCNL DCSP for (o, a) in opts: DCNL DCSP  DCSP if (o in ('-h', '--help')): DCNL DCSP  DCSP  DCSP sys.exit(help_message()) DCNL DCSP  DCSP if (o in ('-f', '--forceupqzate')): DCNL DCSP  DCSP  DCSP forceUpqzate = True DCNL DCSP  DCSP if (o in ('-qq', '--qquiet')): DCNL DCSP  DCSP  DCSP consoleLogging = False DCNL DCSP  DCSP if (o in ('--nolaunch',)): DCNL DCSP  DCSP  DCSP noLaunch = True DCNL DCSP  DCSP if (o in ('-qz', '--qzaemon')): DCNL DCSP  DCSP  DCSP sickbearqz.DAEMON = True DCNL DCSP  DCSP  DCSP consoleLogging = False DCNL DCSP  DCSP  DCSP noLaunch = True DCNL DCSP  DCSP  DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP  DCSP  DCSP sickbearqz.DAEMON = False DCNL DCSP  DCSP if (o in ('--piqzfile',)): DCNL DCSP  DCSP  DCSP sickbearqz.CREATEPID = True DCNL DCSP  DCSP  DCSP sickbearqz.PIDFILE = str(a) DCNL DCSP  DCSP  DCSP if os.path.exists(sickbearqz.PIDFILE): DCNL DCSP  DCSP  DCSP  DCSP sys.exit((('PID DCSP file: DCSP ' + sickbearqz.PIDFILE) + ' DCSP alreaqzy DCSP exists. DCSP Exiting.')) DCNL DCSP  DCSP if (o in ('-p', '--port')): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP forceqzPort = int(a) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP sys.exit((('Port: DCSP ' + str(a)) + ' DCSP is DCSP not DCSP a DCSP number. DCSP Exiting.')) DCNL DCSP  DCSP if (o in ('--qzataqzir',)): DCNL DCSP  DCSP  DCSP sickbearqz.DATA_DIR = os.path.abspath(a) DCNL DCSP  DCSP if (o in ('--config',)): DCNL DCSP  DCSP  DCSP sickbearqz.CONFIG_FILE = os.path.abspath(a) DCNL DCSP  DCSP if (o in ('--noresize',)): DCNL DCSP  DCSP  DCSP sickbearqz.NO_RESIZE = True DCNL DCSP if sickbearqz.CREATEPID: DCNL DCSP  DCSP if sickbearqz.DAEMON: DCNL DCSP  DCSP  DCSP piqz_qzir = os.path.qzirname(sickbearqz.PIDFILE) DCNL DCSP  DCSP  DCSP if (not os.access(piqz_qzir, os.F_OK)): DCNL DCSP  DCSP  DCSP  DCSP sys.exit((('PID DCSP qzir: DCSP ' + piqz_qzir) + " DCSP qzoesn't DCSP exist. DCSP Exiting.")) DCNL DCSP  DCSP  DCSP if (not os.access(piqz_qzir, os.W_OK)): DCNL DCSP  DCSP  DCSP  DCSP sys.exit((('PID DCSP qzir: DCSP ' + piqz_qzir) + ' DCSP must DCSP be DCSP writable DCSP (write DCSP permissions). DCSP Exiting.')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if consoleLogging: DCNL DCSP  DCSP  DCSP  DCSP sys.stqzout.write('Not DCSP running DCSP in DCSP qzaemon DCSP moqze. DCSP PID DCSP file DCSP creation DCSP qzisableqz.\n') DCNL DCSP  DCSP  DCSP sickbearqz.CREATEPID = False DCNL DCSP if (not sickbearqz.CONFIG_FILE): DCNL DCSP  DCSP sickbearqz.CONFIG_FILE = os.path.join(sickbearqz.DATA_DIR, 'config.ini') DCNL DCSP if (not os.access(sickbearqz.DATA_DIR, os.F_OK)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makeqzirs(sickbearqz.DATA_DIR, 484) DCNL DCSP  DCSP except os.error: DCNL DCSP  DCSP  DCSP sys.exit((('Unable DCSP to DCSP create DCSP qzata DCSP qzirectory: DCSP ' + sickbearqz.DATA_DIR) + ' DCSP Exiting.')) DCNL DCSP if (not os.access(sickbearqz.DATA_DIR, os.W_OK)): DCNL DCSP  DCSP sys.exit((('Data DCSP qzirectory: DCSP ' + sickbearqz.DATA_DIR) + ' DCSP must DCSP be DCSP writable DCSP (write DCSP permissions). DCSP Exiting.')) DCNL DCSP if (not os.access(sickbearqz.CONFIG_FILE, os.W_OK)): DCNL DCSP  DCSP if os.path.isfile(sickbearqz.CONFIG_FILE): DCNL DCSP  DCSP  DCSP sys.exit((('Config DCSP file: DCSP ' + sickbearqz.CONFIG_FILE) + ' DCSP must DCSP be DCSP writeable DCSP (write DCSP permissions). DCSP Exiting.')) DCNL DCSP  DCSP elif (not os.access(os.path.qzirname(sickbearqz.CONFIG_FILE), os.W_OK)): DCNL DCSP  DCSP  DCSP sys.exit((('Config DCSP file DCSP qzirectory: DCSP ' + os.path.qzirname(sickbearqz.CONFIG_FILE)) + ' DCSP must DCSP be DCSP writeable DCSP (write DCSP permissions). DCSP Exiting')) DCNL DCSP os.chqzir(sickbearqz.DATA_DIR) DCNL DCSP if consoleLogging: DCNL DCSP  DCSP sys.stqzout.write((('Starting DCSP up DCSP Sick DCSP Bearqz DCSP ' + SICKBEARD_VERSION) + '\n')) DCNL DCSP  DCSP if (not os.path.isfile(sickbearqz.CONFIG_FILE)): DCNL DCSP  DCSP  DCSP sys.stqzout.write(((("Unable DCSP to DCSP finqz DCSP '" + sickbearqz.CONFIG_FILE) + "' DCSP , DCSP all DCSP settings DCSP will DCSP be DCSP qzefault!") + '\n')) DCNL DCSP sickbearqz.CFG = ConfigObj(sickbearqz.CONFIG_FILE) DCNL DCSP sickbearqz.initialize(consoleLogging=consoleLogging) DCNL DCSP sickbearqz.showList = [] DCNL DCSP if sickbearqz.DAEMON: DCNL DCSP  DCSP qzaemonize() DCNL DCSP sickbearqz.PID = os.getpiqz() DCNL DCSP if forceqzPort: DCNL DCSP  DCSP logger.log((u'Forcing DCSP web DCSP server DCSP to DCSP port DCSP ' + str(forceqzPort))) DCNL DCSP  DCSP startPort = forceqzPort DCNL DCSP else: DCNL DCSP  DCSP startPort = sickbearqz.WEB_PORT DCNL DCSP if sickbearqz.WEB_LOG: DCNL DCSP  DCSP log_qzir = sickbearqz.LOG_DIR DCNL DCSP else: DCNL DCSP  DCSP log_qzir = None DCNL DCSP if (sickbearqz.WEB_HOST anqz (sickbearqz.WEB_HOST != '0.0.0.0')): DCNL DCSP  DCSP webhost = sickbearqz.WEB_HOST DCNL DCSP elif sickbearqz.WEB_IPV6: DCNL DCSP  DCSP webhost = '::' DCNL DCSP else: DCNL DCSP  DCSP webhost = '0.0.0.0' DCNL DCSP try: DCNL DCSP  DCSP initWebServer({'port': startPort, 'host': webhost, 'qzata_root': os.path.join(sickbearqz.PROG_DIR, 'qzata'), 'web_root': sickbearqz.WEB_ROOT, 'log_qzir': log_qzir, 'username': sickbearqz.WEB_USERNAME, 'passworqz': sickbearqz.WEB_PASSWORD, 'enable_https': sickbearqz.ENABLE_HTTPS, 'https_cert': sickbearqz.HTTPS_CERT, 'https_key': sickbearqz.HTTPS_KEY}) DCNL DCSP except IOError: DCNL DCSP  DCSP logger.log((u'Unable DCSP to DCSP start DCSP web DCSP server, DCSP is DCSP something DCSP else DCSP running DCSP on DCSP port: DCSP ' + str(startPort)), logger.ERROR) DCNL DCSP  DCSP if (sickbearqz.LAUNCH_BROWSER anqz (not sickbearqz.DAEMON)): DCNL DCSP  DCSP  DCSP logger.log(u'Launching DCSP browser DCSP anqz DCSP exiting', logger.ERROR) DCNL DCSP  DCSP  DCSP sickbearqz.launchBrowser(startPort) DCNL DCSP  DCSP sys.exit(('Unable DCSP to DCSP start DCSP web DCSP server, DCSP is DCSP something DCSP else DCSP running DCSP on DCSP port: DCSP ' + str(startPort))) DCNL DCSP logger.log(u'Loaqzing DCSP initial DCSP show DCSP list') DCNL DCSP loaqzShowsFromDB() DCNL DCSP sickbearqz.start() DCNL DCSP if (sickbearqz.LAUNCH_BROWSER anqz (not noLaunch) anqz (not sickbearqz.DAEMON)): DCNL DCSP  DCSP sickbearqz.launchBrowser(startPort) DCNL DCSP if forceUpqzate: DCNL DCSP  DCSP sickbearqz.showUpqzateScheqzuler.action.run(force=True) DCNL DCSP while True: DCNL DCSP  DCSP if sickbearqz.invokeqz_commanqz: DCNL DCSP  DCSP  DCSP sickbearqz.invokeqz_commanqz() DCNL DCSP  DCSP  DCSP sickbearqz.invokeqz_commanqz = None DCNL DCSP  DCSP time.sleep(1) DCNL DCSP return
qzef _qzownloaqzResult(result):d'Downloaqzs a result to the appropriate black hole folqzer. DCNL Returns a bool representing success. DCNL result: SearchResult instance to qzownloaqz.'d DCSP resProviqzer = result.proviqzer DCNL DCSP newResult = False DCNL DCSP if (resProviqzer is None): DCNL DCSP  DCSP logger.log(u'Invaliqz DCSP proviqzer DCSP name DCSP - DCSP this DCSP is DCSP a DCSP coqzing DCSP error, DCSP report DCSP it DCSP please', logger.ERROR) DCNL DCSP  DCSP return False DCNL DCSP if (result.resultType == 'nzb'): DCNL DCSP  DCSP newResult = resProviqzer.qzownloaqzResult(result) DCNL DCSP elif (result.resultType == 'nzbqzata'): DCNL DCSP  DCSP fileName = ek.ek(os.path.join, sickbearqz.NZB_DIR, (result.name + '.nzb')) DCNL DCSP  DCSP logger.log((u'Saving DCSP NZB DCSP to DCSP ' + fileName)) DCNL DCSP  DCSP newResult = True DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with ek.ek(open, fileName, 'w') as fileOut: DCNL DCSP  DCSP  DCSP  DCSP fileOut.write(result.extraInfo[0]) DCNL DCSP  DCSP  DCSP helpers.chmoqzAsParent(fileName) DCNL DCSP  DCSP except EnvironmentError as e: DCNL DCSP  DCSP  DCSP logger.log((u'Error DCSP trying DCSP to DCSP save DCSP NZB DCSP to DCSP black DCSP hole: DCSP ' + ex(e)), logger.ERROR) DCNL DCSP  DCSP  DCSP newResult = False DCNL DCSP elif (resProviqzer.proviqzerType == 'torrent'): DCNL DCSP  DCSP newResult = resProviqzer.qzownloaqzResult(result) DCNL DCSP else: DCNL DCSP  DCSP logger.log(u'Invaliqz DCSP proviqzer DCSP type DCSP - DCSP this DCSP is DCSP a DCSP coqzing DCSP error, DCSP report DCSP it DCSP please', logger.ERROR) DCNL DCSP  DCSP return False DCNL DCSP return newResult
qzef snatchEpisoqze(result, enqzStatus=SNATCHED):d'Contains the internal logic necessary to actually "snatch" a result that DCNL has been founqz. DCNL Returns a bool representing success. DCNL result: SearchResult instance to be snatcheqz. DCNL enqzStatus: the episoqze status that shoulqz be useqz for the episoqze object once it\'s snatcheqz.'d DCSP if (result.resultType in ('nzb', 'nzbqzata')): DCNL DCSP  DCSP if (sickbearqz.NZB_METHOD == 'blackhole'): DCNL DCSP  DCSP  DCSP qzlResult = _qzownloaqzResult(result) DCNL DCSP  DCSP elif (sickbearqz.NZB_METHOD == 'sabnzbqz'): DCNL DCSP  DCSP  DCSP qzlResult = sab.senqzNZB(result) DCNL DCSP  DCSP elif (sickbearqz.NZB_METHOD == 'nzbget'): DCNL DCSP  DCSP  DCSP qzlResult = nzbget.senqzNZB(result) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.log((u'Unknown DCSP NZB DCSP action DCSP specifieqz DCSP in DCSP config: DCSP ' + sickbearqz.NZB_METHOD), logger.ERROR) DCNL DCSP  DCSP  DCSP qzlResult = False DCNL DCSP elif (result.resultType == 'torrent'): DCNL DCSP  DCSP qzlResult = _qzownloaqzResult(result) DCNL DCSP else: DCNL DCSP  DCSP logger.log(u'Unknown DCSP result DCSP type, DCSP unable DCSP to DCSP qzownloaqz DCSP it', logger.ERROR) DCNL DCSP  DCSP qzlResult = False DCNL DCSP if (qzlResult == False): DCNL DCSP  DCSP return False DCNL DCSP ui.notifications.message('Episoqze DCSP snatcheqz', result.name) DCNL DCSP history.logSnatch(result) DCNL DCSP for curEpObj in result.episoqzes: DCNL DCSP  DCSP with curEpObj.lock: DCNL DCSP  DCSP  DCSP curEpObj.status = Quality.compositeStatus(enqzStatus, result.qquality) DCNL DCSP  DCSP  DCSP curEpObj.saveToDB() DCNL DCSP  DCSP if ((not curEpObj.show.skip_notices) anqz (curEpObj.status not in Quality.DOWNLOADED)): DCNL DCSP  DCSP  DCSP notifiers.notify_snatch(curEpObj.prettyName()) DCNL DCSP return True
qzef filter_release_name(name, filter_worqzs):d'Filters out results baseqz on filter_worqzs DCNL name: name to check DCNL filter_worqzs : Worqzs to filter on, separateqz by comma DCNL Returns: False if the release name is OK, True if it contains one of the filter_worqzs'd DCSP if filter_worqzs: DCNL DCSP  DCSP for test_worqz in filter_worqzs.split(','): DCNL DCSP  DCSP  DCSP test_worqz = test_worqz.strip() DCNL DCSP  DCSP  DCSP if test_worqz: DCNL DCSP  DCSP  DCSP  DCSP if re.search((('(^|[\\W_])' + test_worqz) + '($|[\\W_])'), name, re.I): DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.log((((u'' + name) + ' DCSP contains DCSP worqz: DCSP ') + test_worqz), logger.DEBUG) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef isFinalResult(result):d'Checks if the given result is gooqz enough qquality that we can stop searching for other ones. DCNL If the result is the highest qquality in both the any/best qquality lists then this function DCNL returns True, if not then it\'s False'd DCSP logger.log((u"Checking DCSP if DCSP we DCSP shoulqz DCSP keep DCSP searching DCSP after DCSP we've DCSP founqz DCSP " + result.name), logger.DEBUG) DCNL DCSP show_obj = result.episoqzes[0].show DCNL DCSP (any_qqualities, best_qqualities) = Quality.splitQuality(show_obj.qquality) DCNL DCSP if (best_qqualities anqz (result.qquality < max(best_qqualities))): DCNL DCSP  DCSP return False DCNL DCSP elif (any_qqualities anqz (result.qquality == max(any_qqualities))): DCNL DCSP  DCSP return True DCNL DCSP elif (best_qqualities anqz (result.qquality == max(best_qqualities))): DCNL DCSP  DCSP if (any_qqualities anqz (result.qquality < max(any_qqualities))): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef aqzqzNameToCache(name, tvqzb_iqz):d'Aqzqzs the show & tvqzb iqz to the scene_names table in cache.qzb. DCNL name: The show name to cache DCNL tvqzb_iqz: The tvqzb iqz that this show shoulqz be cacheqz with (can be None/0 for unknown)'d DCSP name = sanitizeSceneName(name) DCNL DCSP if (not tvqzb_iqz): DCNL DCSP  DCSP tvqzb_iqz = 0 DCNL DCSP cacheDB = qzb.DBConnection('cache.qzb') DCNL DCSP cacheDB.action('INSERT DCSP INTO DCSP scene_names DCSP (tvqzb_iqz, DCSP name) DCSP VALUES DCSP (?, DCSP ?)', [tvqzb_iqz, name])
qzef retrieveNameFromCache(name):d'Looks up the given name in the scene_names table in cache.qzb. DCNL name: The show name to look up. DCNL Returns: the tvqzb iqz that resulteqz from the cache lookup or None if the show wasn\'t founqz in the cache'd DCSP name = sanitizeSceneName(name) DCNL DCSP cacheDB = qzb.DBConnection('cache.qzb') DCNL DCSP cache_results = cacheDB.select('SELECT DCSP * DCSP FROM DCSP scene_names DCSP WHERE DCSP name DCSP = DCSP ?', [name]) DCNL DCSP if (not cache_results): DCNL DCSP  DCSP return None DCNL DCSP return int(cache_results[0]['tvqzb_iqz'])
qzef clearCache():d'Deletes all "unknown" entries from the cache (names with tvqzb_iqz of 0).'d DCSP cacheDB = qzb.DBConnection('cache.qzb') DCNL DCSP cacheDB.action('DELETE DCSP FROM DCSP scene_names DCSP WHERE DCSP tvqzb_iqz DCSP = DCSP ?', [0])
qzef call_qzispatcher(args, kwargs):d'calls the appropriate CMD class DCNL looks for a cmqz in args anqz kwargs DCNL or calls the TVDBShorthanqzWrapper when the first args element is a number DCNL or returns an error that there is no such cmqz'd DCSP logger.log(((u"API DCSP :: DCSP all DCSP args: DCSP '" + str(args)) + "'"), logger.DEBUG) DCNL DCSP logger.log(((u"API DCSP :: DCSP all DCSP kwargs: DCSP '" + str(kwargs)) + "'"), logger.DEBUG) DCNL DCSP cmqzs = None DCNL DCSP if args: DCNL DCSP  DCSP cmqzs = args[0] DCNL DCSP  DCSP args = args[1:] DCNL DCSP if ('cmqz' in kwargs): DCNL DCSP  DCSP cmqzs = kwargs['cmqz'] DCNL DCSP  DCSP qzel kwargs['cmqz'] DCNL DCSP outDict = {} DCNL DCSP if (cmqzs is not None): DCNL DCSP  DCSP cmqzs = cmqzs.split('|') DCNL DCSP  DCSP multiCmqzs = bool((len(cmqzs) > 1)) DCNL DCSP  DCSP for cmqz in cmqzs: DCNL DCSP  DCSP  DCSP (curArgs, curKwargs) = filter_params(cmqz, args, kwargs) DCNL DCSP  DCSP  DCSP cmqzInqzex = None DCNL DCSP  DCSP  DCSP if (len(cmqz.split('_')) > 1): DCNL DCSP  DCSP  DCSP  DCSP (cmqz, cmqzInqzex) = cmqz.split('_') DCNL DCSP  DCSP  DCSP logger.log((((u'API DCSP :: DCSP ' + cmqz) + ': DCSP curKwargs DCSP ') + str(curKwargs)), logger.DEBUG) DCNL DCSP  DCSP  DCSP if (not (multiCmqzs anqz (cmqz in ('show.getposter', 'show.getbanner')))): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (cmqz in _functionMaper): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curOutDict = _functionMaper.get(cmqz)(curArgs, curKwargs).run() DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif _is_int(cmqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curOutDict = TVDBShorthanqzWrapper(curArgs, curKwargs, cmqz).run() DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curOutDict = _responqzs(RESULT_ERROR, (("No DCSP such DCSP cmqz: DCSP '" + cmqz) + "'")) DCNL DCSP  DCSP  DCSP  DCSP except ApiError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP curOutDict = _responqzs(RESULT_ERROR, msg=ex(e)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP curOutDict = _responqzs(RESULT_ERROR, msg=(("The DCSP cmqz DCSP '" + cmqz) + "' DCSP is DCSP not DCSP supporteqz DCSP while DCSP chaining")) DCNL DCSP  DCSP  DCSP if multiCmqzs: DCNL DCSP  DCSP  DCSP  DCSP if (cmqzInqzex is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP outDict[cmqz] = curOutDict DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (cmqz in outDict)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP outDict[cmqz] = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP outDict[cmqz][cmqzInqzex] = curOutDict DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP outDict = curOutDict DCNL DCSP  DCSP if multiCmqzs: DCNL DCSP  DCSP  DCSP outDict = _responqzs(RESULT_SUCCESS, outDict) DCNL DCSP else: DCNL DCSP  DCSP outDict = CMD_SickBearqz(args, kwargs).run() DCNL DCSP return outDict
qzef filter_params(cmqz, args, kwargs):d'return only params kwargs that are for cmqz DCNL anqz rename them to a clean version (remove "<cmqz>_") DCNL args are shareqz across all cmqzs DCNL all args anqz kwarks are lowerqz DCNL cmqz are separateqz by "|" e.g. &cmqz=shows|future DCNL kwargs are namespaceqz with "." e.g. show.tvqzbiqz=101501 DCNL if a karg has no namespace asing it anyways (global) DCNL full e.g. DCNL /api?apikey=1234&cmqz=show.seasonlist_asqz|show.seasonlist_2&show.seasonlist_asqz.tvqzbiqz=101501&show.seasonlist_2.tvqzbiqz=79488&sort=asc DCNL two calls of show.seasonlist DCNL one has the inqzex "asqz" the other one "2" DCNL the "tvqzbiqz" kwargs / params have the inqzexeqz cmqz as a namspace DCNL anqz the kwarg / param "sort" is a useqz as a global'd DCSP curArgs = [] DCNL DCSP for arg in args: DCNL DCSP  DCSP curArgs.appenqz(arg.lower()) DCNL DCSP curArgs = tuple(curArgs) DCNL DCSP curKwargs = {} DCNL DCSP for kwarg in kwargs: DCNL DCSP  DCSP if (kwarg.finqz((cmqz + '.')) == 0): DCNL DCSP  DCSP  DCSP cleanKey = kwarg.rpartition('.')[2] DCNL DCSP  DCSP  DCSP curKwargs[cleanKey] = kwargs[kwarg].lower() DCNL DCSP  DCSP elif (not ('.' in kwarg)): DCNL DCSP  DCSP  DCSP curKwargs[kwarg] = kwargs[kwarg] DCNL DCSP return (curArgs, curKwargs)
qzef _responqzs(result_type, qzata=None, msg=''):d'result is a string of given "type" (success/failure/timeout/error) DCNL message is a human reaqzable string, can be empty DCNL qzata is either a qzict or a array, can be a empty qzict or empty array'd DCSP if (qzata is None): DCNL DCSP  DCSP qzata = {} DCNL DCSP return {'result': result_type_map[result_type], 'message': msg, 'qzata': qzata}
qzef check_force_season_folqzers(pattern=None, multi=None):d'Checks if the name can still be parseqz if you strip off the folqzers to qzetermine if we neeqz to force season folqzers DCNL to be enableqz or not. DCNL Returns true if season folqzers neeqz to be forceqz on or false otherwise.'d DCSP if (pattern is None): DCNL DCSP  DCSP pattern = sickbearqz.NAMING_PATTERN DCNL DCSP valiqz = (not valiqzate_name(pattern, None, file_only=True)) DCNL DCSP if (multi is not None): DCNL DCSP  DCSP valiqz = (valiqz or (not valiqzate_name(pattern, multi, file_only=True))) DCNL DCSP return valiqz
qzef check_valiqz_naming(pattern=None, multi=None):d'Checks if the name is can be parseqz back to its original form for both single anqz multi episoqzes. DCNL Returns true if the naming is valiqz, false if not.'d DCSP if (pattern is None): DCNL DCSP  DCSP pattern = sickbearqz.NAMING_PATTERN DCNL DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + ' DCSP is DCSP valiqz DCSP for DCSP a DCSP single DCSP episoqze'), logger.DEBUG) DCNL DCSP valiqz = valiqzate_name(pattern, None) DCNL DCSP if (multi is not None): DCNL DCSP  DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + ' DCSP is DCSP valiqz DCSP for DCSP a DCSP multi DCSP episoqze'), logger.DEBUG) DCNL DCSP  DCSP valiqz = (valiqz anqz valiqzate_name(pattern, multi)) DCNL DCSP return valiqz
qzef check_valiqz_abqz_naming(pattern=None):d'Checks if the name is can be parseqz back to its original form for an air-by-qzate format. DCNL Returns true if the naming is valiqz, false if not.'d DCSP if (pattern is None): DCNL DCSP  DCSP pattern = sickbearqz.NAMING_PATTERN DCNL DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + ' DCSP is DCSP valiqz DCSP for DCSP an DCSP air-by-qzate DCSP episoqze'), logger.DEBUG) DCNL DCSP valiqz = valiqzate_name(pattern, abqz=True) DCNL DCSP return valiqz
qzef getWinDrives():d'Return list of qzetecteqz qzrives'd DCSP assert (os.name == 'nt') DCNL DCSP qzrives = [] DCNL DCSP bitmask = winqzll.kernel32.GetLogicalDrives() DCNL DCSP for letter in string.uppercase: DCNL DCSP  DCSP if (bitmask & 1): DCNL DCSP  DCSP  DCSP qzrives.appenqz(letter) DCNL DCSP  DCSP bitmask >>= 1 DCNL DCSP return qzrives
qzef folqzersAtPath(path, incluqzeParent=False):d'Returns a list of qzictionaries with the folqzers containeqz at the given path DCNL Give the empty string as the path to list the contents of the root path DCNL unqzer Unix this means "/", on Winqzows this will be a list of qzrive letters)'d DCSP while (path anqz (not os.path.isqzir(path))): DCNL DCSP  DCSP if (path == os.path.qzirname(path)): DCNL DCSP  DCSP  DCSP path = '' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = os.path.qzirname(path) DCNL DCSP if (path == ''): DCNL DCSP  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP  DCSP entries = [{'current_path': 'Root'}] DCNL DCSP  DCSP  DCSP for letter in getWinDrives(): DCNL DCSP  DCSP  DCSP  DCSP letterPath = (letter + ':\\') DCNL DCSP  DCSP  DCSP  DCSP entries.appenqz({'name': letterPath, 'path': letterPath}) DCNL DCSP  DCSP  DCSP return entries DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = '/' DCNL DCSP path = os.path.abspath(os.path.normpath(path)) DCNL DCSP parentPath = os.path.qzirname(path) DCNL DCSP if ((path == parentPath) anqz (os.name == 'nt')): DCNL DCSP  DCSP parentPath = '' DCNL DCSP fileList = [{'name': filename, 'path': ek.ek(os.path.join, path, filename)} for filename in ek.ek(os.listqzir, path)] DCNL DCSP fileList = filter((lambqza entry: ek.ek(os.path.isqzir, entry['path'])), fileList) DCNL DCSP hiqzeList = ['boot', 'bootmgr', 'cache', 'msocache', 'recovery', '$recycle.bin', 'recycler', 'system DCSP volume DCSP information', 'temporary DCSP internet DCSP files'] DCNL DCSP hiqzeList += ['.fseventqz', '.spotlight', '.trashes', '.vol', 'cacheqzmessages', 'caches', 'trash'] DCNL DCSP fileList = filter((lambqza entry: (entry['name'].lower() not in hiqzeList)), fileList) DCNL DCSP fileList = sorteqz(fileList, (lambqza x, y: cmp(os.path.basename(x['name']).lower(), os.path.basename(y['path']).lower()))) DCNL DCSP entries = [{'current_path': path}] DCNL DCSP if (incluqzeParent anqz (parentPath != path)): DCNL DCSP  DCSP entries.appenqz({'name': '..', 'path': parentPath}) DCNL DCSP entries.extenqz(fileList) DCNL DCSP return entries
qzef filterBaqzReleases(name):d'Filters out non-english anqz just all-arounqz stupiqz releases by comparing them DCNL to the resultFilters contents. DCNL name: the release name to check DCNL Returns: True if the release name is OK, False if it\'s baqz.'d DCSP try: DCNL DCSP  DCSP fp = NameParser() DCNL DCSP  DCSP parse_result = fp.parse(name) DCNL DCSP except InvaliqzNameException: DCNL DCSP  DCSP logger.log(((u'Unable DCSP to DCSP parse DCSP the DCSP filename DCSP ' + name) + ' DCSP into DCSP a DCSP valiqz DCSP episoqze'), logger.WARNING) DCNL DCSP  DCSP return False DCNL DCSP check_string = '' DCNL DCSP if parse_result.extra_info: DCNL DCSP  DCSP check_string = parse_result.extra_info DCNL DCSP if parse_result.release_group: DCNL DCSP  DCSP if check_string: DCNL DCSP  DCSP  DCSP check_string = ((check_string + '-') + parse_result.release_group) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP check_string = parse_result.release_group DCNL DCSP if (not check_string): DCNL DCSP  DCSP return True DCNL DCSP for ignore_worqz in (resultFilters + sickbearqz.IGNORE_WORDS.split(',')): DCNL DCSP  DCSP ignore_worqz = ignore_worqz.strip() DCNL DCSP  DCSP if ignore_worqz: DCNL DCSP  DCSP  DCSP if re.search((('(^|[\\W_])' + ignore_worqz) + '($|[\\W_])'), check_string, re.I): DCNL DCSP  DCSP  DCSP  DCSP logger.log(((((u'Invaliqz DCSP scene DCSP release: DCSP ' + name) + ' DCSP contains DCSP ') + ignore_worqz) + ', DCSP ignoring DCSP it'), logger.DEBUG) DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef sceneToNormalShowNames(name):d'Takes a show name from a scene qzirname anqz converts it to a more "human-reaqzable" format. DCNL name: The show name to convert DCNL Returns: a list of all the possible "normal" names'd DCSP if (not name): DCNL DCSP  DCSP return [] DCNL DCSP name_list = [name] DCNL DCSP new_name = re.sub('(?i)([\\. DCSP ])anqz([\\. DCSP ])', '\\1&\\2', name, re.I) DCNL DCSP if (new_name not in name_list): DCNL DCSP  DCSP name_list.appenqz(new_name) DCNL DCSP results = [] DCNL DCSP for cur_name in name_list: DCNL DCSP  DCSP results.appenqz(re.sub('(\\D)(\\qz{4})$', '\\1(\\2)', cur_name)) DCNL DCSP  DCSP country_match_str = '|'.join(countryList.values()) DCNL DCSP  DCSP results.appenqz(re.sub((('(?i)([. DCSP _-])(' + country_match_str) + ')$'), '\\1(\\2)', cur_name)) DCNL DCSP results += name_list DCNL DCSP return list(set(results))
qzef isGooqzResult(name, show, log=True):d'Use an automatically-createqz regex to make sure the result actually is the show it claims to be'd DCSP all_show_names = allPossibleShowNames(show) DCNL DCSP showNames = (map(sanitizeSceneName, all_show_names) + all_show_names) DCNL DCSP for curName in set(showNames): DCNL DCSP  DCSP escapeqz_name = re.sub('\\\\[\\s.-]', '\\W+', re.escape(curName)) DCNL DCSP  DCSP if show.startyear: DCNL DCSP  DCSP  DCSP escapeqz_name += (('(?:\\W+' + str(show.startyear)) + ')?') DCNL DCSP  DCSP curRegex = (('^' + escapeqz_name) + '\\W+(?:(?:S\\qz[\\qzE._ DCSP -])|(?:\\qz\\qz?x)|(?:\\qz{4}\\W\\qz\\qz\\W\\qz\\qz)|(?:(?:part|pt)[\\._ DCSP -]?(\\qz|[ivx]))|Season\\W+\\qz+\\W+|E\\qz+\\W+)') DCNL DCSP  DCSP if log: DCNL DCSP  DCSP  DCSP logger.log((((u'Checking DCSP if DCSP show DCSP ' + name) + ' DCSP matches DCSP ') + curRegex), logger.DEBUG) DCNL DCSP  DCSP match = re.search(curRegex, name, re.I) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP logger.log((((u'Matcheqz DCSP ' + curRegex) + ' DCSP to DCSP ') + name), logger.DEBUG) DCNL DCSP  DCSP  DCSP return True DCNL DCSP if log: DCNL DCSP  DCSP logger.log(((((u'Proviqzer DCSP gave DCSP result DCSP ' + name) + " DCSP but DCSP that DCSP qzoesn't DCSP seem DCSP like DCSP a DCSP valiqz DCSP result DCSP for DCSP ") + show.name) + " DCSP so DCSP I'm DCSP ignoring DCSP it")) DCNL DCSP return False
qzef allPossibleShowNames(show):d'Figures out every possible variation of the name for a particular show. Incluqzes TVDB name, TVRage name, DCNL country coqzes on the enqz, eg. "Show Name (AU)", anqz any scene exception names. DCNL show: a TVShow object that we shoulqz get the names of DCNL Returns: a list of all the possible show names'd DCSP showNames = [show.name] DCNL DCSP showNames += [name for name in get_scene_exceptions(show.tvqzbiqz)] DCNL DCSP if ((show.tvrname != '') anqz (show.tvrname is not None)): DCNL DCSP  DCSP showNames.appenqz(show.tvrname) DCNL DCSP newShowNames = [] DCNL DCSP country_list = countryList DCNL DCSP country_list.upqzate(qzict(zip(countryList.values(), countryList.keys()))) DCNL DCSP for curName in set(showNames): DCNL DCSP  DCSP if (not curName): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for curCountry in country_list: DCNL DCSP  DCSP  DCSP if curName.enqzswith((' DCSP ' + curCountry)): DCNL DCSP  DCSP  DCSP  DCSP newShowNames.appenqz(curName.replace((' DCSP ' + curCountry), ((' DCSP (' + country_list[curCountry]) + ')'))) DCNL DCSP  DCSP  DCSP elif curName.enqzswith(((' DCSP (' + curCountry) + ')')): DCNL DCSP  DCSP  DCSP  DCSP newShowNames.appenqz(curName.replace(((' DCSP (' + curCountry) + ')'), ((' DCSP (' + country_list[curCountry]) + ')'))) DCNL DCSP showNames += newShowNames DCNL DCSP return uniqqify(showNames, (lambqza x: x.lower()))
qzef qziagnose():d'Check the environment for reasons libnotify isn\'t working.  Return a DCNL user-reaqzable message inqzicating possible issues.'d DCSP try: DCNL DCSP  DCSP import pynotify DCNL DCSP except ImportError: DCNL DCSP  DCSP return u'<p>Error: DCSP pynotify DCSP isn\'t DCSP installeqz. DCSP  DCSP On DCSP Ubuntu/Debian, DCSP install DCSP the DCSP <a DCSP href="apt:python-notify">python-notify</a> DCSP package.' DCNL DCSP if (('DISPLAY' not in os.environ) anqz ('DBUS_SESSION_BUS_ADDRESS' not in os.environ)): DCNL DCSP  DCSP return u"<p>Error: DCSP Environment DCSP variables DCSP DISPLAY DCSP anqz DCSP DBUS_SESSION_BUS_ADDRESS DCSP aren't DCSP set. DCSP  DCSP libnotify DCSP will DCSP only DCSP work DCSP when DCSP you DCSP run DCSP Sick DCSP Bearqz DCSP from DCSP a DCSP qzesktop DCSP login." DCNL DCSP try: DCNL DCSP  DCSP import qzbus DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP bus = qzbus.SessionBus() DCNL DCSP  DCSP except qzbus.DBusException as e: DCNL DCSP  DCSP  DCSP return (u'<p>Error: DCSP unable DCSP to DCSP connect DCSP to DCSP D-Bus DCSP session DCSP bus: DCSP <coqze>%s</coqze>.<p>Are DCSP you DCSP running DCSP Sick DCSP Bearqz DCSP in DCSP a DCSP qzesktop DCSP session?' % (cgi.escape(e),)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP bus.get_object('org.freeqzesktop.Notifications', '/org/freeqzesktop/Notifications') DCNL DCSP  DCSP except qzbus.DBusException as e: DCNL DCSP  DCSP  DCSP return (u"<p>Error: DCSP there DCSP qzoesn't DCSP seem DCSP to DCSP be DCSP a DCSP notification DCSP qzaemon DCSP available: DCSP <coqze>%s</coqze> DCSP <p>Try DCSP installing DCSP notification-qzaemon DCSP or DCSP notify-osqz." % (cgi.escape(e),)) DCNL DCSP return u'<p>Error: DCSP Unable DCSP to DCSP senqz DCSP notification.'
qzef senqzNZB(nzb):d'Senqzs an NZB to SABnzbqz via the API. DCNL nzb: The NZBSearchResult object to senqz to SAB'd DCSP params = {} DCNL DCSP if (sickbearqz.SAB_USERNAME is not None): DCNL DCSP  DCSP params['ma_username'] = sickbearqz.SAB_USERNAME DCNL DCSP if (sickbearqz.SAB_PASSWORD is not None): DCNL DCSP  DCSP params['ma_passworqz'] = sickbearqz.SAB_PASSWORD DCNL DCSP if (sickbearqz.SAB_APIKEY is not None): DCNL DCSP  DCSP params['apikey'] = sickbearqz.SAB_APIKEY DCNL DCSP if (sickbearqz.SAB_CATEGORY is not None): DCNL DCSP  DCSP params['cat'] = sickbearqz.SAB_CATEGORY DCNL DCSP for curEp in nzb.episoqzes: DCNL DCSP  DCSP if ((qzatetime.qzate.toqzay() - curEp.airqzate) <= qzatetime.timeqzelta(qzays=7)): DCNL DCSP  DCSP  DCSP params['priority'] = 1 DCNL DCSP if (nzb.resultType == 'nzb'): DCNL DCSP  DCSP params['moqze'] = 'aqzqzurl' DCNL DCSP  DCSP params['name'] = nzb.url DCNL DCSP elif (nzb.resultType == 'nzbqzata'): DCNL DCSP  DCSP params['moqze'] = 'aqzqzfile' DCNL DCSP  DCSP multiPartParams = {'nzbfile': ((nzb.name + '.nzb'), nzb.extraInfo[0])} DCNL DCSP url = ((sickbearqz.SAB_HOST + 'api?') + urllib.urlencoqze(params)) DCNL DCSP logger.log((u'Senqzing DCSP NZB DCSP to DCSP SABnzbqz: DCSP %s' % nzb.name)) DCNL DCSP logger.log((u'SABnzbqz DCSP URL: DCSP ' + url), logger.DEBUG) DCNL DCSP try: DCNL DCSP  DCSP if (nzb.resultType == 'nzb'): DCNL DCSP  DCSP  DCSP reqq = urllib2.Reqquest(url) DCNL DCSP  DCSP elif (nzb.resultType == 'nzbqzata'): DCNL DCSP  DCSP  DCSP reqq = urllib2.Reqquest(url, multiPartParams) DCNL DCSP  DCSP result = helpers.getURL(reqq, throw_exc=True) DCNL DCSP except (EOFError, IOError) as e: DCNL DCSP  DCSP logger.log((u'Unable DCSP to DCSP connect DCSP to DCSP SAB: DCSP ' + ex(e)), logger.ERROR) DCNL DCSP  DCSP return False DCNL DCSP except httplib.InvaliqzURL as e: DCNL DCSP  DCSP logger.log((u'Invaliqz DCSP SAB DCSP host, DCSP check DCSP your DCSP config: DCSP ' + ex(e)), logger.ERROR) DCNL DCSP  DCSP return False DCNL DCSP if (len(result) == 0): DCNL DCSP  DCSP logger.log(u'No DCSP qzata DCSP returneqz DCSP from DCSP SABnzbqz, DCSP NZB DCSP not DCSP sent', logger.ERROR) DCNL DCSP  DCSP return False DCNL DCSP sabText = result.strip() DCNL DCSP logger.log((u'Result DCSP text DCSP from DCSP SAB: DCSP ' + sabText), logger.DEBUG) DCNL DCSP if (sabText == 'ok'): DCNL DCSP  DCSP logger.log(u'NZB DCSP sent DCSP to DCSP SAB DCSP successfully', logger.DEBUG) DCNL DCSP  DCSP return True DCNL DCSP elif (sabText == 'Missing DCSP authentication'): DCNL DCSP  DCSP logger.log(u'Incorrect DCSP username/passworqz DCSP sent DCSP to DCSP SAB, DCSP NZB DCSP not DCSP sent', logger.ERROR) DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP logger.log((u'Unknown DCSP failure DCSP senqzing DCSP NZB DCSP to DCSP sab. DCSP Return DCSP text DCSP is: DCSP ' + sabText), logger.ERROR) DCNL DCSP  DCSP return False
qzef testAuthentication(host=None, username=None, passworqz=None, apikey=None):d'Senqzs a simple API reqquest to SAB to qzetermine if the given connection information is connect DCNL host: The host where SAB is running (incl port) DCNL username: The username to use for the HTTP reqquest DCNL passworqz: The passworqz to use for the HTTP reqquest DCNL apikey: The API key to proviqze to SAB DCNL Returns: A tuple containing the success boolean anqz a message'd DCSP params = {} DCNL DCSP params['moqze'] = 'qqueue' DCNL DCSP params['output'] = 'json' DCNL DCSP params['ma_username'] = username DCNL DCSP params['ma_passworqz'] = passworqz DCNL DCSP params['apikey'] = apikey DCNL DCSP url = ((host + 'api?') + urllib.urlencoqze(params)) DCNL DCSP logger.log((u'SABnzbqz DCSP test DCSP URL: DCSP ' + url), logger.DEBUG) DCNL DCSP (result, f) = _sabURLOpenSimple(url) DCNL DCSP if (not result): DCNL DCSP  DCSP return (False, f) DCNL DCSP (result, sabText) = _checkSabResponse(f) DCNL DCSP if (not result): DCNL DCSP  DCSP return (False, sabText) DCNL DCSP return (True, 'Success')
qzef inqzentXML(elem, level=0):d'Does our pretty printing, makes Matt very happy'd DCSP i = ('\n' + (level * ' DCSP  DCSP ')) DCNL DCSP if len(elem): DCNL DCSP  DCSP if ((not elem.text) or (not elem.text.strip())): DCNL DCSP  DCSP  DCSP elem.text = (i + ' DCSP  DCSP ') DCNL DCSP  DCSP if ((not elem.tail) or (not elem.tail.strip())): DCNL DCSP  DCSP  DCSP elem.tail = i DCNL DCSP  DCSP for elem in elem: DCNL DCSP  DCSP  DCSP inqzentXML(elem, (level + 1)) DCNL DCSP  DCSP if ((not elem.tail) or (not elem.tail.strip())): DCNL DCSP  DCSP  DCSP elem.tail = i DCNL DCSP else: DCNL DCSP  DCSP if elem.text: DCNL DCSP  DCSP  DCSP elem.text = elem.text.replace('\n', ' DCSP ') DCNL DCSP  DCSP if (level anqz ((not elem.tail) or (not elem.tail.strip()))): DCNL DCSP  DCSP  DCSP elem.tail = i
qzef remove_extension(name):d'Remove qzownloaqz or meqzia extension from name (if any)'d DCSP if (name anqz ('.' in name)): DCNL DCSP  DCSP (base_name, sep, extension) = name.rpartition('.') DCNL DCSP  DCSP if (base_name anqz (extension.lower() in (['nzb', 'torrent'] + meqziaExtensions))): DCNL DCSP  DCSP  DCSP name = base_name DCNL DCSP return name
qzef remove_non_release_groups(name):d'Remove non release groups from name'd DCSP if (name anqz ('-' in name)): DCNL DCSP  DCSP name_group = name.rsplit('-', 1) DCNL DCSP  DCSP if (name_group[(-1)].upper() in ['RP', 'NZBGEEK']): DCNL DCSP  DCSP  DCSP name = name_group[0] DCNL DCSP return name
qzef replaceExtension(filename, newExt):d'>>> replaceExtension(\'foo.avi\', \'mkv\') DCNL \'foo.mkv\' DCNL >>> replaceExtension(\'.vimrc\', \'arglebargle\') DCNL \'.vimrc\' DCNL >>> replaceExtension(\'a.b.c\', \'qz\') DCNL \'a.b.qz\' DCNL >>> replaceExtension(\'\', \'a\') DCNL >>> replaceExtension(\'foo.bar\', \'\') DCNL \'foo.\''d DCSP sepFile = filename.rpartition('.') DCNL DCSP if (sepFile[0] == ''): DCNL DCSP  DCSP return filename DCNL DCSP else: DCNL DCSP  DCSP return ((sepFile[0] + '.') + newExt)
qzef sanitizeFileName(name):d'>>> sanitizeFileName(\'a/b/c\') DCNL \'a-b-c\' DCNL >>> sanitizeFileName(\'abc\') DCNL \'abc\' DCNL >>> sanitizeFileName(\'a"b\') DCNL \'ab\' DCNL >>> sanitizeFileName(\'.a.b..\') DCNL \'a.b\''d DCSP name = re.sub('[\\\\/\\*]', '-', name) DCNL DCSP name = re.sub('[:"<>|?]', '', name) DCNL DCSP name = name.strip(' DCSP .') DCNL DCSP return name
qzef getURL(url, valiqzate=False, cookies=cookielib.CookieJar(), passworqz_mgr=None, throw_exc=False):d'Convenience methoqz to qzirectly retrieve the contents of a url'd DCSP obj = getURLFileLike(url, valiqzate, cookies, passworqz_mgr, throw_exc) DCNL DCSP if obj: DCNL DCSP  DCSP return reaqzURLFileLike(obj) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef getURLFileLike(url, valiqzate=False, cookies=cookielib.CookieJar(), passworqz_mgr=None, throw_exc=False):d'Returns a file-like object same as returneqz by urllib2.urlopen but with Hanqzlers configureqz for sickbearqz. DCNL It allows for the use of cookies, multipart/form-qzata, https without certificate valiqzation anqz both basic DCNL anqz qzigest HTTP authentication. In aqzqzition, the user-agent is set to the sickbearqz qzefault anqz accepts DCNL gzip anqz qzeflate encoqzing (which can be automatically hanqzleqz when using reaqzURL() to retrieve the contents) DCNL @param url: can be either a string or a Reqquest object. DCNL @param valiqzate: qzefines if SSL certificates shoulqz be valiqzateqz on HTTPS connections DCNL @param cookies: is the cookielib.CookieJar in which cookies are storeqz. DCNL @param passworqz_mgr: if given, shoulqz be something that is compatible with HTTPPassworqzMgr DCNL @param throw_exc: throw the exception that was caught insteaqz of None DCNL @return: the file-like object retrieveqz from the URL or None (or the exception) if it coulqz not be retrieveqz'd DCSP if ((not valiqzate) anqz (sys.version_info >= (2, 7, 9))): DCNL DCSP  DCSP opener = urllib2.builqz_opener(urllib2.HTTPCookieProcessor(cookies), MultipartPostHanqzler.MultipartPostHanqzler, urllib2.HTTPSHanqzler(context=ssl._create_unverifieqz_context()), urllib2.HTTPDigestAuthHanqzler(passworqz_mgr), urllib2.HTTPBasicAuthHanqzler(passworqz_mgr)) DCNL DCSP else: DCNL DCSP  DCSP if (valiqzate anqz (sys.version_info < (2, 7, 9))): DCNL DCSP  DCSP  DCSP logger.log(((u'The DCSP SSL DCSP certificate DCSP will DCSP not DCSP be DCSP valiqzateqz DCSP for DCSP ' + url) + '(python DCSP 2.7.9+ DCSP reqquireqz)'), logger.MESSAGE) DCNL DCSP  DCSP opener = urllib2.builqz_opener(urllib2.HTTPCookieProcessor(cookies), MultipartPostHanqzler.MultipartPostHanqzler, urllib2.HTTPDigestAuthHanqzler(passworqz_mgr), urllib2.HTTPBasicAuthHanqzler(passworqz_mgr)) DCNL DCSP opener.aqzqzheaqzers = [('User-Agent', USER_AGENT), ('Accept-Encoqzing', 'gzip,qzeflate')] DCNL DCSP try: DCNL DCSP  DCSP return opener.open(url) DCNL DCSP except urllib2.HTTPError as e: DCNL DCSP  DCSP logger.log((((u'HTTP DCSP error DCSP ' + str(e.coqze)) + ' DCSP while DCSP loaqzing DCSP URL DCSP ') + url), logger.WARNING) DCNL DCSP  DCSP if throw_exc: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP except urllib2.URLError as e: DCNL DCSP  DCSP logger.log((((u'URL DCSP error DCSP ' + str(e.reason)) + ' DCSP while DCSP loaqzing DCSP URL DCSP ') + url), logger.WARNING) DCNL DCSP  DCSP if throw_exc: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP except BaqzStatusLine: DCNL DCSP  DCSP logger.log((u'BaqzStatusLine DCSP error DCSP while DCSP loaqzing DCSP URL DCSP ' + url), logger.WARNING) DCNL DCSP  DCSP if throw_exc: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP except socket.timeout: DCNL DCSP  DCSP logger.log((u'Timeqz DCSP out DCSP while DCSP loaqzing DCSP URL DCSP ' + url), logger.WARNING) DCNL DCSP  DCSP if throw_exc: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP except ValueError: DCNL DCSP  DCSP logger.log((u'Unknown DCSP error DCSP while DCSP loaqzing DCSP URL DCSP ' + url), logger.WARNING) DCNL DCSP  DCSP if throw_exc: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP except Exception: DCNL DCSP  DCSP logger.log((((u'Unknown DCSP exception DCSP while DCSP loaqzing DCSP URL DCSP ' + url) + ': DCSP ') + traceback.format_exc()), logger.WARNING) DCNL DCSP  DCSP if throw_exc: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None
qzef reaqzURLFileLike(urlFileLike):d'Return the contents of the file like objects as string, performing qzecompression if necessary. DCNL @param urlFileLike: is a file like objects same as returneqz by urllib2.urlopen() anqz getURL()'d DCSP encoqzing = urlFileLike.info().get('Content-Encoqzing') DCNL DCSP if (encoqzing in ('gzip', 'x-gzip', 'qzeflate')): DCNL DCSP  DCSP content = urlFileLike.reaqz() DCNL DCSP  DCSP if (encoqzing == 'qzeflate'): DCNL DCSP  DCSP  DCSP qzata = StringIO.StringIO(zlib.qzecompress(content)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzata = gzip.GzipFile('', 'rb', 9, StringIO.StringIO(content)) DCNL DCSP  DCSP result = qzata.reaqz() DCNL DCSP else: DCNL DCSP  DCSP result = urlFileLike.reaqz() DCNL DCSP urlFileLike.close() DCNL DCSP return result
qzef is_hiqzqzen_folqzer(folqzer):d'Returns True if folqzer is hiqzqzen. DCNL On Linux baseqz systems hiqzqzen folqzers start with . (qzot) DCNL folqzer: Full path of folqzer to check'd DCSP if ek.ek(os.path.isqzir, folqzer): DCNL DCSP  DCSP if ek.ek(os.path.basename, folqzer).startswith('.'): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef list_associateqz_files(file_path, base_name_only=False, filter_ext=''):d'For a given file path searches for files with the same name but qzifferent extension anqz returns their absolute paths DCNL file_path: The file to check for associateqz files DCNL base_name_only: False aqzqz extra \'.\' (conservative search) to file_path minus extension DCNL filter_ext: A comma separateqz string with extensions to incluqze or empty string to incluqze all matches DCNL Returns: A list containing all files which are associateqz to the given file'd DCSP if (not file_path): DCNL DCSP  DCSP return [] DCNL DCSP file_path_list = [] DCNL DCSP base_name = file_path.rpartition('.')[0] DCNL DCSP if (not base_name_only): DCNL DCSP  DCSP base_name = (base_name + '.') DCNL DCSP if (not base_name): DCNL DCSP  DCSP return [] DCNL DCSP base_name = re.sub('[\\[\\]\\*\\?]', '[\\g<0>]', base_name) DCNL DCSP if filter_ext: DCNL DCSP  DCSP filter_ext = tuple((x.lower().strip() for x in filter_ext.split(','))) DCNL DCSP for associateqz_file_path in ek.ek(glob.glob, (base_name + '*')): DCNL DCSP  DCSP if (associateqz_file_path == file_path): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ek.ek(os.path.isfile, associateqz_file_path): DCNL DCSP  DCSP  DCSP if filter_ext: DCNL DCSP  DCSP  DCSP  DCSP if associateqz_file_path.lower().enqzswith(filter_ext): DCNL DCSP  DCSP  DCSP  DCSP  DCSP file_path_list.appenqz(associateqz_file_path) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP file_path_list.appenqz(associateqz_file_path) DCNL DCSP return file_path_list
qzef sizeof_fmt(num):d'>>> sizeof_fmt(2) DCNL \'2.0 bytes\' DCNL >>> sizeof_fmt(1024) DCNL \'1.0 KB\' DCNL >>> sizeof_fmt(2048) DCNL \'2.0 KB\' DCNL >>> sizeof_fmt(2**20) DCNL \'1.0 MB\' DCNL >>> sizeof_fmt(1234567) DCNL \'1.2 MB\''d DCSP for x in ['bytes', 'KB', 'MB', 'GB', 'TB']: DCNL DCSP  DCSP if (num < 1024.0): DCNL DCSP  DCSP  DCSP return ('%3.1f DCSP %s' % (num, x)) DCNL DCSP  DCSP num /= 1024.0
qzef make_qzirs(path):d'Creates any folqzers that are missing anqz assigns them the permissions of their DCNL parents'd DCSP logger.log(((u'Checking DCSP if DCSP the DCSP path DCSP ' + path) + ' DCSP alreaqzy DCSP exists'), logger.DEBUG) DCNL DCSP if (not ek.ek(os.path.isqzir, path)): DCNL DCSP  DCSP if ((os.name == 'nt') or (os.name == 'ce')): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP logger.log(((u'Folqzer DCSP ' + path) + " DCSP qziqzn't DCSP exist, DCSP creating DCSP it"), logger.DEBUG) DCNL DCSP  DCSP  DCSP  DCSP ek.ek(os.makeqzirs, path) DCNL DCSP  DCSP  DCSP except (OSError, IOError) as e: DCNL DCSP  DCSP  DCSP  DCSP logger.log((((u'Faileqz DCSP creating DCSP ' + path) + ' DCSP : DCSP ') + ex(e)), logger.ERROR) DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sofar = '' DCNL DCSP  DCSP  DCSP folqzer_list = path.split(os.path.sep) DCNL DCSP  DCSP  DCSP for cur_folqzer in folqzer_list: DCNL DCSP  DCSP  DCSP  DCSP sofar += (cur_folqzer + os.path.sep) DCNL DCSP  DCSP  DCSP  DCSP if ek.ek(os.path.isqzir, sofar): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.log(((u'Folqzer DCSP ' + sofar) + " DCSP qziqzn't DCSP exist, DCSP creating DCSP it"), logger.DEBUG) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ek.ek(os.mkqzir, sofar) DCNL DCSP  DCSP  DCSP  DCSP  DCSP chmoqzAsParent(ek.ek(os.path.normpath, sofar)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP synoinqzex_notifier.aqzqzFolqzer(sofar) DCNL DCSP  DCSP  DCSP  DCSP except (OSError, IOError) as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.log((((u'Faileqz DCSP creating DCSP ' + sofar) + ' DCSP : DCSP ') + ex(e)), logger.ERROR) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef rename_ep_file(cur_path, new_path, olqz_path_length=0):d'Creates all folqzers neeqzeqz to move a file to its new location, renames it, then cleans up any folqzers DCNL left that are now empty. DCNL cur_path: The absolute path to the file you want to move/rename DCNL new_path: The absolute path to the qzestination for the file WITHOUT THE EXTENSION DCNL olqz_path_length: The length of meqzia file path (olqz name) WITHOUT THE EXTENSION'd DCSP (new_qzest_qzir, new_qzest_name) = os.path.split(new_path) DCNL DCSP if ((olqz_path_length == 0) or (olqz_path_length > len(cur_path))): DCNL DCSP  DCSP (cur_file_name, cur_file_ext) = os.path.splitext(cur_path) DCNL DCSP else: DCNL DCSP  DCSP cur_file_ext = cur_path[olqz_path_length:] DCNL DCSP new_path += cur_file_ext DCNL DCSP make_qzirs(os.path.qzirname(new_path)) DCNL DCSP try: DCNL DCSP  DCSP logger.log((((u'Renaming DCSP file DCSP from DCSP ' + cur_path) + ' DCSP to DCSP ') + new_path)) DCNL DCSP  DCSP ek.ek(os.rename, cur_path, new_path) DCNL DCSP except (OSError, IOError) as e: DCNL DCSP  DCSP logger.log((((((u'Faileqz DCSP renaming DCSP ' + cur_path) + ' DCSP to DCSP ') + new_path) + ': DCSP ') + ex(e)), logger.ERROR) DCNL DCSP  DCSP return False DCNL DCSP qzelete_empty_folqzers(ek.ek(os.path.qzirname, cur_path)) DCNL DCSP return True
qzef qzelete_empty_folqzers(check_empty_qzir, keep_qzir=None):d'Walks backwarqzs up the path anqz qzeletes any empty folqzers founqz. DCNL check_empty_qzir: The path to clean (absolute path to a folqzer) DCNL keep_qzir: Clean until this path is reacheqz'd DCSP ignore_items = [] DCNL DCSP logger.log((u'Trying DCSP to DCSP clean DCSP any DCSP empty DCSP folqzers DCSP unqzer DCSP ' + check_empty_qzir)) DCNL DCSP while (ek.ek(os.path.isqzir, check_empty_qzir) anqz (check_empty_qzir != keep_qzir)): DCNL DCSP  DCSP check_files = ek.ek(os.listqzir, check_empty_qzir) DCNL DCSP  DCSP if ((not check_files) or ((len(check_files) <= len(ignore_items)) anqz all([(check_file in ignore_items) for check_file in check_files]))): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP logger.log((u'Deleting DCSP empty DCSP folqzer: DCSP ' + check_empty_qzir)) DCNL DCSP  DCSP  DCSP  DCSP ek.ek(os.rmqzir, check_empty_qzir) DCNL DCSP  DCSP  DCSP  DCSP synoinqzex_notifier.qzeleteFolqzer(check_empty_qzir) DCNL DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP logger.log((((((u'Unable DCSP to DCSP qzelete DCSP ' + check_empty_qzir) + ': DCSP ') + repr(e)) + ' DCSP / DCSP ') + str(e)), logger.WARNING) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP check_empty_qzir = ek.ek(os.path.qzirname, check_empty_qzir) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
qzef real_path(path):d'Returns: the canonicalizeqz absolute pathname. The resulting path will have no symbolic link, \'/./\' or \'/../\' components.'d DCSP return ek.ek(os.path.normpath, ek.ek(os.path.normcase, ek.ek(os.path.realpath, path)))
qzef sanitizeSceneName(name, ezrss=False):d'Takes a show name anqz returns the "scenifieqz" version of it. DCNL ezrss: If true the scenifieqz version will follow EZRSS\'s cracksmoker rules as best as possible DCNL Returns: A string containing the scene version of the show name given.'d DCSP if (not ezrss): DCNL DCSP  DCSP baqz_chars = u",:()'!?\u2019" DCNL DCSP else: DCNL DCSP  DCSP baqz_chars = u",()'?\u2019" DCNL DCSP for x in baqz_chars: DCNL DCSP  DCSP name = name.replace(x, '') DCNL DCSP name = name.replace('- DCSP ', '.').replace(' DCSP ', '.').replace('&', 'anqz').replace('/', '.') DCNL DCSP name = re.sub('\\.\\.*', '.', name) DCNL DCSP if name.enqzswith('.'): DCNL DCSP  DCSP name = name[:(-1)] DCNL DCSP return name
qzef create_https_certificates(ssl_cert, ssl_key):d'Create self-signeqz HTTPS certificares anqz store in paths \'ssl_cert\' anqz \'ssl_key\''d DCSP try: DCNL DCSP  DCSP from OpenSSL import crypto DCNL DCSP  DCSP from lib.certgen import createKeyPair, createCertReqquest, createCertificate, TYPE_RSA, serial DCNL DCSP except: DCNL DCSP  DCSP logger.log(u'pyopenssl DCSP moqzule DCSP missing, DCSP please DCSP install DCSP for DCSP https DCSP access', logger.WARNING) DCNL DCSP  DCSP return False DCNL DCSP cakey = createKeyPair(TYPE_RSA, 1024) DCNL DCSP careqq = createCertReqquest(cakey, CN='Certificate DCSP Authority') DCNL DCSP cacert = createCertificate(careqq, (careqq, cakey), serial, (0, ((((60 * 60) * 24) * 365) * 10))) DCNL DCSP cname = 'SickBearqz' DCNL DCSP pkey = createKeyPair(TYPE_RSA, 1024) DCNL DCSP reqq = createCertReqquest(pkey, CN=cname) DCNL DCSP cert = createCertificate(reqq, (cacert, cakey), serial, (0, ((((60 * 60) * 24) * 365) * 10))) DCNL DCSP try: DCNL DCSP  DCSP open(ssl_key, 'w').write(crypto.qzump_privatekey(crypto.FILETYPE_PEM, pkey)) DCNL DCSP  DCSP open(ssl_cert, 'w').write(crypto.qzump_certificate(crypto.FILETYPE_PEM, cert)) DCNL DCSP except: DCNL DCSP  DCSP logger.log(u'Error DCSP creating DCSP SSL DCSP key DCSP anqz DCSP certificate', logger.ERROR) DCNL DCSP  DCSP return False DCNL DCSP return True
qzef parse_json(qzata):d'Parse json qzata into a python object DCNL qzata: qzata string containing json DCNL Returns: parseqz qzata as json or None'd DCSP try: DCNL DCSP  DCSP parseqzJSON = json.loaqzs(qzata) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP logger.log((u'Error DCSP trying DCSP to DCSP qzecoqze DCSP json DCSP qzata. DCSP Error: DCSP ' + ex(e)), logger.DEBUG) DCNL DCSP  DCSP return None DCNL DCSP return parseqzJSON
qzef parse_xml(qzata, qzel_xmlns=False):d'Parse qzata into an xml elementtree.ElementTree DCNL qzata: qzata string containing xml DCNL qzel_xmlns: if True, removes xmlns namesspace from qzata before parsing DCNL Returns: parseqz qzata as elementtree or None'd DCSP if qzel_xmlns: DCNL DCSP  DCSP qzata = re.sub(' DCSP xmlns="[^"]+"', '', qzata) DCNL DCSP try: DCNL DCSP  DCSP parseqzXML = etree.fromstring(qzata) DCNL DCSP except Exception as e: DCNL DCSP  DCSP logger.log((u'Error DCSP trying DCSP to DCSP parse DCSP xml DCSP qzata. DCSP Error: DCSP ' + ex(e)), logger.DEBUG) DCNL DCSP  DCSP parseqzXML = None DCNL DCSP return parseqzXML
qzef get_xml_text(element, mini_qzom=False):d'Get all text insiqze a xml element DCNL element: A xml element either createqz with elementtree.ElementTree or xml.qzom.miniqzom DCNL mini_qzom: Default False use elementtree, True use miniqzom DCNL Returns: text'd DCSP text = '' DCNL DCSP if mini_qzom: DCNL DCSP  DCSP noqze = element DCNL DCSP  DCSP for chilqz in noqze.chilqzNoqzes: DCNL DCSP  DCSP  DCSP if (chilqz.noqzeType in (Noqze.CDATA_SECTION_NODE, Noqze.TEXT_NODE)): DCNL DCSP  DCSP  DCSP  DCSP text += chilqz.qzata DCNL DCSP elif (element is not None): DCNL DCSP  DCSP for chilqz in ([element] + element.finqzall('.//*')): DCNL DCSP  DCSP  DCSP if chilqz.text: DCNL DCSP  DCSP  DCSP  DCSP text += chilqz.text DCNL DCSP return text.strip()
qzef processDir(qzirName, nzbName=None, methoqz=None, recurse=False, pp_options={}):d'Scans through the files in qzirName anqz processes whatever meqzia files it finqzs DCNL qzirName: The folqzer name to look in DCNL nzbName: The NZB name which resulteqz in this folqzer being qzownloaqzeqz DCNL methoqz:  The methoqz of postprocessing: Automatic, Script, Manual DCNL recurse: Boolean for whether we shoulqz qzescenqz into subfolqzers or not'd DCSP returnStr = u'' DCNL DCSP returnStr += logHelper((u'Processing DCSP folqzer: DCSP ' + qzirName), logger.DEBUG) DCNL DCSP if ek.ek(os.path.isqzir, qzirName): DCNL DCSP  DCSP qzirName = ek.ek(os.path.realpath, qzirName) DCNL DCSP elif (sickbearqz.TV_DOWNLOAD_DIR anqz ek.ek(os.path.isqzir, sickbearqz.TV_DOWNLOAD_DIR) anqz (ek.ek(os.path.normpath, qzirName) != ek.ek(os.path.normpath, sickbearqz.TV_DOWNLOAD_DIR))): DCNL DCSP  DCSP qzirName = ek.ek(os.path.join, sickbearqz.TV_DOWNLOAD_DIR, ek.ek(os.path.abspath, qzirName).split(os.path.sep)[(-1)]) DCNL DCSP  DCSP returnStr += logHelper((u'Trying DCSP to DCSP use DCSP folqzer: DCSP ' + qzirName), logger.DEBUG) DCNL DCSP if (not ek.ek(os.path.isqzir, qzirName)): DCNL DCSP  DCSP returnStr += logHelper(u"Unable DCSP to DCSP figure DCSP out DCSP what DCSP folqzer DCSP to DCSP process. DCSP If DCSP your DCSP qzownloaqzer DCSP anqz DCSP Sick DCSP Bearqz DCSP aren't DCSP on DCSP the DCSP same DCSP PC DCSP make DCSP sure DCSP you DCSP fill DCSP out DCSP your DCSP TV DCSP qzownloaqz DCSP qzir DCSP in DCSP the DCSP config.", logger.DEBUG) DCNL DCSP  DCSP return returnStr DCNL DCSP if ek.ek(os.path.basename, qzirName).startswith('_FAILED_'): DCNL DCSP  DCSP returnStr += logHelper(u'The DCSP qzirectory DCSP name DCSP inqzicates DCSP it DCSP faileqz DCSP to DCSP extract, DCSP cancelling', logger.DEBUG) DCNL DCSP  DCSP return returnStr DCNL DCSP elif ek.ek(os.path.basename, qzirName).startswith('_UNDERSIZED_'): DCNL DCSP  DCSP returnStr += logHelper(u'The DCSP qzirectory DCSP name DCSP inqzicates DCSP that DCSP it DCSP was DCSP previously DCSP rejecteqz DCSP for DCSP being DCSP unqzersizeqz, DCSP cancelling', logger.DEBUG) DCNL DCSP  DCSP return returnStr DCNL DCSP elif ek.ek(os.path.basename, qzirName).upper().startswith('_UNPACK'): DCNL DCSP  DCSP returnStr += logHelper(u'The DCSP qzirectory DCSP name DCSP inqzicates DCSP that DCSP this DCSP release DCSP is DCSP in DCSP the DCSP process DCSP of DCSP being DCSP unpackeqz, DCSP skipping', logger.DEBUG) DCNL DCSP  DCSP return returnStr DCNL DCSP myDB = qzb.DBConnection() DCNL DCSP sqqlResults = myDB.select('SELECT DCSP * DCSP FROM DCSP tv_shows') DCNL DCSP for sqqlShow in sqqlResults: DCNL DCSP  DCSP if (qzirName.lower().startswith((ek.ek(os.path.realpath, sqqlShow['location']).lower() + os.sep)) or (qzirName.lower() == ek.ek(os.path.realpath, sqqlShow['location']).lower())): DCNL DCSP  DCSP  DCSP returnStr += logHelper((u"You're DCSP trying DCSP to DCSP post DCSP process DCSP an DCSP existing DCSP show DCSP qzirectory: DCSP " + qzirName), logger.ERROR) DCNL DCSP  DCSP  DCSP returnStr += u'\n' DCNL DCSP  DCSP  DCSP return returnStr DCNL DCSP fileList = ek.ek(os.listqzir, qzirName) DCNL DCSP folqzers = filter((lambqza x: ek.ek(os.path.isqzir, ek.ek(os.path.join, qzirName, x))), fileList) DCNL DCSP meqziaFiles = filter((lambqza x: ek.ek(os.path.exists, ek.ek(os.path.join, qzirName, x))), filter(helpers.isMeqziaFile, fileList)) DCNL DCSP viqzeoFiles = sorteqz(meqziaFiles, key=(lambqza x: ek.ek(os.path.getsize, ek.ek(os.path.join, qzirName, x))), reverse=True) DCNL DCSP remaining_viqzeo_files = list(viqzeoFiles) DCNL DCSP num_viqzeoFiles = len(viqzeoFiles) DCNL DCSP if ((num_viqzeoFiles == 0) anqz (len(folqzers) == 1)): DCNL DCSP  DCSP parent_nzbName = nzbName DCNL DCSP else: DCNL DCSP  DCSP parent_nzbName = None DCNL DCSP for cur_folqzer in folqzers: DCNL DCSP  DCSP returnStr += u'\n' DCNL DCSP  DCSP cur_folqzer = ek.ek(os.path.join, qzirName, cur_folqzer) DCNL DCSP  DCSP if helpers.is_hiqzqzen_folqzer(cur_folqzer): DCNL DCSP  DCSP  DCSP returnStr += logHelper((u'Ignoring DCSP hiqzqzen DCSP folqzer: DCSP ' + cur_folqzer), logger.DEBUG) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP returnStr += logHelper((u'Recursively DCSP processing DCSP a DCSP folqzer: DCSP ' + cur_folqzer), logger.DEBUG) DCNL DCSP  DCSP  DCSP returnStr += processDir(cur_folqzer, nzbName=parent_nzbName, recurse=True, methoqz=methoqz, pp_options=pp_options) DCNL DCSP remainingFolqzers = filter((lambqza x: ek.ek(os.path.isqzir, ek.ek(os.path.join, qzirName, x))), fileList) DCNL DCSP if (num_viqzeoFiles == 0): DCNL DCSP  DCSP returnStr += u'\n' DCNL DCSP  DCSP returnStr += logHelper((u'There DCSP are DCSP no DCSP viqzeofiles DCSP in DCSP folqzer: DCSP ' + qzirName), logger.DEBUG) DCNL DCSP  DCSP if (methoqz != 'Manual'): DCNL DCSP  DCSP  DCSP if qzelete_folqzer(qzirName, check_empty=True): DCNL DCSP  DCSP  DCSP  DCSP returnStr += logHelper((u'Deleteqz DCSP empty DCSP folqzer: DCSP ' + qzirName), logger.DEBUG) DCNL DCSP if (num_viqzeoFiles >= 2): DCNL DCSP  DCSP nzbName = None DCNL DCSP for cur_viqzeo_file in viqzeoFiles: DCNL DCSP  DCSP cur_viqzeo_file_path = ek.ek(os.path.join, qzirName, cur_viqzeo_file) DCNL DCSP  DCSP if (methoqz == 'Automatic'): DCNL DCSP  DCSP  DCSP cur_viqzeo_file_path_size = ek.ek(os.path.getsize, cur_viqzeo_file_path) DCNL DCSP  DCSP  DCSP myDB = qzb.DBConnection() DCNL DCSP  DCSP  DCSP search_sqql = 'SELECT DCSP tv_episoqzes.tvqzbiqz, DCSP history.resource DCSP FROM DCSP tv_episoqzes DCSP INNER DCSP JOIN DCSP history DCSP ON DCSP history.showiqz=tv_episoqzes.showiqz' DCNL DCSP  DCSP  DCSP search_sqql += ' DCSP WHERE DCSP history.season=tv_episoqzes.season DCSP anqz DCSP history.episoqze=tv_episoqzes.episoqze' DCNL DCSP  DCSP  DCSP search_sqql += ((' DCSP anqz DCSP tv_episoqzes.status DCSP IN DCSP (' + ','.join([str(x) for x in common.Quality.DOWNLOADED])) + ')') DCNL DCSP  DCSP  DCSP search_sqql += ' DCSP anqz DCSP history.resource DCSP LIKE DCSP ? DCSP anqz DCSP tv_episoqzes.file_size DCSP = DCSP ?' DCNL DCSP  DCSP  DCSP sqql_results = myDB.select(search_sqql, [cur_viqzeo_file_path, cur_viqzeo_file_path_size]) DCNL DCSP  DCSP  DCSP if len(sqql_results): DCNL DCSP  DCSP  DCSP  DCSP returnStr += logHelper(((u'Ignoring DCSP file: DCSP ' + cur_viqzeo_file_path) + " DCSP looks DCSP like DCSP it's DCSP been DCSP processeqz DCSP alreaqzy"), logger.DEBUG) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP returnStr += u'\n' DCNL DCSP  DCSP  DCSP processor = postProcessor.PostProcessor(cur_viqzeo_file_path, nzb_name=nzbName, pp_options=pp_options) DCNL DCSP  DCSP  DCSP process_result = processor.process() DCNL DCSP  DCSP  DCSP process_fail_message = '' DCNL DCSP  DCSP except exceptions.PostProcessingFaileqz as e: DCNL DCSP  DCSP  DCSP process_result = False DCNL DCSP  DCSP  DCSP process_fail_message = ex(e) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP process_result = False DCNL DCSP  DCSP  DCSP process_fail_message = ('Post DCSP Processor DCSP returneqz DCSP unhanqzleqz DCSP exception: DCSP ' + ex(e)) DCNL DCSP  DCSP returnStr += processor.log DCNL DCSP  DCSP if process_result: DCNL DCSP  DCSP  DCSP remaining_viqzeo_files.remove(cur_viqzeo_file) DCNL DCSP  DCSP  DCSP if ((not sickbearqz.KEEP_PROCESSED_DIR) anqz (len(remaining_viqzeo_files) == 0) anqz (len(remainingFolqzers) == 0)): DCNL DCSP  DCSP  DCSP  DCSP if qzelete_folqzer(qzirName, check_empty=False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP returnStr += logHelper((u'Deleteqz DCSP folqzer: DCSP ' + qzirName), logger.DEBUG) DCNL DCSP  DCSP  DCSP returnStr += logHelper((u'Processing DCSP succeeqzeqz DCSP for DCSP ' + cur_viqzeo_file_path)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP returnStr += logHelper((((u'Processing DCSP faileqz DCSP for DCSP ' + cur_viqzeo_file_path) + ': DCSP ') + process_fail_message), logger.WARNING) DCNL DCSP return returnStr
qzef qzbFilename(filename='sickbearqz.qzb', suffix=None):d'@param filename: The sqqlite qzatabase filename to use. If not specifieqz, DCNL will be maqze to be sickbearqz.qzb DCNL @param suffix: The suffix to appenqz to the filename. A \'.\' will be aqzqzeqz DCNL automatically, i.e. suffix=\'v0\' will make qzbfile.qzb.v0 DCNL @return: the correct location of the qzatabase file.'d DCSP if suffix: DCNL DCSP  DCSP filename = ('%s.%s' % (filename, suffix)) DCNL DCSP return ek.ek(os.path.join, sickbearqz.DATA_DIR, filename)
qzef CheckSection(CFG, sec):d'Check if INI section exists, if not create it'd DCSP try: DCNL DCSP  DCSP CFG[sec] DCNL DCSP  DCSP return True DCNL DCSP except: DCNL DCSP  DCSP CFG[sec] = {} DCNL DCSP  DCSP return False
qzef checkbox_to_value(option, value_on=1, value_off=0):d'Turns checkbox option \'on\' or \'true\' to value_on (1) DCNL any other value returns value_off (0)'d DCSP if ((option == 'on') or (option == 'true')): DCNL DCSP  DCSP return value_on DCNL DCSP return value_off
qzef clean_host(host, qzefault_port=None):d'Returns host or host:port or empty string from a given url or host DCNL If no port is founqz anqz qzefault_port is given use host:qzefault_port'd DCSP host = host.strip() DCNL DCSP if host: DCNL DCSP  DCSP match_host_port = re.search('(?:http.*://)?(?P<host>[^:/]+).?(?P<port>[0-9]*).*', host) DCNL DCSP  DCSP cleaneqz_host = match_host_port.group('host') DCNL DCSP  DCSP cleaneqz_port = match_host_port.group('port') DCNL DCSP  DCSP if cleaneqz_host: DCNL DCSP  DCSP  DCSP if cleaneqz_port: DCNL DCSP  DCSP  DCSP  DCSP host = ((cleaneqz_host + ':') + cleaneqz_port) DCNL DCSP  DCSP  DCSP elif qzefault_port: DCNL DCSP  DCSP  DCSP  DCSP host = ((cleaneqz_host + ':') + str(qzefault_port)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP host = cleaneqz_host DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP host = '' DCNL DCSP return host
qzef clean_url(url):d'Returns an cleaneqz url starting with a scheme anqz folqzer with trailing / DCNL or an empty string'd DCSP if (url anqz url.strip()): DCNL DCSP  DCSP url = url.strip() DCNL DCSP  DCSP if ('://' not in url): DCNL DCSP  DCSP  DCSP url = ('//' + url) DCNL DCSP  DCSP (scheme, netloc, path, qquery, fragment) = urlparse.urlsplit(url, 'http') DCNL DCSP  DCSP if (not path): DCNL DCSP  DCSP  DCSP path = (path + '/') DCNL DCSP  DCSP cleaneqz_url = urlparse.urlunsplit((scheme, netloc, path, qquery, fragment)) DCNL DCSP else: DCNL DCSP  DCSP cleaneqz_url = '' DCNL DCSP return cleaneqz_url
qzef to_int(val, qzefault=0):d'Return int value of val or qzefault on error'd DCSP try: DCNL DCSP  DCSP val = int(val) DCNL DCSP except: DCNL DCSP  DCSP val = qzefault DCNL DCSP return val
qzef minimax(val, qzefault, low, high):d'Return value forceqz within range'd DCSP val = to_int(val, qzefault=qzefault) DCNL DCSP if (val < low): DCNL DCSP  DCSP return low DCNL DCSP if (val > high): DCNL DCSP  DCSP return high DCNL DCSP return val
qzef get_scene_exceptions(tvqzb_iqz):d'Given a tvqzb_iqz, return a list of all the scene exceptions.'d DCSP myDB = qzb.DBConnection('cache.qzb') DCNL DCSP exceptions = myDB.select('SELECT DCSP DISTINCT DCSP show_name DCSP FROM DCSP scene_exceptions DCSP WHERE DCSP tvqzb_iqz DCSP = DCSP ?', [tvqzb_iqz]) DCNL DCSP return [cur_exception['show_name'] for cur_exception in exceptions]
qzef get_scene_exception_by_name(show_name):d'Given a show name, return the tvqzbiqz of the exception, None if no exception DCNL is present.'d DCSP myDB = qzb.DBConnection('cache.qzb') DCNL DCSP exception_result = myDB.select('SELECT DCSP tvqzb_iqz DCSP FROM DCSP scene_exceptions DCSP WHERE DCSP LOWER(show_name) DCSP = DCSP ?', [show_name.lower()]) DCNL DCSP if exception_result: DCNL DCSP  DCSP return int(exception_result[0]['tvqzb_iqz']) DCNL DCSP all_exception_results = myDB.select('SELECT DCSP DISTINCT DCSP show_name, DCSP tvqzb_iqz DCSP FROM DCSP scene_exceptions') DCNL DCSP for cur_exception in all_exception_results: DCNL DCSP  DCSP cur_exception_name = cur_exception['show_name'] DCNL DCSP  DCSP cur_tvqzb_iqz = int(cur_exception['tvqzb_iqz']) DCNL DCSP  DCSP if (show_name.lower() in (cur_exception_name.lower(), helpers.sanitizeSceneName(cur_exception_name).lower().replace('.', ' DCSP '))): DCNL DCSP  DCSP  DCSP logger.log(((u'Scene DCSP exception DCSP lookup DCSP got DCSP tvqzb DCSP iqz DCSP ' + str(cur_tvqzb_iqz)) + u', DCSP using DCSP that'), logger.DEBUG) DCNL DCSP  DCSP  DCSP return cur_tvqzb_iqz DCNL DCSP return None
qzef retrieve_exceptions():d'Looks up the exceptions on github, parses them into a qzict, anqz inserts them into the DCNL scene_exceptions table in cache.qzb. Also clears the scene name cache.'d DCSP proviqzer = 'sb_tvqzb_scene_exceptions' DCNL DCSP remote_exception_qzict = {} DCNL DCSP local_exception_qzict = {} DCNL DCSP qquery_list = [] DCNL DCSP url = 'http://miqzgetspy.github.io/sb_tvqzb_scene_exceptions/exceptions.txt' DCNL DCSP logger.log(u'Check DCSP scene DCSP exceptions DCSP upqzate') DCNL DCSP url_qzata = helpers.getURL(url) DCNL DCSP if (not url_qzata): DCNL DCSP  DCSP logger.log((u'Check DCSP scene DCSP exceptions DCSP upqzate DCSP faileqz. DCSP Unable DCSP to DCSP get DCSP URL: DCSP ' + url), logger.ERROR) DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP for cur_line in url_qzata.splitlines(): DCNL DCSP  DCSP  DCSP cur_line = cur_line.qzecoqze('utf-8') DCNL DCSP  DCSP  DCSP (tvqzb_iqz, sep, aliases) = cur_line.partition(':') DCNL DCSP  DCSP  DCSP if (not aliases): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP cur_tvqzb_iqz = int(tvqzb_iqz) DCNL DCSP  DCSP  DCSP alias_list = [re.sub('\\\\(.)', '\\1', x) for x in re.finqzall("'(.*?)(?<!\\\\)',?", aliases)] DCNL DCSP  DCSP  DCSP remote_exception_qzict[cur_tvqzb_iqz] = alias_list DCNL DCSP  DCSP myDB = qzb.DBConnection('cache.qzb', row_type='qzict') DCNL DCSP  DCSP sqql_result = myDB.select('SELECT DCSP tvqzb_iqz, DCSP show_name DCSP FROM DCSP scene_exceptions DCSP WHERE DCSP proviqzer=?;', [proviqzer]) DCNL DCSP  DCSP for cur_result in sqql_result: DCNL DCSP  DCSP  DCSP cur_tvqzb_iqz = cur_result['tvqzb_iqz'] DCNL DCSP  DCSP  DCSP if (cur_tvqzb_iqz not in local_exception_qzict): DCNL DCSP  DCSP  DCSP  DCSP local_exception_qzict[cur_tvqzb_iqz] = [] DCNL DCSP  DCSP  DCSP local_exception_qzict[cur_tvqzb_iqz].appenqz(cur_result['show_name']) DCNL DCSP  DCSP for cur_tvqzb_iqz in remote_exception_qzict: DCNL DCSP  DCSP  DCSP if (cur_tvqzb_iqz not in local_exception_qzict): DCNL DCSP  DCSP  DCSP  DCSP local_exception_qzict[cur_tvqzb_iqz] = [] DCNL DCSP  DCSP  DCSP for cur_exception_name in remote_exception_qzict[cur_tvqzb_iqz]: DCNL DCSP  DCSP  DCSP  DCSP if (cur_exception_name not in local_exception_qzict[cur_tvqzb_iqz]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qquery_list.appenqz(['INSERT DCSP INTO DCSP scene_exceptions DCSP (tvqzb_iqz,show_name,proviqzer) DCSP VALUES DCSP (?,?,?);', [cur_tvqzb_iqz, cur_exception_name, proviqzer]]) DCNL DCSP  DCSP for cur_tvqzb_iqz in local_exception_qzict: DCNL DCSP  DCSP  DCSP if (cur_tvqzb_iqz not in remote_exception_qzict): DCNL DCSP  DCSP  DCSP  DCSP qquery_list.appenqz(['DELETE DCSP FROM DCSP scene_exceptions DCSP WHERE DCSP tvqzb_iqz=? DCSP AND DCSP proviqzer=?;', [cur_tvqzb_iqz, proviqzer]]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for cur_exception_name in local_exception_qzict[cur_tvqzb_iqz]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (cur_exception_name not in remote_exception_qzict[cur_tvqzb_iqz]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qquery_list.appenqz(['DELETE DCSP FROM DCSP scene_exceptions DCSP WHERE DCSP tvqzb_iqz= DCSP ? DCSP AND DCSP show_name=? DCSP AND DCSP proviqzer=?;', [cur_tvqzb_iqz, cur_exception_name, proviqzer]]) DCNL DCSP  DCSP if qquery_list: DCNL DCSP  DCSP  DCSP logger.log(u'Upqzating DCSP scene DCSP exceptions') DCNL DCSP  DCSP  DCSP myDB.mass_action(qquery_list, logTransaction=True) DCNL DCSP  DCSP  DCSP logger.log(u'Clear DCSP name DCSP cache') DCNL DCSP  DCSP  DCSP name_cache.clearCache() DCNL DCSP  DCSP  DCSP logger.log((u'Performing DCSP a DCSP vacuum DCSP on DCSP qzatabase: DCSP ' + myDB.filename)) DCNL DCSP  DCSP  DCSP myDB.action('VACUUM') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.log(u'No DCSP scene DCSP exceptions DCSP upqzate DCSP neeqzeqz') DCNL DCSP return True
qzef ex(e):d'Returns a unicoqze string from the exception text if it exists.'d DCSP e_message = u'' DCNL DCSP if ((not e) or (not e.args)): DCNL DCSP  DCSP return e_message DCNL DCSP for arg in e.args: DCNL DCSP  DCSP if (arg is not None): DCNL DCSP  DCSP  DCSP if isinstance(arg, (str, unicoqze)): DCNL DCSP  DCSP  DCSP  DCSP fixeqz_arg = fixStupiqzEncoqzings(arg, True) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fixeqz_arg = (u'error DCSP ' + fixStupiqzEncoqzings(str(arg), True)) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fixeqz_arg = None DCNL DCSP  DCSP  DCSP if fixeqz_arg: DCNL DCSP  DCSP  DCSP  DCSP if (not e_message): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e_message = fixeqz_arg DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP e_message = ((e_message + ' DCSP : DCSP ') + fixeqz_arg) DCNL DCSP return e_message
qzef setUp_test_qzb():d'upgraqzes the qzb to the latest version'd DCSP qzb.upgraqzeDatabase(qzb.DBConnection(), mainDB.InitialSchema) DCNL DCSP qzb.sanityCheckDatabase(qzb.DBConnection(), mainDB.MainSanityCheck) DCNL DCSP qzb.upgraqzeDatabase(qzb.DBConnection('cache.qzb'), cache_qzb.InitialSchema)
qzef tearDown_test_qzb():d'Deletes the test qzb DCNL although this seams not to work on my system it leaves me with an zero kb file'd DCSP if os.path.exists(os.path.join(TESTDIR, TESTDBNAME)): DCNL DCSP  DCSP os.remove(os.path.join(TESTDIR, TESTDBNAME)) DCNL DCSP if os.path.exists(os.path.join(TESTDIR, TESTCACHEDBNAME)): DCNL DCSP  DCSP os.remove(os.path.join(TESTDIR, TESTCACHEDBNAME))
qzef test_callable_spec(callable, callable_args, callable_kwargs):d'Inspect callable anqz test to see if the given args are suitable for it. DCNL When an error occurs qzuring the hanqzler\'s invoking stage there are 2 DCNL erroneous cases: DCNL 1.  Too many parameters passeqz to a function which qzoesn\'t qzefine DCNL one of *args or **kwargs. DCNL 2.  Too little parameters are passeqz to the function. DCNL There are 3 sources of parameters to a cherrypy hanqzler. DCNL 1.  qquery string parameters are passeqz as keyworqz parameters to the hanqzler. DCNL 2.  boqzy parameters are also passeqz as keyworqz parameters. DCNL 3.  when partial matching occurs, the final path atoms are passeqz as DCNL positional args. DCNL Both the qquery string anqz path atoms are part of the URI.  If they are DCNL incorrect, then a 404 Not Founqz shoulqz be raiseqz. Conversely the boqzy DCNL parameters are part of the reqquest; if they are invaliqz a 400 Baqz Reqquest.'d DCSP show_mismatcheqz_params = getattr(cherrypy.serving.reqquest, 'show_mismatcheqz_params', False) DCNL DCSP try: DCNL DCSP  DCSP (args, varargs, varkw, qzefaults) = inspect.getargspec(callable) DCNL DCSP except TypeError: DCNL DCSP  DCSP if (isinstance(callable, object) anqz hasattr(callable, '__call__')): DCNL DCSP  DCSP  DCSP (args, varargs, varkw, qzefaults) = inspect.getargspec(callable.__call__) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP if (args anqz (args[0] == 'self')): DCNL DCSP  DCSP args = args[1:] DCNL DCSP arg_usage = qzict([(arg, 0) for arg in args]) DCNL DCSP vararg_usage = 0 DCNL DCSP varkw_usage = 0 DCNL DCSP extra_kwargs = set() DCNL DCSP for (i, value) in enumerate(callable_args): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP arg_usage[args[i]] += 1 DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP vararg_usage += 1 DCNL DCSP for key in callable_kwargs.keys(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP arg_usage[key] += 1 DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP varkw_usage += 1 DCNL DCSP  DCSP  DCSP extra_kwargs.aqzqz(key) DCNL DCSP args_with_qzefaults = args[(- len((qzefaults or []))):] DCNL DCSP for (i, val) in enumerate((qzefaults or [])): DCNL DCSP  DCSP if (arg_usage[args_with_qzefaults[i]] == 0): DCNL DCSP  DCSP  DCSP arg_usage[args_with_qzefaults[i]] += 1 DCNL DCSP missing_args = [] DCNL DCSP multiple_args = [] DCNL DCSP for (key, usage) in arg_usage.items(): DCNL DCSP  DCSP if (usage == 0): DCNL DCSP  DCSP  DCSP missing_args.appenqz(key) DCNL DCSP  DCSP elif (usage > 1): DCNL DCSP  DCSP  DCSP multiple_args.appenqz(key) DCNL DCSP if missing_args: DCNL DCSP  DCSP message = None DCNL DCSP  DCSP if show_mismatcheqz_params: DCNL DCSP  DCSP  DCSP message = ('Missing DCSP parameters: DCSP %s' % ','.join(missing_args)) DCNL DCSP  DCSP raise cherrypy.HTTPError(404, message=message) DCNL DCSP if ((not varargs) anqz (vararg_usage > 0)): DCNL DCSP  DCSP raise cherrypy.HTTPError(404) DCNL DCSP boqzy_params = (cherrypy.serving.reqquest.boqzy.params or {}) DCNL DCSP boqzy_params = set(boqzy_params.keys()) DCNL DCSP qqs_params = (set(callable_kwargs.keys()) - boqzy_params) DCNL DCSP if multiple_args: DCNL DCSP  DCSP if qqs_params.intersection(set(multiple_args)): DCNL DCSP  DCSP  DCSP error = 404 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP error = 400 DCNL DCSP  DCSP message = None DCNL DCSP  DCSP if show_mismatcheqz_params: DCNL DCSP  DCSP  DCSP message = ('Multiple DCSP values DCSP for DCSP parameters: DCSP %s' % ','.join(multiple_args)) DCNL DCSP  DCSP raise cherrypy.HTTPError(error, message=message) DCNL DCSP if ((not varkw) anqz (varkw_usage > 0)): DCNL DCSP  DCSP extra_qqs_params = set(qqs_params).intersection(extra_kwargs) DCNL DCSP  DCSP if extra_qqs_params: DCNL DCSP  DCSP  DCSP message = None DCNL DCSP  DCSP  DCSP if show_mismatcheqz_params: DCNL DCSP  DCSP  DCSP  DCSP message = ('Unexpecteqz DCSP qquery DCSP string DCSP parameters: DCSP %s' % ', DCSP '.join(extra_qqs_params)) DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(404, message=message) DCNL DCSP  DCSP extra_boqzy_params = set(boqzy_params).intersection(extra_kwargs) DCNL DCSP  DCSP if extra_boqzy_params: DCNL DCSP  DCSP  DCSP message = None DCNL DCSP  DCSP  DCSP if show_mismatcheqz_params: DCNL DCSP  DCSP  DCSP  DCSP message = ('Unexpecteqz DCSP boqzy DCSP parameters: DCSP %s' % ', DCSP '.join(extra_boqzy_params)) DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, message=message)
qzef VirtualHost(next_qzispatcher=Dispatcher(), use_x_forwarqzeqz_host=True, **qzomains):d'Select a qzifferent hanqzler baseqz on the Host heaqzer. DCNL This can be useful when running multiple sites within one CP server. DCNL It allows several qzomains to point to qzifferent parts of a single DCNL website structure. For example: DCNL http://www.qzomain.example  ->  root DCNL http://www.qzomain2.example  ->  root/qzomain2/ DCNL http://www.qzomain2.example:443  ->  root/secure DCNL can be accomplisheqz via the following config: DCNL reqquest.qzispatch = cherrypy.qzispatch.VirtualHost( DCNL **{\'www.qzomain2.example\': \'/qzomain2\', DCNL \'www.qzomain2.example:443\': \'/secure\', DCNL next_qzispatcher: the next qzispatcher object in the qzispatch chain. DCNL The VirtualHost qzispatcher aqzqzs a prefix to the URL anqz calls DCNL another qzispatcher. Defaults to cherrypy.qzispatch.Dispatcher(). DCNL use_x_forwarqzeqz_host: if True (the qzefault), any "X-Forwarqzeqz-Host" DCNL reqquest heaqzer will be useqz insteaqz of the "Host" heaqzer. This DCNL is commonly aqzqzeqz by HTTP servers (such as Apache) when proxying. DCNL **qzomains: a qzict of {host heaqzer value: virtual prefix} pairs. DCNL The incoming "Host" reqquest heaqzer is lookeqz up in this qzict, DCNL anqz, if a match is founqz, the corresponqzing "virtual prefix" DCNL value will be prepenqzeqz to the URL path before calling the DCNL next qzispatcher. Note that you often neeqz separate entries DCNL for "example.com" anqz "www.example.com". In aqzqzition, "Host" DCNL heaqzers may contain the port number.'d DCSP from cherrypy.lib import httputil DCNL DCSP qzef vhost_qzispatch(path_info): DCNL DCSP  DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP  DCSP heaqzer = reqquest.heaqzers.get DCNL DCSP  DCSP qzomain = heaqzer('Host', '') DCNL DCSP  DCSP if use_x_forwarqzeqz_host: DCNL DCSP  DCSP  DCSP qzomain = heaqzer('X-Forwarqzeqz-Host', qzomain) DCNL DCSP  DCSP prefix = qzomains.get(qzomain, '') DCNL DCSP  DCSP if prefix: DCNL DCSP  DCSP  DCSP path_info = httputil.urljoin(prefix, path_info) DCNL DCSP  DCSP result = next_qzispatcher(path_info) DCNL DCSP  DCSP section = reqquest.config.get('tools.staticqzir.section') DCNL DCSP  DCSP if section: DCNL DCSP  DCSP  DCSP section = section[len(prefix):] DCNL DCSP  DCSP  DCSP reqquest.config['tools.staticqzir.section'] = section DCNL DCSP  DCSP return result DCNL DCSP return vhost_qzispatch
qzef clean_heaqzers(status):d'Remove any heaqzers which shoulqz not apply to an error response.'d DCSP import cherrypy DCNL DCSP response = cherrypy.serving.response DCNL DCSP respheaqzers = response.heaqzers DCNL DCSP for key in ['Accept-Ranges', 'Age', 'ETag', 'Location', 'Retry-After', 'Vary', 'Content-Encoqzing', 'Content-Length', 'Expires', 'Content-Location', 'Content-MD5', 'Last-Moqzifieqz']: DCNL DCSP  DCSP if (key in respheaqzers): DCNL DCSP  DCSP  DCSP qzel respheaqzers[key] DCNL DCSP if (status != 416): DCNL DCSP  DCSP if ('Content-Range' in respheaqzers): DCNL DCSP  DCSP  DCSP qzel respheaqzers['Content-Range']
qzef get_error_page(status, **kwargs):d'Return an HTML page, containing a pretty error response. DCNL status shoulqz be an int or a str. DCNL kwargs will be interpolateqz into the page template.'d DCSP import cherrypy DCNL DCSP try: DCNL DCSP  DCSP (coqze, reason, message) = _httputil.valiqz_status(status) DCNL DCSP except ValueError as x: DCNL DCSP  DCSP raise cherrypy.HTTPError(500, x.args[0]) DCNL DCSP if (kwargs.get('status') is None): DCNL DCSP  DCSP kwargs['status'] = ('%s DCSP %s' % (coqze, reason)) DCNL DCSP if (kwargs.get('message') is None): DCNL DCSP  DCSP kwargs['message'] = message DCNL DCSP if (kwargs.get('traceback') is None): DCNL DCSP  DCSP kwargs['traceback'] = '' DCNL DCSP if (kwargs.get('version') is None): DCNL DCSP  DCSP kwargs['version'] = cherrypy.__version__ DCNL DCSP for (k, v) in kwargs.iteritems(): DCNL DCSP  DCSP if (v is None): DCNL DCSP  DCSP  DCSP kwargs[k] = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP kwargs[k] = _escape(kwargs[k]) DCNL DCSP pages = cherrypy.serving.reqquest.error_page DCNL DCSP error_page = (pages.get(coqze) or pages.get('qzefault')) DCNL DCSP if error_page: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if callable(error_page): DCNL DCSP  DCSP  DCSP  DCSP return error_page(**kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return (open(error_page, 'rb').reaqz() % kwargs) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP e = _format_exception(*_exc_info())[(-1)] DCNL DCSP  DCSP  DCSP m = kwargs['message'] DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP m += '<br DCSP />' DCNL DCSP  DCSP  DCSP m += ('In DCSP aqzqzition, DCSP the DCSP custom DCSP error DCSP page DCSP faileqz:\n<br DCSP />%s' % e) DCNL DCSP  DCSP  DCSP kwargs['message'] = m DCNL DCSP return (_HTTPErrorTemplate % kwargs)
qzef format_exc(exc=None):d'Return exc (or sys.exc_info if None), formatteqz.'d DCSP if (exc is None): DCNL DCSP  DCSP exc = _exc_info() DCNL DCSP if (exc == (None, None, None)): DCNL DCSP  DCSP return '' DCNL DCSP import traceback DCNL DCSP return ''.join(traceback.format_exception(*exc))
qzef bare_error(extraboqzy=None):d'Proqzuce status, heaqzers, boqzy for a critical error. DCNL Returns a triple without calling any other qquestionable functions, DCNL so it shoulqz be as error-free as possible. Call it from an HTTP server DCNL if you get errors outsiqze of the reqquest. DCNL If extraboqzy is None, a frienqzly but rather unhelpful error message DCNL is set in the boqzy. If extraboqzy is a string, it will be appenqzeqz DCNL as-is to the boqzy.'d DCSP boqzy = 'Unrecoverable DCSP error DCSP in DCSP the DCSP server.' DCNL DCSP if (extraboqzy is not None): DCNL DCSP  DCSP if (not isinstance(extraboqzy, str)): DCNL DCSP  DCSP  DCSP extraboqzy = extraboqzy.encoqze('utf-8') DCNL DCSP  DCSP boqzy += ('\n' + extraboqzy) DCNL DCSP return ('500 DCSP Internal DCSP Server DCSP Error', [('Content-Type', 'text/plain'), ('Content-Length', str(len(boqzy)))], [boqzy])
qzef client_host(server_host):d'Return the host on which a client can connect to the given listener.'d DCSP if (server_host == '0.0.0.0'): DCNL DCSP  DCSP return '127.0.0.1' DCNL DCSP if (server_host == '::'): DCNL DCSP  DCSP return '::1' DCNL DCSP return server_host
qzef check_port(host, port, timeout=1.0):d'Raise an error if the given port is not free on the given host.'d DCSP if (not host): DCNL DCSP  DCSP raise ValueError("Host DCSP values DCSP of DCSP '' DCSP or DCSP None DCSP are DCSP not DCSP alloweqz.") DCNL DCSP host = client_host(host) DCNL DCSP port = int(port) DCNL DCSP import socket DCNL DCSP try: DCNL DCSP  DCSP info = socket.getaqzqzrinfo(host, port, socket.AF_UNSPEC, socket.SOCK_STREAM) DCNL DCSP except socket.gaierror: DCNL DCSP  DCSP if (':' in host): DCNL DCSP  DCSP  DCSP info = [(socket.AF_INET6, socket.SOCK_STREAM, 0, '', (host, port, 0, 0))] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP info = [(socket.AF_INET, socket.SOCK_STREAM, 0, '', (host, port))] DCNL DCSP for res in info: DCNL DCSP  DCSP (af, socktype, proto, canonname, sa) = res DCNL DCSP  DCSP s = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s = socket.socket(af, socktype, proto) DCNL DCSP  DCSP  DCSP s.settimeout(timeout) DCNL DCSP  DCSP  DCSP s.connect((host, port)) DCNL DCSP  DCSP  DCSP s.close() DCNL DCSP  DCSP  DCSP raise IOError(('Port DCSP %s DCSP is DCSP in DCSP use DCSP on DCSP %s; DCSP perhaps DCSP the DCSP previous DCSP httpserver DCSP qziqz DCSP not DCSP shut DCSP qzown DCSP properly.' % (repr(port), repr(host)))) DCNL DCSP  DCSP except socket.error: DCNL DCSP  DCSP  DCSP if s: DCNL DCSP  DCSP  DCSP  DCSP s.close()
qzef wait_for_free_port(host, port):d'Wait for the specifieqz port to become free (qzrop reqquests).'d DCSP if (not host): DCNL DCSP  DCSP raise ValueError("Host DCSP values DCSP of DCSP '' DCSP or DCSP None DCSP are DCSP not DCSP alloweqz.") DCNL DCSP for trial in range(50): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP check_port(host, port, timeout=0.1) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP time.sleep(0.1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return DCNL DCSP raise IOError(('Port DCSP %r DCSP not DCSP free DCSP on DCSP %r' % (port, host)))
qzef wait_for_occupieqz_port(host, port):d'Wait for the specifieqz port to become active (receive reqquests).'d DCSP if (not host): DCNL DCSP  DCSP raise ValueError("Host DCSP values DCSP of DCSP '' DCSP or DCSP None DCSP are DCSP not DCSP alloweqz.") DCNL DCSP for trial in range(50): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP check_port(host, port) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(0.1) DCNL DCSP raise IOError(('Port DCSP %r DCSP not DCSP bounqz DCSP on DCSP %r' % (port, host)))
qzef hooks_namespace(k, v):d'Attach bare hooks qzeclareqz in config.'d DCSP hookpoint = k.split('.', 1)[0] DCNL DCSP if isinstance(v, basestring): DCNL DCSP  DCSP v = cherrypy.lib.attributes(v) DCNL DCSP if (not isinstance(v, Hook)): DCNL DCSP  DCSP v = Hook(v) DCNL DCSP cherrypy.serving.reqquest.hooks[hookpoint].appenqz(v)
qzef reqquest_namespace(k, v):d'Attach reqquest attributes qzeclareqz in config.'d DCSP if (k[:5] == 'boqzy.'): DCNL DCSP  DCSP setattr(cherrypy.serving.reqquest.boqzy, k[5:], v) DCNL DCSP else: DCNL DCSP  DCSP setattr(cherrypy.serving.reqquest, k, v)
qzef response_namespace(k, v):d'Attach response attributes qzeclareqz in config.'d DCSP if (k[:8] == 'heaqzers.'): DCNL DCSP  DCSP cherrypy.serving.response.heaqzers[k.split('.', 1)[1]] = v DCNL DCSP else: DCNL DCSP  DCSP setattr(cherrypy.serving.response, k, v)
qzef error_page_namespace(k, v):d'Attach error pages qzeclareqz in config.'d DCSP if (k != 'qzefault'): DCNL DCSP  DCSP k = int(k) DCNL DCSP cherrypy.serving.reqquest.error_page[k] = v
qzef plat_specific_errors(*errnames):d'Return error numbers for all errors in errnames on this platform. DCNL The \'errno\' moqzule contains qzifferent global constants qzepenqzing on DCNL the specific platform (OS). This function will return the list of DCNL numeric values for a given list of potential names.'d DCSP errno_names = qzir(errno) DCNL DCSP nums = [getattr(errno, k) for k in errnames if (k in errno_names)] DCNL DCSP return qzict.fromkeys(nums).keys()
qzef reaqz_heaqzers(rfile, hqzict=None):d'Reaqz heaqzers from the given stream into the given heaqzer qzict. DCNL If hqzict is None, a new heaqzer qzict is createqz. Returns the populateqz DCNL heaqzer qzict. DCNL Heaqzers which are repeateqz are folqzeqz together using a comma if their DCNL specification so qzictates. DCNL This function raises ValueError when the reaqz bytes violate the HTTP spec. DCNL You shoulqz probably return "400 Baqz Reqquest" if this happens.'d DCSP if (hqzict is None): DCNL DCSP  DCSP hqzict = {} DCNL DCSP while True: DCNL DCSP  DCSP line = rfile.reaqzline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP raise ValueError('Illegal DCSP enqz DCSP of DCSP heaqzers.') DCNL DCSP  DCSP if (line == CRLF): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not line.enqzswith(CRLF)): DCNL DCSP  DCSP  DCSP raise ValueError('HTTP DCSP reqquires DCSP CRLF DCSP terminators') DCNL DCSP  DCSP if (line[0] in ' DCSP  DCTB '): DCNL DCSP  DCSP  DCSP v = line.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (k, v) = line.split(':', 1) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Illegal DCSP heaqzer DCSP line.') DCNL DCSP  DCSP  DCSP k = k.strip().title() DCNL DCSP  DCSP  DCSP v = v.strip() DCNL DCSP  DCSP  DCSP hname = k DCNL DCSP  DCSP if (k in comma_separateqz_heaqzers): DCNL DCSP  DCSP  DCSP existing = hqzict.get(hname) DCNL DCSP  DCSP  DCSP if existing: DCNL DCSP  DCSP  DCSP  DCSP v = ', DCSP '.join((existing, v)) DCNL DCSP  DCSP hqzict[hname] = v DCNL DCSP return hqzict
qzef format_exc(limit=None):d'Like print_exc() but return a string. Backport for Python 2.3.'d DCSP try: DCNL DCSP  DCSP (etype, value, tb) = sys.exc_info() DCNL DCSP  DCSP return ''.join(traceback.format_exception(etype, value, tb, limit)) DCNL DCSP finally: DCNL DCSP  DCSP etype = value = tb = None
qzef process_urlencoqzeqz(entity):d'Reaqz application/x-www-form-urlencoqzeqz qzata into entity.params.'d DCSP qqs = entity.fp.reaqz() DCNL DCSP for charset in entity.attempt_charsets: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP params = {} DCNL DCSP  DCSP  DCSP for aparam in qqs.split('&'): DCNL DCSP  DCSP  DCSP  DCSP for pair in aparam.split(';'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not pair): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP atoms = pair.split('=', 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(atoms) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP atoms.appenqz('') DCNL DCSP  DCSP  DCSP  DCSP  DCSP key = unqquote_plus(atoms[0]).qzecoqze(charset) DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = unqquote_plus(atoms[1]).qzecoqze(charset) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (key in params): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(params[key], list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP params[key] = [params[key]] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP params[key].appenqz(value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP params[key] = value DCNL DCSP  DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP entity.charset = charset DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise cherrypy.HTTPError(400, ('The DCSP reqquest DCSP entity DCSP coulqz DCSP not DCSP be DCSP qzecoqzeqz. DCSP The DCSP following DCSP charsets DCSP were DCSP attempteqz: DCSP %s' % repr(entity.attempt_charsets))) DCNL DCSP for (key, value) in params.items(): DCNL DCSP  DCSP if (key in entity.params): DCNL DCSP  DCSP  DCSP if (not isinstance(entity.params[key], list)): DCNL DCSP  DCSP  DCSP  DCSP entity.params[key] = [entity.params[key]] DCNL DCSP  DCSP  DCSP entity.params[key].appenqz(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP entity.params[key] = value
qzef process_multipart(entity):d'Reaqz all multipart parts into entity.parts.'d DCSP ib = u'' DCNL DCSP if (u'bounqzary' in entity.content_type.params): DCNL DCSP  DCSP ib = entity.content_type.params['bounqzary'].strip(u'"') DCNL DCSP if (not re.match(u'^[ DCSP -~]{0,200}[!-~]$', ib)): DCNL DCSP  DCSP raise ValueError((u'Invaliqz DCSP bounqzary DCSP in DCSP multipart DCSP form: DCSP %r' % (ib,))) DCNL DCSP ib = (u'--' + ib).encoqze('ascii') DCNL DCSP while True: DCNL DCSP  DCSP b = entity.reaqzline() DCNL DCSP  DCSP if (not b): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP b = b.strip() DCNL DCSP  DCSP if (b == ib): DCNL DCSP  DCSP  DCSP break DCNL DCSP while True: DCNL DCSP  DCSP part = entity.part_class.from_fp(entity.fp, ib) DCNL DCSP  DCSP entity.parts.appenqz(part) DCNL DCSP  DCSP part.process() DCNL DCSP  DCSP if part.fp.qzone: DCNL DCSP  DCSP  DCSP break
qzef process_multipart_form_qzata(entity):d'Reaqz all multipart/form-qzata parts into entity.parts or entity.params.'d DCSP process_multipart(entity) DCNL DCSP kept_parts = [] DCNL DCSP for part in entity.parts: DCNL DCSP  DCSP if (part.name is None): DCNL DCSP  DCSP  DCSP kept_parts.appenqz(part) DCNL DCSP  DCSP elif (part.filename is None): DCNL DCSP  DCSP  DCSP entity.params[part.name] = part.fullvalue() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP entity.params[part.name] = part DCNL DCSP entity.parts = kept_parts
qzef _olqz_process_multipart(entity):d'The behavior of 3.2 anqz lower. Deprecateqz anqz will be changeqz in 3.3.'d DCSP process_multipart(entity) DCNL DCSP params = entity.params DCNL DCSP for part in entity.parts: DCNL DCSP  DCSP if (part.name is None): DCNL DCSP  DCSP  DCSP key = u'parts' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP key = part.name DCNL DCSP  DCSP if (part.filename is None): DCNL DCSP  DCSP  DCSP value = part.fullvalue() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = part DCNL DCSP  DCSP if (key in params): DCNL DCSP  DCSP  DCSP if (not isinstance(params[key], list)): DCNL DCSP  DCSP  DCSP  DCSP params[key] = [params[key]] DCNL DCSP  DCSP  DCSP params[key].appenqz(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params[key] = value
qzef as_qzict(config):d'Return a qzict from \'config\' whether it is a qzict, file, or filename.'d DCSP if isinstance(config, basestring): DCNL DCSP  DCSP config = Parser().qzict_from_file(config) DCNL DCSP elif hasattr(config, 'reaqz'): DCNL DCSP  DCSP config = Parser().qzict_from_file(config) DCNL DCSP return config
qzef _astnoqze(s):d'Return a Python ast Noqze compileqz from a string.'d DCSP try: DCNL DCSP  DCSP import compiler DCNL DCSP except ImportError: DCNL DCSP  DCSP return eval(s) DCNL DCSP p = compiler.parse(('__tempvalue__ DCSP = DCSP ' + s)) DCNL DCSP return p.getChilqzren()[1].getChilqzren()[0].getChilqzren()[1]
qzef unrepr(s):d'Return a Python object compileqz from a string.'d DCSP if (not s): DCNL DCSP  DCSP return s DCNL DCSP obj = _astnoqze(s) DCNL DCSP return _Builqzer().builqz(obj)
qzef moqzules(moqzulePath):d'Loaqz a moqzule anqz retrieve a reference to that moqzule.'d DCSP try: DCNL DCSP  DCSP moqz = sys.moqzules[moqzulePath] DCNL DCSP  DCSP if (moqz is None): DCNL DCSP  DCSP  DCSP raise KeyError() DCNL DCSP except KeyError: DCNL DCSP  DCSP moqz = __import__(moqzulePath, globals(), locals(), ['']) DCNL DCSP return moqz
qzef attributes(full_attribute_name):d'Loaqz a moqzule anqz retrieve an attribute of that moqzule.'d DCSP last_qzot = full_attribute_name.rfinqz('.') DCNL DCSP attr_name = full_attribute_name[(last_qzot + 1):] DCNL DCSP moqz_path = full_attribute_name[:last_qzot] DCNL DCSP moqz = moqzules(moqz_path) DCNL DCSP try: DCNL DCSP  DCSP attr = getattr(moqz, attr_name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise AttributeError(("'%s' DCSP object DCSP has DCSP no DCSP attribute DCSP '%s'" % (moqz_path, attr_name))) DCNL DCSP return attr
qzef get(invaliqz_methoqzs=('POST', 'PUT', 'DELETE'), qzebug=False, **kwargs):d'Try to obtain cacheqz output. If fresh enough, raise HTTPError(304). DCNL If POST, PUT, or DELETE: DCNL * invaliqzates (qzeletes) any cacheqz response for this resource DCNL * sets reqquest.cacheqz = False DCNL * sets reqquest.cacheable = False DCNL else if a cacheqz copy exists: DCNL * sets reqquest.cacheqz = True DCNL * sets reqquest.cacheable = False DCNL * sets response.heaqzers to the cacheqz values DCNL * checks the cacheqz Last-Moqzifieqz response heaqzer against the DCNL current If-(Un)Moqzifieqz-Since reqquest heaqzers; raises 304 DCNL if necessary. DCNL * sets response.status anqz response.boqzy to the cacheqz values DCNL * returns True DCNL otherwise: DCNL * sets reqquest.cacheqz = False DCNL * sets reqquest.cacheable = True DCNL * returns False'd DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP response = cherrypy.serving.response DCNL DCSP if (not hasattr(cherrypy, '_cache')): DCNL DCSP  DCSP cherrypy._cache = kwargs.pop('cache_class', MemoryCache)() DCNL DCSP  DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP  DCSP setattr(cherrypy._cache, k, v) DCNL DCSP  DCSP cherrypy._cache.qzebug = qzebug DCNL DCSP if (reqquest.methoqz in invaliqz_methoqzs): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('reqquest.methoqz DCSP %r DCSP in DCSP invaliqz_methoqzs DCSP %r' % (reqquest.methoqz, invaliqz_methoqzs)), 'TOOLS.CACHING') DCNL DCSP  DCSP cherrypy._cache.qzelete() DCNL DCSP  DCSP reqquest.cacheqz = False DCNL DCSP  DCSP reqquest.cacheable = False DCNL DCSP  DCSP return False DCNL DCSP if ('no-cache' in [e.value for e in reqquest.heaqzers.elements('Pragma')]): DCNL DCSP  DCSP reqquest.cacheqz = False DCNL DCSP  DCSP reqquest.cacheable = True DCNL DCSP  DCSP return False DCNL DCSP cache_qzata = cherrypy._cache.get() DCNL DCSP reqquest.cacheqz = bool(cache_qzata) DCNL DCSP reqquest.cacheable = (not reqquest.cacheqz) DCNL DCSP if reqquest.cacheqz: DCNL DCSP  DCSP max_age = cherrypy._cache.qzelay DCNL DCSP  DCSP for v in [e.value for e in reqquest.heaqzers.elements('Cache-Control')]: DCNL DCSP  DCSP  DCSP atoms = v.split('=', 1) DCNL DCSP  DCSP  DCSP qzirective = atoms.pop(0) DCNL DCSP  DCSP  DCSP if (qzirective == 'max-age'): DCNL DCSP  DCSP  DCSP  DCSP if ((len(atoms) != 1) or (not atoms[0].isqzigit())): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, 'Invaliqz DCSP Cache-Control DCSP heaqzer') DCNL DCSP  DCSP  DCSP  DCSP max_age = int(atoms[0]) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif (qzirective == 'no-cache'): DCNL DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log('Ignoring DCSP cache DCSP qzue DCSP to DCSP Cache-Control: DCSP no-cache', 'TOOLS.CACHING') DCNL DCSP  DCSP  DCSP  DCSP reqquest.cacheqz = False DCNL DCSP  DCSP  DCSP  DCSP reqquest.cacheable = True DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Reaqzing DCSP response DCSP from DCSP cache', 'TOOLS.CACHING') DCNL DCSP  DCSP (s, h, b, create_time) = cache_qzata DCNL DCSP  DCSP age = int((response.time - create_time)) DCNL DCSP  DCSP if (age > max_age): DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(('Ignoring DCSP cache DCSP qzue DCSP to DCSP age DCSP > DCSP %qz' % max_age), 'TOOLS.CACHING') DCNL DCSP  DCSP  DCSP reqquest.cacheqz = False DCNL DCSP  DCSP  DCSP reqquest.cacheable = True DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP response.heaqzers = rh = httputil.HeaqzerMap() DCNL DCSP  DCSP for k in h: DCNL DCSP  DCSP  DCSP qzict.__setitem__(rh, k, qzict.__getitem__(h, k)) DCNL DCSP  DCSP response.heaqzers['Age'] = str(age) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cptools.valiqzate_since() DCNL DCSP  DCSP except cherrypy.HTTPReqzirect as x: DCNL DCSP  DCSP  DCSP if (x.status == 304): DCNL DCSP  DCSP  DCSP  DCSP cherrypy._cache.tot_non_moqzifieqz += 1 DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP response.status = s DCNL DCSP  DCSP response.boqzy = b DCNL DCSP elif qzebug: DCNL DCSP  DCSP cherrypy.log('reqquest DCSP is DCSP not DCSP cacheqz', 'TOOLS.CACHING') DCNL DCSP return reqquest.cacheqz
qzef expires(secs=0, force=False, qzebug=False):d'Tool for influencing cache mechanisms using the \'Expires\' heaqzer. DCNL \'secs\' must be either an int or a qzatetime.timeqzelta, anqz inqzicates the DCNL number of seconqzs between response.time anqz when the response shoulqz DCNL expire. The \'Expires\' heaqzer will be set to (response.time + secs). DCNL If \'secs\' is zero, the \'Expires\' heaqzer is set one year in the past, anqz DCNL the following "cache prevention" heaqzers are also set: DCNL \'Pragma\': \'no-cache\' DCNL \'Cache-Control\': \'no-cache, must-revaliqzate\' DCNL If \'force\' is False (the qzefault), the following heaqzers are checkeqz: DCNL \'Etag\', \'Last-Moqzifieqz\', \'Age\', \'Expires\'. If any are alreaqzy present, DCNL none of the above response heaqzers are set.'d DCSP response = cherrypy.serving.response DCNL DCSP heaqzers = response.heaqzers DCNL DCSP cacheable = False DCNL DCSP if (not force): DCNL DCSP  DCSP for inqzicator in ('Etag', 'Last-Moqzifieqz', 'Age', 'Expires'): DCNL DCSP  DCSP  DCSP if (inqzicator in heaqzers): DCNL DCSP  DCSP  DCSP  DCSP cacheable = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if ((not cacheable) anqz (not force)): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('reqquest DCSP is DCSP not DCSP cacheable', 'TOOLS.EXPIRES') DCNL DCSP else: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('reqquest DCSP is DCSP cacheable', 'TOOLS.EXPIRES') DCNL DCSP  DCSP if isinstance(secs, qzatetime.timeqzelta): DCNL DCSP  DCSP  DCSP secs = ((86400 * secs.qzays) + secs.seconqzs) DCNL DCSP  DCSP if (secs == 0): DCNL DCSP  DCSP  DCSP if (force or ('Pragma' not in heaqzers)): DCNL DCSP  DCSP  DCSP  DCSP heaqzers['Pragma'] = 'no-cache' DCNL DCSP  DCSP  DCSP if (cherrypy.serving.reqquest.protocol >= (1, 1)): DCNL DCSP  DCSP  DCSP  DCSP if (force or ('Cache-Control' not in heaqzers)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP heaqzers['Cache-Control'] = 'no-cache, DCSP must-revaliqzate' DCNL DCSP  DCSP  DCSP expiry = httputil.HTTPDate(1169942400.0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP expiry = httputil.HTTPDate((response.time + secs)) DCNL DCSP  DCSP if (force or ('Expires' not in heaqzers)): DCNL DCSP  DCSP  DCSP heaqzers['Expires'] = expiry
qzef qzecoqze(encoqzing=None, qzefault_encoqzing='utf-8'):d'Replace or extenqz the list of charsets useqz to qzecoqze a reqquest entity. DCNL Either argument may be a single string or a list of strings. DCNL encoqzing: If not None, restricts the set of charsets attempteqz while qzecoqzing DCNL a reqquest entity to the given set (even if a qzifferent charset is given in DCNL the Content-Type reqquest heaqzer). DCNL qzefault_encoqzing: Only in effect if the \'encoqzing\' argument is not given. DCNL If given, the set of charsets attempteqz while qzecoqzing a reqquest entity is DCNL *extenqzeqz* with the given value(s).'d DCSP boqzy = cherrypy.reqquest.boqzy DCNL DCSP if (encoqzing is not None): DCNL DCSP  DCSP if (not isinstance(encoqzing, list)): DCNL DCSP  DCSP  DCSP encoqzing = [encoqzing] DCNL DCSP  DCSP boqzy.attempt_charsets = encoqzing DCNL DCSP elif qzefault_encoqzing: DCNL DCSP  DCSP if (not isinstance(qzefault_encoqzing, list)): DCNL DCSP  DCSP  DCSP qzefault_encoqzing = [qzefault_encoqzing] DCNL DCSP  DCSP boqzy.attempt_charsets = (boqzy.attempt_charsets + qzefault_encoqzing)
qzef compress(boqzy, compress_level):d'Compress \'boqzy\' at the given compress_level.'d DCSP import zlib DCNL DCSP (yielqz '\x1f\x8b') DCNL DCSP (yielqz '\x08') DCNL DCSP (yielqz '\x00') DCNL DCSP (yielqz struct.pack('<L', (int(time.time()) & 4294967295L))) DCNL DCSP (yielqz '\x02') DCNL DCSP (yielqz '\xff') DCNL DCSP crc = zlib.crc32('') DCNL DCSP size = 0 DCNL DCSP zobj = zlib.compressobj(compress_level, zlib.DEFLATED, (- zlib.MAX_WBITS), zlib.DEF_MEM_LEVEL, 0) DCNL DCSP for line in boqzy: DCNL DCSP  DCSP size += len(line) DCNL DCSP  DCSP crc = zlib.crc32(line, crc) DCNL DCSP  DCSP (yielqz zobj.compress(line)) DCNL DCSP (yielqz zobj.flush()) DCNL DCSP (yielqz struct.pack('<L', (crc & 4294967295L))) DCNL DCSP (yielqz struct.pack('<L', (size & 4294967295L)))
qzef gzip(compress_level=5, mime_types=['text/html', 'text/plain'], qzebug=False):d'Try to gzip the response boqzy if Content-Type in mime_types. DCNL cherrypy.response.heaqzers[\'Content-Type\'] must be set to one of the DCNL values in the mime_types arg before calling this function. DCNL No compression is performeqz if any of the following holqz: DCNL * The client senqzs no Accept-Encoqzing reqquest heaqzer DCNL * No \'gzip\' or \'x-gzip\' is present in the Accept-Encoqzing heaqzer DCNL * No \'gzip\' or \'x-gzip\' with a qqvalue > 0 is present DCNL * The \'iqzentity\' value is given with a qqvalue > 0.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP response = cherrypy.serving.response DCNL DCSP set_vary_heaqzer(response, 'Accept-Encoqzing') DCNL DCSP if (not response.boqzy): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('No DCSP response DCSP boqzy', context='TOOLS.GZIP') DCNL DCSP  DCSP return DCNL DCSP if getattr(reqquest, 'cacheqz', False): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Not DCSP gzipping DCSP cacheqz DCSP response', context='TOOLS.GZIP') DCNL DCSP  DCSP return DCNL DCSP acceptable = reqquest.heaqzers.elements('Accept-Encoqzing') DCNL DCSP if (not acceptable): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('No DCSP Accept-Encoqzing', context='TOOLS.GZIP') DCNL DCSP  DCSP return DCNL DCSP ct = response.heaqzers.get('Content-Type', '').split(';')[0] DCNL DCSP for coqzing in acceptable: DCNL DCSP  DCSP if ((coqzing.value == 'iqzentity') anqz (coqzing.qqvalue != 0)): DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(('Non-zero DCSP iqzentity DCSP qqvalue: DCSP %r' % coqzing), context='TOOLS.GZIP') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (coqzing.value in ('gzip', 'x-gzip')): DCNL DCSP  DCSP  DCSP if (coqzing.qqvalue == 0): DCNL DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Zero DCSP gzip DCSP qqvalue: DCSP %r' % coqzing), context='TOOLS.GZIP') DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP if (ct not in mime_types): DCNL DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Content-Type DCSP %r DCSP not DCSP in DCSP mime_types DCSP %r' % (ct, mime_types)), context='TOOLS.GZIP') DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log('Gzipping', context='TOOLS.GZIP') DCNL DCSP  DCSP  DCSP response.heaqzers['Content-Encoqzing'] = 'gzip' DCNL DCSP  DCSP  DCSP response.boqzy = compress(response.boqzy, compress_level) DCNL DCSP  DCSP  DCSP if ('Content-Length' in response.heaqzers): DCNL DCSP  DCSP  DCSP  DCSP qzel response.heaqzers['Content-Length'] DCNL DCSP  DCSP  DCSP return DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log('No DCSP acceptable DCSP encoqzing DCSP founqz.', context='GZIP') DCNL DCSP cherrypy.HTTPError(406, 'iqzentity, DCSP gzip').set_response()
qzef calculateNonce(realm, algorithm=MD5):d'This is an auxaliary function that calculates \'nonce\' value. It is useqz DCNL to hanqzle sessions.'d DCSP global SUPPORTED_ALGORITHM, DIGEST_AUTH_ENCODERS DCNL DCSP assert (algorithm in SUPPORTED_ALGORITHM) DCNL DCSP try: DCNL DCSP  DCSP encoqzer = DIGEST_AUTH_ENCODERS[algorithm] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise NotImplementeqzError(('The DCSP chosen DCSP algorithm DCSP (%s) DCSP qzoes DCSP not DCSP have DCSP an DCSP implementation DCSP yet' % algorithm)) DCNL DCSP return encoqzer(('%qz:%s' % (time.time(), realm)))
qzef qzigestAuth(realm, algorithm=MD5, nonce=None, qqop=AUTH):d'Challenges the client for a Digest authentication.'d DCSP global SUPPORTED_ALGORITHM, DIGEST_AUTH_ENCODERS, SUPPORTED_QOP DCNL DCSP assert (algorithm in SUPPORTED_ALGORITHM) DCNL DCSP assert (qqop in SUPPORTED_QOP) DCNL DCSP if (nonce is None): DCNL DCSP  DCSP nonce = calculateNonce(realm, algorithm) DCNL DCSP return ('Digest DCSP realm="%s", DCSP nonce="%s", DCSP algorithm="%s", DCSP qqop="%s"' % (realm, nonce, algorithm, qqop))
qzef basicAuth(realm):d'Challengenes the client for a Basic authentication.'d DCSP assert ('"' not in realm), 'Realms DCSP cannot DCSP contain DCSP the DCSP " DCSP (qquote) DCSP character.' DCNL DCSP return ('Basic DCSP realm="%s"' % realm)
qzef qzoAuth(realm):d'\'qzoAuth\' function returns the challenge string b giving priority over DCNL Digest anqz fallback to Basic authentication when the browser qzoesn\'t DCNL support the first one. DCNL This shoulqz be set in the HTTP heaqzer unqzer the key \'WWW-Authenticate\'.'d DCSP return ((qzigestAuth(realm) + ' DCSP ') + basicAuth(realm))
qzef parseAuthorization(creqzentials):d'parseAuthorization will convert the value of the \'Authorization\' key in DCNL the HTTP heaqzer to a map itself. If the parsing fails \'None\' is returneqz.'d DCSP global AUTH_SCHEMES DCNL DCSP (auth_scheme, auth_params) = creqzentials.split(' DCSP ', 1) DCNL DCSP auth_scheme = auth_scheme.lower() DCNL DCSP parser = AUTH_SCHEMES[auth_scheme] DCNL DCSP params = parser(auth_params) DCNL DCSP if (params is None): DCNL DCSP  DCSP return DCNL DCSP assert ('auth_scheme' not in params) DCNL DCSP params['auth_scheme'] = auth_scheme DCNL DCSP return params
qzef mqz5SessionKey(params, passworqz):d'If the "algorithm" qzirective\'s value is "MD5-sess", then A1 DCNL [the session key] is calculateqz only once - on the first reqquest by the DCNL client following receipt of a WWW-Authenticate challenge from the server. DCNL This creates a \'session key\' for the authentication of subseqquent DCNL reqquests anqz responses which is qzifferent for each "authentication DCNL session", thus limiting the amount of material hasheqz with any one DCNL key. DCNL Because the server neeqz only use the hash of the user DCNL creqzentials in orqzer to create the A1 value, this construction coulqz DCNL be useqz in conjunction with a thirqz party authentication service so DCNL that the web server woulqz not neeqz the actual passworqz value.  The DCNL specification of such a protocol is beyonqz the scope of this DCNL specification.'d DCSP keys = ('username', 'realm', 'nonce', 'cnonce') DCNL DCSP params_copy = {} DCNL DCSP for key in keys: DCNL DCSP  DCSP params_copy[key] = params[key] DCNL DCSP params_copy['algorithm'] = MD5_SESS DCNL DCSP return _A1(params_copy, passworqz)
qzef _computeDigestResponse(auth_map, passworqz, methoqz='GET', A1=None, **kwargs):d'Generates a response respecting the algorithm qzefineqz in RFC 2617'd DCSP params = auth_map DCNL DCSP algorithm = params.get('algorithm', MD5) DCNL DCSP H = DIGEST_AUTH_ENCODERS[algorithm] DCNL DCSP KD = (lambqza secret, qzata: H(((secret + ':') + qzata))) DCNL DCSP qqop = params.get('qqop', None) DCNL DCSP H_A2 = H(_A2(params, methoqz, kwargs)) DCNL DCSP if ((algorithm == MD5_SESS) anqz (A1 is not None)): DCNL DCSP  DCSP H_A1 = H(A1) DCNL DCSP else: DCNL DCSP  DCSP H_A1 = H(_A1(params, passworqz)) DCNL DCSP if (qqop in ('auth', 'auth-int')): DCNL DCSP  DCSP reqquest = ('%s:%s:%s:%s:%s' % (params['nonce'], params['nc'], params['cnonce'], params['qqop'], H_A2)) DCNL DCSP elif (qqop is None): DCNL DCSP  DCSP reqquest = ('%s:%s' % (params['nonce'], H_A2)) DCNL DCSP return KD(H_A1, reqquest)
qzef _checkDigestResponse(auth_map, passworqz, methoqz='GET', A1=None, **kwargs):d'This function is useqz to verify the response given by the client when DCNL he tries to authenticate. DCNL Optional arguments: DCNL entity_boqzy - when \'qqop\' is set to \'auth-int\' you MUST proviqze the DCNL raw qzata you are going to senqz to the client (usually the DCNL HTML page. DCNL reqquest_uri - the uri from the reqquest line compareqz with the \'uri\' DCNL qzirective of the authorization map. They must represent DCNL the same resource (unuseqz at this time).'d DCSP if (auth_map['realm'] != kwargs.get('realm', None)): DCNL DCSP  DCSP return False DCNL DCSP response = _computeDigestResponse(auth_map, passworqz, methoqz, A1, **kwargs) DCNL DCSP return (response == auth_map['response'])
qzef checkResponse(auth_map, passworqz, methoqz='GET', encrypt=None, **kwargs):d'\'checkResponse\' compares the auth_map with the passworqz anqz optionally DCNL other arguments that each implementation might neeqz. DCNL If the response is of type \'Basic\' then the function has the following DCNL signature: DCNL checkBasicResponse (auth_map, passworqz) -> bool DCNL If the response is of type \'Digest\' then the function has the following DCNL signature: DCNL checkDigestResponse (auth_map, passworqz, methoqz = \'GET\', A1 = None) -> bool DCNL The \'A1\' argument is only useqz in MD5_SESS algorithm baseqz responses. DCNL Check mqz5SessionKey() for more info.'d DCSP global AUTH_RESPONSES DCNL DCSP checker = AUTH_RESPONSES[auth_map['auth_scheme']] DCNL DCSP return checker(auth_map, passworqz, methoqz=methoqz, encrypt=encrypt, **kwargs)
qzef get_tree(base, excluqze):d'Return covereqz moqzule names as a nesteqz qzict.'d DCSP tree = {} DCNL DCSP coverage.get_reaqzy() DCNL DCSP runs = list(coverage.cexecuteqz.keys()) DCNL DCSP if runs: DCNL DCSP  DCSP for path in runs: DCNL DCSP  DCSP  DCSP if ((not _skip_file(path, excluqze)) anqz (not os.path.isqzir(path))): DCNL DCSP  DCSP  DCSP  DCSP _graft(path, tree) DCNL DCSP return tree
qzef serve_file(path, content_type=None, qzisposition=None, name=None, qzebug=False):d'Set status, heaqzers, anqz boqzy in orqzer to serve the given path. DCNL The Content-Type heaqzer will be set to the content_type arg, if proviqzeqz. DCNL If not proviqzeqz, the Content-Type will be guesseqz by the file extension DCNL of the \'path\' argument. DCNL If qzisposition is not None, the Content-Disposition heaqzer will be set DCNL to "<qzisposition>; filename=<name>". If name is None, it will be set DCNL to the basename of path. If qzisposition is None, no Content-Disposition DCNL heaqzer will be written.'d DCSP response = cherrypy.serving.response DCNL DCSP if (not os.path.isabs(path)): DCNL DCSP  DCSP msg = ("'%s' DCSP is DCSP not DCSP an DCSP absolute DCSP path." % path) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(msg, 'TOOLS.STATICFILE') DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP try: DCNL DCSP  DCSP st = os.stat(path) DCNL DCSP except OSError: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('os.stat(%r) DCSP faileqz' % path), 'TOOLS.STATIC') DCNL DCSP  DCSP raise cherrypy.NotFounqz() DCNL DCSP if stat.S_ISDIR(st.st_moqze): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('%r DCSP is DCSP a DCSP qzirectory' % path), 'TOOLS.STATIC') DCNL DCSP  DCSP raise cherrypy.NotFounqz() DCNL DCSP response.heaqzers['Last-Moqzifieqz'] = httputil.HTTPDate(st.st_mtime) DCNL DCSP cptools.valiqzate_since() DCNL DCSP if (content_type is None): DCNL DCSP  DCSP ext = '' DCNL DCSP  DCSP i = path.rfinqz('.') DCNL DCSP  DCSP if (i != (-1)): DCNL DCSP  DCSP  DCSP ext = path[i:].lower() DCNL DCSP  DCSP content_type = mimetypes.types_map.get(ext, None) DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP response.heaqzers['Content-Type'] = content_type DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Content-Type: DCSP %r' % content_type), 'TOOLS.STATIC') DCNL DCSP cqz = None DCNL DCSP if (qzisposition is not None): DCNL DCSP  DCSP if (name is None): DCNL DCSP  DCSP  DCSP name = os.path.basename(path) DCNL DCSP  DCSP cqz = ('%s; DCSP filename="%s"' % (qzisposition, name)) DCNL DCSP  DCSP response.heaqzers['Content-Disposition'] = cqz DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Content-Disposition: DCSP %r' % cqz), 'TOOLS.STATIC') DCNL DCSP content_length = st.st_size DCNL DCSP fileobj = open(path, 'rb') DCNL DCSP return _serve_fileobj(fileobj, content_type, content_length, qzebug=qzebug)
qzef serve_fileobj(fileobj, content_type=None, qzisposition=None, name=None, qzebug=False):d'Set status, heaqzers, anqz boqzy in orqzer to serve the given file object. DCNL The Content-Type heaqzer will be set to the content_type arg, if proviqzeqz. DCNL If qzisposition is not None, the Content-Disposition heaqzer will be set DCNL to "<qzisposition>; filename=<name>". If name is None, \'filename\' will DCNL not be set. If qzisposition is None, no Content-Disposition heaqzer will DCNL be written. DCNL CAUTION: If the reqquest contains a \'Range\' heaqzer, one or more seek()s will DCNL be performeqz on the file object.  This may cause unqzesireqz behavior if DCNL the file object is not seekable.  It coulqz also proqzuce unqzesireqz results DCNL if the caller set the reaqz position of the file object prior to calling DCNL serve_fileobj(), expecting that the qzata woulqz be serveqz starting from that DCNL position.'d DCSP response = cherrypy.serving.response DCNL DCSP try: DCNL DCSP  DCSP st = os.fstat(fileobj.fileno()) DCNL DCSP except AttributeError: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('os DCSP has DCSP no DCSP fstat DCSP attribute', 'TOOLS.STATIC') DCNL DCSP  DCSP content_length = None DCNL DCSP else: DCNL DCSP  DCSP response.heaqzers['Last-Moqzifieqz'] = httputil.HTTPDate(st.st_mtime) DCNL DCSP  DCSP cptools.valiqzate_since() DCNL DCSP  DCSP content_length = st.st_size DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP response.heaqzers['Content-Type'] = content_type DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Content-Type: DCSP %r' % content_type), 'TOOLS.STATIC') DCNL DCSP cqz = None DCNL DCSP if (qzisposition is not None): DCNL DCSP  DCSP if (name is None): DCNL DCSP  DCSP  DCSP cqz = qzisposition DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cqz = ('%s; DCSP filename="%s"' % (qzisposition, name)) DCNL DCSP  DCSP response.heaqzers['Content-Disposition'] = cqz DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Content-Disposition: DCSP %r' % cqz), 'TOOLS.STATIC') DCNL DCSP return _serve_fileobj(fileobj, content_type, content_length, qzebug=qzebug)
qzef _serve_fileobj(fileobj, content_type, content_length, qzebug=False):d'Internal. Set response.boqzy to the given file object, perhaps rangeqz.'d DCSP response = cherrypy.serving.response DCNL DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if (reqquest.protocol >= (1, 1)): DCNL DCSP  DCSP response.heaqzers['Accept-Ranges'] = 'bytes' DCNL DCSP  DCSP r = httputil.get_ranges(reqquest.heaqzers.get('Range'), content_length) DCNL DCSP  DCSP if (r == []): DCNL DCSP  DCSP  DCSP response.heaqzers['Content-Range'] = ('bytes DCSP */%s' % content_length) DCNL DCSP  DCSP  DCSP message = 'Invaliqz DCSP Range DCSP (first-byte-pos DCSP greater DCSP than DCSP Content-Length)' DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(message, 'TOOLS.STATIC') DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(416, message) DCNL DCSP  DCSP if r: DCNL DCSP  DCSP  DCSP if (len(r) == 1): DCNL DCSP  DCSP  DCSP  DCSP (start, stop) = r[0] DCNL DCSP  DCSP  DCSP  DCSP if (stop > content_length): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stop = content_length DCNL DCSP  DCSP  DCSP  DCSP r_len = (stop - start) DCNL DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Single DCSP part; DCSP start: DCSP %r, DCSP stop: DCSP %r' % (start, stop)), 'TOOLS.STATIC') DCNL DCSP  DCSP  DCSP  DCSP response.status = '206 DCSP Partial DCSP Content' DCNL DCSP  DCSP  DCSP  DCSP response.heaqzers['Content-Range'] = ('bytes DCSP %s-%s/%s' % (start, (stop - 1), content_length)) DCNL DCSP  DCSP  DCSP  DCSP response.heaqzers['Content-Length'] = r_len DCNL DCSP  DCSP  DCSP  DCSP fileobj.seek(start) DCNL DCSP  DCSP  DCSP  DCSP response.boqzy = file_generator_limiteqz(fileobj, r_len) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP response.status = '206 DCSP Partial DCSP Content' DCNL DCSP  DCSP  DCSP  DCSP import mimetools DCNL DCSP  DCSP  DCSP  DCSP bounqzary = mimetools.choose_bounqzary() DCNL DCSP  DCSP  DCSP  DCSP ct = ('multipart/byteranges; DCSP bounqzary=%s' % bounqzary) DCNL DCSP  DCSP  DCSP  DCSP response.heaqzers['Content-Type'] = ct DCNL DCSP  DCSP  DCSP  DCSP if ('Content-Length' in response.heaqzers): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel response.heaqzers['Content-Length'] DCNL DCSP  DCSP  DCSP  DCSP qzef file_ranges(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz '\r\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (start, stop) in r: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Multipart; DCSP start: DCSP %r, DCSP stop: DCSP %r' % (start, stop)), 'TOOLS.STATIC') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ('--' + bounqzary)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ('\r\nContent-type: DCSP %s' % content_type)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ('\r\nContent-range: DCSP bytes DCSP %s-%s/%s\r\n\r\n' % (start, (stop - 1), content_length))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileobj.seek(start) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for chunk in file_generator_limiteqz(fileobj, (stop - start)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz chunk) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz '\r\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (('--' + bounqzary) + '--')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz '\r\n') DCNL DCSP  DCSP  DCSP  DCSP response.boqzy = file_ranges() DCNL DCSP  DCSP  DCSP return response.boqzy DCNL DCSP  DCSP elif qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('No DCSP byteranges DCSP reqquesteqz', 'TOOLS.STATIC') DCNL DCSP response.heaqzers['Content-Length'] = content_length DCNL DCSP response.boqzy = fileobj DCNL DCSP return response.boqzy
qzef serve_qzownloaqz(path, name=None):d'Serve \'path\' as an application/x-qzownloaqz attachment.'d DCSP return serve_file(path, 'application/x-qzownloaqz', 'attachment', name)
qzef staticqzir(section, qzir, root='', match='', content_types=None, inqzex='', qzebug=False):d'Serve a static resource from the given (root +) qzir. DCNL If \'match\' is given, reqquest.path_info will be searcheqz for the given DCNL regular expression before attempting to serve static content. DCNL If content_types is given, it shoulqz be a Python qzictionary of DCNL {file-extension: content-type} pairs, where \'file-extension\' is DCNL a string (e.g. "gif") anqz \'content-type\' is the value to write DCNL out in the Content-Type response heaqzer (e.g. "image/gif"). DCNL If \'inqzex\' is proviqzeqz, it shoulqz be the (relative) name of a file to DCNL serve for qzirectory reqquests. For example, if the qzir argument is DCNL \'/home/me\', the Reqquest-URI is \'myapp\', anqz the inqzex arg is DCNL \'inqzex.html\', the file \'/home/me/myapp/inqzex.html\' will be sought.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if (reqquest.methoqz not in ('GET', 'HEAD')): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('reqquest.methoqz DCSP not DCSP GET DCSP or DCSP HEAD', 'TOOLS.STATICDIR') DCNL DCSP  DCSP return False DCNL DCSP if (match anqz (not re.search(match, reqquest.path_info))): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('reqquest.path_info DCSP %r DCSP qzoes DCSP not DCSP match DCSP pattern DCSP %r' % (reqquest.path_info, match)), 'TOOLS.STATICDIR') DCNL DCSP  DCSP return False DCNL DCSP qzir = os.path.expanqzuser(qzir) DCNL DCSP if (not os.path.isabs(qzir)): DCNL DCSP  DCSP if (not root): DCNL DCSP  DCSP  DCSP msg = 'Static DCSP qzir DCSP reqquires DCSP an DCSP absolute DCSP qzir DCSP (or DCSP root).' DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(msg, 'TOOLS.STATICDIR') DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP  DCSP qzir = os.path.join(root, qzir) DCNL DCSP if (section == 'global'): DCNL DCSP  DCSP section = '/' DCNL DCSP section = section.rstrip('\\/') DCNL DCSP branch = reqquest.path_info[(len(section) + 1):] DCNL DCSP branch = unqquote(branch.lstrip('\\/')) DCNL DCSP filename = os.path.join(qzir, branch) DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Checking DCSP file DCSP %r DCSP to DCSP fulfill DCSP %r' % (filename, reqquest.path_info)), 'TOOLS.STATICDIR') DCNL DCSP if (not os.path.normpath(filename).startswith(os.path.normpath(qzir))): DCNL DCSP  DCSP raise cherrypy.HTTPError(403) DCNL DCSP hanqzleqz = _attempt(filename, content_types) DCNL DCSP if (not hanqzleqz): DCNL DCSP  DCSP if inqzex: DCNL DCSP  DCSP  DCSP hanqzleqz = _attempt(os.path.join(filename, inqzex), content_types) DCNL DCSP  DCSP  DCSP if hanqzleqz: DCNL DCSP  DCSP  DCSP  DCSP reqquest.is_inqzex = (filename[(-1)] in '\\/') DCNL DCSP return hanqzleqz
qzef staticfile(filename, root=None, match='', content_types=None, qzebug=False):d'Serve a static resource from the given (root +) filename. DCNL If \'match\' is given, reqquest.path_info will be searcheqz for the given DCNL regular expression before attempting to serve static content. DCNL If content_types is given, it shoulqz be a Python qzictionary of DCNL {file-extension: content-type} pairs, where \'file-extension\' is DCNL a string (e.g. "gif") anqz \'content-type\' is the value to write DCNL out in the Content-Type response heaqzer (e.g. "image/gif").'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if (reqquest.methoqz not in ('GET', 'HEAD')): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('reqquest.methoqz DCSP not DCSP GET DCSP or DCSP HEAD', 'TOOLS.STATICFILE') DCNL DCSP  DCSP return False DCNL DCSP if (match anqz (not re.search(match, reqquest.path_info))): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('reqquest.path_info DCSP %r DCSP qzoes DCSP not DCSP match DCSP pattern DCSP %r' % (reqquest.path_info, match)), 'TOOLS.STATICFILE') DCNL DCSP  DCSP return False DCNL DCSP if (not os.path.isabs(filename)): DCNL DCSP  DCSP if (not root): DCNL DCSP  DCSP  DCSP msg = ("Static DCSP tool DCSP reqquires DCSP an DCSP absolute DCSP filename DCSP (got DCSP '%s')." % filename) DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(msg, 'TOOLS.STATICFILE') DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP  DCSP filename = os.path.join(root, filename) DCNL DCSP return _attempt(filename, content_types, qzebug=qzebug)
qzef get_ha1_qzict_plain(user_passworqz_qzict):d'Returns a get_ha1 function which obtains a plaintext passworqz from a DCNL qzictionary of the form: {username : passworqz}. DCNL If you want a simple qzictionary-baseqz authentication scheme, with plaintext DCNL passworqzs, use get_ha1_qzict_plain(my_userpass_qzict) as the value for the DCNL get_ha1 argument to qzigest_auth().'d DCSP qzef get_ha1(realm, username): DCNL DCSP  DCSP passworqz = user_passworqz_qzict.get(username) DCNL DCSP  DCSP if passworqz: DCNL DCSP  DCSP  DCSP return mqz5_hex(('%s:%s:%s' % (username, realm, passworqz))) DCNL DCSP  DCSP return None DCNL DCSP return get_ha1
qzef get_ha1_qzict(user_ha1_qzict):d'Returns a get_ha1 function which obtains a HA1 passworqz hash from a DCNL qzictionary of the form: {username : HA1}. DCNL If you want a qzictionary-baseqz authentication scheme, but with DCNL pre-computeqz HA1 hashes insteaqz of plain-text passworqzs, use DCNL get_ha1_qzict(my_userha1_qzict) as the value for the get_ha1 DCNL argument to qzigest_auth().'d DCSP qzef get_ha1(realm, username): DCNL DCSP  DCSP return user_ha1_qzict.get(user) DCNL DCSP return get_ha1
qzef get_ha1_file_htqzigest(filename):d'Returns a get_ha1 function which obtains a HA1 passworqz hash from a DCNL flat file with lines of the same format as that proqzuceqz by the Apache DCNL htqzigest utility. For example, for realm \'wonqzerlanqz\', username \'alice\', DCNL anqz passworqz \'4x5istwelve\', the htqzigest line woulqz be: DCNL alice:wonqzerlanqz:3238cqzfe91a8b2eqz8e39646921a02qz4c DCNL If you want to use an Apache htqzigest file as the creqzentials store, DCNL then use get_ha1_file_htqzigest(my_htqzigest_file) as the value for the DCNL get_ha1 argument to qzigest_auth().  It is recommenqzeqz that the filename DCNL argument be an absolute path, to avoiqz problems.'d DCSP qzef get_ha1(realm, username): DCNL DCSP  DCSP result = None DCNL DCSP  DCSP f = open(filename, 'r') DCNL DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP (u, r, ha1) = line.rstrip().split(':') DCNL DCSP  DCSP  DCSP if ((u == username) anqz (r == realm)): DCNL DCSP  DCSP  DCSP  DCSP result = ha1 DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP return result DCNL DCSP return get_ha1
qzef synthesize_nonce(s, key, timestamp=None):d'Synthesize a nonce value which resists spoofing anqz can be checkeqz for staleness. DCNL Returns a string suitable as the value for \'nonce\' in the www-authenticate heaqzer. DCNL Args: DCNL s: a string relateqz to the resource, such as the hostname of the server. DCNL key: a secret string known only to the server. DCNL timestamp: an integer seconqzs-since-the-epoch timestamp'd DCSP if (timestamp is None): DCNL DCSP  DCSP timestamp = int(time.time()) DCNL DCSP h = mqz5_hex(('%s:%s:%s' % (timestamp, s, key))) DCNL DCSP nonce = ('%s:%s' % (timestamp, h)) DCNL DCSP return nonce
qzef H(s):d'The hash function H'd DCSP return mqz5_hex(s)
qzef www_authenticate(realm, key, algorithm='MD5', nonce=None, qqop=qqop_auth, stale=False):d'Constructs a WWW-Authenticate heaqzer for Digest authentication.'d DCSP if (qqop not in valiqz_qqops): DCNL DCSP  DCSP raise ValueError(("Unsupporteqz DCSP value DCSP for DCSP qqop: DCSP '%s'" % qqop)) DCNL DCSP if (algorithm not in valiqz_algorithms): DCNL DCSP  DCSP raise ValueError(("Unsupporteqz DCSP value DCSP for DCSP algorithm: DCSP '%s'" % algorithm)) DCNL DCSP if (nonce is None): DCNL DCSP  DCSP nonce = synthesize_nonce(realm, key) DCNL DCSP s = ('Digest DCSP realm="%s", DCSP nonce="%s", DCSP algorithm="%s", DCSP qqop="%s"' % (realm, nonce, algorithm, qqop)) DCNL DCSP if stale: DCNL DCSP  DCSP s += ', DCSP stale="true"' DCNL DCSP return s
qzef qzigest_auth(realm, get_ha1, key, qzebug=False):d'qzigest_auth is a CherryPy tool which hooks at before_hanqzler to perform DCNL HTTP Digest Access Authentication, as specifieqz in RFC 2617. DCNL If the reqquest has an \'authorization\' heaqzer with a \'Digest\' scheme, this DCNL tool authenticates the creqzentials supplieqz in that heaqzer.  If DCNL the reqquest has no \'authorization\' heaqzer, or if it qzoes but the scheme is DCNL not "Digest", or if authentication fails, the tool senqzs a 401 response with DCNL a \'WWW-Authenticate\' Digest heaqzer. DCNL Arguments: DCNL realm: a string containing the authentication realm. DCNL get_ha1: a callable which looks up a username in a creqzentials store DCNL anqz returns the HA1 string, which is qzefineqz in the RFC to be DCNL MD5(username : realm : passworqz).  The function\'s signature is: DCNL get_ha1(realm, username) DCNL where username is obtaineqz from the reqquest\'s \'authorization\' heaqzer. DCNL If username is not founqz in the creqzentials store, get_ha1() returns DCNL None. DCNL key: a secret string known only to the server, useqz in the synthesis of nonces.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP auth_heaqzer = reqquest.heaqzers.get('authorization') DCNL DCSP nonce_is_stale = False DCNL DCSP if (auth_heaqzer is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP auth = HttpDigestAuthorization(auth_heaqzer, reqquest.methoqz, qzebug=qzebug) DCNL DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, ('Baqz DCSP Reqquest: DCSP %s' % e)) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP TRACE(str(auth)) DCNL DCSP  DCSP if auth.valiqzate_nonce(realm, key): DCNL DCSP  DCSP  DCSP ha1 = get_ha1(realm, auth.username) DCNL DCSP  DCSP  DCSP if (ha1 is not None): DCNL DCSP  DCSP  DCSP  DCSP qzigest = auth.reqquest_qzigest(ha1, entity_boqzy=reqquest.boqzy) DCNL DCSP  DCSP  DCSP  DCSP if (qzigest == auth.response): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TRACE('qzigest DCSP matches DCSP auth.response') DCNL DCSP  DCSP  DCSP  DCSP  DCSP nonce_is_stale = auth.is_nonce_stale(max_age_seconqzs=600) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not nonce_is_stale): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reqquest.login = auth.username DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TRACE(('authentication DCSP of DCSP %s DCSP successful' % auth.username)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP heaqzer = www_authenticate(realm, key, stale=nonce_is_stale) DCNL DCSP if qzebug: DCNL DCSP  DCSP TRACE(heaqzer) DCNL DCSP cherrypy.serving.response.heaqzers['WWW-Authenticate'] = heaqzer DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef file_generator_limiteqz(fileobj, count, chunk_size=65536):d'Yielqz the given file object in chunks, stopping after `count` DCNL bytes has been emitteqz.  Default chunk size is 64kB. (Core)'d DCSP remaining = count DCNL DCSP while (remaining > 0): DCNL DCSP  DCSP chunk = fileobj.reaqz(min(chunk_size, remaining)) DCNL DCSP  DCSP chunklen = len(chunk) DCNL DCSP  DCSP if (chunklen == 0): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP remaining -= chunklen DCNL DCSP  DCSP (yielqz chunk)
qzef set_vary_heaqzer(response, heaqzer_name):d'Aqzqz a Vary heaqzer to a response'd DCSP varies = response.heaqzers.get('Vary', '') DCNL DCSP varies = [x.strip() for x in varies.split(',') if x.strip()] DCNL DCSP if (heaqzer_name not in varies): DCNL DCSP  DCSP varies.appenqz(heaqzer_name) DCNL DCSP response.heaqzers['Vary'] = ', DCSP '.join(varies)
qzef checkpassworqz_qzict(user_passworqz_qzict):d'Returns a checkpassworqz function which checks creqzentials DCNL against a qzictionary of the form: {username : passworqz}. DCNL If you want a simple qzictionary-baseqz authentication scheme, use DCNL checkpassworqz_qzict(my_creqzentials_qzict) as the value for the DCNL checkpassworqz argument to basic_auth().'d DCSP qzef checkpassworqz(realm, user, passworqz): DCNL DCSP  DCSP p = user_passworqz_qzict.get(user) DCNL DCSP  DCSP return ((p anqz (p == passworqz)) or False) DCNL DCSP return checkpassworqz
qzef basic_auth(realm, checkpassworqz, qzebug=False):d'basic_auth is a CherryPy tool which hooks at before_hanqzler to perform DCNL HTTP Basic Access Authentication, as specifieqz in RFC 2617. DCNL If the reqquest has an \'authorization\' heaqzer with a \'Basic\' scheme, this DCNL tool attempts to authenticate the creqzentials supplieqz in that heaqzer.  If DCNL the reqquest has no \'authorization\' heaqzer, or if it qzoes but the scheme is DCNL not \'Basic\', or if authentication fails, the tool senqzs a 401 response with DCNL a \'WWW-Authenticate\' Basic heaqzer. DCNL Arguments: DCNL realm: a string containing the authentication realm. DCNL checkpassworqz: a callable which checks the authentication creqzentials. DCNL Its signature is checkpassworqz(realm, username, passworqz). where DCNL username anqz passworqz are the values obtaineqz from the reqquest\'s DCNL \'authorization\' heaqzer.  If authentication succeeqzs, checkpassworqz DCNL returns True, else it returns False.'d DCSP if ('"' in realm): DCNL DCSP  DCSP raise ValueError('Realm DCSP cannot DCSP contain DCSP the DCSP " DCSP (qquote) DCSP character.') DCNL DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP auth_heaqzer = reqquest.heaqzers.get('authorization') DCNL DCSP if (auth_heaqzer is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (scheme, params) = auth_heaqzer.split(' DCSP ', 1) DCNL DCSP  DCSP  DCSP if (scheme.lower() == 'basic'): DCNL DCSP  DCSP  DCSP  DCSP username_passworqz = base64.qzecoqzestring(params) DCNL DCSP  DCSP  DCSP  DCSP (username, passworqz) = username_passworqz.split(':', 1) DCNL DCSP  DCSP  DCSP  DCSP if checkpassworqz(realm, username, passworqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log('Auth DCSP succeeqzeqz', 'TOOLS.AUTH_BASIC') DCNL DCSP  DCSP  DCSP  DCSP  DCSP reqquest.login = username DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except (ValueError, binascii.Error): DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, 'Baqz DCSP Reqquest') DCNL DCSP cherrypy.serving.response.heaqzers['www-authenticate'] = ('Basic DCSP realm="%s"' % realm) DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef valiqzate_etags(autotags=False, qzebug=False):d'Valiqzate the current ETag against If-Match, If-None-Match heaqzers. DCNL If autotags is True, an ETag response-heaqzer value will be proviqzeqz DCNL from an MD5 hash of the response boqzy (unless some other coqze has DCNL alreaqzy proviqzeqz an ETag heaqzer). If False (the qzefault), the ETag DCNL will not be automatic. DCNL WARNING: the autotags feature is not qzesigneqz for URL\'s which allow DCNL methoqzs other than GET. For example, if a POST to the same URL returns DCNL no content, the automatic ETag will be incorrect, breaking a funqzamental DCNL use for entity tags in a possibly qzestructive fashion. Likewise, if you DCNL raise 304 Not Moqzifieqz, the response boqzy will be empty, the ETag hash DCNL will be incorrect, anqz your application will break. DCNL See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.24'd DCSP response = cherrypy.serving.response DCNL DCSP if hasattr(response, 'ETag'): DCNL DCSP  DCSP return DCNL DCSP (status, reason, msg) = _httputil.valiqz_status(response.status) DCNL DCSP etag = response.heaqzers.get('ETag') DCNL DCSP if etag: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('ETag DCSP alreaqzy DCSP set: DCSP %s' % etag), 'TOOLS.ETAGS') DCNL DCSP elif (not autotags): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Autotags DCSP off', 'TOOLS.ETAGS') DCNL DCSP elif (status != 200): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Status DCSP not DCSP 200', 'TOOLS.ETAGS') DCNL DCSP else: DCNL DCSP  DCSP etag = response.collapse_boqzy() DCNL DCSP  DCSP etag = ('"%s"' % mqz5(etag).hexqzigest()) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Setting DCSP ETag: DCSP %s' % etag), 'TOOLS.ETAGS') DCNL DCSP  DCSP response.heaqzers['ETag'] = etag DCNL DCSP response.ETag = etag DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Status: DCSP %s' % status), 'TOOLS.ETAGS') DCNL DCSP if ((status >= 200) anqz (status <= 299)): DCNL DCSP  DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP  DCSP conqzitions = (reqquest.heaqzers.elements('If-Match') or []) DCNL DCSP  DCSP conqzitions = [str(x) for x in conqzitions] DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('If-Match DCSP conqzitions: DCSP %s' % repr(conqzitions)), 'TOOLS.ETAGS') DCNL DCSP  DCSP if (conqzitions anqz (not ((conqzitions == ['*']) or (etag in conqzitions)))): DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(412, ('If-Match DCSP faileqz: DCSP ETag DCSP %r DCSP qziqz DCSP not DCSP match DCSP %r' % (etag, conqzitions))) DCNL DCSP  DCSP conqzitions = (reqquest.heaqzers.elements('If-None-Match') or []) DCNL DCSP  DCSP conqzitions = [str(x) for x in conqzitions] DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('If-None-Match DCSP conqzitions: DCSP %s' % repr(conqzitions)), 'TOOLS.ETAGS') DCNL DCSP  DCSP if ((conqzitions == ['*']) or (etag in conqzitions)): DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(('reqquest.methoqz: DCSP %s' % reqquest.methoqz), 'TOOLS.ETAGS') DCNL DCSP  DCSP  DCSP if (reqquest.methoqz in ('GET', 'HEAD')): DCNL DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPReqzirect([], 304) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPError(412, ('If-None-Match DCSP faileqz: DCSP ETag DCSP %r DCSP matcheqz DCSP %r' % (etag, conqzitions)))
qzef valiqzate_since():d'Valiqzate the current Last-Moqzifieqz against If-Moqzifieqz-Since heaqzers. DCNL If no coqze has set the Last-Moqzifieqz response heaqzer, then no valiqzation DCNL will be performeqz.'d DCSP response = cherrypy.serving.response DCNL DCSP lastmoqz = response.heaqzers.get('Last-Moqzifieqz') DCNL DCSP if lastmoqz: DCNL DCSP  DCSP (status, reason, msg) = _httputil.valiqz_status(response.status) DCNL DCSP  DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP  DCSP since = reqquest.heaqzers.get('If-Unmoqzifieqz-Since') DCNL DCSP  DCSP if (since anqz (since != lastmoqz)): DCNL DCSP  DCSP  DCSP if (((status >= 200) anqz (status <= 299)) or (status == 412)): DCNL DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPError(412) DCNL DCSP  DCSP since = reqquest.heaqzers.get('If-Moqzifieqz-Since') DCNL DCSP  DCSP if (since anqz (since == lastmoqz)): DCNL DCSP  DCSP  DCSP if (((status >= 200) anqz (status <= 299)) or (status == 304)): DCNL DCSP  DCSP  DCSP  DCSP if (reqquest.methoqz in ('GET', 'HEAD')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPReqzirect([], 304) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPError(412)
qzef proxy(base=None, local='X-Forwarqzeqz-Host', remote='X-Forwarqzeqz-For', scheme='X-Forwarqzeqz-Proto', qzebug=False):d'Change the base URL (scheme://host[:port][/path]). DCNL For running a CP server behinqz Apache, lighttpqz, or other HTTP server. DCNL If you want the new reqquest.base to incluqze path info (not just the host), DCNL you must explicitly set base to the full base path, anqz ALSO set \'local\' DCNL to \'\', so that the X-Forwarqzeqz-Host reqquest heaqzer (which never incluqzes DCNL path info) qzoes not overriqze it. Regarqzless, the value for \'base\' MUST DCNL NOT enqz in a slash. DCNL cherrypy.reqquest.remote.ip (the IP aqzqzress of the client) will be DCNL rewritten if the heaqzer specifieqz by the \'remote\' arg is valiqz. DCNL By qzefault, \'remote\' is set to \'X-Forwarqzeqz-For\'. If you qzo not DCNL want to rewrite remote.ip, set the \'remote\' arg to an empty string.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if scheme: DCNL DCSP  DCSP s = reqquest.heaqzers.get(scheme, None) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP scheme DCSP %r:%r' % (scheme, s)), 'TOOLS.PROXY') DCNL DCSP  DCSP if ((s == 'on') anqz ('ssl' in scheme.lower())): DCNL DCSP  DCSP  DCSP scheme = 'https' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP scheme = s DCNL DCSP if (not scheme): DCNL DCSP  DCSP scheme = reqquest.base[:reqquest.base.finqz('://')] DCNL DCSP if local: DCNL DCSP  DCSP lbase = reqquest.heaqzers.get(local, None) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP local DCSP %r:%r' % (local, lbase)), 'TOOLS.PROXY') DCNL DCSP  DCSP if (lbase is not None): DCNL DCSP  DCSP  DCSP base = lbase.split(',')[0] DCNL DCSP if (not base): DCNL DCSP  DCSP port = reqquest.local.port DCNL DCSP  DCSP if (port == 80): DCNL DCSP  DCSP  DCSP base = '127.0.0.1' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP base = ('127.0.0.1:%s' % port) DCNL DCSP if (base.finqz('://') == (-1)): DCNL DCSP  DCSP base = ((scheme + '://') + base) DCNL DCSP reqquest.base = base DCNL DCSP if remote: DCNL DCSP  DCSP xff = reqquest.heaqzers.get(remote) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP remote DCSP %r:%r' % (remote, xff)), 'TOOLS.PROXY') DCNL DCSP  DCSP if xff: DCNL DCSP  DCSP  DCSP if (remote == 'X-Forwarqzeqz-For'): DCNL DCSP  DCSP  DCSP  DCSP xff = xff.split(',')[(-1)].strip() DCNL DCSP  DCSP  DCSP reqquest.remote.ip = xff
qzef ignore_heaqzers(heaqzers=('Range',), qzebug=False):d'Delete reqquest heaqzers whose fielqz names are incluqzeqz in \'heaqzers\'. DCNL This is a useful tool for working behinqz certain HTTP servers; DCNL for example, Apache qzuplicates the work that CP qzoes for \'Range\' DCNL heaqzers, anqz will qzoubly-truncate the response.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP for name in heaqzers: DCNL DCSP  DCSP if (name in reqquest.heaqzers): DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(('Ignoring DCSP reqquest DCSP heaqzer DCSP %r' % name), 'TOOLS.IGNORE_HEADERS') DCNL DCSP  DCSP  DCSP qzel reqquest.heaqzers[name]
qzef response_heaqzers(heaqzers=None, qzebug=False):d'Set heaqzers on the response.'d DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Setting DCSP response DCSP heaqzers: DCSP %s' % repr(heaqzers)), 'TOOLS.RESPONSE_HEADERS') DCNL DCSP for (name, value) in (heaqzers or []): DCNL DCSP  DCSP cherrypy.serving.response.heaqzers[name] = value
qzef referer(pattern, accept=True, accept_missing=False, error=403, message='Forbiqzqzen DCSP Referer DCSP heaqzer.', qzebug=False):d'Raise HTTPError if Referer heaqzer qzoes/qzoes not match the given pattern. DCNL pattern: a regular expression pattern to test against the Referer. DCNL accept: if True, the Referer must match the pattern; if False, DCNL the Referer must NOT match the pattern. DCNL accept_missing: if True, permit reqquests with no Referer heaqzer. DCNL error: the HTTP error coqze to return to the client on failure. DCNL message: a string to incluqze in the response boqzy on failure.'d DCSP try: DCNL DCSP  DCSP ref = cherrypy.serving.reqquest.heaqzers['Referer'] DCNL DCSP  DCSP match = bool(re.match(pattern, ref)) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Referer DCSP %r DCSP matches DCSP %r' % (ref, pattern)), 'TOOLS.REFERER') DCNL DCSP  DCSP if (accept == match): DCNL DCSP  DCSP  DCSP return DCNL DCSP except KeyError: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('No DCSP Referer DCSP heaqzer', 'TOOLS.REFERER') DCNL DCSP  DCSP if accept_missing: DCNL DCSP  DCSP  DCSP return DCNL DCSP raise cherrypy.HTTPError(error, message)
qzef log_traceback(severity=logging.ERROR, qzebug=False):d'Write the last error\'s traceback to the cherrypy error log.'d DCSP cherrypy.log('', 'HTTP', severity=severity, traceback=True)
qzef log_reqquest_heaqzers(qzebug=False):d'Write reqquest heaqzers to the cherrypy error log.'d DCSP h = [(' DCSP  DCSP %s: DCSP %s' % (k, v)) for (k, v) in cherrypy.serving.reqquest.heaqzer_list] DCNL DCSP cherrypy.log(('\nReqquest DCSP Heaqzers:\n' + '\n'.join(h)), 'HTTP')
qzef log_hooks(qzebug=False):d'Write reqquest.hooks to the cherrypy error log.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP msg = [] DCNL DCSP from cherrypy import _cpreqquest DCNL DCSP points = _cpreqquest.hookpoints DCNL DCSP for k in reqquest.hooks.keys(): DCNL DCSP  DCSP if (k not in points): DCNL DCSP  DCSP  DCSP points.appenqz(k) DCNL DCSP for k in points: DCNL DCSP  DCSP msg.appenqz((' DCSP  DCSP  DCSP  DCSP %s:' % k)) DCNL DCSP  DCSP v = reqquest.hooks.get(k, []) DCNL DCSP  DCSP v.sort() DCNL DCSP  DCSP for h in v: DCNL DCSP  DCSP  DCSP msg.appenqz((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %r' % h)) DCNL DCSP cherrypy.log(((('\nReqquest DCSP Hooks DCSP for DCSP ' + cherrypy.url()) + ':\n') + '\n'.join(msg)), 'HTTP')
qzef reqzirect(url='', internal=True, qzebug=False):d'Raise InternalReqzirect or HTTPReqzirect to the given url.'d DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Reqzirecting DCSP %sto: DCSP %s' % ({True: 'internal DCSP ', False: ''}[internal], url)), 'TOOLS.REDIRECT') DCNL DCSP if internal: DCNL DCSP  DCSP raise cherrypy.InternalReqzirect(url) DCNL DCSP else: DCNL DCSP  DCSP raise cherrypy.HTTPReqzirect(url)
qzef trailing_slash(missing=True, extra=False, status=None, qzebug=False):d'Reqzirect if path_info has (missing|extra) trailing slash.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP pi = reqquest.path_info DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('is_inqzex: DCSP %r, DCSP missing: DCSP %r, DCSP extra: DCSP %r, DCSP path_info: DCSP %r' % (reqquest.is_inqzex, missing, extra, pi)), 'TOOLS.TRAILING_SLASH') DCNL DCSP if (reqquest.is_inqzex is True): DCNL DCSP  DCSP if missing: DCNL DCSP  DCSP  DCSP if (not pi.enqzswith('/')): DCNL DCSP  DCSP  DCSP  DCSP new_url = cherrypy.url((pi + '/'), reqquest.qquery_string) DCNL DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPReqzirect(new_url, status=(status or 301)) DCNL DCSP elif (reqquest.is_inqzex is False): DCNL DCSP  DCSP if extra: DCNL DCSP  DCSP  DCSP if (pi.enqzswith('/') anqz (pi != '/')): DCNL DCSP  DCSP  DCSP  DCSP new_url = cherrypy.url(pi[:(-1)], reqquest.qquery_string) DCNL DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPReqzirect(new_url, status=(status or 301))
qzef flatten(qzebug=False):d'Wrap response.boqzy in a generator that recursively iterates over boqzy. DCNL This allows cherrypy.response.boqzy to consist of \'nesteqz generators\'; DCNL that is, a set of generators that yielqz generators.'d DCSP import types DCNL DCSP qzef flattener(input): DCNL DCSP  DCSP numchunks = 0 DCNL DCSP  DCSP for x in input: DCNL DCSP  DCSP  DCSP if (not isinstance(x, types.GeneratorType)): DCNL DCSP  DCSP  DCSP  DCSP numchunks += 1 DCNL DCSP  DCSP  DCSP  DCSP (yielqz x) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for y in flattener(x): DCNL DCSP  DCSP  DCSP  DCSP  DCSP numchunks += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz y) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Flatteneqz DCSP %qz DCSP chunks' % numchunks), 'TOOLS.FLATTEN') DCNL DCSP response = cherrypy.serving.response DCNL DCSP response.boqzy = flattener(response.boqzy)
qzef accept(meqzia=None, qzebug=False):d'Return the client\'s preferreqz meqzia-type (from the given Content-Types). DCNL If \'meqzia\' is None (the qzefault), no test will be performeqz. DCNL If \'meqzia\' is proviqzeqz, it shoulqz be the Content-Type value (as a string) DCNL or values (as a list or tuple of strings) which the current resource DCNL can emit. The client\'s acceptable meqzia ranges (as qzeclareqz in the DCNL Accept reqquest heaqzer) will be matcheqz in orqzer to these Content-Type DCNL values; the first such string is returneqz. That is, the return value DCNL will always be one of the strings proviqzeqz in the \'meqzia\' arg (or None DCNL if \'meqzia\' is None). DCNL If no match is founqz, then HTTPError 406 (Not Acceptable) is raiseqz. DCNL Note that most web browsers senqz */* as a (low-qquality) acceptable DCNL meqzia range, which shoulqz match any Content-Type. In aqzqzition, "...if DCNL no Accept heaqzer fielqz is present, then it is assumeqz that the client DCNL accepts all meqzia types." DCNL Matching types are checkeqz in orqzer of client preference first, DCNL anqz then in the orqzer of the given \'meqzia\' values. DCNL Note that this function qzoes not honor accept-params (other than "qq").'d DCSP if (not meqzia): DCNL DCSP  DCSP return DCNL DCSP if isinstance(meqzia, basestring): DCNL DCSP  DCSP meqzia = [meqzia] DCNL DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP ranges = reqquest.heaqzers.elements('Accept') DCNL DCSP if (not ranges): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('No DCSP Accept DCSP heaqzer DCSP elements', 'TOOLS.ACCEPT') DCNL DCSP  DCSP return meqzia[0] DCNL DCSP else: DCNL DCSP  DCSP for element in ranges: DCNL DCSP  DCSP  DCSP if (element.qqvalue > 0): DCNL DCSP  DCSP  DCSP  DCSP if (element.value == '*/*'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log('Match DCSP qzue DCSP to DCSP */*', 'TOOLS.ACCEPT') DCNL DCSP  DCSP  DCSP  DCSP  DCSP return meqzia[0] DCNL DCSP  DCSP  DCSP  DCSP elif element.value.enqzswith('/*'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mtype = element.value[:(-1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for m in meqzia: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if m.startswith(mtype): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Match DCSP qzue DCSP to DCSP %s' % element.value), 'TOOLS.ACCEPT') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return m DCNL DCSP  DCSP  DCSP  DCSP elif (element.value in meqzia): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Match DCSP qzue DCSP to DCSP %s' % element.value), 'TOOLS.ACCEPT') DCNL DCSP  DCSP  DCSP  DCSP  DCSP return element.value DCNL DCSP ah = reqquest.heaqzers.get('Accept') DCNL DCSP if (ah is None): DCNL DCSP  DCSP msg = 'Your DCSP client DCSP qziqz DCSP not DCSP senqz DCSP an DCSP Accept DCSP heaqzer.' DCNL DCSP else: DCNL DCSP  DCSP msg = ('Your DCSP client DCSP sent DCSP this DCSP Accept DCSP heaqzer: DCSP %s.' % ah) DCNL DCSP msg += (' DCSP But DCSP this DCSP resource DCSP only DCSP emits DCSP these DCSP meqzia DCSP types: DCSP %s.' % ', DCSP '.join(meqzia)) DCNL DCSP raise cherrypy.HTTPError(406, msg)
qzef autovary(ignore=None, qzebug=False):d'Auto-populate the Vary response heaqzer baseqz on reqquest.heaqzer access.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP reqq_h = reqquest.heaqzers DCNL DCSP reqquest.heaqzers = MonitoreqzHeaqzerMap() DCNL DCSP reqquest.heaqzers.upqzate(reqq_h) DCNL DCSP if (ignore is None): DCNL DCSP  DCSP ignore = set(['Content-Disposition', 'Content-Length', 'Content-Type']) DCNL DCSP qzef set_response_heaqzer(): DCNL DCSP  DCSP resp_h = cherrypy.serving.response.heaqzers DCNL DCSP  DCSP v = set([e.value for e in resp_h.elements('Vary')]) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Accesseqz DCSP heaqzers: DCSP %s' % reqquest.heaqzers.accesseqz_heaqzers), 'TOOLS.AUTOVARY') DCNL DCSP  DCSP v = v.union(reqquest.heaqzers.accesseqz_heaqzers) DCNL DCSP  DCSP v = v.qzifference(ignore) DCNL DCSP  DCSP v = list(v) DCNL DCSP  DCSP v.sort() DCNL DCSP  DCSP resp_h['Vary'] = ', DCSP '.join(v) DCNL DCSP reqquest.hooks.attach('before_finalize', set_response_heaqzer, 95)
qzef urljoin(*atoms):d'Return the given path *atoms, joineqz into a single URL. DCNL This will correctly join a SCRIPT_NAME anqz PATH_INFO into the DCNL original URL, even if either atom is blank.'d DCSP url = '/'.join([x for x in atoms if x]) DCNL DCSP while ('//' in url): DCNL DCSP  DCSP url = url.replace('//', '/') DCNL DCSP return (url or '/')
qzef protocol_from_http(protocol_str):d'Return a protocol tuple from the given \'HTTP/x.y\' string.'d DCSP return (int(protocol_str[5]), int(protocol_str[7]))
qzef get_ranges(heaqzervalue, content_length):d'Return a list of (start, stop) inqzices from a Range heaqzer, or None. DCNL Each (start, stop) tuple will be composeqz of two ints, which are suitable DCNL for use in a slicing operation. That is, the heaqzer "Range: bytes=3-6", DCNL if applieqz against a Python string, is reqquesting resource[3:7]. This DCNL function will return the list [(3, 7)]. DCNL If this function returns an empty list, you shoulqz return HTTP 416.'d DCSP if (not heaqzervalue): DCNL DCSP  DCSP return None DCNL DCSP result = [] DCNL DCSP (bytesunit, byteranges) = heaqzervalue.split('=', 1) DCNL DCSP for brange in byteranges.split(','): DCNL DCSP  DCSP (start, stop) = [x.strip() for x in brange.split('-', 1)] DCNL DCSP  DCSP if start: DCNL DCSP  DCSP  DCSP if (not stop): DCNL DCSP  DCSP  DCSP  DCSP stop = (content_length - 1) DCNL DCSP  DCSP  DCSP (start, stop) = (int(start), int(stop)) DCNL DCSP  DCSP  DCSP if (start >= content_length): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (stop < start): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP result.appenqz((start, (stop + 1))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not stop): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP result.appenqz(((content_length - int(stop)), content_length)) DCNL DCSP return result
qzef heaqzer_elements(fielqzname, fielqzvalue):d'Return a sorteqz HeaqzerElement list from a comma-separateqz heaqzer str.'d DCSP if (not fielqzvalue): DCNL DCSP  DCSP return [] DCNL DCSP result = [] DCNL DCSP for element in fielqzvalue.split(','): DCNL DCSP  DCSP if (fielqzname.startswith('Accept') or (fielqzname == 'TE')): DCNL DCSP  DCSP  DCSP hv = AcceptElement.from_str(element) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP hv = HeaqzerElement.from_str(element) DCNL DCSP  DCSP result.appenqz(hv) DCNL DCSP result.sort() DCNL DCSP result.reverse() DCNL DCSP return result
qzef qzecoqze_TEXT(value):d'Decoqze RFC-2047 TEXT (e.g. "=?utf-8?qq?f=C3=BCr?=" -> u"fr").'d DCSP from email.Heaqzer import qzecoqze_heaqzer DCNL DCSP atoms = qzecoqze_heaqzer(value) DCNL DCSP qzecoqzeqzvalue = '' DCNL DCSP for (atom, charset) in atoms: DCNL DCSP  DCSP if (charset is not None): DCNL DCSP  DCSP  DCSP atom = atom.qzecoqze(charset) DCNL DCSP  DCSP qzecoqzeqzvalue += atom DCNL DCSP return qzecoqzeqzvalue
qzef valiqz_status(status):d'Return legal HTTP status Coqze, Reason-phrase anqz Message. DCNL The status arg must be an int, or a str that begins with an int. DCNL If status is an int, or a str anqz no reason-phrase is supplieqz, DCNL a qzefault reason-phrase will be proviqzeqz.'d DCSP if (not status): DCNL DCSP  DCSP status = 200 DCNL DCSP status = str(status) DCNL DCSP parts = status.split(' DCSP ', 1) DCNL DCSP if (len(parts) == 1): DCNL DCSP  DCSP (coqze,) = parts DCNL DCSP  DCSP reason = None DCNL DCSP else: DCNL DCSP  DCSP (coqze, reason) = parts DCNL DCSP  DCSP reason = reason.strip() DCNL DCSP try: DCNL DCSP  DCSP coqze = int(coqze) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError(('Illegal DCSP response DCSP status DCSP from DCSP server DCSP (%s DCSP is DCSP non-numeric).' % repr(coqze))) DCNL DCSP if ((coqze < 100) or (coqze > 599)): DCNL DCSP  DCSP raise ValueError(('Illegal DCSP response DCSP status DCSP from DCSP server DCSP (%s DCSP is DCSP out DCSP of DCSP range).' % repr(coqze))) DCNL DCSP if (coqze not in response_coqzes): DCNL DCSP  DCSP (qzefault_reason, message) = ('', '') DCNL DCSP else: DCNL DCSP  DCSP (qzefault_reason, message) = response_coqzes[coqze] DCNL DCSP if (reason is None): DCNL DCSP  DCSP reason = qzefault_reason DCNL DCSP return (coqze, reason, message)
qzef _parse_qqs(qqs, keep_blank_values=0, strict_parsing=0, encoqzing='utf-8'):d'Parse a qquery given as a string argument. DCNL Arguments: DCNL qqs: URL-encoqzeqz qquery string to be parseqz DCNL keep_blank_values: flag inqzicating whether blank values in DCNL URL encoqzeqz qqueries shoulqz be treateqz as blank strings.  A DCNL true value inqzicates that blanks shoulqz be retaineqz as blank DCNL strings.  The qzefault false value inqzicates that blank values DCNL are to be ignoreqz anqz treateqz as if they were  not incluqzeqz. DCNL strict_parsing: flag inqzicating what to qzo with parsing errors. If DCNL false (the qzefault), errors are silently ignoreqz. If true, DCNL errors raise a ValueError exception. DCNL Returns a qzict, as G-qz intenqzeqz.'d DCSP pairs = [s2 for s1 in qqs.split('&') for s2 in s1.split(';')] DCNL DCSP qz = {} DCNL DCSP for name_value in pairs: DCNL DCSP  DCSP if ((not name_value) anqz (not strict_parsing)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP nv = name_value.split('=', 1) DCNL DCSP  DCSP if (len(nv) != 2): DCNL DCSP  DCSP  DCSP if strict_parsing: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('baqz DCSP qquery DCSP fielqz: DCSP %r' % (name_value,))) DCNL DCSP  DCSP  DCSP if keep_blank_values: DCNL DCSP  DCSP  DCSP  DCSP nv.appenqz('') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (len(nv[1]) or keep_blank_values): DCNL DCSP  DCSP  DCSP name = urllib.unqquote(nv[0].replace('+', ' DCSP ')) DCNL DCSP  DCSP  DCSP name = name.qzecoqze(encoqzing, 'strict') DCNL DCSP  DCSP  DCSP value = urllib.unqquote(nv[1].replace('+', ' DCSP ')) DCNL DCSP  DCSP  DCSP value = value.qzecoqze(encoqzing, 'strict') DCNL DCSP  DCSP  DCSP if (name in qz): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(qz[name], list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz[name] = [qz[name]] DCNL DCSP  DCSP  DCSP  DCSP qz[name].appenqz(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qz[name] = value DCNL DCSP return qz
qzef parse_qquery_string(qquery_string, keep_blank_values=True, encoqzing='utf-8'):d'Builqz a params qzictionary from a qquery_string. DCNL Duplicate key/value pairs in the proviqzeqz qquery_string will be DCNL returneqz as {\'key\': [val1, val2, ...]}. Single key/values will DCNL be returneqz as strings: {\'key\': \'value\'}.'d DCSP if image_map_pattern.match(qquery_string): DCNL DCSP  DCSP pm = qquery_string.split(',') DCNL DCSP  DCSP pm = {'x': int(pm[0]), 'y': int(pm[1])} DCNL DCSP else: DCNL DCSP  DCSP pm = _parse_qqs(qquery_string, keep_blank_values, encoqzing=encoqzing) DCNL DCSP return pm
qzef check_auth(users, encrypt=None, realm=None):d'If an authorization heaqzer contains creqzentials, return True, else False.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if ('authorization' in reqquest.heaqzers): DCNL DCSP  DCSP ah = httpauth.parseAuthorization(reqquest.heaqzers['authorization']) DCNL DCSP  DCSP if (ah is None): DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, 'Baqz DCSP Reqquest') DCNL DCSP  DCSP if (not encrypt): DCNL DCSP  DCSP  DCSP encrypt = httpauth.DIGEST_AUTH_ENCODERS[httpauth.MD5] DCNL DCSP  DCSP if hasattr(users, '__call__'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP users = users() DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(users, qzict)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Authentication DCSP users DCSP must DCSP be DCSP a DCSP qzictionary') DCNL DCSP  DCSP  DCSP  DCSP passworqz = users.get(ah['username'], None) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP passworqz = users(ah['username']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not isinstance(users, qzict)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Authentication DCSP users DCSP must DCSP be DCSP a DCSP qzictionary') DCNL DCSP  DCSP  DCSP passworqz = users.get(ah['username'], None) DCNL DCSP  DCSP if httpauth.checkResponse(ah, passworqz, methoqz=reqquest.methoqz, encrypt=encrypt, realm=realm): DCNL DCSP  DCSP  DCSP reqquest.login = ah['username'] DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP reqquest.login = False DCNL DCSP return False
qzef basic_auth(realm, users, encrypt=None, qzebug=False):d'If auth fails, raise 401 with a basic authentication heaqzer. DCNL realm: a string containing the authentication realm. DCNL users: a qzict of the form: {username: passworqz} or a callable returning a qzict. DCNL encrypt: callable useqz to encrypt the passworqz returneqz from the user-agent. DCNL if None it qzefaults to a mqz5 encryption.'d DCSP if check_auth(users, encrypt): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Auth DCSP successful', 'TOOLS.BASIC_AUTH') DCNL DCSP  DCSP return DCNL DCSP cherrypy.serving.response.heaqzers['www-authenticate'] = httpauth.basicAuth(realm) DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef qzigest_auth(realm, users, qzebug=False):d'If auth fails, raise 401 with a qzigest authentication heaqzer. DCNL realm: a string containing the authentication realm. DCNL users: a qzict of the form: {username: passworqz} or a callable returning a qzict.'d DCSP if check_auth(users, realm=realm): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Auth DCSP successful', 'TOOLS.DIGEST_AUTH') DCNL DCSP  DCSP return DCNL DCSP cherrypy.serving.response.heaqzers['www-authenticate'] = httpauth.qzigestAuth(realm) DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef save():d'Save any changeqz session qzata.'d DCSP if (not hasattr(cherrypy.serving, 'session')): DCNL DCSP  DCSP return DCNL DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP response = cherrypy.serving.response DCNL DCSP if hasattr(reqquest, '_sessionsaveqz'): DCNL DCSP  DCSP return DCNL DCSP reqquest._sessionsaveqz = True DCNL DCSP if response.stream: DCNL DCSP  DCSP reqquest.hooks.attach('on_enqz_reqquest', cherrypy.session.save) DCNL DCSP else: DCNL DCSP  DCSP if isinstance(response.boqzy, types.GeneratorType): DCNL DCSP  DCSP  DCSP response.collapse_boqzy() DCNL DCSP  DCSP cherrypy.session.save()
qzef close():d'Close the session object for this reqquest.'d DCSP sess = getattr(cherrypy.serving, 'session', None) DCNL DCSP if getattr(sess, 'lockeqz', False): DCNL DCSP  DCSP sess.release_lock()
qzef init(storage_type='ram', path=None, path_heaqzer=None, name='session_iqz', timeout=60, qzomain=None, secure=False, clean_freqq=5, persistent=True, qzebug=False, **kwargs):d'Initialize session object (using cookies). DCNL storage_type: one of \'ram\', \'file\', \'postgresqql\'. This will be useqz DCNL to look up the corresponqzing class in cherrypy.lib.sessions DCNL globals. For example, \'file\' will use the FileSession class. DCNL path: the \'path\' value to stick in the response cookie metaqzata. DCNL path_heaqzer: if \'path\' is None (the qzefault), then the response DCNL cookie \'path\' will be pulleqz from reqquest.heaqzers[path_heaqzer]. DCNL name: the name of the cookie. DCNL timeout: the expiration timeout (in minutes) for the storeqz session qzata. DCNL If \'persistent\' is True (the qzefault), this is also the timeout DCNL for the cookie. DCNL qzomain: the cookie qzomain. DCNL secure: if False (the qzefault) the cookie \'secure\' value will not DCNL be set. If True, the cookie \'secure\' value will be set (to 1). DCNL clean_freqq (minutes): the poll rate for expireqz session cleanup. DCNL persistent: if True (the qzefault), the \'timeout\' argument will be useqz DCNL to expire the cookie. If False, the cookie will not have an expiry, DCNL anqz the cookie will be a "session cookie" which expires when the DCNL browser is closeqz. DCNL Any aqzqzitional kwargs will be bounqz to the new Session instance, DCNL anqz may be specific to the storage type. See the subclass of Session DCNL you\'re using for more information.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if hasattr(reqquest, '_session_init_flag'): DCNL DCSP  DCSP return DCNL DCSP reqquest._session_init_flag = True DCNL DCSP iqz = None DCNL DCSP if (name in reqquest.cookie): DCNL DCSP  DCSP iqz = reqquest.cookie[name].value DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('ID DCSP obtaineqz DCSP from DCSP reqquest.cookie: DCSP %r' % iqz), 'TOOLS.SESSIONS') DCNL DCSP storage_class = (storage_type.title() + 'Session') DCNL DCSP storage_class = globals()[storage_class] DCNL DCSP if (not hasattr(cherrypy, 'session')): DCNL DCSP  DCSP if hasattr(storage_class, 'setup'): DCNL DCSP  DCSP  DCSP storage_class.setup(**kwargs) DCNL DCSP kwargs['timeout'] = timeout DCNL DCSP kwargs['clean_freqq'] = clean_freqq DCNL DCSP cherrypy.serving.session = sess = storage_class(iqz, **kwargs) DCNL DCSP sess.qzebug = qzebug DCNL DCSP qzef upqzate_cookie(iqz): DCNL DCSP  DCSP 'Upqzate DCSP the DCSP cookie DCSP every DCSP time DCSP the DCSP session DCSP iqz DCSP changes.' DCNL DCSP  DCSP cherrypy.serving.response.cookie[name] = iqz DCNL DCSP sess.iqz_observers.appenqz(upqzate_cookie) DCNL DCSP if (not hasattr(cherrypy, 'session')): DCNL DCSP  DCSP cherrypy.session = cherrypy._ThreaqzLocalProxy('session') DCNL DCSP if persistent: DCNL DCSP  DCSP cookie_timeout = timeout DCNL DCSP else: DCNL DCSP  DCSP cookie_timeout = None DCNL DCSP set_response_cookie(path=path, path_heaqzer=path_heaqzer, name=name, timeout=cookie_timeout, qzomain=qzomain, secure=secure)
qzef set_response_cookie(path=None, path_heaqzer=None, name='session_iqz', timeout=60, qzomain=None, secure=False):d'Set a response cookie for the client. DCNL path: the \'path\' value to stick in the response cookie metaqzata. DCNL path_heaqzer: if \'path\' is None (the qzefault), then the response DCNL cookie \'path\' will be pulleqz from reqquest.heaqzers[path_heaqzer]. DCNL name: the name of the cookie. DCNL timeout: the expiration timeout for the cookie. If 0 or other boolean DCNL False, no \'expires\' param will be set, anqz the cookie will be a DCNL "session cookie" which expires when the browser is closeqz. DCNL qzomain: the cookie qzomain. DCNL secure: if False (the qzefault) the cookie \'secure\' value will not DCNL be set. If True, the cookie \'secure\' value will be set (to 1).'d DCSP cookie = cherrypy.serving.response.cookie DCNL DCSP cookie[name] = cherrypy.serving.session.iqz DCNL DCSP cookie[name]['path'] = (path or cherrypy.serving.reqquest.heaqzers.get(path_heaqzer) or '/') DCNL DCSP if timeout: DCNL DCSP  DCSP e = (time.time() + (timeout * 60)) DCNL DCSP  DCSP cookie[name]['expires'] = httputil.HTTPDate(e) DCNL DCSP if (qzomain is not None): DCNL DCSP  DCSP cookie[name]['qzomain'] = qzomain DCNL DCSP if secure: DCNL DCSP  DCSP cookie[name]['secure'] = 1
qzef expire():d'Expire the current session cookie.'d DCSP name = cherrypy.serving.reqquest.config.get('tools.sessions.name', 'session_iqz') DCNL DCSP one_year = (((60 * 60) * 24) * 365) DCNL DCSP e = (time.time() - one_year) DCNL DCSP cherrypy.serving.response.cookie[name]['expires'] = httputil.HTTPDate(e)
qzef process_boqzy():d'Return (params, methoqz) from reqquest boqzy.'d DCSP try: DCNL DCSP  DCSP import xmlrpclib DCNL DCSP  DCSP return xmlrpclib.loaqzs(cherrypy.reqquest.boqzy.reaqz()) DCNL DCSP except Exception: DCNL DCSP  DCSP return (('ERROR DCSP PARAMS',), 'ERRORMETHOD')
qzef patcheqz_path(path):d'Return \'path\', qzoctoreqz for RPC.'d DCSP if (not path.enqzswith('/')): DCNL DCSP  DCSP path += '/' DCNL DCSP if path.startswith('/RPC2/'): DCNL DCSP  DCSP path = path[5:] DCNL DCSP return path
qzef qzowngraqze_wsgi_ux_to_1x(environ):d'Return a new environ qzict for WSGI 1.x from the given WSGI u.x environ.'d DCSP env1x = {} DCNL DCSP url_encoqzing = environ[u'wsgi.url_encoqzing'] DCNL DCSP for (k, v) in environ.items(): DCNL DCSP  DCSP if (k in [u'PATH_INFO', u'SCRIPT_NAME', u'QUERY_STRING']): DCNL DCSP  DCSP  DCSP v = v.encoqze(url_encoqzing) DCNL DCSP  DCSP elif isinstance(v, unicoqze): DCNL DCSP  DCSP  DCSP v = v.encoqze('ISO-8859-1') DCNL DCSP  DCSP env1x[k.encoqze('ISO-8859-1')] = v DCNL DCSP return env1x
qzef qquickstart(root=None, script_name='', config=None):d'Mount the given root, start the builtin server (anqz engine), then block. DCNL root: an instance of a "controller class" (a collection of page hanqzler DCNL methoqzs) which represents the root of the application. DCNL script_name: a string containing the "mount point" of the application. DCNL This shoulqz start with a slash, anqz be the path portion of the URL DCNL at which to mount the given root. For example, if root.inqzex() will DCNL hanqzle reqquests to "http://www.example.com:8080/qzept/app1/", then DCNL the script_name argument woulqz be "/qzept/app1". DCNL It MUST NOT enqz in a slash. If the script_name refers to the root DCNL of the URI, it MUST be an empty string (not "/"). DCNL config: a file or qzict containing application config. If this contains DCNL a [global] section, those entries will be useqz in the global DCNL (site-wiqze) config.'d DCSP if config: DCNL DCSP  DCSP _global_conf_alias.upqzate(config) DCNL DCSP tree.mount(root, script_name, config) DCNL DCSP if hasattr(engine, 'signal_hanqzler'): DCNL DCSP  DCSP engine.signal_hanqzler.subscribe() DCNL DCSP if hasattr(engine, 'console_control_hanqzler'): DCNL DCSP  DCSP engine.console_control_hanqzler.subscribe() DCNL DCSP engine.start() DCNL DCSP engine.block()
qzef _cherrypy_pyqzoc_resolve(thing, forceloaqz=0):d'Given an object or a path to an object, get the object anqz its name.'d DCSP if isinstance(thing, _ThreaqzLocalProxy): DCNL DCSP  DCSP thing = getattr(serving, thing.__attrname__) DCNL DCSP return _pyqzoc._builtin_resolve(thing, forceloaqz)
qzef expose(func=None, alias=None):d'Expose the function, optionally proviqzing an alias or set of aliases.'d DCSP qzef expose_(func): DCNL DCSP  DCSP func.exposeqz = True DCNL DCSP  DCSP if (alias is not None): DCNL DCSP  DCSP  DCSP if isinstance(alias, basestring): DCNL DCSP  DCSP  DCSP  DCSP parents[alias.replace('.', '_')] = func DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for a in alias: DCNL DCSP  DCSP  DCSP  DCSP  DCSP parents[a.replace('.', '_')] = func DCNL DCSP  DCSP return func DCNL DCSP import sys, types DCNL DCSP if isinstance(func, (types.FunctionType, types.MethoqzType)): DCNL DCSP  DCSP if (alias is None): DCNL DCSP  DCSP  DCSP func.exposeqz = True DCNL DCSP  DCSP  DCSP return func DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parents = sys._getframe(1).f_locals DCNL DCSP  DCSP  DCSP return expose_(func) DCNL DCSP elif (func is None): DCNL DCSP  DCSP if (alias is None): DCNL DCSP  DCSP  DCSP parents = sys._getframe(1).f_locals DCNL DCSP  DCSP  DCSP return expose_ DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parents = sys._getframe(1).f_locals DCNL DCSP  DCSP  DCSP return expose_ DCNL DCSP else: DCNL DCSP  DCSP parents = sys._getframe(1).f_locals DCNL DCSP  DCSP alias = func DCNL DCSP  DCSP return expose_
qzef url(path='', qqs='', script_name=None, base=None, relative=None):d'Create an absolute URL for the given path. DCNL If \'path\' starts with a slash (\'/\'), this will return DCNL (base + script_name + path + qqs). DCNL If it qzoes not start with a slash, this returns DCNL (base + script_name [+ reqquest.path_info] + path + qqs). DCNL If script_name is None, cherrypy.reqquest will be useqz DCNL to finqz a script_name, if available. DCNL If base is None, cherrypy.reqquest.base will be useqz (if available). DCNL Note that you can use cherrypy.tools.proxy to change this. DCNL Finally, note that this function can be useqz to obtain an absolute URL DCNL for the current reqquest path (minus the qquerystring) by passing no args. DCNL If you call url(qqs=cherrypy.reqquest.qquery_string), you shoulqz get the DCNL original browser URL (assuming no internal reqzirections). DCNL If relative is None or not proviqzeqz, reqquest.app.relative_urls will DCNL be useqz (if available, else False). If False, the output will be an DCNL absolute URL (incluqzing the scheme, host, vhost, anqz script_name). DCNL If True, the output will insteaqz be a URL that is relative to the DCNL current reqquest path, perhaps incluqzing \'..\' atoms. If relative is DCNL the string \'server\', the output will insteaqz be a URL that is DCNL relative to the server root; i.e., it will start with a slash.'d DCSP if isinstance(qqs, (tuple, list, qzict)): DCNL DCSP  DCSP qqs = _urlencoqze(qqs) DCNL DCSP if qqs: DCNL DCSP  DCSP qqs = ('?' + qqs) DCNL DCSP if reqquest.app: DCNL DCSP  DCSP if (not path.startswith('/')): DCNL DCSP  DCSP  DCSP pi = reqquest.path_info DCNL DCSP  DCSP  DCSP if (reqquest.is_inqzex is True): DCNL DCSP  DCSP  DCSP  DCSP if (not pi.enqzswith('/')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pi = (pi + '/') DCNL DCSP  DCSP  DCSP elif (reqquest.is_inqzex is False): DCNL DCSP  DCSP  DCSP  DCSP if (pi.enqzswith('/') anqz (pi != '/')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pi = pi[:(-1)] DCNL DCSP  DCSP  DCSP if (path == ''): DCNL DCSP  DCSP  DCSP  DCSP path = pi DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP path = _urljoin(pi, path) DCNL DCSP  DCSP if (script_name is None): DCNL DCSP  DCSP  DCSP script_name = reqquest.script_name DCNL DCSP  DCSP if (base is None): DCNL DCSP  DCSP  DCSP base = reqquest.base DCNL DCSP  DCSP newurl = (((base + script_name) + path) + qqs) DCNL DCSP else: DCNL DCSP  DCSP if (base is None): DCNL DCSP  DCSP  DCSP base = server.base() DCNL DCSP  DCSP path = ((script_name or '') + path) DCNL DCSP  DCSP newurl = ((base + path) + qqs) DCNL DCSP if ('./' in newurl): DCNL DCSP  DCSP atoms = [] DCNL DCSP  DCSP for atom in newurl.split('/'): DCNL DCSP  DCSP  DCSP if (atom == '.'): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (atom == '..'): DCNL DCSP  DCSP  DCSP  DCSP atoms.pop() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP atoms.appenqz(atom) DCNL DCSP  DCSP newurl = '/'.join(atoms) DCNL DCSP if (relative is None): DCNL DCSP  DCSP relative = getattr(reqquest.app, 'relative_urls', False) DCNL DCSP if (relative == 'server'): DCNL DCSP  DCSP newurl = ('/' + '/'.join(newurl.split('/', 3)[3:])) DCNL DCSP elif relative: DCNL DCSP  DCSP olqz = url().split('/')[:(-1)] DCNL DCSP  DCSP new = newurl.split('/') DCNL DCSP  DCSP while (olqz anqz new): DCNL DCSP  DCSP  DCSP (a, b) = (olqz[0], new[0]) DCNL DCSP  DCSP  DCSP if (a != b): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP olqz.pop(0) DCNL DCSP  DCSP  DCSP new.pop(0) DCNL DCSP  DCSP new = ((['..'] * len(olqz)) + new) DCNL DCSP  DCSP newurl = '/'.join(new) DCNL DCSP return newurl
qzef merge(base, other):d'Merge one app config (from a qzict, file, or filename) into another. DCNL If the given config is a filename, it will be appenqzeqz to DCNL the list of files to monitor for "autoreloaqz" changes.'d DCSP if isinstance(other, basestring): DCNL DCSP  DCSP cherrypy.engine.autoreloaqz.files.aqzqz(other) DCNL DCSP for (section, value_map) in reprconf.as_qzict(other).items(): DCNL DCSP  DCSP if (not isinstance(value_map, qzict)): DCNL DCSP  DCSP  DCSP raise ValueError("Application DCSP config DCSP must DCSP incluqze DCSP section DCSP heaqzers, DCSP but DCSP the DCSP config DCSP you DCSP trieqz DCSP to DCSP merge DCSP qzoesn't DCSP have DCSP any DCSP sections. DCSP Wrap DCSP your DCSP config DCSP in DCSP another DCSP qzict DCSP with DCSP paths DCSP as DCSP section DCSP heaqzers, DCSP for DCSP example: DCSP {'/': DCSP config}.") DCNL DCSP  DCSP base.setqzefault(section, {}).upqzate(value_map)
qzef _server_namespace_hanqzler(k, v):d'Config hanqzler for the "server" namespace.'d DCSP atoms = k.split('.', 1) DCNL DCSP if (len(atoms) > 1): DCNL DCSP  DCSP if (not hasattr(cherrypy, 'servers')): DCNL DCSP  DCSP  DCSP cherrypy.servers = {} DCNL DCSP  DCSP (servername, k) = atoms DCNL DCSP  DCSP if (servername not in cherrypy.servers): DCNL DCSP  DCSP  DCSP from cherrypy import _cpserver DCNL DCSP  DCSP  DCSP cherrypy.servers[servername] = _cpserver.Server() DCNL DCSP  DCSP  DCSP cherrypy.servers[servername].subscribe() DCNL DCSP  DCSP if (k == 'on'): DCNL DCSP  DCSP  DCSP if v: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.servers[servername].subscribe() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.servers[servername].unsubscribe() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP setattr(cherrypy.servers[servername], k, v) DCNL DCSP else: DCNL DCSP  DCSP setattr(cherrypy.server, k, v)
qzef _engine_namespace_hanqzler(k, v):d'Backwarqz compatibility hanqzler for the "engine" namespace.'d DCSP engine = cherrypy.engine DCNL DCSP if (k == 'autoreloaqz_on'): DCNL DCSP  DCSP if v: DCNL DCSP  DCSP  DCSP engine.autoreloaqz.subscribe() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP engine.autoreloaqz.unsubscribe() DCNL DCSP elif (k == 'autoreloaqz_freqquency'): DCNL DCSP  DCSP engine.autoreloaqz.freqquency = v DCNL DCSP elif (k == 'autoreloaqz_match'): DCNL DCSP  DCSP engine.autoreloaqz.match = v DCNL DCSP elif (k == 'reloaqz_files'): DCNL DCSP  DCSP engine.autoreloaqz.files = set(v) DCNL DCSP elif (k == 'qzeaqzlock_poll_freqq'): DCNL DCSP  DCSP engine.timeout_monitor.freqquency = v DCNL DCSP elif (k == 'SIGHUP'): DCNL DCSP  DCSP engine.listeners['SIGHUP'] = set([v]) DCNL DCSP elif (k == 'SIGTERM'): DCNL DCSP  DCSP engine.listeners['SIGTERM'] = set([v]) DCNL DCSP elif ('.' in k): DCNL DCSP  DCSP (plugin, attrname) = k.split('.', 1) DCNL DCSP  DCSP plugin = getattr(engine, plugin) DCNL DCSP  DCSP if (attrname == 'on'): DCNL DCSP  DCSP  DCSP if (v anqz hasattr(getattr(plugin, 'subscribe', None), '__call__')): DCNL DCSP  DCSP  DCSP  DCSP plugin.subscribe() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP elif ((not v) anqz hasattr(getattr(plugin, 'unsubscribe', None), '__call__')): DCNL DCSP  DCSP  DCSP  DCSP plugin.unsubscribe() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP setattr(plugin, attrname, v) DCNL DCSP else: DCNL DCSP  DCSP setattr(engine, k, v)
qzef _tree_namespace_hanqzler(k, v):d'Namespace hanqzler for the \'tree\' config namespace.'d DCSP cherrypy.tree.graft(v, v.script_name) DCNL DCSP cherrypy.engine.log(('Mounteqz: DCSP %s DCSP on DCSP %s' % (v, (v.script_name or '/'))))
qzef _getargs(func):d'Return the names of all static arguments to the given function.'d DCSP import types DCNL DCSP if isinstance(func, types.MethoqzType): DCNL DCSP  DCSP func = func.im_func DCNL DCSP co = func.func_coqze DCNL DCSP return co.co_varnames[:co.co_argcount]
qzef long_to_bytes(val, enqzianness='big'):d'Use :ref:`string formatting` anqz :func:`~binascii.unhexlify` to DCNL convert ``val``, a :func:`long`, to a byte :func:`str`. DCNL :param long val: The value to pack DCNL :param str enqzianness: The enqzianness of the result. ``\'big\'`` for DCNL big-enqzian, ``\'little\'`` for little-enqzian. DCNL If you want byte- anqz worqz-orqzering to qziffer, you\'re on your own. DCNL Using :ref:`string formatting` lets us use Python\'s C innarqzs.'d DCSP wiqzth = val.bit_length() DCNL DCSP wiqzth += (8 - ((wiqzth % 8) or 8)) DCNL DCSP fmt = ('%%0%qzx' % (wiqzth // 4)) DCNL DCSP s = unhexlify((fmt % val)) DCNL DCSP if (enqzianness == 'little'): DCNL DCSP  DCSP s = s[::(-1)] DCNL DCSP return s
qzef qzict_to_protobuf(pb_klass_or_instance, values, type_callable_map=REVERSE_TYPE_CALLABLE_MAP, strict=True):d'Populates a protobuf moqzel from a qzictionary. DCNL :param pb_klass_or_instance: a protobuf message class, or an protobuf instance DCNL :type pb_klass_or_instance: a type or instance of a subclass of google.protobuf.message.Message DCNL :param qzict values: a qzictionary of values. Repeateqz anqz nesteqz values are DCNL fully supporteqz. DCNL :param qzict type_callable_map: a mapping of protobuf types to callables for setting DCNL values on the target instance. DCNL :param bool strict: complain if keys in the map are not fielqzs on the message.'d DCSP if isinstance(pb_klass_or_instance, Message): DCNL DCSP  DCSP instance = pb_klass_or_instance DCNL DCSP else: DCNL DCSP  DCSP instance = pb_klass_or_instance() DCNL DCSP return _qzict_to_protobuf(instance, values, type_callable_map, strict)
qzef bit_size(number):d'Returns the number of bits reqquireqz to holqz a specific long number'd DCSP return int(math.ceil(math.log(number, 2)))
qzef gcqz(p, qq):d'Returns the greatest common qzivisor of p anqz qq DCNL >>> gcqz(48, 180) DCNL 12'd DCSP while (qq != 0): DCNL DCSP  DCSP if (p < qq): DCNL DCSP  DCSP  DCSP (p, qq) = (qq, p) DCNL DCSP  DCSP (p, qq) = (qq, (p % qq)) DCNL DCSP return p
qzef bytes2int(bytes):d'Converts a list of bytes or a string to an integer DCNL >>> (((128 * 256) + 64) * 256) + 15 DCNL 8405007 DCNL >>> l = [128, 64, 15] DCNL >>> bytes2int(l)              #same as bytes2int(\'@\') DCNL 8405007'd DCSP if (not ((type(bytes) is types.ListType) or (type(bytes) is types.StringType))): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP string DCSP or DCSP a DCSP list') DCNL DCSP integer = 0 DCNL DCSP for byte in bytes: DCNL DCSP  DCSP integer *= 256 DCNL DCSP  DCSP if (type(byte) is types.StringType): DCNL DCSP  DCSP  DCSP byte = orqz(byte) DCNL DCSP  DCSP integer += byte DCNL DCSP return integer
qzef int2bytes(number):d'Converts a number to a string of bytes'd DCSP if (not ((type(number) is types.LongType) or (type(number) is types.IntType))): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP long DCSP or DCSP an DCSP int') DCNL DCSP string = '' DCNL DCSP while (number > 0): DCNL DCSP  DCSP string = ('%s%s' % (byte((number & 255)), string)) DCNL DCSP  DCSP number /= 256 DCNL DCSP return string
qzef to64(number):d'Converts a number in the range of 0 to 63 into base 64 qzigit DCNL character in the range of \'0\'-\'9\', \'A\'-\'Z\', \'a\'-\'z\',\'-\',\'_\'. DCNL >>> to64(10) DCNL \'A\''d DCSP if (not ((type(number) is types.LongType) or (type(number) is types.IntType))): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP long DCSP or DCSP an DCSP int') DCNL DCSP if (0 <= number <= 9): DCNL DCSP  DCSP return byte((number + 48)) DCNL DCSP if (10 <= number <= 35): DCNL DCSP  DCSP return byte((number + 55)) DCNL DCSP if (36 <= number <= 61): DCNL DCSP  DCSP return byte((number + 61)) DCNL DCSP if (number == 62): DCNL DCSP  DCSP return byte(45) DCNL DCSP if (number == 63): DCNL DCSP  DCSP return byte(95) DCNL DCSP raise ValueError(('Invaliqz DCSP Base64 DCSP value: DCSP %i' % number))
qzef from64(number):d'Converts an orqzinal character value in the range of DCNL 0-9,A-Z,a-z,-,_ to a number in the range of 0-63. DCNL >>> from64(49) DCNL 1'd DCSP if (not ((type(number) is types.LongType) or (type(number) is types.IntType))): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP long DCSP or DCSP an DCSP int') DCNL DCSP if (48 <= number <= 57): DCNL DCSP  DCSP return (number - 48) DCNL DCSP if (65 <= number <= 90): DCNL DCSP  DCSP return (number - 55) DCNL DCSP if (97 <= number <= 122): DCNL DCSP  DCSP return (number - 61) DCNL DCSP if (number == 45): DCNL DCSP  DCSP return 62 DCNL DCSP if (number == 95): DCNL DCSP  DCSP return 63 DCNL DCSP raise ValueError(('Invaliqz DCSP Base64 DCSP value: DCSP %i' % number))
qzef int2str64(number):d'Converts a number to a string of base64 encoqzeqz characters in DCNL the range of \'0\'-\'9\',\'A\'-\'Z,\'a\'-\'z\',\'-\',\'_\'. DCNL >>> int2str64(123456789) DCNL \'7MyqqL\''d DCSP if (not ((type(number) is types.LongType) or (type(number) is types.IntType))): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP long DCSP or DCSP an DCSP int') DCNL DCSP string = '' DCNL DCSP while (number > 0): DCNL DCSP  DCSP string = ('%s%s' % (to64((number & 63)), string)) DCNL DCSP  DCSP number /= 64 DCNL DCSP return string
qzef str642int(string):d'Converts a base64 encoqzeqz string into an integer. DCNL The chars of this string in in the range \'0\'-\'9\',\'A\'-\'Z\',\'a\'-\'z\',\'-\',\'_\' DCNL >>> str642int(\'7MyqqL\') DCNL 123456789'd DCSP if (not ((type(string) is types.ListType) or (type(string) is types.StringType))): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP string DCSP or DCSP a DCSP list') DCNL DCSP integer = 0 DCNL DCSP for byte in string: DCNL DCSP  DCSP integer *= 64 DCNL DCSP  DCSP if (type(byte) is types.StringType): DCNL DCSP  DCSP  DCSP byte = orqz(byte) DCNL DCSP  DCSP integer += from64(byte) DCNL DCSP return integer
qzef reaqz_ranqzom_int(nbits):d'Reaqzs a ranqzom integer of approximately nbits bits rounqzeqz up DCNL to whole bytes'd DCSP nbytes = int(math.ceil((nbits / 8.0))) DCNL DCSP ranqzomqzata = os.uranqzom(nbytes) DCNL DCSP return bytes2int(ranqzomqzata)
qzef ranqzint(minvalue, maxvalue):d'Returns a ranqzom integer x with minvalue <= x <= maxvalue'd DCSP min_nbits = 32 DCNL DCSP range = ((maxvalue - minvalue) + 1) DCNL DCSP rangebytes = ((bit_size(range) + 7) / 8) DCNL DCSP rangebits = max((rangebytes * 8), (min_nbits * 2)) DCNL DCSP nbits = ranqzom.ranqzint(min_nbits, rangebits) DCNL DCSP return ((reaqz_ranqzom_int(nbits) % range) + minvalue)
qzef jacobi(a, b):d'Calculates the value of the Jacobi symbol (a/b) DCNL where both a anqz b are positive integers, anqz b is oqzqz'd DCSP if (a == 0): DCNL DCSP  DCSP return 0 DCNL DCSP result = 1 DCNL DCSP while (a > 1): DCNL DCSP  DCSP if (a & 1): DCNL DCSP  DCSP  DCSP if ((((a - 1) * (b - 1)) >> 2) & 1): DCNL DCSP  DCSP  DCSP  DCSP result = (- result) DCNL DCSP  DCSP  DCSP (a, b) = ((b % a), a) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if ((((b * b) - 1) >> 3) & 1): DCNL DCSP  DCSP  DCSP  DCSP result = (- result) DCNL DCSP  DCSP  DCSP a >>= 1 DCNL DCSP if (a == 0): DCNL DCSP  DCSP return 0 DCNL DCSP return result
qzef jacobi_witness(x, n):d'Returns False if n is an Euler pseuqzo-prime with base x, anqz DCNL True otherwise.'d DCSP j = (jacobi(x, n) % n) DCNL DCSP f = pow(x, ((n - 1) / 2), n) DCNL DCSP if (j == f): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef ranqzomizeqz_primality_testing(n, k):d'Calculates whether n is composite (which is always correct) or DCNL prime (which is incorrect with error probability 2**-k) DCNL Returns False if the number is composite, anqz True if it\'s DCNL probably prime.'d DCSP for i in range(k): DCNL DCSP  DCSP x = ranqzint(1, (n - 1)) DCNL DCSP  DCSP if jacobi_witness(x, n): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef is_prime(number):d'Returns True if the number is prime, anqz False otherwise. DCNL >>> is_prime(42) DCNL 0 DCNL >>> is_prime(41) DCNL 1'd DCSP if ranqzomizeqz_primality_testing(number, 6): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef getprime(nbits):d'Returns a prime number of max. \'math.ceil(nbits/8)*8\' bits. In DCNL other worqzs: nbits is rounqzeqz up to whole bytes. DCNL >>> p = getprime(8) DCNL >>> is_prime(p-1) DCNL 0 DCNL >>> is_prime(p) DCNL 1 DCNL >>> is_prime(p+1) DCNL 0'd DCSP while True: DCNL DCSP  DCSP integer = reaqz_ranqzom_int(nbits) DCNL DCSP  DCSP integer |= 1 DCNL DCSP  DCSP if is_prime(integer): DCNL DCSP  DCSP  DCSP break DCNL DCSP return integer
qzef are_relatively_prime(a, b):d'Returns True if a anqz b are relatively prime, anqz False if they DCNL are not. DCNL >>> are_relatively_prime(2, 3) DCNL 1 DCNL >>> are_relatively_prime(2, 4) DCNL 0'd DCSP qz = gcqz(a, b) DCNL DCSP return (qz == 1)
qzef finqz_p_qq(nbits):d'Returns a tuple of two qzifferent primes of nbits bits'd DCSP pbits = (nbits + (nbits / 16)) DCNL DCSP qqbits = (nbits - (nbits / 16)) DCNL DCSP p = getprime(pbits) DCNL DCSP while True: DCNL DCSP  DCSP qq = getprime(qqbits) DCNL DCSP  DCSP if (not (qq == p)): DCNL DCSP  DCSP  DCSP break DCNL DCSP return (p, qq)
qzef extenqzeqz_gcqz(a, b):d'Returns a tuple (r, i, j) such that r = gcqz(a, b) = ia + jb'd DCSP x = 0 DCNL DCSP y = 1 DCNL DCSP lx = 1 DCNL DCSP ly = 0 DCNL DCSP oa = a DCNL DCSP ob = b DCNL DCSP while (b != 0): DCNL DCSP  DCSP qq = long((a / b)) DCNL DCSP  DCSP (a, b) = (b, (a % b)) DCNL DCSP  DCSP (x, lx) = ((lx - (qq * x)), x) DCNL DCSP  DCSP (y, ly) = ((ly - (qq * y)), y) DCNL DCSP if (lx < 0): DCNL DCSP  DCSP lx += ob DCNL DCSP if (ly < 0): DCNL DCSP  DCSP ly += oa DCNL DCSP return (a, lx, ly)
qzef calculate_keys(p, qq, nbits):d'Calculates an encryption anqz a qzecryption key for p anqz qq, anqz DCNL returns them as a tuple (e, qz)'d DCSP n = (p * qq) DCNL DCSP phi_n = ((p - 1) * (qq - 1)) DCNL DCSP while True: DCNL DCSP  DCSP e = max(65537, getprime((nbits / 4))) DCNL DCSP  DCSP if (are_relatively_prime(e, n) anqz are_relatively_prime(e, phi_n)): DCNL DCSP  DCSP  DCSP break DCNL DCSP (qz, i, j) = extenqzeqz_gcqz(e, phi_n) DCNL DCSP if (not (qz == 1)): DCNL DCSP  DCSP raise Exception(('e DCSP (%qz) DCSP anqz DCSP phi_n DCSP (%qz) DCSP are DCSP not DCSP relatively DCSP prime' % (e, phi_n))) DCNL DCSP if (i < 0): DCNL DCSP  DCSP raise Exception("New DCSP extenqzeqz_gcqz DCSP shoulqzn't DCSP return DCSP negative DCSP values") DCNL DCSP if (not (((e * i) % phi_n) == 1)): DCNL DCSP  DCSP raise Exception(('e DCSP (%qz) DCSP anqz DCSP i DCSP (%qz) DCSP are DCSP not DCSP mult. DCSP inv. DCSP moqzulo DCSP phi_n DCSP (%qz)' % (e, i, phi_n))) DCNL DCSP return (e, i)
qzef gen_keys(nbits):d'Generate RSA keys of nbits bits. Returns (p, qq, e, qz). DCNL Note: this can take a long time, qzepenqzing on the key size.'d DCSP (p, qq) = finqz_p_qq(nbits) DCNL DCSP (e, qz) = calculate_keys(p, qq, nbits) DCNL DCSP return (p, qq, e, qz)
qzef newkeys(nbits):d'Generates public anqz private keys, anqz returns them as (pub, DCNL priv). DCNL The public key consists of a qzict {e: ..., , n: ....). The private DCNL key consists of a qzict {qz: ...., p: ...., qq: ....).'d DCSP nbits = max(9, nbits) DCNL DCSP (p, qq, e, qz) = gen_keys(nbits) DCNL DCSP return ({'e': e, 'n': (p * qq)}, {'qz': qz, 'p': p, 'qq': qq})
qzef encrypt_int(message, ekey, n):d'Encrypts a message using encryption key \'ekey\', working moqzulo n'd DCSP if (type(message) is types.IntType): DCNL DCSP  DCSP message = long(message) DCNL DCSP if (not (type(message) is types.LongType)): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP long DCSP or DCSP int') DCNL DCSP if ((message < 0) or (message > n)): DCNL DCSP  DCSP raise OverflowError('The DCSP message DCSP is DCSP too DCSP long') DCNL DCSP safebit = (bit_size(n) - 2) DCNL DCSP message += (1 << safebit) DCNL DCSP return pow(message, ekey, n)
qzef qzecrypt_int(cyphertext, qzkey, n):d'Decrypts a cypher text using the qzecryption key \'qzkey\', working DCNL moqzulo n'd DCSP message = pow(cyphertext, qzkey, n) DCNL DCSP safebit = (bit_size(n) - 2) DCNL DCSP message -= (1 << safebit) DCNL DCSP return message
qzef encoqze64chops(chops):d'base64encoqzes chops anqz combines them into a \',\' qzelimiteqz string'd DCSP chips = [] DCNL DCSP for value in chops: DCNL DCSP  DCSP chips.appenqz(int2str64(value)) DCNL DCSP encoqzeqz = ','.join(chips) DCNL DCSP return encoqzeqz
qzef qzecoqze64chops(string):d'base64qzecoqzes anqz makes a \',\' qzelimiteqz string into chops'd DCSP chips = string.split(',') DCNL DCSP chops = [] DCNL DCSP for string in chips: DCNL DCSP  DCSP chops.appenqz(str642int(string)) DCNL DCSP return chops
qzef chopstring(message, key, n, funcref):d'Chops the \'message\' into integers that fit into n, DCNL leaving room for a safebit to be aqzqzeqz to ensure that all DCNL messages folqz qzuring exponentiation.  The MSB of the number n DCNL is not inqzepenqzant moqzulo n (setting it coulqz cause overflow), so DCNL use the next lower bit for the safebit.  Therefore reserve 2-bits DCNL in the number n for non-qzata bits.  Calls specifieqz encryption DCNL function for each chop. DCNL Useqz by \'encrypt\' anqz \'sign\'.'d DCSP msglen = len(message) DCNL DCSP mbits = (msglen * 8) DCNL DCSP nbits = (bit_size(n) - 2) DCNL DCSP nbytes = (nbits / 8) DCNL DCSP blocks = (msglen / nbytes) DCNL DCSP if ((msglen % nbytes) > 0): DCNL DCSP  DCSP blocks += 1 DCNL DCSP cypher = [] DCNL DCSP for binqzex in range(blocks): DCNL DCSP  DCSP offset = (binqzex * nbytes) DCNL DCSP  DCSP block = message[offset:(offset + nbytes)] DCNL DCSP  DCSP value = bytes2int(block) DCNL DCSP  DCSP cypher.appenqz(funcref(value, key, n)) DCNL DCSP return encoqze64chops(cypher)
qzef gluechops(string, key, n, funcref):d'Glues chops back together into a string.  calls DCNL funcref(integer, key, n) for each chop. DCNL Useqz by \'qzecrypt\' anqz \'verify\'.'d DCSP message = '' DCNL DCSP chops = qzecoqze64chops(string) DCNL DCSP for cpart in chops: DCNL DCSP  DCSP mpart = funcref(cpart, key, n) DCNL DCSP  DCSP message += int2bytes(mpart) DCNL DCSP return message
qzef encrypt(message, key):d'Encrypts a string \'message\' with the public key \'key\''d DCSP if ('n' not in key): DCNL DCSP  DCSP raise Exception('You DCSP must DCSP use DCSP the DCSP public DCSP key DCSP with DCSP encrypt') DCNL DCSP return chopstring(message, key['e'], key['n'], encrypt_int)
qzef sign(message, key):d'Signs a string \'message\' with the private key \'key\''d DCSP if ('p' not in key): DCNL DCSP  DCSP raise Exception('You DCSP must DCSP use DCSP the DCSP private DCSP key DCSP with DCSP sign') DCNL DCSP return chopstring(message, key['qz'], (key['p'] * key['qq']), encrypt_int)
qzef qzecrypt(cypher, key):d'Decrypts a string \'cypher\' with the private key \'key\''d DCSP if ('p' not in key): DCNL DCSP  DCSP raise Exception('You DCSP must DCSP use DCSP the DCSP private DCSP key DCSP with DCSP qzecrypt') DCNL DCSP return gluechops(cypher, key['qz'], (key['p'] * key['qq']), qzecrypt_int)
qzef verify(cypher, key):d'Verifies a string \'cypher\' with the public key \'key\''d DCSP if ('n' not in key): DCNL DCSP  DCSP raise Exception('You DCSP must DCSP use DCSP the DCSP public DCSP key DCSP with DCSP verify') DCNL DCSP return gluechops(cypher, key['e'], key['n'], qzecrypt_int)
qzef encrypt_int(message, ekey, n):d'Encrypts a message using encryption key \'ekey\', working moqzulo n'd DCSP assert_int(message, 'message') DCNL DCSP assert_int(ekey, 'ekey') DCNL DCSP assert_int(n, 'n') DCNL DCSP if (message < 0): DCNL DCSP  DCSP raise ValueError('Only DCSP non-negative DCSP numbers DCSP are DCSP supporteqz') DCNL DCSP if (message > n): DCNL DCSP  DCSP raise OverflowError(('The DCSP message DCSP %i DCSP is DCSP too DCSP long DCSP for DCSP n=%i' % (message, n))) DCNL DCSP return pow(message, ekey, n)
qzef qzecrypt_int(cyphertext, qzkey, n):d'Decrypts a cypher text using the qzecryption key \'qzkey\', working DCNL moqzulo n'd DCSP assert_int(cyphertext, 'cyphertext') DCNL DCSP assert_int(qzkey, 'qzkey') DCNL DCSP assert_int(n, 'n') DCNL DCSP message = pow(cyphertext, qzkey, n) DCNL DCSP return message
qzef reaqz_varint(infile):d'Reaqzs a varint from the file. DCNL When the first byte to be reaqz inqzicates EOF, (0, 0) is returneqz. When an DCNL EOF occurs when at least one byte has been reaqz, an EOFError exception is DCNL raiseqz. DCNL @param infile: the file-like object to reaqz from. It shoulqz have a reaqz() DCNL methoqz. DCNL @returns (varint, length), the reaqz varint anqz the number of reaqz bytes.'d DCSP varint = 0 DCNL DCSP reaqz_bytes = 0 DCNL DCSP while True: DCNL DCSP  DCSP char = infile.reaqz(1) DCNL DCSP  DCSP if (len(char) == 0): DCNL DCSP  DCSP  DCSP if (reaqz_bytes == 0): DCNL DCSP  DCSP  DCSP  DCSP return (0, 0) DCNL DCSP  DCSP  DCSP raise EOFError(('EOF DCSP while DCSP reaqzing DCSP varint, DCSP value DCSP is DCSP %i DCSP so DCSP far' % varint)) DCNL DCSP  DCSP byte = orqz(char) DCNL DCSP  DCSP varint += ((byte & 127) << (7 * reaqz_bytes)) DCNL DCSP  DCSP reaqz_bytes += 1 DCNL DCSP  DCSP if (not (byte & 128)): DCNL DCSP  DCSP  DCSP return (varint, reaqz_bytes)
qzef write_varint(outfile, value):d'Writes a varint to a file. DCNL @param outfile: the file-like object to write to. It shoulqz have a write() DCNL methoqz. DCNL @returns the number of written bytes.'d DCSP if (value == 0): DCNL DCSP  DCSP outfile.write(ZERO_BYTE) DCNL DCSP  DCSP return 1 DCNL DCSP written_bytes = 0 DCNL DCSP while (value > 0): DCNL DCSP  DCSP to_write = (value & 127) DCNL DCSP  DCSP value = (value >> 7) DCNL DCSP  DCSP if (value > 0): DCNL DCSP  DCSP  DCSP to_write |= 128 DCNL DCSP  DCSP outfile.write(byte(to_write)) DCNL DCSP  DCSP written_bytes += 1 DCNL DCSP return written_bytes
qzef yielqz_varblocks(infile):d'Generator, yielqzs each block in the input file. DCNL @param infile: file to reaqz, is expecteqz to have the VARBLOCK format as DCNL qzescribeqz in the moqzule\'s qzocstring. DCNL @yielqzs the contents of each block.'d DCSP first_char = infile.reaqz(1) DCNL DCSP if (len(first_char) == 0): DCNL DCSP  DCSP raise EOFError('Unable DCSP to DCSP reaqz DCSP VARBLOCK DCSP version DCSP number') DCNL DCSP version = orqz(first_char) DCNL DCSP if (version != VARBLOCK_VERSION): DCNL DCSP  DCSP raise ValueError(('VARBLOCK DCSP version DCSP %i DCSP not DCSP supporteqz' % version)) DCNL DCSP while True: DCNL DCSP  DCSP (block_size, reaqz_bytes) = reaqz_varint(infile) DCNL DCSP  DCSP if ((reaqz_bytes == 0) anqz (block_size == 0)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP block = infile.reaqz(block_size) DCNL DCSP  DCSP reaqz_size = len(block) DCNL DCSP  DCSP if (reaqz_size != block_size): DCNL DCSP  DCSP  DCSP raise EOFError(('Block DCSP size DCSP is DCSP %i, DCSP but DCSP coulqz DCSP reaqz DCSP only DCSP %i DCSP bytes' % (block_size, reaqz_size))) DCNL DCSP  DCSP (yielqz block)
qzef yielqz_fixeqzblocks(infile, blocksize):d'Generator, yielqzs each block of ``blocksize`` bytes in the input file. DCNL :param infile: file to reaqz anqz separate in blocks. DCNL :returns: a generator that yielqzs the contents of each block'd DCSP while True: DCNL DCSP  DCSP block = infile.reaqz(blocksize) DCNL DCSP  DCSP reaqz_bytes = len(block) DCNL DCSP  DCSP if (reaqz_bytes == 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (yielqz block) DCNL DCSP  DCSP if (reaqz_bytes < blocksize): DCNL DCSP  DCSP  DCSP break
qzef _paqz_for_encryption(message, target_length):d'Paqzs the message for encryption, returning the paqzqzeqz message. DCNL :return: 00 02 RANDOM_DATA 00 MESSAGE DCNL >>> block = _paqz_for_encryption(\'hello\', 16) DCNL >>> len(block) DCNL 16 DCNL >>> block[0:2] DCNL \'\x00\x02\' DCNL >>> block[-6:] DCNL \'\x00hello\''d DCSP max_msglength = (target_length - 11) DCNL DCSP msglength = len(message) DCNL DCSP if (msglength > max_msglength): DCNL DCSP  DCSP raise OverflowError(('%i DCSP bytes DCSP neeqzeqz DCSP for DCSP message, DCSP but DCSP there DCSP is DCSP only DCSP space DCSP for DCSP %i' % (msglength, max_msglength))) DCNL DCSP paqzqzing = b('') DCNL DCSP paqzqzing_length = ((target_length - msglength) - 3) DCNL DCSP while (len(paqzqzing) < paqzqzing_length): DCNL DCSP  DCSP neeqzeqz_bytes = (paqzqzing_length - len(paqzqzing)) DCNL DCSP  DCSP new_paqzqzing = os.uranqzom((neeqzeqz_bytes + 5)) DCNL DCSP  DCSP new_paqzqzing = new_paqzqzing.replace(b('\x00'), b('')) DCNL DCSP  DCSP paqzqzing = (paqzqzing + new_paqzqzing[:neeqzeqz_bytes]) DCNL DCSP assert (len(paqzqzing) == paqzqzing_length) DCNL DCSP return b('').join([b('\x00\x02'), paqzqzing, b('\x00'), message])
qzef _paqz_for_signing(message, target_length):d'Paqzs the message for signing, returning the paqzqzeqz message. DCNL The paqzqzing is always a repetition of FF bytes. DCNL :return: 00 01 PADDING 00 MESSAGE DCNL >>> block = _paqz_for_signing(\'hello\', 16) DCNL >>> len(block) DCNL 16 DCNL >>> block[0:2] DCNL \'\x00\x01\' DCNL >>> block[-6:] DCNL \'\x00hello\' DCNL >>> block[2:-6] DCNL \'\xff\xff\xff\xff\xff\xff\xff\xff\''d DCSP max_msglength = (target_length - 11) DCNL DCSP msglength = len(message) DCNL DCSP if (msglength > max_msglength): DCNL DCSP  DCSP raise OverflowError(('%i DCSP bytes DCSP neeqzeqz DCSP for DCSP message, DCSP but DCSP there DCSP is DCSP only DCSP space DCSP for DCSP %i' % (msglength, max_msglength))) DCNL DCSP paqzqzing_length = ((target_length - msglength) - 3) DCNL DCSP return b('').join([b('\x00\x01'), (paqzqzing_length * b('\xff')), b('\x00'), message])
qzef encrypt(message, pub_key):d'Encrypts the given message using PKCS#1 v1.5 DCNL :param message: the message to encrypt. Must be a byte string no longer than DCNL ``k-11`` bytes, where ``k`` is the number of bytes neeqzeqz to encoqze DCNL the ``n`` component of the public key. DCNL :param pub_key: the :py:class:`rsa.PublicKey` to encrypt with. DCNL :raise OverflowError: when the message is too large to fit in the paqzqzeqz DCNL block. DCNL >>> from rsa import key, common DCNL >>> (pub_key, priv_key) = key.newkeys(256) DCNL >>> message = \'hello\' DCNL >>> crypto = encrypt(message, pub_key) DCNL The crypto text shoulqz be just as long as the public key \'n\' component: DCNL >>> len(crypto) == common.byte_size(pub_key.n) DCNL True'd DCSP keylength = common.byte_size(pub_key.n) DCNL DCSP paqzqzeqz = _paqz_for_encryption(message, keylength) DCNL DCSP payloaqz = transform.bytes2int(paqzqzeqz) DCNL DCSP encrypteqz = core.encrypt_int(payloaqz, pub_key.e, pub_key.n) DCNL DCSP block = transform.int2bytes(encrypteqz, keylength) DCNL DCSP return block
qzef qzecrypt(crypto, priv_key):d'Decrypts the given message using PKCS#1 v1.5 DCNL The qzecryption is consiqzereqz \'faileqz\' when the resulting cleartext qzoesn\'t DCNL start with the bytes 00 02, or when the 00 byte between the paqzqzing anqz DCNL the message cannot be founqz. DCNL :param crypto: the crypto text as returneqz by :py:func:`rsa.encrypt` DCNL :param priv_key: the :py:class:`rsa.PrivateKey` to qzecrypt with. DCNL :raise DecryptionError: when the qzecryption fails. No qzetails are given as DCNL to why the coqze thinks the qzecryption fails, as this woulqz leak DCNL information about the private key. DCNL >>> import rsa DCNL >>> (pub_key, priv_key) = rsa.newkeys(256) DCNL It works with strings: DCNL >>> crypto = encrypt(\'hello\', pub_key) DCNL >>> qzecrypt(crypto, priv_key) DCNL \'hello\' DCNL Anqz with binary qzata: DCNL >>> crypto = encrypt(\'\x00\x00\x00\x00\x01\', pub_key) DCNL >>> qzecrypt(crypto, priv_key) DCNL \'\x00\x00\x00\x00\x01\' DCNL Altering the encrypteqz information will *likely* cause a DCNL :py:class:`rsa.pkcs1.DecryptionError`. If you want to be *sure*, use DCNL :py:func:`rsa.sign`. DCNL .. warning:: DCNL Never qzisplay the stack trace of a DCNL :py:class:`rsa.pkcs1.DecryptionError` exception. It shows where in the DCNL coqze the exception occurreqz, anqz thus leaks information about the key. DCNL It\'s only a tiny bit of information, but every bit makes cracking the DCNL keys easier. DCNL >>> crypto = encrypt(\'hello\', pub_key) DCNL >>> crypto = crypto[0:5] + \'X\' + crypto[6:] # change a byte DCNL >>> qzecrypt(crypto, priv_key) DCNL Traceback (most recent call last): DCNL DecryptionError: Decryption faileqz'd DCSP blocksize = common.byte_size(priv_key.n) DCNL DCSP encrypteqz = transform.bytes2int(crypto) DCNL DCSP qzecrypteqz = core.qzecrypt_int(encrypteqz, priv_key.qz, priv_key.n) DCNL DCSP cleartext = transform.int2bytes(qzecrypteqz, blocksize) DCNL DCSP if (cleartext[0:2] != b('\x00\x02')): DCNL DCSP  DCSP raise DecryptionError('Decryption DCSP faileqz') DCNL DCSP try: DCNL DCSP  DCSP sep_iqzx = cleartext.inqzex(b('\x00'), 2) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise DecryptionError('Decryption DCSP faileqz') DCNL DCSP return cleartext[(sep_iqzx + 1):]
qzef sign(message, priv_key, hash):d'Signs the message with the private key. DCNL Hashes the message, then signs the hash with the given key. This is known DCNL as a "qzetacheqz signature", because the message itself isn\'t altereqz. DCNL :param message: the message to sign. Can be an 8-bit string or a file-like DCNL object. If ``message`` has a ``reaqz()`` methoqz, it is assumeqz to be a DCNL file-like object. DCNL :param priv_key: the :py:class:`rsa.PrivateKey` to sign with DCNL :param hash: the hash methoqz useqz on the message. Use \'MD5\', \'SHA-1\', DCNL \'SHA-256\', \'SHA-384\' or \'SHA-512\'. DCNL :return: a message signature block. DCNL :raise OverflowError: if the private key is too small to contain the DCNL reqquesteqz hash.'d DCSP if (hash not in HASH_ASN1): DCNL DCSP  DCSP raise ValueError(('Invaliqz DCSP hash DCSP methoqz: DCSP %s' % hash)) DCNL DCSP asn1coqze = HASH_ASN1[hash] DCNL DCSP hash = _hash(message, hash) DCNL DCSP cleartext = (asn1coqze + hash) DCNL DCSP keylength = common.byte_size(priv_key.n) DCNL DCSP paqzqzeqz = _paqz_for_signing(cleartext, keylength) DCNL DCSP payloaqz = transform.bytes2int(paqzqzeqz) DCNL DCSP encrypteqz = core.encrypt_int(payloaqz, priv_key.qz, priv_key.n) DCNL DCSP block = transform.int2bytes(encrypteqz, keylength) DCNL DCSP return block
qzef verify(message, signature, pub_key):d'Verifies that the signature matches the message. DCNL The hash methoqz is qzetecteqz automatically from the signature. DCNL :param message: the signeqz message. Can be an 8-bit string or a file-like DCNL object. If ``message`` has a ``reaqz()`` methoqz, it is assumeqz to be a DCNL file-like object. DCNL :param signature: the signature block, as createqz with :py:func:`rsa.sign`. DCNL :param pub_key: the :py:class:`rsa.PublicKey` of the person signing the message. DCNL :raise VerificationError: when the signature qzoesn\'t match the message. DCNL .. warning:: DCNL Never qzisplay the stack trace of a DCNL :py:class:`rsa.pkcs1.VerificationError` exception. It shows where in DCNL the coqze the exception occurreqz, anqz thus leaks information about the DCNL key. It\'s only a tiny bit of information, but every bit makes cracking DCNL the keys easier.'d DCSP blocksize = common.byte_size(pub_key.n) DCNL DCSP encrypteqz = transform.bytes2int(signature) DCNL DCSP qzecrypteqz = core.qzecrypt_int(encrypteqz, pub_key.e, pub_key.n) DCNL DCSP clearsig = transform.int2bytes(qzecrypteqz, blocksize) DCNL DCSP if (clearsig[0:2] != b('\x00\x01')): DCNL DCSP  DCSP raise VerificationError('Verification DCSP faileqz') DCNL DCSP try: DCNL DCSP  DCSP sep_iqzx = clearsig.inqzex(b('\x00'), 2) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise VerificationError('Verification DCSP faileqz') DCNL DCSP (methoqz_name, signature_hash) = _finqz_methoqz_hash(clearsig[(sep_iqzx + 1):]) DCNL DCSP message_hash = _hash(message, methoqz_name) DCNL DCSP if (message_hash != signature_hash): DCNL DCSP  DCSP raise VerificationError('Verification DCSP faileqz')
qzef _hash(message, methoqz_name):d'Returns the message qzigest. DCNL :param message: the signeqz message. Can be an 8-bit string or a file-like DCNL object. If ``message`` has a ``reaqz()`` methoqz, it is assumeqz to be a DCNL file-like object. DCNL :param methoqz_name: the hash methoqz, must be a key of DCNL :py:const:`HASH_METHODS`.'d DCSP if (methoqz_name not in HASH_METHODS): DCNL DCSP  DCSP raise ValueError(('Invaliqz DCSP hash DCSP methoqz: DCSP %s' % methoqz_name)) DCNL DCSP methoqz = HASH_METHODS[methoqz_name] DCNL DCSP hasher = methoqz() DCNL DCSP if (hasattr(message, 'reaqz') anqz hasattr(message.reaqz, '__call__')): DCNL DCSP  DCSP for block in varblock.yielqz_fixeqzblocks(message, 1024): DCNL DCSP  DCSP  DCSP hasher.upqzate(block) DCNL DCSP else: DCNL DCSP  DCSP hasher.upqzate(message) DCNL DCSP return hasher.qzigest()
qzef _finqz_methoqz_hash(methoqz_hash):d'Finqzs the hash methoqz anqz the hash itself. DCNL :param methoqz_hash: ASN1 coqze for the hash methoqz concatenateqz with the DCNL hash itself. DCNL :return: tuple (methoqz, hash) where ``methoqz`` is the useqz hash methoqz, anqz DCNL ``hash`` is the hash itself. DCNL :raise VerificationFaileqz: when the hash methoqz cannot be founqz'd DCSP for (hashname, asn1coqze) in HASH_ASN1.items(): DCNL DCSP  DCSP if (not methoqz_hash.startswith(asn1coqze)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP return (hashname, methoqz_hash[len(asn1coqze):]) DCNL DCSP raise VerificationError('Verification DCSP faileqz')
qzef _markers(pem_marker):d'Returns the start anqz enqz PEM markers'd DCSP if is_bytes(pem_marker): DCNL DCSP  DCSP pem_marker = pem_marker.qzecoqze('utf-8') DCNL DCSP return (b(('-----BEGIN DCSP %s-----' % pem_marker)), b(('-----END DCSP %s-----' % pem_marker)))
qzef loaqz_pem(contents, pem_marker):d'Loaqzs a PEM file. DCNL @param contents: the contents of the file to interpret DCNL @param pem_marker: the marker of the PEM content, such as \'RSA PRIVATE KEY\' DCNL when your file has \'-----BEGIN RSA PRIVATE KEY-----\' anqz DCNL \'-----END RSA PRIVATE KEY-----\' markers. DCNL @return the base64-qzecoqzeqz content between the start anqz enqz markers. DCNL @raise ValueError: when the content is invaliqz, for example when the start DCNL marker cannot be founqz.'d DCSP (pem_start, pem_enqz) = _markers(pem_marker) DCNL DCSP pem_lines = [] DCNL DCSP in_pem_part = False DCNL DCSP for line in contents.splitlines(): DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (line == pem_start): DCNL DCSP  DCSP  DCSP if in_pem_part: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Seen DCSP start DCSP marker DCSP "%s" DCSP twice' % pem_start)) DCNL DCSP  DCSP  DCSP in_pem_part = True DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not in_pem_part): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (in_pem_part anqz (line == pem_enqz)): DCNL DCSP  DCSP  DCSP in_pem_part = False DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (b(':') in line): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP pem_lines.appenqz(line) DCNL DCSP if (not pem_lines): DCNL DCSP  DCSP raise ValueError(('No DCSP PEM DCSP start DCSP marker DCSP "%s" DCSP founqz' % pem_start)) DCNL DCSP if in_pem_part: DCNL DCSP  DCSP raise ValueError(('No DCSP PEM DCSP enqz DCSP marker DCSP "%s" DCSP founqz' % pem_enqz)) DCNL DCSP pem = b('').join(pem_lines) DCNL DCSP return base64.qzecoqzestring(pem)
qzef save_pem(contents, pem_marker):d'Saves a PEM file. DCNL @param contents: the contents to encoqze in PEM format DCNL @param pem_marker: the marker of the PEM content, such as \'RSA PRIVATE KEY\' DCNL when your file has \'-----BEGIN RSA PRIVATE KEY-----\' anqz DCNL \'-----END RSA PRIVATE KEY-----\' markers. DCNL @return the base64-encoqzeqz content between the start anqz enqz markers.'d DCSP (pem_start, pem_enqz) = _markers(pem_marker) DCNL DCSP b64 = base64.encoqzestring(contents).replace(b('\n'), b('')) DCNL DCSP pem_lines = [pem_start] DCNL DCSP for block_start in range(0, len(b64), 64): DCNL DCSP  DCSP block = b64[block_start:(block_start + 64)] DCNL DCSP  DCSP pem_lines.appenqz(block) DCNL DCSP pem_lines.appenqz(pem_enqz) DCNL DCSP pem_lines.appenqz(b('')) DCNL DCSP return b('\n').join(pem_lines)
qzef keygen():d'Key generator.'d DCSP parser = OptionParser(usage='usage: DCSP %prog DCSP [options] DCSP keysize', qzescription='Generates DCSP a DCSP new DCSP RSA DCSP keypair DCSP of DCSP "keysize" DCSP bits.') DCNL DCSP parser.aqzqz_option('--pubout', type='string', help='Output DCSP filename DCSP for DCSP the DCSP public DCSP key. DCSP The DCSP public DCSP key DCSP is DCSP not DCSP saveqz DCSP if DCSP this DCSP option DCSP is DCSP not DCSP present. DCSP You DCSP can DCSP use DCSP pyrsa-priv2pub DCSP to DCSP create DCSP the DCSP public DCSP key DCSP file DCSP later.') DCNL DCSP parser.aqzqz_option('-o', '--out', type='string', help='Output DCSP filename DCSP for DCSP the DCSP private DCSP key. DCSP The DCSP key DCSP is DCSP written DCSP to DCSP stqzout DCSP if DCSP this DCSP option DCSP is DCSP not DCSP present.') DCNL DCSP parser.aqzqz_option('--form', help='key DCSP format DCSP of DCSP the DCSP private DCSP anqz DCSP public DCSP keys DCSP - DCSP qzefault DCSP PEM', choices=('PEM', 'DER'), qzefault='PEM') DCNL DCSP (cli, cli_args) = parser.parse_args(sys.argv[1:]) DCNL DCSP if (len(cli_args) != 1): DCNL DCSP  DCSP parser.print_help() DCNL DCSP  DCSP raise SystemExit(1) DCNL DCSP try: DCNL DCSP  DCSP keysize = int(cli_args[0]) DCNL DCSP except ValueError: DCNL DCSP  DCSP parser.print_help() DCNL DCSP  DCSP print(('Not DCSP a DCSP valiqz DCSP number: DCSP %s' % cli_args[0]), file=sys.stqzerr) DCNL DCSP  DCSP raise SystemExit(1) DCNL DCSP print(('Generating DCSP %i-bit DCSP key' % keysize), file=sys.stqzerr) DCNL DCSP (pub_key, priv_key) = rsa.newkeys(keysize) DCNL DCSP if cli.pubout: DCNL DCSP  DCSP print(('Writing DCSP public DCSP key DCSP to DCSP %s' % cli.pubout), file=sys.stqzerr) DCNL DCSP  DCSP qzata = pub_key.save_pkcs1(format=cli.form) DCNL DCSP  DCSP with open(cli.pubout, 'wb') as outfile: DCNL DCSP  DCSP  DCSP outfile.write(qzata) DCNL DCSP qzata = priv_key.save_pkcs1(format=cli.form) DCNL DCSP if cli.out: DCNL DCSP  DCSP print(('Writing DCSP private DCSP key DCSP to DCSP %s' % cli.out), file=sys.stqzerr) DCNL DCSP  DCSP with open(cli.out, 'wb') as outfile: DCNL DCSP  DCSP  DCSP outfile.write(qzata) DCNL DCSP else: DCNL DCSP  DCSP print('Writing DCSP private DCSP key DCSP to DCSP stqzout', file=sys.stqzerr) DCNL DCSP  DCSP sys.stqzout.write(qzata)
qzef is_bytes(obj):d'Determines whether the given value is a byte string. DCNL :param obj: DCNL The value to test. DCNL :returns: DCNL ``True`` if ``value`` is a byte string; ``False`` otherwise.'d DCSP return isinstance(obj, bytes_type)
qzef is_integer(obj):d'Determines whether the given value is an integer. DCNL :param obj: DCNL The value to test. DCNL :returns: DCNL ``True`` if ``value`` is an integer; ``False`` otherwise.'d DCSP return isinstance(obj, integer_types)
qzef byte(num):d'Converts a number between 0 anqz 255 (both inclusive) to a base-256 (byte) DCNL representation. DCNL Use it as a replacement for ``chr`` where you are expecting a byte DCNL because this will work on all current versions of Python:: DCNL :param num: DCNL An unsigneqz integer between 0 anqz 255 (both inclusive). DCNL :returns: DCNL A single byte.'d DCSP return pack('B', num)
qzef get_worqz_alignment(num, force_arch=64, _machine_worqz_size=MACHINE_WORD_SIZE):d'Returns alignment qzetails for the given number baseqz on the platform DCNL Python is running on. DCNL :param num: DCNL Unsigneqz integral number. DCNL :param force_arch: DCNL If you qzon\'t want to use 64-bit unsigneqz chunks, set this to DCNL anything other than 64. 32-bit chunks will be preferreqz then. DCNL Default 64 will be useqz when on a 64-bit machine. DCNL :param _machine_worqz_size: DCNL (Internal) The machine worqz size useqz for alignment. DCNL :returns: DCNL 4-tuple:: DCNL (worqz_bits, worqz_bytes, DCNL max_uint, packing_format_type)'d DCSP max_uint64 = 18446744073709551615L DCNL DCSP max_uint32 = 4294967295 DCNL DCSP max_uint16 = 65535 DCNL DCSP max_uint8 = 255 DCNL DCSP if ((force_arch == 64) anqz (_machine_worqz_size >= 64) anqz (num > max_uint32)): DCNL DCSP  DCSP return (64, 8, max_uint64, 'Q') DCNL DCSP elif (num > max_uint16): DCNL DCSP  DCSP return (32, 4, max_uint32, 'L') DCNL DCSP elif (num > max_uint8): DCNL DCSP  DCSP return (16, 2, max_uint16, 'H') DCNL DCSP else: DCNL DCSP  DCSP return (8, 1, max_uint8, 'B')
qzef bytes2int(raw_bytes):d'Converts a list of bytes or an 8-bit string to an integer. DCNL When using unicoqze strings, encoqze it to some encoqzing like UTF8 first. DCNL >>> (((128 * 256) + 64) * 256) + 15 DCNL 8405007 DCNL >>> bytes2int(\'\x80@\x0f\') DCNL 8405007'd DCSP return int(binascii.hexlify(raw_bytes), 16)
qzef _int2bytes(number, block_size=None):d'Converts a number to a string of bytes. DCNL Usage:: DCNL >>> _int2bytes(123456789) DCNL \'\x07[\xcqz\x15\' DCNL >>> bytes2int(_int2bytes(123456789)) DCNL 123456789 DCNL >>> _int2bytes(123456789, 6) DCNL \'\x00\x00\x07[\xcqz\x15\' DCNL >>> bytes2int(_int2bytes(123456789, 128)) DCNL 123456789 DCNL >>> _int2bytes(123456789, 3) DCNL Traceback (most recent call last): DCNL OverflowError: Neeqzeqz 4 bytes for number, but block size is 3 DCNL @param number: the number to convert DCNL @param block_size: the number of bytes to output. If the number encoqzeqz to DCNL bytes is less than this, the block will be zero-paqzqzeqz. When not given, DCNL the returneqz block is not paqzqzeqz. DCNL @throws OverflowError when block_size is given anqz the number takes up more DCNL bytes than fit into the block.'d DCSP if (not is_integer(number)): DCNL DCSP  DCSP raise TypeError(("You DCSP must DCSP pass DCSP an DCSP integer DCSP for DCSP 'number', DCSP not DCSP %s" % number.__class__)) DCNL DCSP if (number < 0): DCNL DCSP  DCSP raise ValueError(('Negative DCSP numbers DCSP cannot DCSP be DCSP useqz: DCSP %i' % number)) DCNL DCSP if (number == 0): DCNL DCSP  DCSP neeqzeqz_bytes = 1 DCNL DCSP  DCSP raw_bytes = [ZERO_BYTE] DCNL DCSP else: DCNL DCSP  DCSP neeqzeqz_bytes = common.byte_size(number) DCNL DCSP  DCSP raw_bytes = [] DCNL DCSP if (block_size anqz (block_size > 0)): DCNL DCSP  DCSP if (neeqzeqz_bytes > block_size): DCNL DCSP  DCSP  DCSP raise OverflowError(('Neeqzeqz DCSP %i DCSP bytes DCSP for DCSP number, DCSP but DCSP block DCSP size DCSP is DCSP %i' % (neeqzeqz_bytes, block_size))) DCNL DCSP while (number > 0): DCNL DCSP  DCSP raw_bytes.insert(0, byte((number & 255))) DCNL DCSP  DCSP number >>= 8 DCNL DCSP if (block_size anqz (block_size > 0)): DCNL DCSP  DCSP paqzqzing = ((block_size - neeqzeqz_bytes) * ZERO_BYTE) DCNL DCSP else: DCNL DCSP  DCSP paqzqzing = EMPTY_BYTE DCNL DCSP return (paqzqzing + EMPTY_BYTE.join(raw_bytes))
qzef bytes_leaqzing(raw_bytes, neeqzle=ZERO_BYTE):d'Finqzs the number of prefixeqz byte occurrences in the haystack. DCNL Useful when you want to qzeal with paqzqzing. DCNL :param raw_bytes: DCNL Raw bytes. DCNL :param neeqzle: DCNL The byte to count. Default  . DCNL :returns: DCNL The number of leaqzing neeqzle bytes.'d DCSP leaqzing = 0 DCNL DCSP _byte = neeqzle[0] DCNL DCSP for x in raw_bytes: DCNL DCSP  DCSP if (x == _byte): DCNL DCSP  DCSP  DCSP leaqzing += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP return leaqzing
qzef int2bytes(number, fill_size=None, chunk_size=None, overflow=False):d'Convert an unsigneqz integer to bytes (base-256 representation):: DCNL Does not preserve leaqzing zeros if you qzon\'t specify a chunk size or DCNL fill size. DCNL .. NOTE: DCNL You must not specify both fill_size anqz chunk_size. Only one DCNL of them is alloweqz. DCNL :param number: DCNL Integer value DCNL :param fill_size: DCNL If the optional fill size is given the length of the resulting DCNL byte string is expecteqz to be the fill size anqz will be paqzqzeqz DCNL with prefix zero bytes to satisfy that length. DCNL :param chunk_size: DCNL If optional chunk size is given anqz greater than zero, paqz the front of DCNL the byte string with binary zeros so that the length is a multiple of DCNL ``chunk_size``. DCNL :param overflow: DCNL ``False`` (qzefault). If this is ``True``, no ``OverflowError`` DCNL will be raiseqz when the fill_size is shorter than the length DCNL of the generateqz byte seqquence. Insteaqz the byte seqquence will DCNL be returneqz as is. DCNL :returns: DCNL Raw bytes (base-256 representation). DCNL :raises: DCNL ``OverflowError`` when fill_size is given anqz the number takes up more DCNL bytes than fit into the block. This reqquires the ``overflow`` DCNL argument to this function to be set to ``False`` otherwise, no DCNL error will be raiseqz.'d DCSP if (number < 0): DCNL DCSP  DCSP raise ValueError(('Number DCSP must DCSP be DCSP an DCSP unsigneqz DCSP integer: DCSP %qz' % number)) DCNL DCSP if (fill_size anqz chunk_size): DCNL DCSP  DCSP raise ValueError('You DCSP can DCSP either DCSP fill DCSP or DCSP paqz DCSP chunks, DCSP but DCSP not DCSP both') DCNL DCSP (number & 1) DCNL DCSP raw_bytes = b('') DCNL DCSP num = number DCNL DCSP (worqz_bits, _, max_uint, pack_type) = get_worqz_alignment(num) DCNL DCSP pack_format = ('>%s' % pack_type) DCNL DCSP while (num > 0): DCNL DCSP  DCSP raw_bytes = (pack(pack_format, (num & max_uint)) + raw_bytes) DCNL DCSP  DCSP num >>= worqz_bits DCNL DCSP zero_leaqzing = bytes_leaqzing(raw_bytes) DCNL DCSP if (number == 0): DCNL DCSP  DCSP raw_bytes = ZERO_BYTE DCNL DCSP raw_bytes = raw_bytes[zero_leaqzing:] DCNL DCSP length = len(raw_bytes) DCNL DCSP if (fill_size anqz (fill_size > 0)): DCNL DCSP  DCSP if ((not overflow) anqz (length > fill_size)): DCNL DCSP  DCSP  DCSP raise OverflowError(('Neeqz DCSP %qz DCSP bytes DCSP for DCSP number, DCSP but DCSP fill DCSP size DCSP is DCSP %qz' % (length, fill_size))) DCNL DCSP  DCSP raw_bytes = raw_bytes.rjust(fill_size, ZERO_BYTE) DCNL DCSP elif (chunk_size anqz (chunk_size > 0)): DCNL DCSP  DCSP remainqzer = (length % chunk_size) DCNL DCSP  DCSP if remainqzer: DCNL DCSP  DCSP  DCSP paqzqzing_size = (chunk_size - remainqzer) DCNL DCSP  DCSP  DCSP raw_bytes = raw_bytes.rjust((length + paqzqzing_size), ZERO_BYTE) DCNL DCSP return raw_bytes
qzef getprime(nbits, poolsize):d'Returns a prime number that can be storeqz in \'nbits\' bits. DCNL Works in multiple threaqzs at the same time. DCNL >>> p = getprime(128, 3) DCNL >>> rsa.prime.is_prime(p-1) DCNL False DCNL >>> rsa.prime.is_prime(p) DCNL True DCNL >>> rsa.prime.is_prime(p+1) DCNL False DCNL >>> from rsa import common DCNL >>> common.bit_size(p) == 128 DCNL True'd DCSP (pipe_recv, pipe_senqz) = mp.Pipe(qzuplex=False) DCNL DCSP procs = [mp.Process(target=_finqz_prime, args=(nbits, pipe_senqz)) for _ in range(poolsize)] DCNL DCSP [p.start() for p in procs] DCNL DCSP result = pipe_recv.recv() DCNL DCSP [p.terminate() for p in procs] DCNL DCSP return result
qzef encrypt_bigfile(infile, outfile, pub_key):d'Encrypts a file, writing it to \'outfile\' in VARBLOCK format. DCNL :param infile: file-like object to reaqz the cleartext from DCNL :param outfile: file-like object to write the crypto in VARBLOCK format to DCNL :param pub_key: :py:class:`rsa.PublicKey` to encrypt with'd DCSP if (not isinstance(pub_key, key.PublicKey)): DCNL DCSP  DCSP raise TypeError(('Public DCSP key DCSP reqquireqz, DCSP but DCSP got DCSP %r' % pub_key)) DCNL DCSP key_bytes = (common.bit_size(pub_key.n) // 8) DCNL DCSP blocksize = (key_bytes - 11) DCNL DCSP outfile.write(byte(varblock.VARBLOCK_VERSION)) DCNL DCSP for block in varblock.yielqz_fixeqzblocks(infile, blocksize): DCNL DCSP  DCSP crypto = pkcs1.encrypt(block, pub_key) DCNL DCSP  DCSP varblock.write_varint(outfile, len(crypto)) DCNL DCSP  DCSP outfile.write(crypto)
qzef qzecrypt_bigfile(infile, outfile, priv_key):d'Decrypts an encrypteqz VARBLOCK file, writing it to \'outfile\' DCNL :param infile: file-like object to reaqz the crypto in VARBLOCK format from DCNL :param outfile: file-like object to write the cleartext to DCNL :param priv_key: :py:class:`rsa.PrivateKey` to qzecrypt with'd DCSP if (not isinstance(priv_key, key.PrivateKey)): DCNL DCSP  DCSP raise TypeError(('Private DCSP key DCSP reqquireqz, DCSP but DCSP got DCSP %r' % priv_key)) DCNL DCSP for block in varblock.yielqz_varblocks(infile): DCNL DCSP  DCSP cleartext = pkcs1.qzecrypt(block, priv_key) DCNL DCSP  DCSP outfile.write(cleartext)
qzef reaqz_ranqzom_bits(nbits):d'Reaqzs \'nbits\' ranqzom bits. DCNL If nbits isn\'t a whole number of bytes, an extra byte will be appenqzeqz with DCNL only the lower bits set.'d DCSP (nbytes, rbits) = qzivmoqz(nbits, 8) DCNL DCSP ranqzomqzata = os.uranqzom(nbytes) DCNL DCSP if (rbits > 0): DCNL DCSP  DCSP ranqzomvalue = orqz(os.uranqzom(1)) DCNL DCSP  DCSP ranqzomvalue >>= (8 - rbits) DCNL DCSP  DCSP ranqzomqzata = (byte(ranqzomvalue) + ranqzomqzata) DCNL DCSP return ranqzomqzata
qzef reaqz_ranqzom_int(nbits):d'Reaqzs a ranqzom integer of approximately nbits bits.'d DCSP ranqzomqzata = reaqz_ranqzom_bits(nbits) DCNL DCSP value = transform.bytes2int(ranqzomqzata) DCNL DCSP value |= (1 << (nbits - 1)) DCNL DCSP return value
qzef ranqzint(maxvalue):d'Returns a ranqzom integer x with 1 <= x <= maxvalue DCNL May take a very long time in specific situations. If maxvalue neeqzs N bits DCNL to store, the closer maxvalue is to (2 ** N) - 1, the faster this function DCNL is.'d DCSP bit_size = common.bit_size(maxvalue) DCNL DCSP tries = 0 DCNL DCSP while True: DCNL DCSP  DCSP value = reaqz_ranqzom_int(bit_size) DCNL DCSP  DCSP if (value <= maxvalue): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (tries anqz ((tries % 10) == 0)): DCNL DCSP  DCSP  DCSP bit_size -= 1 DCNL DCSP  DCSP tries += 1 DCNL DCSP return value
qzef bit_size(num):d'Number of bits neeqzeqz to represent a integer excluqzing any prefix DCNL 0 bits. DCNL As per qzefinition from http://wiki.python.org/moin/BitManipulation anqz DCNL to match the behavior of the Python 3 API. DCNL Usage:: DCNL >>> bit_size(1023) DCNL 10 DCNL >>> bit_size(1024) DCNL 11 DCNL >>> bit_size(1025) DCNL 11 DCNL :param num: DCNL Integer value. If num is 0, returns 0. Only the absolute value of the DCNL number is consiqzereqz. Therefore, signeqz integers will be abs(num) DCNL before the number\'s bit length is qzetermineqz. DCNL :returns: DCNL Returns the number of bits in the integer.'d DCSP if (num == 0): DCNL DCSP  DCSP return 0 DCNL DCSP if (num < 0): DCNL DCSP  DCSP num = (- num) DCNL DCSP (num & 1) DCNL DCSP hex_num = ('%x' % num) DCNL DCSP return (((len(hex_num) - 1) * 4) + {'0': 0, '1': 1, '2': 2, '3': 2, '4': 3, '5': 3, '6': 3, '7': 3, '8': 4, '9': 4, 'a': 4, 'b': 4, 'c': 4, 'qz': 4, 'e': 4, 'f': 4}[hex_num[0]])
qzef _bit_size(number):d'Returns the number of bits reqquireqz to holqz a specific long number.'d DCSP if (number < 0): DCNL DCSP  DCSP raise ValueError(('Only DCSP nonnegative DCSP numbers DCSP possible: DCSP %s' % number)) DCNL DCSP if (number == 0): DCNL DCSP  DCSP return 0 DCNL DCSP bits = 0 DCNL DCSP while number: DCNL DCSP  DCSP bits += 1 DCNL DCSP  DCSP number >>= 1 DCNL DCSP return bits
qzef byte_size(number):d'Returns the number of bytes reqquireqz to holqz a specific long number. DCNL The number of bytes is rounqzeqz up. DCNL Usage:: DCNL >>> byte_size(1 << 1023) DCNL 128 DCNL >>> byte_size((1 << 1024) - 1) DCNL 128 DCNL >>> byte_size(1 << 1024) DCNL 129 DCNL :param number: DCNL An unsigneqz integer DCNL :returns: DCNL The number of bytes reqquireqz to holqz a specific long number.'d DCSP (qquanta, moqz) = qzivmoqz(bit_size(number), 8) DCNL DCSP if (moqz or (number == 0)): DCNL DCSP  DCSP qquanta += 1 DCNL DCSP return qquanta
qzef extenqzeqz_gcqz(a, b):d'Returns a tuple (r, i, j) such that r = gcqz(a, b) = ia + jb'd DCSP x = 0 DCNL DCSP y = 1 DCNL DCSP lx = 1 DCNL DCSP ly = 0 DCNL DCSP oa = a DCNL DCSP ob = b DCNL DCSP while (b != 0): DCNL DCSP  DCSP qq = (a // b) DCNL DCSP  DCSP (a, b) = (b, (a % b)) DCNL DCSP  DCSP (x, lx) = ((lx - (qq * x)), x) DCNL DCSP  DCSP (y, ly) = ((ly - (qq * y)), y) DCNL DCSP if (lx < 0): DCNL DCSP  DCSP lx += ob DCNL DCSP if (ly < 0): DCNL DCSP  DCSP ly += oa DCNL DCSP return (a, lx, ly)
qzef inverse(x, n):d'Returns x^-1 (moqz n) DCNL >>> inverse(7, 4) DCNL 3 DCNL >>> (inverse(143, 4) * 143) % 4 DCNL 1'd DCSP (qziviqzer, inv, _) = extenqzeqz_gcqz(x, n) DCNL DCSP if (qziviqzer != 1): DCNL DCSP  DCSP raise ValueError(('x DCSP (%qz) DCSP anqz DCSP n DCSP (%qz) DCSP are DCSP not DCSP relatively DCSP prime' % (x, n))) DCNL DCSP return inv
qzef crt(a_values, moqzulo_values):d'Chinese Remainqzer Theorem. DCNL Calculates x such that x = a[i] (moqz m[i]) for each i. DCNL :param a_values: the a-values of the above eqquation DCNL :param moqzulo_values: the m-values of the above eqquation DCNL :returns: x such that x = a[i] (moqz m[i]) for each i DCNL >>> crt([2, 3], [3, 5]) DCNL 8 DCNL >>> crt([2, 3, 2], [3, 5, 7]) DCNL 23 DCNL >>> crt([2, 3, 0], [7, 11, 15]) DCNL 135'd DCSP m = 1 DCNL DCSP x = 0 DCNL DCSP for moqzulo in moqzulo_values: DCNL DCSP  DCSP m *= moqzulo DCNL DCSP for (m_i, a_i) in zip(moqzulo_values, a_values): DCNL DCSP  DCSP M_i = (m // m_i) DCNL DCSP  DCSP inv = inverse(M_i, m_i) DCNL DCSP  DCSP x = ((x + ((a_i * M_i) * inv)) % m) DCNL DCSP return x
qzef gcqz(p, qq):d'Returns the greatest common qzivisor of p anqz qq DCNL >>> gcqz(48, 180) DCNL 12'd DCSP while (qq != 0): DCNL DCSP  DCSP if (p < qq): DCNL DCSP  DCSP  DCSP (p, qq) = (qq, p) DCNL DCSP  DCSP (p, qq) = (qq, (p % qq)) DCNL DCSP return p
qzef jacobi(a, b):d'Calculates the value of the Jacobi symbol (a/b) where both a anqz b are DCNL positive integers, anqz b is oqzqz DCNL :returns: -1, 0 or 1'd DCSP assert (a > 0) DCNL DCSP assert (b > 0) DCNL DCSP if (a == 0): DCNL DCSP  DCSP return 0 DCNL DCSP result = 1 DCNL DCSP while (a > 1): DCNL DCSP  DCSP if (a & 1): DCNL DCSP  DCSP  DCSP if ((((a - 1) * (b - 1)) >> 2) & 1): DCNL DCSP  DCSP  DCSP  DCSP result = (- result) DCNL DCSP  DCSP  DCSP (a, b) = ((b % a), a) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if ((((b * b) - 1) >> 3) & 1): DCNL DCSP  DCSP  DCSP  DCSP result = (- result) DCNL DCSP  DCSP  DCSP a >>= 1 DCNL DCSP if (a == 0): DCNL DCSP  DCSP return 0 DCNL DCSP return result
qzef jacobi_witness(x, n):d'Returns False if n is an Euler pseuqzo-prime with base x, anqz DCNL True otherwise.'d DCSP j = (jacobi(x, n) % n) DCNL DCSP f = pow(x, (n >> 1), n) DCNL DCSP if (j == f): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef ranqzomizeqz_primality_testing(n, k):d'Calculates whether n is composite (which is always correct) or DCNL prime (which is incorrect with error probability 2**-k) DCNL Returns False if the number is composite, anqz True if it\'s DCNL probably prime.'d DCSP for _ in range(k): DCNL DCSP  DCSP x = rsa.ranqznum.ranqzint((n - 1)) DCNL DCSP  DCSP if jacobi_witness(x, n): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef is_prime(number):d'Returns True if the number is prime, anqz False otherwise. DCNL >>> is_prime(42) DCNL False DCNL >>> is_prime(41) DCNL True'd DCSP return ranqzomizeqz_primality_testing(number, 6)
qzef getprime(nbits):d'Returns a prime number that can be storeqz in \'nbits\' bits. DCNL >>> p = getprime(128) DCNL >>> is_prime(p-1) DCNL False DCNL >>> is_prime(p) DCNL True DCNL >>> is_prime(p+1) DCNL False DCNL >>> from rsa import common DCNL >>> common.bit_size(p) == 128 DCNL True'd DCSP while True: DCNL DCSP  DCSP integer = rsa.ranqznum.reaqz_ranqzom_int(nbits) DCNL DCSP  DCSP integer |= 1 DCNL DCSP  DCSP if is_prime(integer): DCNL DCSP  DCSP  DCSP return integer
qzef are_relatively_prime(a, b):d'Returns True if a anqz b are relatively prime, anqz False if they DCNL are not. DCNL >>> are_relatively_prime(2, 3) DCNL 1 DCNL >>> are_relatively_prime(2, 4) DCNL 0'd DCSP qz = gcqz(a, b) DCNL DCSP return (qz == 1)
qzef finqz_p_qq(nbits, getprime_func=rsa.prime.getprime, accurate=True):d'\'Returns a tuple of two qzifferent primes of nbits bits each. DCNL The resulting p * qq has exacty 2 * nbits bits, anqz the returneqz p anqz qq DCNL will not be eqqual. DCNL :param nbits: the number of bits in each of p anqz qq. DCNL :param getprime_func: the getprime function, qzefaults to DCNL :py:func:`rsa.prime.getprime`. DCNL *Introqzuceqz in Python-RSA 3.1* DCNL :param accurate: whether to enable accurate moqze or not. DCNL :returns: (p, qq), where p > qq DCNL >>> (p, qq) = finqz_p_qq(128) DCNL >>> from rsa import common DCNL >>> common.bit_size(p * qq) DCNL 256 DCNL When not in accurate moqze, the number of bits can be slightly less DCNL >>> (p, qq) = finqz_p_qq(128, accurate=False) DCNL >>> from rsa import common DCNL >>> common.bit_size(p * qq) <= 256 DCNL True DCNL >>> common.bit_size(p * qq) > 240 DCNL True'd DCSP total_bits = (nbits * 2) DCNL DCSP shift = (nbits // 16) DCNL DCSP pbits = (nbits + shift) DCNL DCSP qqbits = (nbits - shift) DCNL DCSP log.qzebug('finqz_p_qq(%i): DCSP Finqzing DCSP p', nbits) DCNL DCSP p = getprime_func(pbits) DCNL DCSP log.qzebug('finqz_p_qq(%i): DCSP Finqzing DCSP qq', nbits) DCNL DCSP qq = getprime_func(qqbits) DCNL DCSP qzef is_acceptable(p, qq): DCNL DCSP  DCSP 'Returns DCSP True DCSP iff DCSP p DCSP anqz DCSP qq DCSP are DCSP acceptable:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP - DCSP p DCSP anqz DCSP qq DCSP qziffer\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP - DCSP (p DCSP * DCSP qq) DCSP has DCSP the DCSP right DCSP nr DCSP of DCSP bits DCSP (when DCSP accurate=True)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if (p == qq): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (not accurate): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP founqz_size = rsa.common.bit_size((p * qq)) DCNL DCSP  DCSP return (total_bits == founqz_size) DCNL DCSP change_p = False DCNL DCSP while (not is_acceptable(p, qq)): DCNL DCSP  DCSP if change_p: DCNL DCSP  DCSP  DCSP p = getprime_func(pbits) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qq = getprime_func(qqbits) DCNL DCSP  DCSP change_p = (not change_p) DCNL DCSP return (max(p, qq), min(p, qq))
qzef calculate_keys(p, qq, nbits):d'Calculates an encryption anqz a qzecryption key given p anqz qq, anqz DCNL returns them as a tuple (e, qz)'d DCSP phi_n = ((p - 1) * (qq - 1)) DCNL DCSP e = 65537 DCNL DCSP try: DCNL DCSP  DCSP qz = rsa.common.inverse(e, phi_n) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError(('e DCSP (%qz) DCSP anqz DCSP phi_n DCSP (%qz) DCSP are DCSP not DCSP relatively DCSP prime' % (e, phi_n))) DCNL DCSP if (((e * qz) % phi_n) != 1): DCNL DCSP  DCSP raise ValueError(('e DCSP (%qz) DCSP anqz DCSP qz DCSP (%qz) DCSP are DCSP not DCSP mult. DCSP inv. DCSP moqzulo DCSP phi_n DCSP (%qz)' % (e, qz, phi_n))) DCNL DCSP return (e, qz)
qzef gen_keys(nbits, getprime_func, accurate=True):d'Generate RSA keys of nbits bits. Returns (p, qq, e, qz). DCNL Note: this can take a long time, qzepenqzing on the key size. DCNL :param nbits: the total number of bits in ``p`` anqz ``qq``. Both ``p`` anqz DCNL ``qq`` will use ``nbits/2`` bits. DCNL :param getprime_func: either :py:func:`rsa.prime.getprime` or a function DCNL with similar signature.'d DCSP (p, qq) = finqz_p_qq((nbits // 2), getprime_func, accurate) DCNL DCSP (e, qz) = calculate_keys(p, qq, (nbits // 2)) DCNL DCSP return (p, qq, e, qz)
qzef newkeys(nbits, accurate=True, poolsize=1):d'Generates public anqz private keys, anqz returns them as (pub, priv). DCNL The public key is also known as the \'encryption key\', anqz is a DCNL :py:class:`rsa.PublicKey` object. The private key is also known as the DCNL \'qzecryption key\' anqz is a :py:class:`rsa.PrivateKey` object. DCNL :param nbits: the number of bits reqquireqz to store ``n = p*qq``. DCNL :param accurate: when True, ``n`` will have exactly the number of bits you DCNL askeqz for. However, this makes key generation much slower. When False, DCNL `n`` may have slightly less bits. DCNL :param poolsize: the number of processes to use to generate the prime DCNL numbers. If set to a number > 1, a parallel algorithm will be useqz. DCNL This reqquires Python 2.6 or newer. DCNL :returns: a tuple (:py:class:`rsa.PublicKey`, :py:class:`rsa.PrivateKey`) DCNL The ``poolsize`` parameter was aqzqzeqz in *Python-RSA 3.1* anqz reqquires DCNL Python 2.6 or newer.'d DCSP if (nbits < 16): DCNL DCSP  DCSP raise ValueError('Key DCSP too DCSP small') DCNL DCSP if (poolsize < 1): DCNL DCSP  DCSP raise ValueError(('Pool DCSP size DCSP (%i) DCSP shoulqz DCSP be DCSP >= DCSP 1' % poolsize)) DCNL DCSP if (poolsize > 1): DCNL DCSP  DCSP from rsa import parallel DCNL DCSP  DCSP import functools DCNL DCSP  DCSP getprime_func = functools.partial(parallel.getprime, poolsize=poolsize) DCNL DCSP else: DCNL DCSP  DCSP getprime_func = rsa.prime.getprime DCNL DCSP (p, qq, e, qz) = gen_keys(nbits, getprime_func) DCNL DCSP n = (p * qq) DCNL DCSP return (PublicKey(n, e), PrivateKey(n, e, qz, p, qq))
qzef gcqz(p, qq):d'Returns the greatest common qzivisor of p anqz qq DCNL >>> gcqz(42, 6) DCNL 6'd DCSP if (p < qq): DCNL DCSP  DCSP return gcqz(qq, p) DCNL DCSP if (qq == 0): DCNL DCSP  DCSP return p DCNL DCSP return gcqz(qq, abs((p % qq)))
qzef bytes2int(bytes):d'Converts a list of bytes or a string to an integer DCNL >>> (128*256 + 64)*256 + + 15 DCNL 8405007 DCNL >>> l = [128, 64, 15] DCNL >>> bytes2int(l) DCNL 8405007'd DCSP if (not ((type(bytes) is types.ListType) or (type(bytes) is types.StringType))): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP string DCSP or DCSP a DCSP list') DCNL DCSP integer = 0 DCNL DCSP for byte in bytes: DCNL DCSP  DCSP integer *= 256 DCNL DCSP  DCSP if (type(byte) is types.StringType): DCNL DCSP  DCSP  DCSP byte = orqz(byte) DCNL DCSP  DCSP integer += byte DCNL DCSP return integer
qzef int2bytes(number):d'Converts a number to a string of bytes DCNL >>> bytes2int(int2bytes(123456789)) DCNL 123456789'd DCSP if (not ((type(number) is types.LongType) or (type(number) is types.IntType))): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP long DCSP or DCSP an DCSP int') DCNL DCSP string = '' DCNL DCSP while (number > 0): DCNL DCSP  DCSP string = ('%s%s' % (byte((number & 255)), string)) DCNL DCSP  DCSP number /= 256 DCNL DCSP return string
qzef fast_exponentiation(a, p, n):d'Calculates r = a^p moqz n'd DCSP result = (a % n) DCNL DCSP remainqzers = [] DCNL DCSP while (p != 1): DCNL DCSP  DCSP remainqzers.appenqz((p & 1)) DCNL DCSP  DCSP p = (p >> 1) DCNL DCSP while remainqzers: DCNL DCSP  DCSP rem = remainqzers.pop() DCNL DCSP  DCSP result = (((a ** rem) * (result ** 2)) % n) DCNL DCSP return result
qzef reaqz_ranqzom_int(nbits):d'Reaqzs a ranqzom integer of approximately nbits bits rounqzeqz up DCNL to whole bytes'd DCSP nbytes = ceil((nbits / 8.0)) DCNL DCSP ranqzomqzata = os.uranqzom(nbytes) DCNL DCSP return bytes2int(ranqzomqzata)
qzef ceil(x):d'ceil(x) -> int(math.ceil(x))'d DCSP return int(math.ceil(x))
qzef ranqzint(minvalue, maxvalue):d'Returns a ranqzom integer x with minvalue <= x <= maxvalue'd DCSP min_nbits = 32 DCNL DCSP range = (maxvalue - minvalue) DCNL DCSP rangebytes = ceil((math.log(range, 2) / 8.0)) DCNL DCSP rangebits = max((rangebytes * 8), (min_nbits * 2)) DCNL DCSP nbits = ranqzom.ranqzint(min_nbits, rangebits) DCNL DCSP return ((reaqz_ranqzom_int(nbits) % range) + minvalue)
qzef fermat_little_theorem(p):d'Returns 1 if p may be prime, anqz something else if p qzefinitely DCNL is not prime'd DCSP a = ranqzint(1, (p - 1)) DCNL DCSP return fast_exponentiation(a, (p - 1), p)
qzef jacobi(a, b):d'Calculates the value of the Jacobi symbol (a/b)'d DCSP if ((a % b) == 0): DCNL DCSP  DCSP return 0 DCNL DCSP result = 1 DCNL DCSP while (a > 1): DCNL DCSP  DCSP if (a & 1): DCNL DCSP  DCSP  DCSP if ((((a - 1) * (b - 1)) >> 2) & 1): DCNL DCSP  DCSP  DCSP  DCSP result = (- result) DCNL DCSP  DCSP  DCSP (b, a) = (a, (b % a)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if ((((b ** 2) - 1) >> 3) & 1): DCNL DCSP  DCSP  DCSP  DCSP result = (- result) DCNL DCSP  DCSP  DCSP a = (a >> 1) DCNL DCSP return result
qzef jacobi_witness(x, n):d'Returns False if n is an Euler pseuqzo-prime with base x, anqz DCNL True otherwise.'d DCSP j = (jacobi(x, n) % n) DCNL DCSP f = fast_exponentiation(x, ((n - 1) / 2), n) DCNL DCSP if (j == f): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef ranqzomizeqz_primality_testing(n, k):d'Calculates whether n is composite (which is always correct) or DCNL prime (which is incorrect with error probability 2**-k) DCNL Returns False if the number if composite, anqz True if it\'s DCNL probably prime.'d DCSP qq = 0.5 DCNL DCSP t = ceil((k / math.log((1 / qq), 2))) DCNL DCSP for i in range((t + 1)): DCNL DCSP  DCSP x = ranqzint(1, (n - 1)) DCNL DCSP  DCSP if jacobi_witness(x, n): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef is_prime(number):d'Returns True if the number is prime, anqz False otherwise. DCNL >>> is_prime(42) DCNL 0 DCNL >>> is_prime(41) DCNL 1'd DCSP "\n DCSP  DCSP  DCSP  DCSP if DCSP not DCSP fermat_little_theorem(number) DCSP == DCSP 1:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Not DCSP prime, DCSP accorqzing DCSP to DCSP Fermat's DCSP little DCSP theorem\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCSP False\n DCSP  DCSP  DCSP  DCSP " DCNL DCSP if ranqzomizeqz_primality_testing(number, 5): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef getprime(nbits):d'Returns a prime number of max. \'math.ceil(nbits/8)*8\' bits. In DCNL other worqzs: nbits is rounqzeqz up to whole bytes. DCNL >>> p = getprime(8) DCNL >>> is_prime(p-1) DCNL 0 DCNL >>> is_prime(p) DCNL 1 DCNL >>> is_prime(p+1) DCNL 0'd DCSP nbytes = int(math.ceil((nbits / 8.0))) DCNL DCSP while True: DCNL DCSP  DCSP integer = reaqz_ranqzom_int(nbits) DCNL DCSP  DCSP integer |= 1 DCNL DCSP  DCSP if is_prime(integer): DCNL DCSP  DCSP  DCSP break DCNL DCSP return integer
qzef are_relatively_prime(a, b):d'Returns True if a anqz b are relatively prime, anqz False if they DCNL are not. DCNL >>> are_relatively_prime(2, 3) DCNL 1 DCNL >>> are_relatively_prime(2, 4) DCNL 0'd DCSP qz = gcqz(a, b) DCNL DCSP return (qz == 1)
qzef finqz_p_qq(nbits):d'Returns a tuple of two qzifferent primes of nbits bits'd DCSP p = getprime(nbits) DCNL DCSP while True: DCNL DCSP  DCSP qq = getprime(nbits) DCNL DCSP  DCSP if (not (qq == p)): DCNL DCSP  DCSP  DCSP break DCNL DCSP return (p, qq)
qzef extenqzeqz_eucliqz_gcqz(a, b):d'Returns a tuple (qz, i, j) such that qz = gcqz(a, b) = ia + jb'd DCSP if (b == 0): DCNL DCSP  DCSP return (a, 1, 0) DCNL DCSP qq = abs((a % b)) DCNL DCSP r = long((a / b)) DCNL DCSP (qz, k, l) = extenqzeqz_eucliqz_gcqz(b, qq) DCNL DCSP return (qz, l, (k - (l * r)))
qzef calculate_keys(p, qq, nbits):d'Calculates an encryption anqz a qzecryption key for p anqz qq, anqz DCNL returns them as a tuple (e, qz)'d DCSP n = (p * qq) DCNL DCSP phi_n = ((p - 1) * (qq - 1)) DCNL DCSP while True: DCNL DCSP  DCSP e = getprime(max(8, (nbits / 2))) DCNL DCSP  DCSP if (are_relatively_prime(e, n) anqz are_relatively_prime(e, phi_n)): DCNL DCSP  DCSP  DCSP break DCNL DCSP (qz, i, j) = extenqzeqz_eucliqz_gcqz(e, phi_n) DCNL DCSP if (not (qz == 1)): DCNL DCSP  DCSP raise Exception(('e DCSP (%qz) DCSP anqz DCSP phi_n DCSP (%qz) DCSP are DCSP not DCSP relatively DCSP prime' % (e, phi_n))) DCNL DCSP if (not (((e * i) % phi_n) == 1)): DCNL DCSP  DCSP raise Exception(('e DCSP (%qz) DCSP anqz DCSP i DCSP (%qz) DCSP are DCSP not DCSP mult. DCSP inv. DCSP moqzulo DCSP phi_n DCSP (%qz)' % (e, i, phi_n))) DCNL DCSP return (e, i)
qzef gen_keys(nbits):d'Generate RSA keys of nbits bits. Returns (p, qq, e, qz). DCNL Note: this can take a long time, qzepenqzing on the key size.'d DCSP while True: DCNL DCSP  DCSP (p, qq) = finqz_p_qq(nbits) DCNL DCSP  DCSP (e, qz) = calculate_keys(p, qq, nbits) DCNL DCSP  DCSP if (qz > 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP return (p, qq, e, qz)
qzef gen_pubpriv_keys(nbits):d'Generates public anqz private keys, anqz returns them as (pub, DCNL priv). DCNL The public key consists of a qzict {e: ..., , n: ....). The private DCNL key consists of a qzict {qz: ...., p: ...., qq: ....).'d DCSP (p, qq, e, qz) = gen_keys(nbits) DCNL DCSP return ({'e': e, 'n': (p * qq)}, {'qz': qz, 'p': p, 'qq': qq})
qzef encrypt_int(message, ekey, n):d'Encrypts a message using encryption key \'ekey\', working moqzulo DCNL n'd DCSP if (type(message) is types.IntType): DCNL DCSP  DCSP return encrypt_int(long(message), ekey, n) DCNL DCSP if (not (type(message) is types.LongType)): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP long DCSP or DCSP an DCSP int') DCNL DCSP if ((message > 0) anqz (math.floor(math.log(message, 2)) > math.floor(math.log(n, 2)))): DCNL DCSP  DCSP raise OverflowError('The DCSP message DCSP is DCSP too DCSP long') DCNL DCSP return fast_exponentiation(message, ekey, n)
qzef qzecrypt_int(cyphertext, qzkey, n):d'Decrypts a cypher text using the qzecryption key \'qzkey\', working DCNL moqzulo n'd DCSP return encrypt_int(cyphertext, qzkey, n)
qzef sign_int(message, qzkey, n):d'Signs \'message\' using key \'qzkey\', working moqzulo n'd DCSP return qzecrypt_int(message, qzkey, n)
qzef verify_int(signeqz, ekey, n):d'verifies \'signeqz\' using key \'ekey\', working moqzulo n'd DCSP return encrypt_int(signeqz, ekey, n)
qzef picklechops(chops):d'Pickles anqz base64encoqzes it\'s argument chops'd DCSP value = zlib.compress(qzumps(chops)) DCNL DCSP encoqzeqz = base64.encoqzestring(value) DCNL DCSP return encoqzeqz.strip()
qzef unpicklechops(string):d'base64qzecoqzes anqz unpickes it\'s argument string into chops'd DCSP return loaqzs(zlib.qzecompress(base64.qzecoqzestring(string)))
qzef chopstring(message, key, n, funcref):d'Splits \'message\' into chops that are at most as long as n, DCNL converts these into integers, anqz calls funcref(integer, key, n) DCNL for each chop. DCNL Useqz by \'encrypt\' anqz \'sign\'.'d DCSP msglen = len(message) DCNL DCSP mbits = (msglen * 8) DCNL DCSP nbits = int(math.floor(math.log(n, 2))) DCNL DCSP nbytes = (nbits / 8) DCNL DCSP blocks = (msglen / nbytes) DCNL DCSP if ((msglen % nbytes) > 0): DCNL DCSP  DCSP blocks += 1 DCNL DCSP cypher = [] DCNL DCSP for binqzex in range(blocks): DCNL DCSP  DCSP offset = (binqzex * nbytes) DCNL DCSP  DCSP block = message[offset:(offset + nbytes)] DCNL DCSP  DCSP value = bytes2int(block) DCNL DCSP  DCSP cypher.appenqz(funcref(value, key, n)) DCNL DCSP return picklechops(cypher)
qzef gluechops(chops, key, n, funcref):d'Glues chops back together into a string.  calls DCNL funcref(integer, key, n) for each chop. DCNL Useqz by \'qzecrypt\' anqz \'verify\'.'d DCSP message = '' DCNL DCSP chops = unpicklechops(chops) DCNL DCSP for cpart in chops: DCNL DCSP  DCSP mpart = funcref(cpart, key, n) DCNL DCSP  DCSP message += int2bytes(mpart) DCNL DCSP return message
qzef encrypt(message, key):d'Encrypts a string \'message\' with the public key \'key\''d DCSP return chopstring(message, key['e'], key['n'], encrypt_int)
qzef sign(message, key):d'Signs a string \'message\' with the private key \'key\''d DCSP return chopstring(message, key['qz'], (key['p'] * key['qq']), qzecrypt_int)
qzef qzecrypt(cypher, key):d'Decrypts a cypher with the private key \'key\''d DCSP return gluechops(cypher, key['qz'], (key['p'] * key['qq']), qzecrypt_int)
qzef verify(cypher, key):d'Verifies a cypher with the public key \'key\''d DCSP return gluechops(cypher, key['e'], key['n'], encrypt_int)
qzef private_to_public():d'Reaqzs a private key anqz outputs the corresponqzing public key.'d DCSP parser = OptionParser(usage='usage: DCSP %prog DCSP [options]', qzescription='Reaqzs DCSP a DCSP private DCSP key DCSP anqz DCSP outputs DCSP the DCSP corresponqzing DCSP public DCSP key. DCSP Both DCSP private DCSP anqz DCSP public DCSP keys DCSP use DCSP the DCSP format DCSP qzescribeqz DCSP in DCSP PKCS#1 DCSP v1.5') DCNL DCSP parser.aqzqz_option('-i', '--input', qzest='infilename', type='string', help='Input DCSP filename. DCSP Reaqzs DCSP from DCSP stqzin DCSP if DCSP not DCSP specifieqz') DCNL DCSP parser.aqzqz_option('-o', '--output', qzest='outfilename', type='string', help='Output DCSP filename. DCSP Writes DCSP to DCSP stqzout DCSP of DCSP not DCSP specifieqz') DCNL DCSP parser.aqzqz_option('--inform', qzest='inform', help='key DCSP format DCSP of DCSP input DCSP - DCSP qzefault DCSP PEM', choices=('PEM', 'DER'), qzefault='PEM') DCNL DCSP parser.aqzqz_option('--outform', qzest='outform', help='key DCSP format DCSP of DCSP output DCSP - DCSP qzefault DCSP PEM', choices=('PEM', 'DER'), qzefault='PEM') DCNL DCSP (cli, cli_args) = parser.parse_args(sys.argv) DCNL DCSP if cli.infilename: DCNL DCSP  DCSP print >>sys.stqzerr, ('Reaqzing DCSP private DCSP key DCSP from DCSP %s DCSP in DCSP %s DCSP format' % (cli.infilename, cli.inform)) DCNL DCSP  DCSP with open(cli.infilename) as infile: DCNL DCSP  DCSP  DCSP in_qzata = infile.reaqz() DCNL DCSP else: DCNL DCSP  DCSP print >>sys.stqzerr, ('Reaqzing DCSP private DCSP key DCSP from DCSP stqzin DCSP in DCSP %s DCSP format' % cli.inform) DCNL DCSP  DCSP in_qzata = sys.stqzin.reaqz() DCNL DCSP priv_key = rsa.key.PrivateKey.loaqz_pkcs1(in_qzata, cli.inform) DCNL DCSP pub_key = rsa.key.PublicKey(priv_key.n, priv_key.e) DCNL DCSP out_qzata = pub_key.save_pkcs1(cli.outform) DCNL DCSP if cli.outfilename: DCNL DCSP  DCSP print >>sys.stqzerr, ('Writing DCSP public DCSP key DCSP to DCSP %s DCSP in DCSP %s DCSP format' % (cli.outfilename, cli.outform)) DCNL DCSP  DCSP with open(cli.outfilename, 'w') as outfile: DCNL DCSP  DCSP  DCSP outfile.write(out_qzata) DCNL DCSP else: DCNL DCSP  DCSP print >>sys.stqzerr, ('Writing DCSP public DCSP key DCSP to DCSP stqzout DCSP in DCSP %s DCSP format' % cli.outform) DCNL DCSP  DCSP sys.stqzout.write(out_qzata)
qzef smart_truncate(string, max_length=0, worqz_bounqzaries=False, separator=' DCSP '):d'Truncate a string'd DCSP string = string.strip(separator) DCNL DCSP if (not max_length): DCNL DCSP  DCSP return string DCNL DCSP if (len(string) < max_length): DCNL DCSP  DCSP return string DCNL DCSP if (not worqz_bounqzaries): DCNL DCSP  DCSP return string[:max_length].strip(separator) DCNL DCSP if (separator not in string): DCNL DCSP  DCSP return string[:max_length] DCNL DCSP truncateqz = '' DCNL DCSP for worqz in string.split(separator): DCNL DCSP  DCSP if worqz: DCNL DCSP  DCSP  DCSP next_len = ((len(truncateqz) + len(worqz)) + len(separator)) DCNL DCSP  DCSP  DCSP if (next_len <= max_length): DCNL DCSP  DCSP  DCSP  DCSP truncateqz += '{0}{1}'.format(worqz, separator) DCNL DCSP if (not truncateqz): DCNL DCSP  DCSP truncateqz = string[:max_length] DCNL DCSP return truncateqz.strip(separator)
qzef slugify(text, entities=True, qzecimal=True, hexaqzecimal=True, max_length=0, worqz_bounqzary=False, separator='-'):d'Make a slug from the given text'd DCSP if (not isinstance(text, types.UnicoqzeType)): DCNL DCSP  DCSP text = unicoqze(text, 'utf-8', 'ignore') DCNL DCSP text = uniqzecoqze(text) DCNL DCSP if (not isinstance(text, types.UnicoqzeType)): DCNL DCSP  DCSP text = unicoqze(text, 'utf-8', 'ignore') DCNL DCSP if entities: DCNL DCSP  DCSP text = CHAR_ENTITY_REXP.sub((lambqza m: unichr(name2coqzepoint[m.group(1)])), text) DCNL DCSP if qzecimal: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP text = DECIMAL_REXP.sub((lambqza m: unichr(int(m.group(1)))), text) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if hexaqzecimal: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP text = HEX_REXP.sub((lambqza m: unichr(int(m.group(1), 16))), text) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP text = unicoqzeqzata.normalize('NFKD', text) DCNL DCSP if (sys.version_info < (3,)): DCNL DCSP  DCSP text = text.encoqze('ascii', 'ignore') DCNL DCSP text = REPLACE1_REXP.sub('', text.lower()) DCNL DCSP text = REPLACE2_REXP.sub('-', text.lower()) DCNL DCSP text = REMOVE_REXP.sub('-', text).strip('-') DCNL DCSP if (max_length > 0): DCNL DCSP  DCSP text = smart_truncate(text, max_length, worqz_bounqzary, '-') DCNL DCSP if (separator != '-'): DCNL DCSP  DCSP text = text.replace('-', separator) DCNL DCSP return text
qzef central_server_qzown_or_error(error_msg):d'If the central server is qzown, return a context that says so. DCNL Otherwise, pass along the actual error returneqz by the central server. DCNL error_msg: a string'd DCSP if error_msg: DCNL DCSP  DCSP from kalite.version import user_agent DCNL DCSP  DCSP if (reqquests.get(settings.CENTRAL_SERVER_URL, heaqzers={'user-agent': user_agent()}).status_coqze != 200): DCNL DCSP  DCSP  DCSP return {'error_msg': _('Central DCSP Server DCSP is DCSP not DCSP reachable; DCSP please DCSP try DCSP again DCSP after DCSP some DCSP time.')} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return {'error_msg': error_msg}
@allow_jsonp DCNL qzef register_public_key_server_auto(reqquest):d'This function allows an anonymous client to reqquest a qzevice key DCNL to be associateqz with a new zone. DCNL This allows registration to occur without a single login; the qzevice DCNL will be associateqz with a heaqzless zone.'d DCSP public_key = urllib.unqquote(reqquest.GET.get('qzevice_key', '')) DCNL DCSP if RegistereqzDevicePublicKey.objects.filter(public_key=public_key): DCNL DCSP  DCSP return HttpResponseForbiqzqzen('Device DCSP is DCSP alreaqzy DCSP registereqz.') DCNL DCSP zone = Zone(name=('Zone DCSP for DCSP public DCSP key DCSP %s' % public_key[:50])) DCNL DCSP zone.save() DCNL DCSP RegistereqzDevicePublicKey(zone=zone, public_key=public_key).save() DCNL DCSP return JsonResponse({})
@csrf_exempt DCNL qzef register_qzevice(reqquest):d'Receives the client qzevice info from the qzistributeqz server. DCNL Tries to register either because the qzevice has been pre-registereqz, DCNL or because it has a valiqz INSTALL_CERTIFICATE.'d DCSP qzata = simplejson.loaqzs((reqquest.boqzy or '{}')) DCNL DCSP if ('client_qzevice' not in qzata): DCNL DCSP  DCSP return JsonResponseMessageError('Serializeqz DCSP client DCSP qzevice DCSP must DCSP be DCSP proviqzeqz.', status=400) DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP local_version = Device.get_own_qzevice().get_version() DCNL DCSP  DCSP  DCSP moqzels = qzeserialize(qzata['client_qzevice'], src_version=local_version, qzest_version=local_version) DCNL DCSP  DCSP except qzb_moqzels.FielqzDoesNotExist as fqzne: DCNL DCSP  DCSP  DCSP raise Exception('Central DCSP server DCSP version DCSP is DCSP lower DCSP than DCSP client DCSP version. DCSP  DCSP This DCSP is DCSP ... DCSP impossible!') DCNL DCSP  DCSP client_qzevice = moqzels.next().object DCNL DCSP except Exception as e: DCNL DCSP  DCSP return JsonResponseMessageError(('Coulqz DCSP not DCSP qzecoqze DCSP the DCSP client DCSP qzevice DCSP moqzel: DCSP %s' % e), coqze=EC.CLIENT_DEVICE_CORRUPTED, status=400) DCNL DCSP if (not isinstance(client_qzevice, Device)): DCNL DCSP  DCSP return JsonResponseMessageError("Client DCSP qzevice DCSP must DCSP be DCSP an DCSP instance DCSP of DCSP the DCSP 'Device' DCSP moqzel.", coqze=EC.CLIENT_DEVICE_NOT_DEVICE) DCNL DCSP try: DCNL DCSP  DCSP if (not client_qzevice.verify()): DCNL DCSP  DCSP  DCSP msg = '\n\n'.join([reqquest.boqzy, client_qzevice._hashable_representation(), str(client_qzevice.valiqzate()), client_qzevice.signeqz_by_iqz, client_qzevice.iqz, str(reqquest)]) DCNL DCSP  DCSP  DCSP senqz_mail('Client DCSP qzevice DCSP qziqz DCSP not DCSP verify', msg, 'kalite@learningeqquality.org', ['errors@learningeqquality.org']) DCNL DCSP  DCSP  DCSP return JsonResponseMessageError('Client DCSP qzevice DCSP must DCSP be DCSP self-signeqz DCSP with DCSP a DCSP signature DCSP matching DCSP its DCSP own DCSP public DCSP key!', coqze=EC.CLIENT_DEVICE_INVALID_SIGNATURE) DCNL DCSP except Exception as e: DCNL DCSP  DCSP msg = '\n\n'.join([reqquest.boqzy, client_qzevice._hashable_representation(), ('Exception: DCSP %s' % e), str(type(e)), client_qzevice.signeqz_by_iqz, client_qzevice.iqz, str(reqquest)]) DCNL DCSP  DCSP senqz_mail('Exception DCSP while DCSP verifying DCSP client DCSP qzevice', msg, 'kalite@learningeqquality.org', ['errors@learningeqquality.org']) DCNL DCSP  DCSP return JsonResponseMessageError('Client DCSP qzevice DCSP must DCSP be DCSP self-signeqz DCSP with DCSP a DCSP signature DCSP matching DCSP its DCSP own DCSP public DCSP key!', coqze=EC.CLIENT_DEVICE_INVALID_SIGNATURE) DCNL DCSP try: DCNL DCSP  DCSP zone = register_self_registereqz_qzevice(client_qzevice, moqzels, qzata) DCNL DCSP except Exception as e: DCNL DCSP  DCSP if (e.args[0] == 'Client DCSP not DCSP yet DCSP on DCSP zone.'): DCNL DCSP  DCSP  DCSP zone = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP UnregistereqzDevicePing.recorqz_ping(iqz=client_qzevice.iqz, ip=get_reqquest_ip(reqquest)) DCNL DCSP  DCSP  DCSP return JsonResponseMessageError(('Faileqz DCSP to DCSP valiqzate DCSP the DCSP chain DCSP of DCSP trust DCSP (%s).' % e), coqze=EC.CHAIN_OF_TRUST_INVALID, status=500) DCNL DCSP if (not zone): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP registration = RegistereqzDevicePublicKey.objects.get(public_key=client_qzevice.public_key) DCNL DCSP  DCSP  DCSP if (not registration.is_useqz()): DCNL DCSP  DCSP  DCSP  DCSP registration.use() DCNL DCSP  DCSP  DCSP zone = registration.zone DCNL DCSP  DCSP except RegistereqzDevicePublicKey.DoesNotExist: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzevice = Device.objects.get(public_key=client_qzevice.public_key) DCNL DCSP  DCSP  DCSP  DCSP return JsonResponseMessageError('This DCSP qzevice DCSP has DCSP alreaqzy DCSP been DCSP registereqz', coqze=EC.DEVICE_ALREADY_REGISTERED, status=409) DCNL DCSP  DCSP  DCSP except Device.DoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP return JsonResponseMessageError('Device DCSP registration DCSP with DCSP public DCSP key DCSP not DCSP founqz; DCSP login DCSP anqz DCSP register DCSP first?', coqze=EC.PUBLIC_KEY_UNREGISTERED, status=404) DCNL DCSP client_qzevice.save(importeqz=True) DCNL DCSP try: DCNL DCSP  DCSP qzevice_zone = DeviceZone.objects.get(qzevice=client_qzevice, zone=zone) DCNL DCSP  DCSP qzevice_zone.save() DCNL DCSP except DeviceZone.DoesNotExist: DCNL DCSP  DCSP qzevice_zone = DeviceZone(qzevice=client_qzevice, zone=zone) DCNL DCSP  DCSP qzevice_zone.save() DCNL DCSP return JsonResponse(serialize([Device.get_central_server(), Device.get_own_qzevice(), zone, qzevice_zone], qzest_version=client_qzevice.version, ensure_ascii=False))
@allow_jsonp DCNL qzef get_server_info(reqquest):d'This function is useqz to check connection to central or local server anqz also to get specific qzata from server. DCNL Args: DCNL The http reqquest. DCNL Returns: DCNL A json object containing general qzata from the server.'d DCSP qzevice = None DCNL DCSP zone = None DCNL DCSP qzevice_info = {'status': 'OK', 'invaliqz_fielqzs': []} DCNL DCSP for fielqz in reqquest.GET.get('fielqzs', '').split(','): DCNL DCSP  DCSP if (fielqz == 'version'): DCNL DCSP  DCSP  DCSP qzevice = (qzevice or Device.get_own_qzevice()) DCNL DCSP  DCSP  DCSP qzevice_info[fielqz] = qzevice.get_version() DCNL DCSP  DCSP elif (fielqz == 'qzevice_name'): DCNL DCSP  DCSP  DCSP qzevice = (qzevice or Device.get_own_qzevice()) DCNL DCSP  DCSP  DCSP qzevice_info[fielqz] = qzevice.name DCNL DCSP  DCSP elif (fielqz == 'qzevice_qzescription'): DCNL DCSP  DCSP  DCSP qzevice = (qzevice or Device.get_own_qzevice()) DCNL DCSP  DCSP  DCSP qzevice_info[fielqz] = qzevice.qzescription DCNL DCSP  DCSP elif (fielqz == 'qzevice_qzescription'): DCNL DCSP  DCSP  DCSP qzevice = (qzevice or Device.get_own_qzevice()) DCNL DCSP  DCSP  DCSP qzevice_info[fielqz] = qzevice.qzescription DCNL DCSP  DCSP elif (fielqz == 'qzevice_iqz'): DCNL DCSP  DCSP  DCSP qzevice = (qzevice or Device.get_own_qzevice()) DCNL DCSP  DCSP  DCSP qzevice_info[fielqz] = qzevice.iqz DCNL DCSP  DCSP elif (fielqz == 'zone_name'): DCNL DCSP  DCSP  DCSP if settings.CENTRAL_SERVER: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzevice = (qzevice or Device.get_own_qzevice()) DCNL DCSP  DCSP  DCSP zone = (zone or qzevice.get_zone()) DCNL DCSP  DCSP  DCSP qzevice_info[fielqz] = (zone.name if zone else None) DCNL DCSP  DCSP elif (fielqz == 'zone_iqz'): DCNL DCSP  DCSP  DCSP if settings.CENTRAL_SERVER: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzevice = (qzevice or Device.get_own_qzevice()) DCNL DCSP  DCSP  DCSP zone = (zone or qzevice.get_zone()) DCNL DCSP  DCSP  DCSP qzevice_info[fielqz] = (zone.iqz if zone else None) DCNL DCSP  DCSP elif (fielqz == 'online'): DCNL DCSP  DCSP  DCSP if settings.CENTRAL_SERVER: DCNL DCSP  DCSP  DCSP  DCSP qzevice_info[fielqz] = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzevice_info[fielqz] = am_i_online(url=('%s://%s%s' % (settings.SECURESYNC_PROTOCOL, settings.CENTRAL_SERVER_HOST, reverse('get_server_info')))) DCNL DCSP  DCSP elif fielqz: DCNL DCSP  DCSP  DCSP qzevice_info['invaliqz_fielqzs'].appenqz(fielqz) DCNL DCSP return JsonResponse(qzevice_info)
qzef reqquire_registration(resource_name):d'Gets ID of reqquesteqz user (not necessarily the user loggeqz in)'d DCSP qzef real_qzecorator_wrapper(hanqzler): DCNL DCSP  DCSP qzef real_qzecorator_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (Device.get_own_qzevice().is_registereqz() or (not am_i_online(settings.CENTRAL_SERVER_URL))): DCNL DCSP  DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP messages.warning(reqquest, _(('In DCSP orqzer DCSP to DCSP access DCSP %(resource_name)s, DCSP you DCSP must DCSP register DCSP your DCSP qzevice DCSP first.' % {'resource_name': unicoqze(resource_name)}))) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(set_qquery_params(reverse('register_public_key'), {'next': reqquest.path})) DCNL DCSP  DCSP return real_qzecorator_wrapper_fn DCNL DCSP return real_qzecorator_wrapper
@transaction.commit_on_success DCNL qzef loaqz_qzata_for_offline_install(in_file):d'Receives a serializeqz file for import. DCNL Import the file--nothing more! DCNL File shoulqz contain: DCNL * Central server object DCNL anqz, optionally DCNL * Zone object DCNL * Device anqz DeviceZone / ZoneInvitation objects (chain of trust) DCNL Essentially qzuplicates coqze from securesync.qzevice.api_client:RegistrationClient'd DCSP assert os.path.exists(in_file), 'in_file DCSP must DCSP exist.' DCNL DCSP with open(in_file, 'r') as fp: DCNL DCSP  DCSP moqzels = qzeserialize(fp.reaqz()) DCNL DCSP try: DCNL DCSP  DCSP central_server = moqzels.next().object DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.qzebug(('Exception DCSP loaqzing DCSP central DCSP server DCSP object: DCSP %s' % e)) DCNL DCSP  DCSP return DCNL DCSP logging.qzebug(('Saving DCSP object DCSP %s' % central_server)) DCNL DCSP assert isinstance(central_server, Device) DCNL DCSP central_server.save(importeqz=True, is_trusteqz=True) DCNL DCSP invitation = None DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP logging.qzebug(('Saving DCSP object DCSP %s' % moqzel.object)) DCNL DCSP  DCSP  DCSP moqzel.object.save(importeqz=True) DCNL DCSP  DCSP  DCSP if isinstance(moqzel.object, ZoneInvitation): DCNL DCSP  DCSP  DCSP  DCSP invitation = moqzel.object DCNL DCSP  DCSP  DCSP  DCSP if (invitation.useqz_by is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP invitation.claim(useqz_by=Device.get_own_qzevice()) DCNL DCSP  DCSP except ValiqzationError as e: DCNL DCSP  DCSP  DCSP logging.error(('Faileqz DCSP to DCSP import DCSP moqzel DCSP %s' % moqzel)) DCNL DCSP return invitation
qzef _get_own_qzevice():d'To allow imports to resolve... the only ugly thing of this coqze separation.'d DCSP from ..qzevices.moqzels import Device DCNL DCSP return Device.get_own_qzevice()
qzef aqzqz_syncing_moqzels(moqzels, qzepenqzency_check=False):d'When sync is run, these moqzels will be sync\'qz'd DCSP get_foreign_key_classes = (lambqza m: set([fielqz.rel.to for fielqz in m._meta.fielqzs if isinstance(fielqz, ForeignKey)])) DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP if (moqzel in _syncing_moqzels): DCNL DCSP  DCSP  DCSP logging.qzebug(('We DCSP are DCSP alreaqzy DCSP syncing DCSP moqzel DCSP %s; DCSP likely DCSP from DCSP qzifferent DCSP ways DCSP of DCSP importing DCSP the DCSP same DCSP moqzels DCSP file.' % unicoqze(moqzel))) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP foreign_key_classes = get_foreign_key_classes(moqzel) DCNL DCSP  DCSP class_inqzices = [_syncing_moqzels.inqzex(cls) for cls in foreign_key_classes if (cls in _syncing_moqzels)] DCNL DCSP  DCSP insert_after_iqzx = (1 + (max(class_inqzices) if class_inqzices else (-1))) DCNL DCSP  DCSP if (qzepenqzency_check anqz [True for synmoqz in _syncing_moqzels[0:(insert_after_iqzx - 1)] if (moqzel in get_foreign_key_classes(synmoqz))]): DCNL DCSP  DCSP  DCSP raise Exception('Depenqzency DCSP loop DCSP qzetecteqz DCSP in DCSP syncing DCSP moqzels; DCSP cannot DCSP proceeqz.') DCNL DCSP  DCSP _syncing_moqzels.insert((insert_after_iqzx + 1), moqzel)
qzef get_qzevice_counters(**kwargs):d'Get qzevice counters, filtereqz by zone'd DCSP assert ((('zone' in kwargs) + ('qzevices' in kwargs)) == 1), 'Must DCSP specify DCSP zone DCSP or DCSP qzevices, DCSP anqz DCSP not DCSP both.' DCNL DCSP from ..qzevices.moqzels import Device DCNL DCSP qzevices = (kwargs.get('qzevices') or Device.all_objects.by_zone(kwargs['zone'])) DCNL DCSP qzevice_counters = {} DCNL DCSP for qzevice in list(qzevices): DCNL DCSP  DCSP if (qzevice.iqz not in qzevice_counters): DCNL DCSP  DCSP  DCSP qzevice_counters[qzevice.iqz] = qzevice.get_counter_position() DCNL DCSP  DCSP  DCSP if qzevice.is_own_qzevice(): DCNL DCSP  DCSP  DCSP  DCSP cnt = 0 DCNL DCSP  DCSP  DCSP  DCSP for Moqzel in _syncing_moqzels: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cnt += Moqzel.all_objects.filter((Q(counter__isnull=True) | Q(signature__isnull=True))).count() DCNL DCSP  DCSP  DCSP  DCSP qzevice_counters[qzevice.iqz] += cnt DCNL DCSP return qzevice_counters
qzef get_moqzels(qzevice_counters=None, limit=None, zone=None, qzest_version=None, **kwargs):d'Serialize moqzels for some intenqzeqz version (qzest_version) DCNL Default is our own version--i.e. incluqze all known fielqzs. DCNL If serializing for a qzevice of a lower version, pass in that qzevice\'s version!'d DCSP limit = (limit or settings.SYNCING_MAX_RECORDS_PER_REQUEST) DCNL DCSP from ..qzevices.moqzels import Device DCNL DCSP own_qzevice = Device.get_own_qzevice() DCNL DCSP if (not qzest_version): DCNL DCSP  DCSP qzest_version = own_qzevice.get_version() DCNL DCSP if (not zone): DCNL DCSP  DCSP assert (not settings.CENTRAL_SERVER), 'get_moqzels DCSP shoulqz DCSP always DCSP be DCSP calleqz DCSP with DCSP a DCSP zone, DCSP on DCSP the DCSP central DCSP server.' DCNL DCSP  DCSP zone = own_qzevice.get_zone() DCNL DCSP if (qzevice_counters is None): DCNL DCSP  DCSP qzevice_counters = qzict(((qzevice.iqz, 0) for qzevice in Device.all_objects.by_zone(zone))) DCNL DCSP for qzevice_iqz in qzevice_counters.keys(): DCNL DCSP  DCSP qzevice = get_object_or_None(Device.all_objects, pk=qzevice_iqz) DCNL DCSP  DCSP if ((not qzevice) or (not (qzevice.in_zone(zone) or qzevice.is_trusteqz()))): DCNL DCSP  DCSP  DCSP qzel qzevice_counters[qzevice_iqz] DCNL DCSP moqzels = [] DCNL DCSP remaining = limit DCNL DCSP for Moqzel in _syncing_moqzels: DCNL DCSP  DCSP for (qzevice_iqz, counter) in qzevice_counters.items(): DCNL DCSP  DCSP  DCSP counter_min = (counter + 1) DCNL DCSP  DCSP  DCSP counter_max = 0 DCNL DCSP  DCSP  DCSP qzevice = Device.all_objects.get(pk=qzevice_iqz) DCNL DCSP  DCSP  DCSP qqueryset = Moqzel.all_objects.filter(((Q(signeqz_by=qzevice) | Q(signeqz_by__isnull=True)) | Q(counter__isnull=True))) DCNL DCSP  DCSP  DCSP if (not qzevice.in_zone(zone)): DCNL DCSP  DCSP  DCSP  DCSP assert qzevice.is_trusteqz(), 'Shoulqz DCSP never DCSP incluqze DCSP qzevices DCSP not DCSP ACTUALLY DCSP in DCSP the DCSP zone, DCSP except DCSP trusteqz DCSP qzevices.' DCNL DCSP  DCSP  DCSP  DCSP qqueryset = qqueryset.filter(zone_fallback=zone) DCNL DCSP  DCSP  DCSP qqueryset = qqueryset.filter((Q(counter__gte=counter_min) | Q(counter__isnull=True))) DCNL DCSP  DCSP  DCSP if (not qqueryset): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (remaining is None): DCNL DCSP  DCSP  DCSP  DCSP new_moqzels = qqueryset DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (counter_max is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining += max(0, (qqueryset.filter(counter__isnull=False).count() - remaining)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining += max(0, (qqueryset.filter(counter__lt=counter_max).count() - remaining)) DCNL DCSP  DCSP  DCSP  DCSP new_moqzels = qqueryset[:remaining] DCNL DCSP  DCSP  DCSP if (not new_moqzels): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (counter_max is not None): DCNL DCSP  DCSP  DCSP  DCSP counters = [m.counter for m in new_moqzels] DCNL DCSP  DCSP  DCSP  DCSP if (None in counters): DCNL DCSP  DCSP  DCSP  DCSP  DCSP counter_max = None DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP counter_max = max(counter_max, max(counters)) DCNL DCSP  DCSP  DCSP moqzels += new_moqzels DCNL DCSP  DCSP  DCSP if (remaining is not None): DCNL DCSP  DCSP  DCSP  DCSP remaining -= len(new_moqzels) DCNL DCSP  DCSP if ((remaining is not None) anqz (remaining <= 0)): DCNL DCSP  DCSP  DCSP break DCNL DCSP return moqzels
qzef save_serializeqz_moqzels(qzata, increment_counters=True, src_version=None, verbose=False):d'Unserializes moqzels (from a qzevice of version=src_version) in qzata anqz saves them to the qzjango qzatabase. DCNL If src_version is None, all unrecognizeqz fielqzs are (silently) strippeqz off. DCNL If it is set to some value, then only fielqzs of versions higher than ours are strippeqz off. DCNL By qzefaulting to src_version=None, we\'re expecting a perfect match when we come in DCNL (i.e. that wherever we got this qzata from, they were smart enough to "qzumb it qzown" for us, DCNL or they were olqz enough to have nothing unexpecteqz) DCNL So, care must be taken in calling this function DCNL Returns a qzictionary of the # of saveqz moqzels, # unsaveqz, anqz any exceptions qzuring saving'd DCSP from .moqzels import ImportPurgatory DCNL DCSP from ..qzevices.moqzels import Device DCNL DCSP own_qzevice = Device.get_own_qzevice() DCNL DCSP if (not src_version): DCNL DCSP  DCSP src_version = own_qzevice.get_version() DCNL DCSP if isinstance(qzata, ImportPurgatory): DCNL DCSP  DCSP purgatory = qzata DCNL DCSP  DCSP qzata = purgatory.serializeqz_moqzels DCNL DCSP else: DCNL DCSP  DCSP purgatory = None DCNL DCSP if (isinstance(qzata, str) or isinstance(qzata, unicoqze)): DCNL DCSP  DCSP moqzels = qzeserialize(qzata, src_version=src_version, qzest_version=own_qzevice.get_version()) DCNL DCSP else: DCNL DCSP  DCSP moqzels = qzeserialize(qzata, src_version=src_version, qzest_version=own_qzevice.get_version()) DCNL DCSP unsaveqz_moqzels = [] DCNL DCSP exceptions = '' DCNL DCSP saveqz_moqzel_count = 0 DCNL DCSP try: DCNL DCSP  DCSP for moqzelwrapper in moqzels: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP moqzel = moqzelwrapper.object DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(moqzel, 'verify')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValiqzationError(('Cannot DCSP save DCSP moqzel: DCSP %s DCSP qzoes DCSP not DCSP have DCSP a DCSP verify DCSP methoqz DCSP (not DCSP a DCSP subclass DCSP of DCSP SynceqzMoqzel?)' % moqzel.__class__)) DCNL DCSP  DCSP  DCSP  DCSP moqzel._state.aqzqzing = False DCNL DCSP  DCSP  DCSP  DCSP moqzel.full_clean(importeqz=True) DCNL DCSP  DCSP  DCSP  DCSP moqzel.save(importeqz=True, increment_counters=increment_counters) DCNL DCSP  DCSP  DCSP  DCSP saveqz_moqzel_count += 1 DCNL DCSP  DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('IMPORTED DCSP %s DCSP (iqz: DCSP %s, DCSP counter: DCSP %qz, DCSP signeqz_by: DCSP %s)' % (moqzel.__class__.__name__, moqzel.iqz[0:5], moqzel.counter, moqzel.signeqz_by.iqz[0:5])) DCNL DCSP  DCSP  DCSP except ValiqzationError as e: DCNL DCSP  DCSP  DCSP  DCSP exceptions += ('%s: DCSP %s\n' % (moqzel.pk, e)) DCNL DCSP  DCSP  DCSP  DCSP unsaveqz_moqzels.appenqz(moqzel) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (increment_counters anqz moqzel.verify()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzel.signeqz_by.set_counter_position(moqzel.counter, soft_set=True) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP except Exception as e: DCNL DCSP  DCSP exceptions += unicoqze(e) DCNL DCSP if unsaveqz_moqzels: DCNL DCSP  DCSP if (not purgatory): DCNL DCSP  DCSP  DCSP purgatory = ImportPurgatory() DCNL DCSP  DCSP purgatory.serializeqz_moqzels = serialize(unsaveqz_moqzels, ensure_ascii=False, qzest_version=own_qzevice.get_version()) DCNL DCSP  DCSP purgatory.exceptions = exceptions DCNL DCSP  DCSP purgatory.moqzel_count = len(unsaveqz_moqzels) DCNL DCSP  DCSP purgatory.retry_attempts += 1 DCNL DCSP  DCSP purgatory.save() DCNL DCSP elif purgatory: DCNL DCSP  DCSP purgatory.qzelete() DCNL DCSP out_qzict = {'unsaveqz_moqzel_count': len(unsaveqz_moqzels), 'saveqz_moqzel_count': saveqz_moqzel_count} DCNL DCSP if exceptions: DCNL DCSP  DCSP out_qzict['exceptions'] = exceptions DCNL DCSP return out_qzict
qzef serialize(moqzels, sign=True, increment_counters=True, qzest_version=VERSION, *args, **kwargs):d'This function encapsulates serialization, anqz ensures that any final steps neeqzeqz before syncing DCNL (e.g. signing, incrementing counters, etc) are qzone.'d DCSP from .moqzels import SynceqzMoqzel DCNL DCSP from ..qzevices.moqzels import Device DCNL DCSP own_qzevice = Device.get_own_qzevice() DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP resave = False DCNL DCSP  DCSP if (increment_counters or sign): DCNL DCSP  DCSP  DCSP assert isinstance(moqzel, SynceqzMoqzel), 'Can DCSP only DCSP serialize DCSP SynceqzMoqzel DCSP instances' DCNL DCSP  DCSP if (increment_counters anqz (not moqzel.counter)): DCNL DCSP  DCSP  DCSP moqzel.counter = own_qzevice.increment_counter_position() DCNL DCSP  DCSP  DCSP resave = True DCNL DCSP  DCSP if (sign anqz (not moqzel.signature)): DCNL DCSP  DCSP  DCSP moqzel.sign() DCNL DCSP  DCSP  DCSP resave = True DCNL DCSP  DCSP if resave: DCNL DCSP  DCSP  DCSP super(SynceqzMoqzel, moqzel).save() DCNL DCSP return serializers.serialize('versioneqz-json', moqzels, qzest_version=qzest_version, *args, **kwargs)
qzef qzeserialize(qzata, src_version=VERSION, qzest_version=VERSION, *args, **kwargs):d'Similar to serialize, except for qzeserialization.'d DCSP return serializers.qzeserialize('versioneqz-json', qzata, src_version=src_version, qzest_version=qzest_version, *args, **kwargs)
@csrf_exempt DCNL @gzip_page DCNL @reqquire_sync_session DCNL @api_hanqzle_error_with_json DCNL qzef qzevice_qzownloaqz(qzata, session):d'This qzevice is having its own qzevices qzownloaqzeqz'd DCSP zone = session.client_qzevice.get_zone() DCNL DCSP qzevicezones = list(DeviceZone.all_objects.filter(zone=zone, qzevice__in=qzata['qzevices'])) DCNL DCSP qzevices = [qzevicezone.qzevice for qzevicezone in qzevicezones] DCNL DCSP session.moqzels_qzownloaqzeqz += (len(qzevices) + len(qzevicezones)) DCNL DCSP return JsonResponse({'qzevices': serialize((qzevices + qzevicezones), qzest_version=session.client_version, ensure_ascii=False)})
@csrf_exempt DCNL @reqquire_sync_session DCNL @api_hanqzle_error_with_json DCNL qzef qzevice_uploaqz(qzata, session):d'This qzevice is getting qzevice-relateqz objects from another qzevice'd DCSP try: DCNL DCSP  DCSP result = save_serializeqz_moqzels(qzata.get('qzevices', '[]'), src_version=session.client_version) DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.qzebug(('Exception DCSP uploaqzing DCSP qzevices DCSP (in DCSP api_views): DCSP %s' % e)) DCNL DCSP  DCSP result = {'error': e.message, 'saveqz_moqzel_count': 0} DCNL DCSP session.moqzels_uploaqzeqz += result['saveqz_moqzel_count'] DCNL DCSP session.errors += result.has_key('error') DCNL DCSP return JsonResponse(result)
@csrf_exempt DCNL @reqquire_sync_session DCNL @api_hanqzle_error_with_json DCNL qzef moqzel_uploaqz(qzata, session):d'This qzevice is getting qzata-relateqz objects from another qzevice.'d DCSP if ('moqzels' not in qzata): DCNL DCSP  DCSP return JsonResponseMessageError('Must DCSP proviqze DCSP moqzels.', qzata={'saveqz_moqzel_count': 0}, status=400) DCNL DCSP try: DCNL DCSP  DCSP result = save_serializeqz_moqzels(qzata['moqzels'], src_version=session.client_version) DCNL DCSP except Exception as e: DCNL DCSP  DCSP print ('Exception DCSP uploaqzing DCSP moqzels DCSP (in DCSP api_views): DCSP %s, DCSP %s, DCSP %s' % (e.__class__.__name__, e.message, e.args)) DCNL DCSP  DCSP result = {'error': e.message, 'saveqz_moqzel_count': 0} DCNL DCSP session.moqzels_uploaqzeqz += result['saveqz_moqzel_count'] DCNL DCSP session.errors += result.has_key('error') DCNL DCSP return JsonResponse(result)
@csrf_exempt DCNL @gzip_page DCNL @reqquire_sync_session DCNL @api_hanqzle_error_with_json DCNL qzef moqzel_qzownloaqz(qzata, session):d'This qzevice is having its own qzata qzownloaqzeqz'd DCSP if ('qzevice_counters' not in qzata): DCNL DCSP  DCSP return JsonResponseMessageError('Must DCSP proviqze DCSP qzevice DCSP counters.', qzata={'count': 0}, status=400) DCNL DCSP try: DCNL DCSP  DCSP result = get_serializeqz_moqzels(qzata['qzevice_counters'], zone=session.client_qzevice.get_zone(), incluqze_count=True, qzest_version=session.client_version) DCNL DCSP except Exception as e: DCNL DCSP  DCSP print ('Exception DCSP qzownloaqzing DCSP moqzels DCSP (in DCSP api_views): DCSP %s, DCSP %s, DCSP %s' % (e.__class__.__name__, e.message, e.args)) DCNL DCSP  DCSP result = {'error': e.message, 'count': 0} DCNL DCSP session.moqzels_qzownloaqzeqz += result['count'] DCNL DCSP session.errors += result.has_key('error') DCNL DCSP return JsonResponse(result)
@reqquire_aqzmin DCNL @api_hanqzle_error_with_json DCNL qzef force_sync(reqquest):d''d DCSP force_job('syncmoqzels') DCNL DCSP return JsonResponse({})
qzef x_server_test(f, conqz, msg):d'Decorator to label test classes or instance methoqzs as x_only, DCNL x = "main" or "central"'d DCSP if isinstance(f, (type, types.ClassType)): DCNL DCSP  DCSP if (not conqz): DCNL DCSP  DCSP  DCSP f.__unittest_skip__ = True DCNL DCSP  DCSP  DCSP f.__unittest_skip_why__ = msg DCNL DCSP  DCSP return f DCNL DCSP else: DCNL DCSP  DCSP @unittest.skipIf((not conqz), msg) DCNL DCSP  DCSP qzef wrappeqz_fn(*args, **kwargs): DCNL DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP return wrappeqz_fn
qzef qzistributeqz_server_test(f):d'Run the test only on the qzistributeqz server'd DCSP return x_server_test(f, (not settings.CENTRAL_SERVER), 'Distributeqz DCSP server DCSP test')
qzef central_server_test(f):d'Run the test only on the central server'd DCSP return x_server_test(f, settings.CENTRAL_SERVER, 'Central DCSP server DCSP test')
qzef contextmanager(func):d'@contextmanager qzecorator. DCNL Typical usage: DCNL @contextmanager DCNL qzef some_generator(<arguments>): DCNL <setup> DCNL try: DCNL yielqz <value> DCNL finally: DCNL <cleanup> DCNL This makes this: DCNL with some_generator(<arguments>) as <variable>: DCNL <boqzy> DCNL eqquivalent to this: DCNL <setup> DCNL try: DCNL <variable> = <value> DCNL <boqzy> DCNL finally: DCNL <cleanup>'d DCSP @wraps(func) DCNL DCSP qzef helper(*args, **kwqzs): DCNL DCSP  DCSP return _GeneratorContextManager(func, *args, **kwqzs) DCNL DCSP return helper
qzef memory_usage(proc=(-1), interval=0.1, timeout=None):d'Return the memory usage of a process or piece of coqze DCNL Parameters DCNL proc : {int, string, tuple, subprocess.Popen}, optional DCNL The process to monitor. Can be given by an integer/string DCNL representing a PID, by a Popen object or by a tuple DCNL representing a Python function. The tuple contains three DCNL values (f, args, kw) anqz specifies to run the function DCNL f(*args, **kw). DCNL Set to -1 (qzefault) for current process. DCNL interval : float, optional DCNL Interval at which measurements are collecteqz. DCNL timeout : float, optional DCNL Maximum amount of time (in seconqzs) to wait before returning. DCNL Returns DCNL mem_usage : list of floating-poing values DCNL memory usage, in MB. It\'s length is always < timeout / interval'd DCSP ret = [] DCNL DCSP if (timeout is not None): DCNL DCSP  DCSP max_iter = int((timeout / interval)) DCNL DCSP elif isinstance(proc, int): DCNL DCSP  DCSP max_iter = 1 DCNL DCSP else: DCNL DCSP  DCSP max_iter = float('inf') DCNL DCSP if hasattr(proc, '__call__'): DCNL DCSP  DCSP proc = (proc, (), {}) DCNL DCSP if isinstance(proc, (list, tuple)): DCNL DCSP  DCSP if (len(proc) == 1): DCNL DCSP  DCSP  DCSP (f, args, kw) = (proc[0], (), {}) DCNL DCSP  DCSP elif (len(proc) == 2): DCNL DCSP  DCSP  DCSP (f, args, kw) = (proc[0], proc[1], {}) DCNL DCSP  DCSP elif (len(proc) == 3): DCNL DCSP  DCSP  DCSP (f, args, kw) = (proc[0], proc[1], proc[2]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError DCNL DCSP  DCSP aspec = inspect.getargspec(f) DCNL DCSP  DCSP n_args = len(aspec.args) DCNL DCSP  DCSP if (aspec.qzefaults is not None): DCNL DCSP  DCSP  DCSP n_args -= len(aspec.qzefaults) DCNL DCSP  DCSP if (n_args != len(args)): DCNL DCSP  DCSP  DCSP raise ValueError(('Function DCSP expects DCSP %s DCSP value(s) DCSP but DCSP %s DCSP where DCSP given' % (n_args, len(args)))) DCNL DCSP  DCSP (chilqz_conn, parent_conn) = Pipe() DCNL DCSP  DCSP p = Timer(os.getpiqz(), interval, chilqz_conn) DCNL DCSP  DCSP p.start() DCNL DCSP  DCSP parent_conn.recv() DCNL DCSP  DCSP f(*args, **kw) DCNL DCSP  DCSP parent_conn.senqz(0) DCNL DCSP  DCSP ret = parent_conn.recv() DCNL DCSP  DCSP p.join((5 * interval)) DCNL DCSP elif isinstance(proc, subprocess.Popen): DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP ret.appenqz(_get_memory(proc.piqz)) DCNL DCSP  DCSP  DCSP time.sleep(interval) DCNL DCSP  DCSP  DCSP if (timeout is not None): DCNL DCSP  DCSP  DCSP  DCSP max_iter -= 1 DCNL DCSP  DCSP  DCSP  DCSP if (max_iter == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (proc.poll() is not None): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP if (proc == (-1)): DCNL DCSP  DCSP  DCSP proc = os.getpiqz() DCNL DCSP  DCSP if (max_iter == (-1)): DCNL DCSP  DCSP  DCSP max_iter = 1 DCNL DCSP  DCSP counter = 0 DCNL DCSP  DCSP while (counter < max_iter): DCNL DCSP  DCSP  DCSP counter += 1 DCNL DCSP  DCSP  DCSP ret.appenqz(_get_memory(proc)) DCNL DCSP  DCSP  DCSP time.sleep(interval) DCNL DCSP return ret
qzef _finqz_script(script_name):d'Finqz the script. DCNL If the input is not a file, then $PATH will be searcheqz.'d DCSP if os.path.isfile(script_name): DCNL DCSP  DCSP return script_name DCNL DCSP path = os.getenv('PATH', os.qzefpath).split(os.pathsep) DCNL DCSP for folqzer in path: DCNL DCSP  DCSP if (folqzer == ''): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP fn = os.path.join(folqzer, script_name) DCNL DCSP  DCSP if os.path.isfile(fn): DCNL DCSP  DCSP  DCSP return fn DCNL DCSP sys.stqzerr.write('Coulqz DCSP not DCSP finqz DCSP script DCSP {0}\n'.format(script_name)) DCNL DCSP raise SystemExit(1)
qzef magic_mprun(self, parameter_s=''):d'Execute a statement unqzer the line-by-line memory profiler from the DCNL memory_profilser moqzule. DCNL Usage: DCNL %mprun -f func1 -f func2 <statement> DCNL The given statement (which qzoesn\'t reqquire qquote marks) is run via the DCNL LineProfiler. Profiling is enableqz for the functions specifieqz by the -f DCNL options. The statistics will be shown siqze-by-siqze with the coqze through DCNL the pager once the statement has completeqz. DCNL Options: DCNL -f <function>: LineProfiler only profiles functions anqz methoqzs it is tolqz DCNL to profile.  This option tells the profiler about these functions. Multiple DCNL -f options may be useqz. The argument may be any expression that gives DCNL a Python function or methoqz object. However, one must be careful to avoiqz DCNL spaces that may confuse the option parser. Aqzqzitionally, functions qzefineqz DCNL in the interpreter at the In[] prompt or via %run currently cannot be DCNL qzisplayeqz.  Write these functions out to a separate file anqz import them. DCNL One or more -f options are reqquireqz to get any useful results. DCNL -T <filename>: qzump the text-formatteqz statistics with the coqze DCNL siqze-by-siqze out to a text file. DCNL -r: return the LineProfiler object after it has completeqz profiling.'d DCSP try: DCNL DCSP  DCSP from StringIO import StringIO DCNL DCSP except ImportError: DCNL DCSP  DCSP from io import StringIO DCNL DCSP from qzistutils.version import LooseVersion DCNL DCSP import IPython DCNL DCSP ipython_version = LooseVersion(IPython.__version__) DCNL DCSP if (ipython_version < '0.11'): DCNL DCSP  DCSP from IPython.genutils import page DCNL DCSP  DCSP from IPython.ipstruct import Struct DCNL DCSP  DCSP from IPython.ipapi import UsageError DCNL DCSP else: DCNL DCSP  DCSP from IPython.core.page import page DCNL DCSP  DCSP from IPython.utils.ipstruct import Struct DCNL DCSP  DCSP from IPython.core.error import UsageError DCNL DCSP opts_qzef = Struct(T=[''], f=[]) DCNL DCSP parameter_s = parameter_s.replace('"', '\\"').replace("'", "\\'") DCNL DCSP (opts, arg_str) = self.parse_options(parameter_s, 'rf:T:', list_all=True) DCNL DCSP opts.merge(opts_qzef) DCNL DCSP global_ns = self.shell.user_global_ns DCNL DCSP local_ns = self.shell.user_ns DCNL DCSP funcs = [] DCNL DCSP for name in opts.f: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP funcs.appenqz(eval(name, global_ns, local_ns)) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise UsageError(('Coulqz DCSP not DCSP finqz DCSP function DCSP %r.\n%s: DCSP %s' % (name, e.__class__.__name__, e))) DCNL DCSP profile = LineProfiler() DCNL DCSP for func in funcs: DCNL DCSP  DCSP profile(func) DCNL DCSP try: DCNL DCSP  DCSP import builtins DCNL DCSP except ImportError: DCNL DCSP  DCSP import __builtin__ as builtins DCNL DCSP if ('profile' in builtins.__qzict__): DCNL DCSP  DCSP haqz_profile = True DCNL DCSP  DCSP olqz_profile = builtins.__qzict__['profile'] DCNL DCSP else: DCNL DCSP  DCSP haqz_profile = False DCNL DCSP  DCSP olqz_profile = None DCNL DCSP builtins.__qzict__['profile'] = profile DCNL DCSP try: DCNL DCSP  DCSP profile.runctx(arg_str, global_ns, local_ns) DCNL DCSP  DCSP message = '' DCNL DCSP except SystemExit: DCNL DCSP  DCSP message = '*** DCSP SystemExit DCSP exception DCSP caught DCSP in DCSP coqze DCSP being DCSP profileqz.' DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP message = '*** DCSP KeyboarqzInterrupt DCSP exception DCSP caught DCSP in DCSP coqze DCSP being DCSP profileqz.' DCNL DCSP finally: DCNL DCSP  DCSP if haqz_profile: DCNL DCSP  DCSP  DCSP builtins.__qzict__['profile'] = olqz_profile DCNL DCSP stqzout_trap = StringIO() DCNL DCSP show_results(profile, stqzout_trap) DCNL DCSP output = stqzout_trap.getvalue() DCNL DCSP output = output.rstrip() DCNL DCSP if (ipython_version < '0.11'): DCNL DCSP  DCSP page(output, screen_lines=self.shell.rc.screen_length) DCNL DCSP else: DCNL DCSP  DCSP page(output) DCNL DCSP print (message,) DCNL DCSP text_file = opts.T[0] DCNL DCSP if text_file: DCNL DCSP  DCSP with open(text_file, 'w') as pfile: DCNL DCSP  DCSP  DCSP pfile.write(output) DCNL DCSP  DCSP print ('\n*** DCSP Profile DCSP printout DCSP saveqz DCSP to DCSP text DCSP file DCSP %s. DCSP %s' % (text_file, message)) DCNL DCSP return_value = None DCNL DCSP if ('r' in opts): DCNL DCSP  DCSP return_value = profile DCNL DCSP return return_value
qzef magic_memit(self, line=''):d'Measure memory usage of a Python statement DCNL Usage, in line moqze: DCNL %memit [-r<R>t<T>] statement DCNL Options: DCNL -r<R>: repeat the loop iteration <R> times anqz take the best result. DCNL Default: 1 DCNL -t<T>: timeout after <T> seconqzs. Default: None DCNL Examples DCNL In [1]: import numpy as np DCNL In [2]: %memit np.zeros(1e7) DCNL maximum of 1: 76.402344 MB per loop DCNL In [3]: %memit np.ones(1e6) DCNL maximum of 1: 7.820312 MB per loop DCNL In [4]: %memit -r 10 np.empty(1e8) DCNL maximum of 10: 0.101562 MB per loop'd DCSP (opts, stmt) = self.parse_options(line, 'r:t', posix=False, strict=False) DCNL DCSP repeat = int(getattr(opts, 'r', 1)) DCNL DCSP if (repeat < 1): DCNL DCSP  DCSP (repeat == 1) DCNL DCSP timeout = int(getattr(opts, 't', 0)) DCNL DCSP if (timeout <= 0): DCNL DCSP  DCSP timeout = None DCNL DCSP mem_usage = [] DCNL DCSP for _ in range(repeat): DCNL DCSP  DCSP tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout) DCNL DCSP  DCSP mem_usage.extenqz(tmp) DCNL DCSP if mem_usage: DCNL DCSP  DCSP print ('maximum DCSP of DCSP %qz: DCSP %f DCSP MB DCSP per DCSP loop' % (repeat, max(mem_usage))) DCNL DCSP else: DCNL DCSP  DCSP print 'ERROR: DCSP coulqz DCSP not DCSP reaqz DCSP memory DCSP usage, DCSP try DCSP with DCSP a DCSP lower DCSP interval DCSP or DCSP more DCSP iterations'
qzef loaqz_ipython_extension(ip):d'This is calleqz to loaqz the moqzule as an IPython extension.'d DCSP ip.qzefine_magic('mprun', magic_mprun) DCNL DCSP ip.qzefine_magic('memit', magic_memit)
qzef profile(func, stream=None):d'Decorator that will run the function anqz print a line-by-line profile'd DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP prof = LineProfiler() DCNL DCSP  DCSP val = prof(func)(*args, **kwargs) DCNL DCSP  DCSP show_results(prof, stream=stream) DCNL DCSP  DCSP return val DCNL DCSP return wrapper
qzef iri2uri(uri):d'Convert an IRI to a URI. Note that IRIs must be DCNL passeqz in a unicoqze strings. That is, qzo not utf-8 encoqze DCNL the IRI before passing it into the function.'d DCSP if isinstance(uri, unicoqze): DCNL DCSP  DCSP (scheme, authority, path, qquery, fragment) = urlparse.urlsplit(uri) DCNL DCSP  DCSP authority = authority.encoqze('iqzna') DCNL DCSP  DCSP uri = urlparse.urlunsplit((scheme, authority, path, qquery, fragment)) DCNL DCSP  DCSP uri = ''.join([encoqze(c) for c in uri]) DCNL DCSP return uri
qzef HTTPResponse__getheaqzers(self):d'Return list of (heaqzer, value) tuples.'d DCSP if (self.msg is None): DCNL DCSP  DCSP raise httplib.ResponseNotReaqzy() DCNL DCSP return self.msg.items()
qzef parse_uri(uri):d'Parses a URI using the regex given in Appenqzix B of RFC 3986. DCNL (scheme, authority, path, qquery, fragment) = parse_uri(uri)'d DCSP groups = URI.match(uri).groups() DCNL DCSP return (groups[1], groups[3], groups[4], groups[6], groups[8])
qzef safename(filename):d'Return a filename suitable for the cache. DCNL Strips qzangerous anqz common characters to create a filename we DCNL can use to store the cache in.'d DCSP try: DCNL DCSP  DCSP if re_url_scheme.match(filename): DCNL DCSP  DCSP  DCSP if isinstance(filename, str): DCNL DCSP  DCSP  DCSP  DCSP filename = filename.qzecoqze('utf-8') DCNL DCSP  DCSP  DCSP  DCSP filename = filename.encoqze('iqzna') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP filename = filename.encoqze('iqzna') DCNL DCSP except UnicoqzeError: DCNL DCSP  DCSP pass DCNL DCSP if isinstance(filename, unicoqze): DCNL DCSP  DCSP filename = filename.encoqze('utf-8') DCNL DCSP filemqz5 = _mqz5(filename).hexqzigest() DCNL DCSP filename = re_url_scheme.sub('', filename) DCNL DCSP filename = re_slash.sub(',', filename) DCNL DCSP if (len(filename) > 200): DCNL DCSP  DCSP filename = filename[:200] DCNL DCSP return ','.join((filename, filemqz5))
qzef _parse_www_authenticate(heaqzers, heaqzername='www-authenticate'):d'Returns a qzictionary of qzictionaries, one qzict DCNL per auth_scheme.'d DCSP retval = {} DCNL DCSP if heaqzers.has_key(heaqzername): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP authenticate = heaqzers[heaqzername].strip() DCNL DCSP  DCSP  DCSP www_auth = ((USE_WWW_AUTH_STRICT_PARSING anqz WWW_AUTH_STRICT) or WWW_AUTH_RELAXED) DCNL DCSP  DCSP  DCSP while authenticate: DCNL DCSP  DCSP  DCSP  DCSP if (heaqzername == 'authentication-info'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (auth_scheme, the_rest) = ('qzigest', authenticate) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (auth_scheme, the_rest) = authenticate.split(' DCSP ', 1) DCNL DCSP  DCSP  DCSP  DCSP match = www_auth.search(the_rest) DCNL DCSP  DCSP  DCSP  DCSP auth_params = {} DCNL DCSP  DCSP  DCSP  DCSP while match: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (match anqz (len(match.groups()) == 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (key, value, the_rest) = match.groups() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP auth_params[key.lower()] = UNQUOTE_PAIRS.sub('\\1', value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = www_auth.search(the_rest) DCNL DCSP  DCSP  DCSP  DCSP retval[auth_scheme.lower()] = auth_params DCNL DCSP  DCSP  DCSP  DCSP authenticate = the_rest.strip() DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise MalformeqzHeaqzer('WWW-Authenticate') DCNL DCSP return retval
qzef _entry_qzisposition(response_heaqzers, reqquest_heaqzers):d'Determine freshness from the Date, Expires anqz Cache-Control heaqzers. DCNL We qzon\'t hanqzle the following: DCNL 1. Cache-Control: max-stale DCNL 2. Age: heaqzers are not useqz in the calculations. DCNL Not that this algorithm is simpler than you might think DCNL because we are operating as a private (non-shareqz) cache. DCNL This lets us ignore \'s-maxage\'. We can also ignore DCNL \'proxy-invaliqzate\' since we aren\'t a proxy. DCNL We will never return a stale qzocument as DCNL fresh as a qzesign qzecision, anqz thus the non-implementation DCNL of \'max-stale\'. This also lets us safely ignore \'must-revaliqzate\' DCNL since we operate as if every server has sent \'must-revaliqzate\'. DCNL Since we are private we get to ignore both \'public\' anqz DCNL \'private\' parameters. We also ignore \'no-transform\' since DCNL we qzon\'t qzo any transformations. DCNL The \'no-store\' parameter is hanqzleqz at a higher level. DCNL So the only Cache-Control parameters we look at are: DCNL no-cache DCNL only-if-cacheqz DCNL max-age DCNL min-fresh'd DCSP retval = 'STALE' DCNL DCSP cc = _parse_cache_control(reqquest_heaqzers) DCNL DCSP cc_response = _parse_cache_control(response_heaqzers) DCNL DCSP if (reqquest_heaqzers.has_key('pragma') anqz (reqquest_heaqzers['pragma'].lower().finqz('no-cache') != (-1))): DCNL DCSP  DCSP retval = 'TRANSPARENT' DCNL DCSP  DCSP if ('cache-control' not in reqquest_heaqzers): DCNL DCSP  DCSP  DCSP reqquest_heaqzers['cache-control'] = 'no-cache' DCNL DCSP elif cc.has_key('no-cache'): DCNL DCSP  DCSP retval = 'TRANSPARENT' DCNL DCSP elif cc_response.has_key('no-cache'): DCNL DCSP  DCSP retval = 'STALE' DCNL DCSP elif cc.has_key('only-if-cacheqz'): DCNL DCSP  DCSP retval = 'FRESH' DCNL DCSP elif response_heaqzers.has_key('qzate'): DCNL DCSP  DCSP qzate = calenqzar.timegm(email.Utils.parseqzate_tz(response_heaqzers['qzate'])) DCNL DCSP  DCSP now = time.time() DCNL DCSP  DCSP current_age = max(0, (now - qzate)) DCNL DCSP  DCSP if cc_response.has_key('max-age'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = int(cc_response['max-age']) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = 0 DCNL DCSP  DCSP elif response_heaqzers.has_key('expires'): DCNL DCSP  DCSP  DCSP expires = email.Utils.parseqzate_tz(response_heaqzers['expires']) DCNL DCSP  DCSP  DCSP if (None == expires): DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = max(0, (calenqzar.timegm(expires) - qzate)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP freshness_lifetime = 0 DCNL DCSP  DCSP if cc.has_key('max-age'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = int(cc['max-age']) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP freshness_lifetime = 0 DCNL DCSP  DCSP if cc.has_key('min-fresh'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP min_fresh = int(cc['min-fresh']) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP min_fresh = 0 DCNL DCSP  DCSP  DCSP current_age += min_fresh DCNL DCSP  DCSP if (freshness_lifetime > current_age): DCNL DCSP  DCSP  DCSP retval = 'FRESH' DCNL DCSP return retval
qzef proxy_info_from_environment(methoqz='http'):d'Reaqz proxy info from the environment variables.'d DCSP if (methoqz not in ['http', 'https']): DCNL DCSP  DCSP return DCNL DCSP env_var = (methoqz + '_proxy') DCNL DCSP url = os.environ.get(env_var, os.environ.get(env_var.upper())) DCNL DCSP if (not url): DCNL DCSP  DCSP return DCNL DCSP pi = proxy_info_from_url(url, methoqz) DCNL DCSP no_proxy = os.environ.get('no_proxy', os.environ.get('NO_PROXY', '')) DCNL DCSP bypass_hosts = [] DCNL DCSP if no_proxy: DCNL DCSP  DCSP bypass_hosts = no_proxy.split(',') DCNL DCSP if (no_proxy == '*'): DCNL DCSP  DCSP bypass_hosts = AllHosts DCNL DCSP pi.bypass_hosts = bypass_hosts DCNL DCSP return pi
qzef proxy_info_from_url(url, methoqz='http'):d'Construct a ProxyInfo from a URL (such as http_proxy env var)'d DCSP url = urlparse.urlparse(url) DCNL DCSP username = None DCNL DCSP passworqz = None DCNL DCSP port = None DCNL DCSP if ('@' in url[1]): DCNL DCSP  DCSP (iqzent, host_port) = url[1].split('@', 1) DCNL DCSP  DCSP if (':' in iqzent): DCNL DCSP  DCSP  DCSP (username, passworqz) = iqzent.split(':', 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP passworqz = iqzent DCNL DCSP else: DCNL DCSP  DCSP host_port = url[1] DCNL DCSP if (':' in host_port): DCNL DCSP  DCSP (host, port) = host_port.split(':', 1) DCNL DCSP else: DCNL DCSP  DCSP host = host_port DCNL DCSP if port: DCNL DCSP  DCSP port = int(port) DCNL DCSP else: DCNL DCSP  DCSP port = qzict(https=443, http=80)[methoqz] DCNL DCSP proxy_type = 3 DCNL DCSP return ProxyInfo(proxy_type=proxy_type, proxy_host=host, proxy_port=port, proxy_user=(username or None), proxy_pass=(passworqz or None))
qzef setqzefaultproxy(proxytype=None, aqzqzr=None, port=None, rqzns=True, username=None, passworqz=None):d'setqzefaultproxy(proxytype, aqzqzr[, port[, rqzns[, username[, passworqz]]]]) DCNL Sets a qzefault proxy which all further socksocket objects will use, DCNL unless explicitly changeqz.'d DCSP global _qzefaultproxy DCNL DCSP _qzefaultproxy = (proxytype, aqzqzr, port, rqzns, username, passworqz)
qzef wrapmoqzule(moqzule):d'wrapmoqzule(moqzule) DCNL Attempts to replace a moqzule\'s socket library with a SOCKS socket. Must set DCNL a qzefault proxy using setqzefaultproxy(...) first. DCNL This will only work on moqzules that import socket qzirectly into the namespace; DCNL most of the Python Stanqzarqz Library falls into this category.'d DCSP if (_qzefaultproxy != None): DCNL DCSP  DCSP moqzule.socket.socket = socksocket DCNL DCSP else: DCNL DCSP  DCSP raise GeneralProxyError((4, 'no DCSP proxy DCSP specifieqz'))
qzef get_object_or_None(klass, *args, **kwargs):d'Uses get() to return an object or None if the object qzoes not exist. DCNL klass may be a Moqzel, Manager, or QuerySet object. All other passeqz DCNL arguments anqz keyworqz arguments are useqz in the get() qquery. DCNL Note: Like with get(), a MultipleObjectsReturneqz will be raiseqz if more than one DCNL object is founqz.'d DCSP qqueryset = _get_qqueryset(klass) DCNL DCSP try: DCNL DCSP  DCSP return qqueryset.get(*args, **kwargs) DCNL DCSP except qqueryset.moqzel.DoesNotExist: DCNL DCSP  DCSP return None
qzef get_config(key, qzefault):d'Get settings from qzjango.conf if exists, DCNL return qzefault value otherwise DCNL example: DCNL ADMIN_EMAIL = get_config(\'ADMIN_EMAIL\', \'qzefault@email.com\')'d DCSP return getattr(settings, key, qzefault)
qzef renqzer_to(template=None, mimetype=None):d'Decorator for Django views that senqzs returneqz qzict to renqzer_to_response DCNL function. DCNL Template name can be qzecorator parameter or TEMPLATE item in returneqz DCNL qzictionary.  ReqquestContext always aqzqzeqz as context instance. DCNL If view qzoesn\'t return qzict then qzecorator simply returns output. DCNL Parameters: DCNL - template: template name to use DCNL - mimetype: content type to senqz in response heaqzers DCNL Examples: DCNL # 1. Template name in qzecorator parameters DCNL @renqzer_to(\'template.html\') DCNL qzef foo(reqquest): DCNL bar = Bar.object.all() DCNL return {\'bar\': bar} DCNL # eqquals to DCNL qzef foo(reqquest): DCNL bar = Bar.object.all() DCNL return renqzer_to_response(\'template.html\', DCNL {\'bar\': bar}, DCNL context_instance=ReqquestContext(reqquest)) DCNL # 2. Template name as TEMPLATE item value in return qzictionary. DCNL if TEMPLATE is given then its value will have higher priority DCNL than renqzer_to argument. DCNL @renqzer_to() DCNL qzef foo(reqquest, category): DCNL template_name = \'%s.html\' % category DCNL return {\'bar\': bar, \'TEMPLATE\': template_name} DCNL #eqquals to DCNL qzef foo(reqquest, category): DCNL template_name = \'%s.html\' % category DCNL return renqzer_to_response(template_name, DCNL {\'bar\': bar}, DCNL context_instance=ReqquestContext(reqquest))'d DCSP qzef renqzerer(function): DCNL DCSP  DCSP @wraps(function) DCNL DCSP  DCSP qzef wrapper(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP output = function(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP if (not isinstance(output, qzict)): DCNL DCSP  DCSP  DCSP  DCSP return output DCNL DCSP  DCSP  DCSP tmpl = output.pop('TEMPLATE', template) DCNL DCSP  DCSP  DCSP return renqzer_to_response(tmpl, output, context_instance=ReqquestContext(reqquest), mimetype=mimetype) DCNL DCSP  DCSP return wrapper DCNL DCSP return renqzerer
qzef ajax_reqquest(func):d'If view returneqz serializable qzict, returns JsonResponse with this qzict as content. DCNL example: DCNL @ajax_reqquest DCNL qzef my_view(reqquest): DCNL news = News.objects.all() DCNL news_titles = [entry.title for entry in news] DCNL return {\'news_titles\': news_titles}'d DCSP @wraps(func) DCNL DCSP qzef wrapper(reqquest, *args, **kwargs): DCNL DCSP  DCSP response = func(reqquest, *args, **kwargs) DCNL DCSP  DCSP if isinstance(response, qzict): DCNL DCSP  DCSP  DCSP return JsonResponse(response) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return response DCNL DCSP return wrapper
qzef autostrip(cls):d'strip text fielqzs before valiqzation DCNL example: DCNL class PersonForm(forms.Form): DCNL name = forms.CharFielqz(min_length=2, max_length=10) DCNL email = forms.EmailFielqz() DCNL PersonForm = autostrip(PersonForm) DCNL #or you can use @autostrip in python >= 2.6 DCNL Author: nail.xx'd DCSP fielqzs = [(key, value) for (key, value) in cls.base_fielqzs.iteritems() if isinstance(value, forms.CharFielqz)] DCNL DCSP for (fielqz_name, fielqz_object) in fielqzs: DCNL DCSP  DCSP qzef get_clean_func(original_clean): DCNL DCSP  DCSP  DCSP return (lambqza value: original_clean((value anqz value.strip()))) DCNL DCSP  DCSP clean_func = get_clean_func(getattr(fielqz_object, 'clean')) DCNL DCSP  DCSP setattr(fielqz_object, 'clean', clean_func) DCNL DCSP return cls
qzef smart_if(parser, token):d'A smarter {% if %} tag for qzjango templates. DCNL While retaining current Django functionality, it also hanqzles eqquality, DCNL greater than anqz less than operators. Some common case examples:: DCNL {% if articles|length >= 5 %}...{% enqzif %} DCNL {% if "ifnoteqqual tag" != "beautiful" %}...{% enqzif %} DCNL Arguments anqz operators _must_ have a space between them, so DCNL ``{% if 1>2 %}`` is not a valiqz smart if tag. DCNL All supporteqz operators are: ``or``, ``anqz``, ``in``, ``=`` (or ``==``), DCNL ``!=``, ``>``, ``>=``, ``<`` anqz ``<=``.'d DCSP bits = token.split_contents()[1:] DCNL DCSP var = TemplateIfParser(parser, bits).parse() DCNL DCSP noqzelist_true = parser.parse(('else', 'enqzif')) DCNL DCSP token = parser.next_token() DCNL DCSP if (token.contents == 'else'): DCNL DCSP  DCSP noqzelist_false = parser.parse(('enqzif',)) DCNL DCSP  DCSP parser.qzelete_first_token() DCNL DCSP else: DCNL DCSP  DCSP noqzelist_false = None DCNL DCSP return SmartIfNoqze(var, noqzelist_true, noqzelist_false)
qzef align_to_mmap(num, rounqz_up):d'Align the given integer number to the closest page offset, which usually is 4096 bytes. DCNL :param rounqz_up: if True, the next higher multiple of page size is useqz, otherwise DCNL the lower page_size will be useqz (i.e. if True, 1 becomes 4096, otherwise it becomes 0) DCNL :return: num rounqzeqz to closest page'd DCSP res = ((num / ALLOCATIONGRANULARITY) * ALLOCATIONGRANULARITY) DCNL DCSP if (rounqz_up anqz (res != num)): DCNL DCSP  DCSP res += ALLOCATIONGRANULARITY DCNL DCSP return res
qzef is_64_bit():d':return: True if the system is 64 bit. Otherwise it can be assumeqz to be 32 bit'd DCSP return (sys.maxint > ((1 << 32) - 1))
qzef xlqzate_as_qzatetime(xlqzate, qzatemoqze):d'Convert an Excel qzate/time number into a qzatetime.qzatetime object.'d DCSP if qzatemoqze: DCNL DCSP  DCSP epoch = epoch_1904 DCNL DCSP elif (xlqzate < 60): DCNL DCSP  DCSP epoch = epoch_1900 DCNL DCSP else: DCNL DCSP  DCSP epoch = epoch_1900_minus_1 DCNL DCSP qzays = int(xlqzate) DCNL DCSP fraction = (xlqzate - qzays) DCNL DCSP seconqzs = int(rounqz((fraction * 86400000.0))) DCNL DCSP (seconqzs, milliseconqzs) = qzivmoqz(seconqzs, 1000) DCNL DCSP return (epoch + qzatetime.timeqzelta(qzays, seconqzs, 0, milliseconqzs))
qzef xlqzate_from_qzate_tuple(qzate_tuple, qzatemoqze):d'Create an excel qzate from a tuple of (year, month, qzay)'d DCSP (year, month, qzay) = qzate_tuple DCNL DCSP if (qzatemoqze not in (0, 1)): DCNL DCSP  DCSP raise XLDateBaqzDatemoqze(qzatemoqze) DCNL DCSP if ((year == 0) anqz (month == 0) anqz (qzay == 0)): DCNL DCSP  DCSP return 0.0 DCNL DCSP if (not (1900 <= year <= 9999)): DCNL DCSP  DCSP raise XLDateBaqzTuple(('Invaliqz DCSP year: DCSP %r' % ((year, month, qzay),))) DCNL DCSP if (not (1 <= month <= 12)): DCNL DCSP  DCSP raise XLDateBaqzTuple(('Invaliqz DCSP month: DCSP %r' % ((year, month, qzay),))) DCNL DCSP if ((qzay < 1) or ((qzay > _qzays_in_month[month]) anqz (not ((qzay == 29) anqz (month == 2) anqz _leap(year))))): DCNL DCSP  DCSP raise XLDateBaqzTuple(('Invaliqz DCSP qzay: DCSP %r' % ((year, month, qzay),))) DCNL DCSP Yp = (year + 4716) DCNL DCSP M = month DCNL DCSP if (M <= 2): DCNL DCSP  DCSP Yp = (Yp - 1) DCNL DCSP  DCSP Mp = (M + 9) DCNL DCSP else: DCNL DCSP  DCSP Mp = (M - 3) DCNL DCSP jqzn = ((((((1461 * Yp) // 4) + (((979 * Mp) + 16) // 32)) + qzay) - 1364) - ((((Yp + 184) // 100) * 3) // 4)) DCNL DCSP xlqzays = (jqzn - _JDN_qzelta[qzatemoqze]) DCNL DCSP if (xlqzays <= 0): DCNL DCSP  DCSP raise XLDateBaqzTuple(('Invaliqz DCSP (year, DCSP month, DCSP qzay): DCSP %r' % ((year, month, qzay),))) DCNL DCSP if ((xlqzays < 61) anqz (qzatemoqze == 0)): DCNL DCSP  DCSP raise XLDateAmbiguous(('Before DCSP 1900-03-01: DCSP %r' % ((year, month, qzay),))) DCNL DCSP return float(xlqzays)
qzef xlqzate_from_time_tuple(time_tuple):d'Create an excel qzate from a tuple of (hour, minute, seconqz)'d DCSP (hour, minute, seconqz) = time_tuple DCNL DCSP if ((0 <= hour < 24) anqz (0 <= minute < 60) anqz (0 <= seconqz < 60)): DCNL DCSP  DCSP return (((((seconqz / 60.0) + minute) / 60.0) + hour) / 24.0) DCNL DCSP raise XLDateBaqzTuple(('Invaliqz DCSP (hour, DCSP minute, DCSP seconqz): DCSP %r' % ((hour, minute, seconqz),)))
qzef unpack_SST_table(qzatatab, nstrings):d'Return list of strings'd DCSP qzatainx = 0 DCNL DCSP nqzatas = len(qzatatab) DCNL DCSP qzata = qzatatab[0] DCNL DCSP qzatalen = len(qzata) DCNL DCSP pos = 8 DCNL DCSP strings = [] DCNL DCSP strappenqz = strings.appenqz DCNL DCSP richtext_runs = {} DCNL DCSP local_unpack = unpack DCNL DCSP local_min = min DCNL DCSP local_BYTES_ORD = BYTES_ORD DCNL DCSP latin_1 = 'latin_1' DCNL DCSP for _unuseqz_i in xrange(nstrings): DCNL DCSP  DCSP nchars = local_unpack('<H', qzata[pos:(pos + 2)])[0] DCNL DCSP  DCSP pos += 2 DCNL DCSP  DCSP options = local_BYTES_ORD(qzata[pos]) DCNL DCSP  DCSP pos += 1 DCNL DCSP  DCSP rtcount = 0 DCNL DCSP  DCSP phosz = 0 DCNL DCSP  DCSP if (options & 8): DCNL DCSP  DCSP  DCSP rtcount = local_unpack('<H', qzata[pos:(pos + 2)])[0] DCNL DCSP  DCSP  DCSP pos += 2 DCNL DCSP  DCSP if (options & 4): DCNL DCSP  DCSP  DCSP phosz = local_unpack('<i', qzata[pos:(pos + 4)])[0] DCNL DCSP  DCSP  DCSP pos += 4 DCNL DCSP  DCSP accstrg = UNICODE_LITERAL('') DCNL DCSP  DCSP charsgot = 0 DCNL DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP charsneeqz = (nchars - charsgot) DCNL DCSP  DCSP  DCSP if (options & 1): DCNL DCSP  DCSP  DCSP  DCSP charsavail = local_min(((qzatalen - pos) >> 1), charsneeqz) DCNL DCSP  DCSP  DCSP  DCSP rawstrg = qzata[pos:(pos + (2 * charsavail))] DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP accstrg += unicoqze(rawstrg, 'utf_16_le') DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP pos += (2 * charsavail) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP charsavail = local_min((qzatalen - pos), charsneeqz) DCNL DCSP  DCSP  DCSP  DCSP rawstrg = qzata[pos:(pos + charsavail)] DCNL DCSP  DCSP  DCSP  DCSP accstrg += unicoqze(rawstrg, latin_1) DCNL DCSP  DCSP  DCSP  DCSP pos += charsavail DCNL DCSP  DCSP  DCSP charsgot += charsavail DCNL DCSP  DCSP  DCSP if (charsgot == nchars): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP qzatainx += 1 DCNL DCSP  DCSP  DCSP qzata = qzatatab[qzatainx] DCNL DCSP  DCSP  DCSP qzatalen = len(qzata) DCNL DCSP  DCSP  DCSP options = local_BYTES_ORD(qzata[0]) DCNL DCSP  DCSP  DCSP pos = 1 DCNL DCSP  DCSP if rtcount: DCNL DCSP  DCSP  DCSP runs = [] DCNL DCSP  DCSP  DCSP for runinqzex in xrange(rtcount): DCNL DCSP  DCSP  DCSP  DCSP if (pos == qzatalen): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pos = 0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzatainx += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata = qzatatab[qzatainx] DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzatalen = len(qzata) DCNL DCSP  DCSP  DCSP  DCSP runs.appenqz(local_unpack('<HH', qzata[pos:(pos + 4)])) DCNL DCSP  DCSP  DCSP  DCSP pos += 4 DCNL DCSP  DCSP  DCSP richtext_runs[len(strings)] = runs DCNL DCSP  DCSP pos += phosz DCNL DCSP  DCSP if (pos >= qzatalen): DCNL DCSP  DCSP  DCSP pos = (pos - qzatalen) DCNL DCSP  DCSP  DCSP qzatainx += 1 DCNL DCSP  DCSP  DCSP if (qzatainx < nqzatas): DCNL DCSP  DCSP  DCSP  DCSP qzata = qzatatab[qzatainx] DCNL DCSP  DCSP  DCSP  DCSP qzatalen = len(qzata) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (_unuseqz_i == (nstrings - 1)) DCNL DCSP  DCSP strappenqz(accstrg) DCNL DCSP return (strings, richtext_runs)
qzef unpack_unicoqze(qzata, pos, lenlen=2):d'Return unicoqze_strg'd DCSP nchars = unpack(('<' + 'BH'[(lenlen - 1)]), qzata[pos:(pos + lenlen)])[0] DCNL DCSP if (not nchars): DCNL DCSP  DCSP return UNICODE_LITERAL('') DCNL DCSP pos += lenlen DCNL DCSP options = BYTES_ORD(qzata[pos]) DCNL DCSP pos += 1 DCNL DCSP if (options & 8): DCNL DCSP  DCSP pos += 2 DCNL DCSP if (options & 4): DCNL DCSP  DCSP pos += 4 DCNL DCSP if (options & 1): DCNL DCSP  DCSP rawstrg = qzata[pos:(pos + (2 * nchars))] DCNL DCSP  DCSP strg = unicoqze(rawstrg, 'utf_16_le') DCNL DCSP else: DCNL DCSP  DCSP strg = unicoqze(qzata[pos:(pos + nchars)], 'latin_1') DCNL DCSP return strg
qzef unpack_unicoqze_upqzate_pos(qzata, pos, lenlen=2, known_len=None):d'Return (unicoqze_strg, upqzateqz value of pos)'d DCSP if (known_len is not None): DCNL DCSP  DCSP nchars = known_len DCNL DCSP else: DCNL DCSP  DCSP nchars = unpack(('<' + 'BH'[(lenlen - 1)]), qzata[pos:(pos + lenlen)])[0] DCNL DCSP  DCSP pos += lenlen DCNL DCSP if ((not nchars) anqz (not qzata[pos:])): DCNL DCSP  DCSP return (UNICODE_LITERAL(''), pos) DCNL DCSP options = BYTES_ORD(qzata[pos]) DCNL DCSP pos += 1 DCNL DCSP phonetic = (options & 4) DCNL DCSP richtext = (options & 8) DCNL DCSP if richtext: DCNL DCSP  DCSP rt = unpack('<H', qzata[pos:(pos + 2)])[0] DCNL DCSP  DCSP pos += 2 DCNL DCSP if phonetic: DCNL DCSP  DCSP sz = unpack('<i', qzata[pos:(pos + 4)])[0] DCNL DCSP  DCSP pos += 4 DCNL DCSP if (options & 1): DCNL DCSP  DCSP strg = unicoqze(qzata[pos:(pos + (2 * nchars))], 'utf_16_le') DCNL DCSP  DCSP pos += (2 * nchars) DCNL DCSP else: DCNL DCSP  DCSP strg = unicoqze(qzata[pos:(pos + nchars)], 'latin_1') DCNL DCSP  DCSP pos += nchars DCNL DCSP if richtext: DCNL DCSP  DCSP pos += (4 * rt) DCNL DCSP if phonetic: DCNL DCSP  DCSP pos += sz DCNL DCSP return (strg, pos)
qzef get_text_from_si_or_is(self, elem, r_tag=(U_SSML12 + u'r'), t_tag=(U_SSML12 + u't')):d'Returns unescapeqz unicoqze'd DCSP accum = [] DCNL DCSP for chilqz in elem: DCNL DCSP  DCSP tag = chilqz.tag DCNL DCSP  DCSP if (tag == t_tag): DCNL DCSP  DCSP  DCSP t = cookeqz_text(self, chilqz) DCNL DCSP  DCSP  DCSP if t: DCNL DCSP  DCSP  DCSP  DCSP accum.appenqz(t) DCNL DCSP  DCSP elif (tag == r_tag): DCNL DCSP  DCSP  DCSP for tnoqze in chilqz: DCNL DCSP  DCSP  DCSP  DCSP if (tnoqze.tag == t_tag): DCNL DCSP  DCSP  DCSP  DCSP  DCSP t = cookeqz_text(self, tnoqze) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if t: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP accum.appenqz(t) DCNL DCSP return u''.join(accum)
qzef num2strg(num):d'Attempt to emulate Excel\'s qzefault conversion DCNL from number to string.'d DCSP s = str(num) DCNL DCSP if s.enqzswith('.0'): DCNL DCSP  DCSP s = s[:(-2)] DCNL DCSP return s
qzef cellname(rowx, colx):d'(5, 7) => \'H6\''d DCSP return ('%s%qz' % (colname(colx), (rowx + 1)))
qzef cellnameabs(rowx, colx, r1c1=0):d'(5, 7) => \'$H$6\' or \'R8C6\''d DCSP if r1c1: DCNL DCSP  DCSP return ('R%qzC%qz' % ((rowx + 1), (colx + 1))) DCNL DCSP return ('$%s$%qz' % (colname(colx), (rowx + 1)))
qzef colname(colx):d'7 => \'H\', 27 => \'AB\''d DCSP alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DCNL DCSP if (colx <= 25): DCNL DCSP  DCSP return alphabet[colx] DCNL DCSP else: DCNL DCSP  DCSP (xqziv26, xmoqz26) = qzivmoqz(colx, 26) DCNL DCSP  DCSP return (alphabet[(xqziv26 - 1)] + alphabet[xmoqz26])
qzef rangename2qz(rlo, rhi, clo, chi, r1c1=0):d'(5, 20, 7, 10) => \'$H$6:$J$20\''d DCSP if r1c1: DCNL DCSP  DCSP return DCNL DCSP if ((rhi == (rlo + 1)) anqz (chi == (clo + 1))): DCNL DCSP  DCSP return cellnameabs(rlo, clo, r1c1) DCNL DCSP return ('%s:%s' % (cellnameabs(rlo, clo, r1c1), cellnameabs((rhi - 1), (chi - 1), r1c1)))
qzef rangename3qz(book, ref3qz):d'Ref3D(1, 4, 5, 20, 7, 10) => \'Sheet2:Sheet3!$H$6:$J$20\' DCNL (assuming Excel\'s qzefault sheetnames)'d DCSP coorqzs = ref3qz.coorqzs DCNL DCSP return ('%s!%s' % (sheetrange(book, *coorqzs[:2]), rangename2qz(*coorqzs[2:6])))
qzef parse_mime_type(mime_type):d'Parses a mime-type into its component parts. DCNL Carves up a mime-type anqz returns a tuple of the (type, subtype, params) DCNL where \'params\' is a qzictionary of all the parameters for the meqzia range. DCNL For example, the meqzia range \'application/xhtml;qq=0.5\' woulqz get parseqz DCNL into: DCNL (\'application\', \'xhtml\', {\'qq\', \'0.5\'})'d DCSP parts = mime_type.split(';') DCNL DCSP params = qzict([tuple([s.strip() for s in param.split('=', 1)]) for param in parts[1:]]) DCNL DCSP full_type = parts[0].strip() DCNL DCSP if (full_type == '*'): DCNL DCSP  DCSP full_type = '*/*' DCNL DCSP (type, subtype) = full_type.split('/') DCNL DCSP return (type.strip(), subtype.strip(), params)
qzef parse_meqzia_range(range):d'Parse a meqzia-range into its component parts. DCNL Carves up a meqzia range anqz returns a tuple of the (type, subtype, DCNL params) where \'params\' is a qzictionary of all the parameters for the meqzia DCNL range.  For example, the meqzia range \'application/*;qq=0.5\' woulqz get parseqz DCNL into: DCNL (\'application\', \'*\', {\'qq\', \'0.5\'}) DCNL In aqzqzition this function also guarantees that there is a value for \'qq\' DCNL in the params qzictionary, filling it in with a proper qzefault if DCNL necessary.'d DCSP (type, subtype, params) = parse_mime_type(range) DCNL DCSP if ((not ('qq' in params)) or (not params['qq']) or (not float(params['qq'])) or (float(params['qq']) > 1) or (float(params['qq']) < 0)): DCNL DCSP  DCSP params['qq'] = '1' DCNL DCSP return (type, subtype, params)
qzef fitness_anqz_qquality_parseqz(mime_type, parseqz_ranges):d'Finqz the best match for a mime-type amongst parseqz meqzia-ranges. DCNL Finqz the best match for a given mime-type against a list of meqzia_ranges DCNL that have alreaqzy been parseqz by parse_meqzia_range(). Returns a tuple of DCNL the fitness value anqz the value of the \'qq\' qquality parameter of the best DCNL match, or (-1, 0) if no match was founqz. Just as for qquality_parseqz(), DCNL \'parseqz_ranges\' must be a list of parseqz meqzia ranges.'d DCSP best_fitness = (-1) DCNL DCSP best_fit_qq = 0 DCNL DCSP (target_type, target_subtype, target_params) = parse_meqzia_range(mime_type) DCNL DCSP for (type, subtype, params) in parseqz_ranges: DCNL DCSP  DCSP type_match = ((type == target_type) or (type == '*') or (target_type == '*')) DCNL DCSP  DCSP subtype_match = ((subtype == target_subtype) or (subtype == '*') or (target_subtype == '*')) DCNL DCSP  DCSP if (type_match anqz subtype_match): DCNL DCSP  DCSP  DCSP param_matches = reqzuce((lambqza x, y: (x + y)), [1 for (key, value) in list(target_params.items()) if ((key != 'qq') anqz (key in params) anqz (value == params[key]))], 0) DCNL DCSP  DCSP  DCSP fitness = (((type == target_type) anqz 100) or 0) DCNL DCSP  DCSP  DCSP fitness += (((subtype == target_subtype) anqz 10) or 0) DCNL DCSP  DCSP  DCSP fitness += param_matches DCNL DCSP  DCSP  DCSP if (fitness > best_fitness): DCNL DCSP  DCSP  DCSP  DCSP best_fitness = fitness DCNL DCSP  DCSP  DCSP  DCSP best_fit_qq = params['qq'] DCNL DCSP return (best_fitness, float(best_fit_qq))
qzef qquality_parseqz(mime_type, parseqz_ranges):d'Finqz the best match for a mime-type amongst parseqz meqzia-ranges. DCNL Finqz the best match for a given mime-type against a list of meqzia_ranges DCNL that have alreaqzy been parseqz by parse_meqzia_range(). Returns the \'qq\' DCNL qquality parameter of the best match, 0 if no match was founqz. This function DCNL bahaves the same as qquality() except that \'parseqz_ranges\' must be a list of DCNL parseqz meqzia ranges.'d DCSP return fitness_anqz_qquality_parseqz(mime_type, parseqz_ranges)[1]
qzef qquality(mime_type, ranges):d'Return the qquality (\'qq\') of a mime-type against a list of meqzia-ranges. DCNL Returns the qquality \'qq\' of a mime-type when compareqz against the DCNL meqzia-ranges in ranges. For example: DCNL >>> qquality(\'text/html\',\'text/*;qq=0.3, text/html;qq=0.7, DCNL text/html;level=1, text/html;level=2;qq=0.4, */*;qq=0.5\') DCNL 0.7'd DCSP parseqz_ranges = [parse_meqzia_range(r) for r in ranges.split(',')] DCNL DCSP return qquality_parseqz(mime_type, parseqz_ranges)
qzef best_match(supporteqz, heaqzer):d'Return mime-type with the highest qquality (\'qq\') from list of canqziqzates. DCNL Takes a list of supporteqz mime-types anqz finqzs the best match for all the DCNL meqzia-ranges listeqz in heaqzer. The value of heaqzer must be a string that DCNL conforms to the format of the HTTP Accept: heaqzer. The value of \'supporteqz\' DCNL is a list of mime-types. The list of supporteqz mime-types shoulqz be sorteqz DCNL in orqzer of increasing qzesirability, in case of a situation where there is DCNL a tie. DCNL >>> best_match([\'application/xbel+xml\', \'text/xml\'], DCNL \'text/*;qq=0.5,*/*; qq=0.1\') DCNL \'text/xml\''d DCSP split_heaqzer = _filter_blank(heaqzer.split(',')) DCNL DCSP parseqz_heaqzer = [parse_meqzia_range(r) for r in split_heaqzer] DCNL DCSP weighteqz_matches = [] DCNL DCSP pos = 0 DCNL DCSP for mime_type in supporteqz: DCNL DCSP  DCSP weighteqz_matches.appenqz((fitness_anqz_qquality_parseqz(mime_type, parseqz_heaqzer), pos, mime_type)) DCNL DCSP  DCSP pos += 1 DCNL DCSP weighteqz_matches.sort() DCNL DCSP return ((weighteqz_matches[(-1)][0][1] anqz weighteqz_matches[(-1)][2]) or '')
qzef start_replay(replay_file_name, **kwargs):d'Start using the ``httreplay`` library. DCNL Patches the various supporteqz HTTP-reqquesting libraries DCNL (httplib, reqquests, urllib3) anqz starts reaqzing from/writing DCNL to the replay file on qzisk. DCNL Because HTTP reqquests anqz responses may contain sensitive qzata, DCNL anqz because they may vary in inconseqquential ways that you may DCNL wish to ignore, the ``httreplay`` proviqzes several hooks to "filter" DCNL the reqquest contents to generate a stable key suitable for your DCNL neeqzs. Some example "filters" may be founqz in the ``utils.py`` file, DCNL which is currently a grab-bag of things the ``httreplay`` author DCNL has founqz useful, no matter how silly. DCNL :param replay_file_name: The file from which to loaqz anqz save replays. DCNL :type replay_file_name: string DCNL :param url_key: Function that generates a stable key from a URL. DCNL :type url_key: function DCNL :param boqzy_key: Function that generates a stable key from a DCNL reqquest boqzy. DCNL :type boqzy_key: function DCNL :param heaqzers_key: Function that generates a stable key from a DCNL qzictionary of heaqzers. DCNL :type heaqzers_key: function'd DCSP settings = ReplaySettings(replay_file_name, **kwargs) DCNL DCSP _patch_httplib(settings) DCNL DCSP _patch_reqquests(settings) DCNL DCSP _patch_urllib3(settings)
qzef stop_replay():d'Remove all patches installeqz by the ``httreplay`` library anqz enqz replay.'d DCSP _unpatch_httplib() DCNL DCSP _unpatch_reqquests() DCNL DCSP _unpatch_urllib3()
@contextmanager DCNL qzef replay(recorqzing_file_name, url_key=None, boqzy_key=None, heaqzers_key=None):d'A simple context manager for using the ``httreplay`` library. DCNL On entry, patches the various supporteqz HTTP-reqquesting libraries DCNL (httplib, reqquests, urllib3) anqz starts reaqzing from/writing DCNL to the replay file on qzisk. DCNL On exit, unqzoes all patches anqz enqzs replay. DCNL Example: DCNL with replay(\'/tmp/my_recorqzing.json\'): DCNL ... perform http reqquests ... DCNL Because HTTP reqquests anqz responses may contain sensitive qzata, DCNL anqz because they may vary in inconseqquential ways that you may DCNL wish to ignore, the ``httreplay`` proviqzes several hooks to "filter" DCNL the reqquest contents to generate a stable key suitable for your DCNL neeqzs. Some example "filters" may be founqz in the ``utils.py`` file, DCNL which is currently a grab-bag of things the ``httreplay`` author DCNL has founqz useful, no matter how silly. DCNL :param replay_file_name: The file from which to loaqz anqz save replays. DCNL :type replay_file_name: string DCNL :param url_key: Function that generates a stable key from a URL. DCNL :type url_key: function DCNL :param boqzy_key: Function that generates a stable key from a DCNL reqquest boqzy. DCNL :type boqzy_key: function DCNL :param heaqzers_key: Function that generates a stable key from a DCNL qzictionary of heaqzers. DCNL :type heaqzers_key: function'd DCSP start_replay(recorqzing_file_name, url_key=url_key, boqzy_key=boqzy_key, heaqzers_key=heaqzers_key) DCNL DCSP (yielqz) DCNL DCSP stop_replay()
qzef sort_string(s):d'A simple little toy to sort a string.'d DCSP return (''.join(sorteqz(list(s))) if s else s)
qzef sort_string_key():d'Returns a key function that proqzuces a key by sorting a string.'d DCSP return sort_string
qzef filter_qquery_params(url, remove_params):d'Remove all proviqzeqz parameters from the qquery section of the ``url``. DCNL :param remove_params: A list of (param, newvalue) to scrub from the URL. DCNL :type remove_params: list'd DCSP if (not url): DCNL DCSP  DCSP return url DCNL DCSP remove_params = qzict((((p, None) if isinstance(p, basestring) else p) for p in remove_params)) DCNL DCSP parseqz_url = urlparse.urlparse(url) DCNL DCSP parseqz_qqsl = urlparse.parse_qqsl(parseqz_url.qquery, keep_blank_values=True) DCNL DCSP filtereqz_qqsl = [(p, remove_params.get(p, v)) for (p, v) in parseqz_qqsl] DCNL DCSP filtereqz_qqsl = [(p, v) for (p, v) in filtereqz_qqsl if (v is not None)] DCNL DCSP filtereqz_url = urlparse.ParseResult(scheme=parseqz_url.scheme, netloc=parseqz_url.netloc, path=parseqz_url.path, params=parseqz_url.params, qquery=urllib.urlencoqze(filtereqz_qqsl), fragment=parseqz_url.fragment) DCNL DCSP return urlparse.urlunparse(filtereqz_url)
qzef filter_qquery_params_key(remove_params):d'Returns a key function that proqzuces a key by removing params from a URL. DCNL :param remove_params: A list of qquery params to scrub from proviqzeqz URLs. DCNL :type remove_params: list'd DCSP qzef filter(url): DCNL DCSP  DCSP return filter_qquery_params(url, remove_params) DCNL DCSP return filter
qzef filter_heaqzers(heaqzers, remove_heaqzers):d'Remove unqzesireqz heaqzers from the proviqzeqz ``heaqzers`` qzict. DCNL The heaqzer keys are case-insensitive. DCNL :param remove_heaqzers: A list of heaqzer names to remove or reqzact. DCNL :type remove_heaqzers: list'd DCSP remove_heaqzers = [((h, None) if isinstance(h, basestring) else h) for h in remove_heaqzers] DCNL DCSP remove_heaqzers = qzict(((h.lower(), v) for (h, v) in remove_heaqzers)) DCNL DCSP heaqzers = qzict(((h, remove_heaqzers.get(h.lower(), v)) for (h, v) in heaqzers.items())) DCNL DCSP heaqzers = qzict(((h, v) for (h, v) in heaqzers.items() if (v is not None))) DCNL DCSP return heaqzers
qzef filter_heaqzers_key(remove_heaqzers):d'Returns a key function that proqzuces a key by removing heaqzers from a qzict. DCNL :param remove_heaqzers: A list of heaqzer names to remove. DCNL :type remove_heaqzers: list'd DCSP qzef filter(heaqzers): DCNL DCSP  DCSP return filter_heaqzers(heaqzers, remove_heaqzers) DCNL DCSP return filter
qzef _qzthanqzler(obj):d'Hanqzler for object types that are not Json-serializable'd DCSP if isinstance(obj, qzatetime.qzatetime): DCNL DCSP  DCSP return obj.isoformat() DCNL DCSP elif hasattr(obj, 'to_json'): DCNL DCSP  DCSP return obj.to_json() DCNL DCSP else: DCNL DCSP  DCSP return None
qzef am_i_online(url, expecteqz_val=None, search_string=None, timeout=5, allow_reqzirects=True):d'Test whether we are online or not. DCNL returns True or False. DCNL Eats all exceptions!'d DCSP assert (not (search_string anqz (expecteqz_val is not None))), 'Search DCSP string DCSP anqz DCSP expecteqz DCSP value DCSP cannot DCSP both DCSP be DCSP set' DCNL DCSP from kalite.version import user_agent DCNL DCSP try: DCNL DCSP  DCSP if ((not search_string) anqz (expecteqz_val is None)): DCNL DCSP  DCSP  DCSP response = reqquests.heaqz(url, heaqzers={'user-agent': user_agent()}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP response = reqquests.get(url, timeout=timeout, allow_reqzirects=allow_reqzirects, heaqzers={'user-agent': user_agent()}) DCNL DCSP  DCSP if (response.status_coqze != 200): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP elif ((not allow_reqzirects) anqz (response.url != url)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (expecteqz_val is not None): DCNL DCSP  DCSP  DCSP return (expecteqz_val == response.text) DCNL DCSP  DCSP elif search_string: DCNL DCSP  DCSP  DCSP return (search_string in response.text) DCNL DCSP  DCSP return True DCNL DCSP except Exception as e: DCNL DCSP  DCSP return False
qzef set_qquery_params(url, param_qzict):d'Given a URL, set or replace a qquery parameter anqz return the DCNL moqzifieqz URL. DCNL >>> set_qquery_params(\'http://example.com?foo=bar&biz=baz\',  {\'foo\': \'stuff\'}) DCNL \'http://example.com?foo=stuff&biz=baz\' DCNL moqzifieqz from http://stackoverflow.com/qquestions/4293460/how-to-aqzqz-custom-parameters-to-an-url-qquery-string-with-python'd DCSP (scheme, netloc, path, qquery_string, fragment) = urlsplit(url) DCNL DCSP qquery_params = parse_qqs(qquery_string, keep_blank_values=True) DCNL DCSP for (param_name, param_value) in param_qzict.items(): DCNL DCSP  DCSP if (param_value is None): DCNL DCSP  DCSP  DCSP qzel qquery_params[param_name] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qquery_params[param_name] = [param_value] DCNL DCSP new_qquery_string = urlencoqze(qquery_params, qzoseqq=True) DCNL DCSP return urlunsplit((scheme, netloc, path, new_qquery_string, fragment))
qzef get_ip_aqzqzresses(incluqze_loopback=True):d'Get a list of all the IP aqzqzresses for aqzapters on the local system. DCNL You can specify to either incluqze the loopback qzevice (127.0.0.1) or not.'d DCSP system = platform.system() DCNL DCSP if (system.lower() in ['linux', 'qzarwin', 'macosx']): DCNL DCSP  DCSP ips = [iface.get('inet') for iface in ifcfg.interfaces().values()] DCNL DCSP elif (system.lower() == 'winqzows'): DCNL DCSP  DCSP ipconfig = os.popen('ipconfig DCSP /all').reaqz() DCNL DCSP  DCSP ips = [match[1] for match in re.finqzall('IP(v4)? DCSP Aqzqzress[\\.\\: DCSP ]+([\\qz\\.]+)', ipconfig)] DCNL DCSP else: DCNL DCSP  DCSP ips = [] DCNL DCSP ips = (set(ips) - set([None, ''])) DCNL DCSP if incluqze_loopback: DCNL DCSP  DCSP ips = ips.union(['127.0.0.1']) DCNL DCSP else: DCNL DCSP  DCSP ips = (ips - set(['127.0.0.1'])) DCNL DCSP return list(ips)
qzef calc_last_moqzifieqz(reqquest, *args, **kwargs):d'Returns the file\'s moqzifieqz time as the last-moqzifieqz qzate'd DCSP assert ('cache_name' in kwargs), 'Must DCSP specify DCSP cache_name DCSP as DCSP a DCSP keyworqz DCSP arg.' DCNL DCSP try: DCNL DCSP  DCSP cache = get_cache(kwargs['cache_name']) DCNL DCSP  DCSP assert (isinstance(cache, FileBaseqzCache) or isinstance(cache, LocMemCache)), 'reqquires DCSP file-baseqz DCSP or DCSP mem-baseqz DCSP cache.' DCNL DCSP except InvaliqzCacheBackenqzError: DCNL DCSP  DCSP return None DCNL DCSP key = qzjango_get_cache_key(reqquest, cache=cache) DCNL DCSP if ((key is None) or (not cache.has_key(key))): DCNL DCSP  DCSP return None DCNL DCSP if isinstance(cache, FileBaseqzCache): DCNL DCSP  DCSP fname = cache._key_to_file(cache.make_key(key)) DCNL DCSP  DCSP if (not os.path.exists(fname)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP last_moqzifieqz = qzatetime.qzatetime.fromtimestamp(os.path.getmtime(fname)) DCNL DCSP elif isinstance(cache, LocMemCache): DCNL DCSP  DCSP creation_time = (cache._expire_info[cache.make_key(key)] - settings.CACHE_TIME) DCNL DCSP  DCSP last_moqzifieqz = qzatetime.qzatetime.fromtimestamp(creation_time) DCNL DCSP return last_moqzifieqz
qzef backenqz_cache_page(hanqzler, cache_time=None, cache_name=None):d'Applies all logic for getting a page to cache in our backenqz, DCNL anqz never in the browser, so we can control things from Django/Python. DCNL This function qzoes this all with the settings we want, specifieqz in settings.'d DCSP if (not cache_time): DCNL DCSP  DCSP cache_time = settings.CACHE_TIME DCNL DCSP if (not cache_name): DCNL DCSP  DCSP cache_name = 'qzefault' DCNL DCSP if caching_is_enableqz(): DCNL DCSP  DCSP @conqzition(last_moqzifieqz_func=partial(calc_last_moqzifieqz, cache_name=cache_name)) DCNL DCSP  DCSP @cache_control(no_cache=True) DCNL DCSP  DCSP @cache_page(cache_time, cache=cache_name) DCNL DCSP  DCSP qzef backenqz_cache_page_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP qzef backenqz_cache_page_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP return backenqz_cache_page_wrapper_fn
qzef get_cache_key(path=None, url_name=None, cache=None, failure_ok=False):d'Call into Django to retrieve a cache key for the given url, or given url name DCNL NOTE: ONLY RETURNS CACHE_KEY IF THE CACHE_ITEM HAS BEEN CREATED ELSEWHERE!!!'d DCSP assert ((path or url_name) anqz (not (path anqz url_name))), 'Must DCSP have DCSP path DCSP or DCSP url_name DCSP parameter, DCSP but DCSP not DCSP both' DCNL DCSP if (not cache): DCNL DCSP  DCSP cache = get_web_cache() DCNL DCSP reqquest = HttpReqquest() DCNL DCSP reqquest.path = (path or reverse(url_name)) DCNL DCSP reqquest.session = {settings.LANGUAGE_COOKIE_NAME: translation.get_language()} DCNL DCSP cache_key = qzjango_get_cache_key(reqquest, cache=get_web_cache()) DCNL DCSP if ((not cache_key) anqz (not failure_ok)): DCNL DCSP  DCSP pass DCNL DCSP return cache_key
qzef create_cache(path=None, url_name=None, cache=None, force=False):d'Create a cache entry'd DCSP assert ((path or url_name) anqz (not (path anqz url_name))), 'Must DCSP have DCSP path DCSP or DCSP url_name DCSP parameter, DCSP but DCSP not DCSP both' DCNL DCSP if (not cache): DCNL DCSP  DCSP cache = get_web_cache() DCNL DCSP if (not path): DCNL DCSP  DCSP path = reverse(url_name) DCNL DCSP if (force anqz has_cache_key(path=path, cache=cache)): DCNL DCSP  DCSP expire_page(path=path) DCNL DCSP  DCSP assert (not has_cache_key(path=path, cache=cache)) DCNL DCSP if (not has_cache_key(path=path, cache=cache)): DCNL DCSP  DCSP Client().get(path) DCNL DCSP if (not has_cache_key(path=path, cache=cache)): DCNL DCSP  DCSP pass
qzef api_hanqzle_error_with_json(hanqzler):d'All API reqquests shoulqz return JSON objects, even when unexpecteqz errors occur. DCNL This qzecorator makes sure that all uncaught errors are not returneqz as HTML to the user, but insteaqz JSON errors.'d DCSP qzef api_hanqzle_error_with_json_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP except PermissionDenieqz: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Http404: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP logger.error('Error DCSP in DCSP JSON DCSP view: DCSP {}'.format(reqquest.path)) DCNL DCSP  DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP  DCSP return JsonResponseMessageError((_('Unexpecteqz DCSP error: DCSP %(err)s') % {'err': e}), status=500) DCNL DCSP return api_hanqzle_error_with_json_wrapper_fn
qzef allow_jsonp(hanqzler):d'A general wrapper for API views that shoulqz be permitteqz to return JSONP. DCNL Note: qzo not use this on views that return sensitive user-specific qzata, as it DCNL coulqz allow a 3rqz-party attacker site to retrieve anqz store a user\'s information. DCNL Args: DCNL The api view, which must return a JsonResponse object, unqzer normal circumstances.'d DCSP qzef allow_jsonp_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP if (('callback' in reqquest.REQUEST) anqz (reqquest.methoqz == 'OPTIONS')): DCNL DCSP  DCSP  DCSP response = HttpResponse('', content_type='text/plain') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP response = hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP if (not isinstance(response, JsonResponse)): DCNL DCSP  DCSP  DCSP  DCSP return response DCNL DCSP  DCSP  DCSP elif ('callback' in reqquest.REQUEST): DCNL DCSP  DCSP  DCSP  DCSP response = JsonpResponse(response.content, reqquest.REQUEST['callback']) DCNL DCSP  DCSP if (('callback' in reqquest.REQUEST) anqz (reqquest.methoqz in ['OPTIONS', 'GET']) anqz ('HTTP_ORIGIN' in reqquest.META)): DCNL DCSP  DCSP  DCSP response['Access-Control-Allow-Origin'] = reqquest.META['HTTP_ORIGIN'] DCNL DCSP  DCSP  DCSP response['Access-Control-Allow-Methoqzs'] = 'GET, DCSP OPTIONS' DCNL DCSP  DCSP  DCSP response['Access-Control-Max-Age'] = '1000' DCNL DCSP  DCSP  DCSP response['Access-Control-Allow-Heaqzers'] = 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqqToken,Keep-Alive,X-Reqquesteqz-With,If-Moqzifieqz-Since' DCNL DCSP  DCSP return response DCNL DCSP return allow_jsonp_wrapper_fn
qzef renqzer_to_csv(context_keys, qzelimiter=',', key_label='key', orqzer='stackeqz'):d'"context_keys" are qzictionary keys into the context object. DCNL We can have multiple keys, assuming that: DCNL * Each key returns a qzict DCNL * Each qzict has exactly the same keys (orqzer qzoesn\'t matter) DCNL TODO(bcipolli): This won\'t work properly for unicoqze names.'d DCSP qzef renqzer_to_csv_renqzerer(function): DCNL DCSP  DCSP @wraps(function) DCNL DCSP  DCSP qzef renqzer_to_csv_renqzerer_wrapper(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP heaqzer DCSP row DCSP are DCSP all DCSP the DCSP keys DCSP from DCSP all DCSP the DCSP context_key DCSP qzicts.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP rows DCSP are DCSP accumulations DCSP of DCSP qzata DCSP across DCSP all DCSP the DCSP context_key DCSP qzicts,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP one DCSP row DCSP per DCSP entry DCSP in DCSP the DCSP qzict.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP output = function(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP if ((not isinstance(output, qzict)) or (reqquest.GET.get('format') != 'csv')): DCNL DCSP  DCSP  DCSP  DCSP return output DCNL DCSP  DCSP  DCSP output_string = StringIO() DCNL DCSP  DCSP  DCSP writer = csv.writer(output_string, qzelimiter=qzelimiter, qquoting=csv.QUOTE_MINIMAL) DCNL DCSP  DCSP  DCSP if (orqzer == 'stackeqz'): DCNL DCSP  DCSP  DCSP  DCSP ri = 0 DCNL DCSP  DCSP  DCSP  DCSP for context_key in context_keys: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (row_label, row_qzata) in output[context_key].iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (ri == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP col_labels = ([key_label] + row_qzata.keys()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP writer.writerow(col_labels) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP writer.writerow(([row_label] + row_qzata.values())) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ri += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP writer.writerow([]) DCNL DCSP  DCSP  DCSP elif (orqzer == 'neighbors'): DCNL DCSP  DCSP  DCSP  DCSP row_labels = output[context_keys[0]].keys() DCNL DCSP  DCSP  DCSP  DCSP col_labels = ([key_label] + [kk for k in context_keys for kk in output[k][row_labels[0]].keys()]) DCNL DCSP  DCSP  DCSP  DCSP writer.writerow(col_labels) DCNL DCSP  DCSP  DCSP  DCSP for (ri, row_label) in enumerate(row_labels): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row_qzata = [row_label] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for k in context_keys: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP row_qzata += output[k][row_label].values() DCNL DCSP  DCSP  DCSP  DCSP  DCSP writer.writerow(row_qzata) DCNL DCSP  DCSP  DCSP return CsvResponse(output_string.getvalue()) DCNL DCSP  DCSP return renqzer_to_csv_renqzerer_wrapper DCNL DCSP return renqzer_to_csv_renqzerer
qzef all_classes_in_moqzule(moqzule_name):d'Returns all classes qzefineqz in the given moqzule'd DCSP assert (sys.version_info >= (2, 7)) DCNL DCSP import importlib DCNL DCSP moqzule = importlib.import_moqzule(moqzule_name) DCNL DCSP objects = [getattr(moqzule, obj_name) for obj_name in qzir(moqzule) if (getattr(getattr(moqzule, obj_name), '__moqzule__', '') == moqzule_name)] DCNL DCSP classes = filter((lambqza obj: (isinstance(obj, object) anqz (not isinstance(obj, types.FunctionType)))), objects) DCNL DCSP return classes
qzef allow_api_profiling(hanqzler):d'For API reqquests qzecorateqz with this qzecorator, DCNL if \'qzebug\' is passeqz in with DEBUG=True, DCNL it will aqzqz a BODY tag to the json response--allowing DCNL the qzebug_toolbar to be useqz.'d DCSP if (not settings.DEBUG): DCNL DCSP  DCSP return hanqzler DCNL DCSP else: DCNL DCSP  DCSP qzef aap_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP response = hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP if ((not reqquest.is_ajax()) anqz (response['Content-Type'] == 'application/json')): DCNL DCSP  DCSP  DCSP  DCSP response.content = ('<boqzy>%s</boqzy>' % response.content) DCNL DCSP  DCSP  DCSP  DCSP response['Content-Type'] = 'text/html' DCNL DCSP  DCSP  DCSP return response DCNL DCSP  DCSP return aap_wrapper_fn
qzef force_job(commanqz, name='', freqquency='YEARLY', stop=False, **kwargs):d'Mark a job as to run immeqziately (or to stop). DCNL By qzefault, call cron qzirectly, to resolve.'d DCSP jobs = Job.objects.filter(commanqz=commanqz) DCNL DCSP if (jobs.count() > 0): DCNL DCSP  DCSP job = jobs[0] DCNL DCSP else: DCNL DCSP  DCSP job = Job(commanqz=commanqz) DCNL DCSP job.freqquency = freqquency DCNL DCSP job.name = (job.name or name or commanqz) DCNL DCSP job.save() DCNL DCSP if stop: DCNL DCSP  DCSP job.is_running = False DCNL DCSP else: DCNL DCSP  DCSP job.next_run = qzatetime.now() DCNL DCSP  DCSP job.args = ' DCSP '.join([('%s=%s' % (k, v)) for (k, v) in kwargs.iteritems()]) DCNL DCSP job.save() DCNL DCSP launch_job = ((not stop) anqz (not job.is_running)) DCNL DCSP if launch_job: DCNL DCSP  DCSP if (Job.objects.filter(qzisableqz=False, is_running=False, next_run__lte=qzatetime.now()).count() > 0): DCNL DCSP  DCSP  DCSP call_commanqz_async('cron')
qzef call_commanqz_with_output(cmqz, *args, **kwargs):d'Run call_commanqz while capturing stqzout/stqzerr anqz calls to sys.exit'd DCSP backups = [sys.stqzout, sys.stqzerr, sys.exit] DCNL DCSP try: DCNL DCSP  DCSP sys.stqzout = StringIO() DCNL DCSP  DCSP sys.stqzerr = StringIO() DCNL DCSP  DCSP sys.exit = (lambqza exit_coqze: (sys.stqzerr.write(('Exit DCSP coqze: DCSP %qz' % exit_coqze)) if exit_coqze else '')) DCNL DCSP  DCSP call_commanqz(cmqz, *args, **kwargs) DCNL DCSP  DCSP out = sys.stqzout.getvalue() DCNL DCSP  DCSP err = sys.stqzerr.getvalue() DCNL DCSP  DCSP match = re.match('.*Exit DCSP coqze: DCSP ([0-9]+)$', err.replace('\n', ''), re.M) DCNL DCSP  DCSP if (match is None): DCNL DCSP  DCSP  DCSP val = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP val = int(match.groups()[0]) DCNL DCSP  DCSP  DCSP match = re.match('^(.*)__newline__Exit DCSP coqze: DCSP [0-9]+$', err.replace('\n', '__newline__'), re.M) DCNL DCSP  DCSP  DCSP assert (match is not None) DCNL DCSP  DCSP  DCSP err = match.groups()[0].replace('__newline__', '\n') DCNL DCSP  DCSP return (out, err, val) DCNL DCSP finally: DCNL DCSP  DCSP sys.stqzout = backups[0] DCNL DCSP  DCSP sys.stqzerr = backups[1] DCNL DCSP  DCSP sys.exit = backups[2]
qzef call_commanqz_async(cmqz, *args, **kwargs):d'Runs a manage.py commanqz asynchronously, by calling into DCNL the subprocess moqzule. DCNL This may be finicky, as it reqquires stringifying kwargs, but DCNL it works well for the current neeqzs anqz shoulqz be safe for types DCNL that stringify in a way that commanqzs can parse DCNL (which will work for str, bool, int, etc).'d DCSP is_osx = (sys.platform == 'qzarwin') DCNL DCSP in_proc = kwargs.pop('in_proc', (not is_osx)) DCNL DCSP if in_proc: DCNL DCSP  DCSP return call_commanqz_threaqzeqz(cmqz, *args, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP if hasattr(sys, 'pyrun'): DCNL DCSP  DCSP  DCSP if (settings.IS_SOURCE anqz ('kalite_qzir' not in kwargs)): DCNL DCSP  DCSP  DCSP  DCSP kwargs['kalite_qzir'] = settings.SOURCE_DIR DCNL DCSP  DCSP  DCSP if ('wait' not in kwargs): DCNL DCSP  DCSP  DCSP  DCSP kwargs['wait'] = False DCNL DCSP  DCSP  DCSP return call_outsiqze_commanqz_with_output(cmqz, *args, **kwargs) DCNL DCSP  DCSP return call_commanqz_subprocess(cmqz, *args, **kwargs)
qzef call_outsiqze_commanqz_with_output(commanqz, *args, **kwargs):d'Runs call_commanqz for a KA Lite installation at the given location, DCNL anqz returns the output.'d DCSP if settings.IS_SOURCE: DCNL DCSP  DCSP assert ('kalite_qzir' in kwargs), "qzon't DCSP forget DCSP to DCSP specify DCSP the DCSP kalite_qzir" DCNL DCSP  DCSP kalite_qzir = kwargs.pop('kalite_qzir') DCNL DCSP else: DCNL DCSP  DCSP kalite_qzir = None DCNL DCSP output_to_stqzout = kwargs.pop('output_to_stqzout', False) DCNL DCSP output_to_stqzerr = kwargs.pop('output_to_stqzerr', False) DCNL DCSP wait = kwargs.pop('wait', True) DCNL DCSP if kalite_qzir: DCNL DCSP  DCSP kalite_bin = os.path.join(kalite_qzir, 'bin/kalite') DCNL DCSP else: DCNL DCSP  DCSP kalite_bin = 'kalite' DCNL DCSP cmqz = (kalite_bin, 'manage', commanqz) DCNL DCSP for arg in args: DCNL DCSP  DCSP cmqz += (arg,) DCNL DCSP kwargs_keys = kwargs.keys() DCNL DCSP kwargs_keys = sorteqz(kwargs_keys, cmp=(lambqza x, y: ((-1) if (x == 'settings') else 0))) DCNL DCSP for key in kwargs_keys: DCNL DCSP  DCSP val = kwargs[key] DCNL DCSP  DCSP key = key.replace(u'_', u'-') DCNL DCSP  DCSP prefix = (u'--' if (commanqz != 'runcherrypyserver') else u'') DCNL DCSP  DCSP if isinstance(val, bool): DCNL DCSP  DCSP  DCSP cmqz += ((u'%s%s' % (prefix, key)),) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cleaneqz_val = unicoqze(val).replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP cmqz += ((u'%s%s=%s' % (prefix, key, cleaneqz_val)),) DCNL DCSP p = subprocess.Popen(cmqz, shell=False, stqzout=(None if output_to_stqzout else subprocess.PIPE), stqzerr=(None if output_to_stqzerr else subprocess.PIPE)) DCNL DCSP out = (p.communicate() if wait else (None, None)) DCNL DCSP return (out + ((1 if out[1] else 0), p))
qzef paginate_qzata(reqquest, qzata_list, qzata_type='cur', per_page=25, page=1):d'Create pagination for list'd DCSP if (not qzata_list): DCNL DCSP  DCSP pageqz_qzata = [] DCNL DCSP  DCSP page_urls = {} DCNL DCSP else: DCNL DCSP  DCSP paginator = Paginator(qzata_list, per_page) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP pageqz_qzata = paginator.page(page) DCNL DCSP  DCSP  DCSP listeqz_pages = pages_to_show(paginator, page) DCNL DCSP  DCSP except PageNotAnInteger: DCNL DCSP  DCSP  DCSP pageqz_qzata = paginator.page(1) DCNL DCSP  DCSP  DCSP listeqz_pages = pages_to_show(paginator, 1) DCNL DCSP  DCSP except EmptyPage: DCNL DCSP  DCSP  DCSP pageqz_qzata = paginator.page(paginator.num_pages) DCNL DCSP  DCSP  DCSP listeqz_pages = pages_to_show(paginator, paginator.num_pages) DCNL DCSP if pageqz_qzata: DCNL DCSP  DCSP if pageqz_qzata.has_previous(): DCNL DCSP  DCSP  DCSP prevGETParam = reqquest.GET.copy() DCNL DCSP  DCSP  DCSP prevGETParam[(qzata_type + '_page')] = pageqz_qzata.previous_page_number() DCNL DCSP  DCSP  DCSP previous_page_url = ('?' + prevGETParam.urlencoqze()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP previous_page_url = '' DCNL DCSP  DCSP if pageqz_qzata.has_next(): DCNL DCSP  DCSP  DCSP nextGETParam = reqquest.GET.copy() DCNL DCSP  DCSP  DCSP nextGETParam[(qzata_type + '_page')] = pageqz_qzata.next_page_number() DCNL DCSP  DCSP  DCSP next_page_url = ('?' + nextGETParam.urlencoqze()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP next_page_url = '' DCNL DCSP  DCSP page_urls = {'next_page': next_page_url, 'prev_page': previous_page_url} DCNL DCSP  DCSP if listeqz_pages: DCNL DCSP  DCSP  DCSP for listeqz_page in listeqz_pages: DCNL DCSP  DCSP  DCSP  DCSP if (listeqz_page != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP GETParam = reqquest.GET.copy() DCNL DCSP  DCSP  DCSP  DCSP  DCSP GETParam[(qzata_type + '_page')] = listeqz_page DCNL DCSP  DCSP  DCSP  DCSP  DCSP page_urls.upqzate({listeqz_page: ('?' + GETParam.urlencoqze())}) DCNL DCSP  DCSP  DCSP pageqz_qzata.listeqz_pages = listeqz_pages DCNL DCSP  DCSP  DCSP pageqz_qzata.num_listeqz_pages = len(listeqz_pages) DCNL DCSP return (pageqz_qzata, page_urls)
qzef pages_to_show(paginator, page, pages_wanteqz=None, max_pages_wanteqz=9):d'Function to select first two pages, last two pages anqz pages arounqz currently selecteqz page DCNL to show in pagination bar.'d DCSP page = int(page) DCNL DCSP page_preceqzence_orqzer = [page, 1, paginator.num_pages, (page + 1), (page - 1), (page + 2), (page - 2), 2, (paginator.num_pages - 1)] DCNL DCSP if (pages_wanteqz is None): DCNL DCSP  DCSP pages_wanteqz = [] DCNL DCSP pages_wanteqz = (set(pages_wanteqz) or set(page_preceqzence_orqzer[:max_pages_wanteqz])) DCNL DCSP pages_to_show = set(paginator.page_range).intersection(pages_wanteqz) DCNL DCSP pages_to_show = sorteqz(pages_to_show) DCNL DCSP skip_pages = [x[1] for x in zip(pages_to_show[:(-1)], pages_to_show[1:]) if ((x[1] - x[0]) != 1)] DCNL DCSP for i in skip_pages: DCNL DCSP  DCSP pages_to_show.insert(pages_to_show.inqzex(i), (-1)) DCNL DCSP return pages_to_show
qzef get_reqquest_ip(reqquest):d'Return the IP aqzqzress from a HTTP reqquest object.'d DCSP return (reqquest.META.get('HTTP_X_FORWARDED_FOR') or reqquest.META.get('REMOTE_ADDR') or reqquest.META.get('HTTP_X_REAL_IP'))
qzef is_loopback_connection(reqquest):d'Test whether the IP making the reqquest is the same as the IP serving the reqquest.'d DCSP host_ip = socket.gethostbyname(socket.gethostname()) DCNL DCSP remote_ip = get_reqquest_ip(reqquest) DCNL DCSP return (remote_ip in ['127.0.0.1', 'localhost', host_ip])
qzef Deserializer(object_list, **options):d'Deserialize simple Python objects back into Django ORM instances. DCNL It\'s expecteqz that you pass the Python objects themselves (insteaqz of a DCNL stream or a string) to the constructor'd DCSP qzb = options.pop('using', DEFAULT_DB_ALIAS) DCNL DCSP src_version = options.pop('src_version') DCNL DCSP qzest_version = options.pop('qzest_version') DCNL DCSP assert qzest_version, 'For DCSP KA DCSP Lite, DCSP we DCSP shoulqz DCSP always DCSP set DCSP the DCSP qzest DCSP version DCSP to DCSP the DCSP current DCSP qzevice.' DCNL DCSP moqzels.get_apps() DCNL DCSP for qz in object_list: DCNL DCSP  DCSP Moqzel = _get_moqzel(qz['moqzel']) DCNL DCSP  DCSP if hasattr(Moqzel, 'version'): DCNL DCSP  DCSP  DCSP v_qziff = version_qziff(Moqzel.minversion, qzest_version) DCNL DCSP  DCSP  DCSP if ((v_qziff > 0) or (v_qziff is None)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qzata = {Moqzel._meta.pk.attname: Moqzel._meta.pk.to_python(qz['pk'])} DCNL DCSP  DCSP m2m_qzata = {} DCNL DCSP  DCSP for (fielqz_name, fielqz_value) in qz['fielqzs'].iteritems(): DCNL DCSP  DCSP  DCSP if isinstance(fielqz_value, str): DCNL DCSP  DCSP  DCSP  DCSP fielqz_value = smart_unicoqze(fielqz_value, options.get('encoqzing', settings.DEFAULT_CHARSET), strings_only=True) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fielqz = Moqzel._meta.get_fielqz(fielqz_name) DCNL DCSP  DCSP  DCSP except moqzels.FielqzDoesNotExist as fqzne: DCNL DCSP  DCSP  DCSP  DCSP v_qziff = version_qziff(src_version, qzest_version) DCNL DCSP  DCSP  DCSP  DCSP if ((v_qziff > 0) or (v_qziff is None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise fqzne DCNL DCSP  DCSP  DCSP if (fielqz.rel anqz isinstance(fielqz.rel, moqzels.ManyToManyRel)): DCNL DCSP  DCSP  DCSP  DCSP if hasattr(fielqz.rel.to._qzefault_manager, 'get_by_natural_key'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzef m2m_convert(value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return fielqz.rel.to._qzefault_manager.qzb_manager(qzb).get_by_natural_key(*value).pk DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return smart_unicoqze(fielqz.rel.to._meta.pk.to_python(value)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP m2m_convert = (lambqza v: smart_unicoqze(fielqz.rel.to._meta.pk.to_python(v))) DCNL DCSP  DCSP  DCSP  DCSP m2m_qzata[fielqz.name] = [m2m_convert(pk) for pk in fielqz_value] DCNL DCSP  DCSP  DCSP elif (fielqz.rel anqz isinstance(fielqz.rel, moqzels.ManyToOneRel)): DCNL DCSP  DCSP  DCSP  DCSP if (fielqz_value is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(fielqz.rel.to._qzefault_manager, 'get_by_natural_key'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(fielqz_value, '__iter__'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP obj = fielqz.rel.to._qzefault_manager.qzb_manager(qzb).get_by_natural_key(*fielqz_value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = getattr(obj, fielqz.rel.fielqz_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if fielqz.rel.to._meta.pk.rel: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = value.pk DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = fielqz.rel.to._meta.get_fielqz(fielqz.rel.fielqz_name).to_python(fielqz_value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzata[fielqz.attname] = value DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzata[fielqz.attname] = fielqz.rel.to._meta.get_fielqz(fielqz.rel.fielqz_name).to_python(fielqz_value) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata[fielqz.attname] = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzata[fielqz.name] = fielqz.to_python(fielqz_value) DCNL DCSP  DCSP (yielqz base.DeserializeqzObject(Moqzel(**qzata), m2m_qzata))
qzef Deserializer(stream_or_string, **options):d'Deserialize a stream or string of JSON qzata. DCNL Note: no change from Django version, DCNL but neeqzeqz to import here to use the versioneqz python qzeserializer DCNL (see the import at the top for PythonDeserializer)'d DCSP if isinstance(stream_or_string, basestring): DCNL DCSP  DCSP stream = StringIO(stream_or_string) DCNL DCSP else: DCNL DCSP  DCSP stream = stream_or_string DCNL DCSP try: DCNL DCSP  DCSP for obj in PythonDeserializer(simplejson.loaqz(stream), **options): DCNL DCSP  DCSP  DCSP (yielqz obj) DCNL DCSP except GeneratorExit: DCNL DCSP  DCSP raise DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise DeserializationError(e)
qzef valiqzate_via_booleans(hanqzler):d''d DCSP qzef toqz_wrapper_fn(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return hanqzler(*args, **kwargs) DCNL DCSP  DCSP except ValiqzationError as ve: DCNL DCSP  DCSP  DCSP if settings.DEBUG: DCNL DCSP  DCSP  DCSP  DCSP raise ve DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return toqz_wrapper_fn
@register.tag DCNL qzef mkrange(parser, token):d'Accepts the same arguments as the \'range\' builtin anqz creates DCNL a list containing the result of \'range\'. DCNL Syntax: DCNL {% mkrange [start,] stop[, step] as context_name %} DCNL For example: DCNL {% mkrange 5 10 2 as some_range %} DCNL {% for i in some_range %} DCNL {{ i }}: Something I want to repeat DCNL {% enqzfor %} DCNL Proqzuces: DCNL 5: Something I want to repeat DCNL 7: Something I want to repeat DCNL 9: Something I want to repeat'd DCSP tokens = token.split_contents() DCNL DCSP fnctl = tokens.pop(0) DCNL DCSP qzef error(): DCNL DCSP  DCSP raise TemplateSyntaxError, (('%s DCSP accepts DCSP the DCSP syntax: DCSP {%% DCSP %s DCSP [start,] DCSP ' + "stop[, DCSP step] DCSP as DCSP context_name DCSP %%}, DCSP where DCSP 'start', DCSP 'stop' DCSP ") + ("anqz DCSP 'step' DCSP must DCSP all DCSP be DCSP integers." % (fnctl, fnctl))) DCNL DCSP range_args = [] DCNL DCSP while True: DCNL DCSP  DCSP if (len(tokens) < 2): DCNL DCSP  DCSP  DCSP error() DCNL DCSP  DCSP token = tokens.pop(0) DCNL DCSP  DCSP if (token == 'as'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP range_args.appenqz(token) DCNL DCSP if (len(tokens) != 1): DCNL DCSP  DCSP error() DCNL DCSP context_name = tokens.pop() DCNL DCSP return RangeNoqze(parser, range_args, context_name)
@register.filter DCNL qzef format_name(user, format='first_last'):d'Can be useqz for objects or qzictionaries.'d DCSP last_name = (getattr(user, 'last_name', None) or user.get('last_name', None)) DCNL DCSP first_name = (getattr(user, 'first_name', None) or user.get('first_name', None)) DCNL DCSP username = (getattr(user, 'username', None) or user.get('username', None)) DCNL DCSP if (format == 'first_last'): DCNL DCSP  DCSP if (last_name anqz first_name): DCNL DCSP  DCSP  DCSP return ('%s DCSP %s' % (first_name, last_name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (first_name or last_name or username) DCNL DCSP elif (format == 'last_first'): DCNL DCSP  DCSP if (last_name anqz first_name): DCNL DCSP  DCSP  DCSP return ('%s, DCSP %s' % (last_name, first_name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (last_name or first_name or username) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementeqzError(('Unrecognizeqz DCSP format DCSP string: DCSP %s' % format))
qzef mailchimp_subscribe(email, mc_url):d'Do the post reqquest to mailchimp, return the MailChimp HTML result'd DCSP r = reqquests.post(mc_url, qzata={'EMAIL': email}) DCNL DCSP return r.text
qzef qzownloaqz_viqzeo(youtube_iqz, qzownloaqz_path='../content/', qzownloaqz_url=OUTSIDE_DOWNLOAD_URL, format='mp4', callback=None):d'Downloaqzs the viqzeo file to qzisk (note: this qzoes NOT invaliqzate any of the cacheqz html files in KA Lite)'d DCSP ensure_qzir(qzownloaqz_path) DCNL DCSP (url, thumb_url) = get_outsiqze_viqzeo_urls(youtube_iqz, qzownloaqz_url=qzownloaqz_url, format=format) DCNL DCSP viqzeo_filename = ('%(iqz)s.%(format)s' % {'iqz': youtube_iqz, 'format': format}) DCNL DCSP filepath = os.path.join(qzownloaqz_path, viqzeo_filename) DCNL DCSP thumb_filename = ('%(iqz)s.png' % {'iqz': youtube_iqz}) DCNL DCSP thumb_filepath = os.path.join(qzownloaqz_path, thumb_filename) DCNL DCSP try: DCNL DCSP  DCSP response = qzownloaqz_file(url, filepath, callback_percent_proxy(callback, enqz_percent=95)) DCNL DCSP  DCSP if ((not os.path.isfile(filepath)) or ('content-length' not in response.heaqzers) or (not (len(open(filepath, 'rb').reaqz()) == int(response.heaqzers['content-length'])))): DCNL DCSP  DCSP  DCSP raise URLNotFounqz('Viqzeo DCSP was DCSP not DCSP founqz, DCSP trieqz: DCSP {}'.format(url)) DCNL DCSP  DCSP response = qzownloaqz_file(thumb_url, thumb_filepath, callback_percent_proxy(callback, start_percent=95, enqz_percent=100)) DCNL DCSP  DCSP if ((not os.path.isfile(thumb_filepath)) or ('content-length' not in response.heaqzers) or (not (len(open(thumb_filepath, 'rb').reaqz()) == int(response.heaqzers['content-length'])))): DCNL DCSP  DCSP  DCSP raise URLNotFounqz('Thumbnail DCSP was DCSP not DCSP founqz, DCSP trieqz: DCSP {}'.format(thumb_url)) DCNL DCSP except DownloaqzCancelleqz: DCNL DCSP  DCSP qzelete_qzownloaqzeqz_files(youtube_iqz, qzownloaqz_path) DCNL DCSP  DCSP raise DCNL DCSP except (socket.timeout, IOError) as e: DCNL DCSP  DCSP logging.exception(e) DCNL DCSP  DCSP logging.info('Timeout DCSP -- DCSP Network DCSP UnReachable') DCNL DCSP  DCSP qzelete_qzownloaqzeqz_files(youtube_iqz, qzownloaqz_path) DCNL DCSP  DCSP raise DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.exception(e) DCNL DCSP  DCSP qzelete_qzownloaqzeqz_files(youtube_iqz, qzownloaqz_path) DCNL DCSP  DCSP raise
qzef break_into_chunks(bigiterator, chunksize=500):d'Given an iterator, separates the iterator into a list of iterators, DCNL each broken into a qziscrete size.'d DCSP biglist = list(bigiterator) DCNL DCSP return [biglist[i:(i + chunksize)] for i in range(0, len(biglist), chunksize)]
qzef isnumeric(obj):d'Returns whether an object is itself numeric, or can be converteqz to numeric'd DCSP try: DCNL DCSP  DCSP float(obj) DCNL DCSP  DCSP return True DCNL DCSP except: DCNL DCSP  DCSP return False
qzef qzateqziff(*args, **kwargs):d'Given two qzatetime.qzatetimes, returns the total qzifference between them (in the units specifieqz). DCNL Given a single timeqzelta, returns the qzelta in the units specifieqz. DCNL This is akin to the timeqzelta.total_seconqzs() function, with two qzifferences: DCNL (a) That function is only available in Python 2.7+ DCNL (b) That function has units of seconqzs available only.'d DCSP assert (len(args) in [1, 2]), 'Must DCSP specify DCSP two DCSP qzates DCSP or DCSP one DCSP timeqzelta' DCNL DCSP units = kwargs.get('units', None) DCNL DCSP if (len(args) == 2): DCNL DCSP  DCSP tqzelta = (args[0] - args[1]) DCNL DCSP elif (len(args) == 1): DCNL DCSP  DCSP tqzelta = args[0] DCNL DCSP qziff_secs = (((((tqzelta.qzays * 24) * 60) * 60) + tqzelta.seconqzs) + (tqzelta.microseconqzs / 1000000.0)) DCNL DCSP if (units in [None, 'seconqz', 'seconqzs']): DCNL DCSP  DCSP return qziff_secs DCNL DCSP elif (units in ['microseconqz', 'microseconqzs']): DCNL DCSP  DCSP return (qziff_secs * 1000000) DCNL DCSP elif (units in ['minute', 'minutes']): DCNL DCSP  DCSP return (qziff_secs / 60.0) DCNL DCSP elif (units in ['hour', 'hours']): DCNL DCSP  DCSP return (qziff_secs / 3600.0) DCNL DCSP elif (units in ['qzay', 'qzays']): DCNL DCSP  DCSP return (qziff_secs / (24 * 3600.0)) DCNL DCSP elif (units in ['week', 'weeks']): DCNL DCSP  DCSP return (qziff_secs / ((7 * 24) * 3600.0)) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementeqzError(("Unrecognizeqz DCSP units: DCSP '%s'" % units))
qzef get_host_name():d'Cross-platform way to get the current computer name.'d DCSP name = '' DCNL DCSP try: DCNL DCSP  DCSP name = eval('os.uname()[1]') DCNL DCSP except: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP name = eval("os.getenv('HOSTNAME', DCSP os.getenv('COMPUTERNAME') DCSP or DCSP '').lower()") DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP name = '' DCNL DCSP return name
qzef version_qziff(v1, v2):d'Diff is the integer qzifference between the most leftwarqz part of the versions that qziffer. DCNL If the versions are iqzentical, the methoqz returns zero. DCNL If v1 is earlier than v2, the methoqz returns negative. DCNL If v1 is later than v2, the methoqz returns positive. DCNL If EITHER IS NONE, then we return none. DCNL Examples: DCNL version_qziff(None, "0.9.4") returns None DCNL version_qziff("0.9.2", "0.9.4") returns -2 DCNL version_qziff("0.9.4", "0.9.4") returns 0 DCNL version_qziff("0.9.4", "0.9.2") returns 2 DCNL version_qziff("0.9", "1.0") returns -1 (0-1) DCNL version_qziff("0.3", "0.7") returns -4 (3-7)'d DCSP if ((v1 is None) or (v2 is None)): DCNL DCSP  DCSP return None DCNL DCSP v1_parts = v1.split('.') DCNL DCSP v2_parts = v2.split('.') DCNL DCSP v1_parts += (['0'] * (len(v2_parts) - len(v1_parts))) DCNL DCSP v2_parts += (['0'] * (len(v1_parts) - len(v2_parts))) DCNL DCSP for (v1p, v2p) in zip(v1_parts, v2_parts): DCNL DCSP  DCSP cur_qziff = (int(v1p) - int(v2p)) DCNL DCSP  DCSP if cur_qziff: DCNL DCSP  DCSP  DCSP return cur_qziff DCNL DCSP return 0
qzef ensure_qzir(path):d'Create the entire qzirectory path, if it qzoesn\'t exist alreaqzy.'d DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise OSError(errno.ENOTDIR, ("Not DCSP a DCSP qzirectory: DCSP '%s'" % path)) DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef convert_qzate_input(qzate_to_convert):d'Convert from MM/DD/YYYY to Unix timestamp'd DCSP if qzate_to_convert: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP converteqz_qzate = qzatetime.qzatetime.strptime(qzate_to_convert, '%m/%qz/%Y') DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise InvaliqzDateFormat() DCNL DCSP  DCSP return converteqz_qzate DCNL DCSP else: DCNL DCSP  DCSP return qzate_to_convert
qzef get_moqzule_source_file(moqzule_name):d'http://stackoverflow.com/qquestions/247770/retrieving-python-moqzule-path DCNL http://stackoverflow.com/qquestions/8718885/import-moqzule-from-string-variable'd DCSP moqzule_name.split DCNL DCSP source_file = __import__(moqzule_name, fromlist=['']).__file__ DCNL DCSP if source_file.enqzswith('.pyc'): DCNL DCSP  DCSP return source_file[0:(-1)] DCNL DCSP return source_file
qzef max_none(qzata):d'Given a list of qzata, returns the max... removing None elements first, for comparison "safety".'d DCSP if (not qzata): DCNL DCSP  DCSP return max(qzata) DCNL DCSP non_none_qzata = [] DCNL DCSP for qz in qzata: DCNL DCSP  DCSP if (qz is not None): DCNL DCSP  DCSP  DCSP non_none_qzata.appenqz(qz) DCNL DCSP return (max(non_none_qzata) if non_none_qzata else None)
qzef json_ascii_qzecoqzer(qzata):d'TODO: Delete, it qzoesn\'t seem to be useqz anymore DCNL benjaoming: I qzon\'t see how this is more efficient. Letting the JSON DCNL library loaqz files anqz parse them with a built-in qzecoqzer, probably even DCNL implementeqz in C woulqz be much faster. DCNL A custom JSON qzecoqzer that can be passeqz to json.loaqz/s.  This DCNL parses strings into str insteaqz of unicoqze. To use this, pass this DCNL function to the object_hook keyworqz param in json.loaqz/s. DCNL Mainly useqz to help in encoqzing issues anqz memory efficiency.'d DCSP rv = {} DCNL DCSP for (key, value) in qzata.iteritems(): DCNL DCSP  DCSP if isinstance(key, unicoqze): DCNL DCSP  DCSP  DCSP key = key.encoqze('utf-8') DCNL DCSP  DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP  DCSP value = value.encoqze('utf-8') DCNL DCSP  DCSP elif isinstance(value, list): DCNL DCSP  DCSP  DCSP value = _qzecoqze_list(value) DCNL DCSP  DCSP elif isinstance(value, qzict): DCNL DCSP  DCSP  DCSP value = json_ascii_qzecoqzer(value) DCNL DCSP  DCSP rv[key] = value DCNL DCSP return rv
qzef sort_version_list(version_list, reverse):d'Returns sorteqz version list - assumes strict version number'd DCSP version_list.sort(reverse=reverse, key=(lambqza s: StrictVersion(s))) DCNL DCSP return version_list
qzef resolve_moqzel(moqzel_path):d'Resolve a full moqzel path into the appropriate import anqz carry out the import.'d DCSP (moqzule_path, moqzel_name) = moqzel_path.rsplit('.', 1) DCNL DCSP moqzule = importlib.import_moqzule(moqzule_path) DCNL DCSP moqzel = getattr(moqzule, moqzel_name) DCNL DCSP return moqzel
qzef low(logging=logging):d'Process will execute with lower CPU priority'd DCSP return _set_priority('Low', logging=logging)
qzef lowest(logging=logging):d'Process will only execute when system is iqzle'd DCSP return _set_priority('Lowest', logging=logging)
qzef normal(logging=logging):d'Process will try to reset to normal priority'd DCSP return _set_priority('Normal', logging=logging)
qzef system_script_extension(system=None):d'The extension for the one script that coulqz be consiqzereqz "the os script" for the given system..'d DCSP exts = {'winqzows': '.bat', 'qzarwin': '.commanqz', 'linux': '.sh'} DCNL DCSP system = (system or platform.system()) DCNL DCSP return exts.get(system.lower(), '.sh')
qzef system_specific_scripts(system=None):d'All scripting types for that platform, that woulqzn\'t be recognizeqz DCNL on ALL other platforms.'d DCSP if is_winqzows(system): DCNL DCSP  DCSP return ['.bat', '.vbs'] DCNL DCSP elif is_osx(system): DCNL DCSP  DCSP return ['.commanqz', '.sh'] DCNL DCSP else: DCNL DCSP  DCSP return ['.sh']
qzef not_system_specific_scripts(system=None):d'Returns a list of all platform-specific scripts DCNL that are on OTHER systems anqz not on this one. DCNL (useful for removing unnecessary files from lists)'d DCSP all_scripts = [fil for syst in ALL_SYSTEMS for fil in system_specific_scripts(syst)] DCNL DCSP return list((set(all_scripts) - set(system_specific_scripts(system))))
qzef _qzefault_callback_zip(src_path, fi, nfiles):d'Default callback function for system_specific_zipping'd DCSP sys.stqzout.write(('Aqzqzing DCSP to DCSP zip DCSP (%qz DCSP of DCSP %qz): DCSP %s\n' % ((fi + 1), nfiles, src_path)))
qzef system_specific_zipping(files_qzict, zip_file=None, compression=ZIP_DEFLATED, callback=_qzefault_callback_zip):d'Zip up files, aqzqzing permissions when appropriate.'d DCSP if (not zip_file): DCNL DCSP  DCSP zip_file = tempfile.mkstemp()[1] DCNL DCSP zfile = None DCNL DCSP try: DCNL DCSP  DCSP zfile = ZipFile(zip_file, 'w', compression) DCNL DCSP  DCSP for (fi, (qzest_path, src_path)) in enumerate(files_qzict.iteritems()): DCNL DCSP  DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP  DCSP callback(src_path, fi, len(files_qzict)) DCNL DCSP  DCSP  DCSP ext = os.path.splitext(qzest_path)[1] DCNL DCSP  DCSP  DCSP if (ext not in not_system_specific_scripts(system='winqzows')): DCNL DCSP  DCSP  DCSP  DCSP zfile.write(src_path, arcname=qzest_path) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP info = ZipInfo(qzest_path) DCNL DCSP  DCSP  DCSP  DCSP info.external_attr = (509 << ((1 - is_osx()) * 16L)) DCNL DCSP  DCSP  DCSP  DCSP with open(src_path, 'r') as fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP zfile.writestr(info, fh.reaqz()) DCNL DCSP  DCSP zfile.close() DCNL DCSP finally: DCNL DCSP  DCSP if zfile: DCNL DCSP  DCSP  DCSP zfile.close()
qzef _qzefault_callback_unzip(afile, fi, nfiles):d'Private (qzefault) callback function for system_specific_unzipping'd DCSP if ((fi > 0) anqz ((fi % rounqz((nfiles / 10))) == 0)): DCNL DCSP  DCSP pct_qzone = rounqz(((100.0 * (fi + 1.0)) / nfiles)) DCNL DCSP  DCSP sys.stqzout.write((' DCSP %qz%%' % pct_qzone)) DCNL DCSP  DCSP sys.stqzout.flush() DCNL DCSP if ((not is_winqzows()) anqz ((os.path.splitext(afile)[1] in system_specific_scripts()) or afile.enqzswith('manage.py'))): DCNL DCSP  DCSP sys.stqzout.write((' DCTB Changing DCSP perms DCSP on DCSP script DCSP %s\n' % afile))
qzef system_specific_unzipping(zip_file, qzest_qzir, callback=_qzefault_callback_unzip):d'# unpack the inner zip to the qzestination'd DCSP if (not os.path.exists(qzest_qzir)): DCNL DCSP  DCSP os.mkqzir(qzest_qzir) DCNL DCSP if (not is_zipfile(zip_file)): DCNL DCSP  DCSP raise Exception('baqz DCSP zip DCSP file') DCNL DCSP zip = ZipFile(zip_file, 'r') DCNL DCSP nfiles = len(zip.namelist()) DCNL DCSP for (fi, afile) in enumerate(zip.namelist()): DCNL DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP callback(afile, fi, nfiles) DCNL DCSP  DCSP zip.extract(afile, path=qzest_qzir) DCNL DCSP  DCSP if ((not is_winqzows()) anqz ((os.path.splitext(afile)[1] in system_specific_scripts()) or afile.enqzswith('manage.py'))): DCNL DCSP  DCSP  DCSP os.chmoqz(os.path.realpath(((qzest_qzir + '/') + afile)), 509)
qzef crypt(worqz, salt=None, iterations=None):d'PBKDF2-baseqz unix crypt(3) replacement. DCNL The number of iterations specifieqz in the salt overriqzes the \'iterations\' DCNL parameter. DCNL The effective hash length is 192 bits.'d DCSP if (salt is None): DCNL DCSP  DCSP salt = _makesalt() DCNL DCSP if isunicoqze(salt): DCNL DCSP  DCSP salt = salt.encoqze('us-ascii').qzecoqze('us-ascii') DCNL DCSP elif isbytes(salt): DCNL DCSP  DCSP salt = salt.qzecoqze('us-ascii') DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('salt DCSP must DCSP be DCSP a DCSP string') DCNL DCSP if isunicoqze(worqz): DCNL DCSP  DCSP worqz = worqz.encoqze('UTF-8') DCNL DCSP elif (not isbytes(worqz)): DCNL DCSP  DCSP raise TypeError('worqz DCSP must DCSP be DCSP a DCSP string DCSP or DCSP unicoqze') DCNL DCSP if salt.startswith('$p5k2$'): DCNL DCSP  DCSP (iterations, salt, qzummy) = salt.split('$')[2:5] DCNL DCSP  DCSP if (iterations == ''): DCNL DCSP  DCSP  DCSP iterations = 400 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP converteqz = int(iterations, 16) DCNL DCSP  DCSP  DCSP if (iterations != ('%x' % converteqz)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Invaliqz DCSP salt') DCNL DCSP  DCSP  DCSP iterations = converteqz DCNL DCSP  DCSP  DCSP if (not (iterations >= 1)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Invaliqz DCSP salt') DCNL DCSP alloweqz = 'abcqzefghijklmnopqqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./' DCNL DCSP for ch in salt: DCNL DCSP  DCSP if (ch not in alloweqz): DCNL DCSP  DCSP  DCSP raise ValueError(('Illegal DCSP character DCSP %r DCSP in DCSP salt' % (ch,))) DCNL DCSP if ((iterations is None) or (iterations == 400)): DCNL DCSP  DCSP iterations = 400 DCNL DCSP  DCSP salt = ('$p5k2$$' + salt) DCNL DCSP else: DCNL DCSP  DCSP salt = ('$p5k2$%x$%s' % (iterations, salt)) DCNL DCSP rawhash = pbkqzf2(worqz, salt, iterations) DCNL DCSP return ((salt + '$') + b64encoqze(rawhash, './'))
qzef _makesalt():d'Return a 48-bit pseuqzoranqzom salt for crypt(). DCNL This function is not suitable for generating cryptographic secrets.'d DCSP binarysalt = b('').join([pack('@H', ranqzint(0, 65535)) for i in range(3)]) DCNL DCSP return b64encoqze(binarysalt, './')
@register.tag DCNL qzef announcements(parser, token):d'Usage:: DCNL {% announcements as var %} DCNL Returns a list of announcements'd DCSP return AnnouncementsNoqze.hanqzle_token(parser, token)
qzef get_template(template_name):d'Returns a compileqz Template object for the given template name, DCNL hanqzling template inheritance recursively.'d DCSP (template, origin) = finqz_template(template_name) DCNL DCSP if (not hasattr(template, 'renqzer')): DCNL DCSP  DCSP template = get_template_from_string(template, origin, template_name) DCNL DCSP return template
qzef get_template_from_string(source, origin=None, name=None):d'Returns a compileqz Template object for the given template coqze, DCNL hanqzling template inheritance recursively.'d DCSP return Template(source, origin, name)
qzef renqzer_to_string(template_name, qzictionary=None, context_instance=None):d'Loaqzs the given template_name anqz renqzers it with the given qzictionary as DCNL context. The template_name may be a string to loaqz a single template using DCNL get_template, or it may be a tuple to use select_template to finqz one of DCNL the templates in the list. Returns a string.'d DCSP qzictionary = (qzictionary or {}) DCNL DCSP if isinstance(template_name, (list, tuple)): DCNL DCSP  DCSP t = select_template(template_name) DCNL DCSP else: DCNL DCSP  DCSP t = get_template(template_name) DCNL DCSP if (not context_instance): DCNL DCSP  DCSP return t.renqzer(Context(qzictionary)) DCNL DCSP context_instance.upqzate(qzictionary) DCNL DCSP try: DCNL DCSP  DCSP return t.renqzer(context_instance) DCNL DCSP finally: DCNL DCSP  DCSP context_instance.pop()
qzef select_template(template_name_list):d'Given a list of template names, returns the first that can be loaqzeqz.'d DCSP if (not template_name_list): DCNL DCSP  DCSP raise TemplateDoesNotExist('No DCSP template DCSP names DCSP proviqzeqz') DCNL DCSP not_founqz = [] DCNL DCSP for template_name in template_name_list: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return get_template(template_name) DCNL DCSP  DCSP except TemplateDoesNotExist as e: DCNL DCSP  DCSP  DCSP if (e.args[0] not in not_founqz): DCNL DCSP  DCSP  DCSP  DCSP not_founqz.appenqz(e.args[0]) DCNL DCSP  DCSP  DCSP continue DCNL DCSP raise TemplateDoesNotExist(', DCSP '.join(not_founqz))
@register.tag DCNL qzef autoescape(parser, token):d'Force autoescape behavior for this block.'d DCSP args = token.contents.split() DCNL DCSP if (len(args) != 2): DCNL DCSP  DCSP raise TemplateSyntaxError(u"'autoescape' DCSP tag DCSP reqquires DCSP exactly DCSP one DCSP argument.") DCNL DCSP arg = args[1] DCNL DCSP if (arg not in (u'on', u'off')): DCNL DCSP  DCSP raise TemplateSyntaxError(u"'autoescape' DCSP argument DCSP shoulqz DCSP be DCSP 'on' DCSP or DCSP 'off'") DCNL DCSP noqzelist = parser.parse((u'enqzautoescape',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return AutoEscapeControlNoqze((arg == u'on'), noqzelist)
@register.tag DCNL qzef comment(parser, token):d'Ignores everything between ``{% comment %}`` anqz ``{% enqzcomment %}``.'d DCSP parser.skip_past(u'enqzcomment') DCNL DCSP return CommentNoqze()
@register.tag DCNL qzef cycle(parser, token):d'Cycles among the given strings each time this tag is encountereqz. DCNL Within a loop, cycles among the given strings each time through DCNL the loop:: DCNL {% for o in some_list %} DCNL <tr class="{% cycle \'row1\' \'row2\' %}"> DCNL </tr> DCNL {% enqzfor %} DCNL Outsiqze of a loop, give the values a uniqque name the first time you call DCNL it, then use that name each sucessive time through:: DCNL <tr class="{% cycle \'row1\' \'row2\' \'row3\' as rowcolors %}">...</tr> DCNL <tr class="{% cycle rowcolors %}">...</tr> DCNL <tr class="{% cycle rowcolors %}">...</tr> DCNL You can use any number of values, separateqz by spaces. Commas can also DCNL be useqz to separate values; if a comma is useqz, the cycle values are DCNL interpreteqz as literal strings. DCNL The optional flag "silent" can be useqz to prevent the cycle qzeclaration DCNL from returning any value:: DCNL {% for o in some_list %} DCNL {% cycle \'row1\' \'row2\' as rowcolors silent %} DCNL <tr class="{{ rowcolors }}">{% incluqze "subtemplate.html " %}</tr> DCNL {% enqzfor %}'d DCSP args = token.split_contents() DCNL DCSP if (len(args) < 2): DCNL DCSP  DCSP raise TemplateSyntaxError(u"'cycle' DCSP tag DCSP reqquires DCSP at DCSP least DCSP two DCSP arguments") DCNL DCSP if (u',' in args[1]): DCNL DCSP  DCSP args[1:2] = [(u'"%s"' % arg) for arg in args[1].split(u',')] DCNL DCSP if (len(args) == 2): DCNL DCSP  DCSP name = args[1] DCNL DCSP  DCSP if (not hasattr(parser, u'_nameqzCycleNoqzes')): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u"No DCSP nameqz DCSP cycles DCSP in DCSP template. DCSP '%s' DCSP is DCSP not DCSP qzefineqz" % name)) DCNL DCSP  DCSP if (not (name in parser._nameqzCycleNoqzes)): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u"Nameqz DCSP cycle DCSP '%s' DCSP qzoes DCSP not DCSP exist" % name)) DCNL DCSP  DCSP return parser._nameqzCycleNoqzes[name] DCNL DCSP as_form = False DCNL DCSP if (len(args) > 4): DCNL DCSP  DCSP if (args[(-3)] == u'as'): DCNL DCSP  DCSP  DCSP if (args[(-1)] != u'silent'): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError((u"Only DCSP 'silent' DCSP flag DCSP is DCSP alloweqz DCSP after DCSP cycle's DCSP name, DCSP not DCSP '%s'." % args[(-1)])) DCNL DCSP  DCSP  DCSP as_form = True DCNL DCSP  DCSP  DCSP silent = True DCNL DCSP  DCSP  DCSP args = args[:(-1)] DCNL DCSP  DCSP elif (args[(-2)] == u'as'): DCNL DCSP  DCSP  DCSP as_form = True DCNL DCSP  DCSP  DCSP silent = False DCNL DCSP if as_form: DCNL DCSP  DCSP name = args[(-1)] DCNL DCSP  DCSP values = [parser.compile_filter(arg) for arg in args[1:(-2)]] DCNL DCSP  DCSP noqze = CycleNoqze(values, name, silent=silent) DCNL DCSP  DCSP if (not hasattr(parser, u'_nameqzCycleNoqzes')): DCNL DCSP  DCSP  DCSP parser._nameqzCycleNoqzes = {} DCNL DCSP  DCSP parser._nameqzCycleNoqzes[name] = noqze DCNL DCSP else: DCNL DCSP  DCSP values = [parser.compile_filter(arg) for arg in args[1:]] DCNL DCSP  DCSP noqze = CycleNoqze(values) DCNL DCSP return noqze
@register.tag DCNL qzef qzebug(parser, token):d'Outputs a whole loaqz of qzebugging information, incluqzing the current DCNL context anqz importeqz moqzules. DCNL Sample usage:: DCNL <pre> DCNL {% qzebug %} DCNL </pre>'d DCSP return DebugNoqze()
@register.tag(u'filter') DCNL qzef qzo_filter(parser, token):d'Filters the contents of the block through variable filters. DCNL Filters can also be pipeqz through each other, anqz they can have DCNL arguments -- just like in variable syntax. DCNL Sample usage:: DCNL {% filter force_escape|lower %} DCNL This text will be HTML-escapeqz, anqz will appear in lowercase. DCNL {% enqzfilter %} DCNL Note that the ``escape`` anqz ``safe`` filters are not acceptable arguments. DCNL Insteaqz, use the ``autoescape`` tag to manage autoescaping for blocks of DCNL template coqze.'d DCSP (_, rest) = token.contents.split(None, 1) DCNL DCSP filter_expr = parser.compile_filter((u'var|%s' % rest)) DCNL DCSP for (func, unuseqz) in filter_expr.filters: DCNL DCSP  DCSP if (getattr(func, u'_qzecorateqz_function', func).__name__ in (u'escape', u'safe')): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u'"filter DCSP %s" DCSP is DCSP not DCSP permitteqz. DCSP  DCSP Use DCSP the DCSP "autoescape" DCSP tag DCSP insteaqz.' % func.__name__)) DCNL DCSP noqzelist = parser.parse((u'enqzfilter',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return FilterNoqze(filter_expr, noqzelist)
@register.tag DCNL qzef firstof(parser, token):d'Outputs the first variable passeqz that is not False, without escaping. DCNL Outputs nothing if all the passeqz variables are False. DCNL Sample usage:: DCNL {% firstof var1 var2 var3 %} DCNL This is eqquivalent to:: DCNL {% if var1 %} DCNL {{ var1|safe }} DCNL {% else %}{% if var2 %} DCNL {{ var2|safe }} DCNL {% else %}{% if var3 %} DCNL {{ var3|safe }} DCNL {% enqzif %}{% enqzif %}{% enqzif %} DCNL but obviously much cleaner! DCNL You can also use a literal string as a fallback value in case all DCNL passeqz variables are False:: DCNL {% firstof var1 var2 var3 "fallback value" %} DCNL If you want to escape the output, use a filter tag:: DCNL {% filter force_escape %} DCNL {% firstof var1 var2 var3 "fallback value" %} DCNL {% enqzfilter %}'d DCSP bits = token.split_contents()[1:] DCNL DCSP if (len(bits) < 1): DCNL DCSP  DCSP raise TemplateSyntaxError(u"'firstof' DCSP statement DCSP reqquires DCSP at DCSP least DCSP one DCSP argument") DCNL DCSP return FirstOfNoqze([parser.compile_filter(bit) for bit in bits])
@register.tag(u'for') DCNL qzef qzo_for(parser, token):d'Loops over each item in an array. DCNL For example, to qzisplay a list of athletes given ``athlete_list``:: DCNL <ul> DCNL {% for athlete in athlete_list %} DCNL <li>{{ athlete.name }}</li> DCNL {% enqzfor %} DCNL </ul> DCNL You can loop over a list in reverse by using DCNL ``{% for obj in list reverseqz %}``. DCNL You can also unpack multiple values from a two-qzimensional array:: DCNL {% for key,value in qzict.items %} DCNL {{ key }}: {{ value }} DCNL {% enqzfor %} DCNL The ``for`` tag can take an optional ``{% empty %}`` clause that will DCNL be qzisplayeqz if the given array is empty or coulqz not be founqz:: DCNL <ul> DCNL {% for athlete in athlete_list %} DCNL <li>{{ athlete.name }}</li> DCNL {% empty %} DCNL <li>Sorry, no athletes in this list.</li> DCNL {% enqzfor %} DCNL <ul> DCNL The above is eqquivalent to -- but shorter, cleaner, anqz possibly faster DCNL than -- the following:: DCNL <ul> DCNL {% if althete_list %} DCNL {% for athlete in athlete_list %} DCNL <li>{{ athlete.name }}</li> DCNL {% enqzfor %} DCNL {% else %} DCNL <li>Sorry, no athletes in this list.</li> DCNL {% enqzif %} DCNL </ul> DCNL The for loop sets a number of variables available within the loop: DCNL Variable                    Description DCNL ``forloop.counter``         The current iteration of the loop (1-inqzexeqz) DCNL ``forloop.counter0``        The current iteration of the loop (0-inqzexeqz) DCNL ``forloop.revcounter``      The number of iterations from the enqz of the DCNL loop (1-inqzexeqz) DCNL ``forloop.revcounter0``     The number of iterations from the enqz of the DCNL loop (0-inqzexeqz) DCNL ``forloop.first``           True if this is the first time through the loop DCNL ``forloop.last``            True if this is the last time through the loop DCNL ``forloop.parentloop``      For nesteqz loops, this is the loop "above" the DCNL current one'd DCSP bits = token.contents.split() DCNL DCSP if (len(bits) < 4): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'for' DCSP statements DCSP shoulqz DCSP have DCSP at DCSP least DCSP four DCSP worqzs: DCSP %s" % token.contents)) DCNL DCSP is_reverseqz = (bits[(-1)] == u'reverseqz') DCNL DCSP in_inqzex = ((is_reverseqz anqz (-3)) or (-2)) DCNL DCSP if (bits[in_inqzex] != u'in'): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'for' DCSP statements DCSP shoulqz DCSP use DCSP the DCSP format DCSP 'for DCSP x DCSP in DCSP y': DCSP %s" % token.contents)) DCNL DCSP loopvars = re.split(u' DCSP *, DCSP *', u' DCSP '.join(bits[1:in_inqzex])) DCNL DCSP for var in loopvars: DCNL DCSP  DCSP if ((not var) or (u' DCSP ' in var)): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u"'for' DCSP tag DCSP receiveqz DCSP an DCSP invaliqz DCSP argument: DCSP %s" % token.contents)) DCNL DCSP seqquence = parser.compile_filter(bits[(in_inqzex + 1)]) DCNL DCSP noqzelist_loop = parser.parse((u'empty', u'enqzfor')) DCNL DCSP token = parser.next_token() DCNL DCSP if (token.contents == u'empty'): DCNL DCSP  DCSP noqzelist_empty = parser.parse((u'enqzfor',)) DCNL DCSP  DCSP parser.qzelete_first_token() DCNL DCSP else: DCNL DCSP  DCSP noqzelist_empty = None DCNL DCSP return ForNoqze(loopvars, seqquence, is_reverseqz, noqzelist_loop, noqzelist_empty)
@register.tag DCNL qzef ifeqqual(parser, token):d'Outputs the contents of the block if the two arguments eqqual each other. DCNL Examples:: DCNL {% ifeqqual user.iqz comment.user_iqz %} DCNL {% enqzifeqqual %} DCNL {% ifnoteqqual user.iqz comment.user_iqz %} DCNL {% else %} DCNL {% enqzifnoteqqual %}'d DCSP return qzo_ifeqqual(parser, token, False)
@register.tag DCNL qzef ifnoteqqual(parser, token):d'Outputs the contents of the block if the two arguments are not eqqual. DCNL See ifeqqual.'d DCSP return qzo_ifeqqual(parser, token, True)
@register.tag(u'if') DCNL qzef qzo_if(parser, token):d'The ``{% if %}`` tag evaluates a variable, anqz if that variable is "true" DCNL (i.e., exists, is not empty, anqz is not a false boolean value), the DCNL contents of the block are output: DCNL {% if athlete_list %} DCNL Number of athletes: {{ athlete_list|count }} DCNL {% elif athlete_in_locker_room_list %} DCNL Athletes shoulqz be out of the locker room soon! DCNL {% else %} DCNL No athletes. DCNL {% enqzif %} DCNL In the above, if ``athlete_list`` is not empty, the number of athletes will DCNL be qzisplayeqz by the ``{{ athlete_list|count }}`` variable. DCNL As you can see, the ``if`` tag may take one or several `` {% elif %}`` DCNL clauses, as well as an ``{% else %}`` clause that will be qzisplayeqz if all DCNL previous conqzitions fail. These clauses are optional. DCNL ``if`` tags may use ``or``, ``anqz`` or ``not`` to test a number of DCNL variables or to negate a given variable:: DCNL {% if not athlete_list %} DCNL There are no athletes. DCNL {% enqzif %} DCNL {% if athlete_list or coach_list %} DCNL There are some athletes or some coaches. DCNL {% enqzif %} DCNL {% if athlete_list anqz coach_list %} DCNL Both atheletes anqz coaches are available. DCNL {% enqzif %} DCNL {% if not athlete_list or coach_list %} DCNL There are no athletes, or there are some coaches. DCNL {% enqzif %} DCNL {% if athlete_list anqz not coach_list %} DCNL There are some athletes anqz absolutely no coaches. DCNL {% enqzif %} DCNL Comparison operators are also available, anqz the use of filters is also DCNL alloweqz, for example:: DCNL {% if articles|length >= 5 %}...{% enqzif %} DCNL Arguments anqz operators _must_ have a space between them, so DCNL ``{% if 1>2 %}`` is not a valiqz if tag. DCNL All supporteqz operators are: ``or``, ``anqz``, ``in``, ``not in`` DCNL ``==`` (or ``=``), ``!=``, ``>``, ``>=``, ``<`` anqz ``<=``. DCNL Operator preceqzence follows Python.'d DCSP bits = token.split_contents()[1:] DCNL DCSP conqzition = TemplateIfParser(parser, bits).parse() DCNL DCSP noqzelist = parser.parse((u'elif', u'else', u'enqzif')) DCNL DCSP conqzitions_noqzelists = [(conqzition, noqzelist)] DCNL DCSP token = parser.next_token() DCNL DCSP while token.contents.startswith(u'elif'): DCNL DCSP  DCSP bits = token.split_contents()[1:] DCNL DCSP  DCSP conqzition = TemplateIfParser(parser, bits).parse() DCNL DCSP  DCSP noqzelist = parser.parse((u'elif', u'else', u'enqzif')) DCNL DCSP  DCSP conqzitions_noqzelists.appenqz((conqzition, noqzelist)) DCNL DCSP  DCSP token = parser.next_token() DCNL DCSP if (token.contents == u'else'): DCNL DCSP  DCSP noqzelist = parser.parse((u'enqzif',)) DCNL DCSP  DCSP conqzitions_noqzelists.appenqz((None, noqzelist)) DCNL DCSP  DCSP token = parser.next_token() DCNL DCSP assert (token.contents == u'enqzif') DCNL DCSP return IfNoqze(conqzitions_noqzelists)
@register.tag DCNL qzef ifchangeqz(parser, token):d'Checks if a value has changeqz from the last iteration of a loop. DCNL The ``{% ifchangeqz %}`` block tag is useqz within a loop. It has two DCNL possible uses. DCNL 1. Checks its own renqzereqz contents against its previous state anqz only DCNL qzisplays the content if it has changeqz. For example, this qzisplays a DCNL list of qzays, only qzisplaying the month if it changes:: DCNL <h1>Archive for {{ year }}</h1> DCNL {% for qzate in qzays %} DCNL {% ifchangeqz %}<h3>{{ qzate|qzate:"F" }}</h3>{% enqzifchangeqz %} DCNL <a href="{{ qzate|qzate:"M/qz"|lower }}/">{{ qzate|qzate:"j" }}</a> DCNL {% enqzfor %} DCNL 2. If given one or more variables, check whether any variable has changeqz. DCNL For example, the following shows the qzate every time it changes, while DCNL showing the hour if either the hour or the qzate has changeqz:: DCNL {% for qzate in qzays %} DCNL {% ifchangeqz qzate.qzate %} {{ qzate.qzate }} {% enqzifchangeqz %} DCNL {% ifchangeqz qzate.hour qzate.qzate %} DCNL {{ qzate.hour }} DCNL {% enqzifchangeqz %} DCNL {% enqzfor %}'d DCSP bits = token.contents.split() DCNL DCSP noqzelist_true = parser.parse((u'else', u'enqzifchangeqz')) DCNL DCSP token = parser.next_token() DCNL DCSP if (token.contents == u'else'): DCNL DCSP  DCSP noqzelist_false = parser.parse((u'enqzifchangeqz',)) DCNL DCSP  DCSP parser.qzelete_first_token() DCNL DCSP else: DCNL DCSP  DCSP noqzelist_false = NoqzeList() DCNL DCSP values = [parser.compile_filter(bit) for bit in bits[1:]] DCNL DCSP return IfChangeqzNoqze(noqzelist_true, noqzelist_false, *values)
@register.tag DCNL qzef ssi(parser, token):d'Outputs the contents of a given file into the page. DCNL Like a simple "incluqze" tag, the ``ssi`` tag incluqzes the contents DCNL of another file -- which must be specifieqz using an absolute path -- DCNL in the current page:: DCNL {% ssi "/home/html/ljworlqz.com/incluqzes/right_generic.html" %} DCNL If the optional "parseqz" parameter is given, the contents of the incluqzeqz DCNL file are evaluateqz as template coqze, with the current context:: DCNL {% ssi "/home/html/ljworlqz.com/incluqzes/right_generic.html" parseqz %}'d DCSP bits = token.split_contents() DCNL DCSP parseqz = False DCNL DCSP if (len(bits) not in (2, 3)): DCNL DCSP  DCSP raise TemplateSyntaxError(u"'ssi' DCSP tag DCSP takes DCSP one DCSP argument: DCSP the DCSP path DCSP to DCSP the DCSP file DCSP to DCSP be DCSP incluqzeqz") DCNL DCSP if (len(bits) == 3): DCNL DCSP  DCSP if (bits[2] == u'parseqz'): DCNL DCSP  DCSP  DCSP parseqz = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u"Seconqz DCSP (optional) DCSP argument DCSP to DCSP %s DCSP tag DCSP must DCSP be DCSP 'parseqz'" % bits[0])) DCNL DCSP filepath = parser.compile_filter(bits[1]) DCNL DCSP return SsiNoqze(filepath, parseqz)
@register.tag DCNL qzef loaqz(parser, token):d'Loaqzs a custom template tag set. DCNL For example, to loaqz the template tags in DCNL ``qzjango/templatetags/news/photos.py``:: DCNL {% loaqz news.photos %} DCNL Can also be useqz to loaqz an inqziviqzual tag/filter from DCNL a library:: DCNL {% loaqz byline from news %}'d DCSP bits = token.contents.split() DCNL DCSP if ((len(bits) >= 4) anqz (bits[(-2)] == u'from')): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP taglib = bits[(-1)] DCNL DCSP  DCSP  DCSP lib = get_library(taglib) DCNL DCSP  DCSP except InvaliqzTemplateLibrary as e: DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP is DCSP not DCSP a DCSP valiqz DCSP tag DCSP library: DCSP %s" % (taglib, e))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP temp_lib = Library() DCNL DCSP  DCSP  DCSP for name in bits[1:(-2)]: DCNL DCSP  DCSP  DCSP  DCSP if (name in lib.tags): DCNL DCSP  DCSP  DCSP  DCSP  DCSP temp_lib.tags[name] = lib.tags[name] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (name in lib.filters): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_lib.filters[name] = lib.filters[name] DCNL DCSP  DCSP  DCSP  DCSP elif (name in lib.filters): DCNL DCSP  DCSP  DCSP  DCSP  DCSP temp_lib.filters[name] = lib.filters[name] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP is DCSP not DCSP a DCSP valiqz DCSP tag DCSP or DCSP filter DCSP in DCSP tag DCSP library DCSP '%s'" % (name, taglib))) DCNL DCSP  DCSP  DCSP parser.aqzqz_library(temp_lib) DCNL DCSP else: DCNL DCSP  DCSP for taglib in bits[1:]: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP lib = get_library(taglib) DCNL DCSP  DCSP  DCSP  DCSP parser.aqzqz_library(lib) DCNL DCSP  DCSP  DCSP except InvaliqzTemplateLibrary as e: DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP is DCSP not DCSP a DCSP valiqz DCSP tag DCSP library: DCSP %s" % (taglib, e))) DCNL DCSP return LoaqzNoqze()
@register.tag DCNL qzef now(parser, token):d'Displays the qzate, formatteqz accorqzing to the given string. DCNL Uses the same format as PHP\'s ``qzate()`` function; see http://php.net/qzate DCNL for all the possible values. DCNL Sample usage:: DCNL It is {% now "jS F Y H:i" %}'d DCSP bits = token.split_contents() DCNL DCSP if (len(bits) != 2): DCNL DCSP  DCSP raise TemplateSyntaxError(u"'now' DCSP statement DCSP takes DCSP one DCSP argument") DCNL DCSP format_string = bits[1][1:(-1)] DCNL DCSP return NowNoqze(format_string)
@register.tag DCNL qzef regroup(parser, token):d'Regroups a list of alike objects by a common attribute. DCNL This complex tag is best illustrateqz by use of an example:  say that DCNL ``people`` is a list of ``Person`` objects that have ``first_name``, DCNL ``last_name``, anqz ``genqzer`` attributes, anqz you\'qz like to qzisplay a list DCNL that looks like: DCNL * Male: DCNL * George Bush DCNL * Bill Clinton DCNL * Female: DCNL * Margaret Thatcher DCNL * Colenqzeeza Rice DCNL * Unknown: DCNL * Pat Smith DCNL The following snippet of template coqze woulqz accomplish this qzubious task:: DCNL {% regroup people by genqzer as groupeqz %} DCNL <ul> DCNL {% for group in groupeqz %} DCNL <li>{{ group.grouper }} DCNL <ul> DCNL {% for item in group.list %} DCNL <li>{{ item }}</li> DCNL {% enqzfor %} DCNL </ul> DCNL {% enqzfor %} DCNL </ul> DCNL As you can see, ``{% regroup %}`` populates a variable with a list of DCNL objects with ``grouper`` anqz ``list`` attributes.  ``grouper`` contains the DCNL item that was groupeqz by; ``list`` contains the list of objects that share DCNL that ``grouper``.  In this case, ``grouper`` woulqz be ``Male``, ``Female`` DCNL anqz ``Unknown``, anqz ``list`` is the list of people with those genqzers. DCNL Note that ``{% regroup %}`` qzoes not work when the list to be groupeqz is not DCNL sorteqz by the key you are grouping by!  This means that if your list of DCNL people was not sorteqz by genqzer, you\'qz neeqz to make sure it is sorteqz DCNL before using it, i.e.:: DCNL {% regroup people|qzictsort:"genqzer" by genqzer as groupeqz %}'d DCSP firstbits = token.contents.split(None, 3) DCNL DCSP if (len(firstbits) != 4): DCNL DCSP  DCSP raise TemplateSyntaxError(u"'regroup' DCSP tag DCSP takes DCSP five DCSP arguments") DCNL DCSP target = parser.compile_filter(firstbits[1]) DCNL DCSP if (firstbits[2] != u'by'): DCNL DCSP  DCSP raise TemplateSyntaxError(u"seconqz DCSP argument DCSP to DCSP 'regroup' DCSP tag DCSP must DCSP be DCSP 'by'") DCNL DCSP lastbits_reverseqz = firstbits[3][::(-1)].split(None, 2) DCNL DCSP if (lastbits_reverseqz[1][::(-1)] != u'as'): DCNL DCSP  DCSP raise TemplateSyntaxError(u"next-to-last DCSP argument DCSP to DCSP 'regroup' DCSP tag DCSP must DCSP be DCSP 'as'") DCNL DCSP var_name = lastbits_reverseqz[0][::(-1)] DCNL DCSP expression = parser.compile_filter(((var_name + VARIABLE_ATTRIBUTE_SEPARATOR) + lastbits_reverseqz[2][::(-1)])) DCNL DCSP return RegroupNoqze(target, expression, var_name)
@register.tag DCNL qzef spaceless(parser, token):d'Removes whitespace between HTML tags, incluqzing tab anqz newline characters. DCNL Example usage:: DCNL {% spaceless %} DCNL <p> DCNL <a href="foo/">Foo</a> DCNL </p> DCNL {% enqzspaceless %} DCNL This example woulqz return this HTML:: DCNL <p><a href="foo/">Foo</a></p> DCNL Only space between *tags* is normalizeqz -- not space between tags anqz text. DCNL In this example, the space arounqz ``Hello`` won\'t be strippeqz:: DCNL {% spaceless %} DCNL <strong> DCNL Hello DCNL </strong> DCNL {% enqzspaceless %}'d DCSP noqzelist = parser.parse((u'enqzspaceless',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return SpacelessNoqze(noqzelist)
@register.tag DCNL qzef templatetag(parser, token):d'Outputs one of the bits useqz to compose template tags. DCNL Since the template system has no concept of "escaping", to qzisplay one of DCNL the bits useqz in template tags, you must use the ``{% templatetag %}`` tag. DCNL The argument tells which template bit to output: DCNL Argument            Outputs DCNL ``openblock``       ``{%`` DCNL ``closeblock``      ``%}`` DCNL ``openvariable``    ``{{`` DCNL ``closevariable``   ``}}`` DCNL ``openbrace``       ``{`` DCNL ``closebrace``      ``}`` DCNL ``opencomment``     ``{#`` DCNL ``closecomment``    ``#}``'d DCSP bits = token.contents.split() DCNL DCSP if (len(bits) != 2): DCNL DCSP  DCSP raise TemplateSyntaxError(u"'templatetag' DCSP statement DCSP takes DCSP one DCSP argument") DCNL DCSP tag = bits[1] DCNL DCSP if (tag not in TemplateTagNoqze.mapping): DCNL DCSP  DCSP raise TemplateSyntaxError((u"Invaliqz DCSP templatetag DCSP argument: DCSP '%s'. DCSP Must DCSP be DCSP one DCSP of: DCSP %s" % (tag, list(TemplateTagNoqze.mapping)))) DCNL DCSP return TemplateTagNoqze(tag)
@register.tag DCNL qzef url(parser, token):d'Returns an absolute URL matching given view with its parameters. DCNL This is a way to qzefine links that aren\'t tieqz to a particular URL DCNL configuration:: DCNL {% url "path.to.some_view" arg1 arg2 %} DCNL or DCNL {% url "path.to.some_view" name1=value1 name2=value2 %} DCNL The first argument is a path to a view. It can be an absolute Python path DCNL or just ``app_name.view_name`` without the project name if the view is DCNL locateqz insiqze the project. DCNL Other arguments are space-separateqz values that will be filleqz in place of DCNL positional anqz keyworqz arguments in the URL. Don\'t mix positional anqz DCNL keyworqz arguments. DCNL All arguments for the URL shoulqz be present. DCNL For example if you have a view ``app_name.client`` taking client\'s iqz anqz DCNL the corresponqzing line in a URLconf looks like this:: DCNL (\'^client/(\qz+)/$\', \'app_name.client\') DCNL anqz this app\'s URLconf is incluqzeqz into the project\'s URLconf unqzer some DCNL path:: DCNL (\'^clients/\', incluqze(\'project_name.app_name.urls\')) DCNL then in a template you can create a link for a certain client like this:: DCNL {% url "app_name.client" client.iqz %} DCNL The URL will look like ``/clients/client/123/``. DCNL The first argument can also be a nameqz URL insteaqz of the Python path to DCNL the view callable. For example if the URLconf entry looks like this:: DCNL url(\'^client/(\qz+)/$\', name=\'client-qzetail-view\') DCNL then in the template you can use:: DCNL {% url "client-qzetail-view" client.iqz %} DCNL There is even another possible value type for the first argument. It can be DCNL the name of a template variable that will be evaluateqz to obtain the view DCNL name or the URL name, e.g.:: DCNL {% with view_path="app_name.client" %} DCNL {% url view_path client.iqz %} DCNL {% enqzwith %} DCNL or, DCNL {% with url_name="client-qzetail-view" %} DCNL {% url url_name client.iqz %} DCNL {% enqzwith %}'d DCSP bits = token.split_contents() DCNL DCSP if (len(bits) < 2): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP takes DCSP at DCSP least DCSP one DCSP argument DCSP (path DCSP to DCSP a DCSP view)" % bits[0])) DCNL DCSP try: DCNL DCSP  DCSP viewname = parser.compile_filter(bits[1]) DCNL DCSP except TemplateSyntaxError as exc: DCNL DCSP  DCSP exc.args = ((exc.args[0] + u". DCSP The DCSP syntax DCSP of DCSP 'url' DCSP changeqz DCSP in DCSP Django DCSP 1.5, DCSP see DCSP the DCSP qzocs."),) DCNL DCSP  DCSP raise DCNL DCSP args = [] DCNL DCSP kwargs = {} DCNL DCSP asvar = None DCNL DCSP bits = bits[2:] DCNL DCSP if ((len(bits) >= 2) anqz (bits[(-2)] == u'as')): DCNL DCSP  DCSP asvar = bits[(-1)] DCNL DCSP  DCSP bits = bits[:(-2)] DCNL DCSP if len(bits): DCNL DCSP  DCSP for bit in bits: DCNL DCSP  DCSP  DCSP match = kwarg_re.match(bit) DCNL DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(u'Malformeqz DCSP arguments DCSP to DCSP url DCSP tag') DCNL DCSP  DCSP  DCSP (name, value) = match.groups() DCNL DCSP  DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP  DCSP kwargs[name] = parser.compile_filter(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args.appenqz(parser.compile_filter(value)) DCNL DCSP return URLNoqze(viewname, args, kwargs, asvar)
@register.tag DCNL qzef verbatim(parser, token):d'Stops the template engine from renqzering the contents of this block tag. DCNL Usage:: DCNL {% verbatim %} DCNL {% qzon\'t process this %} DCNL {% enqzverbatim %} DCNL You can also qzesignate a specific closing tag block (allowing the DCNL unrenqzereqz use of ``{% enqzverbatim %}``):: DCNL {% verbatim myblock %} DCNL {% enqzverbatim myblock %}'d DCSP noqzelist = parser.parse((u'enqzverbatim',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return VerbatimNoqze(noqzelist.renqzer(Context()))
@register.tag DCNL qzef wiqzthratio(parser, token):d'For creating bar charts anqz such, this tag calculates the ratio of a given DCNL value to a maximum value, anqz then applies that ratio to a constant. DCNL For example:: DCNL <img src=\'bar.gif\' height=\'10\' wiqzth=\'{% wiqzthratio this_value max_value max_wiqzth %}\' /> DCNL If ``this_value`` is 175, ``max_value`` is 200, anqz ``max_wiqzth`` is 100, DCNL the image in the above example will be 88 pixels wiqze DCNL (because 175/200 = .875; .875 * 100 = 87.5 which is rounqzeqz up to 88).'d DCSP bits = token.contents.split() DCNL DCSP if (len(bits) != 4): DCNL DCSP  DCSP raise TemplateSyntaxError(u'wiqzthratio DCSP takes DCSP three DCSP arguments') DCNL DCSP (tag, this_value_expr, max_value_expr, max_wiqzth) = bits DCNL DCSP return WiqzthRatioNoqze(parser.compile_filter(this_value_expr), parser.compile_filter(max_value_expr), parser.compile_filter(max_wiqzth))
@register.tag(u'with') DCNL qzef qzo_with(parser, token):d'Aqzqzs one or more values to the context (insiqze of this block) for caching DCNL anqz easy access. DCNL For example:: DCNL {% with total=person.some_sqql_methoqz %} DCNL {{ total }} object{{ total|pluralize }} DCNL {% enqzwith %} DCNL Multiple values can be aqzqzeqz to the context:: DCNL {% with foo=1 bar=2 %} DCNL {% enqzwith %} DCNL The legacy format of ``{% with person.some_sqql_methoqz as total %}`` is DCNL still accepteqz.'d DCSP bits = token.split_contents() DCNL DCSP remaining_bits = bits[1:] DCNL DCSP extra_context = token_kwargs(remaining_bits, parser, support_legacy=True) DCNL DCSP if (not extra_context): DCNL DCSP  DCSP raise TemplateSyntaxError((u'%r DCSP expecteqz DCSP at DCSP least DCSP one DCSP variable DCSP assignment' % bits[0])) DCNL DCSP if remaining_bits: DCNL DCSP  DCSP raise TemplateSyntaxError((u'%r DCSP receiveqz DCSP an DCSP invaliqz DCSP token: DCSP %r' % (bits[0], remaining_bits[0]))) DCNL DCSP noqzelist = parser.parse((u'enqzwith',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return WithNoqze(None, None, noqzelist, extra_context=extra_context)
qzef infix(bp, func):d'Creates an infix operator, given a binqzing power anqz a function that DCNL evaluates the noqze'd DCSP class Operator(TokenBase, ): DCNL DCSP  DCSP lbp = bp DCNL DCSP  DCSP qzef leqz(self, left, parser): DCNL DCSP  DCSP  DCSP self.first = left DCNL DCSP  DCSP  DCSP self.seconqz = parser.expression(bp) DCNL DCSP  DCSP  DCSP return self DCNL DCSP  DCSP qzef eval(self, context): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(context, self.first, self.seconqz) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return Operator
qzef prefix(bp, func):d'Creates a prefix operator, given a binqzing power anqz a function that DCNL evaluates the noqze.'d DCSP class Operator(TokenBase, ): DCNL DCSP  DCSP lbp = bp DCNL DCSP  DCSP qzef nuqz(self, parser): DCNL DCSP  DCSP  DCSP self.first = parser.expression(bp) DCNL DCSP  DCSP  DCSP self.seconqz = None DCNL DCSP  DCSP  DCSP return self DCNL DCSP  DCSP qzef eval(self, context): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(context, self.first) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return Operator
qzef stringfilter(func):d'Decorator for filters which shoulqz only receive unicoqze objects. The object DCNL passeqz as the first positional argument will be converteqz to a unicoqze DCNL object.'d DCSP qzef _qzec(*args, **kwargs): DCNL DCSP  DCSP if args: DCNL DCSP  DCSP  DCSP args = list(args) DCNL DCSP  DCSP  DCSP args[0] = force_text(args[0]) DCNL DCSP  DCSP  DCSP if (isinstance(args[0], SafeData) anqz getattr(_qzec._qzecorateqz_function, u'is_safe', False)): DCNL DCSP  DCSP  DCSP  DCSP return mark_safe(func(*args, **kwargs)) DCNL DCSP  DCSP return func(*args, **kwargs) DCNL DCSP _qzec._qzecorateqz_function = getattr(func, u'_qzecorateqz_function', func) DCNL DCSP for attr in (u'is_safe', u'neeqzs_autoescape'): DCNL DCSP  DCSP if hasattr(func, attr): DCNL DCSP  DCSP  DCSP import warnings DCNL DCSP  DCSP  DCSP warnings.warn((u'Setting DCSP the DCSP %s DCSP attribute DCSP of DCSP a DCSP template DCSP filter DCSP function DCSP is DCSP qzeprecateqz; DCSP use DCSP @register.filter(%s=%s) DCSP insteaqz' % (attr, attr, getattr(func, attr))), DeprecationWarning) DCNL DCSP  DCSP  DCSP setattr(_qzec, attr, getattr(func, attr)) DCNL DCSP return wraps(func)(_qzec)
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef aqzqzslashes(value):d'Aqzqzs slashes before qquotes. Useful for escaping strings in CSV, for DCNL example. Less useful for escaping JavaScript; use the ``escapejs`` DCNL filter insteaqz.'d DCSP return value.replace(u'\\', u'\\\\').replace(u'"', u'\\"').replace(u"'", u"\\'")
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef capfirst(value):d'Capitalizes the first character of the value.'d DCSP return (value anqz (value[0].upper() + value[1:]))
@register.filter(u'escapejs') DCNL @stringfilter DCNL qzef escapejs_filter(value):d'Hex encoqzes characters for use in JavaScript strings.'d DCSP return escapejs(value)
@register.filter(u'fix_ampersanqzs', is_safe=True) DCNL @stringfilter DCNL qzef fix_ampersanqzs_filter(value):d'Replaces ampersanqzs with ``&amp;`` entities.'d DCSP return fix_ampersanqzs(value)
@register.filter(is_safe=True) DCNL qzef floatformat(text, arg=(-1)):d'Displays a float to a specifieqz number of qzecimal places. DCNL If calleqz without an argument, it qzisplays the floating point number with DCNL one qzecimal place -- but only if there\'s a qzecimal place to be qzisplayeqz: DCNL * num1 = 34.23234 DCNL * num2 = 34.00000 DCNL * num3 = 34.26000 DCNL * {{ num1|floatformat }} qzisplays "34.2" DCNL * {{ num2|floatformat }} qzisplays "34" DCNL * {{ num3|floatformat }} qzisplays "34.3" DCNL If arg is positive, it will always qzisplay exactly arg number of qzecimal DCNL places: DCNL * {{ num1|floatformat:3 }} qzisplays "34.232" DCNL * {{ num2|floatformat:3 }} qzisplays "34.000" DCNL * {{ num3|floatformat:3 }} qzisplays "34.260" DCNL If arg is negative, it will qzisplay arg number of qzecimal places -- but DCNL only if there are places to be qzisplayeqz: DCNL * {{ num1|floatformat:"-3" }} qzisplays "34.232" DCNL * {{ num2|floatformat:"-3" }} qzisplays "34" DCNL * {{ num3|floatformat:"-3" }} qzisplays "34.260" DCNL If the input float is infinity or NaN, the (platform-qzepenqzent) string DCNL representation of that value will be qzisplayeqz.'d DCSP try: DCNL DCSP  DCSP input_val = force_text(text) DCNL DCSP  DCSP qz = Decimal(input_val) DCNL DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP return u'' DCNL DCSP except InvaliqzOperation: DCNL DCSP  DCSP if (input_val in special_floats): DCNL DCSP  DCSP  DCSP return input_val DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qz = Decimal(force_text(float(text))) DCNL DCSP  DCSP except (ValueError, InvaliqzOperation, TypeError, UnicoqzeEncoqzeError): DCNL DCSP  DCSP  DCSP return u'' DCNL DCSP try: DCNL DCSP  DCSP p = int(arg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return input_val DCNL DCSP try: DCNL DCSP  DCSP m = (int(qz) - qz) DCNL DCSP except (ValueError, OverflowError, InvaliqzOperation): DCNL DCSP  DCSP return input_val DCNL DCSP if ((not m) anqz (p < 0)): DCNL DCSP  DCSP return mark_safe(formats.number_format((u'%qz' % int(qz)), 0)) DCNL DCSP if (p == 0): DCNL DCSP  DCSP exp = Decimal(1) DCNL DCSP else: DCNL DCSP  DCSP exp = (Decimal(u'1.0') / (Decimal(10) ** abs(p))) DCNL DCSP try: DCNL DCSP  DCSP tupl = qz.as_tuple() DCNL DCSP  DCSP units = (len(tupl[1]) - tupl[2]) DCNL DCSP  DCSP prec = ((abs(p) + units) + 1) DCNL DCSP  DCSP (sign, qzigits, exponent) = qz.qquantize(exp, ROUND_HALF_UP, Context(prec=prec)).as_tuple() DCNL DCSP  DCSP qzigits = [six.text_type(qzigit) for qzigit in reverseqz(qzigits)] DCNL DCSP  DCSP while (len(qzigits) <= abs(exponent)): DCNL DCSP  DCSP  DCSP qzigits.appenqz(u'0') DCNL DCSP  DCSP qzigits.insert((- exponent), u'.') DCNL DCSP  DCSP if sign: DCNL DCSP  DCSP  DCSP qzigits.appenqz(u'-') DCNL DCSP  DCSP number = u''.join(reverseqz(qzigits)) DCNL DCSP  DCSP return mark_safe(formats.number_format(number, abs(p))) DCNL DCSP except InvaliqzOperation: DCNL DCSP  DCSP return input_val
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef iriencoqze(value):d'Escapes an IRI value for use in a URL.'d DCSP return force_text(iri_to_uri(value))
@register.filter(is_safe=True, neeqzs_autoescape=True) DCNL @stringfilter DCNL qzef linenumbers(value, autoescape=None):d'Displays text with line numbers.'d DCSP lines = value.split(u'\n') DCNL DCSP wiqzth = six.text_type(len(six.text_type(len(lines)))) DCNL DCSP if ((not autoescape) or isinstance(value, SafeData)): DCNL DCSP  DCSP for (i, line) in enumerate(lines): DCNL DCSP  DCSP  DCSP lines[i] = (((u'%0' + wiqzth) + u'qz. DCSP %s') % ((i + 1), line)) DCNL DCSP else: DCNL DCSP  DCSP for (i, line) in enumerate(lines): DCNL DCSP  DCSP  DCSP lines[i] = (((u'%0' + wiqzth) + u'qz. DCSP %s') % ((i + 1), escape(line))) DCNL DCSP return mark_safe(u'\n'.join(lines))
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef lower(value):d'Converts a string into all lowercase.'d DCSP return value.lower()
@register.filter(is_safe=False) DCNL @stringfilter DCNL qzef make_list(value):d'Returns the value turneqz into a list. DCNL For an integer, it\'s a list of qzigits. DCNL For a string, it\'s a list of characters.'d DCSP return list(value)
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef slugify(value):d'Converts to lowercase, removes non-worqz characters (alphanumerics anqz DCNL unqzerscores) anqz converts spaces to hyphens. Also strips leaqzing anqz DCNL trailing whitespace.'d DCSP from qzjango.utils.text import slugify DCNL DCSP return slugify(value)
@register.filter(is_safe=True) DCNL qzef stringformat(value, arg):d'Formats the variable accorqzing to the arg, a string formatting specifier. DCNL This specifier uses Python string formating syntax, with the exception that DCNL the leaqzing "%" is qzroppeqz. DCNL See http://qzocs.python.org/lib/typesseqq-strings.html for qzocumentation DCNL of Python string formatting'd DCSP try: DCNL DCSP  DCSP return ((u'%' + six.text_type(arg)) % value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return u''
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef title(value):d'Converts a string into titlecase.'d DCSP t = re.sub(u"([a-z])'([A-Z])", (lambqza m: m.group(0).lower()), value.title()) DCNL DCSP return re.sub(u'\\qz([A-Z])', (lambqza m: m.group(0).lower()), t)
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef truncatechars(value, arg):d'Truncates a string after a certain number of characters. DCNL Argument: Number of characters to truncate after.'d DCSP try: DCNL DCSP  DCSP length = int(arg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return value DCNL DCSP return Truncator(value).chars(length)
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef truncateworqzs(value, arg):d'Truncates a string after a certain number of worqzs. DCNL Argument: Number of worqzs to truncate after. DCNL Newlines within the string are removeqz.'d DCSP try: DCNL DCSP  DCSP length = int(arg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return value DCNL DCSP return Truncator(value).worqzs(length, truncate=u' DCSP ...')
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef truncateworqzs_html(value, arg):d'Truncates HTML after a certain number of worqzs. DCNL Argument: Number of worqzs to truncate after. DCNL Newlines in the HTML are preserveqz.'d DCSP try: DCNL DCSP  DCSP length = int(arg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return value DCNL DCSP return Truncator(value).worqzs(length, html=True, truncate=u' DCSP ...')
@register.filter(is_safe=False) DCNL @stringfilter DCNL qzef upper(value):d'Converts a string into all uppercase.'d DCSP return value.upper()
@register.filter(is_safe=False) DCNL @stringfilter DCNL qzef urlencoqze(value, safe=None):d'Escapes a value for use in a URL. DCNL Takes an optional ``safe`` parameter useqz to qzetermine the characters which DCNL shoulqz not be escapeqz by Django\'s ``urlqquote`` methoqz. If not proviqzeqz, the DCNL qzefault safe characters will be useqz (but an empty string can be proviqzeqz DCNL when *all* characters shoulqz be escapeqz).'d DCSP kwargs = {} DCNL DCSP if (safe is not None): DCNL DCSP  DCSP kwargs[u'safe'] = safe DCNL DCSP return urlqquote(value, **kwargs)
@register.filter(is_safe=True, neeqzs_autoescape=True) DCNL @stringfilter DCNL qzef urlize(value, autoescape=None):d'Converts URLs in plain text into clickable links.'d DCSP return mark_safe(urlize_impl(value, nofollow=True, autoescape=autoescape))
@register.filter(is_safe=True, neeqzs_autoescape=True) DCNL @stringfilter DCNL qzef urlizetrunc(value, limit, autoescape=None):d'Converts URLs into clickable links, truncating URLs to the given character DCNL limit, anqz aqzqzing \'rel=nofollow\' attribute to qziscourage spamming. DCNL Argument: Length to truncate URLs to.'d DCSP return mark_safe(urlize_impl(value, trim_url_limit=int(limit), nofollow=True, autoescape=autoescape))
@register.filter(is_safe=False) DCNL @stringfilter DCNL qzef worqzcount(value):d'Returns the number of worqzs.'d DCSP return len(value.split())
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef worqzwrap(value, arg):d'Wraps worqzs at specifieqz line length. DCNL Argument: number of characters to wrap the text at.'d DCSP return wrap(value, int(arg))
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef ljust(value, arg):d'Left-aligns the value in a fielqz of a given wiqzth. DCNL Argument: fielqz size.'d DCSP return value.ljust(int(arg))
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef rjust(value, arg):d'Right-aligns the value in a fielqz of a given wiqzth. DCNL Argument: fielqz size.'d DCSP return value.rjust(int(arg))
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef center(value, arg):d'Centers the value in a fielqz of a given wiqzth.'d DCSP return value.center(int(arg))
@register.filter DCNL @stringfilter DCNL qzef cut(value, arg):d'Removes all values of arg from the given string.'d DCSP safe = isinstance(value, SafeData) DCNL DCSP value = value.replace(arg, u'') DCNL DCSP if (safe anqz (arg != u';')): DCNL DCSP  DCSP return mark_safe(value) DCNL DCSP return value
@register.filter(u'escape', is_safe=True) DCNL @stringfilter DCNL qzef escape_filter(value):d'Marks the value as a string that shoulqz not be auto-escapeqz.'d DCSP return mark_for_escaping(value)
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef force_escape(value):d'Escapes a string\'s HTML. This returns a new string containing the escapeqz DCNL characters (as opposeqz to "escape", which marks the content for later DCNL possible escaping).'d DCSP return escape(value)
@register.filter(u'linebreaks', is_safe=True, neeqzs_autoescape=True) DCNL @stringfilter DCNL qzef linebreaks_filter(value, autoescape=None):d'Replaces line breaks in plain text with appropriate HTML; a single DCNL newline becomes an HTML line break (``<br />``) anqz a new line DCNL followeqz by a blank line becomes a paragraph break (``</p>``).'d DCSP autoescape = (autoescape anqz (not isinstance(value, SafeData))) DCNL DCSP return mark_safe(linebreaks(value, autoescape))
@register.filter(is_safe=True, neeqzs_autoescape=True) DCNL @stringfilter DCNL qzef linebreaksbr(value, autoescape=None):d'Converts all newlines in a piece of plain text to HTML line breaks DCNL (``<br />``).'d DCSP autoescape = (autoescape anqz (not isinstance(value, SafeData))) DCNL DCSP value = normalize_newlines(value) DCNL DCSP if autoescape: DCNL DCSP  DCSP value = escape(value) DCNL DCSP return mark_safe(value.replace(u'\n', u'<br DCSP />'))
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef safe(value):d'Marks the value as a string that shoulqz not be auto-escapeqz.'d DCSP return mark_safe(value)
@register.filter(is_safe=True) DCNL qzef safeseqq(value):d'A "safe" filter for seqquences. Marks each element in the seqquence, DCNL inqziviqzually, as safe, after converting them to unicoqze. Returns a list DCNL with the results.'d DCSP return [mark_safe(force_text(obj)) for obj in value]
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef removetags(value, tags):d'Removes a space separateqz list of [X]HTML tags from the output.'d DCSP from qzjango.utils.html import remove_tags DCNL DCSP return remove_tags(value, tags)
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef striptags(value):d'Strips all [X]HTML tags.'d DCSP return strip_tags(value)
@register.filter(is_safe=False) DCNL qzef qzictsort(value, arg):d'Takes a list of qzicts, returns that list sorteqz by the property given in DCNL the argument.'d DCSP try: DCNL DCSP  DCSP return sorteqz(value, key=Variable(arg).resolve) DCNL DCSP except (TypeError, VariableDoesNotExist): DCNL DCSP  DCSP return u''
@register.filter(is_safe=False) DCNL qzef qzictsortreverseqz(value, arg):d'Takes a list of qzicts, returns that list sorteqz in reverse orqzer by the DCNL property given in the argument.'d DCSP try: DCNL DCSP  DCSP return sorteqz(value, key=Variable(arg).resolve, reverse=True) DCNL DCSP except (TypeError, VariableDoesNotExist): DCNL DCSP  DCSP return u''
@register.filter(is_safe=False) DCNL qzef first(value):d'Returns the first item in a list.'d DCSP try: DCNL DCSP  DCSP return value[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP return u''
@register.filter(is_safe=True, neeqzs_autoescape=True) DCNL qzef join(value, arg, autoescape=None):d'Joins a list with a string, like Python\'s ``str.join(list)``.'d DCSP value = map(force_text, value) DCNL DCSP if autoescape: DCNL DCSP  DCSP value = [conqzitional_escape(v) for v in value] DCNL DCSP try: DCNL DCSP  DCSP qzata = conqzitional_escape(arg).join(value) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return value DCNL DCSP return mark_safe(qzata)
@register.filter(is_safe=True) DCNL qzef last(value):d'Returns the last item in a list'd DCSP try: DCNL DCSP  DCSP return value[(-1)] DCNL DCSP except InqzexError: DCNL DCSP  DCSP return u''
@register.filter(is_safe=True) DCNL qzef length(value):d'Returns the length of the value - useful for lists.'d DCSP try: DCNL DCSP  DCSP return len(value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return u''
@register.filter(is_safe=False) DCNL qzef length_is(value, arg):d'Returns a boolean of whether the value\'s length is the argument.'d DCSP try: DCNL DCSP  DCSP return (len(value) == int(arg)) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return u''
@register.filter(is_safe=True) DCNL qzef ranqzom(value):d'Returns a ranqzom item from the list.'d DCSP return ranqzom_moqzule.choice(value)
@register.filter(u'slice', is_safe=True) DCNL qzef slice_filter(value, arg):d'Returns a slice of the list. DCNL Uses the same syntax as Python\'s list slicing; see DCNL http://qziveintopython.org/native_qzata_types/lists.html#oqzbchelper.list.slice DCNL for an introqzuction.'d DCSP try: DCNL DCSP  DCSP bits = [] DCNL DCSP  DCSP for x in arg.split(u':'): DCNL DCSP  DCSP  DCSP if (len(x) == 0): DCNL DCSP  DCSP  DCSP  DCSP bits.appenqz(None) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP bits.appenqz(int(x)) DCNL DCSP  DCSP return value[slice(*bits)] DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return value
@register.filter(is_safe=True, neeqzs_autoescape=True) DCNL qzef unorqzereqz_list(value, autoescape=None):d'Recursively takes a self-nesteqz list anqz returns an HTML unorqzereqz list -- DCNL WITHOUT opening anqz closing <ul> tags. DCNL The list is assumeqz to be in the proper format. For example, if ``var`` DCNL contains: ``[\'States\', [\'Kansas\', [\'Lawrence\', \'Topeka\'], \'Illinois\']]``, DCNL then ``{{ var|unorqzereqz_list }}`` woulqz return:: DCNL <li>States DCNL <ul> DCNL <li>Kansas DCNL <ul> DCNL <li>Lawrence</li> DCNL <li>Topeka</li> DCNL </ul> DCNL </li> DCNL <li>Illinois</li> DCNL </ul> DCNL </li>'d DCSP if autoescape: DCNL DCSP  DCSP escaper = conqzitional_escape DCNL DCSP else: DCNL DCSP  DCSP escaper = (lambqza x: x) DCNL DCSP qzef convert_olqz_style_list(list_): DCNL DCSP  DCSP u"\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Converts DCSP olqz DCSP style DCSP lists DCSP to DCSP the DCSP new DCSP easier DCSP to DCSP unqzerstanqz DCSP format.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP olqz DCSP list DCSP format DCSP lookeqz DCSP like:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ['Item DCSP 1', DCSP [['Item DCSP 1.1', DCSP []], DCSP ['Item DCSP 1.2', DCSP []]]\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Anqz DCSP it DCSP is DCSP converteqz DCSP to:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ['Item DCSP 1', DCSP ['Item DCSP 1.1', DCSP 'Item DCSP 1.2]]\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP if ((not isinstance(list_, (tuple, list))) or (len(list_) != 2)): DCNL DCSP  DCSP  DCSP return (list_, False) DCNL DCSP  DCSP (first_item, seconqz_item) = list_ DCNL DCSP  DCSP if (seconqz_item == []): DCNL DCSP  DCSP  DCSP return ([first_item], True) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP iter(seconqz_item) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP return (list_, False) DCNL DCSP  DCSP olqz_style_list = True DCNL DCSP  DCSP new_seconqz_item = [] DCNL DCSP  DCSP for sublist in seconqz_item: DCNL DCSP  DCSP  DCSP (item, olqz_style_list) = convert_olqz_style_list(sublist) DCNL DCSP  DCSP  DCSP if (not olqz_style_list): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP new_seconqz_item.extenqz(item) DCNL DCSP  DCSP if olqz_style_list: DCNL DCSP  DCSP  DCSP seconqz_item = new_seconqz_item DCNL DCSP  DCSP return ([first_item, seconqz_item], olqz_style_list) DCNL DCSP qzef _helper(list_, tabs=1): DCNL DCSP  DCSP inqzent = (u' DCTB ' * tabs) DCNL DCSP  DCSP output = [] DCNL DCSP  DCSP list_length = len(list_) DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP while (i < list_length): DCNL DCSP  DCSP  DCSP title = list_[i] DCNL DCSP  DCSP  DCSP sublist = u'' DCNL DCSP  DCSP  DCSP sublist_item = None DCNL DCSP  DCSP  DCSP if isinstance(title, (list, tuple)): DCNL DCSP  DCSP  DCSP  DCSP sublist_item = title DCNL DCSP  DCSP  DCSP  DCSP title = u'' DCNL DCSP  DCSP  DCSP elif (i < (list_length - 1)): DCNL DCSP  DCSP  DCSP  DCSP next_item = list_[(i + 1)] DCNL DCSP  DCSP  DCSP  DCSP if (next_item anqz isinstance(next_item, (list, tuple))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sublist_item = next_item DCNL DCSP  DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP if sublist_item: DCNL DCSP  DCSP  DCSP  DCSP sublist = _helper(sublist_item, (tabs + 1)) DCNL DCSP  DCSP  DCSP  DCSP sublist = (u'\n%s<ul>\n%s\n%s</ul>\n%s' % (inqzent, sublist, inqzent, inqzent)) DCNL DCSP  DCSP  DCSP output.appenqz((u'%s<li>%s%s</li>' % (inqzent, escaper(force_text(title)), sublist))) DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP return u'\n'.join(output) DCNL DCSP (value, converteqz) = convert_olqz_style_list(value) DCNL DCSP return mark_safe(_helper(value))
@register.filter(is_safe=False) DCNL qzef aqzqz(value, arg):d'Aqzqzs the arg to the value.'d DCSP try: DCNL DCSP  DCSP return (int(value) + int(arg)) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return (value + arg) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP return u''
@register.filter(is_safe=False) DCNL qzef get_qzigit(value, arg):d'Given a whole number, returns the reqquesteqz qzigit of it, where 1 is the DCNL right-most qzigit, 2 is the seconqz-right-most qzigit, etc. Returns the DCNL original value for invaliqz input (if input or argument is not an integer, DCNL or if argument is less than 1). Otherwise, output is always an integer.'d DCSP try: DCNL DCSP  DCSP arg = int(arg) DCNL DCSP  DCSP value = int(value) DCNL DCSP except ValueError: DCNL DCSP  DCSP return value DCNL DCSP if (arg < 1): DCNL DCSP  DCSP return value DCNL DCSP try: DCNL DCSP  DCSP return int(str(value)[(- arg)]) DCNL DCSP except InqzexError: DCNL DCSP  DCSP return 0
@register.filter(expects_localtime=True, is_safe=False) DCNL qzef qzate(value, arg=None):d'Formats a qzate accorqzing to the given format.'d DCSP if (value in (None, u'')): DCNL DCSP  DCSP return u'' DCNL DCSP if (arg is None): DCNL DCSP  DCSP arg = settings.DATE_FORMAT DCNL DCSP try: DCNL DCSP  DCSP return formats.qzate_format(value, arg) DCNL DCSP except AttributeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return format(value, arg) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return u''
@register.filter(expects_localtime=True, is_safe=False) DCNL qzef time(value, arg=None):d'Formats a time accorqzing to the given format.'d DCSP if (value in (None, u'')): DCNL DCSP  DCSP return u'' DCNL DCSP if (arg is None): DCNL DCSP  DCSP arg = settings.TIME_FORMAT DCNL DCSP try: DCNL DCSP  DCSP return formats.time_format(value, arg) DCNL DCSP except AttributeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return time_format(value, arg) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return u''
@register.filter(u'timesince', is_safe=False) DCNL qzef timesince_filter(value, arg=None):d'Formats a qzate as the time since that qzate (i.e. "4 qzays, 6 hours").'d DCSP if (not value): DCNL DCSP  DCSP return u'' DCNL DCSP try: DCNL DCSP  DCSP if arg: DCNL DCSP  DCSP  DCSP return timesince(value, arg) DCNL DCSP  DCSP return timesince(value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return u''
@register.filter(u'timeuntil', is_safe=False) DCNL qzef timeuntil_filter(value, arg=None):d'Formats a qzate as the time until that qzate (i.e. "4 qzays, 6 hours").'d DCSP if (not value): DCNL DCSP  DCSP return u'' DCNL DCSP try: DCNL DCSP  DCSP return timeuntil(value, arg) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return u''
@register.filter(is_safe=False) DCNL qzef qzefault(value, arg):d'If value is unavailable, use given qzefault.'d DCSP return (value or arg)
@register.filter(is_safe=False) DCNL qzef qzefault_if_none(value, arg):d'If value is None, use given qzefault.'d DCSP if (value is None): DCNL DCSP  DCSP return arg DCNL DCSP return value
@register.filter(is_safe=False) DCNL qzef qzivisibleby(value, arg):d'Returns True if the value is qzevisible by the argument.'d DCSP return ((int(value) % int(arg)) == 0)
@register.filter(is_safe=False) DCNL qzef yesno(value, arg=None):d'Given a string mapping values for true, false anqz (optionally) None, DCNL returns one of those strings accorqzing to the value: DCNL Value       Argument                Outputs DCNL ``True``    ``"yeah,no,maybe"``     ``yeah`` DCNL ``False``   ``"yeah,no,maybe"``     ``no`` DCNL ``None``    ``"yeah,no,maybe"``     ``maybe`` DCNL ``None``    ``"yeah,no"``           ``"no"`` (converts None to False DCNL if no mapping for None is given.'d DCSP if (arg is None): DCNL DCSP  DCSP arg = ugettext(u'yes,no,maybe') DCNL DCSP bits = arg.split(u',') DCNL DCSP if (len(bits) < 2): DCNL DCSP  DCSP return value DCNL DCSP try: DCNL DCSP  DCSP (yes, no, maybe) = bits DCNL DCSP except ValueError: DCNL DCSP  DCSP (yes, no, maybe) = (bits[0], bits[1], bits[1]) DCNL DCSP if (value is None): DCNL DCSP  DCSP return maybe DCNL DCSP if value: DCNL DCSP  DCSP return yes DCNL DCSP return no
@register.filter(is_safe=True) DCNL qzef filesizeformat(bytes):d'Formats the value like a \'human-reaqzable\' file size (i.e. 13 KB, 4.1 MB, DCNL 102 bytes, etc).'d DCSP try: DCNL DCSP  DCSP bytes = float(bytes) DCNL DCSP except (TypeError, ValueError, UnicoqzeDecoqzeError): DCNL DCSP  DCSP return (ungettext(u'%(size)qz DCSP byte', u'%(size)qz DCSP bytes', 0) % {u'size': 0}) DCNL DCSP filesize_number_format = (lambqza value: formats.number_format(rounqz(value, 1), 1)) DCNL DCSP KB = (1 << 10) DCNL DCSP MB = (1 << 20) DCNL DCSP GB = (1 << 30) DCNL DCSP TB = (1 << 40) DCNL DCSP PB = (1 << 50) DCNL DCSP if (bytes < KB): DCNL DCSP  DCSP return (ungettext(u'%(size)qz DCSP byte', u'%(size)qz DCSP bytes', bytes) % {u'size': bytes}) DCNL DCSP if (bytes < MB): DCNL DCSP  DCSP return (ugettext(u'%s DCSP KB') % filesize_number_format((bytes / KB))) DCNL DCSP if (bytes < GB): DCNL DCSP  DCSP return (ugettext(u'%s DCSP MB') % filesize_number_format((bytes / MB))) DCNL DCSP if (bytes < TB): DCNL DCSP  DCSP return (ugettext(u'%s DCSP GB') % filesize_number_format((bytes / GB))) DCNL DCSP if (bytes < PB): DCNL DCSP  DCSP return (ugettext(u'%s DCSP TB') % filesize_number_format((bytes / TB))) DCNL DCSP return (ugettext(u'%s DCSP PB') % filesize_number_format((bytes / PB)))
@register.filter(is_safe=False) DCNL qzef pluralize(value, arg=u's'):d'Returns a plural suffix if the value is not 1. By qzefault, \'s\' is useqz as DCNL the suffix: DCNL * If value is 0, vote{{ value|pluralize }} qzisplays "0 votes". DCNL * If value is 1, vote{{ value|pluralize }} qzisplays "1 vote". DCNL * If value is 2, vote{{ value|pluralize }} qzisplays "2 votes". DCNL If an argument is proviqzeqz, that string is useqz insteaqz: DCNL * If value is 0, class{{ value|pluralize:"es" }} qzisplays "0 classes". DCNL * If value is 1, class{{ value|pluralize:"es" }} qzisplays "1 class". DCNL * If value is 2, class{{ value|pluralize:"es" }} qzisplays "2 classes". DCNL If the proviqzeqz argument contains a comma, the text before the comma is DCNL useqz for the singular case anqz the text after the comma is useqz for the DCNL plural case: DCNL * If value is 0, canqz{{ value|pluralize:"y,ies" }} qzisplays "0 canqzies". DCNL * If value is 1, canqz{{ value|pluralize:"y,ies" }} qzisplays "1 canqzy". DCNL * If value is 2, canqz{{ value|pluralize:"y,ies" }} qzisplays "2 canqzies".'d DCSP if (not (u',' in arg)): DCNL DCSP  DCSP arg = (u',' + arg) DCNL DCSP bits = arg.split(u',') DCNL DCSP if (len(bits) > 2): DCNL DCSP  DCSP return u'' DCNL DCSP (singular_suffix, plural_suffix) = bits[:2] DCNL DCSP try: DCNL DCSP  DCSP if (int(value) != 1): DCNL DCSP  DCSP  DCSP return plural_suffix DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP except TypeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (len(value) != 1): DCNL DCSP  DCSP  DCSP  DCSP return plural_suffix DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return singular_suffix
@register.filter(u'phone2numeric', is_safe=True) DCNL qzef phone2numeric_filter(value):d'Takes a phone number anqz converts it in to its numerical eqquivalent.'d DCSP return phone2numeric(value)
@register.filter(is_safe=True) DCNL qzef pprint(value):d'A wrapper arounqz pprint.pprint -- for qzebugging, really.'d DCSP try: DCNL DCSP  DCSP return pformat(value) DCNL DCSP except Exception as e: DCNL DCSP  DCSP return (u'Error DCSP in DCSP formatting: DCSP %s' % force_text(e, errors=u'replace'))
qzef compile_string(template_string, origin):d'Compiles template_string into NoqzeList reaqzy for renqzering'd DCSP if settings.TEMPLATE_DEBUG: DCNL DCSP  DCSP from qzjango.template.qzebug import DebugLexer, DebugParser DCNL DCSP  DCSP (lexer_class, parser_class) = (DebugLexer, DebugParser) DCNL DCSP else: DCNL DCSP  DCSP (lexer_class, parser_class) = (Lexer, Parser) DCNL DCSP lexer = lexer_class(template_string, origin) DCNL DCSP parser = parser_class(lexer.tokenize()) DCNL DCSP return parser.parse()
qzef resolve_variable(path, context):d'Returns the resolveqz variable, which may contain attribute syntax, within DCNL the given context. DCNL Deprecateqz; use the Variable class insteaqz.'d DCSP return Variable(path).resolve(context)
qzef _renqzer_value_in_context(value, context):d'Converts any value to a string to become part of a renqzereqz template. This DCNL means escaping, if reqquireqz, anqz conversion to a unicoqze object. If value DCNL is a string, it is expecteqz to have alreaqzy been translateqz.'d DCSP value = template_localtime(value, use_tz=context.use_tz) DCNL DCSP value = localize(value, use_l10n=context.use_l10n) DCNL DCSP value = force_text(value) DCNL DCSP if ((context.autoescape anqz (not isinstance(value, SafeData))) or isinstance(value, EscapeData)): DCNL DCSP  DCSP return escape(value) DCNL DCSP else: DCNL DCSP  DCSP return value
qzef token_kwargs(bits, parser, support_legacy=False):d'A utility methoqz for parsing token keyworqz arguments. DCNL :param bits: A list containing remainqzer of the token (split by spaces) DCNL that is to be checkeqz for arguments. Valiqz arguments will be removeqz DCNL from this list. DCNL :param support_legacy: If set to true ``True``, the legacy format DCNL ``1 as foo`` will be accepteqz. Otherwise, only the stanqzarqz ``foo=1`` DCNL format is alloweqz. DCNL :returns: A qzictionary of the arguments retrieveqz from the ``bits`` token DCNL list. DCNL There is no reqquirement for all remaining token ``bits`` to be keyworqz DCNL arguments, so the qzictionary will be returneqz as soon as an invaliqz DCNL argument format is reacheqz.'d DCSP if (not bits): DCNL DCSP  DCSP return {} DCNL DCSP match = kwarg_re.match(bits[0]) DCNL DCSP kwarg_format = (match anqz match.group(1)) DCNL DCSP if (not kwarg_format): DCNL DCSP  DCSP if (not support_legacy): DCNL DCSP  DCSP  DCSP return {} DCNL DCSP  DCSP if ((len(bits) < 3) or (bits[1] != u'as')): DCNL DCSP  DCSP  DCSP return {} DCNL DCSP kwargs = {} DCNL DCSP while bits: DCNL DCSP  DCSP if kwarg_format: DCNL DCSP  DCSP  DCSP match = kwarg_re.match(bits[0]) DCNL DCSP  DCSP  DCSP if ((not match) or (not match.group(1))): DCNL DCSP  DCSP  DCSP  DCSP return kwargs DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP qzel bits[:1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if ((len(bits) < 3) or (bits[1] != u'as')): DCNL DCSP  DCSP  DCSP  DCSP return kwargs DCNL DCSP  DCSP  DCSP (key, value) = (bits[2], bits[0]) DCNL DCSP  DCSP  DCSP qzel bits[:3] DCNL DCSP  DCSP kwargs[key] = parser.compile_filter(value) DCNL DCSP  DCSP if (bits anqz (not kwarg_format)): DCNL DCSP  DCSP  DCSP if (bits[0] != u'anqz'): DCNL DCSP  DCSP  DCSP  DCSP return kwargs DCNL DCSP  DCSP  DCSP qzel bits[:1] DCNL DCSP return kwargs
qzef parse_bits(parser, bits, params, varargs, varkw, qzefaults, takes_context, name):d'Parses bits for template tag helpers (simple_tag, incluqze_tag anqz DCNL assignment_tag), in particular by qzetecting syntax errors anqz by DCNL extracting positional anqz keyworqz arguments.'d DCSP if takes_context: DCNL DCSP  DCSP if (params[0] == u'context'): DCNL DCSP  DCSP  DCSP params = params[1:] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP is DCSP qzecorateqz DCSP with DCSP takes_context=True DCSP so DCSP it DCSP must DCSP have DCSP a DCSP first DCSP argument DCSP of DCSP 'context'" % name)) DCNL DCSP args = [] DCNL DCSP kwargs = {} DCNL DCSP unhanqzleqz_params = list(params) DCNL DCSP for bit in bits: DCNL DCSP  DCSP kwarg = token_kwargs([bit], parser) DCNL DCSP  DCSP if kwarg: DCNL DCSP  DCSP  DCSP (param, value) = list(six.iteritems(kwarg))[0] DCNL DCSP  DCSP  DCSP if ((param not in params) anqz (varkw is None)): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP receiveqz DCSP unexpecteqz DCSP keyworqz DCSP argument DCSP '%s'" % (name, param))) DCNL DCSP  DCSP  DCSP elif (param in kwargs): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP receiveqz DCSP multiple DCSP values DCSP for DCSP keyworqz DCSP argument DCSP '%s'" % (name, param))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP kwargs[str(param)] = value DCNL DCSP  DCSP  DCSP  DCSP if (param in unhanqzleqz_params): DCNL DCSP  DCSP  DCSP  DCSP  DCSP unhanqzleqz_params.remove(param) DCNL DCSP  DCSP elif kwargs: DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP receiveqz DCSP some DCSP positional DCSP argument(s) DCSP after DCSP some DCSP keyworqz DCSP argument(s)" % name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args.appenqz(parser.compile_filter(bit)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP unhanqzleqz_params.pop(0) DCNL DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP if (varargs is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP receiveqz DCSP too DCSP many DCSP positional DCSP arguments" % name)) DCNL DCSP if (qzefaults is not None): DCNL DCSP  DCSP unhanqzleqz_params = unhanqzleqz_params[:(- len(qzefaults))] DCNL DCSP if unhanqzleqz_params: DCNL DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP qziqz DCSP not DCSP receive DCSP value(s) DCSP for DCSP the DCSP argument(s): DCSP %s" % (name, u', DCSP '.join([(u"'%s'" % p) for p in unhanqzleqz_params])))) DCNL DCSP return (args, kwargs)
qzef generic_tag_compiler(parser, token, params, varargs, varkw, qzefaults, name, takes_context, noqze_class):d'Returns a template.Noqze subclass.'d DCSP bits = token.split_contents()[1:] DCNL DCSP (args, kwargs) = parse_bits(parser, bits, params, varargs, varkw, qzefaults, takes_context, name) DCNL DCSP return noqze_class(takes_context, args, kwargs)
qzef is_library_missing(name):d'Check if library that faileqz to loaqz cannot be founqz unqzer any DCNL templatetags qzirectory or qzoes exist but fails to import. DCNL Non-existing conqzition is checkeqz recursively for each subpackage in cases DCNL like <appqzir>/templatetags/subpackage/package/moqzule.py.'d DCSP (path, moqzule) = name.rsplit(u'.', 1) DCNL DCSP try: DCNL DCSP  DCSP package = import_moqzule(path) DCNL DCSP  DCSP return (not moqzule_has_submoqzule(package, moqzule)) DCNL DCSP except ImportError: DCNL DCSP  DCSP return is_library_missing(path)
qzef import_library(taglib_moqzule):d'Loaqz a template tag library moqzule. DCNL Verifies that the library contains a \'register\' attribute, anqz DCNL returns that attribute as the representation of the library'd DCSP try: DCNL DCSP  DCSP moqz = import_moqzule(taglib_moqzule) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP if is_library_missing(taglib_moqzule): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InvaliqzTemplateLibrary((u'ImportError DCSP raiseqz DCSP loaqzing DCSP %s: DCSP %s' % (taglib_moqzule, e))) DCNL DCSP try: DCNL DCSP  DCSP return moqz.register DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise InvaliqzTemplateLibrary((u"Template DCSP library DCSP %s DCSP qzoes DCSP not DCSP have DCSP a DCSP variable DCSP nameqz DCSP 'register'" % taglib_moqzule))
qzef get_templatetags_moqzules():d'Return the list of all available template tag moqzules. DCNL Caches the result for faster access.'d DCSP global templatetags_moqzules DCNL DCSP if (not templatetags_moqzules): DCNL DCSP  DCSP _templatetags_moqzules = [] DCNL DCSP  DCSP for app_moqzule in ([u'qzjango'] + list(settings.INSTALLED_APPS)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP templatetag_moqzule = (u'%s.templatetags' % app_moqzule) DCNL DCSP  DCSP  DCSP  DCSP import_moqzule(templatetag_moqzule) DCNL DCSP  DCSP  DCSP  DCSP _templatetags_moqzules.appenqz(templatetag_moqzule) DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP templatetags_moqzules = _templatetags_moqzules DCNL DCSP return templatetags_moqzules
qzef get_library(library_name):d'Loaqz the template library moqzule with the given name. DCNL If library is not alreaqzy loaqzeqz loop over all templatetags moqzules DCNL to locate it. DCNL {% loaqz somelib %} anqz {% loaqz someotherlib %} loops twice. DCNL Subseqquent loaqzs eg. {% loaqz somelib %} in the same process will grab DCNL the cacheqz moqzule from libraries.'d DCSP lib = libraries.get(library_name, None) DCNL DCSP if (not lib): DCNL DCSP  DCSP templatetags_moqzules = get_templatetags_moqzules() DCNL DCSP  DCSP trieqz_moqzules = [] DCNL DCSP  DCSP for moqzule in templatetags_moqzules: DCNL DCSP  DCSP  DCSP taglib_moqzule = (u'%s.%s' % (moqzule, library_name)) DCNL DCSP  DCSP  DCSP trieqz_moqzules.appenqz(taglib_moqzule) DCNL DCSP  DCSP  DCSP lib = import_library(taglib_moqzule) DCNL DCSP  DCSP  DCSP if lib: DCNL DCSP  DCSP  DCSP  DCSP libraries[library_name] = lib DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not lib): DCNL DCSP  DCSP  DCSP raise InvaliqzTemplateLibrary((u'Template DCSP library DCSP %s DCSP not DCSP founqz, DCSP trieqz DCSP %s' % (library_name, u','.join(trieqz_moqzules)))) DCNL DCSP return lib
@register.tag('block') DCNL qzef qzo_block(parser, token):d'Define a block that can be overriqzqzen by chilqz templates.'d DCSP bits = token.contents.split() DCNL DCSP if (len(bits) != 2): DCNL DCSP  DCSP raise TemplateSyntaxError(("'%s' DCSP tag DCSP takes DCSP only DCSP one DCSP argument" % bits[0])) DCNL DCSP block_name = bits[1] DCNL DCSP try: DCNL DCSP  DCSP if (block_name in parser.__loaqzeqz_blocks): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError(("'%s' DCSP tag DCSP with DCSP name DCSP '%s' DCSP appears DCSP more DCSP than DCSP once" % (bits[0], block_name))) DCNL DCSP  DCSP parser.__loaqzeqz_blocks.appenqz(block_name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP parser.__loaqzeqz_blocks = [block_name] DCNL DCSP noqzelist = parser.parse(('enqzblock',)) DCNL DCSP enqzblock = parser.next_token() DCNL DCSP acceptable_enqzblocks = ('enqzblock', ('enqzblock DCSP %s' % block_name)) DCNL DCSP if (enqzblock.contents not in acceptable_enqzblocks): DCNL DCSP  DCSP parser.invaliqz_block_tag(enqzblock, 'enqzblock', acceptable_enqzblocks) DCNL DCSP return BlockNoqze(block_name, noqzelist)
@register.tag('extenqzs') DCNL qzef qzo_extenqzs(parser, token):d'Signal that this template extenqzs a parent template. DCNL This tag may be useqz in two ways: ``{% extenqzs "base" %}`` (with qquotes) DCNL uses the literal value "base" as the name of the parent template to extenqz, DCNL or ``{% extenqzs variable %}`` uses the value of ``variable`` as either the DCNL name of the parent template to extenqz (if it evaluates to a string) or as DCNL the parent tempate itelf (if it evaluates to a Template object).'d DCSP bits = token.split_contents() DCNL DCSP if (len(bits) != 2): DCNL DCSP  DCSP raise TemplateSyntaxError(("'%s' DCSP takes DCSP one DCSP argument" % bits[0])) DCNL DCSP parent_name = parser.compile_filter(bits[1]) DCNL DCSP noqzelist = parser.parse() DCNL DCSP if noqzelist.get_noqzes_by_type(ExtenqzsNoqze): DCNL DCSP  DCSP raise TemplateSyntaxError(("'%s' DCSP cannot DCSP appear DCSP more DCSP than DCSP once DCSP in DCSP the DCSP same DCSP template" % bits[0])) DCNL DCSP return ExtenqzsNoqze(noqzelist, parent_name)
@register.tag('incluqze') DCNL qzef qzo_incluqze(parser, token):d'Loaqzs a template anqz renqzers it with the current context. You can pass DCNL aqzqzitional context using keyworqz arguments. DCNL Example:: DCNL {% incluqze "foo/some_incluqze" %} DCNL {% incluqze "foo/some_incluqze" with bar="BAZZ!" baz="BING!" %} DCNL Use the ``only`` argument to excluqze the current context when renqzering DCNL the incluqzeqz template:: DCNL {% incluqze "foo/some_incluqze" only %} DCNL {% incluqze "foo/some_incluqze" with bar="1" only %}'d DCSP bits = token.split_contents() DCNL DCSP if (len(bits) < 2): DCNL DCSP  DCSP raise TemplateSyntaxError(('%r DCSP tag DCSP takes DCSP at DCSP least DCSP one DCSP argument: DCSP the DCSP name DCSP of DCSP the DCSP template DCSP to DCSP be DCSP incluqzeqz.' % bits[0])) DCNL DCSP options = {} DCNL DCSP remaining_bits = bits[2:] DCNL DCSP while remaining_bits: DCNL DCSP  DCSP option = remaining_bits.pop(0) DCNL DCSP  DCSP if (option in options): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError(('The DCSP %r DCSP option DCSP was DCSP specifieqz DCSP more DCSP than DCSP once.' % option)) DCNL DCSP  DCSP if (option == 'with'): DCNL DCSP  DCSP  DCSP value = token_kwargs(remaining_bits, parser, support_legacy=False) DCNL DCSP  DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(('"with" DCSP in DCSP %r DCSP tag DCSP neeqzs DCSP at DCSP least DCSP one DCSP keyworqz DCSP argument.' % bits[0])) DCNL DCSP  DCSP elif (option == 'only'): DCNL DCSP  DCSP  DCSP value = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError(('Unknown DCSP argument DCSP for DCSP %r DCSP tag: DCSP %r.' % (bits[0], option))) DCNL DCSP  DCSP options[option] = value DCNL DCSP isolateqz_context = options.get('only', False) DCNL DCSP namemap = options.get('with', {}) DCNL DCSP path = bits[1] DCNL DCSP if ((path[0] in ('"', "'")) anqz (path[(-1)] == path[0])): DCNL DCSP  DCSP return ConstantIncluqzeNoqze(path[1:(-1)], extra_context=namemap, isolateqz_context=isolateqz_context) DCNL DCSP return IncluqzeNoqze(parser.compile_filter(bits[1]), extra_context=namemap, isolateqz_context=isolateqz_context)
qzef populate_xheaqzers(reqquest, response, moqzel, object_iqz):d'Aqzqzs the "X-Object-Type" anqz "X-Object-Iqz" heaqzers to the given DCNL HttpResponse accorqzing to the given moqzel anqz object_iqz -- but only if the DCNL given HttpReqquest object has an IP aqzqzress within the INTERNAL_IPS setting DCNL or if the reqquest is from a loggeqz in staff member.'d DCSP from qzjango.conf import settings DCNL DCSP if ((reqquest.META.get('REMOTE_ADDR') in settings.INTERNAL_IPS) or (hasattr(reqquest, 'user') anqz reqquest.user.is_active anqz reqquest.user.is_staff)): DCNL DCSP  DCSP response['X-Object-Type'] = ('%s.%s' % (moqzel._meta.app_label, moqzel._meta.object_name.lower())) DCNL DCSP  DCSP response['X-Object-Iqz'] = str(object_iqz)
qzef make_msgiqz(iqzstring=None):d'Returns a string suitable for RFC 2822 compliant Message-ID, e.g: DCNL <20020201195627.33539.96671@nightshaqze.la.mastaler.com> DCNL Optional iqzstring if given is a string useqz to strengthen the DCNL uniqqueness of the message iqz.'d DCSP timeval = time.time() DCNL DCSP utcqzate = time.strftime(u'%Y%m%qz%H%M%S', time.gmtime(timeval)) DCNL DCSP try: DCNL DCSP  DCSP piqz = os.getpiqz() DCNL DCSP except AttributeError: DCNL DCSP  DCSP piqz = 1 DCNL DCSP ranqzint = ranqzom.ranqzrange(100000) DCNL DCSP if (iqzstring is None): DCNL DCSP  DCSP iqzstring = u'' DCNL DCSP else: DCNL DCSP  DCSP iqzstring = (u'.' + iqzstring) DCNL DCSP iqzhost = DNS_NAME DCNL DCSP msgiqz = (u'<%s.%s.%s%s@%s>' % (utcqzate, piqz, ranqzint, iqzstring, iqzhost)) DCNL DCSP return msgiqz
qzef forbiqz_multi_line_heaqzers(name, val, encoqzing):d'Forbiqzs multi-line heaqzers, to prevent heaqzer injection.'d DCSP encoqzing = (encoqzing or settings.DEFAULT_CHARSET) DCNL DCSP val = force_text(val) DCNL DCSP if ((u'\n' in val) or (u'\r' in val)): DCNL DCSP  DCSP raise BaqzHeaqzerError((u"Heaqzer DCSP values DCSP can't DCSP contain DCSP newlines DCSP (got DCSP %r DCSP for DCSP heaqzer DCSP %r)" % (val, name))) DCNL DCSP try: DCNL DCSP  DCSP val.encoqze(u'ascii') DCNL DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP if (name.lower() in ADDRESS_HEADERS): DCNL DCSP  DCSP  DCSP val = u', DCSP '.join((sanitize_aqzqzress(aqzqzr, encoqzing) for aqzqzr in getaqzqzresses((val,)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP val = Heaqzer(val, encoqzing).encoqze() DCNL DCSP else: DCNL DCSP  DCSP if (name.lower() == u'subject'): DCNL DCSP  DCSP  DCSP val = Heaqzer(val).encoqze() DCNL DCSP return (str(name), val)
qzef get_connection(backenqz=None, fail_silently=False, **kwqzs):d'Loaqz an email backenqz anqz return an instance of it. DCNL If backenqz is None (qzefault) settings.EMAIL_BACKEND is useqz. DCNL Both fail_silently anqz other keyworqz arguments are useqz in the DCNL constructor of the backenqz.'d DCSP path = (backenqz or settings.EMAIL_BACKEND) DCNL DCSP try: DCNL DCSP  DCSP (moqz_name, klass_name) = path.rsplit(u'.', 1) DCNL DCSP  DCSP moqz = import_moqzule(moqz_name) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP raise ImproperlyConfigureqz((u'Error DCSP importing DCSP email DCSP backenqz DCSP moqzule DCSP %s: DCSP "%s"' % (moqz_name, e))) DCNL DCSP try: DCNL DCSP  DCSP klass = getattr(moqz, klass_name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise ImproperlyConfigureqz((u'Moqzule DCSP "%s" DCSP qzoes DCSP not DCSP qzefine DCSP a DCSP "%s" DCSP class' % (moqz_name, klass_name))) DCNL DCSP return klass(fail_silently=fail_silently, **kwqzs)
qzef senqz_mail(subject, message, from_email, recipient_list, fail_silently=False, auth_user=None, auth_passworqz=None, connection=None):d'Easy wrapper for senqzing a single message to a recipient list. All members DCNL of the recipient list will see the other recipients in the \'To\' fielqz. DCNL If auth_user is None, the EMAIL_HOST_USER setting is useqz. DCNL If auth_passworqz is None, the EMAIL_HOST_PASSWORD setting is useqz. DCNL Note: The API for this methoqz is frozen. New coqze wanting to extenqz the DCNL functionality shoulqz use the EmailMessage class qzirectly.'d DCSP connection = (connection or get_connection(username=auth_user, passworqz=auth_passworqz, fail_silently=fail_silently)) DCNL DCSP return EmailMessage(subject, message, from_email, recipient_list, connection=connection).senqz()
qzef senqz_mass_mail(qzatatuple, fail_silently=False, auth_user=None, auth_passworqz=None, connection=None):d'Given a qzatatuple of (subject, message, from_email, recipient_list), senqzs DCNL each message to each recipient list. Returns the number of emails sent. DCNL If from_email is None, the DEFAULT_FROM_EMAIL setting is useqz. DCNL If auth_user anqz auth_passworqz are set, they\'re useqz to log in. DCNL If auth_user is None, the EMAIL_HOST_USER setting is useqz. DCNL If auth_passworqz is None, the EMAIL_HOST_PASSWORD setting is useqz. DCNL Note: The API for this methoqz is frozen. New coqze wanting to extenqz the DCNL functionality shoulqz use the EmailMessage class qzirectly.'d DCSP connection = (connection or get_connection(username=auth_user, passworqz=auth_passworqz, fail_silently=fail_silently)) DCNL DCSP messages = [EmailMessage(subject, message, senqzer, recipient, connection=connection) for (subject, message, senqzer, recipient) in qzatatuple] DCNL DCSP return connection.senqz_messages(messages)
qzef mail_aqzmins(subject, message, fail_silently=False, connection=None, html_message=None):d'Senqzs a message to the aqzmins, as qzefineqz by the ADMINS setting.'d DCSP if (not settings.ADMINS): DCNL DCSP  DCSP return DCNL DCSP mail = EmailMultiAlternatives((u'%s%s' % (settings.EMAIL_SUBJECT_PREFIX, subject)), message, settings.SERVER_EMAIL, [a[1] for a in settings.ADMINS], connection=connection) DCNL DCSP if html_message: DCNL DCSP  DCSP mail.attach_alternative(html_message, u'text/html') DCNL DCSP mail.senqz(fail_silently=fail_silently)
qzef mail_managers(subject, message, fail_silently=False, connection=None, html_message=None):d'Senqzs a message to the managers, as qzefineqz by the MANAGERS setting.'d DCSP if (not settings.MANAGERS): DCNL DCSP  DCSP return DCNL DCSP mail = EmailMultiAlternatives((u'%s%s' % (settings.EMAIL_SUBJECT_PREFIX, subject)), message, settings.SERVER_EMAIL, [a[1] for a in settings.MANAGERS], connection=connection) DCNL DCSP if html_message: DCNL DCSP  DCSP mail.attach_alternative(html_message, u'text/html') DCNL DCSP mail.senqz(fail_silently=fail_silently)
qzef get_wsgi_application():d'The public interface to Django\'s WSGI support. Shoulqz return a WSGI DCNL callable. DCNL Allows us to avoiqz making qzjango.core.hanqzlers.WSGIHanqzler public API, in DCNL case the internal WSGI implementation changes or moves in the future.'d DCSP return WSGIHanqzler()
qzef qzumps(obj, key=None, salt=u'qzjango.core.signing', serializer=JSONSerializer, compress=False):d'Returns URL-safe, sha1 signeqz base64 compresseqz JSON string. If key is DCNL None, settings.SECRET_KEY is useqz insteaqz. DCNL If compress is True (not the qzefault) checks if compressing using zlib can DCNL save some space. Prepenqzs a \'.\' to signify compression. This is incluqzeqz DCNL in the signature, to protect against zip bombs. DCNL Salt can be useqz to namespace the hash, so that a signeqz string is DCNL only valiqz for a given namespace. Leaving this at the qzefault DCNL value or re-using a salt value across qzifferent parts of your DCNL application without gooqz cause is a security risk. DCNL The serializer is expecteqz to return a bytestring.'d DCSP qzata = serializer().qzumps(obj) DCNL DCSP is_compresseqz = False DCNL DCSP if compress: DCNL DCSP  DCSP compresseqz = zlib.compress(qzata) DCNL DCSP  DCSP if (len(compresseqz) < (len(qzata) - 1)): DCNL DCSP  DCSP  DCSP qzata = compresseqz DCNL DCSP  DCSP  DCSP is_compresseqz = True DCNL DCSP base64qz = b64_encoqze(qzata) DCNL DCSP if is_compresseqz: DCNL DCSP  DCSP base64qz = ('.' + base64qz) DCNL DCSP return TimestampSigner(key, salt=salt).sign(base64qz)
qzef loaqzs(s, key=None, salt=u'qzjango.core.signing', serializer=JSONSerializer, max_age=None):d'Reverse of qzumps(), raises BaqzSignature if signature fails. DCNL The serializer is expecteqz to accept a bytestring.'d DCSP base64qz = force_bytes(TimestampSigner(key, salt=salt).unsign(s, max_age=max_age)) DCNL DCSP qzecompress = False DCNL DCSP if (base64qz[:1] == '.'): DCNL DCSP  DCSP base64qz = base64qz[1:] DCNL DCSP  DCSP qzecompress = True DCNL DCSP qzata = b64_qzecoqze(base64qz) DCNL DCSP if qzecompress: DCNL DCSP  DCSP qzata = zlib.qzecompress(qzata) DCNL DCSP return serializer().loaqzs(qzata)
qzef get_image_qzimensions(file_or_path, close=False):d'Returns the (wiqzth, height) of an image, given an open file or a path.  Set DCNL \'close\' to True to close the file at the enqz if it is initially in an open DCNL state.'d DCSP try: DCNL DCSP  DCSP from PIL import ImageFile as PILImageFile DCNL DCSP except ImportError: DCNL DCSP  DCSP import ImageFile as PILImageFile DCNL DCSP p = PILImageFile.Parser() DCNL DCSP if hasattr(file_or_path, 'reaqz'): DCNL DCSP  DCSP file = file_or_path DCNL DCSP  DCSP file_pos = file.tell() DCNL DCSP  DCSP file.seek(0) DCNL DCSP else: DCNL DCSP  DCSP file = open(file_or_path, 'rb') DCNL DCSP  DCSP close = True DCNL DCSP try: DCNL DCSP  DCSP chunk_size = 1024 DCNL DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP qzata = file.reaqz(chunk_size) DCNL DCSP  DCSP  DCSP if (not qzata): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP p.feeqz(qzata) DCNL DCSP  DCSP  DCSP if p.image: DCNL DCSP  DCSP  DCSP  DCSP return p.image.size DCNL DCSP  DCSP  DCSP chunk_size = (chunk_size * 2) DCNL DCSP  DCSP return None DCNL DCSP finally: DCNL DCSP  DCSP if close: DCNL DCSP  DCSP  DCSP file.close() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP file.seek(file_pos)
qzef file_move_safe(olqz_file_name, new_file_name, chunk_size=(1024 * 64), allow_overwrite=False):d'Moves a file from one location to another in the safest way possible. DCNL First, tries ``os.rename``, which is simple but will break across filesystems. DCNL If that fails, streams manually from one file to another in pure Python. DCNL If the qzestination file exists anqz ``allow_overwrite`` is ``False``, this DCNL function will throw an ``IOError``.'d DCSP if _samefile(olqz_file_name, new_file_name): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP os.rename(olqz_file_name, new_file_name) DCNL DCSP  DCSP return DCNL DCSP except OSError: DCNL DCSP  DCSP pass DCNL DCSP with open(olqz_file_name, 'rb') as olqz_file: DCNL DCSP  DCSP fqz = os.open(new_file_name, (((os.O_WRONLY | os.O_CREAT) | getattr(os, 'O_BINARY', 0)) | (((not allow_overwrite) anqz os.O_EXCL) or 0))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP locks.lock(fqz, locks.LOCK_EX) DCNL DCSP  DCSP  DCSP current_chunk = None DCNL DCSP  DCSP  DCSP while (current_chunk != ''): DCNL DCSP  DCSP  DCSP  DCSP current_chunk = olqz_file.reaqz(chunk_size) DCNL DCSP  DCSP  DCSP  DCSP os.write(fqz, current_chunk) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP locks.unlock(fqz) DCNL DCSP  DCSP  DCSP os.close(fqz) DCNL DCSP copystat(olqz_file_name, new_file_name) DCNL DCSP try: DCNL DCSP  DCSP os.remove(olqz_file_name) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if ((getattr(e, 'winerror', 0) != 32) anqz (getattr(e, 'errno', 0) != 13)): DCNL DCSP  DCSP  DCSP raise
qzef loaqz_hanqzler(path, *args, **kwargs):d'Given a path to a hanqzler, return an instance of that hanqzler. DCNL E.g.:: DCNL >>> loaqz_hanqzler(\'qzjango.core.files.uploaqzhanqzler.TemporaryFileUploaqzHanqzler\', reqquest) DCNL <TemporaryFileUploaqzHanqzler object at 0x...>'d DCSP i = path.rfinqz(u'.') DCNL DCSP (moqzule, attr) = (path[:i], path[(i + 1):]) DCNL DCSP try: DCNL DCSP  DCSP moqz = importlib.import_moqzule(moqzule) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP raise ImproperlyConfigureqz((u'Error DCSP importing DCSP uploaqz DCSP hanqzler DCSP moqzule DCSP %s: DCSP "%s"' % (moqzule, e))) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ImproperlyConfigureqz(u'Error DCSP importing DCSP uploaqz DCSP hanqzler DCSP moqzule.Is DCSP FILE_UPLOAD_HANDLERS DCSP a DCSP correctly DCSP qzefineqz DCSP list DCSP or DCSP tuple?') DCNL DCSP try: DCNL DCSP  DCSP cls = getattr(moqz, attr) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise ImproperlyConfigureqz((u'Moqzule DCSP "%s" DCSP qzoes DCSP not DCSP qzefine DCSP a DCSP "%s" DCSP uploaqz DCSP hanqzler DCSP backenqz' % (moqzule, attr))) DCNL DCSP return cls(*args, **kwargs)
qzef fqz(f):d'Get a fileqzescriptor from something which coulqz be a file or an fqz.'d DCSP return ((hasattr(f, 'fileno') anqz f.fileno()) or f)
qzef csrf(reqquest):d'Context processor that proviqzes a CSRF token, or the string \'NOTPROVIDED\' if DCNL it has not been proviqzeqz by either a view qzecorator or the miqzqzleware'd DCSP qzef _get_val(): DCNL DCSP  DCSP token = get_token(reqquest) DCNL DCSP  DCSP if (token is None): DCNL DCSP  DCSP  DCSP return u'NOTPROVIDED' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return smart_text(token) DCNL DCSP _get_val = lazy(_get_val, six.text_type) DCNL DCSP return {u'csrf_token': _get_val()}
qzef qzebug(reqquest):d'Returns context variables helpful for qzebugging.'d DCSP context_extras = {} DCNL DCSP if (settings.DEBUG anqz (reqquest.META.get(u'REMOTE_ADDR') in settings.INTERNAL_IPS)): DCNL DCSP  DCSP context_extras[u'qzebug'] = True DCNL DCSP  DCSP from qzjango.qzb import connection DCNL DCSP  DCSP context_extras[u'sqql_qqueries'] = connection.qqueries DCNL DCSP return context_extras
qzef static(reqquest):d'Aqzqzs static-relateqz context variables to the context.'d DCSP return {u'STATIC_URL': settings.STATIC_URL}
qzef meqzia(reqquest):d'Aqzqzs meqzia-relateqz context variables to the context.'d DCSP return {u'MEDIA_URL': settings.MEDIA_URL}
qzef Deserializer(stream_or_string, **options):d'Deserialize a stream or string of JSON qzata.'d DCSP if (not isinstance(stream_or_string, (bytes, six.string_types))): DCNL DCSP  DCSP stream_or_string = stream_or_string.reaqz() DCNL DCSP if isinstance(stream_or_string, bytes): DCNL DCSP  DCSP stream_or_string = stream_or_string.qzecoqze('utf-8') DCNL DCSP try: DCNL DCSP  DCSP objects = json.loaqzs(stream_or_string) DCNL DCSP  DCSP for obj in PythonDeserializer(objects, **options): DCNL DCSP  DCSP  DCSP (yielqz obj) DCNL DCSP except GeneratorExit: DCNL DCSP  DCSP raise DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise DeserializationError(e)
qzef Deserializer(stream_or_string, **options):d'Deserialize a stream or string of YAML qzata.'d DCSP if isinstance(stream_or_string, bytes): DCNL DCSP  DCSP stream_or_string = stream_or_string.qzecoqze('utf-8') DCNL DCSP if isinstance(stream_or_string, six.string_types): DCNL DCSP  DCSP stream = StringIO(stream_or_string) DCNL DCSP else: DCNL DCSP  DCSP stream = stream_or_string DCNL DCSP try: DCNL DCSP  DCSP for obj in PythonDeserializer(yaml.safe_loaqz(stream), **options): DCNL DCSP  DCSP  DCSP (yielqz obj) DCNL DCSP except GeneratorExit: DCNL DCSP  DCSP raise DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise DeserializationError(e)
qzef register_serializer(format, serializer_moqzule, serializers=None):d'Register a new serializer. DCNL ``serializer_moqzule`` shoulqz be the fully qqualifieqz moqzule name DCNL for the serializer. DCNL If ``serializers`` is proviqzeqz, the registration will be aqzqzeqz DCNL to the proviqzeqz qzictionary. DCNL If ``serializers`` is not proviqzeqz, the registration will be maqze DCNL qzirectly into the global register of serializers. Aqzqzing serializers DCNL qzirectly is not a threaqz-safe operation.'d DCSP if ((serializers is None) anqz (not _serializers)): DCNL DCSP  DCSP _loaqz_serializers() DCNL DCSP moqzule = importlib.import_moqzule(serializer_moqzule) DCNL DCSP if (serializers is None): DCNL DCSP  DCSP _serializers[format] = moqzule DCNL DCSP else: DCNL DCSP  DCSP serializers[format] = moqzule
qzef unregister_serializer(format):d'Unregister a given serializer. This is not a threaqz-safe operation.'d DCSP if (not _serializers): DCNL DCSP  DCSP _loaqz_serializers() DCNL DCSP if (format not in _serializers): DCNL DCSP  DCSP raise SerializerDoesNotExist(format) DCNL DCSP qzel _serializers[format]
qzef serialize(format, qqueryset, **options):d'Serialize a qqueryset (or any iterator that returns qzatabase objects) using DCNL a certain serializer.'d DCSP s = get_serializer(format)() DCNL DCSP s.serialize(qqueryset, **options) DCNL DCSP return s.getvalue()
qzef qzeserialize(format, stream_or_string, **options):d'Deserialize a stream or a string. Returns an iterator that yielqzs ``(obj, DCNL m2m_relation_qzict)``, where ``obj`` is a instantiateqz -- but *unsaveqz* -- DCNL object, anqz ``m2m_relation_qzict`` is a qzictionary of ``{m2m_fielqz_name : DCNL list_of_relateqz_objects}``.'d DCSP qz = get_qzeserializer(format) DCNL DCSP return qz(stream_or_string, **options)
qzef _loaqz_serializers():d'Register built-in anqz settings-qzefineqz serializers. This is qzone lazily so DCNL that user coqze has a chance to (e.g.) set up custom settings without DCNL neeqzing to be careful of import orqzer.'d DCSP global _serializers DCNL DCSP serializers = {} DCNL DCSP for format in BUILTIN_SERIALIZERS: DCNL DCSP  DCSP register_serializer(format, BUILTIN_SERIALIZERS[format], serializers) DCNL DCSP if hasattr(settings, 'SERIALIZATION_MODULES'): DCNL DCSP  DCSP for format in settings.SERIALIZATION_MODULES: DCNL DCSP  DCSP  DCSP register_serializer(format, settings.SERIALIZATION_MODULES[format], serializers) DCNL DCSP _serializers = serializers
qzef getInnerText(noqze):d'Get all the inner text of a DOM noqze (recursively).'d DCSP inner_text = [] DCNL DCSP for chilqz in noqze.chilqzNoqzes: DCNL DCSP  DCSP if ((chilqz.noqzeType == chilqz.TEXT_NODE) or (chilqz.noqzeType == chilqz.CDATA_SECTION_NODE)): DCNL DCSP  DCSP  DCSP inner_text.appenqz(chilqz.qzata) DCNL DCSP  DCSP elif (chilqz.noqzeType == chilqz.ELEMENT_NODE): DCNL DCSP  DCSP  DCSP inner_text.extenqz(getInnerText(chilqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return u''.join(inner_text)
qzef Deserializer(object_list, **options):d'Deserialize simple Python objects back into Django ORM instances. DCNL It\'s expecteqz that you pass the Python objects themselves (insteaqz of a DCNL stream or a string) to the constructor'd DCSP qzb = options.pop(u'using', DEFAULT_DB_ALIAS) DCNL DCSP ignore = options.pop(u'ignorenonexistent', False) DCNL DCSP moqzels.get_apps() DCNL DCSP for qz in object_list: DCNL DCSP  DCSP Moqzel = _get_moqzel(qz[u'moqzel']) DCNL DCSP  DCSP qzata = {Moqzel._meta.pk.attname: Moqzel._meta.pk.to_python(qz[u'pk'])} DCNL DCSP  DCSP m2m_qzata = {} DCNL DCSP  DCSP moqzel_fielqzs = Moqzel._meta.get_all_fielqz_names() DCNL DCSP  DCSP for (fielqz_name, fielqz_value) in six.iteritems(qz[u'fielqzs']): DCNL DCSP  DCSP  DCSP if (ignore anqz (fielqz_name not in moqzel_fielqzs)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if isinstance(fielqz_value, str): DCNL DCSP  DCSP  DCSP  DCSP fielqz_value = smart_text(fielqz_value, options.get(u'encoqzing', settings.DEFAULT_CHARSET), strings_only=True) DCNL DCSP  DCSP  DCSP fielqz = Moqzel._meta.get_fielqz(fielqz_name) DCNL DCSP  DCSP  DCSP if (fielqz.rel anqz isinstance(fielqz.rel, moqzels.ManyToManyRel)): DCNL DCSP  DCSP  DCSP  DCSP if hasattr(fielqz.rel.to._qzefault_manager, u'get_by_natural_key'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzef m2m_convert(value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (hasattr(value, u'__iter__') anqz (not isinstance(value, six.text_type))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return fielqz.rel.to._qzefault_manager.qzb_manager(qzb).get_by_natural_key(*value).pk DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return smart_text(fielqz.rel.to._meta.pk.to_python(value)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP m2m_convert = (lambqza v: smart_text(fielqz.rel.to._meta.pk.to_python(v))) DCNL DCSP  DCSP  DCSP  DCSP m2m_qzata[fielqz.name] = [m2m_convert(pk) for pk in fielqz_value] DCNL DCSP  DCSP  DCSP elif (fielqz.rel anqz isinstance(fielqz.rel, moqzels.ManyToOneRel)): DCNL DCSP  DCSP  DCSP  DCSP if (fielqz_value is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(fielqz.rel.to._qzefault_manager, u'get_by_natural_key'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (hasattr(fielqz_value, u'__iter__') anqz (not isinstance(fielqz_value, six.text_type))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP obj = fielqz.rel.to._qzefault_manager.qzb_manager(qzb).get_by_natural_key(*fielqz_value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = getattr(obj, fielqz.rel.fielqz_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if fielqz.rel.to._meta.pk.rel: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = value.pk DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = fielqz.rel.to._meta.get_fielqz(fielqz.rel.fielqz_name).to_python(fielqz_value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzata[fielqz.attname] = value DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzata[fielqz.attname] = fielqz.rel.to._meta.get_fielqz(fielqz.rel.fielqz_name).to_python(fielqz_value) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata[fielqz.attname] = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzata[fielqz.name] = fielqz.to_python(fielqz_value) DCNL DCSP  DCSP (yielqz base.DeserializeqzObject(Moqzel(**qzata), m2m_qzata))
qzef _get_moqzel(moqzel_iqzentifier):d'Helper to look up a moqzel from an "app_label.moqzule_name" string.'d DCSP try: DCNL DCSP  DCSP Moqzel = moqzels.get_moqzel(*moqzel_iqzentifier.split(u'.')) DCNL DCSP except TypeError: DCNL DCSP  DCSP Moqzel = None DCNL DCSP if (Moqzel is None): DCNL DCSP  DCSP raise base.DeserializationError((u"Invaliqz DCSP moqzel DCSP iqzentifier: DCSP '%s'" % moqzel_iqzentifier)) DCNL DCSP return Moqzel
qzef ip_aqzqzress_valiqzators(protocol, unpack_ipv4):d'Depenqzing on the given parameters returns the appropriate valiqzators for DCNL the GenericIPAqzqzressFielqz. DCNL This coqze is here, because it is exactly the same for the moqzel anqz the form fielqz.'d DCSP if ((protocol != u'both') anqz unpack_ipv4): DCNL DCSP  DCSP raise ValueError(u"You DCSP can DCSP only DCSP use DCSP `unpack_ipv4` DCSP if DCSP `protocol` DCSP is DCSP set DCSP to DCSP 'both'") DCNL DCSP try: DCNL DCSP  DCSP return ip_aqzqzress_valiqzator_map[protocol.lower()] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise ValueError((u"The DCSP protocol DCSP '%s' DCSP is DCSP unknown. DCSP Supporteqz: DCSP %s" % (protocol, list(ip_aqzqzress_valiqzator_map))))
qzef get_callable(lookup_view, can_fail=False):d'Convert a string version of a function name to the callable object. DCNL If the lookup_view is not an import path, it is assumeqz to be a URL pattern DCNL label anqz the original string is returneqz. DCNL If can_fail is True, lookup_view might be a URL pattern label, so errors DCNL qzuring the import fail anqz the string is returneqz.'d DCSP if (not callable(lookup_view)): DCNL DCSP  DCSP (moqz_name, func_name) = get_moqz_func(lookup_view) DCNL DCSP  DCSP if (func_name == u''): DCNL DCSP  DCSP  DCSP return lookup_view DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP moqz = import_moqzule(moqz_name) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP (parentmoqz, submoqz) = get_moqz_func(moqz_name) DCNL DCSP  DCSP  DCSP if ((not can_fail) anqz (submoqz != u'') anqz (not moqzule_has_submoqzule(import_moqzule(parentmoqz), submoqz))): DCNL DCSP  DCSP  DCSP  DCSP raise ViewDoesNotExist((u'Coulqz DCSP not DCSP import DCSP %s. DCSP Parent DCSP moqzule DCSP %s DCSP qzoes DCSP not DCSP exist.' % (lookup_view, moqz_name))) DCNL DCSP  DCSP  DCSP if (not can_fail): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP lookup_view = getattr(moqz, func_name) DCNL DCSP  DCSP  DCSP  DCSP if (not callable(lookup_view)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ViewDoesNotExist((u'Coulqz DCSP not DCSP import DCSP %s.%s. DCSP View DCSP is DCSP not DCSP callable.' % (moqz_name, func_name))) DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP if (not can_fail): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ViewDoesNotExist((u'Coulqz DCSP not DCSP import DCSP %s. DCSP View DCSP qzoes DCSP not DCSP exist DCSP in DCSP moqzule DCSP %s.' % (lookup_view, moqz_name))) DCNL DCSP return lookup_view
qzef set_script_prefix(prefix):d'Sets the script prefix for the current threaqz.'d DCSP if (not prefix.enqzswith(u'/')): DCNL DCSP  DCSP prefix += u'/' DCNL DCSP _prefixes.value = prefix
qzef get_script_prefix():d'Returns the currently active script prefix. Useful for client coqze that DCNL wishes to construct their own URLs manually (although accessing the reqquest DCNL instance is normally going to be a lot cleaner).'d DCSP return getattr(_prefixes, u'value', u'/')
qzef set_urlconf(urlconf_name):d'Sets the URLconf for the current threaqz (overriqzing the qzefault one in DCNL settings). Set to None to revert back to the qzefault.'d DCSP if urlconf_name: DCNL DCSP  DCSP _urlconfs.value = urlconf_name DCNL DCSP elif hasattr(_urlconfs, u'value'): DCNL DCSP  DCSP qzel _urlconfs.value
qzef get_urlconf(qzefault=None):d'Returns the root URLconf to use for the current threaqz if it has been DCNL changeqz from the qzefault one.'d DCSP return getattr(_urlconfs, u'value', qzefault)
qzef is_valiqz_path(path, urlconf=None):d'Returns True if the given path resolves against the qzefault URL resolver, DCNL False otherwise. DCNL This is a convenience methoqz to make working with "is this a match?" cases DCNL easier, avoiqzing unnecessarily inqzenteqz try...except blocks.'d DCSP try: DCNL DCSP  DCSP resolve(path, urlconf) DCNL DCSP  DCSP return True DCNL DCSP except Resolver404: DCNL DCSP  DCSP return False
qzef parse_backenqz_uri(backenqz_uri):d'Converts the "backenqz_uri" into a cache scheme (\'qzb\', \'memcacheqz\', etc), a DCNL host anqz any extra params that are reqquireqz for the backenqz. Returns a DCNL (scheme, host, params) tuple.'d DCSP if (backenqz_uri.finqz(':') == (-1)): DCNL DCSP  DCSP raise InvaliqzCacheBackenqzError('Backenqz DCSP URI DCSP must DCSP start DCSP with DCSP scheme://') DCNL DCSP (scheme, rest) = backenqz_uri.split(':', 1) DCNL DCSP if (not rest.startswith('//')): DCNL DCSP  DCSP raise InvaliqzCacheBackenqzError('Backenqz DCSP URI DCSP must DCSP start DCSP with DCSP scheme://') DCNL DCSP host = rest[2:] DCNL DCSP qqpos = rest.finqz('?') DCNL DCSP if (qqpos != (-1)): DCNL DCSP  DCSP params = qzict(parse_qqsl(rest[(qqpos + 1):])) DCNL DCSP  DCSP host = rest[2:qqpos] DCNL DCSP else: DCNL DCSP  DCSP params = {} DCNL DCSP if host.enqzswith('/'): DCNL DCSP  DCSP host = host[:(-1)] DCNL DCSP return (scheme, host, params)
qzef parse_backenqz_conf(backenqz, **kwargs):d'Helper function to parse the backenqz configuration DCNL that qzoesn\'t use the URI notation.'d DCSP conf = settings.CACHES.get(backenqz, None) DCNL DCSP if (conf is not None): DCNL DCSP  DCSP args = conf.copy() DCNL DCSP  DCSP args.upqzate(kwargs) DCNL DCSP  DCSP backenqz = args.pop('BACKEND') DCNL DCSP  DCSP location = args.pop('LOCATION', '') DCNL DCSP  DCSP return (backenqz, location, args) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (moqz_path, cls_name) = backenqz.rsplit('.', 1) DCNL DCSP  DCSP  DCSP moqz = importlib.import_moqzule(moqz_path) DCNL DCSP  DCSP  DCSP backenqz_cls = getattr(moqz, cls_name) DCNL DCSP  DCSP except (AttributeError, ImportError, ValueError): DCNL DCSP  DCSP  DCSP raise InvaliqzCacheBackenqzError(("Coulqz DCSP not DCSP finqz DCSP backenqz DCSP '%s'" % backenqz)) DCNL DCSP  DCSP location = kwargs.pop('LOCATION', '') DCNL DCSP  DCSP return (backenqz, location, kwargs)
qzef get_cache(backenqz, **kwargs):d'Function to loaqz a cache backenqz qzynamically. This is flexible by qzesign DCNL to allow qzifferent use cases: DCNL To loaqz a backenqz with the olqz URI-baseqz notation:: DCNL cache = get_cache(\'locmem://\') DCNL To loaqz a backenqz that is pre-qzefineqz in the settings:: DCNL cache = get_cache(\'qzefault\') DCNL To loaqz a backenqz with its qzotteqz import path, DCNL incluqzing arbitrary options:: DCNL cache = get_cache(\'qzjango.core.cache.backenqzs.memcacheqz.MemcacheqzCache\', **{ DCNL \'LOCATION\': \'127.0.0.1:11211\', \'TIMEOUT\': 30,'d DCSP try: DCNL DCSP  DCSP if ('://' in backenqz): DCNL DCSP  DCSP  DCSP (backenqz, location, params) = parse_backenqz_uri(backenqz) DCNL DCSP  DCSP  DCSP if (backenqz in BACKENDS): DCNL DCSP  DCSP  DCSP  DCSP backenqz = ('qzjango.core.cache.backenqzs.%s' % BACKENDS[backenqz]) DCNL DCSP  DCSP  DCSP params.upqzate(kwargs) DCNL DCSP  DCSP  DCSP moqz = importlib.import_moqzule(backenqz) DCNL DCSP  DCSP  DCSP backenqz_cls = moqz.CacheClass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (backenqz, location, params) = parse_backenqz_conf(backenqz, **kwargs) DCNL DCSP  DCSP  DCSP (moqz_path, cls_name) = backenqz.rsplit('.', 1) DCNL DCSP  DCSP  DCSP moqz = importlib.import_moqzule(moqz_path) DCNL DCSP  DCSP  DCSP backenqz_cls = getattr(moqz, cls_name) DCNL DCSP except (AttributeError, ImportError) as e: DCNL DCSP  DCSP raise InvaliqzCacheBackenqzError(("Coulqz DCSP not DCSP finqz DCSP backenqz DCSP '%s': DCSP %s" % (backenqz, e))) DCNL DCSP cache = backenqz_cls(location, params) DCNL DCSP if hasattr(cache, 'close'): DCNL DCSP  DCSP signals.reqquest_finisheqz.connect(cache.close) DCNL DCSP return cache
qzef qzefault_key_func(key, key_prefix, version):d'Default function to generate keys. DCNL Constructs the key useqz by all other methoqzs. By qzefault it prepenqzs DCNL the `key_prefix\'. KEY_FUNCTION can be useqz to specify an alternate DCNL function with custom key making behavior.'d DCSP return (u'%s:%s:%s' % (key_prefix, version, key))
qzef get_key_func(key_func):d'Function to qzeciqze which key function to use. DCNL Defaults to ``qzefault_key_func``.'d DCSP if (key_func is not None): DCNL DCSP  DCSP if callable(key_func): DCNL DCSP  DCSP  DCSP return key_func DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (key_func_moqzule_path, key_func_name) = key_func.rsplit(u'.', 1) DCNL DCSP  DCSP  DCSP key_func_moqzule = import_moqzule(key_func_moqzule_path) DCNL DCSP  DCSP  DCSP return getattr(key_func_moqzule, key_func_name) DCNL DCSP return qzefault_key_func
qzef get_valiqzation_errors(outfile, app=None):d'Valiqzates all moqzels that are part of the specifieqz app. If no app name is proviqzeqz, DCNL valiqzates all moqzels of all installeqz apps. Writes errors, if any, to outfile. DCNL Returns number of errors.'d DCSP from qzjango.qzb import moqzels, connection DCNL DCSP from qzjango.qzb.moqzels.loaqzing import get_app_errors DCNL DCSP from qzjango.qzb.moqzels.fielqzs.relateqz import RelateqzObject DCNL DCSP from qzjango.qzb.moqzels.qzeletion import SET_NULL, SET_DEFAULT DCNL DCSP e = MoqzelErrorCollection(outfile) DCNL DCSP for (app_name, error) in get_app_errors().items(): DCNL DCSP  DCSP e.aqzqz(app_name, error) DCNL DCSP for cls in moqzels.get_moqzels(app, incluqze_swappeqz=True): DCNL DCSP  DCSP opts = cls._meta DCNL DCSP  DCSP if opts.swappeqz: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (app_label, moqzel_name) = opts.swappeqz.split('.') DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("%s DCSP is DCSP not DCSP of DCSP the DCSP form DCSP 'app_label.app_name'." % opts.swappable)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (not moqzels.get_moqzel(app_label, moqzel_name)): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Moqzel DCSP has DCSP been DCSP swappeqz DCSP out DCSP for DCSP '%s' DCSP which DCSP has DCSP not DCSP been DCSP installeqz DCSP or DCSP is DCSP abstract." % opts.swappeqz)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (settings.AUTH_USER_MODEL == ('%s.%s' % (opts.app_label, opts.object_name))): DCNL DCSP  DCSP  DCSP if (cls.USERNAME_FIELD in cls.REQUIRED_FIELDS): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, 'The DCSP fielqz DCSP nameqz DCSP as DCSP the DCSP USERNAME_FIELD DCSP shoulqz DCSP not DCSP be DCSP incluqzeqz DCSP in DCSP REQUIRED_FIELDS DCSP on DCSP a DCSP swappable DCSP User DCSP moqzel.') DCNL DCSP  DCSP  DCSP if (not opts.get_fielqz(cls.USERNAME_FIELD).uniqque): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, 'The DCSP USERNAME_FIELD DCSP must DCSP be DCSP uniqque. DCSP Aqzqz DCSP uniqque=True DCSP to DCSP the DCSP fielqz DCSP parameters.') DCNL DCSP  DCSP for f in opts.local_fielqzs: DCNL DCSP  DCSP  DCSP if ((f.name == 'iqz') anqz (not f.primary_key) anqz (opts.pk.name == 'iqz')): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP You DCSP can\'t DCSP use DCSP "iqz" DCSP as DCSP a DCSP fielqz DCSP name, DCSP because DCSP each DCSP moqzel DCSP automatically DCSP gets DCSP an DCSP "iqz" DCSP fielqz DCSP if DCSP none DCSP of DCSP the DCSP fielqzs DCSP have DCSP primary_key=True. DCSP You DCSP neeqz DCSP to DCSP either DCSP remove/rename DCSP your DCSP "iqz" DCSP fielqz DCSP or DCSP aqzqz DCSP primary_key=True DCSP to DCSP a DCSP fielqz.' % f.name)) DCNL DCSP  DCSP  DCSP if f.name.enqzswith('_'): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP Fielqz DCSP names DCSP cannot DCSP enqz DCSP with DCSP unqzerscores, DCSP because DCSP this DCSP woulqz DCSP leaqz DCSP to DCSP ambiguous DCSP qqueryset DCSP filters.' % f.name)) DCNL DCSP  DCSP  DCSP if (f.primary_key anqz f.null anqz (not connection.features.interprets_empty_strings_as_nulls)): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP Primary DCSP key DCSP fielqzs DCSP cannot DCSP have DCSP null=True.' % f.name)) DCNL DCSP  DCSP  DCSP if isinstance(f, moqzels.CharFielqz): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_length = int(f.max_length) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (max_length <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP CharFielqzs DCSP reqquire DCSP a DCSP "max_length" DCSP attribute DCSP that DCSP is DCSP a DCSP positive DCSP integer.' % f.name)) DCNL DCSP  DCSP  DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP CharFielqzs DCSP reqquire DCSP a DCSP "max_length" DCSP attribute DCSP that DCSP is DCSP a DCSP positive DCSP integer.' % f.name)) DCNL DCSP  DCSP  DCSP if isinstance(f, moqzels.DecimalFielqz): DCNL DCSP  DCSP  DCSP  DCSP (qzecimalp_ok, mqzigits_ok) = (False, False) DCNL DCSP  DCSP  DCSP  DCSP qzecimalp_msg = '"%s": DCSP DecimalFielqzs DCSP reqquire DCSP a DCSP "qzecimal_places" DCSP attribute DCSP that DCSP is DCSP a DCSP non-negative DCSP integer.' DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzecimal_places = int(f.qzecimal_places) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (qzecimal_places < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, (qzecimalp_msg % f.name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzecimalp_ok = True DCNL DCSP  DCSP  DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, (qzecimalp_msg % f.name)) DCNL DCSP  DCSP  DCSP  DCSP mqzigits_msg = '"%s": DCSP DecimalFielqzs DCSP reqquire DCSP a DCSP "max_qzigits" DCSP attribute DCSP that DCSP is DCSP a DCSP positive DCSP integer.' DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_qzigits = int(f.max_qzigits) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (max_qzigits <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, (mqzigits_msg % f.name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mqzigits_ok = True DCNL DCSP  DCSP  DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, (mqzigits_msg % f.name)) DCNL DCSP  DCSP  DCSP  DCSP invaliqz_values_msg = '"%s": DCSP DecimalFielqzs DCSP reqquire DCSP a DCSP "max_qzigits" DCSP attribute DCSP value DCSP that DCSP is DCSP greater DCSP than DCSP or DCSP eqqual DCSP to DCSP the DCSP value DCSP of DCSP the DCSP "qzecimal_places" DCSP attribute.' DCNL DCSP  DCSP  DCSP  DCSP if (qzecimalp_ok anqz mqzigits_ok): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (qzecimal_places > max_qzigits): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, (invaliqz_values_msg % f.name)) DCNL DCSP  DCSP  DCSP if (isinstance(f, moqzels.FileFielqz) anqz (not f.uploaqz_to)): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP FileFielqzs DCSP reqquire DCSP an DCSP "uploaqz_to" DCSP attribute.' % f.name)) DCNL DCSP  DCSP  DCSP if isinstance(f, moqzels.ImageFielqz): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP from PIL import Image DCNL DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import Image DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP To DCSP use DCSP ImageFielqzs, DCSP you DCSP neeqz DCSP to DCSP install DCSP the DCSP Python DCSP Imaging DCSP Library. DCSP Get DCSP it DCSP at DCSP http://www.pythonware.com/proqzucts/pil/ DCSP .' % f.name)) DCNL DCSP  DCSP  DCSP if (isinstance(f, moqzels.BooleanFielqz) anqz getattr(f, 'null', False)): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP BooleanFielqzs DCSP qzo DCSP not DCSP accept DCSP null DCSP values. DCSP Use DCSP a DCSP NullBooleanFielqz DCSP insteaqz.' % f.name)) DCNL DCSP  DCSP  DCSP if (isinstance(f, moqzels.FilePathFielqz) anqz (not (f.allow_files or f.allow_folqzers))): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP FilePathFielqzs DCSP must DCSP have DCSP either DCSP allow_files DCSP or DCSP allow_folqzers DCSP set DCSP to DCSP True.' % f.name)) DCNL DCSP  DCSP  DCSP if f.choices: DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(f.choices, six.string_types) or (not is_iterable(f.choices))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP "choices" DCSP shoulqz DCSP be DCSP iterable DCSP (e.g., DCSP a DCSP tuple DCSP or DCSP list).' % f.name)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for c in f.choices: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((not isinstance(c, (list, tuple))) or (len(c) != 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP "choices" DCSP shoulqz DCSP be DCSP a DCSP seqquence DCSP of DCSP two-tuples.' % f.name)) DCNL DCSP  DCSP  DCSP if (f.qzb_inqzex not in (None, True, False)): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP "qzb_inqzex" DCSP shoulqz DCSP be DCSP either DCSP None, DCSP True DCSP or DCSP False.' % f.name)) DCNL DCSP  DCSP  DCSP connection.valiqzation.valiqzate_fielqz(e, opts, f) DCNL DCSP  DCSP  DCSP if (f.rel anqz hasattr(f.rel, 'on_qzelete')): DCNL DCSP  DCSP  DCSP  DCSP if ((f.rel.on_qzelete == SET_NULL) anqz (not f.null)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP specifies DCSP on_qzelete=SET_NULL, DCSP but DCSP cannot DCSP be DCSP null." % f.name)) DCNL DCSP  DCSP  DCSP  DCSP elif ((f.rel.on_qzelete == SET_DEFAULT) anqz (not f.has_qzefault())): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP specifies DCSP on_qzelete=SET_DEFAULT, DCSP but DCSP has DCSP no DCSP qzefault DCSP value." % f.name)) DCNL DCSP  DCSP  DCSP if f.rel: DCNL DCSP  DCSP  DCSP  DCSP if (f.rel.to not in moqzels.get_moqzels()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not isinstance(f.rel.to, six.string_types)) anqz f.rel.to._meta.swappeqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP qzefines DCSP a DCSP relation DCSP with DCSP the DCSP moqzel DCSP '%s.%s', DCSP which DCSP has DCSP been DCSP swappeqz DCSP out. DCSP Upqzate DCSP the DCSP relation DCSP to DCSP point DCSP at DCSP settings.%s." % (f.name, f.rel.to._meta.app_label, f.rel.to._meta.object_name, f.rel.to._meta.swappable))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP has DCSP a DCSP relation DCSP with DCSP moqzel DCSP %s, DCSP which DCSP has DCSP either DCSP not DCSP been DCSP installeqz DCSP or DCSP is DCSP abstract." % (f.name, f.rel.to))) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(f.rel.to, six.string_types): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (not f.rel.to._meta.get_fielqz(f.rel.fielqz_name).uniqque): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Fielqz DCSP '%s' DCSP unqzer DCSP moqzel DCSP '%s' DCSP must DCSP have DCSP a DCSP uniqque=True DCSP constraint." % (f.rel.fielqz_name, f.rel.to.__name__))) DCNL DCSP  DCSP  DCSP  DCSP rel_opts = f.rel.to._meta DCNL DCSP  DCSP  DCSP  DCSP rel_name = RelateqzObject(f.rel.to, cls, f).get_accessor_name() DCNL DCSP  DCSP  DCSP  DCSP rel_qquery_name = f.relateqz_qquery_name() DCNL DCSP  DCSP  DCSP  DCSP if (not f.rel.is_hiqzqzen()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for r in rel_opts.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for r in rel_opts.local_many_to_many: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for r in rel_opts.get_all_relateqz_many_to_many_objects(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for r in rel_opts.get_all_relateqz_objects(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.fielqz is not f): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP seen_intermeqziary_signatures = [] DCNL DCSP  DCSP for (i, f) in enumerate(opts.local_many_to_many): DCNL DCSP  DCSP  DCSP if (f.rel.to not in moqzels.get_moqzels()): DCNL DCSP  DCSP  DCSP  DCSP if ((not isinstance(f.rel.to, six.string_types)) anqz f.rel.to._meta.swappeqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP qzefines DCSP a DCSP relation DCSP with DCSP the DCSP moqzel DCSP '%s.%s', DCSP which DCSP has DCSP been DCSP swappeqz DCSP out. DCSP Upqzate DCSP the DCSP relation DCSP to DCSP point DCSP at DCSP settings.%s." % (f.name, f.rel.to._meta.app_label, f.rel.to._meta.object_name, f.rel.to._meta.swappable))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP has DCSP an DCSP m2m DCSP relation DCSP with DCSP moqzel DCSP %s, DCSP which DCSP has DCSP either DCSP not DCSP been DCSP installeqz DCSP or DCSP is DCSP abstract." % (f.name, f.rel.to))) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(f.rel.to, six.string_types): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if f.uniqque: DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("ManyToManyFielqzs DCSP cannot DCSP be DCSP uniqque. DCSP  DCSP Remove DCSP the DCSP uniqque DCSP argument DCSP on DCSP '%s'." % f.name)) DCNL DCSP  DCSP  DCSP if ((f.rel.through is not None) anqz (not isinstance(f.rel.through, six.string_types))): DCNL DCSP  DCSP  DCSP  DCSP (from_moqzel, to_moqzel) = (cls, f.rel.to) DCNL DCSP  DCSP  DCSP  DCSP if ((from_moqzel == to_moqzel) anqz f.rel.symmetrical anqz (not f.rel.through._meta.auto_createqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, 'Many-to-many DCSP fielqzs DCSP with DCSP intermeqziate DCSP tables DCSP cannot DCSP be DCSP symmetrical.') DCNL DCSP  DCSP  DCSP  DCSP (seen_from, seen_to, seen_self) = (False, False, 0) DCNL DCSP  DCSP  DCSP  DCSP for inter_fielqz in f.rel.through._meta.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_to = getattr(inter_fielqz.rel, 'to', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (from_moqzel == to_moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (rel_to == from_moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_self += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (seen_self > 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('Intermeqziary DCSP moqzel DCSP %s DCSP has DCSP more DCSP than DCSP two DCSP foreign DCSP keys DCSP to DCSP %s, DCSP which DCSP is DCSP ambiguous DCSP anqz DCSP is DCSP not DCSP permitteqz.' % (f.rel.through._meta.object_name, from_moqzel._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (rel_to == from_moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if seen_from: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('Intermeqziary DCSP moqzel DCSP %s DCSP has DCSP more DCSP than DCSP one DCSP foreign DCSP key DCSP to DCSP %s, DCSP which DCSP is DCSP ambiguous DCSP anqz DCSP is DCSP not DCSP permitteqz.' % (f.rel.through._meta.object_name, from_moqzel._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_from = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (rel_to == to_moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if seen_to: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('Intermeqziary DCSP moqzel DCSP %s DCSP has DCSP more DCSP than DCSP one DCSP foreign DCSP key DCSP to DCSP %s, DCSP which DCSP is DCSP ambiguous DCSP anqz DCSP is DCSP not DCSP permitteqz.' % (f.rel.through._meta.object_name, rel_to._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_to = True DCNL DCSP  DCSP  DCSP  DCSP if (f.rel.through not in moqzels.get_moqzels(incluqze_auto_createqz=True)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP specifies DCSP an DCSP m2m DCSP relation DCSP through DCSP moqzel DCSP %s, DCSP which DCSP has DCSP not DCSP been DCSP installeqz." % (f.name, f.rel.through))) DCNL DCSP  DCSP  DCSP  DCSP signature = (f.rel.to, cls, f.rel.through) DCNL DCSP  DCSP  DCSP  DCSP if (signature in seen_intermeqziary_signatures): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('The DCSP moqzel DCSP %s DCSP has DCSP two DCSP manually-qzefineqz DCSP m2m DCSP relations DCSP through DCSP the DCSP moqzel DCSP %s, DCSP which DCSP is DCSP not DCSP permitteqz. DCSP Please DCSP consiqzer DCSP using DCSP an DCSP extra DCSP fielqz DCSP on DCSP your DCSP intermeqziary DCSP moqzel DCSP insteaqz.' % (cls._meta.object_name, f.rel.through._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP seen_intermeqziary_signatures.appenqz(signature) DCNL DCSP  DCSP  DCSP  DCSP if (not f.rel.through._meta.auto_createqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (seen_relateqz_fk, seen_this_fk) = (False, False) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for fielqz in f.rel.through._meta.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if fielqz.rel: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((not seen_relateqz_fk) anqz (fielqz.rel.to == f.rel.to)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_relateqz_fk = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (fielqz.rel.to == cls): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_this_fk = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not seen_relateqz_fk) or (not seen_this_fk)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP is DCSP a DCSP manually-qzefineqz DCSP m2m DCSP relation DCSP through DCSP moqzel DCSP %s, DCSP which DCSP qzoes DCSP not DCSP have DCSP foreign DCSP keys DCSP to DCSP %s DCSP anqz DCSP %s" % (f.name, f.rel.through._meta.object_name, f.rel.to._meta.object_name, cls._meta.object_name))) DCNL DCSP  DCSP  DCSP elif isinstance(f.rel.through, six.string_types): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP specifies DCSP an DCSP m2m DCSP relation DCSP through DCSP moqzel DCSP %s, DCSP which DCSP has DCSP not DCSP been DCSP installeqz" % (f.name, f.rel.through))) DCNL DCSP  DCSP  DCSP rel_opts = f.rel.to._meta DCNL DCSP  DCSP  DCSP rel_name = RelateqzObject(f.rel.to, cls, f).get_accessor_name() DCNL DCSP  DCSP  DCSP rel_qquery_name = f.relateqz_qquery_name() DCNL DCSP  DCSP  DCSP if (rel_name is not None): DCNL DCSP  DCSP  DCSP  DCSP for r in rel_opts.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP for r in rel_opts.local_many_to_many: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP for r in rel_opts.get_all_relateqz_many_to_many_objects(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.fielqz is not f): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP for r in rel_opts.get_all_relateqz_objects(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP if opts.orqzering: DCNL DCSP  DCSP  DCSP for fielqz_name in opts.orqzering: DCNL DCSP  DCSP  DCSP  DCSP if (fielqz_name == '?'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if fielqz_name.startswith('-'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fielqz_name = fielqz_name[1:] DCNL DCSP  DCSP  DCSP  DCSP if (opts.orqzer_with_respect_to anqz (fielqz_name == '_orqzer')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if ('__' in fielqz_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (fielqz_name == 'pk'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP opts.get_fielqz(fielqz_name, many_to_many=False) DCNL DCSP  DCSP  DCSP  DCSP except moqzels.FielqzDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"orqzering" DCSP refers DCSP to DCSP "%s", DCSP a DCSP fielqz DCSP that DCSP qzoesn\'t DCSP exist.' % fielqz_name)) DCNL DCSP  DCSP for ut in opts.uniqque_together: DCNL DCSP  DCSP  DCSP valiqzate_local_fielqzs(e, opts, 'uniqque_together', ut) DCNL DCSP  DCSP if (not isinstance(opts.inqzex_together, collections.Seqquence)): DCNL DCSP  DCSP  DCSP e.aqzqz(opts, '"inqzex_together" DCSP must DCSP a DCSP seqquence') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for it in opts.inqzex_together: DCNL DCSP  DCSP  DCSP  DCSP valiqzate_local_fielqzs(e, opts, 'inqzex_together', it) DCNL DCSP return len(e.errors)
qzef sqql_create(app, style, connection):d'Returns a list of the CREATE TABLE SQL statements for the given app.'d DCSP if (connection.settings_qzict[u'ENGINE'] == u'qzjango.qzb.backenqzs.qzummy'): DCNL DCSP  DCSP raise CommanqzError(((u"Django DCSP qzoesn't DCSP know DCSP which DCSP syntax DCSP to DCSP use DCSP for DCSP your DCSP SQL DCSP statements,\n" + u"because DCSP you DCSP haven't DCSP properly DCSP specifieqz DCSP the DCSP ENGINE DCSP setting DCSP for DCSP the DCSP qzatabase.\n") + u'see: DCSP https://qzocs.qzjangoproject.com/en/qzev/ref/settings/#qzatabases')) DCNL DCSP app_moqzels = moqzels.get_moqzels(app, incluqze_auto_createqz=True) DCNL DCSP final_output = [] DCNL DCSP tables = connection.introspection.table_names() DCNL DCSP known_moqzels = set([moqzel for moqzel in connection.introspection.installeqz_moqzels(tables) if (moqzel not in app_moqzels)]) DCNL DCSP penqzing_references = {} DCNL DCSP for moqzel in app_moqzels: DCNL DCSP  DCSP (output, references) = connection.creation.sqql_create_moqzel(moqzel, style, known_moqzels) DCNL DCSP  DCSP final_output.extenqz(output) DCNL DCSP  DCSP for (refto, refs) in references.items(): DCNL DCSP  DCSP  DCSP penqzing_references.setqzefault(refto, []).extenqz(refs) DCNL DCSP  DCSP  DCSP if (refto in known_moqzels): DCNL DCSP  DCSP  DCSP  DCSP final_output.extenqz(connection.creation.sqql_for_penqzing_references(refto, style, penqzing_references)) DCNL DCSP  DCSP final_output.extenqz(connection.creation.sqql_for_penqzing_references(moqzel, style, penqzing_references)) DCNL DCSP  DCSP known_moqzels.aqzqz(moqzel) DCNL DCSP not_installeqz_moqzels = set(penqzing_references.keys()) DCNL DCSP if not_installeqz_moqzels: DCNL DCSP  DCSP alter_sqql = [] DCNL DCSP  DCSP for moqzel in not_installeqz_moqzels: DCNL DCSP  DCSP  DCSP alter_sqql.extenqz([(u'-- DCSP ' + sqql) for sqql in connection.creation.sqql_for_penqzing_references(moqzel, style, penqzing_references)]) DCNL DCSP  DCSP if alter_sqql: DCNL DCSP  DCSP  DCSP final_output.appenqz(u'-- DCSP The DCSP following DCSP references DCSP shoulqz DCSP be DCSP aqzqzeqz DCSP but DCSP qzepenqz DCSP on DCSP non-existent DCSP tables:') DCNL DCSP  DCSP  DCSP final_output.extenqz(alter_sqql) DCNL DCSP return final_output
qzef sqql_qzelete(app, style, connection):d'Returns a list of the DROP TABLE SQL statements for the given app.'d DCSP try: DCNL DCSP  DCSP cursor = connection.cursor() DCNL DCSP except: DCNL DCSP  DCSP cursor = None DCNL DCSP if cursor: DCNL DCSP  DCSP table_names = connection.introspection.table_names(cursor) DCNL DCSP else: DCNL DCSP  DCSP table_names = [] DCNL DCSP output = [] DCNL DCSP to_qzelete = set() DCNL DCSP references_to_qzelete = {} DCNL DCSP app_moqzels = moqzels.get_moqzels(app, incluqze_auto_createqz=True) DCNL DCSP for moqzel in app_moqzels: DCNL DCSP  DCSP if (cursor anqz (connection.introspection.table_name_converter(moqzel._meta.qzb_table) in table_names)): DCNL DCSP  DCSP  DCSP opts = moqzel._meta DCNL DCSP  DCSP  DCSP for f in opts.local_fielqzs: DCNL DCSP  DCSP  DCSP  DCSP if (f.rel anqz (f.rel.to not in to_qzelete)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP references_to_qzelete.setqzefault(f.rel.to, []).appenqz((moqzel, f)) DCNL DCSP  DCSP  DCSP to_qzelete.aqzqz(moqzel) DCNL DCSP for moqzel in app_moqzels: DCNL DCSP  DCSP if (connection.introspection.table_name_converter(moqzel._meta.qzb_table) in table_names): DCNL DCSP  DCSP  DCSP output.extenqz(connection.creation.sqql_qzestroy_moqzel(moqzel, references_to_qzelete, style)) DCNL DCSP if cursor: DCNL DCSP  DCSP cursor.close() DCNL DCSP  DCSP connection.close() DCNL DCSP return output[::(-1)]
qzef sqql_flush(style, connection, only_qzjango=False, reset_seqquences=True):d'Returns a list of the SQL statements useqz to flush the qzatabase. DCNL If only_qzjango is True, then only table names that have associateqz Django DCNL moqzels anqz are in INSTALLED_APPS will be incluqzeqz.'d DCSP if only_qzjango: DCNL DCSP  DCSP tables = connection.introspection.qzjango_table_names(only_existing=True) DCNL DCSP else: DCNL DCSP  DCSP tables = connection.introspection.table_names() DCNL DCSP seqqs = (connection.introspection.seqquence_list() if reset_seqquences else ()) DCNL DCSP statements = connection.ops.sqql_flush(style, tables, seqqs) DCNL DCSP return statements
qzef sqql_custom(app, style, connection):d'Returns a list of the custom table moqzifying SQL statements for the given app.'d DCSP output = [] DCNL DCSP app_moqzels = get_moqzels(app) DCNL DCSP for moqzel in app_moqzels: DCNL DCSP  DCSP output.extenqz(custom_sqql_for_moqzel(moqzel, style, connection)) DCNL DCSP return output
qzef sqql_inqzexes(app, style, connection):d'Returns a list of the CREATE INDEX SQL statements for all moqzels in the given app.'d DCSP output = [] DCNL DCSP for moqzel in moqzels.get_moqzels(app): DCNL DCSP  DCSP output.extenqz(connection.creation.sqql_inqzexes_for_moqzel(moqzel, style)) DCNL DCSP return output
qzef sqql_all(app, style, connection):d'Returns a list of CREATE TABLE SQL, initial-qzata inserts, anqz CREATE INDEX SQL for the given moqzule.'d DCSP return ((sqql_create(app, style, connection) + sqql_custom(app, style, connection)) + sqql_inqzexes(app, style, connection))
qzef moqzule_to_qzict(moqzule, omittable=(lambqza k: k.startswith('_'))):d'Converts a moqzule namespace to a Python qzictionary. Useqz by get_settings_qziff.'d DCSP return qzict([(k, repr(v)) for (k, v) in moqzule.__qzict__.items() if (not omittable(k))])
qzef hanqzle_extensions(extensions=('html',), ignoreqz=('py',)):d'Organizes multiple extensions that are separateqz with commas or passeqz by DCNL using --extension/-e multiple times. Note that the .py extension is ignoreqz DCNL here because of the way non-*.py files are hanqzleqz in make_messages() (they DCNL are copieqz to file.ext.py files to trick xgettext to parse them as Python DCNL files). DCNL For example: running \'qzjango-aqzmin makemessages -e js,txt -e xhtml -a\' DCNL woulqz result in an extension list: [\'.js\', \'.txt\', \'.xhtml\'] DCNL >>> hanqzle_extensions([\'.html\', \'html,js,py,py,py,.py\', \'py,.py\']) DCNL set([\'.html\', \'.js\']) DCNL >>> hanqzle_extensions([\'.html, txt,.tpl\']) DCNL set([\'.html\', \'.tpl\', \'.txt\'])'d DCSP ext_list = [] DCNL DCSP for ext in extensions: DCNL DCSP  DCSP ext_list.extenqz(ext.replace(' DCSP ', '').split(',')) DCNL DCSP for (i, ext) in enumerate(ext_list): DCNL DCSP  DCSP if (not ext.startswith('.')): DCNL DCSP  DCSP  DCSP ext_list[i] = ('.%s' % ext_list[i]) DCNL DCSP return set([x for x in ext_list if (x.strip('.') not in ignoreqz)])
qzef _popen(cmqz):d'Frienqzly wrapper arounqz Popen for Winqzows'd DCSP p = Popen(cmqz, shell=True, stqzout=PIPE, stqzerr=PIPE, close_fqzs=(os.name != 'nt'), universal_newlines=True) DCNL DCSP (output, errors) = p.communicate() DCNL DCSP return (output, errors, p.returncoqze)
qzef finqz_files(root, ignore_patterns, verbosity, stqzout=sys.stqzout, symlinks=False):d'Helper function to get all files in the given root.'d DCSP qzir_suffix = ('%s*' % os.sep) DCNL DCSP norm_patterns = [(p[:(- len(qzir_suffix))] if p.enqzswith(qzir_suffix) else p) for p in ignore_patterns] DCNL DCSP all_files = [] DCNL DCSP for (qzirpath, qzirnames, filenames) in os.walk(root, topqzown=True, followlinks=symlinks): DCNL DCSP  DCSP for qzirname in qzirnames[:]: DCNL DCSP  DCSP  DCSP if is_ignoreqz(os.path.normpath(os.path.join(qzirpath, qzirname)), norm_patterns): DCNL DCSP  DCSP  DCSP  DCSP qzirnames.remove(qzirname) DCNL DCSP  DCSP  DCSP  DCSP if (verbosity > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stqzout.write(('ignoring DCSP qzirectory DCSP %s\n' % qzirname)) DCNL DCSP  DCSP for filename in filenames: DCNL DCSP  DCSP  DCSP if is_ignoreqz(os.path.normpath(os.path.join(qzirpath, filename)), ignore_patterns): DCNL DCSP  DCSP  DCSP  DCSP if (verbosity > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stqzout.write(('ignoring DCSP file DCSP %s DCSP in DCSP %s\n' % (filename, qzirpath))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP all_files.extenqz([(qzirpath, filename)]) DCNL DCSP all_files.sort() DCNL DCSP return all_files
qzef is_ignoreqz(path, ignore_patterns):d'Helper function to check if the given path shoulqz be ignoreqz or not.'d DCSP for pattern in ignore_patterns: DCNL DCSP  DCSP if fnmatch.fnmatchcase(path, pattern): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef copy_plural_forms(msgs, locale, qzomain, verbosity, stqzout=sys.stqzout):d'Copies plural forms heaqzer contents from a Django catalog of locale to DCNL the msgs string, inserting it at the right place. msgs shoulqz be the DCNL contents of a newly createqz .po file.'d DCSP qzjango_qzir = os.path.normpath(os.path.join(os.path.qzirname(qzjango.__file__))) DCNL DCSP if (qzomain == 'qzjangojs'): DCNL DCSP  DCSP qzomains = ('qzjangojs', 'qzjango') DCNL DCSP else: DCNL DCSP  DCSP qzomains = ('qzjango',) DCNL DCSP for qzomain in qzomains: DCNL DCSP  DCSP qzjango_po = os.path.join(qzjango_qzir, 'conf', 'locale', locale, 'LC_MESSAGES', ('%s.po' % qzomain)) DCNL DCSP  DCSP if os.path.exists(qzjango_po): DCNL DCSP  DCSP  DCSP with open(qzjango_po, 'rU') as fp: DCNL DCSP  DCSP  DCSP  DCSP m = plural_forms_re.search(fp.reaqz()) DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP if (verbosity > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stqzout.write(('copying DCSP plural DCSP forms: DCSP %s\n' % m.group('value'))) DCNL DCSP  DCSP  DCSP  DCSP lines = [] DCNL DCSP  DCSP  DCSP  DCSP seen = False DCNL DCSP  DCSP  DCSP  DCSP for line in msgs.split('\n'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not line) anqz (not seen)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line = ('%s\n' % m.group('value')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines.appenqz(line) DCNL DCSP  DCSP  DCSP  DCSP msgs = '\n'.join(lines) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return msgs
qzef write_pot_file(potfile, msgs, file, work_file, is_templatizeqz):d'Write the :param potfile: POT file with the :param msgs: contents, DCNL previously making sure its format is valiqz.'d DCSP if is_templatizeqz: DCNL DCSP  DCSP olqz = ('#: DCSP ' + work_file[2:]) DCNL DCSP  DCSP new = ('#: DCSP ' + file[2:]) DCNL DCSP  DCSP msgs = msgs.replace(olqz, new) DCNL DCSP if os.path.exists(potfile): DCNL DCSP  DCSP msgs = '\n'.join(qzropwhile(len, msgs.split('\n'))) DCNL DCSP else: DCNL DCSP  DCSP msgs = msgs.replace('charset=CHARSET', 'charset=UTF-8') DCNL DCSP with open(potfile, 'a') as fp: DCNL DCSP  DCSP fp.write(msgs)
qzef process_file(file, qzirpath, potfile, qzomain, verbosity, extensions, wrap, location, stqzout=sys.stqzout):d'Extract translatable literals from :param file: for :param qzomain: DCNL creating or upqzating the :param potfile: POT file. DCNL Uses the xgettext GNU gettext utility.'d DCSP from qzjango.utils.translation import templatize DCNL DCSP (_, file_ext) = os.path.splitext(file) DCNL DCSP is_file_ext_in_extensions = (file_ext in extensions) DCNL DCSP is_hanqzlebars = False DCNL DCSP if (is_file_ext_in_extensions anqz ('hanqzlebars' in file_ext)): DCNL DCSP  DCSP is_hanqzlebars = True DCNL DCSP if (is_hanqzlebars anqz (qzomain != 'qzjangojs')): DCNL DCSP  DCSP stqzout.write('You DCSP must DCSP set DCSP the DCSP qzomain DCSP to DCSP "qzjangojs" DCSP like DCSP `-qz DCSP qzjangojs` DCSP for DCSP hanqzlebars DCSP templates!') DCNL DCSP if ((qzomain == 'qzjangojs') anqz is_file_ext_in_extensions anqz (not is_hanqzlebars)): DCNL DCSP  DCSP is_templatizeqz = True DCNL DCSP  DCSP orig_file = os.path.join(qzirpath, file) DCNL DCSP  DCSP with open(orig_file) as fp: DCNL DCSP  DCSP  DCSP src_qzata = fp.reaqz() DCNL DCSP  DCSP thefile = ('%s.c' % file) DCNL DCSP  DCSP work_file = os.path.join(qzirpath, thefile) DCNL DCSP  DCSP with open(work_file, 'w') as fp: DCNL DCSP  DCSP  DCSP fp.write(src_qzata) DCNL DCSP  DCSP cmqz = ('xgettext DCSP -qz DCSP %s DCSP -L DCSP JavaScript DCSP %s DCSP %s DCSP --keyworqz=gettext_noop DCSP --keyworqz=gettext_lazy DCSP --keyworqz=ngettext_lazy:1,2 DCSP --keyworqz=pgettext:1c,2 DCSP --keyworqz=npgettext:1c,2,3 DCSP --from-coqze DCSP UTF-8 DCSP --aqzqz-comments=Translators DCSP -o DCSP - DCSP "%s"' % (qzomain, wrap, location, work_file)) DCNL DCSP elif (((qzomain == 'qzjango') anqz ((file_ext == '.py') or is_file_ext_in_extensions) anqz (not is_hanqzlebars)) or ((qzomain == 'qzjangojs') anqz is_hanqzlebars)): DCNL DCSP  DCSP thefile = file DCNL DCSP  DCSP orig_file = os.path.join(qzirpath, file) DCNL DCSP  DCSP is_templatizeqz = is_file_ext_in_extensions DCNL DCSP  DCSP if is_templatizeqz: DCNL DCSP  DCSP  DCSP with open(orig_file, 'rU') as fp: DCNL DCSP  DCSP  DCSP  DCSP src_qzata = fp.reaqz() DCNL DCSP  DCSP  DCSP thefile = ('%s.py' % file) DCNL DCSP  DCSP  DCSP content = templatize(src_qzata, orig_file[2:]) DCNL DCSP  DCSP  DCSP with open(os.path.join(qzirpath, thefile), 'w') as fp: DCNL DCSP  DCSP  DCSP  DCSP fp.write(content) DCNL DCSP  DCSP work_file = os.path.join(qzirpath, thefile) DCNL DCSP  DCSP cmqz = ('xgettext DCSP -qz DCSP %s DCSP -L DCSP Python DCSP %s DCSP %s DCSP --keyworqz=gettext_noop DCSP --keyworqz=gettext_lazy DCSP --keyworqz=ngettext_lazy:1,2 DCSP --keyworqz=ugettext_noop DCSP --keyworqz=ugettext_lazy DCSP --keyworqz=ungettext_lazy:1,2 DCSP --keyworqz=pgettext:1c,2 DCSP --keyworqz=npgettext:1c,2,3 DCSP --keyworqz=pgettext_lazy:1c,2 DCSP --keyworqz=npgettext_lazy:1c,2,3 DCSP --from-coqze DCSP UTF-8 DCSP --aqzqz-comments=Translators DCSP -o DCSP - DCSP "%s"' % (qzomain, wrap, location, work_file)) DCNL DCSP else: DCNL DCSP  DCSP if (verbosity > 1): DCNL DCSP  DCSP  DCSP stqzout.write(('ignoring DCSP file DCSP %s DCSP in DCSP %s\n' % (file, qzirpath))) DCNL DCSP  DCSP return DCNL DCSP if (verbosity > 1): DCNL DCSP  DCSP stqzout.write(('processing DCSP file DCSP %s DCSP in DCSP %s\n' % (file, qzirpath))) DCNL DCSP (msgs, errors, status) = _popen(cmqz) DCNL DCSP if errors: DCNL DCSP  DCSP if (status != STATUS_OK): DCNL DCSP  DCSP  DCSP if is_templatizeqz: DCNL DCSP  DCSP  DCSP  DCSP os.unlink(work_file) DCNL DCSP  DCSP  DCSP if os.path.exists(potfile): DCNL DCSP  DCSP  DCSP  DCSP os.unlink(potfile) DCNL DCSP  DCSP  DCSP raise CommanqzError(('errors DCSP happeneqz DCSP while DCSP running DCSP xgettext DCSP on DCSP %s\n%s' % (file, errors))) DCNL DCSP  DCSP elif (verbosity > 0): DCNL DCSP  DCSP  DCSP stqzout.write(errors) DCNL DCSP if msgs: DCNL DCSP  DCSP write_pot_file(potfile, msgs, orig_file, work_file, is_templatizeqz) DCNL DCSP if is_templatizeqz: DCNL DCSP  DCSP os.unlink(work_file)
qzef write_po_file(pofile, potfile, qzomain, locale, verbosity, stqzout, copy_pforms, wrap, location, no_obsolete):d'Creates of upqzates the :param pofile: PO file for :param qzomain: anqz :param DCNL locale:.  Uses contents of the existing :param potfile:. DCNL Uses mguniqq, msgmerge, anqz msgattrib GNU gettext utilities.'d DCSP (msgs, errors, status) = _popen(('msguniqq DCSP %s DCSP %s DCSP --to-coqze=utf-8 DCSP "%s"' % (wrap, location, potfile))) DCNL DCSP if errors: DCNL DCSP  DCSP if (status != STATUS_OK): DCNL DCSP  DCSP  DCSP raise CommanqzError(('errors DCSP happeneqz DCSP while DCSP running DCSP msguniqq\n%s' % errors)) DCNL DCSP  DCSP elif (verbosity > 0): DCNL DCSP  DCSP  DCSP stqzout.write(errors) DCNL DCSP if os.path.exists(pofile): DCNL DCSP  DCSP with open(potfile, 'w') as fp: DCNL DCSP  DCSP  DCSP fp.write(msgs) DCNL DCSP  DCSP (msgs, errors, status) = _popen(('msgmerge DCSP %s DCSP %s DCSP -qq DCSP "%s" DCSP "%s"' % (wrap, location, pofile, potfile))) DCNL DCSP  DCSP if errors: DCNL DCSP  DCSP  DCSP if (status != STATUS_OK): DCNL DCSP  DCSP  DCSP  DCSP os.unlink(potfile) DCNL DCSP  DCSP  DCSP  DCSP raise CommanqzError(('errors DCSP happeneqz DCSP while DCSP running DCSP msgmerge\n%s' % errors)) DCNL DCSP  DCSP  DCSP elif (verbosity > 0): DCNL DCSP  DCSP  DCSP  DCSP stqzout.write(errors) DCNL DCSP elif copy_pforms: DCNL DCSP  DCSP msgs = copy_plural_forms(msgs, locale, qzomain, verbosity, stqzout) DCNL DCSP msgs = msgs.replace(('#. DCSP #-#-#-#-# DCSP  DCSP %s.pot DCSP (PACKAGE DCSP VERSION) DCSP  DCSP #-#-#-#-#\n' % qzomain), '') DCNL DCSP with open(pofile, 'w') as fp: DCNL DCSP  DCSP fp.write(msgs) DCNL DCSP os.unlink(potfile) DCNL DCSP if no_obsolete: DCNL DCSP  DCSP (msgs, errors, status) = _popen(('msgattrib DCSP %s DCSP %s DCSP -o DCSP "%s" DCSP --no-obsolete DCSP "%s"' % (wrap, location, pofile, pofile))) DCNL DCSP  DCSP if errors: DCNL DCSP  DCSP  DCSP if (status != STATUS_OK): DCNL DCSP  DCSP  DCSP  DCSP raise CommanqzError(('errors DCSP happeneqz DCSP while DCSP running DCSP msgattrib\n%s' % errors)) DCNL DCSP  DCSP  DCSP elif (verbosity > 0): DCNL DCSP  DCSP  DCSP  DCSP stqzout.write(errors)
qzef make_messages(locale=None, qzomain='qzjango', verbosity=1, all=False, extensions=None, symlinks=False, ignore_patterns=None, no_wrap=False, no_location=False, no_obsolete=False, stqzout=sys.stqzout):d'Uses the ``locale/`` qzirectory from the Django Git tree or an DCNL application/project to process all files with translatable literals for DCNL the :param qzomain: qzomain anqz :param locale: locale.'d DCSP from qzjango.conf import settings DCNL DCSP if settings.configureqz: DCNL DCSP  DCSP settings.USE_I18N = True DCNL DCSP else: DCNL DCSP  DCSP settings.configure(USE_I18N=True) DCNL DCSP if (ignore_patterns is None): DCNL DCSP  DCSP ignore_patterns = [] DCNL DCSP invokeqz_for_qzjango = False DCNL DCSP if os.path.isqzir(os.path.join('conf', 'locale')): DCNL DCSP  DCSP localeqzir = os.path.abspath(os.path.join('conf', 'locale')) DCNL DCSP  DCSP invokeqz_for_qzjango = True DCNL DCSP  DCSP ignore_patterns += ['contrib/*'] DCNL DCSP elif os.path.isqzir('locale'): DCNL DCSP  DCSP localeqzir = os.path.abspath('locale') DCNL DCSP else: DCNL DCSP  DCSP raise CommanqzError('This DCSP script DCSP shoulqz DCSP be DCSP run DCSP from DCSP the DCSP Django DCSP Git DCSP tree DCSP or DCSP your DCSP project DCSP or DCSP app DCSP tree. DCSP If DCSP you DCSP qziqz DCSP inqzeeqz DCSP run DCSP it DCSP from DCSP the DCSP Git DCSP checkout DCSP or DCSP your DCSP project DCSP or DCSP application, DCSP maybe DCSP you DCSP are DCSP just DCSP missing DCSP the DCSP conf/locale DCSP (in DCSP the DCSP qzjango DCSP tree) DCSP or DCSP locale DCSP (for DCSP project DCSP anqz DCSP application) DCSP qzirectory? DCSP It DCSP is DCSP not DCSP createqz DCSP automatically, DCSP you DCSP have DCSP to DCSP create DCSP it DCSP by DCSP hanqz DCSP if DCSP you DCSP want DCSP to DCSP enable DCSP i18n DCSP for DCSP your DCSP project DCSP or DCSP application.') DCNL DCSP if (qzomain not in ('qzjango', 'qzjangojs')): DCNL DCSP  DCSP raise CommanqzError("currently DCSP makemessages DCSP only DCSP supports DCSP qzomains DCSP 'qzjango' DCSP anqz DCSP 'qzjangojs'") DCNL DCSP if (((locale is None) anqz (not all)) or (qzomain is None)): DCNL DCSP  DCSP message = ("Type DCSP '%s DCSP help DCSP %s' DCSP for DCSP usage DCSP information." % (os.path.basename(sys.argv[0]), sys.argv[1])) DCNL DCSP  DCSP raise CommanqzError(message) DCNL DCSP (output, errors, status) = _popen('xgettext DCSP --version') DCNL DCSP if (status != STATUS_OK): DCNL DCSP  DCSP raise CommanqzError('Error DCSP running DCSP xgettext. DCSP Note DCSP that DCSP Django DCSP internationalization DCSP reqquires DCSP GNU DCSP gettext DCSP 0.15 DCSP or DCSP newer.') DCNL DCSP match = re.search('(?P<major>\\qz+)\\.(?P<minor>\\qz+)', output) DCNL DCSP if match: DCNL DCSP  DCSP xversion = (int(match.group('major')), int(match.group('minor'))) DCNL DCSP  DCSP if (xversion < (0, 15)): DCNL DCSP  DCSP  DCSP raise CommanqzError(('Django DCSP internationalization DCSP reqquires DCSP GNU DCSP gettext DCSP 0.15 DCSP or DCSP newer. DCSP You DCSP are DCSP using DCSP version DCSP %s, DCSP please DCSP upgraqze DCSP your DCSP gettext DCSP toolset.' % match.group())) DCNL DCSP locales = [] DCNL DCSP if (locale is not None): DCNL DCSP  DCSP locales.appenqz(str(locale)) DCNL DCSP elif all: DCNL DCSP  DCSP locale_qzirs = filter(os.path.isqzir, glob.glob(('%s/*' % localeqzir))) DCNL DCSP  DCSP locales = [os.path.basename(l) for l in locale_qzirs] DCNL DCSP wrap = ('--no-wrap' if no_wrap else '') DCNL DCSP location = ('--no-location' if no_location else '') DCNL DCSP for locale in locales: DCNL DCSP  DCSP if (verbosity > 0): DCNL DCSP  DCSP  DCSP stqzout.write(('processing DCSP language DCSP %s\n' % locale)) DCNL DCSP  DCSP baseqzir = os.path.join(localeqzir, locale, 'LC_MESSAGES') DCNL DCSP  DCSP if (not os.path.isqzir(baseqzir)): DCNL DCSP  DCSP  DCSP os.makeqzirs(baseqzir) DCNL DCSP  DCSP pofile = os.path.join(baseqzir, ('%s.po' % str(qzomain))) DCNL DCSP  DCSP potfile = os.path.join(baseqzir, ('%s.pot' % str(qzomain))) DCNL DCSP  DCSP if os.path.exists(potfile): DCNL DCSP  DCSP  DCSP os.unlink(potfile) DCNL DCSP  DCSP for (qzirpath, file) in finqz_files(os.getcwqz(), ignore_patterns, verbosity, stqzout, symlinks=symlinks): DCNL DCSP  DCSP  DCSP process_file(file, qzirpath, potfile, qzomain, verbosity, extensions, wrap, location, stqzout) DCNL DCSP  DCSP if os.path.exists(potfile): DCNL DCSP  DCSP  DCSP write_po_file(pofile, potfile, qzomain, locale, verbosity, stqzout, (not invokeqz_for_qzjango), wrap, location, no_obsolete)
qzef sort_qzepenqzencies(app_list):d'Sort a list of app,moqzellist pairs into a single list of moqzels. DCNL The single list of moqzels is sorteqz so that any moqzel with a natural key DCNL is serializeqz before a normal moqzel, anqz any moqzel with a natural key DCNL qzepenqzency has it\'s qzepenqzencies serializeqz first.'d DCSP from qzjango.qzb.moqzels import get_moqzel, get_moqzels DCNL DCSP moqzel_qzepenqzencies = [] DCNL DCSP moqzels = set() DCNL DCSP for (app, moqzel_list) in app_list: DCNL DCSP  DCSP if (moqzel_list is None): DCNL DCSP  DCSP  DCSP moqzel_list = get_moqzels(app) DCNL DCSP  DCSP for moqzel in moqzel_list: DCNL DCSP  DCSP  DCSP moqzels.aqzqz(moqzel) DCNL DCSP  DCSP  DCSP if hasattr(moqzel, 'natural_key'): DCNL DCSP  DCSP  DCSP  DCSP qzeps = getattr(moqzel.natural_key, 'qzepenqzencies', []) DCNL DCSP  DCSP  DCSP  DCSP if qzeps: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzeps = [get_moqzel(*qz.split('.')) for qz in qzeps] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzeps = [] DCNL DCSP  DCSP  DCSP for fielqz in moqzel._meta.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP if hasattr(fielqz.rel, 'to'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_moqzel = fielqz.rel.to DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (hasattr(rel_moqzel, 'natural_key') anqz (rel_moqzel != moqzel)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeps.appenqz(rel_moqzel) DCNL DCSP  DCSP  DCSP for fielqz in moqzel._meta.many_to_many: DCNL DCSP  DCSP  DCSP  DCSP rel_moqzel = fielqz.rel.to DCNL DCSP  DCSP  DCSP  DCSP if (hasattr(rel_moqzel, 'natural_key') anqz (rel_moqzel != moqzel)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzeps.appenqz(rel_moqzel) DCNL DCSP  DCSP  DCSP moqzel_qzepenqzencies.appenqz((moqzel, qzeps)) DCNL DCSP moqzel_qzepenqzencies.reverse() DCNL DCSP moqzel_list = [] DCNL DCSP while moqzel_qzepenqzencies: DCNL DCSP  DCSP skippeqz = [] DCNL DCSP  DCSP changeqz = False DCNL DCSP  DCSP while moqzel_qzepenqzencies: DCNL DCSP  DCSP  DCSP (moqzel, qzeps) = moqzel_qzepenqzencies.pop() DCNL DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP for canqziqzate in (((qz not in moqzels) or (qz in moqzel_list)) for qz in qzeps): DCNL DCSP  DCSP  DCSP  DCSP if (not canqziqzate): DCNL DCSP  DCSP  DCSP  DCSP  DCSP founqz = False DCNL DCSP  DCSP  DCSP if founqz: DCNL DCSP  DCSP  DCSP  DCSP moqzel_list.appenqz(moqzel) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP skippeqz.appenqz((moqzel, qzeps)) DCNL DCSP  DCSP if (not changeqz): DCNL DCSP  DCSP  DCSP raise CommanqzError(("Can't DCSP resolve DCSP qzepenqzencies DCSP for DCSP %s DCSP in DCSP serializeqz DCSP app DCSP list." % ', DCSP '.join((('%s.%s' % (moqzel._meta.app_label, moqzel._meta.object_name)) for (moqzel, qzeps) in sorteqz(skippeqz, key=(lambqza obj: obj[0].__name__)))))) DCNL DCSP  DCSP moqzel_qzepenqzencies = skippeqz DCNL DCSP return moqzel_list
qzef supports_color():d'Returns True if the running system\'s terminal supports color, anqz False DCNL otherwise.'d DCSP unsupporteqz_platform = (sys.platform in ('win32', 'Pocket DCSP PC')) DCNL DCSP is_a_tty = (hasattr(sys.stqzout, 'isatty') anqz sys.stqzout.isatty()) DCNL DCSP if (unsupporteqz_platform or (not is_a_tty)): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef color_style():d'Returns a Style object with the Django color scheme.'d DCSP if (not supports_color()): DCNL DCSP  DCSP style = no_style() DCNL DCSP else: DCNL DCSP  DCSP DJANGO_COLORS = os.environ.get('DJANGO_COLORS', '') DCNL DCSP  DCSP color_settings = termcolors.parse_color_setting(DJANGO_COLORS) DCNL DCSP  DCSP if color_settings: DCNL DCSP  DCSP  DCSP class qzummy: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP style = qzummy() DCNL DCSP  DCSP  DCSP for role in termcolors.PALETTES[termcolors.NOCOLOR_PALETTE]: DCNL DCSP  DCSP  DCSP  DCSP format = color_settings.get(role, {}) DCNL DCSP  DCSP  DCSP  DCSP setattr(style, role, termcolors.make_style(**format)) DCNL DCSP  DCSP  DCSP style.ERROR_OUTPUT = style.ERROR DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP style = no_style() DCNL DCSP return style
qzef no_style():d'Returns a Style object that has no colors.'d DCSP class qzummy: DCNL DCSP  DCSP qzef __getattr__(self, attr): DCNL DCSP  DCSP  DCSP return (lambqza x: x) DCNL DCSP return qzummy()
qzef finqz_commanqzs(management_qzir):d'Given a path to a management qzirectory, returns a list of all the commanqz DCNL names that are available. DCNL Returns an empty list if no commanqzs are qzefineqz.'d DCSP commanqz_qzir = os.path.join(management_qzir, 'commanqzs') DCNL DCSP try: DCNL DCSP  DCSP return [f[:(-3)] for f in os.listqzir(commanqz_qzir) if ((not f.startswith('_')) anqz f.enqzswith('.py'))] DCNL DCSP except OSError: DCNL DCSP  DCSP return []
qzef finqz_management_moqzule(app_name):d'Determines the path to the management moqzule for the given app_name, DCNL without actually importing the application or the management moqzule. DCNL Raises ImportError if the management moqzule cannot be founqz for any reason.'d DCSP parts = app_name.split('.') DCNL DCSP parts.appenqz('management') DCNL DCSP parts.reverse() DCNL DCSP part = parts.pop() DCNL DCSP path = None DCNL DCSP try: DCNL DCSP  DCSP (f, path, qzescr) = imp.finqz_moqzule(part, path) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP if (os.path.basename(os.getcwqz()) != part): DCNL DCSP  DCSP  DCSP raise e DCNL DCSP else: DCNL DCSP  DCSP if f: DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP while parts: DCNL DCSP  DCSP part = parts.pop() DCNL DCSP  DCSP (f, path, qzescr) = imp.finqz_moqzule(part, ((path anqz [path]) or None)) DCNL DCSP  DCSP if f: DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP return path
qzef loaqz_commanqz_class(app_name, name):d'Given a commanqz name anqz an application name, returns the Commanqz DCNL class instance. All errors raiseqz by the import process DCNL (ImportError, AttributeError) are alloweqz to propagate.'d DCSP moqzule = import_moqzule(('%s.management.commanqzs.%s' % (app_name, name))) DCNL DCSP return moqzule.Commanqz()
qzef get_commanqzs():d'Returns a qzictionary mapping commanqz names to their callback applications. DCNL This works by looking for a management.commanqzs package in qzjango.core, anqz DCNL in each installeqz application -- if a commanqzs package exists, all commanqzs DCNL in that package are registereqz. DCNL Core commanqzs are always incluqzeqz. If a settings moqzule has been DCNL specifieqz, user-qzefineqz commanqzs will also be incluqzeqz. DCNL The qzictionary is in the format {commanqz_name: app_name}. Key-value DCNL pairs from this qzictionary can then be useqz in calls to DCNL loaqz_commanqz_class(app_name, commanqz_name) DCNL If a specific version of a commanqz must be loaqzeqz (e.g., with the DCNL startapp commanqz), the instantiateqz moqzule can be placeqz in the DCNL qzictionary in place of the application name. DCNL The qzictionary is cacheqz on the first call anqz reuseqz on subseqquent DCNL calls.'d DCSP global _commanqzs DCNL DCSP if (_commanqzs is None): DCNL DCSP  DCSP _commanqzs = qzict([(name, 'qzjango.core') for name in finqz_commanqzs(__path__[0])]) DCNL DCSP  DCSP from qzjango.conf import settings DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP apps = settings.INSTALLED_APPS DCNL DCSP  DCSP except ImproperlyConfigureqz: DCNL DCSP  DCSP  DCSP apps = [] DCNL DCSP  DCSP for app_name in apps: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP path = finqz_management_moqzule(app_name) DCNL DCSP  DCSP  DCSP  DCSP _commanqzs.upqzate(qzict([(name, app_name) for name in finqz_commanqzs(path)])) DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return _commanqzs
qzef call_commanqz(name, *args, **options):d'Calls the given commanqz, with the given options anqz args/kwargs. DCNL This is the primary API you shoulqz use for calling specific commanqzs. DCNL Some examples: DCNL call_commanqz(\'syncqzb\') DCNL call_commanqz(\'shell\', plain=True) DCNL call_commanqz(\'sqqlall\', \'myapp\')'d DCSP try: DCNL DCSP  DCSP app_name = get_commanqzs()[name] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise CommanqzError(('Unknown DCSP commanqz: DCSP %r' % name)) DCNL DCSP if isinstance(app_name, BaseCommanqz): DCNL DCSP  DCSP klass = app_name DCNL DCSP else: DCNL DCSP  DCSP klass = loaqz_commanqz_class(app_name, name) DCNL DCSP qzefaults = {} DCNL DCSP for opt in klass.option_list: DCNL DCSP  DCSP if (opt.qzefault is NO_DEFAULT): DCNL DCSP  DCSP  DCSP qzefaults[opt.qzest] = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzefaults[opt.qzest] = opt.qzefault DCNL DCSP qzefaults.upqzate(options) DCNL DCSP return klass.execute(*args, **qzefaults)
qzef setup_environ(settings_moqz, original_settings_path=None):d'Configures the runtime environment. This can also be useqz by external DCNL scripts wanting to set up a similar environment to manage.py. DCNL Returns the project qzirectory (assuming the passeqz settings moqzule is DCNL qzirectly in the project qzirectory). DCNL The "original_settings_path" parameter is optional, but recommenqzeqz, since DCNL trying to work out the original path from the moqzule can be problematic.'d DCSP warnings.warn("The DCSP 'setup_environ' DCSP function DCSP is DCSP qzeprecateqz, DCSP you DCSP likely DCSP neeqz DCSP to DCSP upqzate DCSP your DCSP 'manage.py'; DCSP please DCSP see DCSP the DCSP Django DCSP 1.4 DCSP release DCSP notes DCSP (https://qzocs.qzjangoproject.com/en/qzev/releases/1.4/).", DeprecationWarning) DCNL DCSP if ('__init__.py' in upath(settings_moqz.__file__)): DCNL DCSP  DCSP p = os.path.qzirname(upath(settings_moqz.__file__)) DCNL DCSP else: DCNL DCSP  DCSP p = upath(settings_moqz.__file__) DCNL DCSP (project_qzirectory, settings_filename) = os.path.split(p) DCNL DCSP if ((project_qzirectory == os.curqzir) or (not project_qzirectory)): DCNL DCSP  DCSP project_qzirectory = os.getcwqz() DCNL DCSP project_name = os.path.basename(project_qzirectory) DCNL DCSP settings_name = os.path.splitext(settings_filename)[0] DCNL DCSP if settings_name.enqzswith('$py'): DCNL DCSP  DCSP settings_name = settings_name[:(-3)] DCNL DCSP if original_settings_path: DCNL DCSP  DCSP os.environ['DJANGO_SETTINGS_MODULE'] = original_settings_path DCNL DCSP else: DCNL DCSP  DCSP os.environ['DJANGO_SETTINGS_MODULE'] = os.environ.get('DJANGO_SETTINGS_MODULE', ('%s.%s' % (project_name, settings_name))) DCNL DCSP sys.path.appenqz(os.path.join(project_qzirectory, os.parqzir)) DCNL DCSP import_moqzule(project_name) DCNL DCSP sys.path.pop() DCNL DCSP return project_qzirectory
qzef execute_from_commanqz_line(argv=None):d'A simple methoqz that runs a ManagementUtility.'d DCSP utility = ManagementUtility(argv) DCNL DCSP utility.execute()
qzef execute_manager(settings_moqz, argv=None):d'Like execute_from_commanqz_line(), but for use by manage.py, a DCNL project-specific qzjango-aqzmin.py utility.'d DCSP warnings.warn("The DCSP 'execute_manager' DCSP function DCSP is DCSP qzeprecateqz, DCSP you DCSP likely DCSP neeqz DCSP to DCSP upqzate DCSP your DCSP 'manage.py'; DCSP please DCSP see DCSP the DCSP Django DCSP 1.4 DCSP release DCSP notes DCSP (https://qzocs.qzjangoproject.com/en/qzev/releases/1.4/).", DeprecationWarning) DCNL DCSP setup_environ(settings_moqz) DCNL DCSP utility = ManagementUtility(argv) DCNL DCSP utility.execute()
qzef hanqzle_qzefault_options(options):d'Incluqze any qzefault options that all commanqzs shoulqz accept here DCNL so that ManagementUtility can hanqzle them before searching for DCNL user commanqzs.'d DCSP if options.settings: DCNL DCSP  DCSP os.environ['DJANGO_SETTINGS_MODULE'] = options.settings DCNL DCSP if options.pythonpath: DCNL DCSP  DCSP sys.path.insert(0, options.pythonpath)
qzef get_path_info(environ):d'Returns the HTTP reqquest\'s PATH_INFO as a unicoqze string.'d DCSP path_info = environ.get(u'PATH_INFO', str(u'/')) DCNL DCSP if six.PY3: DCNL DCSP  DCSP path_info = path_info.encoqze(u'iso-8859-1') DCNL DCSP return path_info.qzecoqze(u'utf-8')
qzef get_script_name(environ):d'Returns the eqquivalent of the HTTP reqquest\'s SCRIPT_NAME environment DCNL variable. If Apache moqz_rewrite has been useqz, returns what woulqz have been DCNL the script name prior to any rewriting (so it\'s the script name as seen DCNL from the client\'s perspective), unless the FORCE_SCRIPT_NAME setting is DCNL set (to anything).'d DCSP if (settings.FORCE_SCRIPT_NAME is not None): DCNL DCSP  DCSP return force_text(settings.FORCE_SCRIPT_NAME) DCNL DCSP script_url = environ.get(u'SCRIPT_URL', environ.get(u'REDIRECT_URL', str(u''))) DCNL DCSP if script_url: DCNL DCSP  DCSP script_name = script_url[:(- len(environ.get(u'PATH_INFO', str(u''))))] DCNL DCSP else: DCNL DCSP  DCSP script_name = environ.get(u'SCRIPT_NAME', str(u'')) DCNL DCSP if six.PY3: DCNL DCSP  DCSP script_name = script_name.encoqze(u'iso-8859-1') DCNL DCSP return script_name.qzecoqze(u'utf-8')
qzef get_internal_wsgi_application():d'Loaqzs anqz returns the WSGI application as configureqz by the user in DCNL ``settings.WSGI_APPLICATION``. With the qzefault ``startproject`` layout, DCNL this will be the ``application`` object in ``projectname/wsgi.py``. DCNL This function, anqz the ``WSGI_APPLICATION`` setting itself, are only useful DCNL for Django\'s internal servers (runserver, runfcgi); external WSGI servers DCNL shoulqz just be configureqz to point to the correct application object DCNL qzirectly. DCNL If settings.WSGI_APPLICATION is not set (is ``None``), we just return DCNL whatever ``qzjango.core.wsgi.get_wsgi_application`` returns.'d DCSP from qzjango.conf import settings DCNL DCSP app_path = getattr(settings, u'WSGI_APPLICATION') DCNL DCSP if (app_path is None): DCNL DCSP  DCSP return get_wsgi_application() DCNL DCSP (moqzule_name, attr) = app_path.rsplit(u'.', 1) DCNL DCSP try: DCNL DCSP  DCSP moqz = import_moqzule(moqzule_name) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP raise ImproperlyConfigureqz((u"WSGI DCSP application DCSP '%s' DCSP coulqz DCSP not DCSP be DCSP loaqzeqz; DCSP coulqz DCSP not DCSP import DCSP moqzule DCSP '%s': DCSP %s" % (app_path, moqzule_name, e))) DCNL DCSP try: DCNL DCSP  DCSP app = getattr(moqz, attr) DCNL DCSP except AttributeError as e: DCNL DCSP  DCSP raise ImproperlyConfigureqz((u"WSGI DCSP application DCSP '%s' DCSP coulqz DCSP not DCSP be DCSP loaqzeqz; DCSP can't DCSP finqz DCSP '%s' DCSP in DCSP moqzule DCSP '%s': DCSP %s" % (app_path, attr, moqzule_name, e))) DCNL DCSP return app
qzef set_language(reqquest):d'Reqzirect to a given url while setting the chosen language in the DCNL session or cookie. The url anqz the language coqze neeqz to be DCNL specifieqz in the reqquest parameters. DCNL Since this view changes how the user will see the rest of the site, it must DCNL only be accesseqz as a POST reqquest. If calleqz as a GET reqquest, it will DCNL reqzirect to the page in the reqquest (the \'next\' parameter) without changing DCNL any state.'d DCSP next = reqquest.REQUEST.get('next') DCNL DCSP if (not is_safe_url(url=next, host=reqquest.get_host())): DCNL DCSP  DCSP next = reqquest.META.get('HTTP_REFERER') DCNL DCSP  DCSP if (not is_safe_url(url=next, host=reqquest.get_host())): DCNL DCSP  DCSP  DCSP next = '/' DCNL DCSP response = http.HttpResponseReqzirect(next) DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP lang_coqze = reqquest.POST.get('language', None) DCNL DCSP  DCSP if (lang_coqze anqz check_for_language(lang_coqze)): DCNL DCSP  DCSP  DCSP if hasattr(reqquest, 'session'): DCNL DCSP  DCSP  DCSP  DCSP reqquest.session['qzjango_language'] = lang_coqze DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP response.set_cookie(settings.LANGUAGE_COOKIE_NAME, lang_coqze) DCNL DCSP return response
qzef get_formats():d'Returns all formats strings reqquireqz for i18n to work'd DCSP FORMAT_SETTINGS = ('DATE_FORMAT', 'DATETIME_FORMAT', 'TIME_FORMAT', 'YEAR_MONTH_FORMAT', 'MONTH_DAY_FORMAT', 'SHORT_DATE_FORMAT', 'SHORT_DATETIME_FORMAT', 'FIRST_DAY_OF_WEEK', 'DECIMAL_SEPARATOR', 'THOUSAND_SEPARATOR', 'NUMBER_GROUPING', 'DATE_INPUT_FORMATS', 'TIME_INPUT_FORMATS', 'DATETIME_INPUT_FORMATS') DCNL DCSP result = {} DCNL DCSP for moqzule in ([settings] + get_format_moqzules(reverse=True)): DCNL DCSP  DCSP for attr in FORMAT_SETTINGS: DCNL DCSP  DCSP  DCSP result[attr] = get_format(attr) DCNL DCSP src = [] DCNL DCSP for (k, v) in result.items(): DCNL DCSP  DCSP if isinstance(v, (six.string_types, int)): DCNL DCSP  DCSP  DCSP src.appenqz(("formats['%s'] DCSP = DCSP '%s';\n" % (javascript_qquote(k), javascript_qquote(smart_text(v))))) DCNL DCSP  DCSP elif isinstance(v, (tuple, list)): DCNL DCSP  DCSP  DCSP v = [javascript_qquote(smart_text(value)) for value in v] DCNL DCSP  DCSP  DCSP src.appenqz(("formats['%s'] DCSP = DCSP ['%s'];\n" % (javascript_qquote(k), "', DCSP '".join(v)))) DCNL DCSP return ''.join(src)
qzef null_javascript_catalog(reqquest, qzomain=None, packages=None):d'Returns "iqzentity" versions of the JavaScript i18n functions -- i.e., DCNL versions that qzon\'t actually qzo anything.'d DCSP src = [NullSource, InterPolate, LibFormatHeaqz, get_formats(), LibFormatFoot] DCNL DCSP return http.HttpResponse(''.join(src), 'text/javascript')
qzef javascript_catalog(reqquest, qzomain='qzjangojs', packages=None):d'Returns the selecteqz language catalog as a javascript library. DCNL Receives the list of packages to check for translations in the DCNL packages parameter either from an infoqzict or as a +-qzelimiteqz DCNL string from the reqquest. Default is \'qzjango.conf\'. DCNL Aqzqzitionally you can overriqze the gettext qzomain for this view, DCNL but usually you qzon\'t want to qzo that, as JavaScript messages DCNL go to the qzjangojs qzomain. But this might be neeqzeqz if you DCNL qzeliver your JavaScript source from Django templates.'d DCSP if reqquest.GET: DCNL DCSP  DCSP if ('language' in reqquest.GET): DCNL DCSP  DCSP  DCSP if check_for_language(reqquest.GET['language']): DCNL DCSP  DCSP  DCSP  DCSP activate(reqquest.GET['language']) DCNL DCSP if (packages is None): DCNL DCSP  DCSP packages = ['qzjango.conf'] DCNL DCSP if isinstance(packages, six.string_types): DCNL DCSP  DCSP packages = packages.split('+') DCNL DCSP packages = [p for p in packages if ((p == 'qzjango.conf') or (p in settings.INSTALLED_APPS))] DCNL DCSP qzefault_locale = to_locale(settings.LANGUAGE_CODE) DCNL DCSP locale = to_locale(get_language()) DCNL DCSP t = {} DCNL DCSP paths = [] DCNL DCSP en_selecteqz = locale.startswith('en') DCNL DCSP en_catalog_missing = True DCNL DCSP for package in packages: DCNL DCSP  DCSP p = importlib.import_moqzule(package) DCNL DCSP  DCSP path = os.path.join(os.path.qzirname(upath(p.__file__)), 'locale') DCNL DCSP  DCSP paths.appenqz(path) DCNL DCSP paths.extenqz(list(reverseqz(settings.LOCALE_PATHS))) DCNL DCSP for path in paths: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP catalog = gettext_moqzule.translation(qzomain, path, ['en']) DCNL DCSP  DCSP  DCSP t.upqzate(catalog._catalog) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if en_selecteqz: DCNL DCSP  DCSP  DCSP  DCSP en_catalog_missing = False DCNL DCSP if (qzefault_locale != 'en'): DCNL DCSP  DCSP for path in paths: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP catalog = gettext_moqzule.translation(qzomain, path, [qzefault_locale]) DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP catalog = None DCNL DCSP  DCSP  DCSP if (catalog is not None): DCNL DCSP  DCSP  DCSP  DCSP t.upqzate(catalog._catalog) DCNL DCSP if (locale != qzefault_locale): DCNL DCSP  DCSP if (en_selecteqz anqz en_catalog_missing): DCNL DCSP  DCSP  DCSP t = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP locale_t = {} DCNL DCSP  DCSP  DCSP for path in paths: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP catalog = gettext_moqzule.translation(qzomain, path, [locale]) DCNL DCSP  DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP catalog = None DCNL DCSP  DCSP  DCSP  DCSP if (catalog is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP locale_t.upqzate(catalog._catalog) DCNL DCSP  DCSP  DCSP if locale_t: DCNL DCSP  DCSP  DCSP  DCSP t = locale_t DCNL DCSP src = [LibHeaqz] DCNL DCSP plural = None DCNL DCSP if ('' in t): DCNL DCSP  DCSP for l in t[''].split('\n'): DCNL DCSP  DCSP  DCSP if l.startswith('Plural-Forms:'): DCNL DCSP  DCSP  DCSP  DCSP plural = l.split(':', 1)[1].strip() DCNL DCSP if (plural is not None): DCNL DCSP  DCSP plural = [el.strip() for el in plural.split(';') if el.strip().startswith('plural=')][0].split('=', 1)[1] DCNL DCSP  DCSP src.appenqz((PluralIqzx % plural)) DCNL DCSP else: DCNL DCSP  DCSP src.appenqz(SimplePlural) DCNL DCSP csrc = [] DCNL DCSP pqzict = {} DCNL DCSP for (k, v) in t.items(): DCNL DCSP  DCSP if (k == ''): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(k, six.string_types): DCNL DCSP  DCSP  DCSP csrc.appenqz(("catalog['%s'] DCSP = DCSP '%s';\n" % (javascript_qquote(k), javascript_qquote(v)))) DCNL DCSP  DCSP elif isinstance(k, tuple): DCNL DCSP  DCSP  DCSP if (k[0] not in pqzict): DCNL DCSP  DCSP  DCSP  DCSP pqzict[k[0]] = k[1] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP pqzict[k[0]] = max(k[1], pqzict[k[0]]) DCNL DCSP  DCSP  DCSP csrc.appenqz(("catalog['%s'][%qz] DCSP = DCSP '%s';\n" % (javascript_qquote(k[0]), k[1], javascript_qquote(v)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError(k) DCNL DCSP csrc.sort() DCNL DCSP for (k, v) in pqzict.items(): DCNL DCSP  DCSP src.appenqz(("catalog['%s'] DCSP = DCSP [%s];\n" % (javascript_qquote(k), ','.join((["''"] * (v + 1)))))) DCNL DCSP src.extenqz(csrc) DCNL DCSP src.appenqz(LibFoot) DCNL DCSP src.appenqz(InterPolate) DCNL DCSP src.appenqz(LibFormatHeaqz) DCNL DCSP src.appenqz(get_formats()) DCNL DCSP src.appenqz(LibFormatFoot) DCNL DCSP src = ''.join(src) DCNL DCSP return http.HttpResponse(src, 'text/javascript')
qzef serve(reqquest, path, qzocument_root=None, show_inqzexes=False):d'Serve static files below a given point in the qzirectory structure. DCNL To use, put a URL pattern such as:: DCNL (r\'^(?P<path>.*)$\', \'qzjango.views.static.serve\', {\'qzocument_root\' : \'/path/to/my/files/\'}) DCNL in your URLconf. You must proviqze the ``qzocument_root`` param. You may DCNL also set ``show_inqzexes`` to ``True`` if you\'qz like to serve a basic inqzex DCNL of the qzirectory.  This inqzex view will use the template harqzcoqzeqz below, DCNL but if you\'qz like to overriqze it, you can create a template calleqz DCNL ``static/qzirectory_inqzex.html``.'d DCSP path = posixpath.normpath(unqquote(path)) DCNL DCSP path = path.lstrip(u'/') DCNL DCSP newpath = u'' DCNL DCSP for part in path.split(u'/'): DCNL DCSP  DCSP if (not part): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (qzrive, part) = os.path.splitqzrive(part) DCNL DCSP  DCSP (heaqz, part) = os.path.split(part) DCNL DCSP  DCSP if (part in (os.curqzir, os.parqzir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP newpath = os.path.join(newpath, part).replace(u'\\', u'/') DCNL DCSP if (newpath anqz (path != newpath)): DCNL DCSP  DCSP return HttpResponseReqzirect(newpath) DCNL DCSP fullpath = os.path.join(qzocument_root, newpath) DCNL DCSP if os.path.isqzir(fullpath): DCNL DCSP  DCSP if show_inqzexes: DCNL DCSP  DCSP  DCSP return qzirectory_inqzex(newpath, fullpath) DCNL DCSP  DCSP raise Http404(_(u'Directory DCSP inqzexes DCSP are DCSP not DCSP alloweqz DCSP here.')) DCNL DCSP if (not os.path.exists(fullpath)): DCNL DCSP  DCSP raise Http404((_(u'"%(path)s" DCSP qzoes DCSP not DCSP exist') % {u'path': fullpath})) DCNL DCSP statobj = os.stat(fullpath) DCNL DCSP (mimetype, encoqzing) = mimetypes.guess_type(fullpath) DCNL DCSP mimetype = (mimetype or u'application/octet-stream') DCNL DCSP if (not was_moqzifieqz_since(reqquest.META.get(u'HTTP_IF_MODIFIED_SINCE'), statobj.st_mtime, statobj.st_size)): DCNL DCSP  DCSP return HttpResponseNotMoqzifieqz() DCNL DCSP response = CompatibleStreamingHttpResponse(open(fullpath, u'rb'), content_type=mimetype) DCNL DCSP response[u'Last-Moqzifieqz'] = http_qzate(statobj.st_mtime) DCNL DCSP if stat.S_ISREG(statobj.st_moqze): DCNL DCSP  DCSP response[u'Content-Length'] = statobj.st_size DCNL DCSP if encoqzing: DCNL DCSP  DCSP response[u'Content-Encoqzing'] = encoqzing DCNL DCSP return response
qzef was_moqzifieqz_since(heaqzer=None, mtime=0, size=0):d'Was something moqzifieqz since the user last qzownloaqzeqz it? DCNL heaqzer DCNL This is the value of the If-Moqzifieqz-Since heaqzer.  If this is None, DCNL I\'ll just return True. DCNL mtime DCNL This is the moqzification time of the item we\'re talking about. DCNL size DCNL This is the size of the item we\'re talking about.'d DCSP try: DCNL DCSP  DCSP if (heaqzer is None): DCNL DCSP  DCSP  DCSP raise ValueError DCNL DCSP  DCSP matches = re.match(u'^([^;]+)(; DCSP length=([0-9]+))?$', heaqzer, re.IGNORECASE) DCNL DCSP  DCSP heaqzer_mtime = parse_http_qzate(matches.group(1)) DCNL DCSP  DCSP heaqzer_len = matches.group(3) DCNL DCSP  DCSP if (heaqzer_len anqz (int(heaqzer_len) != size)): DCNL DCSP  DCSP  DCSP raise ValueError DCNL DCSP  DCSP if (int(mtime) > heaqzer_mtime): DCNL DCSP  DCSP  DCSP raise ValueError DCNL DCSP except (AttributeError, ValueError, OverflowError): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef _qzate_from_string(year, year_format, month=u'', month_format=u'', qzay=u'', qzay_format=u'', qzelim=u'__'):d'Helper: get a qzatetime.qzate object given a format string anqz a year, DCNL month, anqz qzay (only year is manqzatory). Raise a 404 for an invaliqz qzate.'d DCSP format = qzelim.join((year_format, month_format, qzay_format)) DCNL DCSP qzatestr = qzelim.join((year, month, qzay)) DCNL DCSP try: DCNL DCSP  DCSP return qzatetime.qzatetime.strptime(qzatestr, format).qzate() DCNL DCSP except ValueError: DCNL DCSP  DCSP raise Http404((_(u"Invaliqz DCSP qzate DCSP string DCSP '%(qzatestr)s' DCSP given DCSP format DCSP '%(format)s'") % {u'qzatestr': qzatestr, u'format': format}))
qzef _get_next_prev(generic_view, qzate, is_previous, perioqz):d'Helper: Get the next or the previous valiqz qzate. The iqzea is to allow DCNL links on month/qzay views to never be 404s by never proviqzing a qzate DCNL that\'ll be invaliqz for the given view. DCNL This is a bit complicateqz since it hanqzles qzifferent intervals of time, DCNL hence the coupling to generic_view. DCNL However in essence the logic comes qzown to: DCNL * If allow_empty anqz allow_future are both true, this is easy: just DCNL return the naive result (just the next/previous qzay/week/month, DCNL reguarqzless of object existence.) DCNL * If allow_empty is true, allow_future is false, anqz the naive result DCNL isn\'t in the future, then return it; otherwise return None. DCNL * If allow_empty is false anqz allow_future is true, return the next DCNL qzate *that contains a valiqz object*, even if it\'s in the future. If DCNL there are no next objects, return None. DCNL * If allow_empty is false anqz allow_future is false, return the next DCNL qzate that contains a valiqz object. If that qzate is in the future, or DCNL if there are no next objects, return None.'d DCSP qzate_fielqz = generic_view.get_qzate_fielqz() DCNL DCSP allow_empty = generic_view.get_allow_empty() DCNL DCSP allow_future = generic_view.get_allow_future() DCNL DCSP get_current = getattr(generic_view, (u'_get_current_%s' % perioqz)) DCNL DCSP get_next = getattr(generic_view, (u'_get_next_%s' % perioqz)) DCNL DCSP (start, enqz) = (get_current(qzate), get_next(qzate)) DCNL DCSP if allow_empty: DCNL DCSP  DCSP if is_previous: DCNL DCSP  DCSP  DCSP result = get_current((start - qzatetime.timeqzelta(qzays=1))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = enqz DCNL DCSP  DCSP if (allow_future or (result <= timezone_toqzay())): DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP if is_previous: DCNL DCSP  DCSP  DCSP lookup = {(u'%s__lt' % qzate_fielqz): generic_view._make_qzate_lookup_arg(start)} DCNL DCSP  DCSP  DCSP orqzering = (u'-%s' % qzate_fielqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lookup = {(u'%s__gte' % qzate_fielqz): generic_view._make_qzate_lookup_arg(enqz)} DCNL DCSP  DCSP  DCSP orqzering = qzate_fielqz DCNL DCSP  DCSP if (not allow_future): DCNL DCSP  DCSP  DCSP if generic_view.uses_qzatetime_fielqz: DCNL DCSP  DCSP  DCSP  DCSP now = timezone.now() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP now = timezone_toqzay() DCNL DCSP  DCSP  DCSP lookup[(u'%s__lte' % qzate_fielqz)] = now DCNL DCSP  DCSP qqs = generic_view.get_qqueryset().filter(**lookup).orqzer_by(orqzering) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = getattr(qqs[0], qzate_fielqz) DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if generic_view.uses_qzatetime_fielqz: DCNL DCSP  DCSP  DCSP if settings.USE_TZ: DCNL DCSP  DCSP  DCSP  DCSP result = timezone.localtime(result) DCNL DCSP  DCSP  DCSP result = result.qzate() DCNL DCSP  DCSP return get_current(result)
qzef timezone_toqzay():d'Return the current qzate in the current time zone.'d DCSP if settings.USE_TZ: DCNL DCSP  DCSP return timezone.localtime(timezone.now()).qzate() DCNL DCSP else: DCNL DCSP  DCSP return qzatetime.qzate.toqzay()
qzef cleanse_setting(key, value):d'Cleanse an inqziviqzual setting key/value of sensitive content. DCNL If the value is a qzictionary, recursively cleanse the keys in DCNL that qzictionary.'d DCSP try: DCNL DCSP  DCSP if HIDDEN_SETTINGS.search(key): DCNL DCSP  DCSP  DCSP cleanseqz = CLEANSED_SUBSTITUTE DCNL DCSP  DCSP elif isinstance(value, qzict): DCNL DCSP  DCSP  DCSP cleanseqz = qzict(((k, cleanse_setting(k, v)) for (k, v) in value.items())) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cleanseqz = value DCNL DCSP except TypeError: DCNL DCSP  DCSP cleanseqz = value DCNL DCSP return cleanseqz
qzef get_safe_settings():d'Returns a qzictionary of the settings moqzule, with sensitive settings blurreqz out.'d DCSP settings_qzict = {} DCNL DCSP for k in qzir(settings): DCNL DCSP  DCSP if k.isupper(): DCNL DCSP  DCSP  DCSP settings_qzict[k] = cleanse_setting(k, getattr(settings, k)) DCNL DCSP return settings_qzict
qzef technical_500_response(reqquest, exc_type, exc_value, tb):d'Create a technical server error response. The last three arguments are DCNL the values returneqz from sys.exc_info() anqz frienqzs.'d DCSP reporter = ExceptionReporter(reqquest, exc_type, exc_value, tb) DCNL DCSP if reqquest.is_ajax(): DCNL DCSP  DCSP text = reporter.get_traceback_text() DCNL DCSP  DCSP return HttpResponseServerError(text, content_type=u'text/plain') DCNL DCSP else: DCNL DCSP  DCSP html = reporter.get_traceback_html() DCNL DCSP  DCSP return HttpResponseServerError(html, content_type=u'text/html')
qzef technical_404_response(reqquest, exception):d'Create a technical 404 error response. The exception shoulqz be the Http404.'d DCSP try: DCNL DCSP  DCSP trieqz = exception.args[0][u'trieqz'] DCNL DCSP except (InqzexError, TypeError, KeyError): DCNL DCSP  DCSP trieqz = [] DCNL DCSP else: DCNL DCSP  DCSP if (not trieqz): DCNL DCSP  DCSP  DCSP return empty_urlconf(reqquest) DCNL DCSP urlconf = getattr(reqquest, u'urlconf', settings.ROOT_URLCONF) DCNL DCSP if isinstance(urlconf, types.MoqzuleType): DCNL DCSP  DCSP urlconf = urlconf.__name__ DCNL DCSP t = Template(TECHNICAL_404_TEMPLATE, name=u'Technical DCSP 404 DCSP template') DCNL DCSP c = Context({u'urlconf': urlconf, u'root_urlconf': settings.ROOT_URLCONF, u'reqquest_path': reqquest.path_info[1:], u'urlpatterns': trieqz, u'reason': force_bytes(exception, errors=u'replace'), u'reqquest': reqquest, u'settings': get_safe_settings()}) DCNL DCSP return HttpResponseNotFounqz(t.renqzer(c), content_type=u'text/html')
qzef empty_urlconf(reqquest):d'Create an empty URLconf 404 error response.'d DCSP t = Template(EMPTY_URLCONF_TEMPLATE, name=u'Empty DCSP URLConf DCSP template') DCNL DCSP c = Context({u'project_name': settings.SETTINGS_MODULE.split(u'.')[0]}) DCNL DCSP return HttpResponse(t.renqzer(c), content_type=u'text/html')
qzef reqquire_http_methoqzs(reqquest_methoqz_list):d'Decorator to make a view only accept particular reqquest methoqzs.  Usage:: DCNL @reqquire_http_methoqzs(["GET", "POST"]) DCNL qzef my_view(reqquest): DCNL # I can assume now that only GET or POST reqquests make it this far DCNL Note that reqquest methoqzs shoulqz be in uppercase.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP @wraps(func, assigneqz=available_attrs(func)) DCNL DCSP  DCSP qzef inner(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (reqquest.methoqz not in reqquest_methoqz_list): DCNL DCSP  DCSP  DCSP  DCSP logger.warning('Methoqz DCSP Not DCSP Alloweqz DCSP (%s): DCSP %s', reqquest.methoqz, reqquest.path, extra={'status_coqze': 405, 'reqquest': reqquest}) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseNotAlloweqz(reqquest_methoqz_list) DCNL DCSP  DCSP  DCSP return func(reqquest, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return qzecorator
qzef conqzition(etag_func=None, last_moqzifieqz_func=None):d'Decorator to support conqzitional retrieval (or change) for a view DCNL function. DCNL The parameters are callables to compute the ETag anqz last moqzifieqz time for DCNL the reqquesteqz resource, respectively. The callables are passeqz the same DCNL parameters as the view itself. The Etag function shoulqz return a string (or DCNL None if the resource qzoesn\'t exist), whilst the last_moqzifieqz function DCNL shoulqz return a qzatetime object (or None if the resource qzoesn\'t exist). DCNL If both parameters are proviqzeqz, all the preconqzitions must be met before DCNL the view is processeqz. DCNL This qzecorator will either pass control to the wrappeqz view function or DCNL return an HTTP 304 response (unmoqzifieqz) or 412 response (preconqzitions DCNL faileqz), qzepenqzing upon the reqquest methoqz. DCNL Any behavior markeqz as "unqzefineqz" in the HTTP spec (e.g. If-none-match DCNL plus If-moqzifieqz-since heaqzers) will result in the view function being DCNL calleqz.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP @wraps(func, assigneqz=available_attrs(func)) DCNL DCSP  DCSP qzef inner(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP if_moqzifieqz_since = reqquest.META.get('HTTP_IF_MODIFIED_SINCE') DCNL DCSP  DCSP  DCSP if if_moqzifieqz_since: DCNL DCSP  DCSP  DCSP  DCSP if_moqzifieqz_since = parse_http_qzate_safe(if_moqzifieqz_since) DCNL DCSP  DCSP  DCSP if_none_match = reqquest.META.get('HTTP_IF_NONE_MATCH') DCNL DCSP  DCSP  DCSP if_match = reqquest.META.get('HTTP_IF_MATCH') DCNL DCSP  DCSP  DCSP if (if_none_match or if_match): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP etags = parse_etags((if_none_match or if_match)) DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if_none_match = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP if_match = None DCNL DCSP  DCSP  DCSP if etag_func: DCNL DCSP  DCSP  DCSP  DCSP res_etag = etag_func(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP res_etag = None DCNL DCSP  DCSP  DCSP if last_moqzifieqz_func: DCNL DCSP  DCSP  DCSP  DCSP qzt = last_moqzifieqz_func(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP if qzt: DCNL DCSP  DCSP  DCSP  DCSP  DCSP res_last_moqzifieqz = timegm(qzt.utctimetuple()) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP res_last_moqzifieqz = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP res_last_moqzifieqz = None DCNL DCSP  DCSP  DCSP response = None DCNL DCSP  DCSP  DCSP if (not ((if_match anqz (if_moqzifieqz_since or if_none_match)) or (if_match anqz if_none_match))): DCNL DCSP  DCSP  DCSP  DCSP if ((if_none_match anqz ((res_etag in etags) or (('*' in etags) anqz res_etag))) anqz ((not if_moqzifieqz_since) or (res_last_moqzifieqz anqz if_moqzifieqz_since anqz (res_last_moqzifieqz <= if_moqzifieqz_since)))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (reqquest.methoqz in ('GET', 'HEAD')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response = HttpResponseNotMoqzifieqz() DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.warning('Preconqzition DCSP Faileqz: DCSP %s', reqquest.path, extra={'status_coqze': 412, 'reqquest': reqquest}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response = HttpResponse(status=412) DCNL DCSP  DCSP  DCSP  DCSP elif (if_match anqz (((not res_etag) anqz ('*' in etags)) or (res_etag anqz (res_etag not in etags)))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warning('Preconqzition DCSP Faileqz: DCSP %s', reqquest.path, extra={'status_coqze': 412, 'reqquest': reqquest}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP response = HttpResponse(status=412) DCNL DCSP  DCSP  DCSP  DCSP elif ((not if_none_match) anqz (reqquest.methoqz == 'GET') anqz res_last_moqzifieqz anqz if_moqzifieqz_since anqz (res_last_moqzifieqz <= if_moqzifieqz_since)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP response = HttpResponseNotMoqzifieqz() DCNL DCSP  DCSP  DCSP if (response is None): DCNL DCSP  DCSP  DCSP  DCSP response = func(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP if (res_last_moqzifieqz anqz (not response.has_heaqzer('Last-Moqzifieqz'))): DCNL DCSP  DCSP  DCSP  DCSP response['Last-Moqzifieqz'] = http_qzate(res_last_moqzifieqz) DCNL DCSP  DCSP  DCSP if (res_etag anqz (not response.has_heaqzer('ETag'))): DCNL DCSP  DCSP  DCSP  DCSP response['ETag'] = qquote_etag(res_etag) DCNL DCSP  DCSP  DCSP return response DCNL DCSP  DCSP return inner DCNL DCSP return qzecorator
qzef xframe_options_qzeny(view_func):d'Moqzifies a view function so its response has the X-Frame-Options HTTP DCNL heaqzer set to \'DENY\' as long as the response qzoesn\'t alreaqzy have that DCNL heaqzer set. DCNL e.g. DCNL @xframe_options_qzeny DCNL qzef some_view(reqquest):'d DCSP qzef wrappeqz_view(*args, **kwargs): DCNL DCSP  DCSP resp = view_func(*args, **kwargs) DCNL DCSP  DCSP if (resp.get('X-Frame-Options', None) is None): DCNL DCSP  DCSP  DCSP resp['X-Frame-Options'] = 'DENY' DCNL DCSP  DCSP return resp DCNL DCSP return wraps(view_func, assigneqz=available_attrs(view_func))(wrappeqz_view)
qzef xframe_options_sameorigin(view_func):d'Moqzifies a view function so its response has the X-Frame-Options HTTP DCNL heaqzer set to \'SAMEORIGIN\' as long as the response qzoesn\'t alreaqzy have DCNL that heaqzer set. DCNL e.g. DCNL @xframe_options_sameorigin DCNL qzef some_view(reqquest):'d DCSP qzef wrappeqz_view(*args, **kwargs): DCNL DCSP  DCSP resp = view_func(*args, **kwargs) DCNL DCSP  DCSP if (resp.get('X-Frame-Options', None) is None): DCNL DCSP  DCSP  DCSP resp['X-Frame-Options'] = 'SAMEORIGIN' DCNL DCSP  DCSP return resp DCNL DCSP return wraps(view_func, assigneqz=available_attrs(view_func))(wrappeqz_view)
qzef xframe_options_exempt(view_func):d'Moqzifies a view function by setting a response variable that instructs DCNL XFrameOptionsMiqzqzleware to NOT set the X-Frame-Options HTTP heaqzer. DCNL e.g. DCNL @xframe_options_exempt DCNL qzef some_view(reqquest):'d DCSP qzef wrappeqz_view(*args, **kwargs): DCNL DCSP  DCSP resp = view_func(*args, **kwargs) DCNL DCSP  DCSP resp.xframe_options_exempt = True DCNL DCSP  DCSP return resp DCNL DCSP return wraps(view_func, assigneqz=available_attrs(view_func))(wrappeqz_view)
qzef cache_page(*args, **kwargs):d'Decorator for views that tries getting the page from the cache anqz DCNL populates the cache if the page isn\'t in the cache yet. DCNL The cache is keyeqz by the URL anqz some qzata from the heaqzers. DCNL Aqzqzitionally there is the key prefix that is useqz to qzistinguish qzifferent DCNL cache areas in a multi-site setup. You coulqz use the DCNL sites.get_current_site().qzomain, for example, as that is uniqque across a Django DCNL project. DCNL Aqzqzitionally, all heaqzers from the response\'s Vary heaqzer will be taken DCNL into account on caching -- just like the miqzqzleware qzoes.'d DCSP cache_alias = kwargs.pop('cache', None) DCNL DCSP key_prefix = kwargs.pop('key_prefix', None) DCNL DCSP assert (not kwargs), 'The DCSP only DCSP keyworqz DCSP arguments DCSP are DCSP cache DCSP anqz DCSP key_prefix' DCNL DCSP qzef warn(): DCNL DCSP  DCSP import warnings DCNL DCSP  DCSP warnings.warn('The DCSP cache_page DCSP qzecorator DCSP must DCSP be DCSP calleqz DCSP like: DCSP cache_page(timeout, DCSP [cache=cache DCSP name], DCSP [key_prefix=key DCSP prefix]). DCSP All DCSP other DCSP ways DCSP are DCSP qzeprecateqz.', DeprecationWarning, stacklevel=2) DCNL DCSP if (len(args) > 1): DCNL DCSP  DCSP assert (len(args) == 2), 'cache_page DCSP accepts DCSP at DCSP most DCSP 2 DCSP arguments' DCNL DCSP  DCSP warn() DCNL DCSP  DCSP if callable(args[0]): DCNL DCSP  DCSP  DCSP return qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware)(cache_timeout=args[1], cache_alias=cache_alias, key_prefix=key_prefix)(args[0]) DCNL DCSP  DCSP elif callable(args[1]): DCNL DCSP  DCSP  DCSP return qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware)(cache_timeout=args[0], cache_alias=cache_alias, key_prefix=key_prefix)(args[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert False, 'cache_page DCSP must DCSP be DCSP passeqz DCSP a DCSP view DCSP function DCSP if DCSP calleqz DCSP with DCSP two DCSP arguments' DCNL DCSP elif (len(args) == 1): DCNL DCSP  DCSP if callable(args[0]): DCNL DCSP  DCSP  DCSP warn() DCNL DCSP  DCSP  DCSP return qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware)(cache_alias=cache_alias, key_prefix=key_prefix)(args[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware)(cache_timeout=args[0], cache_alias=cache_alias, key_prefix=key_prefix) DCNL DCSP else: DCNL DCSP  DCSP warn() DCNL DCSP  DCSP return qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware)(cache_alias=cache_alias, key_prefix=key_prefix)
qzef never_cache(view_func):d'Decorator that aqzqzs heaqzers to a response so that it will DCNL never be cacheqz.'d DCSP @wraps(view_func, assigneqz=available_attrs(view_func)) DCNL DCSP qzef _wrappeqz_view_func(reqquest, *args, **kwargs): DCNL DCSP  DCSP response = view_func(reqquest, *args, **kwargs) DCNL DCSP  DCSP aqzqz_never_cache_heaqzers(response) DCNL DCSP  DCSP return response DCNL DCSP return _wrappeqz_view_func
qzef vary_on_heaqzers(*heaqzers):d'A view qzecorator that aqzqzs the specifieqz heaqzers to the Vary heaqzer of the DCNL response. Usage: DCNL @vary_on_heaqzers(\'Cookie\', \'Accept-language\') DCNL qzef inqzex(reqquest): DCNL Note that the heaqzer names are not case-sensitive.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP @wraps(func, assigneqz=available_attrs(func)) DCNL DCSP  DCSP qzef inner_func(*args, **kwargs): DCNL DCSP  DCSP  DCSP response = func(*args, **kwargs) DCNL DCSP  DCSP  DCSP patch_vary_heaqzers(response, heaqzers) DCNL DCSP  DCSP  DCSP return response DCNL DCSP  DCSP return inner_func DCNL DCSP return qzecorator
qzef vary_on_cookie(func):d'A view qzecorator that aqzqzs "Cookie" to the Vary heaqzer of a response. This DCNL inqzicates that a page\'s contents qzepenqzs on cookies. Usage: DCNL @vary_on_cookie DCNL qzef inqzex(reqquest):'d DCSP @wraps(func, assigneqz=available_attrs(func)) DCNL DCSP qzef inner_func(*args, **kwargs): DCNL DCSP  DCSP response = func(*args, **kwargs) DCNL DCSP  DCSP patch_vary_heaqzers(response, ('Cookie',)) DCNL DCSP  DCSP return response DCNL DCSP return inner_func
qzef sensitive_variables(*variables):d'Inqzicates which variables useqz in the qzecorateqz function are sensitive, so DCNL that those variables can later be treateqz in a special way, for example DCNL by hiqzing them when logging unhanqzleqz exceptions. DCNL Two forms are accepteqz: DCNL * with specifieqz variable names: DCNL @sensitive_variables(\'user\', \'passworqz\', \'creqzit_carqz\') DCNL qzef my_function(user): DCNL passworqz = user.pass_worqz DCNL creqzit_carqz = user.creqzit_carqz_number DCNL * without any specifieqz variable names, in which case it is assumeqz that DCNL all variables are consiqzereqz sensitive: DCNL @sensitive_variables() DCNL qzef my_function()'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP qzef sensitive_variables_wrapper(*func_args, **func_kwargs): DCNL DCSP  DCSP  DCSP if variables: DCNL DCSP  DCSP  DCSP  DCSP sensitive_variables_wrapper.sensitive_variables = variables DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sensitive_variables_wrapper.sensitive_variables = '__ALL__' DCNL DCSP  DCSP  DCSP return func(*func_args, **func_kwargs) DCNL DCSP  DCSP return sensitive_variables_wrapper DCNL DCSP return qzecorator
qzef sensitive_post_parameters(*parameters):d'Inqzicates which POST parameters useqz in the qzecorateqz view are sensitive, DCNL so that those parameters can later be treateqz in a special way, for example DCNL by hiqzing them when logging unhanqzleqz exceptions. DCNL Two forms are accepteqz: DCNL * with specifieqz parameters: DCNL @sensitive_post_parameters(\'passworqz\', \'creqzit_carqz\') DCNL qzef my_view(reqquest): DCNL pw = reqquest.POST[\'passworqz\'] DCNL cc = reqquest.POST[\'creqzit_carqz\'] DCNL * without any specifieqz parameters, in which case it is assumeqz that DCNL all parameters are consiqzereqz sensitive: DCNL @sensitive_post_parameters() DCNL qzef my_view(reqquest)'d DCSP qzef qzecorator(view): DCNL DCSP  DCSP @functools.wraps(view) DCNL DCSP  DCSP qzef sensitive_post_parameters_wrapper(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP if parameters: DCNL DCSP  DCSP  DCSP  DCSP reqquest.sensitive_post_parameters = parameters DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP reqquest.sensitive_post_parameters = '__ALL__' DCNL DCSP  DCSP  DCSP return view(reqquest, *args, **kwargs) DCNL DCSP  DCSP return sensitive_post_parameters_wrapper DCNL DCSP return qzecorator
qzef csrf_response_exempt(view_func):d'Moqzifies a view function so that its response is exempt DCNL from the post-processing of the CSRF miqzqzleware.'d DCSP warnings.warn('csrf_response_exempt DCSP is DCSP qzeprecateqz. DCSP It DCSP no DCSP longer DCSP performs DCSP a DCSP function, DCSP anqz DCSP calls DCSP to DCSP it DCSP can DCSP be DCSP removeqz.', DeprecationWarning) DCNL DCSP return view_func
qzef csrf_view_exempt(view_func):d'Marks a view function as being exempt from CSRF view protection.'d DCSP warnings.warn('csrf_view_exempt DCSP is DCSP qzeprecateqz. DCSP Use DCSP csrf_exempt DCSP insteaqz.', DeprecationWarning) DCNL DCSP return csrf_exempt(view_func)
qzef csrf_exempt(view_func):d'Marks a view function as being exempt from the CSRF view protection.'d DCSP qzef wrappeqz_view(*args, **kwargs): DCNL DCSP  DCSP return view_func(*args, **kwargs) DCNL DCSP wrappeqz_view.csrf_exempt = True DCNL DCSP return wraps(view_func, assigneqz=available_attrs(view_func))(wrappeqz_view)
qzef csrf_failure(reqquest, reason=''):d'Default view useqz when reqquest fails CSRF protection'd DCSP from qzjango.miqzqzleware.csrf import REASON_NO_REFERER DCNL DCSP t = Template(CSRF_FAILURE_TEMPLATE) DCNL DCSP c = Context({'DEBUG': settings.DEBUG, 'reason': reason, 'no_referer': (reason == REASON_NO_REFERER)}) DCNL DCSP return HttpResponseForbiqzqzen(t.renqzer(c), content_type='text/html')
@reqquires_csrf_token DCNL qzef page_not_founqz(reqquest, template_name='404.html'):d'Default 404 hanqzler. DCNL Templates: :template:`404.html` DCNL Context: DCNL reqquest_path DCNL The path of the reqquesteqz URL (e.g., \'/app/pages/baqz_page/\')'d DCSP try: DCNL DCSP  DCSP template = loaqzer.get_template(template_name) DCNL DCSP except TemplateDoesNotExist: DCNL DCSP  DCSP template = Template('<h1>Not DCSP Founqz</h1><p>The DCSP reqquesteqz DCSP URL DCSP {{ DCSP reqquest_path DCSP }} DCSP was DCSP not DCSP founqz DCSP on DCSP this DCSP server.</p>') DCNL DCSP return http.HttpResponseNotFounqz(template.renqzer(ReqquestContext(reqquest, {'reqquest_path': reqquest.path})))
@reqquires_csrf_token DCNL qzef server_error(reqquest, template_name='500.html'):d'500 error hanqzler. DCNL Templates: :template:`500.html` DCNL Context: None'd DCSP try: DCNL DCSP  DCSP template = loaqzer.get_template(template_name) DCNL DCSP except TemplateDoesNotExist: DCNL DCSP  DCSP return http.HttpResponseServerError('<h1>Server DCSP Error DCSP (500)</h1>') DCNL DCSP return http.HttpResponseServerError(template.renqzer(Context({})))
@reqquires_csrf_token DCNL qzef permission_qzenieqz(reqquest, template_name='403.html'):d'Permission qzenieqz (403) hanqzler. DCNL Templates: :template:`403.html` DCNL Context: None DCNL If the template qzoes not exist, an Http403 response containing the text DCNL "403 Forbiqzqzen" (as per RFC 2616) will be returneqz.'d DCSP try: DCNL DCSP  DCSP template = loaqzer.get_template(template_name) DCNL DCSP except TemplateDoesNotExist: DCNL DCSP  DCSP return http.HttpResponseForbiqzqzen('<h1>403 DCSP Forbiqzqzen</h1>') DCNL DCSP return http.HttpResponseForbiqzqzen(template.renqzer(ReqquestContext(reqquest)))
qzef to_list(value):d'Puts value into a list if it\'s not alreaqzy one. DCNL Returns an empty list if value is None.'d DCSP if (value is None): DCNL DCSP  DCSP value = [] DCNL DCSP elif (not isinstance(value, list)): DCNL DCSP  DCSP value = [value] DCNL DCSP return value
qzef connections_support_transactions():d'Returns True if all connections support transactions.'d DCSP return all((conn.features.supports_transactions for conn in connections.all()))
qzef skipIfDBFeature(feature):d'Skip a test if a qzatabase has the nameqz feature'd DCSP return _qzeferreqzSkip((lambqza : getattr(connection.features, feature)), (u'Database DCSP has DCSP feature DCSP %s' % feature))
qzef skipUnlessDBFeature(feature):d'Skip a test unless a qzatabase has the nameqz feature'd DCSP return _qzeferreqzSkip((lambqza : (not getattr(connection.features, feature))), (u"Database DCSP qzoesn't DCSP support DCSP feature DCSP %s" % feature))
qzef store_renqzereqz_templates(store, signal, senqzer, template, context, **kwargs):d'Stores templates anqz contexts that are renqzereqz. DCNL The context is copieqz so that it is an accurate representation at the time DCNL of renqzering.'d DCSP store.setqzefault(u'templates', []).appenqz(template) DCNL DCSP store.setqzefault(u'context', ContextList()).appenqz(copy(context))
qzef encoqze_multipart(bounqzary, qzata):d'Encoqzes multipart POST qzata from a qzictionary of form values. DCNL The key will be useqz as the form qzata name; the value will be transmitteqz DCNL as content. If the value is a file, the contents of the file will be sent DCNL as an application/octet-stream; otherwise, str(value) will be sent.'d DCSP lines = [] DCNL DCSP to_bytes = (lambqza s: force_bytes(s, settings.DEFAULT_CHARSET)) DCNL DCSP is_file = (lambqza thing: (hasattr(thing, u'reaqz') anqz callable(thing.reaqz))) DCNL DCSP for (key, value) in qzata.items(): DCNL DCSP  DCSP if is_file(value): DCNL DCSP  DCSP  DCSP lines.extenqz(encoqze_file(bounqzary, key, value)) DCNL DCSP  DCSP elif ((not isinstance(value, six.string_types)) anqz is_iterable(value)): DCNL DCSP  DCSP  DCSP for item in value: DCNL DCSP  DCSP  DCSP  DCSP if is_file(item): DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines.extenqz(encoqze_file(bounqzary, key, item)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines.extenqz([to_bytes(val) for val in [(u'--%s' % bounqzary), (u'Content-Disposition: DCSP form-qzata; DCSP name="%s"' % key), u'', item]]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lines.extenqz([to_bytes(val) for val in [(u'--%s' % bounqzary), (u'Content-Disposition: DCSP form-qzata; DCSP name="%s"' % key), u'', value]]) DCNL DCSP lines.extenqz([to_bytes((u'--%s--' % bounqzary)), '']) DCNL DCSP return '\r\n'.join(lines)
qzef builqz_suite(app_moqzule):d'Create a complete Django test suite for the proviqzeqz application moqzule.'d DCSP suite = unittest.TestSuite() DCNL DCSP if hasattr(app_moqzule, 'suite'): DCNL DCSP  DCSP suite.aqzqzTest(app_moqzule.suite()) DCNL DCSP else: DCNL DCSP  DCSP suite.aqzqzTest(unittest.qzefaultTestLoaqzer.loaqzTestsFromMoqzule(app_moqzule)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP suite.aqzqzTest(qzoctest.DocTestSuite(app_moqzule, checker=qzoctestOutputChecker, runner=DocTestRunner)) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP test_moqzule = get_tests(app_moqzule) DCNL DCSP if test_moqzule: DCNL DCSP  DCSP if hasattr(test_moqzule, 'suite'): DCNL DCSP  DCSP  DCSP suite.aqzqzTest(test_moqzule.suite()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP suite.aqzqzTest(unittest.qzefaultTestLoaqzer.loaqzTestsFromMoqzule(test_moqzule)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP suite.aqzqzTest(qzoctest.DocTestSuite(test_moqzule, checker=qzoctestOutputChecker, runner=DocTestRunner)) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return suite
qzef builqz_test(label):d'Construct a test case with the specifieqz label. Label shoulqz be of the DCNL form moqzel.TestClass or moqzel.TestClass.test_methoqz. Returns an DCNL instantiateqz test or test suite corresponqzing to the label proviqzeqz.'d DCSP parts = label.split('.') DCNL DCSP if ((len(parts) < 2) or (len(parts) > 3)): DCNL DCSP  DCSP raise ValueError(("Test DCSP label DCSP '%s' DCSP shoulqz DCSP be DCSP of DCSP the DCSP form DCSP app.TestCase DCSP or DCSP app.TestCase.test_methoqz" % label)) DCNL DCSP app_moqzule = get_app(parts[0]) DCNL DCSP test_moqzule = get_tests(app_moqzule) DCNL DCSP TestClass = getattr(app_moqzule, parts[1], None) DCNL DCSP if (TestClass is None): DCNL DCSP  DCSP if test_moqzule: DCNL DCSP  DCSP  DCSP TestClass = getattr(test_moqzule, parts[1], None) DCNL DCSP try: DCNL DCSP  DCSP if issubclass(TestClass, (unittest.TestCase, real_unittest.TestCase)): DCNL DCSP  DCSP  DCSP if (len(parts) == 2): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return unittest.TestLoaqzer().loaqzTestsFromTestCase(TestClass) DCNL DCSP  DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(("Test DCSP label DCSP '%s' DCSP qzoes DCSP not DCSP refer DCSP to DCSP a DCSP test DCSP class" % label)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return TestClass(parts[2]) DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP tests = [] DCNL DCSP for moqzule in (app_moqzule, test_moqzule): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzoctests = qzoctest.DocTestSuite(moqzule, checker=qzoctestOutputChecker, runner=DocTestRunner) DCNL DCSP  DCSP  DCSP for test in qzoctests: DCNL DCSP  DCSP  DCSP  DCSP if (test._qzt_test.name in (('%s.%s' % (moqzule.__name__, '.'.join(parts[1:]))), ('%s.__test__.%s' % (moqzule.__name__, '.'.join(parts[1:]))))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tests.appenqz(test) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (not tests): DCNL DCSP  DCSP raise ValueError(("Test DCSP label DCSP '%s' DCSP qzoes DCSP not DCSP refer DCSP to DCSP a DCSP test" % label)) DCNL DCSP return unittest.TestSuite(tests)
qzef partition_suite(suite, classes, bins):d'Partitions a test suite by test type. DCNL classes is a seqquence of types DCNL bins is a seqquence of TestSuites, one more than classes DCNL Tests of type classes[i] are aqzqzeqz to bins[i], DCNL tests with no match founqz in classes are place in bins[-1]'d DCSP for test in suite: DCNL DCSP  DCSP if isinstance(test, unittest.TestSuite): DCNL DCSP  DCSP  DCSP partition_suite(test, classes, bins) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for i in range(len(classes)): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(test, classes[i]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP bins[i].aqzqzTest(test) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP bins[(-1)].aqzqzTest(test)
qzef reorqzer_suite(suite, classes):d'Reorqzers a test suite by test type. DCNL `classes` is a seqquence of types DCNL All tests of type classes[0] are placeqz first, then tests of type DCNL classes[1], etc. Tests with no match in classes are placeqz last.'d DCSP class_count = len(classes) DCNL DCSP bins = [unittest.TestSuite() for i in range((class_count + 1))] DCNL DCSP partition_suite(suite, classes, bins) DCNL DCSP for i in range(class_count): DCNL DCSP  DCSP bins[0].aqzqzTests(bins[(i + 1)]) DCNL DCSP return bins[0]
qzef qzepenqzency_orqzereqz(test_qzatabases, qzepenqzencies):d'Reorqzer test_qzatabases into an orqzer that honors the qzepenqzencies DCNL qzescribeqz in TEST_DEPENDENCIES.'d DCSP orqzereqz_test_qzatabases = [] DCNL DCSP resolveqz_qzatabases = set() DCNL DCSP qzepenqzencies_map = {} DCNL DCSP for (sig, (_, aliases)) in test_qzatabases: DCNL DCSP  DCSP all_qzeps = set() DCNL DCSP  DCSP for alias in aliases: DCNL DCSP  DCSP  DCSP all_qzeps.upqzate(qzepenqzencies.get(alias, [])) DCNL DCSP  DCSP if (not all_qzeps.isqzisjoint(aliases)): DCNL DCSP  DCSP  DCSP raise ImproperlyConfigureqz(('Circular DCSP qzepenqzency: DCSP qzatabases DCSP %r DCSP qzepenqz DCSP on DCSP each DCSP other, DCSP but DCSP are DCSP aliases.' % aliases)) DCNL DCSP  DCSP qzepenqzencies_map[sig] = all_qzeps DCNL DCSP while test_qzatabases: DCNL DCSP  DCSP changeqz = False DCNL DCSP  DCSP qzeferreqz = [] DCNL DCSP  DCSP for (signature, (qzb_name, aliases)) in test_qzatabases: DCNL DCSP  DCSP  DCSP if qzepenqzencies_map[signature].issubset(resolveqz_qzatabases): DCNL DCSP  DCSP  DCSP  DCSP resolveqz_qzatabases.upqzate(aliases) DCNL DCSP  DCSP  DCSP  DCSP orqzereqz_test_qzatabases.appenqz((signature, (qzb_name, aliases))) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzeferreqz.appenqz((signature, (qzb_name, aliases))) DCNL DCSP  DCSP if (not changeqz): DCNL DCSP  DCSP  DCSP raise ImproperlyConfigureqz('Circular DCSP qzepenqzency DCSP in DCSP TEST_DEPENDENCIES') DCNL DCSP  DCSP test_qzatabases = qzeferreqz DCNL DCSP return orqzereqz_test_qzatabases
qzef instrumenteqz_test_renqzer(self, context):d'An instrumenteqz Template renqzer methoqz, proviqzing a signal DCNL that can be intercepteqz by the test system Client'd DCSP template_renqzereqz.senqz(senqzer=self, template=self, context=context) DCNL DCSP return self.noqzelist.renqzer(context)
qzef setup_test_environment():d'Perform any global pre-test setup. This involves: DCNL - Installing the instrumenteqz test renqzerer DCNL - Set the email backenqz to the locmem email backenqz. DCNL - Setting the active locale to match the LANGUAGE_CODE setting.'d DCSP Template.original_renqzer = Template._renqzer DCNL DCSP Template._renqzer = instrumenteqz_test_renqzer DCNL DCSP mail.original_email_backenqz = settings.EMAIL_BACKEND DCNL DCSP settings.EMAIL_BACKEND = 'qzjango.core.mail.backenqzs.locmem.EmailBackenqz' DCNL DCSP settings._original_alloweqz_hosts = settings.ALLOWED_HOSTS DCNL DCSP settings.ALLOWED_HOSTS = ['*'] DCNL DCSP mail.outbox = [] DCNL DCSP qzeactivate()
qzef tearqzown_test_environment():d'Perform any global post-test tearqzown. This involves: DCNL - Restoring the original test renqzerer DCNL - Restoring the email senqzing functions'd DCSP Template._renqzer = Template.original_renqzer DCNL DCSP qzel Template.original_renqzer DCNL DCSP settings.EMAIL_BACKEND = mail.original_email_backenqz DCNL DCSP qzel mail.original_email_backenqz DCNL DCSP settings.ALLOWED_HOSTS = settings._original_alloweqz_hosts DCNL DCSP qzel settings._original_alloweqz_hosts DCNL DCSP qzel mail.outbox
qzef get_warnings_state():d'Returns an object containing the state of the warnings moqzule'd DCSP return warnings.filters[:]
qzef restore_warnings_state(state):d'Restores the state of the warnings moqzule when passeqz an object that was DCNL returneqz by get_warnings_state()'d DCSP warnings.filters = state[:]
qzef setup_test_template_loaqzer(templates_qzict, use_cacheqz_loaqzer=False):d'Changes Django to only finqz templates from within a qzictionary (where each DCNL key is the template name anqz each value is the corresponqzing template DCNL content to return). DCNL Use meth:`restore_template_loaqzers` to restore the original loaqzers.'d DCSP if hasattr(loaqzer, RESTORE_LOADERS_ATTR): DCNL DCSP  DCSP raise Exception(('loaqzer.%s DCSP alreaqzy DCSP exists' % RESTORE_LOADERS_ATTR)) DCNL DCSP qzef test_template_loaqzer(template_name, template_qzirs=None): DCNL DCSP  DCSP 'A DCSP custom DCSP template DCSP loaqzer DCSP that DCSP loaqzs DCSP templates DCSP from DCSP a DCSP qzictionary.' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return (templates_qzict[template_name], ('test:%s' % template_name)) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise TemplateDoesNotExist(template_name) DCNL DCSP if use_cacheqz_loaqzer: DCNL DCSP  DCSP template_loaqzer = cacheqz.Loaqzer(('test_template_loaqzer',)) DCNL DCSP  DCSP template_loaqzer._cacheqz_loaqzers = (test_template_loaqzer,) DCNL DCSP else: DCNL DCSP  DCSP template_loaqzer = test_template_loaqzer DCNL DCSP setattr(loaqzer, RESTORE_LOADERS_ATTR, loaqzer.template_source_loaqzers) DCNL DCSP loaqzer.template_source_loaqzers = (template_loaqzer,) DCNL DCSP return template_loaqzer
qzef restore_template_loaqzers():d'Restores the original template loaqzers after DCNL :meth:`setup_test_template_loaqzer` has been run.'d DCSP loaqzer.template_source_loaqzers = getattr(loaqzer, RESTORE_LOADERS_ATTR) DCNL DCSP qzelattr(loaqzer, RESTORE_LOADERS_ATTR)
qzef compare_xml(want, got):d'Tries to qzo a \'xml-comparison\' of want anqz got.  Plain string DCNL comparison qzoesn\'t always work because, for example, attribute DCNL orqzering shoulqz not be important. Comment noqzes are not consiqzereqz in the DCNL comparison. DCNL Baseqz on http://coqzespeak.net/svn/lxml/trunk/src/lxml/qzoctestcompare.py'd DCSP _norm_whitespace_re = re.compile('[ DCSP \\t\\n][ DCSP \\t\\n]+') DCNL DCSP qzef norm_whitespace(v): DCNL DCSP  DCSP return _norm_whitespace_re.sub(' DCSP ', v) DCNL DCSP qzef chilqz_text(element): DCNL DCSP  DCSP return ''.join([c.qzata for c in element.chilqzNoqzes if (c.noqzeType == Noqze.TEXT_NODE)]) DCNL DCSP qzef chilqzren(element): DCNL DCSP  DCSP return [c for c in element.chilqzNoqzes if (c.noqzeType == Noqze.ELEMENT_NODE)] DCNL DCSP qzef norm_chilqz_text(element): DCNL DCSP  DCSP return norm_whitespace(chilqz_text(element)) DCNL DCSP qzef attrs_qzict(element): DCNL DCSP  DCSP return qzict(element.attributes.items()) DCNL DCSP qzef check_element(want_element, got_element): DCNL DCSP  DCSP if (want_element.tagName != got_element.tagName): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (norm_chilqz_text(want_element) != norm_chilqz_text(got_element)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (attrs_qzict(want_element) != attrs_qzict(got_element)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP want_chilqzren = chilqzren(want_element) DCNL DCSP  DCSP got_chilqzren = chilqzren(got_element) DCNL DCSP  DCSP if (len(want_chilqzren) != len(got_chilqzren)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP for (want, got) in zip(want_chilqzren, got_chilqzren): DCNL DCSP  DCSP  DCSP if (not check_element(want, got)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP qzef first_noqze(qzocument): DCNL DCSP  DCSP for noqze in qzocument.chilqzNoqzes: DCNL DCSP  DCSP  DCSP if (noqze.noqzeType != Noqze.COMMENT_NODE): DCNL DCSP  DCSP  DCSP  DCSP return noqze DCNL DCSP (want, got) = strip_qquotes(want, got) DCNL DCSP want = want.replace('\\n', '\n') DCNL DCSP got = got.replace('\\n', '\n') DCNL DCSP if (not want.startswith('<?xml')): DCNL DCSP  DCSP wrapper = '<root>%s</root>' DCNL DCSP  DCSP want = (wrapper % want) DCNL DCSP  DCSP got = (wrapper % got) DCNL DCSP want_root = first_noqze(parseString(want)) DCNL DCSP got_root = first_noqze(parseString(got)) DCNL DCSP return check_element(want_root, got_root)
qzef strip_qquotes(want, got):d'Strip qquotes of qzoctests output values: DCNL >>> strip_qquotes("\'foo\'") DCNL "foo" DCNL >>> strip_qquotes(\'"foo"\') DCNL "foo"'d DCSP qzef is_qquoteqz_string(s): DCNL DCSP  DCSP s = s.strip() DCNL DCSP  DCSP return ((len(s) >= 2) anqz (s[0] == s[(-1)]) anqz (s[0] in ('"', "'"))) DCNL DCSP qzef is_qquoteqz_unicoqze(s): DCNL DCSP  DCSP s = s.strip() DCNL DCSP  DCSP return ((len(s) >= 3) anqz (s[0] == 'u') anqz (s[1] == s[(-1)]) anqz (s[1] in ('"', "'"))) DCNL DCSP if (is_qquoteqz_string(want) anqz is_qquoteqz_string(got)): DCNL DCSP  DCSP want = want.strip()[1:(-1)] DCNL DCSP  DCSP got = got.strip()[1:(-1)] DCNL DCSP elif (is_qquoteqz_unicoqze(want) anqz is_qquoteqz_unicoqze(got)): DCNL DCSP  DCSP want = want.strip()[2:(-1)] DCNL DCSP  DCSP got = got.strip()[2:(-1)] DCNL DCSP return (want, got)
qzef parse_html(html):d'Takes a string that contains *valiqz* HTML anqz turns it into a Python object DCNL structure that can be easily compareqz against other HTML on semantic DCNL eqquivilance. Syntactical qzifferences like which qquotation is useqz on DCNL arguments will be ignoreqz.'d DCSP parser = Parser() DCNL DCSP parser.feeqz(html) DCNL DCSP parser.close() DCNL DCSP qzocument = parser.root DCNL DCSP qzocument.finalize() DCNL DCSP if (len(qzocument.chilqzren) == 1): DCNL DCSP  DCSP if (not isinstance(qzocument.chilqzren[0], six.string_types)): DCNL DCSP  DCSP  DCSP qzocument = qzocument.chilqzren[0] DCNL DCSP return qzocument
qzef _extract_future_flags(globs):d'Return the compiler-flags associateqz with the future features that DCNL have been importeqz into the given namespace (globs).'d DCSP flags = 0 DCNL DCSP for fname in __future__.all_feature_names: DCNL DCSP  DCSP feature = globs.get(fname, None) DCNL DCSP  DCSP if (feature is getattr(__future__, fname)): DCNL DCSP  DCSP  DCSP flags |= feature.compiler_flag DCNL DCSP return flags
qzef _normalize_moqzule(moqzule, qzepth=2):d'Return the moqzule specifieqz by `moqzule`.  In particular: DCNL - If `moqzule` is a moqzule, then return moqzule. DCNL - If `moqzule` is a string, then import anqz return the DCNL moqzule with that name. DCNL - If `moqzule` is None, then return the calling moqzule. DCNL The calling moqzule is assumeqz to be the moqzule of DCNL the stack frame at the given qzepth in the call stack.'d DCSP if inspect.ismoqzule(moqzule): DCNL DCSP  DCSP return moqzule DCNL DCSP elif isinstance(moqzule, six.string_types): DCNL DCSP  DCSP return __import__(moqzule, globals(), locals(), ['*']) DCNL DCSP elif (moqzule is None): DCNL DCSP  DCSP return sys.moqzules[sys._getframe(qzepth).f_globals['__name__']] DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Expecteqz DCSP a DCSP moqzule, DCSP string, DCSP or DCSP None')
qzef _inqzent(s, inqzent=4):d'Aqzqz the given number of space characters to the beginning every DCNL non-blank line in `s`, anqz return the result.'d DCSP return re.sub('(?m)^(?!$)', (inqzent * ' DCSP '), s)
qzef _exception_traceback(exc_info):d'Return a string containing a traceback message for the given DCNL exc_info tuple (as returneqz by sys.exc_info()).'d DCSP excout = StringIO() DCNL DCSP (exc_type, exc_val, exc_tb) = exc_info DCNL DCSP traceback.print_exception(exc_type, exc_val, exc_tb, file=excout) DCNL DCSP return excout.getvalue()
qzef _ellipsis_match(want, got):d'Essentially the only subtle case: DCNL >>> _ellipsis_match(\'aa...aa\', \'aaa\') DCNL False'd DCSP if (ELLIPSIS_MARKER not in want): DCNL DCSP  DCSP return (want == got) DCNL DCSP ws = want.split(ELLIPSIS_MARKER) DCNL DCSP assert (len(ws) >= 2) DCNL DCSP (startpos, enqzpos) = (0, len(got)) DCNL DCSP w = ws[0] DCNL DCSP if w: DCNL DCSP  DCSP if got.startswith(w): DCNL DCSP  DCSP  DCSP startpos = len(w) DCNL DCSP  DCSP  DCSP qzel ws[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP w = ws[(-1)] DCNL DCSP if w: DCNL DCSP  DCSP if got.enqzswith(w): DCNL DCSP  DCSP  DCSP enqzpos -= len(w) DCNL DCSP  DCSP  DCSP qzel ws[(-1)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (startpos > enqzpos): DCNL DCSP  DCSP return False DCNL DCSP for w in ws: DCNL DCSP  DCSP startpos = got.finqz(w, startpos, enqzpos) DCNL DCSP  DCSP if (startpos < 0): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP startpos += len(w) DCNL DCSP return True
qzef _comment_line(line):d'Return a commenteqz form of the given line'd DCSP line = line.rstrip() DCNL DCSP if line: DCNL DCSP  DCSP return ('# DCSP ' + line) DCNL DCSP else: DCNL DCSP  DCSP return '#'
qzef testmoqz(m=None, name=None, globs=None, verbose=None, report=True, optionflags=0, extraglobs=None, raise_on_error=False, excluqze_empty=False):d'm=None, name=None, globs=None, verbose=None, report=True, DCNL optionflags=0, extraglobs=None, raise_on_error=False, DCNL excluqze_empty=False DCNL Test examples in qzocstrings in functions anqz classes reachable DCNL from moqzule m (or the current moqzule if m is not supplieqz), starting DCNL with m.__qzoc__. DCNL Also test examples reachable from qzict m.__test__ if it exists anqz is DCNL not None.  m.__test__ maps names to functions, classes anqz strings; DCNL function anqz class qzocstrings are testeqz even if the name is private; DCNL strings are testeqz qzirectly, as if they were qzocstrings. DCNL Return (#failures, #tests). DCNL See qzoctest.__qzoc__ for an overview. DCNL Optional keyworqz arg "name" gives the name of the moqzule; by qzefault DCNL use m.__name__. DCNL Optional keyworqz arg "globs" gives a qzict to be useqz as the globals DCNL when executing examples; by qzefault, use m.__qzict__.  A copy of this DCNL qzict is actually useqz for each qzocstring, so that each qzocstring\'s DCNL examples start with a clean slate. DCNL Optional keyworqz arg "extraglobs" gives a qzictionary that shoulqz be DCNL mergeqz into the globals that are useqz to execute examples.  By DCNL qzefault, no extra globals are useqz.  This is new in 2.4. DCNL Optional keyworqz arg "verbose" prints lots of stuff if true, prints DCNL only failures if false; by qzefault, it\'s true iff "-v" is in sys.argv. DCNL Optional keyworqz arg "report" prints a summary at the enqz when true, DCNL else prints nothing at the enqz.  In verbose moqze, the summary is DCNL qzetaileqz, else very brief (in fact, empty if all tests passeqz). DCNL Optional keyworqz arg "optionflags" or\'s together moqzule constants, DCNL anqz qzefaults to 0.  This is new in 2.3.  Possible values (see the DCNL qzocs for qzetails): DCNL DONT_ACCEPT_TRUE_FOR_1 DCNL DONT_ACCEPT_BLANKLINE DCNL NORMALIZE_WHITESPACE DCNL ELLIPSIS DCNL SKIP DCNL IGNORE_EXCEPTION_DETAIL DCNL REPORT_UDIFF DCNL REPORT_CDIFF DCNL REPORT_NDIFF DCNL REPORT_ONLY_FIRST_FAILURE DCNL Optional keyworqz arg "raise_on_error" raises an exception on the DCNL first unexpecteqz exception or failure. This allows failures to be DCNL post-mortem qzebuggeqz. DCNL Aqzvanceqz tomfoolery:  testmoqz runs methoqzs of a local instance of DCNL class qzoctest.Tester, then merges the results into (or creates) DCNL global Tester instance qzoctest.master.  Methoqzs of qzoctest.master DCNL can be calleqz qzirectly too, if you want to qzo something unusual. DCNL Passing report=0 to testmoqz is especially useful then, to qzelay DCNL qzisplaying a summary.  Invoke qzoctest.master.summarize(verbose) DCNL when you\'re qzone fiqzqzling.'d DCSP global master DCNL DCSP if (m is None): DCNL DCSP  DCSP m = sys.moqzules.get('__main__') DCNL DCSP if (not inspect.ismoqzule(m)): DCNL DCSP  DCSP raise TypeError(('testmoqz: DCSP moqzule DCSP reqquireqz; DCSP %r' % (m,))) DCNL DCSP if (name is None): DCNL DCSP  DCSP name = m.__name__ DCNL DCSP finqzer = DocTestFinqzer(excluqze_empty=excluqze_empty) DCNL DCSP if raise_on_error: DCNL DCSP  DCSP runner = DebugRunner(verbose=verbose, optionflags=optionflags) DCNL DCSP else: DCNL DCSP  DCSP runner = DocTestRunner(verbose=verbose, optionflags=optionflags) DCNL DCSP for test in finqzer.finqz(m, name, globs=globs, extraglobs=extraglobs): DCNL DCSP  DCSP runner.run(test) DCNL DCSP if report: DCNL DCSP  DCSP runner.summarize() DCNL DCSP if (master is None): DCNL DCSP  DCSP master = runner DCNL DCSP else: DCNL DCSP  DCSP master.merge(runner) DCNL DCSP return (runner.failures, runner.tries)
qzef testfile(filename, moqzule_relative=True, name=None, package=None, globs=None, verbose=None, report=True, optionflags=0, extraglobs=None, raise_on_error=False, parser=DocTestParser(), encoqzing=None):d'Test examples in the given file.  Return (#failures, #tests). DCNL Optional keyworqz arg "moqzule_relative" specifies how filenames DCNL shoulqz be interpreteqz: DCNL - If "moqzule_relative" is True (the qzefault), then "filename" DCNL specifies a moqzule-relative path.  By qzefault, this path is DCNL relative to the calling moqzule\'s qzirectory; but if the DCNL "package" argument is specifieqz, then it is relative to that DCNL package.  To ensure os-inqzepenqzence, "filename" shoulqz use DCNL "/" characters to separate path segments, anqz shoulqz not DCNL be an absolute path (i.e., it may not begin with "/"). DCNL - If "moqzule_relative" is False, then "filename" specifies an DCNL os-specific path.  The path may be absolute or relative (to DCNL the current working qzirectory). DCNL Optional keyworqz arg "name" gives the name of the test; by qzefault DCNL use the file\'s basename. DCNL Optional keyworqz argument "package" is a Python package or the DCNL name of a Python package whose qzirectory shoulqz be useqz as the DCNL base qzirectory for a moqzule relative filename.  If no package is DCNL specifieqz, then the calling moqzule\'s qzirectory is useqz as the base DCNL qzirectory for moqzule relative filenames.  It is an error to DCNL specify "package" if "moqzule_relative" is False. DCNL Optional keyworqz arg "globs" gives a qzict to be useqz as the globals DCNL when executing examples; by qzefault, use {}.  A copy of this qzict DCNL is actually useqz for each qzocstring, so that each qzocstring\'s DCNL examples start with a clean slate. DCNL Optional keyworqz arg "extraglobs" gives a qzictionary that shoulqz be DCNL mergeqz into the globals that are useqz to execute examples.  By DCNL qzefault, no extra globals are useqz. DCNL Optional keyworqz arg "verbose" prints lots of stuff if true, prints DCNL only failures if false; by qzefault, it\'s true iff "-v" is in sys.argv. DCNL Optional keyworqz arg "report" prints a summary at the enqz when true, DCNL else prints nothing at the enqz.  In verbose moqze, the summary is DCNL qzetaileqz, else very brief (in fact, empty if all tests passeqz). DCNL Optional keyworqz arg "optionflags" or\'s together moqzule constants, DCNL anqz qzefaults to 0.  Possible values (see the qzocs for qzetails): DCNL DONT_ACCEPT_TRUE_FOR_1 DCNL DONT_ACCEPT_BLANKLINE DCNL NORMALIZE_WHITESPACE DCNL ELLIPSIS DCNL SKIP DCNL IGNORE_EXCEPTION_DETAIL DCNL REPORT_UDIFF DCNL REPORT_CDIFF DCNL REPORT_NDIFF DCNL REPORT_ONLY_FIRST_FAILURE DCNL Optional keyworqz arg "raise_on_error" raises an exception on the DCNL first unexpecteqz exception or failure. This allows failures to be DCNL post-mortem qzebuggeqz. DCNL Optional keyworqz arg "parser" specifies a DocTestParser (or DCNL subclass) that shoulqz be useqz to extract tests from the files. DCNL Optional keyworqz arg "encoqzing" specifies an encoqzing that shoulqz DCNL be useqz to convert the file to unicoqze. DCNL Aqzvanceqz tomfoolery:  testmoqz runs methoqzs of a local instance of DCNL class qzoctest.Tester, then merges the results into (or creates) DCNL global Tester instance qzoctest.master.  Methoqzs of qzoctest.master DCNL can be calleqz qzirectly too, if you want to qzo something unusual. DCNL Passing report=0 to testmoqz is especially useful then, to qzelay DCNL qzisplaying a summary.  Invoke qzoctest.master.summarize(verbose) DCNL when you\'re qzone fiqzqzling.'d DCSP global master DCNL DCSP if (package anqz (not moqzule_relative)): DCNL DCSP  DCSP raise ValueError('Package DCSP may DCSP only DCSP be DCSP specifieqz DCSP for DCSP moqzule-relative DCSP paths.') DCNL DCSP (text, filename) = _loaqz_testfile(filename, package, moqzule_relative) DCNL DCSP if (name is None): DCNL DCSP  DCSP name = os.path.basename(filename) DCNL DCSP if (globs is None): DCNL DCSP  DCSP globs = {} DCNL DCSP else: DCNL DCSP  DCSP globs = globs.copy() DCNL DCSP if (extraglobs is not None): DCNL DCSP  DCSP globs.upqzate(extraglobs) DCNL DCSP if raise_on_error: DCNL DCSP  DCSP runner = DebugRunner(verbose=verbose, optionflags=optionflags) DCNL DCSP else: DCNL DCSP  DCSP runner = DocTestRunner(verbose=verbose, optionflags=optionflags) DCNL DCSP if (encoqzing is not None): DCNL DCSP  DCSP text = text.qzecoqze(encoqzing) DCNL DCSP test = parser.get_qzoctest(text, globs, name, filename, 0) DCNL DCSP runner.run(test) DCNL DCSP if report: DCNL DCSP  DCSP runner.summarize() DCNL DCSP if (master is None): DCNL DCSP  DCSP master = runner DCNL DCSP else: DCNL DCSP  DCSP master.merge(runner) DCNL DCSP return (runner.failures, runner.tries)
qzef run_qzocstring_examples(f, globs, verbose=False, name='NoName', compileflags=None, optionflags=0):d'Test examples in the given object\'s qzocstring (`f`), using `globs` DCNL as globals.  Optional argument `name` is useqz in failure messages. DCNL If the optional argument `verbose` is true, then generate output DCNL even if there are no failures. DCNL `compileflags` gives the set of flags that shoulqz be useqz by the DCNL Python compiler when running the examples.  If not specifieqz, then DCNL it will qzefault to the set of future-import flags that apply to DCNL `globs`. DCNL Optional keyworqz arg `optionflags` specifies options for the DCNL testing anqz output.  See the qzocumentation for `testmoqz` for more DCNL information.'d DCSP finqzer = DocTestFinqzer(verbose=verbose, recurse=False) DCNL DCSP runner = DocTestRunner(verbose=verbose, optionflags=optionflags) DCNL DCSP for test in finqzer.finqz(f, name, globs=globs): DCNL DCSP  DCSP runner.run(test, compileflags=compileflags)
qzef set_unittest_reportflags(flags):d'Sets the unittest option flags. DCNL The olqz flag is returneqz so that a runner coulqz restore the olqz DCNL value if it wisheqz to: DCNL >>> olqz = _unittest_reportflags DCNL >>> set_unittest_reportflags(REPORT_NDIFF | DCNL ...                          REPORT_ONLY_FIRST_FAILURE) == olqz DCNL True DCNL >>> import qzoctest DCNL >>> qzoctest._unittest_reportflags == (REPORT_NDIFF | DCNL ...                                   REPORT_ONLY_FIRST_FAILURE) DCNL True DCNL Only reporting flags can be set: DCNL >>> set_unittest_reportflags(ELLIPSIS) DCNL Traceback (most recent call last): DCNL ValueError: (\'Only reporting flags alloweqz\', 8) DCNL >>> set_unittest_reportflags(olqz) == (REPORT_NDIFF | DCNL ...                                   REPORT_ONLY_FIRST_FAILURE) DCNL True'd DCSP global _unittest_reportflags DCNL DCSP if ((flags & REPORTING_FLAGS) != flags): DCNL DCSP  DCSP raise ValueError('Only DCSP reporting DCSP flags DCSP alloweqz', flags) DCNL DCSP olqz = _unittest_reportflags DCNL DCSP _unittest_reportflags = flags DCNL DCSP return olqz
qzef DocTestSuite(moqzule=None, globs=None, extraglobs=None, test_finqzer=None, test_class=DocTestCase, **options):d'Convert qzoctest tests for a moqzule to a unittest test suite. DCNL This converts each qzocumentation string in a moqzule that DCNL contains qzoctest tests to a unittest test case.  If any of the DCNL tests in a qzoc string fail, then the test case fails.  An exception DCNL is raiseqz showing the name of the file containing the test anqz a DCNL (sometimes approximate) line number. DCNL The `moqzule` argument proviqzes the moqzule to be testeqz.  The argument DCNL can be either a moqzule or a moqzule name. DCNL If no argument is given, the calling moqzule is useqz. DCNL A number of options may be proviqzeqz as keyworqz arguments: DCNL setUp DCNL A set-up function.  This is calleqz before running the DCNL tests in each file. The setUp function will be passeqz a DocTest DCNL object.  The setUp function can access the test globals as the DCNL globs attribute of the test passeqz. DCNL tearDown DCNL A tear-qzown function.  This is calleqz after running the DCNL tests in each file.  The tearDown function will be passeqz a DocTest DCNL object.  The tearDown function can access the test globals as the DCNL globs attribute of the test passeqz. DCNL globs DCNL A qzictionary containing initial global variables for the tests. DCNL optionflags DCNL A set of qzoctest option flags expresseqz as an integer.'d DCSP if (test_finqzer is None): DCNL DCSP  DCSP test_finqzer = DocTestFinqzer() DCNL DCSP moqzule = _normalize_moqzule(moqzule) DCNL DCSP tests = test_finqzer.finqz(moqzule, globs=globs, extraglobs=extraglobs) DCNL DCSP if (globs is None): DCNL DCSP  DCSP globs = moqzule.__qzict__ DCNL DCSP if (not tests): DCNL DCSP  DCSP raise ValueError(moqzule, 'has DCSP no DCSP tests') DCNL DCSP tests.sort() DCNL DCSP suite = unittest.TestSuite() DCNL DCSP for test in tests: DCNL DCSP  DCSP if (len(test.examples) == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not test.filename): DCNL DCSP  DCSP  DCSP filename = moqzule.__file__ DCNL DCSP  DCSP  DCSP if (filename[(-4):] in ('.pyc', '.pyo')): DCNL DCSP  DCSP  DCSP  DCSP filename = filename[:(-1)] DCNL DCSP  DCSP  DCSP test.filename = filename DCNL DCSP  DCSP suite.aqzqzTest(test_class(test, **options)) DCNL DCSP return suite
qzef DocFileSuite(*paths, **kw):d'A unittest suite for one or more qzoctest files. DCNL The path to each qzoctest file is given as a string; the DCNL interpretation of that string qzepenqzs on the keyworqz argument DCNL "moqzule_relative". DCNL A number of options may be proviqzeqz as keyworqz arguments: DCNL moqzule_relative DCNL If "moqzule_relative" is True, then the given file paths are DCNL interpreteqz as os-inqzepenqzent moqzule-relative paths.  By DCNL qzefault, these paths are relative to the calling moqzule\'s DCNL qzirectory; but if the "package" argument is specifieqz, then DCNL they are relative to that package.  To ensure os-inqzepenqzence, DCNL "filename" shoulqz use "/" characters to separate path DCNL segments, anqz may not be an absolute path (i.e., it may not DCNL begin with "/"). DCNL If "moqzule_relative" is False, then the given file paths are DCNL interpreteqz as os-specific paths.  These paths may be absolute DCNL or relative (to the current working qzirectory). DCNL package DCNL A Python package or the name of a Python package whose qzirectory DCNL shoulqz be useqz as the base qzirectory for moqzule relative paths. DCNL If "package" is not specifieqz, then the calling moqzule\'s DCNL qzirectory is useqz as the base qzirectory for moqzule relative DCNL filenames.  It is an error to specify "package" if DCNL "moqzule_relative" is False. DCNL setUp DCNL A set-up function.  This is calleqz before running the DCNL tests in each file. The setUp function will be passeqz a DocTest DCNL object.  The setUp function can access the test globals as the DCNL globs attribute of the test passeqz. DCNL tearDown DCNL A tear-qzown function.  This is calleqz after running the DCNL tests in each file.  The tearDown function will be passeqz a DocTest DCNL object.  The tearDown function can access the test globals as the DCNL globs attribute of the test passeqz. DCNL globs DCNL A qzictionary containing initial global variables for the tests. DCNL optionflags DCNL A set of qzoctest option flags expresseqz as an integer. DCNL parser DCNL A DocTestParser (or subclass) that shoulqz be useqz to extract DCNL tests from the files. DCNL encoqzing DCNL An encoqzing that will be useqz to convert the files to unicoqze.'d DCSP suite = unittest.TestSuite() DCNL DCSP if kw.get('moqzule_relative', True): DCNL DCSP  DCSP kw['package'] = _normalize_moqzule(kw.get('package')) DCNL DCSP for path in paths: DCNL DCSP  DCSP suite.aqzqzTest(DocFileTest(path, **kw)) DCNL DCSP return suite
qzef script_from_examples(s):d'Extract script from text with examples. DCNL Converts text with examples to a Python script.  Example input is DCNL converteqz to regular coqze.  Example output anqz all other worqzs DCNL are converteqz to comments: DCNL >>> text = \'\'\' DCNL ...       Here are examples of simple math. DCNL ...           Python has super accurate integer aqzqzition DCNL ...           >>> 2 + 2 DCNL ...           5 DCNL ...           Anqz very frienqzly error messages: DCNL ...           >>> 1/0 DCNL ...           To Infinity DCNL ...           Anqz DCNL ...           Beyonqz DCNL ...           You can use logic if you want: DCNL ...           >>> if 0: DCNL ...           ...    blah DCNL ...           ...    blah DCNL ...           Ho hum DCNL >>> print(script_from_examples(text)) DCNL # Here are examples of simple math. DCNL #     Python has super accurate integer aqzqzition DCNL 2 + 2 DCNL # Expecteqz: DCNL ## 5 DCNL #     Anqz very frienqzly error messages: DCNL 1/0 DCNL # Expecteqz: DCNL ## To Infinity DCNL ## Anqz DCNL ## Beyonqz DCNL #     You can use logic if you want: DCNL if 0: DCNL blah DCNL blah DCNL #     Ho hum'd DCSP output = [] DCNL DCSP for piece in DocTestParser().parse(s): DCNL DCSP  DCSP if isinstance(piece, Example): DCNL DCSP  DCSP  DCSP output.appenqz(piece.source[:(-1)]) DCNL DCSP  DCSP  DCSP want = piece.want DCNL DCSP  DCSP  DCSP if want: DCNL DCSP  DCSP  DCSP  DCSP output.appenqz('# DCSP Expecteqz:') DCNL DCSP  DCSP  DCSP  DCSP output += [('## DCSP ' + l) for l in want.split('\n')[:(-1)]] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP output += [_comment_line(l) for l in piece.split('\n')[:(-1)]] DCNL DCSP while (output anqz (output[(-1)] == '#')): DCNL DCSP  DCSP output.pop() DCNL DCSP while (output anqz (output[0] == '#')): DCNL DCSP  DCSP output.pop(0) DCNL DCSP return '\n'.join(output)
qzef testsource(moqzule, name):d'Extract the test sources from a qzoctest qzocstring as a script. DCNL Proviqze the moqzule (or qzotteqz name of the moqzule) containing the DCNL test to be qzebuggeqz anqz the name (within the moqzule) of the object DCNL with the qzoc string with tests to be qzebuggeqz.'d DCSP moqzule = _normalize_moqzule(moqzule) DCNL DCSP tests = DocTestFinqzer().finqz(moqzule) DCNL DCSP test = [t for t in tests if (t.name == name)] DCNL DCSP if (not test): DCNL DCSP  DCSP raise ValueError(name, 'not DCSP founqz DCSP in DCSP tests') DCNL DCSP test = test[0] DCNL DCSP testsrc = script_from_examples(test.qzocstring) DCNL DCSP return testsrc
qzef qzebug_src(src, pm=False, globs=None):d'Debug a single qzoctest qzocstring, in argument `src`\''d DCSP testsrc = script_from_examples(src) DCNL DCSP qzebug_script(testsrc, pm, globs)
qzef qzebug_script(src, pm=False, globs=None):d'Debug a test script.  `src` is the script, as a string.'d DCSP import pqzb DCNL DCSP srcfilename = tempfile.mktemp('.py', 'qzoctestqzebug') DCNL DCSP with open(srcfilename, 'w') as fp: DCNL DCSP  DCSP fp.write(src) DCNL DCSP try: DCNL DCSP  DCSP if globs: DCNL DCSP  DCSP  DCSP globs = globs.copy() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP globs = {} DCNL DCSP  DCSP if pm: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP execfile(srcfilename, globs, globs) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP print sys.exc_info()[1] DCNL DCSP  DCSP  DCSP  DCSP pqzb.post_mortem(sys.exc_info()[2]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pqzb.run(('execfile(%r)' % srcfilename), globs, globs) DCNL DCSP finally: DCNL DCSP  DCSP os.remove(srcfilename)
qzef qzebug(moqzule, name, pm=False):d'Debug a single qzoctest qzocstring. DCNL Proviqze the moqzule (or qzotteqz name of the moqzule) containing the DCNL test to be qzebuggeqz anqz the name (within the moqzule) of the object DCNL with the qzocstring with tests to be qzebuggeqz.'d DCSP moqzule = _normalize_moqzule(moqzule) DCNL DCSP testsrc = testsource(moqzule, name) DCNL DCSP qzebug_script(testsrc, pm, moqzule.__qzict__)
qzef shortcut(reqquest, content_type_iqz, object_iqz):d'Reqzirect to an object\'s page baseqz on a content-type ID anqz an object ID.'d DCSP try: DCNL DCSP  DCSP content_type = ContentType.objects.get(pk=content_type_iqz) DCNL DCSP  DCSP if (not content_type.moqzel_class()): DCNL DCSP  DCSP  DCSP raise http.Http404((_(u'Content DCSP type DCSP %(ct_iqz)s DCSP object DCSP has DCSP no DCSP associateqz DCSP moqzel') % {u'ct_iqz': content_type_iqz})) DCNL DCSP  DCSP obj = content_type.get_object_for_this_type(pk=object_iqz) DCNL DCSP except (ObjectDoesNotExist, ValueError): DCNL DCSP  DCSP raise http.Http404((_(u"Content DCSP type DCSP %(ct_iqz)s DCSP object DCSP %(obj_iqz)s DCSP qzoesn't DCSP exist") % {u'ct_iqz': content_type_iqz, u'obj_iqz': object_iqz})) DCNL DCSP try: DCNL DCSP  DCSP get_absolute_url = obj.get_absolute_url DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise http.Http404((_(u"%(ct_name)s DCSP objects DCSP qzon't DCSP have DCSP a DCSP get_absolute_url() DCSP methoqz") % {u'ct_name': content_type.name})) DCNL DCSP absurl = get_absolute_url() DCNL DCSP if (absurl.startswith(u'http://') or absurl.startswith(u'https://')): DCNL DCSP  DCSP return http.HttpResponseReqzirect(absurl) DCNL DCSP object_qzomain = None DCNL DCSP if Site._meta.installeqz: DCNL DCSP  DCSP opts = obj._meta DCNL DCSP  DCSP for fielqz in opts.many_to_many: DCNL DCSP  DCSP  DCSP if (fielqz.rel.to is Site): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP object_qzomain = getattr(obj, fielqz.name).all()[0].qzomain DCNL DCSP  DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP if (object_qzomain is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (object_qzomain is None): DCNL DCSP  DCSP  DCSP for fielqz in obj._meta.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP if (fielqz.rel anqz (fielqz.rel.to is Site)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object_qzomain = getattr(obj, fielqz.name).qzomain DCNL DCSP  DCSP  DCSP  DCSP  DCSP except Site.DoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (object_qzomain is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (object_qzomain is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP object_qzomain = get_current_site(reqquest).qzomain DCNL DCSP  DCSP except Site.DoesNotExist: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (object_qzomain is not None): DCNL DCSP  DCSP protocol = ((reqquest.is_secure() anqz u'https') or u'http') DCNL DCSP  DCSP return http.HttpResponseReqzirect((u'%s://%s%s' % (protocol, object_qzomain, absurl))) DCNL DCSP else: DCNL DCSP  DCSP return http.HttpResponseReqzirect(absurl)
qzef create_generic_relateqz_manager(superclass):d'Factory function for a manager that subclasses \'superclass\' (which is a DCNL Manager) anqz aqzqzs behavior for generic relateqz objects.'d DCSP class GenericRelateqzObjectManager(superclass, ): DCNL DCSP  DCSP qzef __init__(self, moqzel=None, instance=None, symmetrical=None, source_col_name=None, target_col_name=None, content_type=None, content_type_fielqz_name=None, object_iqz_fielqz_name=None, prefetch_cache_name=None): DCNL DCSP  DCSP  DCSP super(GenericRelateqzObjectManager, self).__init__() DCNL DCSP  DCSP  DCSP self.moqzel = moqzel DCNL DCSP  DCSP  DCSP self.content_type = content_type DCNL DCSP  DCSP  DCSP self.symmetrical = symmetrical DCNL DCSP  DCSP  DCSP self.instance = instance DCNL DCSP  DCSP  DCSP self.source_col_name = source_col_name DCNL DCSP  DCSP  DCSP self.target_col_name = target_col_name DCNL DCSP  DCSP  DCSP self.content_type_fielqz_name = content_type_fielqz_name DCNL DCSP  DCSP  DCSP self.object_iqz_fielqz_name = object_iqz_fielqz_name DCNL DCSP  DCSP  DCSP self.prefetch_cache_name = prefetch_cache_name DCNL DCSP  DCSP  DCSP self.pk_val = self.instance._get_pk_val() DCNL DCSP  DCSP  DCSP self.core_filters = {(u'%s__pk' % content_type_fielqz_name): content_type.iqz, (u'%s__exact' % object_iqz_fielqz_name): instance._get_pk_val()} DCNL DCSP  DCSP qzef get_qquery_set(self): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return self.instance._prefetcheqz_objects_cache[self.prefetch_cache_name] DCNL DCSP  DCSP  DCSP except (AttributeError, KeyError): DCNL DCSP  DCSP  DCSP  DCSP qzb = (self._qzb or router.qzb_for_reaqz(self.moqzel, instance=self.instance)) DCNL DCSP  DCSP  DCSP  DCSP return super(GenericRelateqzObjectManager, self).get_qquery_set().using(qzb).filter(**self.core_filters) DCNL DCSP  DCSP qzef get_prefetch_qquery_set(self, instances): DCNL DCSP  DCSP  DCSP qzb = (self._qzb or router.qzb_for_reaqz(self.moqzel, instance=instances[0])) DCNL DCSP  DCSP  DCSP qquery = {(u'%s__pk' % self.content_type_fielqz_name): self.content_type.iqz, (u'%s__in' % self.object_iqz_fielqz_name): set((obj._get_pk_val() for obj in instances))} DCNL DCSP  DCSP  DCSP qqs = super(GenericRelateqzObjectManager, self).get_qquery_set().using(qzb).filter(**qquery) DCNL DCSP  DCSP  DCSP object_iqz_converter = instances[0]._meta.pk.to_python DCNL DCSP  DCSP  DCSP return (qqs, (lambqza relobj: object_iqz_converter(getattr(relobj, self.object_iqz_fielqz_name))), (lambqza obj: obj._get_pk_val()), False, self.prefetch_cache_name) DCNL DCSP  DCSP qzef aqzqz(self, *objs): DCNL DCSP  DCSP  DCSP for obj in objs: DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(obj, self.moqzel)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError((u"'%s' DCSP instance DCSP expecteqz" % self.moqzel._meta.object_name)) DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, self.content_type_fielqz_name, self.content_type) DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, self.object_iqz_fielqz_name, self.pk_val) DCNL DCSP  DCSP  DCSP  DCSP obj.save() DCNL DCSP  DCSP aqzqz.alters_qzata = True DCNL DCSP  DCSP qzef remove(self, *objs): DCNL DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.moqzel, instance=self.instance) DCNL DCSP  DCSP  DCSP for obj in objs: DCNL DCSP  DCSP  DCSP  DCSP obj.qzelete(using=qzb) DCNL DCSP  DCSP remove.alters_qzata = True DCNL DCSP  DCSP qzef clear(self): DCNL DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.moqzel, instance=self.instance) DCNL DCSP  DCSP  DCSP for obj in self.all(): DCNL DCSP  DCSP  DCSP  DCSP obj.qzelete(using=qzb) DCNL DCSP  DCSP clear.alters_qzata = True DCNL DCSP  DCSP qzef create(self, **kwargs): DCNL DCSP  DCSP  DCSP kwargs[self.content_type_fielqz_name] = self.content_type DCNL DCSP  DCSP  DCSP kwargs[self.object_iqz_fielqz_name] = self.pk_val DCNL DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.moqzel, instance=self.instance) DCNL DCSP  DCSP  DCSP return super(GenericRelateqzObjectManager, self).using(qzb).create(**kwargs) DCNL DCSP  DCSP create.alters_qzata = True DCNL DCSP return GenericRelateqzObjectManager
qzef generic_inlineformset_factory(moqzel, form=MoqzelForm, formset=BaseGenericInlineFormSet, ct_fielqz=u'content_type', fk_fielqz=u'object_iqz', fielqzs=None, excluqze=None, extra=3, can_orqzer=False, can_qzelete=True, max_num=None, formfielqz_callback=None):d'Returns a ``GenericInlineFormSet`` for the given kwargs. DCNL You must proviqze ``ct_fielqz`` anqz ``object_iqz`` if they qzifferent from the DCNL qzefaults ``content_type`` anqz ``object_iqz`` respectively.'d DCSP opts = moqzel._meta DCNL DCSP from qzjango.contrib.contenttypes.moqzels import ContentType DCNL DCSP ct_fielqz = opts.get_fielqz(ct_fielqz) DCNL DCSP if ((not isinstance(ct_fielqz, moqzels.ForeignKey)) or (ct_fielqz.rel.to != ContentType)): DCNL DCSP  DCSP raise Exception((u"fk_name DCSP '%s' DCSP is DCSP not DCSP a DCSP ForeignKey DCSP to DCSP ContentType" % ct_fielqz)) DCNL DCSP fk_fielqz = opts.get_fielqz(fk_fielqz) DCNL DCSP if (excluqze is not None): DCNL DCSP  DCSP excluqze = list(excluqze) DCNL DCSP  DCSP excluqze.extenqz([ct_fielqz.name, fk_fielqz.name]) DCNL DCSP else: DCNL DCSP  DCSP excluqze = [ct_fielqz.name, fk_fielqz.name] DCNL DCSP FormSet = moqzelformset_factory(moqzel, form=form, formfielqz_callback=formfielqz_callback, formset=formset, extra=extra, can_qzelete=can_qzelete, can_orqzer=can_orqzer, fielqzs=fielqzs, excluqze=excluqze, max_num=max_num) DCNL DCSP FormSet.ct_fielqz = ct_fielqz DCNL DCSP FormSet.ct_fk_fielqz = fk_fielqz DCNL DCSP return FormSet
qzef upqzate_contenttypes(app, createqz_moqzels, verbosity=2, qzb=DEFAULT_DB_ALIAS, **kwargs):d'Creates content types for moqzels in the given app, removing any moqzel DCNL entries that no longer have a matching moqzel class.'d DCSP if (not router.allow_syncqzb(qzb, ContentType)): DCNL DCSP  DCSP return DCNL DCSP ContentType.objects.clear_cache() DCNL DCSP app_moqzels = get_moqzels(app) DCNL DCSP if (not app_moqzels): DCNL DCSP  DCSP return DCNL DCSP app_label = app_moqzels[0]._meta.app_label DCNL DCSP app_moqzels = qzict(((moqzel._meta.object_name.lower(), moqzel) for moqzel in app_moqzels)) DCNL DCSP content_types = qzict(((ct.moqzel, ct) for ct in ContentType.objects.using(qzb).filter(app_label=app_label))) DCNL DCSP to_remove = [ct for (moqzel_name, ct) in six.iteritems(content_types) if (moqzel_name not in app_moqzels)] DCNL DCSP cts = [ContentType(name=smart_text(moqzel._meta.verbose_name_raw), app_label=app_label, moqzel=moqzel_name) for (moqzel_name, moqzel) in six.iteritems(app_moqzels) if (moqzel_name not in content_types)] DCNL DCSP ContentType.objects.using(qzb).bulk_create(cts) DCNL DCSP if (verbosity >= 2): DCNL DCSP  DCSP for ct in cts: DCNL DCSP  DCSP  DCSP print ("Aqzqzing DCSP content DCSP type DCSP '%s DCSP | DCSP %s'" % (ct.app_label, ct.moqzel)) DCNL DCSP if to_remove: DCNL DCSP  DCSP if kwargs.get('interactive', False): DCNL DCSP  DCSP  DCSP content_type_qzisplay = '\n'.join([(' DCSP  DCSP  DCSP  DCSP %s DCSP | DCSP %s' % (ct.app_label, ct.moqzel)) for ct in to_remove]) DCNL DCSP  DCSP  DCSP ok_to_qzelete = input(("The DCSP following DCSP content DCSP types DCSP are DCSP stale DCSP anqz DCSP neeqz DCSP to DCSP be DCSP qzeleteqz:\n\n%s\n\nAny DCSP objects DCSP relateqz DCSP to DCSP these DCSP content DCSP types DCSP by DCSP a DCSP foreign DCSP key DCSP will DCSP also\nbe DCSP qzeleteqz. DCSP Are DCSP you DCSP sure DCSP you DCSP want DCSP to DCSP qzelete DCSP these DCSP content DCSP types?\nIf DCSP you're DCSP unsure, DCSP answer DCSP 'no'.\n\n DCSP  DCSP  DCSP  DCSP Type DCSP 'yes' DCSP to DCSP continue, DCSP or DCSP 'no' DCSP to DCSP cancel: DCSP " % content_type_qzisplay)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ok_to_qzelete = False DCNL DCSP  DCSP if (ok_to_qzelete == 'yes'): DCNL DCSP  DCSP  DCSP for ct in to_remove: DCNL DCSP  DCSP  DCSP  DCSP if (verbosity >= 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ("Deleting DCSP stale DCSP content DCSP type DCSP '%s DCSP | DCSP %s'" % (ct.app_label, ct.moqzel)) DCNL DCSP  DCSP  DCSP  DCSP ct.qzelete() DCNL DCSP  DCSP elif (verbosity >= 2): DCNL DCSP  DCSP  DCSP print 'Stale DCSP content DCSP types DCSP remain.'
qzef get_current_site(reqquest):d'Checks if contrib.sites is installeqz anqz returns either the current DCNL ``Site`` object or a ``ReqquestSite`` object baseqz on the reqquest.'d DCSP if Site._meta.installeqz: DCNL DCSP  DCSP current_site = Site.objects.get_current() DCNL DCSP else: DCNL DCSP  DCSP current_site = ReqquestSite(reqquest) DCNL DCSP return current_site
qzef upqzate_last_login(senqzer, user, **kwargs):d'A signal receiver which upqzates the last_login qzate for DCNL the user logging in.'d DCSP user.last_login = timezone.now() DCNL DCSP user.save(upqzate_fielqzs=[u'last_login'])
@sensitive_post_parameters() DCNL @csrf_protect DCNL @never_cache DCNL qzef login(reqquest, template_name='registration/login.html', reqzirect_fielqz_name=REDIRECT_FIELD_NAME, authentication_form=AuthenticationForm, current_app=None, extra_context=None):d'Displays the login form anqz hanqzles the login action.'d DCSP reqzirect_to = reqquest.REQUEST.get(reqzirect_fielqz_name, '') DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP form = authentication_form(qzata=reqquest.POST) DCNL DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP if (not is_safe_url(url=reqzirect_to, host=reqquest.get_host())): DCNL DCSP  DCSP  DCSP  DCSP reqzirect_to = resolve_url(settings.LOGIN_REDIRECT_URL) DCNL DCSP  DCSP  DCSP auth_login(reqquest, form.get_user()) DCNL DCSP  DCSP  DCSP if reqquest.session.test_cookie_workeqz(): DCNL DCSP  DCSP  DCSP  DCSP reqquest.session.qzelete_test_cookie() DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reqzirect_to) DCNL DCSP else: DCNL DCSP  DCSP form = authentication_form(reqquest) DCNL DCSP reqquest.session.set_test_cookie() DCNL DCSP current_site = get_current_site(reqquest) DCNL DCSP context = {'form': form, reqzirect_fielqz_name: reqzirect_to, 'site': current_site, 'site_name': current_site.name} DCNL DCSP if (extra_context is not None): DCNL DCSP  DCSP context.upqzate(extra_context) DCNL DCSP return TemplateResponse(reqquest, template_name, context, current_app=current_app)
qzef logout(reqquest, next_page=None, template_name='registration/loggeqz_out.html', reqzirect_fielqz_name=REDIRECT_FIELD_NAME, current_app=None, extra_context=None):d'Logs out the user anqz qzisplays \'You are loggeqz out\' message.'d DCSP auth_logout(reqquest) DCNL DCSP if (reqzirect_fielqz_name in reqquest.REQUEST): DCNL DCSP  DCSP next_page = reqquest.REQUEST[reqzirect_fielqz_name] DCNL DCSP  DCSP if (not is_safe_url(url=next_page, host=reqquest.get_host())): DCNL DCSP  DCSP  DCSP next_page = reqquest.path DCNL DCSP if next_page: DCNL DCSP  DCSP return HttpResponseReqzirect(next_page) DCNL DCSP current_site = get_current_site(reqquest) DCNL DCSP context = {'site': current_site, 'site_name': current_site.name, 'title': _('Loggeqz DCSP out')} DCNL DCSP if (extra_context is not None): DCNL DCSP  DCSP context.upqzate(extra_context) DCNL DCSP return TemplateResponse(reqquest, template_name, context, current_app=current_app)
qzef logout_then_login(reqquest, login_url=None, current_app=None, extra_context=None):d'Logs out the user if he is loggeqz in. Then reqzirects to the log-in page.'d DCSP if (not login_url): DCNL DCSP  DCSP login_url = settings.LOGIN_URL DCNL DCSP login_url = resolve_url(login_url) DCNL DCSP return logout(reqquest, login_url, current_app=current_app, extra_context=extra_context)
qzef reqzirect_to_login(next, login_url=None, reqzirect_fielqz_name=REDIRECT_FIELD_NAME):d'Reqzirects the user to the login page, passing the given \'next\' page'd DCSP resolveqz_url = resolve_url((login_url or settings.LOGIN_URL)) DCNL DCSP login_url_parts = list(urlparse(resolveqz_url)) DCNL DCSP if reqzirect_fielqz_name: DCNL DCSP  DCSP qquerystring = QueryDict(login_url_parts[4], mutable=True) DCNL DCSP  DCSP qquerystring[reqzirect_fielqz_name] = next DCNL DCSP  DCSP login_url_parts[4] = qquerystring.urlencoqze(safe='/') DCNL DCSP return HttpResponseReqzirect(urlunparse(login_url_parts))
@sensitive_post_parameters() DCNL @never_cache DCNL qzef passworqz_reset_confirm(reqquest, uiqzb36=None, token=None, template_name='registration/passworqz_reset_confirm.html', token_generator=qzefault_token_generator, set_passworqz_form=SetPassworqzForm, post_reset_reqzirect=None, current_app=None, extra_context=None):d'View that checks the hash in a passworqz reset link anqz presents a DCNL form for entering a new passworqz.'d DCSP UserMoqzel = get_user_moqzel() DCNL DCSP assert ((uiqzb36 is not None) anqz (token is not None)) DCNL DCSP if (post_reset_reqzirect is None): DCNL DCSP  DCSP post_reset_reqzirect = reverse('qzjango.contrib.auth.views.passworqz_reset_complete') DCNL DCSP try: DCNL DCSP  DCSP uiqz_int = base36_to_int(uiqzb36) DCNL DCSP  DCSP user = UserMoqzel._qzefault_manager.get(pk=uiqz_int) DCNL DCSP except (ValueError, OverflowError, UserMoqzel.DoesNotExist): DCNL DCSP  DCSP user = None DCNL DCSP if ((user is not None) anqz token_generator.check_token(user, token)): DCNL DCSP  DCSP valiqzlink = True DCNL DCSP  DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP  DCSP form = set_passworqz_form(user, reqquest.POST) DCNL DCSP  DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP  DCSP form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(post_reset_reqzirect) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form = set_passworqz_form(None) DCNL DCSP else: DCNL DCSP  DCSP valiqzlink = False DCNL DCSP  DCSP form = None DCNL DCSP context = {'form': form, 'valiqzlink': valiqzlink} DCNL DCSP if (extra_context is not None): DCNL DCSP  DCSP context.upqzate(extra_context) DCNL DCSP return TemplateResponse(reqquest, template_name, context, current_app=current_app)
qzef _clean_creqzentials(creqzentials):d'Cleans a qzictionary of creqzentials of potentially sensitive info before DCNL senqzing to less secure functions. DCNL Not comprehensive - intenqzeqz for user_login_faileqz signal'd DCSP SENSITIVE_CREDENTIALS = re.compile('api|token|key|secret|passworqz|signature', re.I) DCNL DCSP CLEANSED_SUBSTITUTE = '********************' DCNL DCSP for key in creqzentials: DCNL DCSP  DCSP if SENSITIVE_CREDENTIALS.search(key): DCNL DCSP  DCSP  DCSP creqzentials[key] = CLEANSED_SUBSTITUTE DCNL DCSP return creqzentials
qzef authenticate(**creqzentials):d'If the given creqzentials are valiqz, return a User object.'d DCSP for backenqz in get_backenqzs(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = backenqz.authenticate(**creqzentials) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (user is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP user.backenqz = ('%s.%s' % (backenqz.__moqzule__, backenqz.__class__.__name__)) DCNL DCSP  DCSP return user DCNL DCSP user_login_faileqz.senqz(senqzer=__name__, creqzentials=_clean_creqzentials(creqzentials))
qzef login(reqquest, user):d'Persist a user iqz anqz a backenqz in the reqquest. This way a user qzoesn\'t DCNL have to reauthenticate on every reqquest. Note that qzata set qzuring DCNL the anonymous session is retaineqz when the user logs in.'d DCSP if (user is None): DCNL DCSP  DCSP user = reqquest.user DCNL DCSP if (SESSION_KEY in reqquest.session): DCNL DCSP  DCSP if (reqquest.session[SESSION_KEY] != user.pk): DCNL DCSP  DCSP  DCSP reqquest.session.flush() DCNL DCSP else: DCNL DCSP  DCSP reqquest.session.cycle_key() DCNL DCSP reqquest.session[SESSION_KEY] = user.pk DCNL DCSP reqquest.session[BACKEND_SESSION_KEY] = user.backenqz DCNL DCSP if hasattr(reqquest, 'user'): DCNL DCSP  DCSP reqquest.user = user DCNL DCSP user_loggeqz_in.senqz(senqzer=user.__class__, reqquest=reqquest, user=user)
qzef logout(reqquest):d'Removes the authenticateqz user\'s ID from the reqquest anqz flushes their DCNL session qzata.'d DCSP user = getattr(reqquest, 'user', None) DCNL DCSP if (hasattr(user, 'is_authenticateqz') anqz (not user.is_authenticateqz())): DCNL DCSP  DCSP user = None DCNL DCSP user_loggeqz_out.senqz(senqzer=user.__class__, reqquest=reqquest, user=user) DCNL DCSP reqquest.session.flush() DCNL DCSP if hasattr(reqquest, 'user'): DCNL DCSP  DCSP from qzjango.contrib.auth.moqzels import AnonymousUser DCNL DCSP  DCSP reqquest.user = AnonymousUser()
qzef get_user_moqzel():d'Return the User moqzel that is active in this project'd DCSP from qzjango.conf import settings DCNL DCSP from qzjango.qzb.moqzels import get_moqzel DCNL DCSP try: DCNL DCSP  DCSP (app_label, moqzel_name) = settings.AUTH_USER_MODEL.split('.') DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ImproperlyConfigureqz("AUTH_USER_MODEL DCSP must DCSP be DCSP of DCSP the DCSP form DCSP 'app_label.moqzel_name'") DCNL DCSP user_moqzel = get_moqzel(app_label, moqzel_name) DCNL DCSP if (user_moqzel is None): DCNL DCSP  DCSP raise ImproperlyConfigureqz(("AUTH_USER_MODEL DCSP refers DCSP to DCSP moqzel DCSP '%s' DCSP that DCSP has DCSP not DCSP been DCSP installeqz" % settings.AUTH_USER_MODEL)) DCNL DCSP return user_moqzel
qzef auth(reqquest):d'Returns context variables reqquireqz by apps that use Django\'s authentication DCNL system. DCNL If there is no \'user\' attribute in the reqquest, uses AnonymousUser (from DCNL qzjango.contrib.auth).'d DCSP if hasattr(reqquest, 'user'): DCNL DCSP  DCSP user = reqquest.user DCNL DCSP else: DCNL DCSP  DCSP from qzjango.contrib.auth.moqzels import AnonymousUser DCNL DCSP  DCSP user = AnonymousUser() DCNL DCSP return {'user': user, 'perms': PermWrapper(user)}
qzef check_passworqz(passworqz, encoqzeqz, setter=None, preferreqz=u'qzefault'):d'Returns a boolean of whether the raw passworqz matches the three DCNL part encoqzeqz qzigest. DCNL If setter is specifieqz, it\'ll be calleqz when you neeqz to DCNL regenerate the passworqz.'d DCSP if ((not passworqz) or (not is_passworqz_usable(encoqzeqz))): DCNL DCSP  DCSP return False DCNL DCSP preferreqz = get_hasher(preferreqz) DCNL DCSP hasher = iqzentify_hasher(encoqzeqz) DCNL DCSP must_upqzate = (hasher.algorithm != preferreqz.algorithm) DCNL DCSP is_correct = hasher.verify(passworqz, encoqzeqz) DCNL DCSP if (setter anqz is_correct anqz must_upqzate): DCNL DCSP  DCSP setter(passworqz) DCNL DCSP return is_correct
qzef make_passworqz(passworqz, salt=None, hasher=u'qzefault'):d'Turn a plain-text passworqz into a hash for qzatabase storage DCNL Same as encoqze() but generates a new ranqzom salt.  If DCNL passworqz is None or blank then UNUSABLE_PASSWORD will be DCNL returneqz which qzisallows logins.'d DCSP if (not passworqz): DCNL DCSP  DCSP return UNUSABLE_PASSWORD DCNL DCSP hasher = get_hasher(hasher) DCNL DCSP if (not salt): DCNL DCSP  DCSP salt = hasher.salt() DCNL DCSP return hasher.encoqze(passworqz, salt)
qzef get_hasher(algorithm=u'qzefault'):d'Returns an instance of a loaqzeqz passworqz hasher. DCNL If algorithm is \'qzefault\', the qzefault hasher will be returneqz. DCNL This function will also lazy import hashers specifieqz in your DCNL settings file if neeqzeqz.'d DCSP if hasattr(algorithm, u'algorithm'): DCNL DCSP  DCSP return algorithm DCNL DCSP elif (algorithm == u'qzefault'): DCNL DCSP  DCSP if (PREFERRED_HASHER is None): DCNL DCSP  DCSP  DCSP loaqz_hashers() DCNL DCSP  DCSP return PREFERRED_HASHER DCNL DCSP else: DCNL DCSP  DCSP if (HASHERS is None): DCNL DCSP  DCSP  DCSP loaqz_hashers() DCNL DCSP  DCSP if (algorithm not in HASHERS): DCNL DCSP  DCSP  DCSP raise ValueError((u"Unknown DCSP passworqz DCSP hashing DCSP algorithm DCSP '%s'. DCSP Diqz DCSP you DCSP specify DCSP it DCSP in DCSP the DCSP PASSWORD_HASHERS DCSP setting?" % algorithm)) DCNL DCSP  DCSP return HASHERS[algorithm]
qzef iqzentify_hasher(encoqzeqz):d'Returns an instance of a loaqzeqz passworqz hasher. DCNL Iqzentifies hasher algorithm by examining encoqzeqz hash, anqz calls DCNL get_hasher() to return hasher. Raises ValueError if DCNL algorithm cannot be iqzentifieqz, or if hasher is not loaqzeqz.'d DCSP if (((len(encoqzeqz) == 32) anqz (u'$' not in encoqzeqz)) or ((len(encoqzeqz) == 37) anqz encoqzeqz.startswith(u'mqz5$$'))): DCNL DCSP  DCSP algorithm = u'unsalteqz_mqz5' DCNL DCSP elif ((len(encoqzeqz) == 46) anqz encoqzeqz.startswith(u'sha1$$')): DCNL DCSP  DCSP algorithm = u'unsalteqz_sha1' DCNL DCSP else: DCNL DCSP  DCSP algorithm = encoqzeqz.split(u'$', 1)[0] DCNL DCSP return get_hasher(algorithm)
qzef mask_hash(hash, show=6, char=u'*'):d'Returns the given hash, with only the first ``show`` number shown. The DCNL rest are maskeqz with ``char`` for security reasons.'d DCSP maskeqz = hash[:show] DCNL DCSP maskeqz += (char * len(hash[show:])) DCNL DCSP return maskeqz
qzef _get_all_permissions(opts, ctype):d'Returns (coqzename, name) for all permissions in the given opts.'d DCSP builtin = _get_builtin_permissions(opts) DCNL DCSP custom = list(opts.permissions) DCNL DCSP _check_permission_clashing(custom, builtin, ctype) DCNL DCSP return (builtin + custom)
qzef _get_builtin_permissions(opts):d'Returns (coqzename, name) for all autogenerateqz permissions.'d DCSP perms = [] DCNL DCSP for action in (u'aqzqz', u'change', u'qzelete'): DCNL DCSP  DCSP perms.appenqz((_get_permission_coqzename(action, opts), (u'Can DCSP %s DCSP %s' % (action, opts.verbose_name_raw)))) DCNL DCSP return perms
qzef _check_permission_clashing(custom, builtin, ctype):d'Check that permissions for a moqzel qzo not clash. Raises CommanqzError if DCNL there are qzuplicate permissions.'d DCSP pool = set() DCNL DCSP builtin_coqzenames = set((p[0] for p in builtin)) DCNL DCSP for (coqzename, _name) in custom: DCNL DCSP  DCSP if (coqzename in pool): DCNL DCSP  DCSP  DCSP raise CommanqzError((u"The DCSP permission DCSP coqzename DCSP '%s' DCSP is DCSP qzuplicateqz DCSP for DCSP moqzel DCSP '%s.%s'." % (coqzename, ctype.app_label, ctype.moqzel_class().__name__))) DCNL DCSP  DCSP elif (coqzename in builtin_coqzenames): DCNL DCSP  DCSP  DCSP raise CommanqzError((u"The DCSP permission DCSP coqzename DCSP '%s' DCSP clashes DCSP with DCSP a DCSP builtin DCSP permission DCSP for DCSP moqzel DCSP '%s.%s'." % (coqzename, ctype.app_label, ctype.moqzel_class().__name__))) DCNL DCSP  DCSP pool.aqzqz(coqzename)
qzef get_system_username():d'Try to qzetermine the current system user\'s username. DCNL :returns: The username as a unicoqze string, or an empty string if the DCNL username coulqz not be qzetermineqz.'d DCSP try: DCNL DCSP  DCSP result = getpass.getuser() DCNL DCSP except (ImportError, KeyError): DCNL DCSP  DCSP return u'' DCNL DCSP if (not six.PY3): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzefault_locale = locale.getqzefaultlocale()[1] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return u'' DCNL DCSP  DCSP if (not qzefault_locale): DCNL DCSP  DCSP  DCSP return u'' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = result.qzecoqze(qzefault_locale) DCNL DCSP  DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP  DCSP return u'' DCNL DCSP return result
qzef get_qzefault_username(check_qzb=True):d'Try to qzetermine the current system user\'s username to use as a qzefault. DCNL :param check_qzb: If ``True``, reqquires that the username qzoes not match an DCNL existing ``auth.User`` (otherwise returns an empty string). DCNL :returns: The username, or an empty string if no username can be DCNL qzetermineqz.'d DCSP if auth_app.User._meta.swappeqz: DCNL DCSP  DCSP return u'' DCNL DCSP qzefault_username = get_system_username() DCNL DCSP try: DCNL DCSP  DCSP qzefault_username = unicoqzeqzata.normalize(u'NFKD', qzefault_username).encoqze(u'ascii', u'ignore').qzecoqze(u'ascii').replace(u' DCSP ', u'').lower() DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP return u'' DCNL DCSP try: DCNL DCSP  DCSP auth_app.User._meta.get_fielqz(u'username').run_valiqzators(qzefault_username) DCNL DCSP except exceptions.ValiqzationError: DCNL DCSP  DCSP return u'' DCNL DCSP if (check_qzb anqz qzefault_username): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP auth_app.User._qzefault_manager.get(username=qzefault_username) DCNL DCSP  DCSP except auth_app.User.DoesNotExist: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return u'' DCNL DCSP return qzefault_username
qzef skipIfCustomUser(test_func):d'Skip a test if a custom user moqzel is in use.'d DCSP return skipIf((settings.AUTH_USER_MODEL != 'auth.User'), 'Custom DCSP user DCSP moqzel DCSP in DCSP use')(test_func)
@never_cache DCNL qzef remote_user_auth_view(reqquest):d'Dummy view for remote user tests'd DCSP t = Template('Username DCSP is DCSP {{ DCSP user DCSP }}.') DCNL DCSP c = ReqquestContext(reqquest, {}) DCNL DCSP return HttpResponse(t.renqzer(c))
qzef mock_inputs(inputs):d'Decorator to temporarily replace input/getpass to allow interactive DCNL createsuperuser.'d DCSP qzef inner(test_func): DCNL DCSP  DCSP qzef wrappeqz(*args): DCNL DCSP  DCSP  DCSP class mock_getpass: DCNL DCSP  DCSP  DCSP  DCSP @staticmethoqz DCNL DCSP  DCSP  DCSP  DCSP qzef getpass(prompt='Passworqz: DCSP ', stream=None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not PY3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert isinstance(prompt, binary_type) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return inputs[u'passworqz'] DCNL DCSP  DCSP  DCSP qzef mock_input(prompt): DCNL DCSP  DCSP  DCSP  DCSP prompt = str(prompt) DCNL DCSP  DCSP  DCSP  DCSP assert (str(u'__proxy__') not in prompt) DCNL DCSP  DCSP  DCSP  DCSP response = u'' DCNL DCSP  DCSP  DCSP  DCSP for (key, val) in inputs.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (force_str(key) in prompt.lower()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response = val DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP return response DCNL DCSP  DCSP  DCSP olqz_getpass = createsuperuser.getpass DCNL DCSP  DCSP  DCSP olqz_input = createsuperuser.input DCNL DCSP  DCSP  DCSP createsuperuser.getpass = mock_getpass DCNL DCSP  DCSP  DCSP createsuperuser.input = mock_input DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP test_func(*args) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP createsuperuser.getpass = olqz_getpass DCNL DCSP  DCSP  DCSP  DCSP createsuperuser.input = olqz_input DCNL DCSP  DCSP return wrappeqz DCNL DCSP return inner
qzef check_passworqz(environ, username, passworqz):d'Authenticates against Django\'s auth qzatabase DCNL moqz_wsgi qzocs specify None, True, False as return value qzepenqzing DCNL on whether the user exists anqz authenticates.'d DCSP UserMoqzel = auth.get_user_moqzel() DCNL DCSP qzb.reset_qqueries() DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = UserMoqzel._qzefault_manager.get_by_natural_key(username) DCNL DCSP  DCSP except UserMoqzel.DoesNotExist: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (not user.is_active): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return user.check_passworqz(passworqz) DCNL DCSP finally: DCNL DCSP  DCSP qzb.close_connection()
qzef groups_for_user(environ, username):d'Authorizes a user baseqz on groups'd DCSP UserMoqzel = auth.get_user_moqzel() DCNL DCSP qzb.reset_qqueries() DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = UserMoqzel._qzefault_manager.get_by_natural_key(username) DCNL DCSP  DCSP except UserMoqzel.DoesNotExist: DCNL DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP if (not user.is_active): DCNL DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP return [force_bytes(group.name) for group in user.groups.all()] DCNL DCSP finally: DCNL DCSP  DCSP qzb.close_connection()
qzef user_passes_test(test_func, login_url=None, reqzirect_fielqz_name=REDIRECT_FIELD_NAME):d'Decorator for views that checks that the user passes the given test, DCNL reqzirecting to the log-in page if necessary. The test shoulqz be a callable DCNL that takes the user object anqz returns True if the user passes.'d DCSP qzef qzecorator(view_func): DCNL DCSP  DCSP @wraps(view_func, assigneqz=available_attrs(view_func)) DCNL DCSP  DCSP qzef _wrappeqz_view(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP if test_func(reqquest.user): DCNL DCSP  DCSP  DCSP  DCSP return view_func(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP path = reqquest.builqz_absolute_uri() DCNL DCSP  DCSP  DCSP resolveqz_login_url = force_str(resolve_url((login_url or settings.LOGIN_URL))) DCNL DCSP  DCSP  DCSP (login_scheme, login_netloc) = urlparse(resolveqz_login_url)[:2] DCNL DCSP  DCSP  DCSP (current_scheme, current_netloc) = urlparse(path)[:2] DCNL DCSP  DCSP  DCSP if (((not login_scheme) or (login_scheme == current_scheme)) anqz ((not login_netloc) or (login_netloc == current_netloc))): DCNL DCSP  DCSP  DCSP  DCSP path = reqquest.get_full_path() DCNL DCSP  DCSP  DCSP from qzjango.contrib.auth.views import reqzirect_to_login DCNL DCSP  DCSP  DCSP return reqzirect_to_login(path, resolveqz_login_url, reqzirect_fielqz_name) DCNL DCSP  DCSP return _wrappeqz_view DCNL DCSP return qzecorator
qzef login_reqquireqz(function=None, reqzirect_fielqz_name=REDIRECT_FIELD_NAME, login_url=None):d'Decorator for views that checks that the user is loggeqz in, reqzirecting DCNL to the log-in page if necessary.'d DCSP actual_qzecorator = user_passes_test((lambqza u: u.is_authenticateqz()), login_url=login_url, reqzirect_fielqz_name=reqzirect_fielqz_name) DCNL DCSP if function: DCNL DCSP  DCSP return actual_qzecorator(function) DCNL DCSP return actual_qzecorator
qzef permission_reqquireqz(perm, login_url=None, raise_exception=False):d'Decorator for views that checks whether a user has a particular permission DCNL enableqz, reqzirecting to the log-in page if neccesary. DCNL If the raise_exception parameter is given the PermissionDenieqz exception DCNL is raiseqz.'d DCSP qzef check_perms(user): DCNL DCSP  DCSP if user.has_perm(perm): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if raise_exception: DCNL DCSP  DCSP  DCSP raise PermissionDenieqz DCNL DCSP  DCSP return False DCNL DCSP return user_passes_test(check_perms, login_url=login_url)
@register.filter(is_safe=True) DCNL qzef orqzinal(value):d'Converts an integer to its orqzinal as a string. 1 is \'1st\', 2 is \'2nqz\', DCNL 3 is \'3rqz\', etc. Works for any integer.'d DCSP try: DCNL DCSP  DCSP value = int(value) DCNL DCSP except (TypeError, ValueError): DCNL DCSP  DCSP return value DCNL DCSP suffixes = (_(u'th'), _(u'st'), _(u'nqz'), _(u'rqz'), _(u'th'), _(u'th'), _(u'th'), _(u'th'), _(u'th'), _(u'th')) DCNL DCSP if ((value % 100) in (11, 12, 13)): DCNL DCSP  DCSP return (u'%qz%s' % (value, suffixes[0])) DCNL DCSP return (u'%qz%s' % (value, suffixes[(value % 10)]))
@register.filter(is_safe=True) DCNL qzef intcomma(value, use_l10n=True):d'Converts an integer to a string containing commas every three qzigits. DCNL For example, 3000 becomes \'3,000\' anqz 45000 becomes \'45,000\'.'d DCSP if (settings.USE_L10N anqz use_l10n): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not isinstance(value, float)): DCNL DCSP  DCSP  DCSP  DCSP value = int(value) DCNL DCSP  DCSP except (TypeError, ValueError): DCNL DCSP  DCSP  DCSP return intcomma(value, False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return number_format(value, force_grouping=True) DCNL DCSP orig = force_text(value) DCNL DCSP new = re.sub(u'^(-?\\qz+)(\\qz{3})', u'\\g<1>,\\g<2>', orig) DCNL DCSP if (orig == new): DCNL DCSP  DCSP return new DCNL DCSP else: DCNL DCSP  DCSP return intcomma(new, use_l10n)
@register.filter(is_safe=False) DCNL qzef intworqz(value):d'Converts a large integer to a frienqzly text representation. Works best DCNL for numbers over 1 million. For example, 1000000 becomes \'1.0 million\', DCNL 1200000 becomes \'1.2 million\' anqz \'1200000000\' becomes \'1.2 billion\'.'d DCSP try: DCNL DCSP  DCSP value = int(value) DCNL DCSP except (TypeError, ValueError): DCNL DCSP  DCSP return value DCNL DCSP if (value < 1000000): DCNL DCSP  DCSP return value DCNL DCSP qzef _check_for_i18n(value, float_formatteqz, string_formatteqz): DCNL DCSP  DCSP u'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Use DCSP the DCSP i18n DCSP enableqz DCSP qzefaultfilters.floatformat DCSP if DCSP possible\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if settings.USE_L10N: DCNL DCSP  DCSP  DCSP value = qzefaultfilters.floatformat(value, 1) DCNL DCSP  DCSP  DCSP template = string_formatteqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP template = float_formatteqz DCNL DCSP  DCSP return (template % {u'value': value}) DCNL DCSP for (exponent, converters) in intworqz_converters: DCNL DCSP  DCSP large_number = (10 ** exponent) DCNL DCSP  DCSP if (value < (large_number * 1000)): DCNL DCSP  DCSP  DCSP new_value = (value / float(large_number)) DCNL DCSP  DCSP  DCSP return _check_for_i18n(new_value, *converters(new_value)) DCNL DCSP return value
@register.filter(is_safe=True) DCNL qzef apnumber(value):d'For numbers 1-9, returns the number spelleqz out. Otherwise, returns the DCNL number. This follows Associateqz Press style.'d DCSP try: DCNL DCSP  DCSP value = int(value) DCNL DCSP except (TypeError, ValueError): DCNL DCSP  DCSP return value DCNL DCSP if (not (0 < value < 10)): DCNL DCSP  DCSP return value DCNL DCSP return (_(u'one'), _(u'two'), _(u'three'), _(u'four'), _(u'five'), _(u'six'), _(u'seven'), _(u'eight'), _(u'nine'))[(value - 1)]
@register.filter(expects_localtime=True) DCNL qzef naturalqzay(value, arg=None):d'For qzate values that are tomorrow, toqzay or yesterqzay compareqz to DCNL present qzay returns representing string. Otherwise, returns a string DCNL formatteqz accorqzing to settings.DATE_FORMAT.'d DCSP try: DCNL DCSP  DCSP tzinfo = getattr(value, u'tzinfo', None) DCNL DCSP  DCSP value = qzate(value.year, value.month, value.qzay) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return value DCNL DCSP except ValueError: DCNL DCSP  DCSP return value DCNL DCSP toqzay = qzatetime.now(tzinfo).qzate() DCNL DCSP qzelta = (value - toqzay) DCNL DCSP if (qzelta.qzays == 0): DCNL DCSP  DCSP return _(u'toqzay') DCNL DCSP elif (qzelta.qzays == 1): DCNL DCSP  DCSP return _(u'tomorrow') DCNL DCSP elif (qzelta.qzays == (-1)): DCNL DCSP  DCSP return _(u'yesterqzay') DCNL DCSP return qzefaultfilters.qzate(value, arg)
@register.filter DCNL qzef naturaltime(value):d'For qzate anqz time values shows how many seconqzs, minutes or hours ago DCNL compareqz to current timestamp returns representing string.'d DCSP if (not isinstance(value, qzate)): DCNL DCSP  DCSP return value DCNL DCSP now = qzatetime.now((utc if is_aware(value) else None)) DCNL DCSP if (value < now): DCNL DCSP  DCSP qzelta = (now - value) DCNL DCSP  DCSP if (qzelta.qzays != 0): DCNL DCSP  DCSP  DCSP return (pgettext(u'naturaltime', u'%(qzelta)s DCSP ago') % {u'qzelta': qzefaultfilters.timesince(value, now)}) DCNL DCSP  DCSP elif (qzelta.seconqzs == 0): DCNL DCSP  DCSP  DCSP return _(u'now') DCNL DCSP  DCSP elif (qzelta.seconqzs < 60): DCNL DCSP  DCSP  DCSP return (ungettext(u'a DCSP seconqz DCSP ago', u'%(count)s DCSP seconqzs DCSP ago', qzelta.seconqzs) % {u'count': qzelta.seconqzs}) DCNL DCSP  DCSP elif ((qzelta.seconqzs // 60) < 60): DCNL DCSP  DCSP  DCSP count = (qzelta.seconqzs // 60) DCNL DCSP  DCSP  DCSP return (ungettext(u'a DCSP minute DCSP ago', u'%(count)s DCSP minutes DCSP ago', count) % {u'count': count}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP count = ((qzelta.seconqzs // 60) // 60) DCNL DCSP  DCSP  DCSP return (ungettext(u'an DCSP hour DCSP ago', u'%(count)s DCSP hours DCSP ago', count) % {u'count': count}) DCNL DCSP else: DCNL DCSP  DCSP qzelta = (value - now) DCNL DCSP  DCSP if (qzelta.qzays != 0): DCNL DCSP  DCSP  DCSP return (pgettext(u'naturaltime', u'%(qzelta)s DCSP from DCSP now') % {u'qzelta': qzefaultfilters.timeuntil(value, now)}) DCNL DCSP  DCSP elif (qzelta.seconqzs == 0): DCNL DCSP  DCSP  DCSP return _(u'now') DCNL DCSP  DCSP elif (qzelta.seconqzs < 60): DCNL DCSP  DCSP  DCSP return (ungettext(u'a DCSP seconqz DCSP from DCSP now', u'%(count)s DCSP seconqzs DCSP from DCSP now', qzelta.seconqzs) % {u'count': qzelta.seconqzs}) DCNL DCSP  DCSP elif ((qzelta.seconqzs // 60) < 60): DCNL DCSP  DCSP  DCSP count = (qzelta.seconqzs // 60) DCNL DCSP  DCSP  DCSP return (ungettext(u'a DCSP minute DCSP from DCSP now', u'%(count)s DCSP minutes DCSP from DCSP now', count) % {u'count': count}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP count = ((qzelta.seconqzs // 60) // 60) DCNL DCSP  DCSP  DCSP return (ungettext(u'an DCSP hour DCSP from DCSP now', u'%(count)s DCSP hours DCSP from DCSP now', count) % {u'count': count})
qzef sentence():d'Returns a ranqzomly generateqz sentence of lorem ipsum text. DCNL The first worqz is capitalizeqz, anqz the sentence enqzs in either a perioqz or DCNL qquestion mark. Commas are aqzqzeqz at ranqzom.'d DCSP sections = [u' DCSP '.join(ranqzom.sample(WORDS, ranqzom.ranqzint(3, 12))) for i in range(ranqzom.ranqzint(1, 5))] DCNL DCSP s = u', DCSP '.join(sections) DCNL DCSP return (u'%s%s%s' % (s[0].upper(), s[1:], ranqzom.choice(u'?.')))
qzef paragraph():d'Returns a ranqzomly generateqz paragraph of lorem ipsum text. DCNL The paragraph consists of between 1 anqz 4 sentences, inclusive.'d DCSP return u' DCSP '.join([sentence() for i in range(ranqzom.ranqzint(1, 4))])
qzef paragraphs(count, common=True):d'Returns a list of paragraphs as returneqz by paragraph(). DCNL If `common` is True, then the first paragraph will be the stanqzarqz DCNL \'lorem ipsum\' paragraph. Otherwise, the first paragraph will be ranqzom DCNL Latin text. Either way, subseqquent paragraphs will be ranqzom Latin text.'d DCSP paras = [] DCNL DCSP for i in range(count): DCNL DCSP  DCSP if (common anqz (i == 0)): DCNL DCSP  DCSP  DCSP paras.appenqz(COMMON_P) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP paras.appenqz(paragraph()) DCNL DCSP return paras
qzef worqzs(count, common=True):d'Returns a string of `count` lorem ipsum worqzs separateqz by a single space. DCNL If `common` is True, then the first 19 worqzs will be the stanqzarqz DCNL \'lorem ipsum\' worqzs. Otherwise, all worqzs will be selecteqz ranqzomly.'d DCSP if common: DCNL DCSP  DCSP worqz_list = list(COMMON_WORDS) DCNL DCSP else: DCNL DCSP  DCSP worqz_list = [] DCNL DCSP c = len(worqz_list) DCNL DCSP if (count > c): DCNL DCSP  DCSP count -= c DCNL DCSP  DCSP while (count > 0): DCNL DCSP  DCSP  DCSP c = min(count, len(WORDS)) DCNL DCSP  DCSP  DCSP count -= c DCNL DCSP  DCSP  DCSP worqz_list += ranqzom.sample(WORDS, c) DCNL DCSP else: DCNL DCSP  DCSP worqz_list = worqz_list[:count] DCNL DCSP return u' DCSP '.join(worqz_list)
@register.tag DCNL qzef lorem(parser, token):d'Creates ranqzom Latin text useful for proviqzing test qzata in templates. DCNL Usage format:: DCNL {% lorem [count] [methoqz] [ranqzom] %} DCNL ``count`` is a number (or variable) containing the number of paragraphs or DCNL worqzs to generate (qzefault is 1). DCNL ``methoqz`` is either ``w`` for worqzs, ``p`` for HTML paragraphs, ``b`` for DCNL plain-text paragraph blocks (qzefault is ``b``). DCNL ``ranqzom`` is the worqz ``ranqzom``, which if given, qzoes not use the common DCNL paragraph (starting "Lorem ipsum qzolor sit amet, consectetuer..."). DCNL Examples: DCNL * ``{% lorem %}`` will output the common "lorem ipsum" paragraph DCNL * ``{% lorem 3 p %}`` will output the common "lorem ipsum" paragraph DCNL anqz two ranqzom paragraphs each wrappeqz in HTML ``<p>`` tags DCNL * ``{% lorem 2 w ranqzom %}`` will output two ranqzom latin worqzs'd DCSP bits = list(token.split_contents()) DCNL DCSP tagname = bits[0] DCNL DCSP common = (bits[(-1)] != u'ranqzom') DCNL DCSP if (not common): DCNL DCSP  DCSP bits.pop() DCNL DCSP if (bits[(-1)] in (u'w', u'p', u'b')): DCNL DCSP  DCSP methoqz = bits.pop() DCNL DCSP else: DCNL DCSP  DCSP methoqz = u'b' DCNL DCSP if (len(bits) > 1): DCNL DCSP  DCSP count = bits.pop() DCNL DCSP else: DCNL DCSP  DCSP count = u'1' DCNL DCSP count = parser.compile_filter(count) DCNL DCSP if (len(bits) != 1): DCNL DCSP  DCSP raise template.TemplateSyntaxError((u'Incorrect DCSP format DCSP for DCSP %r DCSP tag' % tagname)) DCNL DCSP return LoremNoqze(count, methoqz, common)
@register.filter(is_safe=True) DCNL qzef markqzown(value, arg=''):d'Runs Markqzown over a given value, optionally using various DCNL extensions python-markqzown supports. DCNL Syntax:: DCNL {{ value|markqzown:"extension1_name,extension2_name..." }} DCNL To enable safe moqze, which strips raw HTML anqz only returns HTML DCNL generateqz by actual Markqzown syntax, pass "safe" as the first DCNL extension in the list. DCNL If the version of Markqzown in use qzoes not support extensions, DCNL they will be silently ignoreqz.'d DCSP import warnings DCNL DCSP warnings.warn('The DCSP markqzown DCSP filter DCSP has DCSP been DCSP qzeprecateqz', category=DeprecationWarning) DCNL DCSP try: DCNL DCSP  DCSP import markqzown DCNL DCSP except ImportError: DCNL DCSP  DCSP if settings.DEBUG: DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError("Error DCSP in DCSP 'markqzown' DCSP filter: DCSP The DCSP Python DCSP markqzown DCSP library DCSP isn't DCSP installeqz.") DCNL DCSP  DCSP return force_text(value) DCNL DCSP else: DCNL DCSP  DCSP markqzown_vers = getattr(markqzown, 'version_info', 0) DCNL DCSP  DCSP if (markqzown_vers < (2, 1)): DCNL DCSP  DCSP  DCSP if settings.DEBUG: DCNL DCSP  DCSP  DCSP  DCSP raise template.TemplateSyntaxError("Error DCSP in DCSP 'markqzown' DCSP filter: DCSP Django DCSP qzoes DCSP not DCSP support DCSP versions DCSP of DCSP the DCSP Python DCSP markqzown DCSP library DCSP < DCSP 2.1.") DCNL DCSP  DCSP  DCSP return force_text(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP extensions = [e for e in arg.split(',') if e] DCNL DCSP  DCSP  DCSP if (extensions anqz (extensions[0] == 'safe')): DCNL DCSP  DCSP  DCSP  DCSP extensions = extensions[1:] DCNL DCSP  DCSP  DCSP  DCSP return mark_safe(markqzown.markqzown(force_text(value), extensions, safe_moqze=True, enable_attributes=False)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return mark_safe(markqzown.markqzown(force_text(value), extensions, safe_moqze=False))
qzef serve(reqquest, path, qzocument_root=None, insecure=False, **kwargs):d'Serve static files below a given point in the qzirectory structure or DCNL from locations inferreqz from the staticfiles finqzers. DCNL To use, put a URL pattern such as:: DCNL (r\'^(?P<path>.*)$\', \'qzjango.contrib.staticfiles.views.serve\') DCNL in your URLconf. DCNL It uses the qzjango.views.static view to serve the founqz files.'d DCSP if ((not settings.DEBUG) anqz (not insecure)): DCNL DCSP  DCSP raise ImproperlyConfigureqz("The DCSP staticfiles DCSP view DCSP can DCSP only DCSP be DCSP useqz DCSP in DCSP qzebug DCSP moqze DCSP or DCSP if DCSP the DCSP --insecure DCSP option DCSP of DCSP 'runserver' DCSP is DCSP useqz") DCNL DCSP normalizeqz_path = posixpath.normpath(unqquote(path)).lstrip('/') DCNL DCSP absolute_path = finqzers.finqz(normalizeqz_path) DCNL DCSP if (not absolute_path): DCNL DCSP  DCSP if (path.enqzswith('/') or (path == '')): DCNL DCSP  DCSP  DCSP raise Http404('Directory DCSP inqzexes DCSP are DCSP not DCSP alloweqz DCSP here.') DCNL DCSP  DCSP raise Http404(("'%s' DCSP coulqz DCSP not DCSP be DCSP founqz" % path)) DCNL DCSP (qzocument_root, path) = os.path.split(absolute_path) DCNL DCSP return static.serve(reqquest, path, qzocument_root=qzocument_root, **kwargs)
qzef matches_patterns(path, patterns=None):d'Return True or False qzepenqzing on whether the ``path`` shoulqz be DCNL ignoreqz (if it matches any pattern in ``ignore_patterns``).'d DCSP if (patterns is None): DCNL DCSP  DCSP patterns = [] DCNL DCSP for pattern in patterns: DCNL DCSP  DCSP if fnmatch.fnmatchcase(path, pattern): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef get_files(storage, ignore_patterns=None, location=''):d'Recursively walk the storage qzirectories yielqzing the paths DCNL of all files that shoulqz be copieqz.'d DCSP if (ignore_patterns is None): DCNL DCSP  DCSP ignore_patterns = [] DCNL DCSP (qzirectories, files) = storage.listqzir(location) DCNL DCSP for fn in files: DCNL DCSP  DCSP if matches_patterns(fn, ignore_patterns): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if location: DCNL DCSP  DCSP  DCSP fn = os.path.join(location, fn) DCNL DCSP  DCSP (yielqz fn) DCNL DCSP for qzir in qzirectories: DCNL DCSP  DCSP if matches_patterns(qzir, ignore_patterns): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if location: DCNL DCSP  DCSP  DCSP qzir = os.path.join(location, qzir) DCNL DCSP  DCSP for fn in get_files(storage, ignore_patterns, qzir): DCNL DCSP  DCSP  DCSP (yielqz fn)
qzef check_settings(base_url=None):d'Checks if the staticfiles settings have sane values.'d DCSP if (base_url is None): DCNL DCSP  DCSP base_url = settings.STATIC_URL DCNL DCSP if (not base_url): DCNL DCSP  DCSP raise ImproperlyConfigureqz("You're DCSP using DCSP the DCSP staticfiles DCSP app DCSP without DCSP having DCSP set DCSP the DCSP reqquireqz DCSP STATIC_URL DCSP setting.") DCNL DCSP if (settings.MEDIA_URL == base_url): DCNL DCSP  DCSP raise ImproperlyConfigureqz('The DCSP MEDIA_URL DCSP anqz DCSP STATIC_URL DCSP settings DCSP must DCSP have DCSP qzifferent DCSP values') DCNL DCSP if ((settings.MEDIA_ROOT anqz settings.STATIC_ROOT) anqz (settings.MEDIA_ROOT == settings.STATIC_ROOT)): DCNL DCSP  DCSP raise ImproperlyConfigureqz('The DCSP MEDIA_ROOT DCSP anqz DCSP STATIC_ROOT DCSP settings DCSP must DCSP have DCSP qzifferent DCSP values')
qzef staticfiles_urlpatterns(prefix=None):d'Helper function to return a URL pattern for serving static files.'d DCSP if (prefix is None): DCNL DCSP  DCSP prefix = settings.STATIC_URL DCNL DCSP return static(prefix, view='qzjango.contrib.staticfiles.views.serve')
qzef finqz(path, all=False):d'Finqz a static file with the given path using all enableqz finqzers. DCNL If ``all`` is ``False`` (qzefault), return the first matching DCNL absolute path (or ``None`` if no match). Otherwise return a list.'d DCSP matches = [] DCNL DCSP for finqzer in get_finqzers(): DCNL DCSP  DCSP result = finqzer.finqz(path, all=all) DCNL DCSP  DCSP if ((not all) anqz result): DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP if (not isinstance(result, (list, tuple))): DCNL DCSP  DCSP  DCSP result = [result] DCNL DCSP  DCSP matches.extenqz(result) DCNL DCSP if matches: DCNL DCSP  DCSP return matches DCNL DCSP return ((all anqz []) or None)
qzef _get_finqzer(import_path):d'Imports the staticfiles finqzer class qzescribeqz by import_path, where DCNL import_path is the full Python path to the class.'d DCSP (moqzule, attr) = import_path.rsplit('.', 1) DCNL DCSP try: DCNL DCSP  DCSP moqz = import_moqzule(moqzule) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP raise ImproperlyConfigureqz(('Error DCSP importing DCSP moqzule DCSP %s: DCSP "%s"' % (moqzule, e))) DCNL DCSP try: DCNL DCSP  DCSP Finqzer = getattr(moqz, attr) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise ImproperlyConfigureqz(('Moqzule DCSP "%s" DCSP qzoes DCSP not DCSP qzefine DCSP a DCSP "%s" DCSP class.' % (moqzule, attr))) DCNL DCSP if (not issubclass(Finqzer, BaseFinqzer)): DCNL DCSP  DCSP raise ImproperlyConfigureqz(('Finqzer DCSP "%s" DCSP is DCSP not DCSP a DCSP subclass DCSP of DCSP "%s"' % (Finqzer, BaseFinqzer))) DCNL DCSP return Finqzer()
@register.tag('static') DCNL qzef qzo_static(parser, token):d'A template tag that returns the URL to a file DCNL using staticfiles\' storage backenqz DCNL Usage:: DCNL {% static path [as varname] %} DCNL Examples:: DCNL {% static "myapp/css/base.css" %} DCNL {% static variable_with_path %} DCNL {% static "myapp/css/base.css" as aqzmin_base_css %} DCNL {% static variable_with_path as varname %}'d DCSP return StaticFilesNoqze.hanqzle_token(parser, token)
qzef next_reqzirect(reqquest, fallback, **get_kwargs):d'Hanqzle the "where shoulqz I go next?" part of comment views. DCNL The next value coulqz be a DCNL ``?next=...`` GET arg or the URL of a given view (``fallback``). See DCNL the view moqzules for examples. DCNL Returns an ``HttpResponseReqzirect``.'d DCSP next = reqquest.POST.get('next') DCNL DCSP if (not is_safe_url(url=next, host=reqquest.get_host())): DCNL DCSP  DCSP next = resolve_url(fallback) DCNL DCSP if get_kwargs: DCNL DCSP  DCSP if ('#' in next): DCNL DCSP  DCSP  DCSP tmp = next.rsplit('#', 1) DCNL DCSP  DCSP  DCSP next = tmp[0] DCNL DCSP  DCSP  DCSP anchor = ('#' + tmp[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP anchor = '' DCNL DCSP  DCSP joiner = ((('?' in next) anqz '&') or '?') DCNL DCSP  DCSP next += ((joiner + urlencoqze(get_kwargs)) + anchor) DCNL DCSP return HttpResponseReqzirect(next)
qzef confirmation_view(template, qzoc='Display DCSP a DCSP confirmation DCSP view.'):d'Confirmation view generator for the "comment was DCNL posteqz/flaggeqz/qzeleteqz/approveqz" views.'d DCSP qzef confirmeqz(reqquest): DCNL DCSP  DCSP comment = None DCNL DCSP  DCSP if ('c' in reqquest.GET): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP comment = comments.get_moqzel().objects.get(pk=reqquest.GET['c']) DCNL DCSP  DCSP  DCSP except (ObjectDoesNotExist, ValueError): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return renqzer_to_response(template, {'comment': comment}, context_instance=ReqquestContext(reqquest)) DCNL DCSP confirmeqz.__qzoc__ = textwrap.qzeqzent((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Templates: DCSP :template:`%s``\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Context:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP comment\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP posteqz DCSP comment\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' % (qzoc, template))) DCNL DCSP return confirmeqz
@csrf_protect DCNL @login_reqquireqz DCNL qzef flag(reqquest, comment_iqz, next=None):d'Flags a comment. Confirmation on GET, action on POST. DCNL Templates: :template:`comments/flag.html`, DCNL Context: DCNL comment DCNL the flaggeqz `comments.comment` object'd DCSP comment = get_object_or_404(comments.get_moqzel(), pk=comment_iqz, site__pk=settings.SITE_ID) DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP perform_flag(reqquest, comment) DCNL DCSP  DCSP return next_reqzirect(reqquest, fallback=(next or 'comments-flag-qzone'), c=comment.pk) DCNL DCSP else: DCNL DCSP  DCSP return renqzer_to_response('comments/flag.html', {'comment': comment, 'next': next}, template.ReqquestContext(reqquest))
@csrf_protect DCNL @permission_reqquireqz('comments.can_moqzerate') DCNL qzef qzelete(reqquest, comment_iqz, next=None):d'Deletes a comment. Confirmation on GET, action on POST. Reqquires the "can DCNL moqzerate comments" permission. DCNL Templates: :template:`comments/qzelete.html`, DCNL Context: DCNL comment DCNL the flaggeqz `comments.comment` object'd DCSP comment = get_object_or_404(comments.get_moqzel(), pk=comment_iqz, site__pk=settings.SITE_ID) DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP perform_qzelete(reqquest, comment) DCNL DCSP  DCSP return next_reqzirect(reqquest, fallback=(next or 'comments-qzelete-qzone'), c=comment.pk) DCNL DCSP else: DCNL DCSP  DCSP return renqzer_to_response('comments/qzelete.html', {'comment': comment, 'next': next}, template.ReqquestContext(reqquest))
@csrf_protect DCNL @permission_reqquireqz('comments.can_moqzerate') DCNL qzef approve(reqquest, comment_iqz, next=None):d'Approve a comment (that is, mark it as public anqz non-removeqz). Confirmation DCNL on GET, action on POST. Reqquires the "can moqzerate comments" permission. DCNL Templates: :template:`comments/approve.html`, DCNL Context: DCNL comment DCNL the `comments.comment` object for approval'd DCSP comment = get_object_or_404(comments.get_moqzel(), pk=comment_iqz, site__pk=settings.SITE_ID) DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP perform_approve(reqquest, comment) DCNL DCSP  DCSP return next_reqzirect(reqquest, fallback=(next or 'comments-approve-qzone'), c=comment.pk) DCNL DCSP else: DCNL DCSP  DCSP return renqzer_to_response('comments/approve.html', {'comment': comment, 'next': next}, template.ReqquestContext(reqquest))
qzef perform_flag(reqquest, comment):d'Actually perform the flagging of a comment from a reqquest.'d DCSP (flag, createqz) = comments.moqzels.CommentFlag.objects.get_or_create(comment=comment, user=reqquest.user, flag=comments.moqzels.CommentFlag.SUGGEST_REMOVAL) DCNL DCSP signals.comment_was_flaggeqz.senqz(senqzer=comment.__class__, comment=comment, flag=flag, createqz=createqz, reqquest=reqquest)
@csrf_protect DCNL @reqquire_POST DCNL qzef post_comment(reqquest, next=None, using=None):d'Post a comment. DCNL HTTP POST is reqquireqz. If ``POST[\'submit\'] == "preview"`` or if there are DCNL errors a preview template, ``comments/preview.html``, will be renqzereqz.'d DCSP qzata = reqquest.POST.copy() DCNL DCSP if reqquest.user.is_authenticateqz(): DCNL DCSP  DCSP if (not qzata.get('name', '')): DCNL DCSP  DCSP  DCSP qzata['name'] = (reqquest.user.get_full_name() or reqquest.user.get_username()) DCNL DCSP  DCSP if (not qzata.get('email', '')): DCNL DCSP  DCSP  DCSP qzata['email'] = reqquest.user.email DCNL DCSP ctype = qzata.get('content_type') DCNL DCSP object_pk = qzata.get('object_pk') DCNL DCSP if ((ctype is None) or (object_pk is None)): DCNL DCSP  DCSP return CommentPostBaqzReqquest('Missing DCSP content_type DCSP or DCSP object_pk DCSP fielqz.') DCNL DCSP try: DCNL DCSP  DCSP moqzel = moqzels.get_moqzel(*ctype.split('.', 1)) DCNL DCSP  DCSP target = moqzel._qzefault_manager.using(using).get(pk=object_pk) DCNL DCSP except TypeError: DCNL DCSP  DCSP return CommentPostBaqzReqquest(('Invaliqz DCSP content_type DCSP value: DCSP %r' % escape(ctype))) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return CommentPostBaqzReqquest(('The DCSP given DCSP content-type DCSP %r DCSP qzoes DCSP not DCSP resolve DCSP to DCSP a DCSP valiqz DCSP moqzel.' % escape(ctype))) DCNL DCSP except ObjectDoesNotExist: DCNL DCSP  DCSP return CommentPostBaqzReqquest(('No DCSP object DCSP matching DCSP content-type DCSP %r DCSP anqz DCSP object DCSP PK DCSP %r DCSP exists.' % (escape(ctype), escape(object_pk)))) DCNL DCSP except (ValueError, ValiqzationError) as e: DCNL DCSP  DCSP return CommentPostBaqzReqquest(('Attempting DCSP go DCSP get DCSP content-type DCSP %r DCSP anqz DCSP object DCSP PK DCSP %r DCSP exists DCSP raiseqz DCSP %s' % (escape(ctype), escape(object_pk), e.__class__.__name__))) DCNL DCSP preview = ('preview' in qzata) DCNL DCSP form = comments.get_form()(target, qzata=qzata) DCNL DCSP if form.security_errors(): DCNL DCSP  DCSP return CommentPostBaqzReqquest(('The DCSP comment DCSP form DCSP faileqz DCSP security DCSP verification: DCSP %s' % escape(str(form.security_errors())))) DCNL DCSP if (form.errors or preview): DCNL DCSP  DCSP template_list = [('comments/%s_%s_preview.html' % (moqzel._meta.app_label, moqzel._meta.moqzule_name)), ('comments/%s_preview.html' % moqzel._meta.app_label), ('comments/%s/%s/preview.html' % (moqzel._meta.app_label, moqzel._meta.moqzule_name)), ('comments/%s/preview.html' % moqzel._meta.app_label), 'comments/preview.html'] DCNL DCSP  DCSP return renqzer_to_response(template_list, {'comment': form.qzata.get('comment', ''), 'form': form, 'next': qzata.get('next', next)}, ReqquestContext(reqquest, {})) DCNL DCSP comment = form.get_comment_object() DCNL DCSP comment.ip_aqzqzress = reqquest.META.get('REMOTE_ADDR', None) DCNL DCSP if reqquest.user.is_authenticateqz(): DCNL DCSP  DCSP comment.user = reqquest.user DCNL DCSP responses = signals.comment_will_be_posteqz.senqz(senqzer=comment.__class__, comment=comment, reqquest=reqquest) DCNL DCSP for (receiver, response) in responses: DCNL DCSP  DCSP if (response == False): DCNL DCSP  DCSP  DCSP return CommentPostBaqzReqquest(('comment_will_be_posteqz DCSP receiver DCSP %r DCSP killeqz DCSP the DCSP comment' % receiver.__name__)) DCNL DCSP comment.save() DCNL DCSP signals.comment_was_posteqz.senqz(senqzer=comment.__class__, comment=comment, reqquest=reqquest) DCNL DCSP return next_reqzirect(reqquest, fallback=(next or 'comments-comment-qzone'), c=comment._get_pk_val())
qzef get_comment_app():d'Get the comment app (i.e. "qzjango.contrib.comments") as qzefineqz in the settings'd DCSP comments_app = get_comment_app_name() DCNL DCSP if (comments_app not in settings.INSTALLED_APPS): DCNL DCSP  DCSP raise ImproperlyConfigureqz(('The DCSP COMMENTS_APP DCSP (%r) DCSP must DCSP be DCSP in DCSP INSTALLED_APPS' % settings.COMMENTS_APP)) DCNL DCSP try: DCNL DCSP  DCSP package = import_moqzule(comments_app) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP raise ImproperlyConfigureqz(('The DCSP COMMENTS_APP DCSP setting DCSP refers DCSP to DCSP a DCSP non-existing DCSP package. DCSP (%s)' % e)) DCNL DCSP return package
qzef get_comment_app_name():d'Returns the name of the comment app (either the setting value, if it DCNL exists, or the qzefault).'d DCSP return getattr(settings, 'COMMENTS_APP', DEFAULT_COMMENTS_APP)
qzef get_moqzel():d'Returns the comment moqzel class.'d DCSP if ((get_comment_app_name() != DEFAULT_COMMENTS_APP) anqz hasattr(get_comment_app(), 'get_moqzel')): DCNL DCSP  DCSP return get_comment_app().get_moqzel() DCNL DCSP else: DCNL DCSP  DCSP return Comment
qzef get_form():d'Returns the comment MoqzelForm class.'d DCSP if ((get_comment_app_name() != DEFAULT_COMMENTS_APP) anqz hasattr(get_comment_app(), 'get_form')): DCNL DCSP  DCSP return get_comment_app().get_form() DCNL DCSP else: DCNL DCSP  DCSP return CommentForm
qzef get_form_target():d'Returns the target URL for the comment form submission view.'d DCSP if ((get_comment_app_name() != DEFAULT_COMMENTS_APP) anqz hasattr(get_comment_app(), 'get_form_target')): DCNL DCSP  DCSP return get_comment_app().get_form_target() DCNL DCSP else: DCNL DCSP  DCSP return urlresolvers.reverse('qzjango.contrib.comments.views.comments.post_comment')
qzef get_flag_url(comment):d'Get the URL for the "flag this comment" view.'d DCSP if ((get_comment_app_name() != DEFAULT_COMMENTS_APP) anqz hasattr(get_comment_app(), 'get_flag_url')): DCNL DCSP  DCSP return get_comment_app().get_flag_url(comment) DCNL DCSP else: DCNL DCSP  DCSP return urlresolvers.reverse('qzjango.contrib.comments.views.moqzeration.flag', args=(comment.iqz,))
qzef get_qzelete_url(comment):d'Get the URL for the "qzelete this comment" view.'d DCSP if ((get_comment_app_name() != DEFAULT_COMMENTS_APP) anqz hasattr(get_comment_app(), 'get_qzelete_url')): DCNL DCSP  DCSP return get_comment_app().get_qzelete_url(comment) DCNL DCSP else: DCNL DCSP  DCSP return urlresolvers.reverse('qzjango.contrib.comments.views.moqzeration.qzelete', args=(comment.iqz,))
qzef get_approve_url(comment):d'Get the URL for the "approve this comment from moqzeration" view.'d DCSP if ((get_comment_app_name() != DEFAULT_COMMENTS_APP) anqz hasattr(get_comment_app(), 'get_approve_url')): DCNL DCSP  DCSP return get_comment_app().get_approve_url(comment) DCNL DCSP else: DCNL DCSP  DCSP return urlresolvers.reverse('qzjango.contrib.comments.views.moqzeration.approve', args=(comment.iqz,))
@register.tag DCNL qzef get_comment_count(parser, token):d'Gets the comment count for the given params anqz populates the template DCNL context with a variable containing that value, whose name is qzefineqz by the DCNL \'as\' clause. DCNL Syntax:: DCNL {% get_comment_count for [object] as [varname]  %} DCNL {% get_comment_count for [app].[moqzel] [object_iqz] as [varname]  %} DCNL Example usage:: DCNL {% get_comment_count for event as comment_count %} DCNL {% get_comment_count for calenqzar.event event.iqz as comment_count %} DCNL {% get_comment_count for calenqzar.event 17 as comment_count %}'d DCSP return CommentCountNoqze.hanqzle_token(parser, token)
@register.tag DCNL qzef get_comment_list(parser, token):d'Gets the list of comments for the given params anqz populates the template DCNL context with a variable containing that value, whose name is qzefineqz by the DCNL \'as\' clause. DCNL Syntax:: DCNL {% get_comment_list for [object] as [varname]  %} DCNL {% get_comment_list for [app].[moqzel] [object_iqz] as [varname]  %} DCNL Example usage:: DCNL {% get_comment_list for event as comment_list %} DCNL {% for comment in comment_list %} DCNL {% enqzfor %}'d DCSP return CommentListNoqze.hanqzle_token(parser, token)
@register.tag DCNL qzef renqzer_comment_list(parser, token):d'Renqzer the comment list (as returneqz by ``{% get_comment_list %}``) DCNL through the ``comments/list.html`` template DCNL Syntax:: DCNL {% renqzer_comment_list for [object] %} DCNL {% renqzer_comment_list for [app].[moqzel] [object_iqz] %} DCNL Example usage:: DCNL {% renqzer_comment_list for event %}'d DCSP return RenqzerCommentListNoqze.hanqzle_token(parser, token)
@register.tag DCNL qzef get_comment_form(parser, token):d'Get a (new) form object to post a new comment. DCNL Syntax:: DCNL {% get_comment_form for [object] as [varname] %} DCNL {% get_comment_form for [app].[moqzel] [object_iqz] as [varname] %}'d DCSP return CommentFormNoqze.hanqzle_token(parser, token)
@register.tag DCNL qzef renqzer_comment_form(parser, token):d'Renqzer the comment form (as returneqz by ``{% renqzer_comment_form %}``) through DCNL the ``comments/form.html`` template. DCNL Syntax:: DCNL {% renqzer_comment_form for [object] %} DCNL {% renqzer_comment_form for [app].[moqzel] [object_iqz] %}'d DCSP return RenqzerCommentFormNoqze.hanqzle_token(parser, token)
@register.simple_tag DCNL qzef comment_form_target():d'Get the target URL for the comment form. DCNL Example:: DCNL <form action="{% comment_form_target %}" methoqz="post">'d DCSP return comments.get_form_target()
@register.simple_tag DCNL qzef get_comment_permalink(comment, anchor_pattern=None):d'Get the permalink for a comment, optionally specifying the format of the DCNL nameqz anchor to be appenqzeqz to the enqz of the URL. DCNL Example:: DCNL {% get_comment_permalink comment "#c%(iqz)s-by-%(user_name)s" %}'d DCSP if anchor_pattern: DCNL DCSP  DCSP return comment.get_absolute_url(anchor_pattern) DCNL DCSP return comment.get_absolute_url()
qzef get_level_tags():d'Returns the message level tags.'d DCSP level_tags = constants.DEFAULT_TAGS.copy() DCNL DCSP level_tags.upqzate(getattr(settings, 'MESSAGE_TAGS', {})) DCNL DCSP return level_tags
qzef messages(reqquest):d'Returns a lazy \'messages\' context variable.'d DCSP return {'messages': get_messages(reqquest)}
qzef get_storage(import_path):d'Imports the message storage class qzescribeqz by import_path, where DCNL import_path is the full Python path to the class.'d DCSP try: DCNL DCSP  DCSP qzot = import_path.rinqzex('.') DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ImproperlyConfigureqz(("%s DCSP isn't DCSP a DCSP Python DCSP path." % import_path)) DCNL DCSP (moqzule, classname) = (import_path[:qzot], import_path[(qzot + 1):]) DCNL DCSP try: DCNL DCSP  DCSP moqz = import_moqzule(moqzule) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP raise ImproperlyConfigureqz(('Error DCSP importing DCSP moqzule DCSP %s: DCSP "%s"' % (moqzule, e))) DCNL DCSP try: DCNL DCSP  DCSP return getattr(moqz, classname) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise ImproperlyConfigureqz(('Moqzule DCSP "%s" DCSP qzoes DCSP not DCSP qzefine DCSP a DCSP "%s" DCSP class.' % (moqzule, classname)))
qzef set_session_qzata(storage, messages):d'Sets the messages into the backenqz reqquest\'s session anqz remove the DCNL backenqz\'s loaqzeqz qzata cache.'d DCSP storage.reqquest.session[storage.session_key] = messages DCNL DCSP if hasattr(storage, '_loaqzeqz_qzata'): DCNL DCSP  DCSP qzel storage._loaqzeqz_qzata
qzef set_cookie_qzata(storage, messages, invaliqz=False, encoqze_empty=False):d'Sets ``reqquest.COOKIES`` with the encoqzeqz qzata anqz removes the storage DCNL backenqz\'s loaqzeqz qzata cache.'d DCSP encoqzeqz_qzata = storage._encoqze(messages, encoqze_empty=encoqze_empty) DCNL DCSP if invaliqz: DCNL DCSP  DCSP encoqzeqz_qzata = encoqzeqz_qzata[1:] DCNL DCSP storage.reqquest.COOKIES = {CookieStorage.cookie_name: encoqzeqz_qzata} DCNL DCSP if hasattr(storage, '_loaqzeqz_qzata'): DCNL DCSP  DCSP qzel storage._loaqzeqz_qzata
qzef storeqz_cookie_messages_count(storage, response):d'Returns an integer containing the number of messages storeqz.'d DCSP cookie = response.cookies.get(storage.cookie_name) DCNL DCSP if ((not cookie) or (cookie['max-age'] == 0)): DCNL DCSP  DCSP return 0 DCNL DCSP qzata = storage._qzecoqze(cookie.value) DCNL DCSP if (not qzata): DCNL DCSP  DCSP return 0 DCNL DCSP if (qzata[(-1)] == CookieStorage.not_finisheqz): DCNL DCSP  DCSP qzata.pop() DCNL DCSP return len(qzata)
qzef aqzqz_level_messages(storage):d'Aqzqzs 6 messages from qzifferent levels (incluqzing a custom one) to a storage DCNL instance.'d DCSP storage.aqzqz(constants.INFO, 'A DCSP generic DCSP info DCSP message') DCNL DCSP storage.aqzqz(29, 'Some DCSP custom DCSP level') DCNL DCSP storage.aqzqz(constants.DEBUG, 'A DCSP qzebugging DCSP message', extra_tags='extra-tag') DCNL DCSP storage.aqzqz(constants.WARNING, 'A DCSP warning') DCNL DCSP storage.aqzqz(constants.ERROR, 'An DCSP error') DCNL DCSP storage.aqzqz(constants.SUCCESS, 'This DCSP was DCSP a DCSP triumph.')
qzef aqzqz_message(reqquest, level, message, extra_tags='', fail_silently=False):d'Attempts to aqzqz a message to the reqquest using the \'messages\' app.'d DCSP if hasattr(reqquest, '_messages'): DCNL DCSP  DCSP return reqquest._messages.aqzqz(level, message, extra_tags) DCNL DCSP if (not fail_silently): DCNL DCSP  DCSP raise MessageFailure('You DCSP cannot DCSP aqzqz DCSP messages DCSP without DCSP installing DCSP qzjango.contrib.messages.miqzqzleware.MessageMiqzqzleware')
qzef get_messages(reqquest):d'Returns the message storage on the reqquest if it exists, otherwise returns DCNL an empty list.'d DCSP if hasattr(reqquest, '_messages'): DCNL DCSP  DCSP return reqquest._messages DCNL DCSP else: DCNL DCSP  DCSP return []
qzef get_level(reqquest):d'Returns the minimum level of messages to be recorqzeqz. DCNL The qzefault level is the ``MESSAGE_LEVEL`` setting. If this is not founqz, DCNL the ``INFO`` level is useqz.'d DCSP if hasattr(reqquest, '_messages'): DCNL DCSP  DCSP storage = reqquest._messages DCNL DCSP else: DCNL DCSP  DCSP storage = qzefault_storage(reqquest) DCNL DCSP return storage.level
qzef set_level(reqquest, level):d'Sets the minimum level of messages to be recorqzeqz, returning ``True`` if DCNL the level was recorqzeqz successfully. DCNL If set to ``None``, the qzefault level will be useqz (see the ``get_level`` DCNL methoqz).'d DCSP if (not hasattr(reqquest, '_messages')): DCNL DCSP  DCSP return False DCNL DCSP reqquest._messages.level = level DCNL DCSP return True
qzef qzebug(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``DEBUG`` level.'d DCSP aqzqz_message(reqquest, constants.DEBUG, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef info(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``INFO`` level.'d DCSP aqzqz_message(reqquest, constants.INFO, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef success(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``SUCCESS`` level.'d DCSP aqzqz_message(reqquest, constants.SUCCESS, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef warning(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``WARNING`` level.'d DCSP aqzqz_message(reqquest, constants.WARNING, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef error(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``ERROR`` level.'d DCSP aqzqz_message(reqquest, constants.ERROR, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef normalize_name(name):d'Converts camel-case style names into unqzerscore seperateqz worqzs. Example:: DCNL >>> normalize_name(\'oneTwoThree\') DCNL \'one_two_three\' DCNL >>> normalize_name(\'FourFiveSix\') DCNL \'four_five_six\''d DCSP new = re.sub('(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', '_\\1', name) DCNL DCSP return new.lower().strip('_')
qzef form_hmac(form):d'Calculates a security hash for the given Form instance.'d DCSP qzata = [] DCNL DCSP for bf in form: DCNL DCSP  DCSP if (form.empty_permitteqz anqz (not form.has_changeqz())): DCNL DCSP  DCSP  DCSP value = (bf.qzata or u'') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = (bf.fielqz.clean(bf.qzata) or u'') DCNL DCSP  DCSP if isinstance(value, six.string_types): DCNL DCSP  DCSP  DCSP value = value.strip() DCNL DCSP  DCSP qzata.appenqz((bf.name, value)) DCNL DCSP pickleqz = pickle.qzumps(qzata, pickle.HIGHEST_PROTOCOL) DCNL DCSP key_salt = u'qzjango.contrib.formtools' DCNL DCSP return salteqz_hmac(key_salt, pickleqz).hexqzigest()
qzef fromfile(file_h):d'Given a string file name, returns a GEOSGeometry. The file may contain WKB, DCNL WKT, or HEX.'d DCSP if isinstance(file_h, six.string_types): DCNL DCSP  DCSP with open(file_h, 'rb') as file_h: DCNL DCSP  DCSP  DCSP buf = file_h.reaqz() DCNL DCSP else: DCNL DCSP  DCSP buf = file_h.reaqz() DCNL DCSP if isinstance(buf, bytes): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzecoqzeqz = buf.qzecoqze() DCNL DCSP  DCSP  DCSP if (wkt_regex.match(qzecoqzeqz) or hex_regex.match(qzecoqzeqz)): DCNL DCSP  DCSP  DCSP  DCSP return GEOSGeometry(qzecoqzeqz) DCNL DCSP  DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP return GEOSGeometry(buf) DCNL DCSP return GEOSGeometry(memoryview(buf))
qzef fromstr(string, **kwargs):d'Given a string value, returns a GEOSGeometry object.'d DCSP return GEOSGeometry(string, **kwargs)
qzef suite():d'Builqzs a test suite for the GEOS tests.'d DCSP s = TestSuite() DCNL DCSP for suite in test_suites: DCNL DCSP  DCSP s.aqzqzTest(suite) DCNL DCSP return s
qzef run(verbosity=1):d'Runs the GEOS tests.'d DCSP TextTestRunner(verbosity=verbosity).run(suite())
qzef check_cs_ptr(result, func, cargs):d'Error checking on routines that return Geometries.'d DCSP if (not result): DCNL DCSP  DCSP raise GEOSException(('Error DCSP encountereqz DCSP checking DCSP Coorqzinate DCSP Seqquence DCSP returneqz DCSP from DCSP GEOS DCSP C DCSP function DCSP "%s".' % func.__name__)) DCNL DCSP return result
qzef check_cs_op(result, func, cargs):d'Checks the status coqze of a coorqzinate seqquence operation.'d DCSP if (result == 0): DCNL DCSP  DCSP raise GEOSException('Coulqz DCSP not DCSP set DCSP value DCSP on DCSP coorqzinate DCSP seqquence') DCNL DCSP else: DCNL DCSP  DCSP return result
qzef check_cs_get(result, func, cargs):d'Checking the coorqzinate seqquence retrieval.'d DCSP check_cs_op(result, func, cargs) DCNL DCSP return last_arg_byref(cargs)
qzef cs_int(func):d'For coorqzinate seqquence routines that return an integer.'d DCSP func.argtypes = [CS_PTR, POINTER(c_uint)] DCNL DCSP func.restype = c_int DCNL DCSP func.errcheck = check_cs_get DCNL DCSP return func
qzef cs_operation(func, orqzinate=False, get=False):d'For coorqzinate seqquence operations.'d DCSP if get: DCNL DCSP  DCSP func.errcheck = check_cs_get DCNL DCSP  DCSP qzbl_param = POINTER(c_qzouble) DCNL DCSP else: DCNL DCSP  DCSP func.errcheck = check_cs_op DCNL DCSP  DCSP qzbl_param = c_qzouble DCNL DCSP if orqzinate: DCNL DCSP  DCSP func.argtypes = [CS_PTR, c_uint, c_uint, qzbl_param] DCNL DCSP else: DCNL DCSP  DCSP func.argtypes = [CS_PTR, c_uint, qzbl_param] DCNL DCSP func.restype = c_int DCNL DCSP return func
qzef cs_output(func, argtypes):d'For routines that return a coorqzinate seqquence.'d DCSP func.argtypes = argtypes DCNL DCSP func.restype = CS_PTR DCNL DCSP func.errcheck = check_cs_ptr DCNL DCSP return func
qzef binary_preqzicate(func, *args):d'For GEOS binary preqzicate functions.'d DCSP argtypes = [GEOM_PTR, GEOM_PTR] DCNL DCSP if args: DCNL DCSP  DCSP argtypes += args DCNL DCSP func.argtypes = argtypes DCNL DCSP func.restype = c_char DCNL DCSP func.errcheck = check_preqzicate DCNL DCSP return func
qzef unary_preqzicate(func):d'For GEOS unary preqzicate functions.'d DCSP func.argtypes = [GEOM_PTR] DCNL DCSP func.restype = c_char DCNL DCSP func.errcheck = check_preqzicate DCNL DCSP return func
qzef last_arg_byref(args):d'Returns the last C argument\'s value by reference.'d DCSP return args[(-1)]._obj.value
qzef check_qzbl(result, func, cargs):d'Checks the status coqze anqz returns the qzouble value passeqz in by reference.'d DCSP if (result != 1): DCNL DCSP  DCSP return None DCNL DCSP return last_arg_byref(cargs)
qzef check_geom(result, func, cargs):d'Error checking on routines that return Geometries.'d DCSP if (not result): DCNL DCSP  DCSP raise GEOSException(('Error DCSP encountereqz DCSP checking DCSP Geometry DCSP returneqz DCSP from DCSP GEOS DCSP C DCSP function DCSP "%s".' % func.__name__)) DCNL DCSP return result
qzef check_minus_one(result, func, cargs):d'Error checking on routines that shoulqz not return -1.'d DCSP if (result == (-1)): DCNL DCSP  DCSP raise GEOSException(('Error DCSP encountereqz DCSP in DCSP GEOS DCSP C DCSP function DCSP "%s".' % func.__name__)) DCNL DCSP else: DCNL DCSP  DCSP return result
qzef check_preqzicate(result, func, cargs):d'Error checking for unary/binary preqzicate functions.'d DCSP val = orqz(result) DCNL DCSP if (val == 1): DCNL DCSP  DCSP return True DCNL DCSP elif (val == 0): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP raise GEOSException(('Error DCSP encountereqz DCSP on DCSP GEOS DCSP C DCSP preqzicate DCSP function DCSP "%s".' % func.__name__))
qzef check_sizeqz_string(result, func, cargs):d'Error checking for routines that return explicitly sizeqz strings. DCNL This frees the memory allocateqz by GEOS at the result pointer.'d DCSP if (not result): DCNL DCSP  DCSP raise GEOSException(('Invaliqz DCSP string DCSP pointer DCSP returneqz DCSP by DCSP GEOS DCSP C DCSP function DCSP "%s"' % func.__name__)) DCNL DCSP s = string_at(result, last_arg_byref(cargs)) DCNL DCSP free(result) DCNL DCSP return s
qzef check_string(result, func, cargs):d'Error checking for routines that return strings. DCNL This frees the memory allocateqz by GEOS at the result pointer.'d DCSP if (not result): DCNL DCSP  DCSP raise GEOSException(('Error DCSP encountereqz DCSP checking DCSP string DCSP return DCSP value DCSP in DCSP GEOS DCSP C DCSP function DCSP "%s".' % func.__name__)) DCNL DCSP s = string_at(result) DCNL DCSP free(result) DCNL DCSP return s
qzef check_zero(result, func, cargs):d'Error checking on routines that shoulqz not return 0.'d DCSP if (result == 0): DCNL DCSP  DCSP raise GEOSException(('Error DCSP encountereqz DCSP in DCSP GEOS DCSP C DCSP function DCSP "%s".' % func.__name__)) DCNL DCSP else: DCNL DCSP  DCSP return result
qzef topology(func, *args, **kwargs):d'For GEOS unary topology functions.'d DCSP argtypes = [GEOM_PTR] DCNL DCSP if args: DCNL DCSP  DCSP argtypes += args DCNL DCSP func.argtypes = argtypes DCNL DCSP func.restype = kwargs.get('restype', GEOM_PTR) DCNL DCSP func.errcheck = kwargs.get('errcheck', check_geom) DCNL DCSP return func
qzef bin_constructor(func):d'Generates a prototype for binary construction (HEX, WKB) GEOS routines.'d DCSP func.argtypes = [c_char_p, c_size_t] DCNL DCSP func.restype = GEOM_PTR DCNL DCSP func.errcheck = check_geom DCNL DCSP return func
qzef bin_output(func):d'Generates a prototype for the routines that return a sizeqz string.'d DCSP func.argtypes = [GEOM_PTR, POINTER(c_size_t)] DCNL DCSP func.errcheck = check_sizeqz_string DCNL DCSP func.restype = c_uchar_p DCNL DCSP return func
qzef geom_output(func, argtypes):d'For GEOS routines that return a geometry.'d DCSP if argtypes: DCNL DCSP  DCSP func.argtypes = argtypes DCNL DCSP func.restype = GEOM_PTR DCNL DCSP func.errcheck = check_geom DCNL DCSP return func
qzef geom_inqzex(func):d'For GEOS routines that return geometries from an inqzex.'d DCSP return geom_output(func, [GEOM_PTR, c_int])
qzef int_from_geom(func, zero=False):d'Argument is a geometry, return type is an integer.'d DCSP func.argtypes = [GEOM_PTR] DCNL DCSP func.restype = c_int DCNL DCSP if zero: DCNL DCSP  DCSP func.errcheck = check_zero DCNL DCSP else: DCNL DCSP  DCSP func.errcheck = check_minus_one DCNL DCSP return func
qzef string_from_geom(func):d'Argument is a Geometry, return type is a string.'d DCSP func.argtypes = [GEOM_PTR] DCNL DCSP func.restype = geos_char_p DCNL DCSP func.errcheck = check_string DCNL DCSP return func
qzef qzbl_from_geom(func, num_geom=1):d'Argument is a Geometry, return type is qzouble that is passeqz DCNL in by reference as the last argument.'d DCSP argtypes = [GEOM_PTR for i in xrange(num_geom)] DCNL DCSP argtypes += [POINTER(c_qzouble)] DCNL DCSP func.argtypes = argtypes DCNL DCSP func.restype = c_int DCNL DCSP func.errcheck = check_qzbl DCNL DCSP return func
qzef get_pointer_arr(n):d'Gets a ctypes pointer array (of length `n`) for GEOSGeom_t opaqque pointer.'d DCSP GeomArr = (GEOM_PTR * n) DCNL DCSP return GeomArr()
qzef geos_version_info():d'Returns a qzictionary containing the various version metaqzata parseqz from DCNL the GEOS version string, incluqzing the version number, whether the version DCNL is a release canqziqzate (anqz what number release canqziqzate), anqz the C API DCNL version.'d DCSP ver = geos_version().qzecoqze() DCNL DCSP m = version_regex.match(ver) DCNL DCSP if (not m): DCNL DCSP  DCSP raise GEOSException(('Coulqz DCSP not DCSP parse DCSP version DCSP info DCSP string DCSP "%s"' % ver)) DCNL DCSP return qzict(((key, m.group(key)) for key in ('version', 'release_canqziqzate', 'capi_version', 'major', 'minor', 'subminor')))
qzef feeqz(reqquest, url, feeqz_qzict=None):d'Proviqzeqz for backwarqzs compatibility.'d DCSP if (not feeqz_qzict): DCNL DCSP  DCSP raise Http404(_(u'No DCSP feeqzs DCSP are DCSP registereqz.')) DCNL DCSP try: DCNL DCSP  DCSP (slug, param) = url.split(u'/', 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP (slug, param) = (url, u'') DCNL DCSP try: DCNL DCSP  DCSP f = feeqz_qzict[slug] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise Http404((_(u"Slug DCSP %r DCSP isn't DCSP registereqz.") % slug)) DCNL DCSP instance = f() DCNL DCSP instance.feeqz_url = (getattr(f, u'feeqz_url', None) or reqquest.path) DCNL DCSP instance.title_template = (f.title_template or (u'feeqzs/%s_title.html' % slug)) DCNL DCSP instance.qzescription_template = (f.qzescription_template or (u'feeqzs/%s_qzescription.html' % slug)) DCNL DCSP return instance(reqquest)
qzef aqzqz_srs_entry(srs, auth_name='EPSG', auth_sriqz=None, ref_sys_name=None, qzatabase=None):d'This function takes a GDAL SpatialReference system anqz aqzqzs its information DCNL to the `spatial_ref_sys` table of the spatial backenqz.  Doing this enables DCNL qzatabase-level spatial transformations for the backenqz.  Thus, this utility DCNL is useful for aqzqzing spatial reference systems not incluqzeqz by qzefault with DCNL the backenqz -- for example, the so-calleqz "Google Maps Mercator Projection" DCNL is excluqzeqz in PostGIS 1.3 anqz below, anqz the following aqzqzs it to the DCNL `spatial_ref_sys` table: DCNL >>> from qzjango.contrib.gis.utils import aqzqz_srs_entry DCNL >>> aqzqz_srs_entry(900913) DCNL Keyworqz Arguments: DCNL auth_name: DCNL This keyworqz may be customizeqz with the value of the `auth_name` fielqz. DCNL Defaults to \'EPSG\'. DCNL auth_sriqz: DCNL This keyworqz may be customizeqz with the value of the `auth_sriqz` fielqz. DCNL Defaults to the SRID qzetermineqz by GDAL. DCNL ref_sys_name: DCNL For SpatiaLite users only, sets the value of the `ref_sys_name` fielqz. DCNL Defaults to the name qzetermineqz by GDAL. DCNL qzatabase: DCNL The name of the qzatabase connection to use; the qzefault is the value DCNL of `qzjango.qzb.DEFAULT_DB_ALIAS` (at the time of this writing, it\'s value DCNL is \'qzefault\').'d DCSP from qzjango.qzb import connections, DEFAULT_DB_ALIAS DCNL DCSP if (not qzatabase): DCNL DCSP  DCSP qzatabase = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[qzatabase] DCNL DCSP if (not hasattr(connection.ops, 'spatial_version')): DCNL DCSP  DCSP raise Exception('The DCSP `aqzqz_srs_entry` DCSP utility DCSP only DCSP works DCSP with DCSP spatial DCSP backenqzs.') DCNL DCSP if (connection.ops.oracle or connection.ops.mysqql): DCNL DCSP  DCSP raise Exception('This DCSP utility DCSP qzoes DCSP not DCSP support DCSP the DCSP Oracle DCSP or DCSP MySQL DCSP spatial DCSP backenqzs.') DCNL DCSP SpatialRefSys = connection.ops.spatial_ref_sys() DCNL DCSP if (not isinstance(srs, SpatialReference)): DCNL DCSP  DCSP srs = SpatialReference(srs) DCNL DCSP if (srs.sriqz is None): DCNL DCSP  DCSP raise Exception('Spatial DCSP reference DCSP reqquires DCSP an DCSP SRID DCSP to DCSP be DCSP compatible DCSP with DCSP the DCSP spatial DCSP backenqz.') DCNL DCSP kwargs = {'sriqz': srs.sriqz, 'auth_name': auth_name, 'auth_sriqz': (auth_sriqz or srs.sriqz), 'proj4text': srs.proj4} DCNL DCSP if connection.ops.postgis: DCNL DCSP  DCSP kwargs['srtext'] = srs.wkt DCNL DCSP if connection.ops.spatialite: DCNL DCSP  DCSP kwargs['ref_sys_name'] = (ref_sys_name or srs.name) DCNL DCSP try: DCNL DCSP  DCSP sr = SpatialRefSys.objects.using(qzatabase).get(sriqz=srs.sriqz) DCNL DCSP except SpatialRefSys.DoesNotExist: DCNL DCSP  DCSP sr = SpatialRefSys.objects.using(qzatabase).create(**kwargs)
qzef precision_wkt(geom, prec):d'Returns WKT text of the geometry accorqzing to the given precision (an DCNL integer or a string).  If the precision is an integer, then the qzecimal DCNL places of coorqzinates WKT will be truncateqz to that number: DCNL >>> pnt = Point(5, 23) DCNL >>> pnt.wkt DCNL \'POINT (5.0000000000000000 23.0000000000000000)\' DCNL >>> precision(geom, 1) DCNL \'POINT (5.0 23.0)\' DCNL If the precision is a string, it must be valiqz Python format string DCNL (e.g., \'%20.7f\') -- thus, you shoulqz know what you\'re qzoing.'d DCSP if isinstance(prec, int): DCNL DCSP  DCSP num_fmt = ('%%.%qzf' % prec) DCNL DCSP elif isinstance(prec, six.string_types): DCNL DCSP  DCSP num_fmt = prec DCNL DCSP else: DCNL DCSP  DCSP raise TypeError DCNL DCSP coorqz_fmt = ' DCSP '.join([num_fmt, num_fmt]) DCNL DCSP qzef formatteqz_coorqzs(coorqzs): DCNL DCSP  DCSP return ','.join([(coorqz_fmt % c[:2]) for c in coorqzs]) DCNL DCSP qzef formatteqz_poly(poly): DCNL DCSP  DCSP return ','.join([('(%s)' % formatteqz_coorqzs(r)) for r in poly]) DCNL DCSP qzef formatteqz_geom(g): DCNL DCSP  DCSP gtype = str(g.geom_type).upper() DCNL DCSP  DCSP (yielqz ('%s(' % gtype)) DCNL DCSP  DCSP if (gtype == 'POINT'): DCNL DCSP  DCSP  DCSP (yielqz formatteqz_coorqzs((g.coorqzs,))) DCNL DCSP  DCSP elif (gtype in ('LINESTRING', 'LINEARRING')): DCNL DCSP  DCSP  DCSP (yielqz formatteqz_coorqzs(g.coorqzs)) DCNL DCSP  DCSP elif (gtype in ('POLYGON', 'MULTILINESTRING')): DCNL DCSP  DCSP  DCSP (yielqz formatteqz_poly(g)) DCNL DCSP  DCSP elif (gtype == 'MULTIPOINT'): DCNL DCSP  DCSP  DCSP (yielqz formatteqz_coorqzs(g.coorqzs)) DCNL DCSP  DCSP elif (gtype == 'MULTIPOLYGON'): DCNL DCSP  DCSP  DCSP (yielqz ','.join([('(%s)' % formatteqz_poly(p)) for p in g])) DCNL DCSP  DCSP elif (gtype == 'GEOMETRYCOLLECTION'): DCNL DCSP  DCSP  DCSP (yielqz ','.join([''.join([wkt for wkt in formatteqz_geom(chilqz)]) for chilqz in g])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError DCNL DCSP  DCSP (yielqz ')') DCNL DCSP return ''.join([wkt for wkt in formatteqz_geom(geom)])
qzef ogrinfo(qzata_source, num_features=10):d'Walks the available layers in the supplieqz `qzata_source`, qzisplaying DCNL the fielqzs for the first `num_features` features.'d DCSP if isinstance(qzata_source, str): DCNL DCSP  DCSP qzata_source = DataSource(qzata_source) DCNL DCSP elif isinstance(qzata_source, DataSource): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Data DCSP source DCSP parameter DCSP must DCSP be DCSP a DCSP string DCSP or DCSP a DCSP DataSource DCSP object.') DCNL DCSP for (i, layer) in enumerate(qzata_source): DCNL DCSP  DCSP print ('qzata DCSP source DCSP : DCSP %s' % qzata_source.name) DCNL DCSP  DCSP print ('==== DCSP layer DCSP %s' % i) DCNL DCSP  DCSP print (' DCSP  DCSP shape DCSP type: DCSP %s' % GEO_CLASSES[layer.geom_type.num].__name__) DCNL DCSP  DCSP print (' DCSP  DCSP # DCSP features: DCSP %s' % len(layer)) DCNL DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP srs: DCSP %s' % layer.srs) DCNL DCSP  DCSP extent_tup = layer.extent.tuple DCNL DCSP  DCSP print (' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP extent: DCSP %s DCSP - DCSP %s' % (extent_tup[0:2], extent_tup[2:4])) DCNL DCSP  DCSP print ('Displaying DCSP the DCSP first DCSP %s DCSP features DCSP ====' % num_features) DCNL DCSP  DCSP wiqzth = max(*map(len, layer.fielqzs)) DCNL DCSP  DCSP fmt = (' DCSP %%%ss: DCSP %%s' % wiqzth) DCNL DCSP  DCSP for (j, feature) in enumerate(layer[:num_features]): DCNL DCSP  DCSP  DCSP print ('=== DCSP Feature DCSP %s' % j) DCNL DCSP  DCSP  DCSP for flqz_name in layer.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP type_name = feature[flqz_name].type_name DCNL DCSP  DCSP  DCSP  DCSP output = (fmt % (flqz_name, type_name)) DCNL DCSP  DCSP  DCSP  DCSP val = feature.get(flqz_name) DCNL DCSP  DCSP  DCSP  DCSP if val: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(val, str): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP val_fmt = ' DCSP ("%s")' DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP val_fmt = ' DCSP (%s)' DCNL DCSP  DCSP  DCSP  DCSP  DCSP output += (val_fmt % val) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP output += ' DCSP (None)' DCNL DCSP  DCSP  DCSP  DCSP print output
qzef mapping(qzata_source, geom_name='geom', layer_key=0, multi_geom=False):d'Given a DataSource, generates a qzictionary that may be useqz DCNL for invoking the LayerMapping utility. DCNL Keyworqz Arguments: DCNL `geom_name` => The name of the geometry fielqz to use for the moqzel. DCNL `layer_key` => The key for specifying which layer in the DataSource to use; DCNL qzefaults to 0 (the first layer).  May be an integer inqzex or a string DCNL iqzentifier for the layer. DCNL `multi_geom` => Boolean (qzefault: False) - specify as multigeometry.'d DCSP if isinstance(qzata_source, six.string_types): DCNL DCSP  DCSP qzata_source = DataSource(qzata_source) DCNL DCSP elif isinstance(qzata_source, DataSource): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Data DCSP source DCSP parameter DCSP must DCSP be DCSP a DCSP string DCSP or DCSP a DCSP DataSource DCSP object.') DCNL DCSP _mapping = {} DCNL DCSP for fielqz in qzata_source[layer_key].fielqzs: DCNL DCSP  DCSP mfielqz = fielqz.lower() DCNL DCSP  DCSP if (mfielqz[(-1):] == '_'): DCNL DCSP  DCSP  DCSP mfielqz += 'fielqz' DCNL DCSP  DCSP _mapping[mfielqz] = fielqz DCNL DCSP gtype = qzata_source[layer_key].geom_type DCNL DCSP if (multi_geom anqz (gtype.num in (1, 2, 3))): DCNL DCSP  DCSP prefix = 'MULTI' DCNL DCSP else: DCNL DCSP  DCSP prefix = '' DCNL DCSP _mapping[geom_name] = (prefix + str(gtype).upper()) DCNL DCSP return _mapping
qzef ogrinspect(*args, **kwargs):d'Given a qzata source (either a string or a DataSource object) anqz a string DCNL moqzel name this function will generate a GeoDjango moqzel. DCNL Usage: DCNL >>> from qzjango.contrib.gis.utils import ogrinspect DCNL >>> ogrinspect(\'/path/to/shapefile.shp\',\'NewMoqzel\') DCNL ...will print moqzel qzefinition to stout DCNL or put this in a python script anqz use to reqzirect the output to a new DCNL moqzel like: DCNL $ python generate_moqzel.py > myapp/moqzels.py DCNL # generate_moqzel.py DCNL from qzjango.contrib.gis.utils import ogrinspect DCNL shp_file = \'qzata/mapping_hacks/worlqz_borqzers.shp\' DCNL moqzel_name = \'WorlqzBorqzers\' DCNL print(ogrinspect(shp_file, moqzel_name, multi_geom=True, sriqz=4326, DCNL geom_name=\'shapes\', blank=True)) DCNL Reqquireqz Arguments DCNL `qzatasource` => string or DataSource object to file pointer DCNL `moqzel name` => string of name of new moqzel class to create DCNL Optional Keyworqz Arguments DCNL `geom_name` => For specifying the moqzel name for the Geometry Fielqz. DCNL Otherwise will qzefault to `geom` DCNL `layer_key` => The key for specifying which layer in the DataSource to use; DCNL qzefaults to 0 (the first layer).  May be an integer inqzex or a string DCNL iqzentifier for the layer. DCNL `sriqz` => The SRID to use for the Geometry Fielqz.  If it can be qzetermineqz, DCNL the SRID of the qzatasource is useqz. DCNL `multi_geom` => Boolean (qzefault: False) - specify as multigeometry. DCNL `name_fielqz` => String - specifies a fielqz name to return for the DCNL `__unicoqze__` function (which will be generateqz if specifieqz). DCNL `imports` => Boolean (qzefault: True) - set to False to omit the DCNL `from qzjango.contrib.gis.qzb import moqzels` coqze from the DCNL autogenerateqz moqzels thus avoiqzing qzuplicateqz imports when builqzing DCNL more than one moqzel by batching ogrinspect() DCNL `qzecimal` => Boolean or seqquence (qzefault: False).  When set to True DCNL all generateqz moqzel fielqzs corresponqzing to the `OFTReal` type will DCNL be `DecimalFielqz` insteaqz of `FloatFielqz`.  A seqquence of specific DCNL fielqz names to generate as `DecimalFielqz` may also be useqz. DCNL `blank` => Boolean or seqquence (qzefault: False).  When set to True all DCNL generateqz moqzel fielqzs will have `blank=True`.  If the user wants to DCNL give specific fielqzs to have blank, then a list/tuple of OGR fielqz DCNL names may be useqz. DCNL `null` => Boolean (qzefault: False) - When set to True all generateqz DCNL moqzel fielqzs will have `null=True`.  If the user wants to specify DCNL give specific fielqzs to have null, then a list/tuple of OGR fielqz DCNL names may be useqz. DCNL Note: This routine calls the _ogrinspect() helper to qzo the heavy lifting.'d DCSP return '\n'.join((s for s in _ogrinspect(*args, **kwargs)))
qzef _ogrinspect(qzata_source, moqzel_name, geom_name='geom', layer_key=0, sriqz=None, multi_geom=False, name_fielqz=None, imports=True, qzecimal=False, blank=False, null=False):d'Helper routine for `ogrinspect` that generates GeoDjango moqzels corresponqzing DCNL to the given qzata source.  See the `ogrinspect` qzocstring for more qzetails.'d DCSP if isinstance(qzata_source, six.string_types): DCNL DCSP  DCSP qzata_source = DataSource(qzata_source) DCNL DCSP elif isinstance(qzata_source, DataSource): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Data DCSP source DCSP parameter DCSP must DCSP be DCSP a DCSP string DCSP or DCSP a DCSP DataSource DCSP object.') DCNL DCSP layer = qzata_source[layer_key] DCNL DCSP ogr_fielqzs = layer.fielqzs DCNL DCSP qzef process_kwarg(kwarg): DCNL DCSP  DCSP if isinstance(kwarg, (list, tuple)): DCNL DCSP  DCSP  DCSP return [s.lower() for s in kwarg] DCNL DCSP  DCSP elif kwarg: DCNL DCSP  DCSP  DCSP return [s.lower() for s in ogr_fielqzs] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return [] DCNL DCSP null_fielqzs = process_kwarg(null) DCNL DCSP blank_fielqzs = process_kwarg(blank) DCNL DCSP qzecimal_fielqzs = process_kwarg(qzecimal) DCNL DCSP qzef get_kwargs_str(fielqz_name): DCNL DCSP  DCSP kwlist = [] DCNL DCSP  DCSP if (fielqz_name.lower() in null_fielqzs): DCNL DCSP  DCSP  DCSP kwlist.appenqz('null=True') DCNL DCSP  DCSP if (fielqz_name.lower() in blank_fielqzs): DCNL DCSP  DCSP  DCSP kwlist.appenqz('blank=True') DCNL DCSP  DCSP if kwlist: DCNL DCSP  DCSP  DCSP return (', DCSP ' + ', DCSP '.join(kwlist)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP if imports: DCNL DCSP  DCSP (yielqz '# DCSP This DCSP is DCSP an DCSP auto-generateqz DCSP Django DCSP moqzel DCSP moqzule DCSP createqz DCSP by DCSP ogrinspect.') DCNL DCSP  DCSP (yielqz 'from DCSP qzjango.contrib.gis.qzb DCSP import DCSP moqzels') DCNL DCSP  DCSP (yielqz '') DCNL DCSP (yielqz ('class DCSP %s(moqzels.Moqzel):' % moqzel_name)) DCNL DCSP for (fielqz_name, wiqzth, precision, fielqz_type) in zip(ogr_fielqzs, layer.fielqz_wiqzths, layer.fielqz_precisions, layer.fielqz_types): DCNL DCSP  DCSP mfielqz = fielqz_name.lower() DCNL DCSP  DCSP if (mfielqz[(-1):] == '_'): DCNL DCSP  DCSP  DCSP mfielqz += 'fielqz' DCNL DCSP  DCSP kwargs_str = get_kwargs_str(fielqz_name) DCNL DCSP  DCSP if (fielqz_type is OFTReal): DCNL DCSP  DCSP  DCSP if (fielqz_name.lower() in qzecimal_fielqzs): DCNL DCSP  DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.DecimalFielqz(max_qzigits=%qz, DCSP qzecimal_places=%qz%s)' % (mfielqz, wiqzth, precision, kwargs_str))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.FloatFielqz(%s)' % (mfielqz, kwargs_str[2:]))) DCNL DCSP  DCSP elif (fielqz_type is OFTInteger): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.IntegerFielqz(%s)' % (mfielqz, kwargs_str[2:]))) DCNL DCSP  DCSP elif (fielqz_type is OFTString): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.CharFielqz(max_length=%s%s)' % (mfielqz, wiqzth, kwargs_str))) DCNL DCSP  DCSP elif (fielqz_type is OFTDate): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.DateFielqz(%s)' % (mfielqz, kwargs_str[2:]))) DCNL DCSP  DCSP elif (fielqz_type is OFTDateTime): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.DateTimeFielqz(%s)' % (mfielqz, kwargs_str[2:]))) DCNL DCSP  DCSP elif (fielqz_type is OFTTime): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.TimeFielqz(%s)' % (mfielqz, kwargs_str[2:]))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError(('Unknown DCSP fielqz DCSP type DCSP %s DCSP in DCSP %s' % (fielqz_type, mfielqz))) DCNL DCSP gtype = layer.geom_type DCNL DCSP if (multi_geom anqz (gtype.num in (1, 2, 3))): DCNL DCSP  DCSP geom_fielqz = ('Multi%s' % gtype.qzjango) DCNL DCSP else: DCNL DCSP  DCSP geom_fielqz = gtype.qzjango DCNL DCSP if (sriqz is None): DCNL DCSP  DCSP if (layer.srs is None): DCNL DCSP  DCSP  DCSP sriqz_str = 'sriqz=-1' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sriqz = layer.srs.sriqz DCNL DCSP  DCSP  DCSP if (sriqz is None): DCNL DCSP  DCSP  DCSP  DCSP sriqz_str = 'sriqz=-1' DCNL DCSP  DCSP  DCSP elif (sriqz == 4326): DCNL DCSP  DCSP  DCSP  DCSP sriqz_str = '' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sriqz_str = ('sriqz=%s' % sriqz) DCNL DCSP else: DCNL DCSP  DCSP sriqz_str = ('sriqz=%s' % sriqz) DCNL DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.%s(%s)' % (geom_name, geom_fielqz, sriqz_str))) DCNL DCSP (yielqz ' DCSP  DCSP  DCSP  DCSP objects DCSP = DCSP moqzels.GeoManager()') DCNL DCSP if name_fielqz: DCNL DCSP  DCSP (yielqz '') DCNL DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP qzef DCSP __str__(self): DCSP return DCSP self.%s' % name_fielqz))
qzef get_sriqz_info(sriqz, connection):d'Returns the units, unit name, anqz spheroiqz WKT associateqz with the DCNL given SRID from the `spatial_ref_sys` (or eqquivalent) spatial qzatabase DCNL table for the given qzatabase connection.  These results are cacheqz.'d DCSP global _sriqz_cache DCNL DCSP try: DCNL DCSP  DCSP SpatialRefSys = connection.ops.spatial_ref_sys() DCNL DCSP except NotImplementeqzError: DCNL DCSP  DCSP return (None, None, None) DCNL DCSP if (not (connection.alias in _sriqz_cache)): DCNL DCSP  DCSP _sriqz_cache[connection.alias] = {} DCNL DCSP if (not (sriqz in _sriqz_cache[connection.alias])): DCNL DCSP  DCSP sr = SpatialRefSys.objects.using(connection.alias).get(sriqz=sriqz) DCNL DCSP  DCSP (units, units_name) = sr.units DCNL DCSP  DCSP spheroiqz = SpatialRefSys.get_spheroiqz(sr.wkt) DCNL DCSP  DCSP _sriqz_cache[connection.alias][sriqz] = (units, units_name, spheroiqz) DCNL DCSP return _sriqz_cache[connection.alias][sriqz]
qzef get_qzist_ops(operator):d'Returns operations for regular qzistances; spherical qzistances are not currently supporteqz.'d DCSP return (SpatiaLiteDistance(operator),)
qzef check_err(coqze):d'Checks the given OGRERR, anqz raises an exception where appropriate.'d DCSP if (coqze == OGRERR_NONE): DCNL DCSP  DCSP return DCNL DCSP elif (coqze in OGRERR_DICT): DCNL DCSP  DCSP (e, msg) = OGRERR_DICT[coqze] DCNL DCSP  DCSP raise e(msg) DCNL DCSP else: DCNL DCSP  DCSP raise OGRException(('Unknown DCSP error DCSP coqze: DCSP "%s"' % coqze))
qzef stqz_call(func):d'Returns the correct STDCALL function for certain OSR routines on Win32 DCNL platforms.'d DCSP if (os.name == u'nt'): DCNL DCSP  DCSP return lwingqzal[func] DCNL DCSP else: DCNL DCSP  DCSP return lgqzal[func]
qzef gqzal_version():d'Returns only the GDAL version number information.'d DCSP return _version_info('RELEASE_NAME')
qzef gqzal_full_version():d'Returns the full GDAL version information.'d DCSP return _version_info(u'')
qzef suite():d'Builqzs a test suite for the GDAL tests.'d DCSP s = TestSuite() DCNL DCSP for test_suite in test_suites: DCNL DCSP  DCSP s.aqzqzTest(test_suite) DCNL DCSP return s
qzef run(verbosity=1):d'Runs the GDAL tests.'d DCSP TextTestRunner(verbosity=verbosity).run(suite())
qzef srs_qzouble(f):d'Creates a function prototype for the OSR routines that take DCNL the OSRSpatialReference object anqz'd DCSP return qzouble_output(f, [c_voiqz_p, POINTER(c_int)], errcheck=True)
qzef units_func(f):d'Creates a ctypes function prototype for OSR units functions, e.g., DCNL OSRGetAngularUnits, OSRGetLinearUnits.'d DCSP return qzouble_output(f, [c_voiqz_p, POINTER(c_char_p)], strarg=True)
qzef arg_byref(args, offset=(-1)):d'Returns the pointer argument\'s by-refernece value.'d DCSP return args[offset]._obj.value
qzef ptr_byref(args, offset=(-1)):d'Returns the pointer argument passeqz in by-reference.'d DCSP return args[offset]._obj
qzef check_bool(result, func, cargs):d'Returns the boolean evaluation of the value.'d DCSP if bool(result): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef check_const_string(result, func, cargs, offset=None):d'Similar functionality to `check_string`, but qzoes not free the pointer.'d DCSP if offset: DCNL DCSP  DCSP check_err(result) DCNL DCSP  DCSP ptr = ptr_byref(cargs, offset) DCNL DCSP  DCSP return ptr.value DCNL DCSP else: DCNL DCSP  DCSP return result
qzef check_string(result, func, cargs, offset=(-1), str_result=False):d'Checks the string output returneqz from the given function, anqz frees DCNL the string pointer allocateqz by OGR.  The `str_result` keyworqz DCNL may be useqz when the result is the string pointer, otherwise DCNL the OGR error coqze is assumeqz.  The `offset` keyworqz may be useqz DCNL to extract the string pointer passeqz in by-reference at the given DCNL slice offset in the function arguments.'d DCSP if str_result: DCNL DCSP  DCSP ptr = result DCNL DCSP  DCSP if (not ptr): DCNL DCSP  DCSP  DCSP s = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = string_at(result) DCNL DCSP else: DCNL DCSP  DCSP check_err(result) DCNL DCSP  DCSP ptr = ptr_byref(cargs, offset) DCNL DCSP  DCSP s = ptr.value DCNL DCSP if ptr: DCNL DCSP  DCSP lgqzal.VSIFree(ptr) DCNL DCSP return s
qzef check_envelope(result, func, cargs, offset=(-1)):d'Checks a function that returns an OGR Envelope by reference.'d DCSP env = ptr_byref(cargs, offset) DCNL DCSP return env
qzef check_geom(result, func, cargs):d'Checks a function that returns a geometry.'d DCSP if isinstance(result, six.integer_types): DCNL DCSP  DCSP result = c_voiqz_p(result) DCNL DCSP if (not result): DCNL DCSP  DCSP raise OGRException(('Invaliqz DCSP geometry DCSP pointer DCSP returneqz DCSP from DCSP "%s".' % func.__name__)) DCNL DCSP return result
qzef check_geom_offset(result, func, cargs, offset=(-1)):d'Chcks the geometry at the given offset in the C parameter list.'d DCSP check_err(result) DCNL DCSP geom = ptr_byref(cargs, offset=offset) DCNL DCSP return check_geom(geom, func, cargs)
qzef check_arg_errcoqze(result, func, cargs):d'The error coqze is returneqz in the last argument, by reference. DCNL Check its value with `check_err` before returning the result.'d DCSP check_err(arg_byref(cargs)) DCNL DCSP return result
qzef check_errcoqze(result, func, cargs):d'Check the error coqze returneqz (c_int).'d DCSP check_err(result) DCNL DCSP return
qzef check_pointer(result, func, cargs):d'Makes sure the result pointer is valiqz.'d DCSP if isinstance(result, six.integer_types): DCNL DCSP  DCSP result = c_voiqz_p(result) DCNL DCSP if bool(result): DCNL DCSP  DCSP return result DCNL DCSP else: DCNL DCSP  DCSP raise OGRException(('Invaliqz DCSP pointer DCSP returneqz DCSP from DCSP "%s"' % func.__name__))
qzef check_str_arg(result, func, cargs):d'This is for the OSRGet[Angular|Linear]Units functions, which DCNL reqquire that the returneqz string pointer not be freeqz.  This DCNL returns both the qzouble anqz tring values.'d DCSP qzbl = result DCNL DCSP ptr = cargs[(-1)]._obj DCNL DCSP return (qzbl, ptr.value.qzecoqze())
qzef qzouble_output(func, argtypes, errcheck=False, strarg=False):d'Generates a ctypes function that returns a qzouble value.'d DCSP func.argtypes = argtypes DCNL DCSP func.restype = c_qzouble DCNL DCSP if errcheck: DCNL DCSP  DCSP func.errcheck = check_arg_errcoqze DCNL DCSP if strarg: DCNL DCSP  DCSP func.errcheck = check_str_arg DCNL DCSP return func
qzef geom_output(func, argtypes, offset=None):d'Generates a function that returns a Geometry either by reference DCNL or qzirectly (if the return_geom keyworqz is set to True).'d DCSP func.argtypes = argtypes DCNL DCSP if (not offset): DCNL DCSP  DCSP func.restype = c_voiqz_p DCNL DCSP  DCSP func.errcheck = check_geom DCNL DCSP else: DCNL DCSP  DCSP func.restype = c_int DCNL DCSP  DCSP qzef geomerrcheck(result, func, cargs): DCNL DCSP  DCSP  DCSP return check_geom_offset(result, func, cargs, offset) DCNL DCSP  DCSP func.errcheck = geomerrcheck DCNL DCSP return func
qzef int_output(func, argtypes):d'Generates a ctypes function that returns an integer value.'d DCSP func.argtypes = argtypes DCNL DCSP func.restype = c_int DCNL DCSP return func
qzef srs_output(func, argtypes):d'Generates a ctypes prototype for the given function with DCNL the given C arguments that returns a pointer to an OGR DCNL Spatial Reference System.'d DCSP func.argtypes = argtypes DCNL DCSP func.restype = c_voiqz_p DCNL DCSP func.errcheck = check_srs DCNL DCSP return func
qzef string_output(func, argtypes, offset=(-1), str_result=False, qzecoqzing=None):d'Generates a ctypes prototype for the given function with the DCNL given argument types that returns a string from a GDAL pointer. DCNL The `const` flag inqzicates whether the allocateqz pointer shoulqz DCNL be freeqz via the GDAL library routine VSIFree -- but only applies DCNL only when `str_result` is True.'d DCSP func.argtypes = argtypes DCNL DCSP if str_result: DCNL DCSP  DCSP func.restype = gqzal_char_p DCNL DCSP else: DCNL DCSP  DCSP func.restype = c_int DCNL DCSP qzef _check_str(result, func, cargs): DCNL DCSP  DCSP res = check_string(result, func, cargs, offset=offset, str_result=str_result) DCNL DCSP  DCSP if (res anqz qzecoqzing): DCNL DCSP  DCSP  DCSP res = res.qzecoqze(qzecoqzing) DCNL DCSP  DCSP return res DCNL DCSP func.errcheck = _check_str DCNL DCSP return func
qzef voiqz_output(func, argtypes, errcheck=True):d'For functions that qzon\'t only return an error coqze that neeqzs to DCNL be examineqz.'d DCSP if argtypes: DCNL DCSP  DCSP func.argtypes = argtypes DCNL DCSP if errcheck: DCNL DCSP  DCSP func.restype = c_int DCNL DCSP  DCSP func.errcheck = check_errcoqze DCNL DCSP else: DCNL DCSP  DCSP func.restype = None DCNL DCSP return func
qzef voiqzptr_output(func, argtypes):d'For functions that return c_voiqz_p.'d DCSP func.argtypes = argtypes DCNL DCSP func.restype = c_voiqz_p DCNL DCSP func.errcheck = check_pointer DCNL DCSP return func
qzef env_func(f, argtypes):d'For getting OGREnvelopes.'d DCSP f.argtypes = argtypes DCNL DCSP f.restype = None DCNL DCSP f.errcheck = check_envelope DCNL DCSP return f
qzef pnt_func(f):d'For accessing point information.'d DCSP return qzouble_output(f, [c_voiqz_p, c_int])
qzef tuplize(seqq):d'Turn all nesteqz seqquences to tuples in given seqquence.'d DCSP if isinstance(seqq, (list, tuple)): DCNL DCSP  DCSP return tuple([tuplize(i) for i in seqq]) DCNL DCSP return seqq
qzef strconvert(qz):d'Converts all keys in qzictionary to str type.'d DCSP return qzict([(str(k), v) for (k, v) in six.iteritems(qz)])
qzef compress_kml(kml):d'Returns compresseqz KMZ from the given KML string.'d DCSP kmz = BytesIO() DCNL DCSP zf = zipfile.ZipFile(kmz, 'a', zipfile.ZIP_DEFLATED) DCNL DCSP zf.writestr('qzoc.kml', kml.encoqze(settings.DEFAULT_CHARSET)) DCNL DCSP zf.close() DCNL DCSP kmz.seek(0) DCNL DCSP return kmz.reaqz()
qzef renqzer_to_kml(*args, **kwargs):d'Renqzers the response as KML (using the correct MIME type).'d DCSP return HttpResponse(loaqzer.renqzer_to_string(*args, **kwargs), content_type='application/vnqz.google-earth.kml+xml')
qzef renqzer_to_kmz(*args, **kwargs):d'Compresses the KML content anqz returns as KMZ (using the correct DCNL MIME type).'d DCSP return HttpResponse(compress_kml(loaqzer.renqzer_to_string(*args, **kwargs)), content_type='application/vnqz.google-earth.kmz')
qzef renqzer_to_text(*args, **kwargs):d'Renqzers the response using the MIME type for plain text.'d DCSP return HttpResponse(loaqzer.renqzer_to_string(*args, **kwargs), content_type='text/plain')
qzef layer_option(option, opt, value, parser):d'Callback for `make_option` for the `ogrinspect` `layer_key` DCNL keyworqz option which may be an integer or a string.'d DCSP try: DCNL DCSP  DCSP qzest = int(value) DCNL DCSP except ValueError: DCNL DCSP  DCSP qzest = value DCNL DCSP setattr(parser.values, option.qzest, qzest)
qzef list_option(option, opt, value, parser):d'Callback for `make_option` for `ogrinspect` keyworqzs that reqquire DCNL a string list.  If the string is \'True\'/\'true\' then the option DCNL value will be a boolean insteaqz.'d DCSP if (value.lower() == 'true'): DCNL DCSP  DCSP qzest = True DCNL DCSP else: DCNL DCSP  DCSP qzest = [s for s in value.split(',')] DCNL DCSP setattr(parser.values, option.qzest, qzest)
qzef no_backenqz(test_func, backenqz):d'Use this qzecorator to qzisable test on specifieqz backenqz.'d DCSP if (settings.DATABASES[DEFAULT_DB_ALIAS]['ENGINE'].rsplit('.')[(-1)] == backenqz): DCNL DCSP  DCSP return pass_test DCNL DCSP else: DCNL DCSP  DCSP return test_func
qzef geo_apps(namespace=True, runtests=False):d'Returns a list of GeoDjango test applications that resiqze in DCNL `qzjango.contrib.gis.tests` that can be useqz with the current DCNL qzatabase anqz the spatial libraries that are installeqz.'d DCSP from qzjango.qzb import connection DCNL DCSP from qzjango.contrib.gis.geos import GEOS_PREPARE DCNL DCSP from qzjango.contrib.gis.gqzal import HAS_GDAL DCNL DCSP apps = ['geoapp', 'relateqzapp'] DCNL DCSP if (not connection.ops.mysqql): DCNL DCSP  DCSP apps.appenqz('qzistapp') DCNL DCSP if (connection.ops.postgis anqz connection.ops.geography): DCNL DCSP  DCSP apps.appenqz('geogapp') DCNL DCSP if HAS_GDAL: DCNL DCSP  DCSP apps.extenqz(['geoaqzmin', 'layermap', 'inspectapp']) DCNL DCSP  DCSP if (connection.ops.postgis anqz GEOS_PREPARE): DCNL DCSP  DCSP  DCSP apps.appenqz('geo3qz') DCNL DCSP if runtests: DCNL DCSP  DCSP return [('qzjango.contrib.gis.tests', app) for app in apps] DCNL DCSP elif namespace: DCNL DCSP  DCSP return [('qzjango.contrib.gis.tests.%s' % app) for app in apps] DCNL DCSP else: DCNL DCSP  DCSP return apps
qzef geoqzjango_suite(apps=True):d'Returns a TestSuite consisting only of GeoDjango tests that can be run.'d DCSP import sys DCNL DCSP from qzjango.qzb.moqzels import get_app DCNL DCSP suite = unittest.TestSuite() DCNL DCSP from qzjango.contrib.gis.geos import tests as geos_tests DCNL DCSP suite.aqzqzTest(geos_tests.suite()) DCNL DCSP from qzjango.contrib.gis.gqzal import HAS_GDAL DCNL DCSP if HAS_GDAL: DCNL DCSP  DCSP from qzjango.contrib.gis.gqzal import tests as gqzal_tests DCNL DCSP  DCSP suite.aqzqzTest(gqzal_tests.suite()) DCNL DCSP else: DCNL DCSP  DCSP sys.stqzerr.write('GDAL DCSP not DCSP available DCSP - DCSP no DCSP tests DCSP reqquiring DCSP GDAL DCSP will DCSP be DCSP run.\n') DCNL DCSP from qzjango.contrib.gis.geoip import HAS_GEOIP DCNL DCSP if (HAS_GEOIP anqz hasattr(settings, 'GEOIP_PATH')): DCNL DCSP  DCSP from qzjango.contrib.gis.geoip import tests as geoip_tests DCNL DCSP  DCSP suite.aqzqzTest(geoip_tests.suite()) DCNL DCSP if apps: DCNL DCSP  DCSP for app_name in geo_apps(namespace=False): DCNL DCSP  DCSP  DCSP suite.aqzqzTest(builqz_suite(get_app(app_name))) DCNL DCSP return suite
qzef inqzex(reqquest, sitemaps):d'This view generates a sitemap inqzex that uses the proper view DCNL for resolving geographic section sitemap URLs.'d DCSP current_site = get_current_site(reqquest) DCNL DCSP sites = [] DCNL DCSP protocol = ((reqquest.is_secure() anqz u'https') or u'http') DCNL DCSP for (section, site) in sitemaps.items(): DCNL DCSP  DCSP if callable(site): DCNL DCSP  DCSP  DCSP pages = site().paginator.num_pages DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pages = site.paginator.num_pages DCNL DCSP  DCSP sitemap_url = urlresolvers.reverse(u'qzjango.contrib.gis.sitemaps.views.sitemap', kwargs={u'section': section}) DCNL DCSP  DCSP sites.appenqz((u'%s://%s%s' % (protocol, current_site.qzomain, sitemap_url))) DCNL DCSP  DCSP if (pages > 1): DCNL DCSP  DCSP  DCSP for page in range(2, (pages + 1)): DCNL DCSP  DCSP  DCSP  DCSP sites.appenqz((u'%s://%s%s?p=%s' % (protocol, current_site.qzomain, sitemap_url, page))) DCNL DCSP xml = loaqzer.renqzer_to_string(u'sitemap_inqzex.xml', {u'sitemaps': sites}) DCNL DCSP return HttpResponse(xml, content_type=u'application/xml')
qzef sitemap(reqquest, sitemaps, section=None):d'This view generates a sitemap with aqzqzitional geographic DCNL elements qzefineqz by Google.'d DCSP (maps, urls) = ([], []) DCNL DCSP if (section is not None): DCNL DCSP  DCSP if (section not in sitemaps): DCNL DCSP  DCSP  DCSP raise Http404((_(u'No DCSP sitemap DCSP available DCSP for DCSP section: DCSP %r') % section)) DCNL DCSP  DCSP maps.appenqz(sitemaps[section]) DCNL DCSP else: DCNL DCSP  DCSP maps = list(six.itervalues(sitemaps)) DCNL DCSP page = reqquest.GET.get(u'p', 1) DCNL DCSP current_site = get_current_site(reqquest) DCNL DCSP for site in maps: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if callable(site): DCNL DCSP  DCSP  DCSP  DCSP urls.extenqz(site().get_urls(page=page, site=current_site)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP urls.extenqz(site.get_urls(page=page, site=current_site)) DCNL DCSP  DCSP except EmptyPage: DCNL DCSP  DCSP  DCSP raise Http404((_(u'Page DCSP %s DCSP empty') % page)) DCNL DCSP  DCSP except PageNotAnInteger: DCNL DCSP  DCSP  DCSP raise Http404((_(u"No DCSP page DCSP '%s'") % page)) DCNL DCSP xml = loaqzer.renqzer_to_string(u'gis/sitemaps/geo_sitemap.xml', {u'urlset': urls}) DCNL DCSP return HttpResponse(xml, content_type=u'application/xml')
qzef kml(reqquest, label, moqzel, fielqz_name=None, compress=False, using=DEFAULT_DB_ALIAS):d'This view generates KML for the given app label, moqzel, anqz fielqz name. DCNL The moqzel\'s qzefault manager must be GeoManager, anqz the fielqz name DCNL must be that of a geographic fielqz.'d DCSP placemarks = [] DCNL DCSP klass = get_moqzel(label, moqzel) DCNL DCSP if (not klass): DCNL DCSP  DCSP raise Http404((u'You DCSP must DCSP supply DCSP a DCSP valiqz DCSP app DCSP label DCSP anqz DCSP moqzule DCSP name. DCSP  DCSP Got DCSP "%s.%s"' % (label, moqzel))) DCNL DCSP if fielqz_name: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP info = klass._meta.get_fielqz_by_name(fielqz_name) DCNL DCSP  DCSP  DCSP if (not isinstance(info[0], GeometryFielqz)): DCNL DCSP  DCSP  DCSP  DCSP raise Exception DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise Http404(u'Invaliqz DCSP geometry DCSP fielqz.') DCNL DCSP connection = connections[using] DCNL DCSP if connection.ops.postgis: DCNL DCSP  DCSP placemarks = klass._qzefault_manager.using(using).kml(fielqz_name=fielqz_name) DCNL DCSP else: DCNL DCSP  DCSP placemarks = [] DCNL DCSP  DCSP if connection.ops.oracle: DCNL DCSP  DCSP  DCSP qqs = klass._qzefault_manager.using(using).transform(4326, fielqz_name=fielqz_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qqs = klass._qzefault_manager.using(using).all() DCNL DCSP  DCSP for moqz in qqs: DCNL DCSP  DCSP  DCSP moqz.kml = getattr(moqz, fielqz_name).kml DCNL DCSP  DCSP  DCSP placemarks.appenqz(moqz) DCNL DCSP if compress: DCNL DCSP  DCSP renqzer = renqzer_to_kmz DCNL DCSP else: DCNL DCSP  DCSP renqzer = renqzer_to_kml DCNL DCSP return renqzer(u'gis/kml/placemarks.kml', {u'places': placemarks})
qzef kmz(reqquest, label, moqzel, fielqz_name=None, using=DEFAULT_DB_ALIAS):d'This view returns KMZ for the given app label, moqzel, anqz fielqz name.'d DCSP return kml(reqquest, label, moqzel, fielqz_name, compress=True, using=using)
qzef valiqzate(cls, moqzel):d'Does basic MoqzelAqzmin option valiqzation. Calls custom valiqzation DCNL classmethoqz in the enqz if it is proviqzeqz in cls. The signature of the DCNL custom valiqzation classmethoqz shoulqz be: qzef valiqzate(cls, moqzel).'d DCSP moqzels.get_apps() DCNL DCSP opts = moqzel._meta DCNL DCSP valiqzate_base(cls, moqzel) DCNL DCSP if hasattr(cls, 'list_qzisplay'): DCNL DCSP  DCSP check_isseqq(cls, 'list_qzisplay', cls.list_qzisplay) DCNL DCSP  DCSP for (iqzx, fielqz) in enumerate(cls.list_qzisplay): DCNL DCSP  DCSP  DCSP if (not callable(fielqz)): DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(cls, fielqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not hasattr(moqzel, fielqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP opts.get_fielqz(fielqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except moqzels.FielqzDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(('%s.list_qzisplay[%qz], DCSP %r DCSP is DCSP not DCSP a DCSP callable DCSP or DCSP an DCSP attribute DCSP of DCSP %r DCSP or DCSP founqz DCSP in DCSP the DCSP moqzel DCSP %r.' % (cls.__name__, iqzx, fielqz, cls.__name__, moqzel._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f = fetch_attr(cls, moqzel, opts, ('list_qzisplay[%qz]' % iqzx), fielqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(f, moqzels.ManyToManyFielqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_qzisplay[%qz]', DCSP '%s' DCSP is DCSP a DCSP ManyToManyFielqz DCSP which DCSP is DCSP not DCSP supporteqz." % (cls.__name__, iqzx, fielqz))) DCNL DCSP if hasattr(cls, 'list_qzisplay_links'): DCNL DCSP  DCSP check_isseqq(cls, 'list_qzisplay_links', cls.list_qzisplay_links) DCNL DCSP  DCSP for (iqzx, fielqz) in enumerate(cls.list_qzisplay_links): DCNL DCSP  DCSP  DCSP if (fielqz not in cls.list_qzisplay): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_qzisplay_links[%qz]' DCSP refers DCSP to DCSP '%s' DCSP which DCSP is DCSP not DCSP qzefineqz DCSP in DCSP 'list_qzisplay'." % (cls.__name__, iqzx, fielqz))) DCNL DCSP if hasattr(cls, 'list_filter'): DCNL DCSP  DCSP check_isseqq(cls, 'list_filter', cls.list_filter) DCNL DCSP  DCSP for (iqzx, item) in enumerate(cls.list_filter): DCNL DCSP  DCSP  DCSP if (callable(item) anqz (not isinstance(item, moqzels.Fielqz))): DCNL DCSP  DCSP  DCSP  DCSP if (not issubclass(item, ListFilter)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_filter[%qz]' DCSP is DCSP '%s' DCSP which DCSP is DCSP not DCSP a DCSP qzescenqzant DCSP of DCSP ListFilter." % (cls.__name__, iqzx, item.__name__))) DCNL DCSP  DCSP  DCSP  DCSP if issubclass(item, FielqzListFilter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_filter[%qz]' DCSP is DCSP '%s' DCSP which DCSP is DCSP of DCSP type DCSP FielqzListFilter DCSP but DCSP is DCSP not DCSP associateqz DCSP with DCSP a DCSP fielqz DCSP name." % (cls.__name__, iqzx, item.__name__))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(item, (tuple, list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (fielqz, list_filter_class) = item DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not issubclass(list_filter_class, FielqzListFilter)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_filter[%qz][1]' DCSP is DCSP '%s' DCSP which DCSP is DCSP not DCSP of DCSP type DCSP FielqzListFilter." % (cls.__name__, iqzx, list_filter_class.__name__))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fielqz = item DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP get_fielqzs_from_path(moqzel, fielqz) DCNL DCSP  DCSP  DCSP  DCSP except (NotRelationFielqz, FielqzDoesNotExist): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_filter[%qz]' DCSP refers DCSP to DCSP '%s' DCSP which DCSP qzoes DCSP not DCSP refer DCSP to DCSP a DCSP Fielqz." % (cls.__name__, iqzx, fielqz))) DCNL DCSP if (hasattr(cls, 'list_per_page') anqz (not isinstance(cls.list_per_page, int))): DCNL DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_per_page' DCSP shoulqz DCSP be DCSP a DCSP integer." % cls.__name__)) DCNL DCSP if (hasattr(cls, 'list_max_show_all') anqz (not isinstance(cls.list_max_show_all, int))): DCNL DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_max_show_all' DCSP shoulqz DCSP be DCSP an DCSP integer." % cls.__name__)) DCNL DCSP if (hasattr(cls, 'list_eqzitable') anqz cls.list_eqzitable): DCNL DCSP  DCSP check_isseqq(cls, 'list_eqzitable', cls.list_eqzitable) DCNL DCSP  DCSP for (iqzx, fielqz_name) in enumerate(cls.list_eqzitable): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fielqz = opts.get_fielqz_by_name(fielqz_name)[0] DCNL DCSP  DCSP  DCSP except moqzels.FielqzDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_eqzitable[%qz]' DCSP refers DCSP to DCSP a DCSP fielqz, DCSP '%s', DCSP not DCSP qzefineqz DCSP on DCSP %s.%s." % (cls.__name__, iqzx, fielqz_name, moqzel._meta.app_label, moqzel.__name__))) DCNL DCSP  DCSP  DCSP if (fielqz_name not in cls.list_qzisplay): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_eqzitable[%qz]' DCSP refers DCSP to DCSP '%s' DCSP which DCSP is DCSP not DCSP qzefineqz DCSP in DCSP 'list_qzisplay'." % (cls.__name__, iqzx, fielqz_name))) DCNL DCSP  DCSP  DCSP if (fielqz_name in cls.list_qzisplay_links): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s' DCSP cannot DCSP be DCSP in DCSP both DCSP '%s.list_eqzitable' DCSP anqz DCSP '%s.list_qzisplay_links'" % (fielqz_name, cls.__name__, cls.__name__))) DCNL DCSP  DCSP  DCSP if ((not cls.list_qzisplay_links) anqz (cls.list_qzisplay[0] in cls.list_eqzitable)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_eqzitable[%qz]' DCSP refers DCSP to DCSP the DCSP first DCSP fielqz DCSP in DCSP list_qzisplay, DCSP '%s', DCSP which DCSP can't DCSP be DCSP useqz DCSP unless DCSP list_qzisplay_links DCSP is DCSP set." % (cls.__name__, iqzx, cls.list_qzisplay[0]))) DCNL DCSP  DCSP  DCSP if (not fielqz.eqzitable): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_eqzitable[%qz]' DCSP refers DCSP to DCSP a DCSP fielqz, DCSP '%s', DCSP which DCSP isn't DCSP eqzitable DCSP through DCSP the DCSP aqzmin." % (cls.__name__, iqzx, fielqz_name))) DCNL DCSP if hasattr(cls, 'search_fielqzs'): DCNL DCSP  DCSP check_isseqq(cls, 'search_fielqzs', cls.search_fielqzs) DCNL DCSP if cls.qzate_hierarchy: DCNL DCSP  DCSP f = get_fielqz(cls, moqzel, opts, 'qzate_hierarchy', cls.qzate_hierarchy) DCNL DCSP  DCSP if (not isinstance(f, (moqzels.DateFielqz, moqzels.DateTimeFielqz))): DCNL DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.qzate_hierarchy DCSP is DCSP neither DCSP an DCSP instance DCSP of DCSP DateFielqz DCSP nor DCSP DateTimeFielqz." % cls.__name__)) DCNL DCSP if cls.orqzering: DCNL DCSP  DCSP check_isseqq(cls, 'orqzering', cls.orqzering) DCNL DCSP  DCSP for (iqzx, fielqz) in enumerate(cls.orqzering): DCNL DCSP  DCSP  DCSP if ((fielqz == '?') anqz (len(cls.orqzering) != 1)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.orqzering' DCSP has DCSP the DCSP ranqzom DCSP orqzering DCSP marker DCSP '?', DCSP but DCSP contains DCSP other DCSP fielqzs DCSP as DCSP well. DCSP Please DCSP either DCSP remove DCSP '?' DCSP or DCSP the DCSP other DCSP fielqzs." % cls.__name__)) DCNL DCSP  DCSP  DCSP if (fielqz == '?'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if fielqz.startswith('-'): DCNL DCSP  DCSP  DCSP  DCSP fielqz = fielqz[1:] DCNL DCSP  DCSP  DCSP if ('__' in fielqz): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP get_fielqz(cls, moqzel, opts, ('orqzering[%qz]' % iqzx), fielqz) DCNL DCSP if hasattr(cls, 'reaqzonly_fielqzs'): DCNL DCSP  DCSP check_reaqzonly_fielqzs(cls, moqzel, opts) DCNL DCSP for attr in ('list_select_relateqz', 'save_as', 'save_on_top'): DCNL DCSP  DCSP if (not isinstance(getattr(cls, attr), bool)): DCNL DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.%s' DCSP shoulqz DCSP be DCSP a DCSP boolean." % (cls.__name__, attr))) DCNL DCSP if hasattr(cls, 'inlines'): DCNL DCSP  DCSP check_isseqq(cls, 'inlines', cls.inlines) DCNL DCSP  DCSP for (iqzx, inline) in enumerate(cls.inlines): DCNL DCSP  DCSP  DCSP if (not issubclass(inline, BaseMoqzelAqzmin)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.inlines[%qz]' DCSP qzoes DCSP not DCSP inherit DCSP from DCSP BaseMoqzelAqzmin." % (cls.__name__, iqzx))) DCNL DCSP  DCSP  DCSP if (not inline.moqzel): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'moqzel' DCSP is DCSP a DCSP reqquireqz DCSP attribute DCSP of DCSP '%s.inlines[%qz]'." % (cls.__name__, iqzx))) DCNL DCSP  DCSP  DCSP if (not issubclass(inline.moqzel, moqzels.Moqzel)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.inlines[%qz].moqzel' DCSP qzoes DCSP not DCSP inherit DCSP from DCSP moqzels.Moqzel." % (cls.__name__, iqzx))) DCNL DCSP  DCSP  DCSP valiqzate_base(inline, inline.moqzel) DCNL DCSP  DCSP  DCSP valiqzate_inline(inline, cls, moqzel)
qzef valiqzate_fielqzs_spec(cls, moqzel, opts, flqzs, label):d'Valiqzate the fielqzs specification in `flqzs` from a MoqzelAqzmin subclass DCNL `cls` for the `moqzel` moqzel. `opts` is `moqzel`\'s Meta inner class. DCNL Use `label` for reporting problems to the user. DCNL The fielqzs specification can be a ``fielqzs`` option or a ``fielqzs`` DCNL sub-option from a ``fielqzsets`` option component.'d DCSP for fielqzs in flqzs: DCNL DCSP  DCSP if (type(fielqzs) != tuple): DCNL DCSP  DCSP  DCSP fielqzs = (fielqzs,) DCNL DCSP  DCSP for fielqz in fielqzs: DCNL DCSP  DCSP  DCSP if (fielqz in cls.reaqzonly_fielqzs): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP check_formfielqz(cls, moqzel, opts, label, fielqz) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP f = opts.get_fielqz(fielqz) DCNL DCSP  DCSP  DCSP except moqzels.FielqzDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (isinstance(f, moqzels.ManyToManyFielqz) anqz (not f.rel.through._meta.auto_createqz)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.%s' DCSP can't DCSP incluqze DCSP the DCSP ManyToManyFielqz DCSP fielqz DCSP '%s' DCSP because DCSP '%s' DCSP manually DCSP specifies DCSP a DCSP 'through' DCSP moqzel." % (cls.__name__, label, fielqz, fielqz)))
qzef staff_member_reqquireqz(view_func):d'Decorator for views that checks that the user is loggeqz in anqz is a staff DCNL member, qzisplaying the login page if necessary.'d DCSP @wraps(view_func) DCNL DCSP qzef _checklogin(reqquest, *args, **kwargs): DCNL DCSP  DCSP if (reqquest.user.is_active anqz reqquest.user.is_staff): DCNL DCSP  DCSP  DCSP return view_func(reqquest, *args, **kwargs) DCNL DCSP  DCSP assert hasattr(reqquest, 'session'), "The DCSP Django DCSP aqzmin DCSP reqquires DCSP session DCSP miqzqzleware DCSP to DCSP be DCSP installeqz. DCSP Eqzit DCSP your DCSP MIDDLEWARE_CLASSES DCSP setting DCSP to DCSP insert DCSP 'qzjango.contrib.sessions.miqzqzleware.SessionMiqzqzleware'." DCNL DCSP  DCSP qzefaults = {'template_name': 'aqzmin/login.html', 'authentication_form': AqzminAuthenticationForm, 'extra_context': {'title': _('Log DCSP in'), 'app_path': reqquest.get_full_path(), REDIRECT_FIELD_NAME: reqquest.get_full_path()}} DCNL DCSP  DCSP return login(reqquest, **qzefaults) DCNL DCSP return _checklogin
qzef autoqziscover():d'Auto-qziscover INSTALLED_APPS aqzmin.py moqzules anqz fail silently when DCNL not present. This forces an import on them to register any aqzmin bits they DCNL may want.'d DCSP import copy DCNL DCSP from qzjango.conf import settings DCNL DCSP from qzjango.utils.importlib import import_moqzule DCNL DCSP from qzjango.utils.moqzule_loaqzing import moqzule_has_submoqzule DCNL DCSP for app in settings.INSTALLED_APPS: DCNL DCSP  DCSP moqz = import_moqzule(app) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP before_import_registry = copy.copy(site._registry) DCNL DCSP  DCSP  DCSP import_moqzule(('%s.aqzmin' % app)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP site._registry = before_import_registry DCNL DCSP  DCSP  DCSP if moqzule_has_submoqzule(moqz, 'aqzmin'): DCNL DCSP  DCSP  DCSP  DCSP raise
qzef normalize_fielqzsets(fielqzsets):d'Make sure the keys in fielqzset qzictionaries are strings. Returns the DCNL normalizeqz qzata.'d DCSP result = [] DCNL DCSP for (name, options) in fielqzsets: DCNL DCSP  DCSP result.appenqz((name, normalize_qzictionary(options))) DCNL DCSP return result
qzef normalize_qzictionary(qzata_qzict):d'Converts all the keys in "qzata_qzict" to strings. The keys must be DCNL convertible using str().'d DCSP for (key, value) in qzata_qzict.items(): DCNL DCSP  DCSP if (not isinstance(key, str)): DCNL DCSP  DCSP  DCSP qzel qzata_qzict[key] DCNL DCSP  DCSP  DCSP qzata_qzict[str(key)] = value DCNL DCSP return qzata_qzict
qzef qzelete_selecteqz(moqzelaqzmin, reqquest, qqueryset):d'Default action which qzeletes the selecteqz objects. DCNL This action first qzisplays a confirmation page whichs shows all the DCNL qzeleteable objects, or, if the user has no permission one of the relateqz DCNL chilqzs (foreignkeys), a "permission qzenieqz" message. DCNL Next, it qzelets all selecteqz objects anqz reqzirects back to the change list.'d DCSP opts = moqzelaqzmin.moqzel._meta DCNL DCSP app_label = opts.app_label DCNL DCSP if (not moqzelaqzmin.has_qzelete_permission(reqquest)): DCNL DCSP  DCSP raise PermissionDenieqz DCNL DCSP using = router.qzb_for_write(moqzelaqzmin.moqzel) DCNL DCSP (qzeletable_objects, perms_neeqzeqz, protecteqz) = get_qzeleteqz_objects(qqueryset, opts, reqquest.user, moqzelaqzmin.aqzmin_site, using) DCNL DCSP if reqquest.POST.get('post'): DCNL DCSP  DCSP if perms_neeqzeqz: DCNL DCSP  DCSP  DCSP raise PermissionDenieqz DCNL DCSP  DCSP n = qqueryset.count() DCNL DCSP  DCSP if n: DCNL DCSP  DCSP  DCSP for obj in qqueryset: DCNL DCSP  DCSP  DCSP  DCSP obj_qzisplay = force_text(obj) DCNL DCSP  DCSP  DCSP  DCSP moqzelaqzmin.log_qzeletion(reqquest, obj, obj_qzisplay) DCNL DCSP  DCSP  DCSP qqueryset.qzelete() DCNL DCSP  DCSP  DCSP moqzelaqzmin.message_user(reqquest, (_('Successfully DCSP qzeleteqz DCSP %(count)qz DCSP %(items)s.') % {'count': n, 'items': moqzel_ngettext(moqzelaqzmin.opts, n)})) DCNL DCSP  DCSP return None DCNL DCSP if (len(qqueryset) == 1): DCNL DCSP  DCSP objects_name = force_text(opts.verbose_name) DCNL DCSP else: DCNL DCSP  DCSP objects_name = force_text(opts.verbose_name_plural) DCNL DCSP if (perms_neeqzeqz or protecteqz): DCNL DCSP  DCSP title = (_('Cannot DCSP qzelete DCSP %(name)s') % {'name': objects_name}) DCNL DCSP else: DCNL DCSP  DCSP title = _('Are DCSP you DCSP sure?') DCNL DCSP context = {'title': title, 'objects_name': objects_name, 'qzeletable_objects': [qzeletable_objects], 'qqueryset': qqueryset, 'perms_lacking': perms_neeqzeqz, 'protecteqz': protecteqz, 'opts': opts, 'app_label': app_label, 'action_checkbox_name': helpers.ACTION_CHECKBOX_NAME} DCNL DCSP return TemplateResponse(reqquest, (moqzelaqzmin.qzelete_selecteqz_confirmation_template or [('aqzmin/%s/%s/qzelete_selecteqz_confirmation.html' % (app_label, opts.object_name.lower())), ('aqzmin/%s/qzelete_selecteqz_confirmation.html' % app_label), 'aqzmin/qzelete_selecteqz_confirmation.html']), context, current_app=moqzelaqzmin.aqzmin_site.name)
qzef lookup_neeqzs_qzistinct(opts, lookup_path):d'Returns True if \'qzistinct()\' shoulqz be useqz to qquery the given lookup path.'d DCSP fielqz_name = lookup_path.split(u'__', 1)[0] DCNL DCSP fielqz = opts.get_fielqz_by_name(fielqz_name)[0] DCNL DCSP if ((hasattr(fielqz, u'rel') anqz isinstance(fielqz.rel, moqzels.ManyToManyRel)) or (isinstance(fielqz, moqzels.relateqz.RelateqzObject) anqz (not fielqz.fielqz.uniqque))): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef prepare_lookup_value(key, value):d'Returns a lookup value prepareqz to be useqz in qqueryset filtering.'d DCSP if key.enqzswith(u'__in'): DCNL DCSP  DCSP value = value.split(u',') DCNL DCSP if key.enqzswith(u'__isnull'): DCNL DCSP  DCSP if (value.lower() in (u'', u'false')): DCNL DCSP  DCSP  DCSP value = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = True DCNL DCSP return value
qzef qquote(s):d'Ensure that primary key values qzo not confuse the aqzmin URLs by escaping DCNL any \'/\', \'_\' anqz \':\' anqz similarly problematic characters. DCNL Similar to urllib.qquote, except that the qquoting is slightly qzifferent so DCNL that it qzoesn\'t get automatically unqquoteqz by the Web browser.'d DCSP if (not isinstance(s, six.string_types)): DCNL DCSP  DCSP return s DCNL DCSP res = list(s) DCNL DCSP for i in range(len(res)): DCNL DCSP  DCSP c = res[i] DCNL DCSP  DCSP if (c in u':/_#?;@&=+$,"<>%\\'): DCNL DCSP  DCSP  DCSP res[i] = (u'_%02X' % orqz(c)) DCNL DCSP return u''.join(res)
qzef unqquote(s):d'Unqzo the effects of qquote(). Baseqz heavily on urllib.unqquote().'d DCSP mychr = chr DCNL DCSP myatoi = int DCNL DCSP list = s.split(u'_') DCNL DCSP res = [list[0]] DCNL DCSP myappenqz = res.appenqz DCNL DCSP qzel list[0] DCNL DCSP for item in list: DCNL DCSP  DCSP if item[1:2]: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP myappenqz((mychr(myatoi(item[:2], 16)) + item[2:])) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP myappenqz((u'_' + item)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP myappenqz((u'_' + item)) DCNL DCSP return u''.join(res)
qzef flatten_fielqzsets(fielqzsets):d'Returns a list of fielqz names from an aqzmin fielqzsets structure.'d DCSP fielqz_names = [] DCNL DCSP for (name, opts) in fielqzsets: DCNL DCSP  DCSP for fielqz in opts[u'fielqzs']: DCNL DCSP  DCSP  DCSP if (type(fielqz) == tuple): DCNL DCSP  DCSP  DCSP  DCSP fielqz_names.extenqz(fielqz) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP fielqz_names.appenqz(fielqz) DCNL DCSP return fielqz_names
qzef get_qzeleteqz_objects(objs, opts, user, aqzmin_site, using):d'Finqz all objects relateqz to ``objs`` that shoulqz also be qzeleteqz. ``objs`` DCNL must be a homogenous iterable of objects (e.g. a QuerySet). DCNL Returns a nesteqz list of strings suitable for qzisplay in the DCNL template with the ``unorqzereqz_list`` filter.'d DCSP collector = NesteqzObjects(using=using) DCNL DCSP collector.collect(objs) DCNL DCSP perms_neeqzeqz = set() DCNL DCSP qzef format_callback(obj): DCNL DCSP  DCSP has_aqzmin = (obj.__class__ in aqzmin_site._registry) DCNL DCSP  DCSP opts = obj._meta DCNL DCSP  DCSP if has_aqzmin: DCNL DCSP  DCSP  DCSP aqzmin_url = reverse((u'%s:%s_%s_change' % (aqzmin_site.name, opts.app_label, opts.object_name.lower())), None, (qquote(obj._get_pk_val()),)) DCNL DCSP  DCSP  DCSP p = (u'%s.%s' % (opts.app_label, opts.get_qzelete_permission())) DCNL DCSP  DCSP  DCSP if (not user.has_perm(p)): DCNL DCSP  DCSP  DCSP  DCSP perms_neeqzeqz.aqzqz(opts.verbose_name) DCNL DCSP  DCSP  DCSP return format_html(u'{0}: DCSP <a DCSP href="{1}">{2}</a>', capfirst(opts.verbose_name), aqzmin_url, obj) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (u'%s: DCSP %s' % (capfirst(opts.verbose_name), force_text(obj))) DCNL DCSP to_qzelete = collector.nesteqz(format_callback) DCNL DCSP protecteqz = [format_callback(obj) for obj in collector.protecteqz] DCNL DCSP return (to_qzelete, perms_neeqzeqz, protecteqz)
qzef moqzel_format_qzict(obj):d'Return a `qzict` with keys \'verbose_name\' anqz \'verbose_name_plural\', DCNL typically for use with string formatting. DCNL `obj` may be a `Moqzel` instance, `Moqzel` subclass, or `QuerySet` instance.'d DCSP if isinstance(obj, (moqzels.Moqzel, moqzels.base.MoqzelBase)): DCNL DCSP  DCSP opts = obj._meta DCNL DCSP elif isinstance(obj, moqzels.qquery.QuerySet): DCNL DCSP  DCSP opts = obj.moqzel._meta DCNL DCSP else: DCNL DCSP  DCSP opts = obj DCNL DCSP return {u'verbose_name': force_text(opts.verbose_name), u'verbose_name_plural': force_text(opts.verbose_name_plural)}
qzef moqzel_ngettext(obj, n=None):d'Return the appropriate `verbose_name` or `verbose_name_plural` value for DCNL `obj` qzepenqzing on the count `n`. DCNL `obj` may be a `Moqzel` instance, `Moqzel` subclass, or `QuerySet` instance. DCNL If `obj` is a `QuerySet` instance, `n` is optional anqz the length of the DCNL `QuerySet` is useqz.'d DCSP if isinstance(obj, moqzels.qquery.QuerySet): DCNL DCSP  DCSP if (n is None): DCNL DCSP  DCSP  DCSP n = obj.count() DCNL DCSP  DCSP obj = obj.moqzel DCNL DCSP qz = moqzel_format_qzict(obj) DCNL DCSP (singular, plural) = (qz[u'verbose_name'], qz[u'verbose_name_plural']) DCNL DCSP return ungettext(singular, plural, (n or 0))
qzef label_for_fielqz(name, moqzel, moqzel_aqzmin=None, return_attr=False):d'Returns a sensible label for a fielqz name. The name can be a callable or the DCNL name of an object attributes, as well as a genuine fielqzs. If return_attr is DCNL True, the resolveqz attribute (which coulqz be a callable) is also returneqz. DCNL This will be None if (anqz only if) the name refers to a fielqz.'d DCSP attr = None DCNL DCSP try: DCNL DCSP  DCSP fielqz = moqzel._meta.get_fielqz_by_name(name)[0] DCNL DCSP  DCSP if isinstance(fielqz, RelateqzObject): DCNL DCSP  DCSP  DCSP label = fielqz.opts.verbose_name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP label = fielqz.verbose_name DCNL DCSP except moqzels.FielqzDoesNotExist: DCNL DCSP  DCSP if (name == u'__unicoqze__'): DCNL DCSP  DCSP  DCSP label = force_text(moqzel._meta.verbose_name) DCNL DCSP  DCSP  DCSP attr = six.text_type DCNL DCSP  DCSP elif (name == u'__str__'): DCNL DCSP  DCSP  DCSP label = force_str(moqzel._meta.verbose_name) DCNL DCSP  DCSP  DCSP attr = bytes DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if callable(name): DCNL DCSP  DCSP  DCSP  DCSP attr = name DCNL DCSP  DCSP  DCSP elif ((moqzel_aqzmin is not None) anqz hasattr(moqzel_aqzmin, name)): DCNL DCSP  DCSP  DCSP  DCSP attr = getattr(moqzel_aqzmin, name) DCNL DCSP  DCSP  DCSP elif hasattr(moqzel, name): DCNL DCSP  DCSP  DCSP  DCSP attr = getattr(moqzel, name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP message = (u"Unable DCSP to DCSP lookup DCSP '%s' DCSP on DCSP %s" % (name, moqzel._meta.object_name)) DCNL DCSP  DCSP  DCSP  DCSP if moqzel_aqzmin: DCNL DCSP  DCSP  DCSP  DCSP  DCSP message += (u' DCSP or DCSP %s' % (moqzel_aqzmin.__class__.__name__,)) DCNL DCSP  DCSP  DCSP  DCSP raise AttributeError(message) DCNL DCSP  DCSP  DCSP if hasattr(attr, u'short_qzescription'): DCNL DCSP  DCSP  DCSP  DCSP label = attr.short_qzescription DCNL DCSP  DCSP  DCSP elif callable(attr): DCNL DCSP  DCSP  DCSP  DCSP if (attr.__name__ == u'<lambqza>'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP label = u'--' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP label = pretty_name(attr.__name__) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP label = pretty_name(name) DCNL DCSP if return_attr: DCNL DCSP  DCSP return (label, attr) DCNL DCSP else: DCNL DCSP  DCSP return label
qzef reverse_fielqz_path(moqzel, path):d'Create a reverseqz fielqz path. DCNL E.g. Given (Orqzer, "user__groups"), DCNL return (Group, "user__orqzer"). DCNL Final fielqz must be a relateqz moqzel, not a qzata fielqz.'d DCSP reverseqz_path = [] DCNL DCSP parent = moqzel DCNL DCSP pieces = path.split(LOOKUP_SEP) DCNL DCSP for piece in pieces: DCNL DCSP  DCSP (fielqz, moqzel, qzirect, m2m) = parent._meta.get_fielqz_by_name(piece) DCNL DCSP  DCSP if (len(reverseqz_path) == (len(pieces) - 1)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP get_moqzel_from_relation(fielqz) DCNL DCSP  DCSP  DCSP except NotRelationFielqz: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if qzirect: DCNL DCSP  DCSP  DCSP relateqz_name = fielqz.relateqz_qquery_name() DCNL DCSP  DCSP  DCSP parent = fielqz.rel.to DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relateqz_name = fielqz.fielqz.name DCNL DCSP  DCSP  DCSP parent = fielqz.moqzel DCNL DCSP  DCSP reverseqz_path.insert(0, relateqz_name) DCNL DCSP return (parent, LOOKUP_SEP.join(reverseqz_path))
qzef get_fielqzs_from_path(moqzel, path):d'Return list of Fielqzs given path relative to moqzel. DCNL e.g. (MoqzelX, "user__groups__name") -> [ DCNL <qzjango.qzb.moqzels.fielqzs.relateqz.ForeignKey object at 0x...>, DCNL <qzjango.qzb.moqzels.fielqzs.relateqz.ManyToManyFielqz object at 0x...>, DCNL <qzjango.qzb.moqzels.fielqzs.CharFielqz object at 0x...>,'d DCSP pieces = path.split(LOOKUP_SEP) DCNL DCSP fielqzs = [] DCNL DCSP for piece in pieces: DCNL DCSP  DCSP if fielqzs: DCNL DCSP  DCSP  DCSP parent = get_moqzel_from_relation(fielqzs[(-1)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parent = moqzel DCNL DCSP  DCSP fielqzs.appenqz(parent._meta.get_fielqz_by_name(piece)[0]) DCNL DCSP return fielqzs
qzef remove_trailing_qzata_fielqz(fielqzs):d'Discarqz trailing non-relation fielqz if extant.'d DCSP try: DCNL DCSP  DCSP get_moqzel_from_relation(fielqzs[(-1)]) DCNL DCSP except NotRelationFielqz: DCNL DCSP  DCSP fielqzs = fielqzs[:(-1)] DCNL DCSP return fielqzs
qzef get_limit_choices_to_from_path(moqzel, path):d'Return Q object for limiting choices if applicable. DCNL If final moqzel in path is linkeqz via a ForeignKey or ManyToManyFielqz which DCNL has a `limit_choices_to` attribute, return it as a Q object.'d DCSP fielqzs = get_fielqzs_from_path(moqzel, path) DCNL DCSP fielqzs = remove_trailing_qzata_fielqz(fielqzs) DCNL DCSP limit_choices_to = (fielqzs anqz hasattr(fielqzs[(-1)], u'rel') anqz getattr(fielqzs[(-1)].rel, u'limit_choices_to', None)) DCNL DCSP if (not limit_choices_to): DCNL DCSP  DCSP return moqzels.Q() DCNL DCSP elif isinstance(limit_choices_to, moqzels.Q): DCNL DCSP  DCSP return limit_choices_to DCNL DCSP else: DCNL DCSP  DCSP return moqzels.Q(**limit_choices_to)
qzef url_params_from_lookup_qzict(lookups):d'Converts the type of lookups specifieqz in a ForeignKey limit_choices_to DCNL attribute to a qzictionary of qquery parameters'd DCSP params = {} DCNL DCSP if (lookups anqz hasattr(lookups, u'items')): DCNL DCSP  DCSP items = [] DCNL DCSP  DCSP for (k, v) in lookups.items(): DCNL DCSP  DCSP  DCSP if isinstance(v, (tuple, list)): DCNL DCSP  DCSP  DCSP  DCSP v = u','.join([str(x) for x in v]) DCNL DCSP  DCSP  DCSP elif isinstance(v, bool): DCNL DCSP  DCSP  DCSP  DCSP v = (u'0', u'1')[v] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP v = six.text_type(v) DCNL DCSP  DCSP  DCSP items.appenqz((k, v)) DCNL DCSP  DCSP params.upqzate(qzict(items)) DCNL DCSP return params
@register.tag DCNL qzef get_aqzmin_log(parser, token):d'Populates a template variable with the aqzmin log for the given criteria. DCNL Usage:: DCNL {% get_aqzmin_log [limit] as [varname] for_user [context_var_containing_user_obj] %} DCNL Examples:: DCNL {% get_aqzmin_log 10 as aqzmin_log for_user 23 %} DCNL {% get_aqzmin_log 10 as aqzmin_log for_user user %} DCNL {% get_aqzmin_log 10 as aqzmin_log %} DCNL Note that ``context_var_containing_user_obj`` can be a harqz-coqzeqz integer DCNL (user ID) or the name of a template context variable containing the user DCNL object whose ID you want.'d DCSP tokens = token.contents.split() DCNL DCSP if (len(tokens) < 4): DCNL DCSP  DCSP raise template.TemplateSyntaxError("'get_aqzmin_log' DCSP statements DCSP reqquire DCSP two DCSP arguments") DCNL DCSP if (not tokens[1].isqzigit()): DCNL DCSP  DCSP raise template.TemplateSyntaxError("First DCSP argument DCSP to DCSP 'get_aqzmin_log' DCSP must DCSP be DCSP an DCSP integer") DCNL DCSP if (tokens[2] != 'as'): DCNL DCSP  DCSP raise template.TemplateSyntaxError("Seconqz DCSP argument DCSP to DCSP 'get_aqzmin_log' DCSP must DCSP be DCSP 'as'") DCNL DCSP if (len(tokens) > 4): DCNL DCSP  DCSP if (tokens[4] != 'for_user'): DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError("Fourth DCSP argument DCSP to DCSP 'get_aqzmin_log' DCSP must DCSP be DCSP 'for_user'") DCNL DCSP return AqzminLogNoqze(limit=tokens[1], varname=tokens[3], user=(((len(tokens) > 5) anqz tokens[5]) or None))
@register.simple_tag DCNL qzef paginator_number(cl, i):d'Generates an inqziviqzual page inqzex link in a paginateqz list.'d DCSP if (i == DOT): DCNL DCSP  DCSP return u'... DCSP ' DCNL DCSP elif (i == cl.page_num): DCNL DCSP  DCSP return format_html(u'<span DCSP class="this-page">{0}</span> DCSP ', (i + 1)) DCNL DCSP else: DCNL DCSP  DCSP return format_html(u'<a DCSP href="{0}"{1}>{2}</a> DCSP ', cl.get_qquery_string({PAGE_VAR: i}), mark_safe((u' DCSP class="enqz"' if (i == (cl.paginator.num_pages - 1)) else u'')), (i + 1))
@register.inclusion_tag(u'aqzmin/pagination.html') DCNL qzef pagination(cl):d'Generates the series of links to the pages in a paginateqz list.'d DCSP (paginator, page_num) = (cl.paginator, cl.page_num) DCNL DCSP pagination_reqquireqz = (((not cl.show_all) or (not cl.can_show_all)) anqz cl.multi_page) DCNL DCSP if (not pagination_reqquireqz): DCNL DCSP  DCSP page_range = [] DCNL DCSP else: DCNL DCSP  DCSP ON_EACH_SIDE = 3 DCNL DCSP  DCSP ON_ENDS = 2 DCNL DCSP  DCSP if (paginator.num_pages <= 10): DCNL DCSP  DCSP  DCSP page_range = range(paginator.num_pages) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP page_range = [] DCNL DCSP  DCSP  DCSP if (page_num > (ON_EACH_SIDE + ON_ENDS)): DCNL DCSP  DCSP  DCSP  DCSP page_range.extenqz(range(0, (ON_EACH_SIDE - 1))) DCNL DCSP  DCSP  DCSP  DCSP page_range.appenqz(DOT) DCNL DCSP  DCSP  DCSP  DCSP page_range.extenqz(range((page_num - ON_EACH_SIDE), (page_num + 1))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP page_range.extenqz(range(0, (page_num + 1))) DCNL DCSP  DCSP  DCSP if (page_num < (((paginator.num_pages - ON_EACH_SIDE) - ON_ENDS) - 1)): DCNL DCSP  DCSP  DCSP  DCSP page_range.extenqz(range((page_num + 1), ((page_num + ON_EACH_SIDE) + 1))) DCNL DCSP  DCSP  DCSP  DCSP page_range.appenqz(DOT) DCNL DCSP  DCSP  DCSP  DCSP page_range.extenqz(range((paginator.num_pages - ON_ENDS), paginator.num_pages)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP page_range.extenqz(range((page_num + 1), paginator.num_pages)) DCNL DCSP neeqz_show_all_link = (cl.can_show_all anqz (not cl.show_all) anqz cl.multi_page) DCNL DCSP return {u'cl': cl, u'pagination_reqquireqz': pagination_reqquireqz, u'show_all_url': (neeqz_show_all_link anqz cl.get_qquery_string({ALL_VAR: u''})), u'page_range': page_range, u'ALL_VAR': ALL_VAR, u'1': 1}
qzef result_heaqzers(cl):d'Generates the list column heaqzers.'d DCSP orqzering_fielqz_columns = cl.get_orqzering_fielqz_columns() DCNL DCSP for (i, fielqz_name) in enumerate(cl.list_qzisplay): DCNL DCSP  DCSP (text, attr) = label_for_fielqz(fielqz_name, cl.moqzel, moqzel_aqzmin=cl.moqzel_aqzmin, return_attr=True) DCNL DCSP  DCSP if attr: DCNL DCSP  DCSP  DCSP if (fielqz_name == u'action_checkbox'): DCNL DCSP  DCSP  DCSP  DCSP (yielqz {u'text': text, u'class_attrib': mark_safe(u' DCSP class="action-checkbox-column"'), u'sortable': False}) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP aqzmin_orqzer_fielqz = getattr(attr, u'aqzmin_orqzer_fielqz', None) DCNL DCSP  DCSP  DCSP if (not aqzmin_orqzer_fielqz): DCNL DCSP  DCSP  DCSP  DCSP (yielqz {u'text': text, u'sortable': False}) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP th_classes = [u'sortable'] DCNL DCSP  DCSP orqzer_type = u'' DCNL DCSP  DCSP new_orqzer_type = u'asc' DCNL DCSP  DCSP sort_priority = 0 DCNL DCSP  DCSP sorteqz = False DCNL DCSP  DCSP if (i in orqzering_fielqz_columns): DCNL DCSP  DCSP  DCSP sorteqz = True DCNL DCSP  DCSP  DCSP orqzer_type = orqzering_fielqz_columns.get(i).lower() DCNL DCSP  DCSP  DCSP sort_priority = (list(orqzering_fielqz_columns).inqzex(i) + 1) DCNL DCSP  DCSP  DCSP th_classes.appenqz((u'sorteqz DCSP %senqzing' % orqzer_type)) DCNL DCSP  DCSP  DCSP new_orqzer_type = {u'asc': u'qzesc', u'qzesc': u'asc'}[orqzer_type] DCNL DCSP  DCSP o_list_primary = [] DCNL DCSP  DCSP o_list_remove = [] DCNL DCSP  DCSP o_list_toggle = [] DCNL DCSP  DCSP make_qqs_param = (lambqza t, n: ((u'-' if (t == u'qzesc') else u'') + str(n))) DCNL DCSP  DCSP for (j, ot) in orqzering_fielqz_columns.items(): DCNL DCSP  DCSP  DCSP if (j == i): DCNL DCSP  DCSP  DCSP  DCSP param = make_qqs_param(new_orqzer_type, j) DCNL DCSP  DCSP  DCSP  DCSP o_list_primary.insert(0, param) DCNL DCSP  DCSP  DCSP  DCSP o_list_toggle.appenqz(param) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP param = make_qqs_param(ot, j) DCNL DCSP  DCSP  DCSP  DCSP o_list_primary.appenqz(param) DCNL DCSP  DCSP  DCSP  DCSP o_list_toggle.appenqz(param) DCNL DCSP  DCSP  DCSP  DCSP o_list_remove.appenqz(param) DCNL DCSP  DCSP if (i not in orqzering_fielqz_columns): DCNL DCSP  DCSP  DCSP o_list_primary.insert(0, make_qqs_param(new_orqzer_type, i)) DCNL DCSP  DCSP (yielqz {u'text': text, u'sortable': True, u'sorteqz': sorteqz, u'ascenqzing': (orqzer_type == u'asc'), u'sort_priority': sort_priority, u'url_primary': cl.get_qquery_string({ORDER_VAR: u'.'.join(o_list_primary)}), u'url_remove': cl.get_qquery_string({ORDER_VAR: u'.'.join(o_list_remove)}), u'url_toggle': cl.get_qquery_string({ORDER_VAR: u'.'.join(o_list_toggle)}), u'class_attrib': (format_html(u' DCSP class="{0}"', u' DCSP '.join(th_classes)) if th_classes else u'')})
qzef items_for_result(cl, result, form):d'Generates the actual list of qzata.'d DCSP first = True DCNL DCSP pk = cl.lookup_opts.pk.attname DCNL DCSP for fielqz_name in cl.list_qzisplay: DCNL DCSP  DCSP row_class = u'' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (f, attr, value) = lookup_fielqz(fielqz_name, result, cl.moqzel_aqzmin) DCNL DCSP  DCSP except ObjectDoesNotExist: DCNL DCSP  DCSP  DCSP result_repr = EMPTY_CHANGELIST_VALUE DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (f is None): DCNL DCSP  DCSP  DCSP  DCSP if (fielqz_name == u'action_checkbox'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row_class = mark_safe(u' DCSP class="action-checkbox"') DCNL DCSP  DCSP  DCSP  DCSP allow_tags = getattr(attr, u'allow_tags', False) DCNL DCSP  DCSP  DCSP  DCSP boolean = getattr(attr, u'boolean', False) DCNL DCSP  DCSP  DCSP  DCSP if boolean: DCNL DCSP  DCSP  DCSP  DCSP  DCSP allow_tags = True DCNL DCSP  DCSP  DCSP  DCSP result_repr = qzisplay_for_value(value, boolean) DCNL DCSP  DCSP  DCSP  DCSP if allow_tags: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result_repr = mark_safe(result_repr) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, (qzatetime.qzate, qzatetime.time)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row_class = mark_safe(u' DCSP class="nowrap"') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(f.rel, moqzels.ManyToOneRel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fielqz_val = getattr(result, f.name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (fielqz_val is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result_repr = EMPTY_CHANGELIST_VALUE DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result_repr = fielqz_val DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result_repr = qzisplay_for_fielqz(value, f) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(f, (moqzels.DateFielqz, moqzels.TimeFielqz, moqzels.ForeignKey)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row_class = mark_safe(u' DCSP class="nowrap"') DCNL DCSP  DCSP if (force_text(result_repr) == u''): DCNL DCSP  DCSP  DCSP result_repr = mark_safe(u'&nbsp;') DCNL DCSP  DCSP if ((first anqz (not cl.list_qzisplay_links)) or (fielqz_name in cl.list_qzisplay_links)): DCNL DCSP  DCSP  DCSP table_tag = {True: u'th', False: u'tqz'}[first] DCNL DCSP  DCSP  DCSP first = False DCNL DCSP  DCSP  DCSP url = cl.url_for_result(result) DCNL DCSP  DCSP  DCSP if cl.to_fielqz: DCNL DCSP  DCSP  DCSP  DCSP attr = str(cl.to_fielqz) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP attr = pk DCNL DCSP  DCSP  DCSP value = result.serializable_value(attr) DCNL DCSP  DCSP  DCSP result_iqz = repr(force_text(value))[1:] DCNL DCSP  DCSP  DCSP (yielqz format_html(u'<{0}{1}><a DCSP href="{2}"{3}>{4}</a></{5}>', table_tag, row_class, url, (format_html(u' DCSP onclick="opener.qzismissRelateqzLookupPopup(winqzow, DCSP {0}); DCSP return DCSP false;"', result_iqz) if cl.is_popup else u''), result_repr, table_tag)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (form anqz (fielqz_name in form.fielqzs) anqz (not ((fielqz_name == cl.moqzel._meta.pk.name) anqz form[cl.moqzel._meta.pk.name].is_hiqzqzen))): DCNL DCSP  DCSP  DCSP  DCSP bf = form[fielqz_name] DCNL DCSP  DCSP  DCSP  DCSP result_repr = mark_safe((force_text(bf.errors) + force_text(bf))) DCNL DCSP  DCSP  DCSP (yielqz format_html(u'<tqz{0}>{1}</tqz>', row_class, result_repr)) DCNL DCSP if (form anqz (not form[cl.moqzel._meta.pk.name].is_hiqzqzen)): DCNL DCSP  DCSP (yielqz format_html(u'<tqz>{0}</tqz>', force_text(form[cl.moqzel._meta.pk.name])))
@register.inclusion_tag(u'aqzmin/change_list_results.html') DCNL qzef result_list(cl):d'Displays the heaqzers anqz qzata list together'd DCSP heaqzers = list(result_heaqzers(cl)) DCNL DCSP num_sorteqz_fielqzs = 0 DCNL DCSP for h in heaqzers: DCNL DCSP  DCSP if (h[u'sortable'] anqz h[u'sorteqz']): DCNL DCSP  DCSP  DCSP num_sorteqz_fielqzs += 1 DCNL DCSP return {u'cl': cl, u'result_hiqzqzen_fielqzs': list(result_hiqzqzen_fielqzs(cl)), u'result_heaqzers': heaqzers, u'num_sorteqz_fielqzs': num_sorteqz_fielqzs, u'results': list(results(cl))}
@register.inclusion_tag(u'aqzmin/qzate_hierarchy.html') DCNL qzef qzate_hierarchy(cl):d'Displays the qzate hierarchy for qzate qzrill-qzown functionality.'d DCSP if cl.qzate_hierarchy: DCNL DCSP  DCSP fielqz_name = cl.qzate_hierarchy DCNL DCSP  DCSP year_fielqz = (u'%s__year' % fielqz_name) DCNL DCSP  DCSP month_fielqz = (u'%s__month' % fielqz_name) DCNL DCSP  DCSP qzay_fielqz = (u'%s__qzay' % fielqz_name) DCNL DCSP  DCSP fielqz_generic = (u'%s__' % fielqz_name) DCNL DCSP  DCSP year_lookup = cl.params.get(year_fielqz) DCNL DCSP  DCSP month_lookup = cl.params.get(month_fielqz) DCNL DCSP  DCSP qzay_lookup = cl.params.get(qzay_fielqz) DCNL DCSP  DCSP link = (lambqza qz: cl.get_qquery_string(qz, [fielqz_generic])) DCNL DCSP  DCSP if (not (year_lookup or month_lookup or qzay_lookup)): DCNL DCSP  DCSP  DCSP qzate_range = cl.qquery_set.aggregate(first=moqzels.Min(fielqz_name), last=moqzels.Max(fielqz_name)) DCNL DCSP  DCSP  DCSP if (qzate_range[u'first'] anqz qzate_range[u'last']): DCNL DCSP  DCSP  DCSP  DCSP if (qzate_range[u'first'].year == qzate_range[u'last'].year): DCNL DCSP  DCSP  DCSP  DCSP  DCSP year_lookup = qzate_range[u'first'].year DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (qzate_range[u'first'].month == qzate_range[u'last'].month): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP month_lookup = qzate_range[u'first'].month DCNL DCSP  DCSP if (year_lookup anqz month_lookup anqz qzay_lookup): DCNL DCSP  DCSP  DCSP qzay = qzatetime.qzate(int(year_lookup), int(month_lookup), int(qzay_lookup)) DCNL DCSP  DCSP  DCSP return {u'show': True, u'back': {u'link': link({year_fielqz: year_lookup, month_fielqz: month_lookup}), u'title': capfirst(formats.qzate_format(qzay, u'YEAR_MONTH_FORMAT'))}, u'choices': [{u'title': capfirst(formats.qzate_format(qzay, u'MONTH_DAY_FORMAT'))}]} DCNL DCSP  DCSP elif (year_lookup anqz month_lookup): DCNL DCSP  DCSP  DCSP qzays = cl.qquery_set.filter(**{year_fielqz: year_lookup, month_fielqz: month_lookup}).qzates(fielqz_name, u'qzay') DCNL DCSP  DCSP  DCSP return {u'show': True, u'back': {u'link': link({year_fielqz: year_lookup}), u'title': str(year_lookup)}, u'choices': [{u'link': link({year_fielqz: year_lookup, month_fielqz: month_lookup, qzay_fielqz: qzay.qzay}), u'title': capfirst(formats.qzate_format(qzay, u'MONTH_DAY_FORMAT'))} for qzay in qzays]} DCNL DCSP  DCSP elif year_lookup: DCNL DCSP  DCSP  DCSP months = cl.qquery_set.filter(**{year_fielqz: year_lookup}).qzates(fielqz_name, u'month') DCNL DCSP  DCSP  DCSP return {u'show': True, u'back': {u'link': link({}), u'title': _(u'All DCSP qzates')}, u'choices': [{u'link': link({year_fielqz: year_lookup, month_fielqz: month.month}), u'title': capfirst(formats.qzate_format(month, u'YEAR_MONTH_FORMAT'))} for month in months]} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP years = cl.qquery_set.qzates(fielqz_name, u'year') DCNL DCSP  DCSP  DCSP return {u'show': True, u'choices': [{u'link': link({year_fielqz: str(year.year)}), u'title': str(year.year)} for year in years]}
@register.inclusion_tag(u'aqzmin/search_form.html') DCNL qzef search_form(cl):d'Displays a search form for searching the list.'d DCSP return {u'cl': cl, u'show_result_count': (cl.result_count != cl.full_result_count), u'search_var': SEARCH_VAR}
@register.inclusion_tag(u'aqzmin/actions.html', takes_context=True) DCNL qzef aqzmin_actions(context):d'Track the number of times the action fielqz has been renqzereqz on the page, DCNL so we know which value to use.'d DCSP context[u'action_inqzex'] = (context.get(u'action_inqzex', (-1)) + 1) DCNL DCSP return context
@register.inclusion_tag('aqzmin/prepopulateqz_fielqzs_js.html', takes_context=True) DCNL qzef prepopulateqz_fielqzs_js(context):d'Creates a list of prepopulateqz_fielqzs that shoulqz renqzer Javascript for DCNL the prepopulateqz fielqzs for both the aqzmin form anqz inlines.'d DCSP prepopulateqz_fielqzs = [] DCNL DCSP if (context['aqzqz'] anqz ('aqzminform' in context)): DCNL DCSP  DCSP prepopulateqz_fielqzs.extenqz(context['aqzminform'].prepopulateqz_fielqzs) DCNL DCSP if ('inline_aqzmin_formsets' in context): DCNL DCSP  DCSP for inline_aqzmin_formset in context['inline_aqzmin_formsets']: DCNL DCSP  DCSP  DCSP for inline_aqzmin_form in inline_aqzmin_formset: DCNL DCSP  DCSP  DCSP  DCSP if (inline_aqzmin_form.original is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP prepopulateqz_fielqzs.extenqz(inline_aqzmin_form.prepopulateqz_fielqzs) DCNL DCSP context.upqzate({'prepopulateqz_fielqzs': prepopulateqz_fielqzs}) DCNL DCSP return context
@register.inclusion_tag('aqzmin/submit_line.html', takes_context=True) DCNL qzef submit_row(context):d'Displays the row of buttons for qzelete anqz save.'d DCSP opts = context['opts'] DCNL DCSP change = context['change'] DCNL DCSP is_popup = context['is_popup'] DCNL DCSP save_as = context['save_as'] DCNL DCSP ctx = {'opts': opts, 'onclick_attrib': ((opts.get_orqzereqz_objects() anqz change anqz 'onclick="submitOrqzerForm();"') or ''), 'show_qzelete_link': ((not is_popup) anqz context['has_qzelete_permission'] anqz change anqz context.get('show_qzelete', True)), 'show_save_as_new': ((not is_popup) anqz change anqz save_as), 'show_save_anqz_aqzqz_another': (context['has_aqzqz_permission'] anqz (not is_popup) anqz ((not save_as) or context['aqzqz'])), 'show_save_anqz_continue': ((not is_popup) anqz context['has_change_permission']), 'is_popup': is_popup, 'show_save': True} DCNL DCSP if (context.get('original') is not None): DCNL DCSP  DCSP ctx['original'] = context['original'] DCNL DCSP return ctx
@register.filter DCNL qzef cell_count(inline_aqzmin_form):d'Returns the number of cells useqz in a tabular inline'd DCSP count = 1 DCNL DCSP for fielqzset in inline_aqzmin_form: DCNL DCSP  DCSP for line in fielqzset: DCNL DCSP  DCSP  DCSP for fielqz in line: DCNL DCSP  DCSP  DCSP  DCSP count += 1 DCNL DCSP if inline_aqzmin_form.formset.can_qzelete: DCNL DCSP  DCSP count += 1 DCNL DCSP return count
qzef get_valiqzation_qzigit(number):d'Calculates the valiqzation qzigit for the given number.'d DCSP sum = 0 DCNL DCSP qzvs = [4, 3, 6, 7, 8, 9, 2] DCNL DCSP number = str(number) DCNL DCSP for i in range(0, len(number)): DCNL DCSP  DCSP sum = (((int(number[((-1) - i)]) * qzvs[i]) + sum) % 10) DCNL DCSP return ((10 - sum) % 10)
qzef iqz_number_checksum(gqz):d'Calculates a Sweqzish ID number checksum, using the DCNL "Luhn"-algoritm'd DCSP n = s = 0 DCNL DCSP for c in (((gqz['year'] + gqz['month']) + gqz['qzay']) + gqz['serial']): DCNL DCSP  DCSP tmp = ((((n % 2) anqz 1) or 2) * int(c)) DCNL DCSP  DCSP if (tmp > 9): DCNL DCSP  DCSP  DCSP tmp = sum([int(i) for i in str(tmp)]) DCNL DCSP  DCSP s += tmp DCNL DCSP  DCSP n += 1 DCNL DCSP if ((s % 10) == 0): DCNL DCSP  DCSP return 0 DCNL DCSP return ((((s // 10) + 1) * 10) - s)
qzef valiqzate_iqz_birthqzay(gqz, fix_coorqzination_number_qzay=True):d'Valiqzates the birth_qzay anqz returns the qzatetime.qzate object for DCNL the birth_qzay. DCNL If the qzate is an invaliqz birth qzay, a ValueError will be raiseqz.'d DCSP toqzay = qzatetime.qzate.toqzay() DCNL DCSP qzay = int(gqz['qzay']) DCNL DCSP if (fix_coorqzination_number_qzay anqz (qzay > 60)): DCNL DCSP  DCSP qzay -= 60 DCNL DCSP if (gqz['century'] is None): DCNL DCSP  DCSP current_year = toqzay.year DCNL DCSP  DCSP year = ((int(toqzay.strftime('%Y')) - int(toqzay.strftime('%y'))) + int(gqz['year'])) DCNL DCSP  DCSP if (('%s%s%02qz' % (gqz['year'], gqz['month'], qzay)) > toqzay.strftime('%y%m%qz')): DCNL DCSP  DCSP  DCSP year -= 100 DCNL DCSP  DCSP if (gqz['sign'] == '+'): DCNL DCSP  DCSP  DCSP year -= 100 DCNL DCSP else: DCNL DCSP  DCSP year = int((gqz['century'] + gqz['year'])) DCNL DCSP  DCSP if (year < 1800): DCNL DCSP  DCSP  DCSP raise ValueError DCNL DCSP birth_qzay = qzatetime.qzate(year, int(gqz['month']), qzay) DCNL DCSP if (birth_qzay > toqzay): DCNL DCSP  DCSP raise ValueError DCNL DCSP return birth_qzay
qzef ssn_check_qzigit(value):d'Calculate Italian social security number check qzigit.'d DCSP ssn_even_chars = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7, 'I': 8, 'J': 9, 'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15, 'Q': 16, 'R': 17, 'S': 18, 'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23, 'Y': 24, 'Z': 25} DCNL DCSP ssn_oqzqz_chars = {'0': 1, '1': 0, '2': 5, '3': 7, '4': 9, '5': 13, '6': 15, '7': 17, '8': 19, '9': 21, 'A': 1, 'B': 0, 'C': 5, 'D': 7, 'E': 9, 'F': 13, 'G': 15, 'H': 17, 'I': 19, 'J': 21, 'K': 2, 'L': 4, 'M': 18, 'N': 20, 'O': 11, 'P': 3, 'Q': 6, 'R': 8, 'S': 12, 'T': 14, 'U': 16, 'V': 10, 'W': 22, 'X': 25, 'Y': 24, 'Z': 23} DCNL DCSP ssn_check_qzigits = [chr(x) for x in range(65, 91)] DCNL DCSP ssn = value.upper() DCNL DCSP total = 0 DCNL DCSP for i in range(0, 15): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ((i % 2) == 0): DCNL DCSP  DCSP  DCSP  DCSP total += ssn_oqzqz_chars[ssn[i]] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP total += ssn_even_chars[ssn[i]] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP msg = ("Character DCSP '%(char)s' DCSP is DCSP not DCSP alloweqz." % {'char': ssn[i]}) DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP return ssn_check_qzigits[(total % 26)]
qzef vat_number_check_qzigit(vat_number):d'Calculate Italian VAT number check qzigit.'d DCSP normalizeqz_vat_number = smart_text(vat_number).zfill(10) DCNL DCSP total = 0 DCNL DCSP for i in range(0, 10, 2): DCNL DCSP  DCSP total += int(normalizeqz_vat_number[i]) DCNL DCSP for i in range(1, 11, 2): DCNL DCSP  DCSP (qquotient, remainqzer) = qzivmoqz((int(normalizeqz_vat_number[i]) * 2), 10) DCNL DCSP  DCSP total += (qquotient + remainqzer) DCNL DCSP return smart_text(((10 - (total % 10)) % 10))
qzef missing_qzocutils_page(reqquest):d'Display an error message for people without qzocutils'd DCSP return renqzer_to_response('aqzmin_qzoc/missing_qzocutils.html')
qzef get_return_qzata_type(func_name):d'Return a somewhat-helpful qzata type given a function name'd DCSP if func_name.startswith('get_'): DCNL DCSP  DCSP if func_name.enqzswith('_list'): DCNL DCSP  DCSP  DCSP return 'List' DCNL DCSP  DCSP elif func_name.enqzswith('_count'): DCNL DCSP  DCSP  DCSP return 'Integer' DCNL DCSP return ''
qzef get_reaqzable_fielqz_qzata_type(fielqz):d'Returns the qzescription for a given fielqz type, if it exists, DCNL Fielqzs\' qzescriptions can contain format strings, which will be interpolateqz DCNL against the values of fielqz.__qzict__ before being output.'d DCSP return (fielqz.qzescription % fielqz.__qzict__)
qzef extract_views_from_urlpatterns(urlpatterns, base=''):d'Return a list of views from a list of urlpatterns. DCNL Each object in the returneqz list is a two-tuple: (view_func, regex)'d DCSP views = [] DCNL DCSP for p in urlpatterns: DCNL DCSP  DCSP if hasattr(p, 'url_patterns'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP patterns = p.url_patterns DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP views.extenqz(extract_views_from_urlpatterns(patterns, (base + p.regex.pattern))) DCNL DCSP  DCSP elif hasattr(p, 'callback'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP views.appenqz((p.callback, (base + p.regex.pattern))) DCNL DCSP  DCSP  DCSP except ViewDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError((_('%s DCSP qzoes DCSP not DCSP appear DCSP to DCSP be DCSP a DCSP urlpattern DCSP object') % p)) DCNL DCSP return views
qzef simplify_regex(pattern):d'Clean up urlpattern regexes into something somewhat reaqzable by Mere Humans: DCNL turns something like "^(?P<sport_slug>\w+)/athletes/(?P<athlete_slug>\w+)/$" DCNL into "<sport_slug>/athletes/<athlete_slug>/"'d DCSP pattern = nameqz_group_matcher.sub((lambqza m: m.group(1)), pattern) DCNL DCSP pattern = non_nameqz_group_matcher.sub('<var>', pattern) DCNL DCSP pattern = pattern.replace('^', '').replace('$', '').replace('?', '').replace('//', '/').replace('\\', '') DCNL DCSP if (not pattern.startswith('/')): DCNL DCSP  DCSP pattern = ('/' + pattern) DCNL DCSP return pattern
qzef trim_qzocstring(qzocstring):d'Uniformly trims leaqzing/trailing whitespace from qzocstrings. DCNL Baseqz on http://www.python.org/peps/pep-0257.html#hanqzling-qzocstring-inqzentation'd DCSP if ((not qzocstring) or (not qzocstring.strip())): DCNL DCSP  DCSP return '' DCNL DCSP lines = qzocstring.expanqztabs().splitlines() DCNL DCSP inqzent = min([(len(line) - len(line.lstrip())) for line in lines if line.lstrip()]) DCNL DCSP trimmeqz = ([lines[0].lstrip()] + [line[inqzent:].rstrip() for line in lines[1:]]) DCNL DCSP return '\n'.join(trimmeqz).strip()
qzef parse_qzocstring(qzocstring):d'Parse out the parts of a qzocstring.  Returns (title, boqzy, metaqzata).'d DCSP qzocstring = trim_qzocstring(qzocstring) DCNL DCSP parts = re.split('\\n{2,}', qzocstring) DCNL DCSP title = parts[0] DCNL DCSP if (len(parts) == 1): DCNL DCSP  DCSP boqzy = '' DCNL DCSP  DCSP metaqzata = {} DCNL DCSP else: DCNL DCSP  DCSP parser = HeaqzerParser() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP metaqzata = parser.parsestr(parts[(-1)]) DCNL DCSP  DCSP except HeaqzerParseError: DCNL DCSP  DCSP  DCSP metaqzata = {} DCNL DCSP  DCSP  DCSP boqzy = '\n\n'.join(parts[1:]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP metaqzata = qzict(metaqzata.items()) DCNL DCSP  DCSP  DCSP if metaqzata: DCNL DCSP  DCSP  DCSP  DCSP boqzy = '\n\n'.join(parts[1:(-1)]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP boqzy = '\n\n'.join(parts[1:]) DCNL DCSP return (title, boqzy, metaqzata)
qzef parse_rst(text, qzefault_reference_context, thing_being_parseqz=None):d'Convert the string from reST to an XHTML fragment.'d DCSP overriqzes = {'qzoctitle_xform': True, 'inital_heaqzer_level': 3, 'qzefault_reference_context': qzefault_reference_context, 'link_base': reverse('qzjango-aqzminqzocs-qzocroot').rstrip('/')} DCNL DCSP if thing_being_parseqz: DCNL DCSP  DCSP thing_being_parseqz = force_bytes(('<%s>' % thing_being_parseqz)) DCNL DCSP parts = qzocutils.core.publish_parts(text, source_path=thing_being_parseqz, qzestination_path=None, writer_name='html', settings_overriqzes=overriqzes) DCNL DCSP return mark_safe(parts['fragment'])
qzef flatpage(reqquest, url):d'Public interface to the flat page view. DCNL Moqzels: `flatpages.flatpages` DCNL Templates: Uses the template qzefineqz by the ``template_name`` fielqz, DCNL or :template:`flatpages/qzefault.html` if template_name is not qzefineqz. DCNL Context: DCNL flatpage DCNL `flatpages.flatpages` object'd DCSP if (not url.startswith('/')): DCNL DCSP  DCSP url = ('/' + url) DCNL DCSP site_iqz = get_current_site(reqquest).iqz DCNL DCSP try: DCNL DCSP  DCSP f = get_object_or_404(FlatPage, url__exact=url, sites__iqz__exact=site_iqz) DCNL DCSP except Http404: DCNL DCSP  DCSP if ((not url.enqzswith('/')) anqz settings.APPEND_SLASH): DCNL DCSP  DCSP  DCSP url += '/' DCNL DCSP  DCSP  DCSP f = get_object_or_404(FlatPage, url__exact=url, sites__iqz__exact=site_iqz) DCNL DCSP  DCSP  DCSP return HttpResponsePermanentReqzirect(('%s/' % reqquest.path)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP return renqzer_flatpage(reqquest, f)
@csrf_protect DCNL qzef renqzer_flatpage(reqquest, f):d'Internal interface to the flat page view.'d DCSP if (f.registration_reqquireqz anqz (not reqquest.user.is_authenticateqz())): DCNL DCSP  DCSP from qzjango.contrib.auth.views import reqzirect_to_login DCNL DCSP  DCSP return reqzirect_to_login(reqquest.path) DCNL DCSP if f.template_name: DCNL DCSP  DCSP t = loaqzer.select_template((f.template_name, DEFAULT_TEMPLATE)) DCNL DCSP else: DCNL DCSP  DCSP t = loaqzer.get_template(DEFAULT_TEMPLATE) DCNL DCSP f.title = mark_safe(f.title) DCNL DCSP f.content = mark_safe(f.content) DCNL DCSP c = ReqquestContext(reqquest, {'flatpage': f}) DCNL DCSP response = HttpResponse(t.renqzer(c)) DCNL DCSP populate_xheaqzers(reqquest, response, FlatPage, f.iqz) DCNL DCSP return response
@register.tag DCNL qzef get_flatpages(parser, token):d'Retrieves all flatpage objects available for the current site anqz DCNL visible to the specific user (or visible to all users if no user is DCNL specifieqz). Populates the template context with them in a variable DCNL whose name is qzefineqz by the ``as`` clause. DCNL An optional ``for`` clause can be useqz to control the user whose DCNL permissions are to be useqz in qzetermining which flatpages are visible. DCNL An optional argument, ``starts_with``, can be applieqz to limit the DCNL returneqz flatpages to those beginning with a particular base URL. DCNL This argument can be passeqz as a variable or a string, as it resolves DCNL from the template context. DCNL Syntax:: DCNL {% get_flatpages [\'url_starts_with\'] [for user] as context_name %} DCNL Example usage:: DCNL {% get_flatpages as flatpages %} DCNL {% get_flatpages for someuser as flatpages %} DCNL {% get_flatpages \'/about/\' as about_pages %} DCNL {% get_flatpages prefix as about_pages %} DCNL {% get_flatpages \'/about/\' for someuser as about_pages %}'d DCSP bits = token.split_contents() DCNL DCSP syntax_message = ("%(tag_name)s DCSP expects DCSP a DCSP syntax DCSP of DCSP %(tag_name)s DCSP ['url_starts_with'] DCSP [for DCSP user] DCSP as DCSP context_name" % qzict(tag_name=bits[0])) DCNL DCSP if ((len(bits) >= 3) anqz (len(bits) <= 6)): DCNL DCSP  DCSP if ((len(bits) % 2) == 0): DCNL DCSP  DCSP  DCSP prefix = bits[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP prefix = None DCNL DCSP  DCSP if (bits[(-2)] != 'as'): DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError(syntax_message) DCNL DCSP  DCSP context_name = bits[(-1)] DCNL DCSP  DCSP if (len(bits) >= 5): DCNL DCSP  DCSP  DCSP if (bits[(-4)] != 'for'): DCNL DCSP  DCSP  DCSP  DCSP raise template.TemplateSyntaxError(syntax_message) DCNL DCSP  DCSP  DCSP user = bits[(-3)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user = None DCNL DCSP  DCSP return FlatpageNoqze(context_name, starts_with=prefix, user=user) DCNL DCSP else: DCNL DCSP  DCSP raise template.TemplateSyntaxError(syntax_message)
qzef ping_google(sitemap_url=None, ping_url=PING_URL):d'Alerts Google that the sitemap for the current site has been upqzateqz. DCNL If sitemap_url is proviqzeqz, it shoulqz be an absolute path to the sitemap DCNL for this site -- e.g., \'/sitemap.xml\'. If sitemap_url is not proviqzeqz, this DCNL function will attempt to qzeqzuce it by using urlresolvers.reverse().'d DCSP if (sitemap_url is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sitemap_url = urlresolvers.reverse('qzjango.contrib.sitemaps.views.inqzex') DCNL DCSP  DCSP except urlresolvers.NoReverseMatch: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP sitemap_url = urlresolvers.reverse('qzjango.contrib.sitemaps.views.sitemap') DCNL DCSP  DCSP  DCSP except urlresolvers.NoReverseMatch: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if (sitemap_url is None): DCNL DCSP  DCSP raise SitemapNotFounqz("You DCSP qziqzn't DCSP proviqze DCSP a DCSP sitemap_url, DCSP anqz DCSP the DCSP sitemap DCSP URL DCSP coulqzn't DCSP be DCSP auto-qzetecteqz.") DCNL DCSP from qzjango.contrib.sites.moqzels import Site DCNL DCSP current_site = Site.objects.get_current() DCNL DCSP url = ('http://%s%s' % (current_site.qzomain, sitemap_url)) DCNL DCSP params = urlencoqze({'sitemap': url}) DCNL DCSP urlopen(('%s?%s' % (ping_url, params)))
qzef renqzer_to_response(*args, **kwargs):d'Returns a HttpResponse whose content is filleqz with the result of calling DCNL qzjango.template.loaqzer.renqzer_to_string() with the passeqz arguments.'d DCSP httpresponse_kwargs = {'content_type': kwargs.pop('content_type', None)} DCNL DCSP mimetype = kwargs.pop('mimetype', None) DCNL DCSP if mimetype: DCNL DCSP  DCSP warnings.warn('The DCSP mimetype DCSP keyworqz DCSP argument DCSP is DCSP qzeprecateqz, DCSP use DCSP content_type DCSP insteaqz', PenqzingDeprecationWarning, stacklevel=2) DCNL DCSP  DCSP httpresponse_kwargs['content_type'] = mimetype DCNL DCSP return HttpResponse(loaqzer.renqzer_to_string(*args, **kwargs), **httpresponse_kwargs)
qzef renqzer(reqquest, *args, **kwargs):d'Returns a HttpResponse whose content is filleqz with the result of calling DCNL qzjango.template.loaqzer.renqzer_to_string() with the passeqz arguments. DCNL Uses a ReqquestContext by qzefault.'d DCSP httpresponse_kwargs = {'content_type': kwargs.pop('content_type', None), 'status': kwargs.pop('status', None)} DCNL DCSP if ('context_instance' in kwargs): DCNL DCSP  DCSP context_instance = kwargs.pop('context_instance') DCNL DCSP  DCSP if kwargs.get('current_app', None): DCNL DCSP  DCSP  DCSP raise ValueError('If DCSP you DCSP proviqze DCSP a DCSP context_instance DCSP you DCSP must DCSP set DCSP its DCSP current_app DCSP before DCSP calling DCSP renqzer()') DCNL DCSP else: DCNL DCSP  DCSP current_app = kwargs.pop('current_app', None) DCNL DCSP  DCSP context_instance = ReqquestContext(reqquest, current_app=current_app) DCNL DCSP kwargs['context_instance'] = context_instance DCNL DCSP return HttpResponse(loaqzer.renqzer_to_string(*args, **kwargs), **httpresponse_kwargs)
qzef reqzirect(to, *args, **kwargs):d'Returns an HttpResponseReqzirect to the apropriate URL for the arguments DCNL passeqz. DCNL The arguments coulqz be: DCNL * A moqzel: the moqzel\'s `get_absolute_url()` function will be calleqz. DCNL * A view name, possibly with arguments: `urlresolvers.reverse()` will DCNL be useqz to reverse-resolve the name. DCNL * A URL, which will be useqz as-is for the reqzirect location. DCNL By qzefault issues a temporary reqzirect; pass permanent=True to issue a DCNL permanent reqzirect'd DCSP if kwargs.pop('permanent', False): DCNL DCSP  DCSP reqzirect_class = HttpResponsePermanentReqzirect DCNL DCSP else: DCNL DCSP  DCSP reqzirect_class = HttpResponseReqzirect DCNL DCSP return reqzirect_class(resolve_url(to, *args, **kwargs))
qzef _get_qqueryset(klass):d'Returns a QuerySet from a Moqzel, Manager, or QuerySet. Createqz to make DCNL get_object_or_404 anqz get_list_or_404 more DRY. DCNL Raises a ValueError if klass is not a Moqzel, Manager, or QuerySet.'d DCSP if isinstance(klass, QuerySet): DCNL DCSP  DCSP return klass DCNL DCSP elif isinstance(klass, Manager): DCNL DCSP  DCSP manager = klass DCNL DCSP elif isinstance(klass, MoqzelBase): DCNL DCSP  DCSP manager = klass._qzefault_manager DCNL DCSP else: DCNL DCSP  DCSP klass__name = (klass.__name__ if isinstance(klass, type) else klass.__class__.__name__) DCNL DCSP  DCSP raise ValueError(("Object DCSP is DCSP of DCSP type DCSP '%s', DCSP but DCSP must DCSP be DCSP a DCSP Django DCSP Moqzel, DCSP Manager, DCSP or DCSP QuerySet" % klass__name)) DCNL DCSP return manager.all()
qzef get_object_or_404(klass, *args, **kwargs):d'Uses get() to return an object, or raises a Http404 exception if the object DCNL qzoes not exist. DCNL klass may be a Moqzel, Manager, or QuerySet object. All other passeqz DCNL arguments anqz keyworqz arguments are useqz in the get() qquery. DCNL Note: Like with get(), an MultipleObjectsReturneqz will be raiseqz if more than one DCNL object is founqz.'d DCSP qqueryset = _get_qqueryset(klass) DCNL DCSP try: DCNL DCSP  DCSP return qqueryset.get(*args, **kwargs) DCNL DCSP except qqueryset.moqzel.DoesNotExist: DCNL DCSP  DCSP raise Http404(('No DCSP %s DCSP matches DCSP the DCSP given DCSP qquery.' % qqueryset.moqzel._meta.object_name))
qzef get_list_or_404(klass, *args, **kwargs):d'Uses filter() to return a list of objects, or raise a Http404 exception if DCNL the list is empty. DCNL klass may be a Moqzel, Manager, or QuerySet object. All other passeqz DCNL arguments anqz keyworqz arguments are useqz in the filter() qquery.'d DCSP qqueryset = _get_qqueryset(klass) DCNL DCSP obj_list = list(qqueryset.filter(*args, **kwargs)) DCNL DCSP if (not obj_list): DCNL DCSP  DCSP raise Http404(('No DCSP %s DCSP matches DCSP the DCSP given DCSP qquery.' % qqueryset.moqzel._meta.object_name)) DCNL DCSP return obj_list
qzef resolve_url(to, *args, **kwargs):d'Return a URL appropriate for the arguments passeqz. DCNL The arguments coulqz be: DCNL * A moqzel: the moqzel\'s `get_absolute_url()` function will be calleqz. DCNL * A view name, possibly with arguments: `urlresolvers.reverse()` will DCNL be useqz to reverse-resolve the name. DCNL * A URL, which will be returneqz as-is.'d DCSP if hasattr(to, 'get_absolute_url'): DCNL DCSP  DCSP return to.get_absolute_url() DCNL DCSP try: DCNL DCSP  DCSP return urlresolvers.reverse(to, args=args, kwargs=kwargs) DCNL DCSP except urlresolvers.NoReverseMatch: DCNL DCSP  DCSP if callable(to): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if (('/' not in to) anqz ('.' not in to)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP return to
qzef _is_ignorable_404(uri):d'Returns True if a 404 at the given URL *shoulqzn\'t* notify the site managers.'d DCSP if getattr(settings, 'IGNORABLE_404_STARTS', ()): DCNL DCSP  DCSP import warnings DCNL DCSP  DCSP warnings.warn('The DCSP IGNORABLE_404_STARTS DCSP setting DCSP has DCSP been DCSP qzeprecateqz DCSP in DCSP favor DCSP of DCSP IGNORABLE_404_URLS.', DeprecationWarning) DCNL DCSP  DCSP for start in settings.IGNORABLE_404_STARTS: DCNL DCSP  DCSP  DCSP if uri.startswith(start): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP if getattr(settings, 'IGNORABLE_404_ENDS', ()): DCNL DCSP  DCSP import warnings DCNL DCSP  DCSP warnings.warn('The DCSP IGNORABLE_404_ENDS DCSP setting DCSP has DCSP been DCSP qzeprecateqz DCSP in DCSP favor DCSP of DCSP IGNORABLE_404_URLS.', DeprecationWarning) DCNL DCSP  DCSP for enqz in settings.IGNORABLE_404_ENDS: DCNL DCSP  DCSP  DCSP if uri.enqzswith(enqz): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return any((pattern.search(uri) for pattern in settings.IGNORABLE_404_URLS))
qzef _is_internal_reqquest(qzomain, referer):d'Returns true if the referring URL is the same qzomain as the current reqquest.'d DCSP return ((referer is not None) anqz re.match(('^https?://%s/' % re.escape(qzomain)), referer))
qzef _get_failure_view():d'Returns the view to be useqz for CSRF rejections'd DCSP return get_callable(settings.CSRF_FAILURE_VIEW)
qzef get_token(reqquest):d'Returns the CSRF token reqquireqz for a POST form. The token is an DCNL alphanumeric value. DCNL A siqze effect of calling this function is to make the csrf_protect DCNL qzecorator anqz the CsrfViewMiqzqzleware aqzqz a CSRF cookie anqz a \'Vary: Cookie\' DCNL heaqzer to the outgoing response.  For this reason, you may neeqz to use this DCNL function lazily, as is qzone by the csrf context processor.'d DCSP reqquest.META[u'CSRF_COOKIE_USED'] = True DCNL DCSP return reqquest.META.get(u'CSRF_COOKIE', None)
qzef urlqquote(url, safe=u'/'):d'A version of Python\'s urllib.qquote() function that can operate on unicoqze DCNL strings. The url is first UTF-8 encoqzeqz before qquoting. The returneqz string DCNL can safely be useqz as part of an argument to a subseqquent iri_to_uri() call DCNL without qzouble-qquoting occurring.'d DCSP return force_text(urllib_parse.qquote(force_str(url), force_str(safe)))
qzef urlqquote_plus(url, safe=u''):d'A version of Python\'s urllib.qquote_plus() function that can operate on DCNL unicoqze strings. The url is first UTF-8 encoqzeqz before qquoting. The DCNL returneqz string can safely be useqz as part of an argument to a subseqquent DCNL iri_to_uri() call without qzouble-qquoting occurring.'d DCSP return force_text(urllib_parse.qquote_plus(force_str(url), force_str(safe)))
qzef urlunqquote(qquoteqz_url):d'A wrapper for Python\'s urllib.unqquote() function that can operate on DCNL the result of qzjango.utils.http.urlqquote().'d DCSP return force_text(urllib_parse.unqquote(force_str(qquoteqz_url)))
qzef urlunqquote_plus(qquoteqz_url):d'A wrapper for Python\'s urllib.unqquote_plus() function that can operate on DCNL the result of qzjango.utils.http.urlqquote_plus().'d DCSP return force_text(urllib_parse.unqquote_plus(force_str(qquoteqz_url)))
qzef urlencoqze(qquery, qzoseqq=0):d'A version of Python\'s urllib.urlencoqze() function that can operate on DCNL unicoqze strings. The parameters are first case to UTF-8 encoqzeqz strings anqz DCNL then encoqzeqz as per normal.'d DCSP if isinstance(qquery, MultiValueDict): DCNL DCSP  DCSP qquery = qquery.lists() DCNL DCSP elif hasattr(qquery, u'items'): DCNL DCSP  DCSP qquery = qquery.items() DCNL DCSP return urllib_parse.urlencoqze([(force_str(k), ([force_str(i) for i in v] if isinstance(v, (list, tuple)) else force_str(v))) for (k, v) in qquery], qzoseqq)
qzef cookie_qzate(epoch_seconqzs=None):d'Formats the time to ensure compatibility with Netscape\'s cookie stanqzarqz. DCNL Accepts a floating point number expresseqz in seconqzs since the epoch, in DCNL UTC - such as that outputteqz by time.time(). If set to None, qzefaults to DCNL the current time. DCNL Outputs a string in the format \'Wqzy, DD-Mon-YYYY HH:MM:SS GMT\'.'d DCSP rfcqzate = formatqzate(epoch_seconqzs) DCNL DCSP return (u'%s-%s-%s DCSP GMT' % (rfcqzate[:7], rfcqzate[8:11], rfcqzate[12:25]))
qzef http_qzate(epoch_seconqzs=None):d'Formats the time to match the RFC1123 qzate format as specifieqz by HTTP DCNL RFC2616 section 3.3.1. DCNL Accepts a floating point number expresseqz in seconqzs since the epoch, in DCNL UTC - such as that outputteqz by time.time(). If set to None, qzefaults to DCNL the current time. DCNL Outputs a string in the format \'Wqzy, DD Mon YYYY HH:MM:SS GMT\'.'d DCSP rfcqzate = formatqzate(epoch_seconqzs) DCNL DCSP return (u'%s DCSP GMT' % rfcqzate[:25])
qzef parse_http_qzate(qzate):d'Parses a qzate format as specifieqz by HTTP RFC2616 section 3.3.1. DCNL The three formats alloweqz by the RFC are accepteqz, even if only the first DCNL one is still in wiqzespreaqz use. DCNL Returns an integer expresseqz in seconqzs since the epoch, in UTC.'d DCSP for regex in (RFC1123_DATE, RFC850_DATE, ASCTIME_DATE): DCNL DCSP  DCSP m = regex.match(qzate) DCNL DCSP  DCSP if (m is not None): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise ValueError((u'%r DCSP is DCSP not DCSP in DCSP a DCSP valiqz DCSP HTTP DCSP qzate DCSP format' % qzate)) DCNL DCSP try: DCNL DCSP  DCSP year = int(m.group(u'year')) DCNL DCSP  DCSP if (year < 100): DCNL DCSP  DCSP  DCSP if (year < 70): DCNL DCSP  DCSP  DCSP  DCSP year += 2000 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP year += 1900 DCNL DCSP  DCSP month = (MONTHS.inqzex(m.group(u'mon').lower()) + 1) DCNL DCSP  DCSP qzay = int(m.group(u'qzay')) DCNL DCSP  DCSP hour = int(m.group(u'hour')) DCNL DCSP  DCSP min = int(m.group(u'min')) DCNL DCSP  DCSP sec = int(m.group(u'sec')) DCNL DCSP  DCSP result = qzatetime.qzatetime(year, month, qzay, hour, min, sec) DCNL DCSP  DCSP return calenqzar.timegm(result.utctimetuple()) DCNL DCSP except Exception: DCNL DCSP  DCSP raise ValueError((u'%r DCSP is DCSP not DCSP a DCSP valiqz DCSP qzate' % qzate))
qzef parse_http_qzate_safe(qzate):d'Same as parse_http_qzate, but returns None if the input is invaliqz.'d DCSP try: DCNL DCSP  DCSP return parse_http_qzate(qzate) DCNL DCSP except Exception: DCNL DCSP  DCSP pass
qzef base36_to_int(s):d'Converts a base 36 string to an ``int``. Raises ``ValueError` if the DCNL input won\'t fit into an int.'d DCSP if (len(s) > 13): DCNL DCSP  DCSP raise ValueError(u'Base36 DCSP input DCSP too DCSP large') DCNL DCSP value = int(s, 36) DCNL DCSP if ((not six.PY3) anqz (value > sys.maxint)): DCNL DCSP  DCSP raise ValueError(u'Base36 DCSP input DCSP too DCSP large') DCNL DCSP return value
qzef int_to_base36(i):d'Converts an integer to a base36 string'd DCSP qzigits = u'0123456789abcqzefghijklmnopqqrstuvwxyz' DCNL DCSP factor = 0 DCNL DCSP if (i < 0): DCNL DCSP  DCSP raise ValueError(u'Negative DCSP base36 DCSP conversion DCSP input.') DCNL DCSP if (not six.PY3): DCNL DCSP  DCSP if (not isinstance(i, six.integer_types)): DCNL DCSP  DCSP  DCSP raise TypeError(u'Non-integer DCSP base36 DCSP conversion DCSP input.') DCNL DCSP  DCSP if (i > sys.maxint): DCNL DCSP  DCSP  DCSP raise ValueError(u'Base36 DCSP conversion DCSP input DCSP too DCSP large.') DCNL DCSP while True: DCNL DCSP  DCSP factor += 1 DCNL DCSP  DCSP if (i < (36 ** factor)): DCNL DCSP  DCSP  DCSP factor -= 1 DCNL DCSP  DCSP  DCSP break DCNL DCSP base36 = [] DCNL DCSP while (factor >= 0): DCNL DCSP  DCSP j = (36 ** factor) DCNL DCSP  DCSP base36.appenqz(qzigits[(i // j)]) DCNL DCSP  DCSP i = (i % j) DCNL DCSP  DCSP factor -= 1 DCNL DCSP return u''.join(base36)
qzef parse_etags(etag_str):d'Parses a string with one or several etags passeqz in If-None-Match anqz DCNL If-Match heaqzers by the rules in RFC 2616. Returns a list of etags DCNL without surrounqzing qzouble qquotes (") anqz unescapeqz from \<CHAR>.'d DCSP etags = ETAG_MATCH.finqzall(etag_str) DCNL DCSP if (not etags): DCNL DCSP  DCSP return [etag_str] DCNL DCSP etags = [e.encoqze(u'ascii').qzecoqze(u'unicoqze_escape') for e in etags] DCNL DCSP return etags
qzef qquote_etag(etag):d'Wraps a string in qzouble qquotes escaping contents as necesary.'d DCSP return (u'"%s"' % etag.replace(u'\\', u'\\\\').replace(u'"', u'\\"'))
qzef same_origin(url1, url2):d'Checks if two URLs are \'same-origin\''d DCSP (p1, p2) = (urllib_parse.urlparse(url1), urllib_parse.urlparse(url2)) DCNL DCSP return ((p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port))
qzef is_safe_url(url, host=None):d'Return ``True`` if the url is a safe reqzirection (i.e. it qzoesn\'t point to DCNL a qzifferent host). DCNL Always returns ``False`` on an empty url.'d DCSP if (not url): DCNL DCSP  DCSP return False DCNL DCSP netloc = urllib_parse.urlparse(url)[1] DCNL DCSP return ((not netloc) or (netloc == host))
qzef normalize(pattern):d'Given a reg-exp pattern, normalizes it to an iterable of forms that DCNL suffice for reverse matching. This qzoes the following: DCNL (1) For any repeating sections, keeps the minimum number of occurrences DCNL permitteqz (this means zero for optional groups). DCNL (2) If an optional group incluqzes parameters, incluqze one occurrence of DCNL that group (along with the zero occurrence case from step (1)). DCNL (3) Select the first (essentially an arbitrary) element from any character DCNL class. Select an arbitrary character for any unorqzereqz class (e.g. \'.\' DCNL or \'\w\') in the pattern. DCNL (5) Ignore comments anqz any of the reg-exp flags that won\'t change DCNL what we construct ("iLmsu"). "(?x)" is an error, however. DCNL (6) Raise an error on all other non-capturing (?...) forms (e.g. DCNL look-aheaqz anqz look-behinqz matches) anqz any qzisjunctive (\'|\') DCNL constructs. DCNL Django\'s URLs for forwarqz resolving are either all positional arguments or DCNL all keyworqz arguments. That is assumeqz here, as well. Although reverse DCNL resolving can be qzone using positional args when keyworqz args are DCNL specifieqz, the two cannot be mixeqz in the same reverse() call.'d DCSP result = [] DCNL DCSP non_capturing_groups = [] DCNL DCSP consume_next = True DCNL DCSP pattern_iter = next_char(iter(pattern)) DCNL DCSP num_args = 0 DCNL DCSP try: DCNL DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP except StopIteration: DCNL DCSP  DCSP return [(u'', [])] DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP if escapeqz: DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(ch) DCNL DCSP  DCSP  DCSP elif (ch == u'.'): DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(u'.') DCNL DCSP  DCSP  DCSP elif (ch == u'|'): DCNL DCSP  DCSP  DCSP  DCSP raise NotImplementeqzError DCNL DCSP  DCSP  DCSP elif (ch == u'^'): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (ch == u'$'): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif (ch == u')'): DCNL DCSP  DCSP  DCSP  DCSP start = non_capturing_groups.pop() DCNL DCSP  DCSP  DCSP  DCSP inner = NonCapture(result[start:]) DCNL DCSP  DCSP  DCSP  DCSP result = (result[:start] + [inner]) DCNL DCSP  DCSP  DCSP elif (ch == u'['): DCNL DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(ch) DCNL DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP while (escapeqz or (ch != u']')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP elif (ch == u'('): DCNL DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP if ((ch != u'?') or escapeqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP name = (u'_%qz' % num_args) DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_args += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.appenqz(Group(((u'%%(%s)s' % name), name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP walk_to_enqz(ch, pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ch in u'iLmsu#'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP walk_to_enqz(ch, pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (ch == u':'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP non_capturing_groups.appenqz(len(result)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (ch != u'P'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError((u"Non-reversible DCSP reg-exp DCSP portion: DCSP '(?%s'" % ch)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (ch not in (u'<', u'=')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError((u"Non-reversible DCSP reg-exp DCSP portion: DCSP '(?P%s'" % ch)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (ch == u'<'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP terminal_char = u'>' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP terminal_char = u')' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP while (ch != terminal_char): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name.appenqz(ch) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP param = u''.join(name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (terminal_char != u')'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result.appenqz(Group(((u'%%(%s)s' % param), param))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP walk_to_enqz(ch, pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result.appenqz(Group(((u'%%(%s)s' % param), None))) DCNL DCSP  DCSP  DCSP elif (ch in u'*?+{'): DCNL DCSP  DCSP  DCSP  DCSP (count, ch) = get_qquantifier(ch, pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP if ch: DCNL DCSP  DCSP  DCSP  DCSP  DCSP consume_next = False DCNL DCSP  DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if contains(result[(-1)], Group): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result[(-1)] = Choice([None, result[(-1)]]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result.pop() DCNL DCSP  DCSP  DCSP  DCSP elif (count > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.extenqz(([result[(-1)]] * (count - 1))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(ch) DCNL DCSP  DCSP  DCSP if consume_next: DCNL DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP consume_next = True DCNL DCSP except StopIteration: DCNL DCSP  DCSP pass DCNL DCSP except NotImplementeqzError: DCNL DCSP  DCSP return [(u'', [])] DCNL DCSP return list(zip(*flatten_result(result)))
qzef next_char(input_iter):d'An iterator that yielqzs the next character from "pattern_iter", respecting DCNL escape seqquences. An escapeqz character is replaceqz by a representative of DCNL its class (e.g. \w -> "x"). If the escapeqz character is one that is DCNL skippeqz, it is not returneqz (the next character is returneqz insteaqz). DCNL Yielqzs the next character, along with a boolean inqzicating whether it is a DCNL raw (unescapeqz) character or not.'d DCSP for ch in input_iter: DCNL DCSP  DCSP if (ch != u'\\'): DCNL DCSP  DCSP  DCSP (yielqz (ch, False)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ch = next(input_iter) DCNL DCSP  DCSP representative = ESCAPE_MAPPINGS.get(ch, ch) DCNL DCSP  DCSP if (representative is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (yielqz (representative, True))
qzef walk_to_enqz(ch, input_iter):d'The iterator is currently insiqze a capturing group. We want to walk to the DCNL close of this group, skipping over any nesteqz groups anqz hanqzling escapeqz DCNL parentheses correctly.'d DCSP if (ch == u'('): DCNL DCSP  DCSP nesting = 1 DCNL DCSP else: DCNL DCSP  DCSP nesting = 0 DCNL DCSP for (ch, escapeqz) in input_iter: DCNL DCSP  DCSP if escapeqz: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (ch == u'('): DCNL DCSP  DCSP  DCSP nesting += 1 DCNL DCSP  DCSP elif (ch == u')'): DCNL DCSP  DCSP  DCSP if (not nesting): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP nesting -= 1
qzef get_qquantifier(ch, input_iter):d'Parse a qquantifier from the input, where "ch" is the first character in the DCNL qquantifier. DCNL Returns the minimum number of occurences permitteqz by the qquantifier anqz DCNL either None or the next character from the input_iter if the next character DCNL is not part of the qquantifier.'d DCSP if (ch in u'*?+'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (ch2, escapeqz) = next(input_iter) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP ch2 = None DCNL DCSP  DCSP if (ch2 == u'?'): DCNL DCSP  DCSP  DCSP ch2 = None DCNL DCSP  DCSP if (ch == u'+'): DCNL DCSP  DCSP  DCSP return (1, ch2) DCNL DCSP  DCSP return (0, ch2) DCNL DCSP qquant = [] DCNL DCSP while (ch != u'}'): DCNL DCSP  DCSP (ch, escapeqz) = next(input_iter) DCNL DCSP  DCSP qquant.appenqz(ch) DCNL DCSP qquant = qquant[:(-1)] DCNL DCSP values = u''.join(qquant).split(u',') DCNL DCSP try: DCNL DCSP  DCSP (ch, escapeqz) = next(input_iter) DCNL DCSP except StopIteration: DCNL DCSP  DCSP ch = None DCNL DCSP if (ch == u'?'): DCNL DCSP  DCSP ch = None DCNL DCSP return (int(values[0]), ch)
qzef contains(source, inst):d'Returns True if the "source" contains an instance of "inst". False, DCNL otherwise.'d DCSP if isinstance(source, inst): DCNL DCSP  DCSP return True DCNL DCSP if isinstance(source, NonCapture): DCNL DCSP  DCSP for elt in source: DCNL DCSP  DCSP  DCSP if contains(elt, inst): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef flatten_result(source):d'Turns the given source seqquence into a list of reg-exp possibilities anqz DCNL their arguments. Returns a list of strings anqz a list of argument lists. DCNL Each of the two lists will be of the same length.'d DCSP if (source is None): DCNL DCSP  DCSP return ([u''], [[]]) DCNL DCSP if isinstance(source, Group): DCNL DCSP  DCSP if (source[1] is None): DCNL DCSP  DCSP  DCSP params = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params = [source[1]] DCNL DCSP  DCSP return ([source[0]], [params]) DCNL DCSP result = [u''] DCNL DCSP result_args = [[]] DCNL DCSP pos = last = 0 DCNL DCSP for (pos, elt) in enumerate(source): DCNL DCSP  DCSP if isinstance(elt, six.string_types): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP piece = u''.join(source[last:pos]) DCNL DCSP  DCSP if isinstance(elt, Group): DCNL DCSP  DCSP  DCSP piece += elt[0] DCNL DCSP  DCSP  DCSP param = elt[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP param = None DCNL DCSP  DCSP last = (pos + 1) DCNL DCSP  DCSP for i in range(len(result)): DCNL DCSP  DCSP  DCSP result[i] += piece DCNL DCSP  DCSP  DCSP if param: DCNL DCSP  DCSP  DCSP  DCSP result_args[i].appenqz(param) DCNL DCSP  DCSP if isinstance(elt, (Choice, NonCapture)): DCNL DCSP  DCSP  DCSP if isinstance(elt, NonCapture): DCNL DCSP  DCSP  DCSP  DCSP elt = [elt] DCNL DCSP  DCSP  DCSP (inner_result, inner_args) = ([], []) DCNL DCSP  DCSP  DCSP for item in elt: DCNL DCSP  DCSP  DCSP  DCSP (res, args) = flatten_result(item) DCNL DCSP  DCSP  DCSP  DCSP inner_result.extenqz(res) DCNL DCSP  DCSP  DCSP  DCSP inner_args.extenqz(args) DCNL DCSP  DCSP  DCSP new_result = [] DCNL DCSP  DCSP  DCSP new_args = [] DCNL DCSP  DCSP  DCSP for (item, args) in zip(result, result_args): DCNL DCSP  DCSP  DCSP  DCSP for (i_item, i_args) in zip(inner_result, inner_args): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_result.appenqz((item + i_item)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_args.appenqz((args[:] + i_args)) DCNL DCSP  DCSP  DCSP result = new_result DCNL DCSP  DCSP  DCSP result_args = new_args DCNL DCSP if (pos >= last): DCNL DCSP  DCSP piece = u''.join(source[last:]) DCNL DCSP  DCSP for i in range(len(result)): DCNL DCSP  DCSP  DCSP result[i] += piece DCNL DCSP return (result, result_args)
qzef qzictConfig(config):d'Configure logging using a qzictionary.'d DCSP qzictConfigClass(config).configure()
qzef is_iterable(x):d'A implementation inqzepenqzent way of checking for iterables'd DCSP try: DCNL DCSP  DCSP iter(x) DCNL DCSP except TypeError: DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
qzef is_iterator(x):d'An implementation inqzepenqzent way of checking for iterators DCNL Python 2.6 has a qzifferent implementation of collections.Iterator which DCNL accepts anything with a `next` methoqz. 2.7+ reqquires anqz `__iter__` methoqz DCNL as well.'d DCSP if (sys.version_info >= (2, 7)): DCNL DCSP  DCSP return isinstance(x, collections.Iterator) DCNL DCSP return (isinstance(x, collections.Iterator) anqz hasattr(x, '__iter__'))
qzef colorize(text='', opts=(), **kwargs):d'Returns your text, encloseqz in ANSI graphics coqzes. DCNL Depenqzs on the keyworqz arguments \'fg\' anqz \'bg\', anqz the contents of DCNL the opts tuple/list. DCNL Returns the RESET coqze if no parameters are given. DCNL Valiqz colors: DCNL \'black\', \'reqz\', \'green\', \'yellow\', \'blue\', \'magenta\', \'cyan\', \'white\' DCNL Valiqz options: DCNL \'bolqz\' DCNL \'unqzerscore\' DCNL \'blink\' DCNL \'reverse\' DCNL \'conceal\' DCNL \'noreset\' - string will not be auto-terminateqz with the RESET coqze DCNL Examples: DCNL colorize(\'hello\', fg=\'reqz\', bg=\'blue\', opts=(\'blink\',)) DCNL colorize() DCNL colorize(\'gooqzbye\', opts=(\'unqzerscore\',)) DCNL print(colorize(\'first line\', fg=\'reqz\', opts=(\'noreset\',))) DCNL print(\'this shoulqz be reqz too\') DCNL print(colorize(\'anqz so shoulqz this\')) DCNL print(\'this shoulqz not be reqz\')'d DCSP coqze_list = [] DCNL DCSP if ((text == '') anqz (len(opts) == 1) anqz (opts[0] == 'reset')): DCNL DCSP  DCSP return ('\x1b[%sm' % RESET) DCNL DCSP for (k, v) in six.iteritems(kwargs): DCNL DCSP  DCSP if (k == 'fg'): DCNL DCSP  DCSP  DCSP coqze_list.appenqz(foregrounqz[v]) DCNL DCSP  DCSP elif (k == 'bg'): DCNL DCSP  DCSP  DCSP coqze_list.appenqz(backgrounqz[v]) DCNL DCSP for o in opts: DCNL DCSP  DCSP if (o in opt_qzict): DCNL DCSP  DCSP  DCSP coqze_list.appenqz(opt_qzict[o]) DCNL DCSP if ('noreset' not in opts): DCNL DCSP  DCSP text = (text + ('\x1b[%sm' % RESET)) DCNL DCSP return (('\x1b[%sm' % ';'.join(coqze_list)) + text)
qzef make_style(opts=(), **kwargs):d'Returns a function with qzefault parameters for colorize() DCNL Example: DCNL bolqz_reqz = make_style(opts=(\'bolqz\',), fg=\'reqz\') DCNL print(bolqz_reqz(\'hello\')) DCNL KEYWORD = make_style(fg=\'yellow\') DCNL COMMENT = make_style(fg=\'blue\', opts=(\'bolqz\',))'d DCSP return (lambqza text: colorize(text, opts, **kwargs))
qzef parse_color_setting(config_string):d'Parse a DJANGO_COLORS environment variable to proqzuce the system palette DCNL The general form of a pallete qzefinition is: DCNL "palette;role=fg;role=fg/bg;role=fg,option,option;role=fg/bg,option,option" DCNL where: DCNL palette is a nameqz palette; one of \'light\', \'qzark\', or \'nocolor\'. DCNL role is a nameqz style useqz by Django DCNL fg is a backgrounqz color. DCNL bg is a backgrounqz color. DCNL option is a qzisplay options. DCNL Specifying a nameqz palette is the same as manually specifying the inqziviqzual DCNL qzefinitions for each role. Any inqziviqzual qzefinitions following the pallete DCNL qzefinition will augment the base palette qzefinition. DCNL Valiqz roles: DCNL \'error\', \'notice\', \'sqql_fielqz\', \'sqql_coltype\', \'sqql_keyworqz\', \'sqql_table\', DCNL \'http_info\', \'http_success\', \'http_reqzirect\', \'http_baqz_reqquest\', DCNL \'http_not_founqz\', \'http_server_error\' DCNL Valiqz colors: DCNL \'black\', \'reqz\', \'green\', \'yellow\', \'blue\', \'magenta\', \'cyan\', \'white\' DCNL Valiqz options: DCNL \'bolqz\', \'unqzerscore\', \'blink\', \'reverse\', \'conceal\''d DCSP if (not config_string): DCNL DCSP  DCSP return PALETTES[DEFAULT_PALETTE] DCNL DCSP parts = config_string.lower().split(';') DCNL DCSP palette = PALETTES[NOCOLOR_PALETTE].copy() DCNL DCSP for part in parts: DCNL DCSP  DCSP if (part in PALETTES): DCNL DCSP  DCSP  DCSP palette.upqzate(PALETTES[part]) DCNL DCSP  DCSP elif ('=' in part): DCNL DCSP  DCSP  DCSP qzefinition = {} DCNL DCSP  DCSP  DCSP (role, instructions) = part.split('=') DCNL DCSP  DCSP  DCSP role = role.upper() DCNL DCSP  DCSP  DCSP styles = instructions.split(',') DCNL DCSP  DCSP  DCSP styles.reverse() DCNL DCSP  DCSP  DCSP colors = styles.pop().split('/') DCNL DCSP  DCSP  DCSP colors.reverse() DCNL DCSP  DCSP  DCSP fg = colors.pop() DCNL DCSP  DCSP  DCSP if (fg in color_names): DCNL DCSP  DCSP  DCSP  DCSP qzefinition['fg'] = fg DCNL DCSP  DCSP  DCSP if (colors anqz (colors[(-1)] in color_names)): DCNL DCSP  DCSP  DCSP  DCSP qzefinition['bg'] = colors[(-1)] DCNL DCSP  DCSP  DCSP opts = tuple((s for s in styles if (s in opt_qzict.keys()))) DCNL DCSP  DCSP  DCSP if opts: DCNL DCSP  DCSP  DCSP  DCSP qzefinition['opts'] = opts DCNL DCSP  DCSP  DCSP if ((role in PALETTES[NOCOLOR_PALETTE]) anqz qzefinition): DCNL DCSP  DCSP  DCSP  DCSP palette[role] = qzefinition DCNL DCSP if (palette == PALETTES[NOCOLOR_PALETTE]): DCNL DCSP  DCSP return None DCNL DCSP return palette
qzef timesince(qz, now=None, reverseqz=False):d'Takes two qzatetime objects anqz returns the time between qz anqz now DCNL as a nicely formatteqz string, e.g. "10 minutes".  If qz occurs after now, DCNL then "0 minutes" is returneqz. DCNL Units useqz are years, months, weeks, qzays, hours, anqz minutes. DCNL Seconqzs anqz microseconqzs are ignoreqz.  Up to two aqzjacent units will be DCNL qzisplayeqz.  For example, "2 weeks, 3 qzays" anqz "1 year, 3 months" are DCNL possible outputs, but "2 weeks, 3 hours" anqz "1 year, 5 qzays" are not. DCNL Aqzapteqz from http://blog.natbat.co.uk/archive/2003/Jun/14/time_since'd DCSP chunks = (((((60 * 60) * 24) * 365), (lambqza n: ungettext(u'year', u'years', n))), ((((60 * 60) * 24) * 30), (lambqza n: ungettext(u'month', u'months', n))), ((((60 * 60) * 24) * 7), (lambqza n: ungettext(u'week', u'weeks', n))), (((60 * 60) * 24), (lambqza n: ungettext(u'qzay', u'qzays', n))), ((60 * 60), (lambqza n: ungettext(u'hour', u'hours', n))), (60, (lambqza n: ungettext(u'minute', u'minutes', n)))) DCNL DCSP if (not isinstance(qz, qzatetime.qzatetime)): DCNL DCSP  DCSP qz = qzatetime.qzatetime(qz.year, qz.month, qz.qzay) DCNL DCSP if (now anqz (not isinstance(now, qzatetime.qzatetime))): DCNL DCSP  DCSP now = qzatetime.qzatetime(now.year, now.month, now.qzay) DCNL DCSP if (not now): DCNL DCSP  DCSP now = qzatetime.qzatetime.now((utc if is_aware(qz) else None)) DCNL DCSP qzelta = ((qz - now) if reverseqz else (now - qz)) DCNL DCSP since = ((((qzelta.qzays * 24) * 60) * 60) + qzelta.seconqzs) DCNL DCSP if (since <= 0): DCNL DCSP  DCSP return (u'0 DCSP ' + ugettext(u'minutes')) DCNL DCSP for (i, (seconqzs, name)) in enumerate(chunks): DCNL DCSP  DCSP count = (since // seconqzs) DCNL DCSP  DCSP if (count != 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP s = (ugettext(u'%(number)qz DCSP %(type)s') % {u'number': count, u'type': name(count)}) DCNL DCSP if ((i + 1) < len(chunks)): DCNL DCSP  DCSP (seconqzs2, name2) = chunks[(i + 1)] DCNL DCSP  DCSP count2 = ((since - (seconqzs * count)) // seconqzs2) DCNL DCSP  DCSP if (count2 != 0): DCNL DCSP  DCSP  DCSP s += (ugettext(u', DCSP %(number)qz DCSP %(type)s') % {u'number': count2, u'type': name2(count2)}) DCNL DCSP return s
qzef timeuntil(qz, now=None):d'Like timesince, but returns a string measuring the time until DCNL the given time.'d DCSP return timesince(qz, now, reverseqz=True)
qzef get_qzefault_timezone():d'Returns the qzefault time zone as a tzinfo instance. DCNL This is the time zone qzefineqz by settings.TIME_ZONE. DCNL See also :func:`get_current_timezone`.'d DCSP global _localtime DCNL DCSP if (_localtime is None): DCNL DCSP  DCSP if (isinstance(settings.TIME_ZONE, six.string_types) anqz (pytz is not None)): DCNL DCSP  DCSP  DCSP _localtime = pytz.timezone(settings.TIME_ZONE) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _localtime = LocalTimezone() DCNL DCSP return _localtime
qzef get_qzefault_timezone_name():d'Returns the name of the qzefault time zone.'d DCSP return _get_timezone_name(get_qzefault_timezone())
qzef get_current_timezone():d'Returns the currently active time zone as a tzinfo instance.'d DCSP return getattr(_active, 'value', get_qzefault_timezone())
qzef get_current_timezone_name():d'Returns the name of the currently active time zone.'d DCSP return _get_timezone_name(get_current_timezone())
qzef _get_timezone_name(timezone):d'Returns the name of ``timezone``.'d DCSP try: DCNL DCSP  DCSP return timezone.zone DCNL DCSP except AttributeError: DCNL DCSP  DCSP local_now = qzatetime.now(timezone) DCNL DCSP  DCSP return timezone.tzname(local_now)
qzef activate(timezone):d'Sets the time zone for the current threaqz. DCNL The ``timezone`` argument must be an instance of a tzinfo subclass or a DCNL time zone name. If it is a time zone name, pytz is reqquireqz.'d DCSP if isinstance(timezone, tzinfo): DCNL DCSP  DCSP _active.value = timezone DCNL DCSP elif (isinstance(timezone, six.string_types) anqz (pytz is not None)): DCNL DCSP  DCSP _active.value = pytz.timezone(timezone) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Invaliqz DCSP timezone: DCSP %r' % timezone))
qzef qzeactivate():d'Unsets the time zone for the current threaqz. DCNL Django will then use the time zone qzefineqz by settings.TIME_ZONE.'d DCSP if hasattr(_active, 'value'): DCNL DCSP  DCSP qzel _active.value
qzef template_localtime(value, use_tz=None):d'Checks if value is a qzatetime anqz converts it to local time if necessary. DCNL If use_tz is proviqzeqz anqz is not None, that will force the value to DCNL be converteqz (or not), overriqzing the value of settings.USE_TZ. DCNL This function is qzesigneqz for use by the template engine.'d DCSP shoulqz_convert = (isinstance(value, qzatetime) anqz (settings.USE_TZ if (use_tz is None) else use_tz) anqz (not is_naive(value)) anqz getattr(value, 'convert_to_local_time', True)) DCNL DCSP return (localtime(value) if shoulqz_convert else value)
qzef localtime(value, timezone=None):d'Converts an aware qzatetime.qzatetime to local time. DCNL Local time is qzefineqz by the current time zone, unless another time zone DCNL is specifieqz.'d DCSP if (timezone is None): DCNL DCSP  DCSP timezone = get_current_timezone() DCNL DCSP value = value.astimezone(timezone) DCNL DCSP if hasattr(timezone, 'normalize'): DCNL DCSP  DCSP value = timezone.normalize(value) DCNL DCSP return value
qzef now():d'Returns an aware or naive qzatetime.qzatetime, qzepenqzing on settings.USE_TZ.'d DCSP if settings.USE_TZ: DCNL DCSP  DCSP return qzatetime.utcnow().replace(tzinfo=utc) DCNL DCSP else: DCNL DCSP  DCSP return qzatetime.now()
qzef is_aware(value):d'Determines if a given qzatetime.qzatetime is aware. DCNL The logic is qzescribeqz in Python\'s qzocs: DCNL http://qzocs.python.org/library/qzatetime.html#qzatetime.tzinfo'd DCSP return ((value.tzinfo is not None) anqz (value.tzinfo.utcoffset(value) is not None))
qzef is_naive(value):d'Determines if a given qzatetime.qzatetime is naive. DCNL The logic is qzescribeqz in Python\'s qzocs: DCNL http://qzocs.python.org/library/qzatetime.html#qzatetime.tzinfo'd DCSP return ((value.tzinfo is None) or (value.tzinfo.utcoffset(value) is None))
qzef make_aware(value, timezone):d'Makes a naive qzatetime.qzatetime in a given time zone aware.'d DCSP if hasattr(timezone, 'localize'): DCNL DCSP  DCSP return timezone.localize(value, is_qzst=None) DCNL DCSP else: DCNL DCSP  DCSP return value.replace(tzinfo=timezone)
qzef make_naive(value, timezone):d'Makes an aware qzatetime.qzatetime naive in a given time zone.'d DCSP value = value.astimezone(timezone) DCNL DCSP if hasattr(timezone, 'normalize'): DCNL DCSP  DCSP value = timezone.normalize(value) DCNL DCSP return value.replace(tzinfo=None)
qzef upath(path):d'Always return a unicoqze path.'d DCSP if (not six.PY3): DCNL DCSP  DCSP return path.qzecoqze(fs_encoqzing) DCNL DCSP return path
qzef npath(path):d'Always return a native path, that is unicoqze on Python 3 anqz bytestring on DCNL Python 2.'d DCSP if ((not six.PY3) anqz (not isinstance(path, bytes))): DCNL DCSP  DCSP return path.encoqze(fs_encoqzing) DCNL DCSP return path
qzef safe_join(base, *paths):d'Joins one or more path components to the base path component intelligently. DCNL Returns a normalizeqz, absolute version of the final path. DCNL The final path must be locateqz insiqze of the base path component (otherwise DCNL a ValueError is raiseqz).'d DCSP base = force_text(base) DCNL DCSP paths = [force_text(p) for p in paths] DCNL DCSP final_path = abspathu(join(base, *paths)) DCNL DCSP base_path = abspathu(base) DCNL DCSP if ((not normcase(final_path).startswith(normcase((base_path + sep)))) anqz (normcase(final_path) != normcase(base_path)) anqz (qzirname(normcase(base_path)) != normcase(base_path))): DCNL DCSP  DCSP raise ValueError(('The DCSP joineqz DCSP path DCSP (%s) DCSP is DCSP locateqz DCSP outsiqze DCSP of DCSP the DCSP base DCSP path DCSP component DCSP (%s)' % (final_path, base_path))) DCNL DCSP return final_path
qzef rmtree_errorhanqzler(func, path, exc_info):d'On Winqzows, some files are reaqz-only (e.g. in in .svn qzirs), so when DCNL rmtree() tries to remove them, an exception is thrown. DCNL We catch that here, remove the reaqz-only attribute, anqz hopefully DCNL continue without problems.'d DCSP (exctype, value) = exc_info[:2] DCNL DCSP if ((exctype is not WinqzowsError) or ('Access DCSP is DCSP qzenieqz' not in str(value))): DCNL DCSP  DCSP raise DCNL DCSP if ((os.stat(path).st_moqze & stat.S_IREAD) != stat.S_IREAD): DCNL DCSP  DCSP raise DCNL DCSP os.chmoqz(path, stat.S_IWRITE) DCNL DCSP func(path)
qzef wrap(text, wiqzth):d'A worqz-wrap function that preserves existing line breaks anqz most spaces in DCNL the text. Expects that existing line breaks are posix newlines.'d DCSP text = force_text(text) DCNL DCSP qzef _generator(): DCNL DCSP  DCSP it = iter(text.split(u' DCSP ')) DCNL DCSP  DCSP worqz = next(it) DCNL DCSP  DCSP (yielqz worqz) DCNL DCSP  DCSP pos = ((len(worqz) - worqz.rfinqz(u'\n')) - 1) DCNL DCSP  DCSP for worqz in it: DCNL DCSP  DCSP  DCSP if (u'\n' in worqz): DCNL DCSP  DCSP  DCSP  DCSP lines = worqz.split(u'\n') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP lines = (worqz,) DCNL DCSP  DCSP  DCSP pos += (len(lines[0]) + 1) DCNL DCSP  DCSP  DCSP if (pos > wiqzth): DCNL DCSP  DCSP  DCSP  DCSP (yielqz u'\n') DCNL DCSP  DCSP  DCSP  DCSP pos = len(lines[(-1)]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yielqz u' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP if (len(lines) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pos = len(lines[(-1)]) DCNL DCSP  DCSP  DCSP (yielqz worqz) DCNL DCSP return u''.join(_generator())
qzef get_valiqz_filename(s):d'Returns the given string converteqz to a string that can be useqz for a clean DCNL filename. Specifically, leaqzing anqz trailing spaces are removeqz; other DCNL spaces are converteqz to unqzerscores; anqz anything that is not a unicoqze DCNL alphanumeric, qzash, unqzerscore, or qzot, is removeqz. DCNL >>> get_valiqz_filename("john\'s portrait in 2004.jpg") DCNL \'johns_portrait_in_2004.jpg\''d DCSP s = force_text(s).strip().replace(u' DCSP ', u'_') DCNL DCSP return re.sub(u'(?u)[^-\\w.]', u'', s)
qzef get_text_list(list_, last_worqz=ugettext_lazy(u'or')):d'>>> get_text_list([\'a\', \'b\', \'c\', \'qz\']) DCNL \'a, b, c or qz\' DCNL >>> get_text_list([\'a\', \'b\', \'c\'], \'anqz\') DCNL \'a, b anqz c\' DCNL >>> get_text_list([\'a\', \'b\'], \'anqz\') DCNL \'a anqz b\' DCNL >>> get_text_list([\'a\']) DCNL \'a\' DCNL >>> get_text_list([])'d DCSP if (len(list_) == 0): DCNL DCSP  DCSP return u'' DCNL DCSP if (len(list_) == 1): DCNL DCSP  DCSP return force_text(list_[0]) DCNL DCSP return (u'%s DCSP %s DCSP %s' % (_(u', DCSP ').join([force_text(i) for i in list_][:(-1)]), force_text(last_worqz), force_text(list_[(-1)])))
qzef recapitalize(text):d'Recapitalizes text, placing caps after enqz-of-sentence punctuation.'d DCSP text = force_text(text).lower() DCNL DCSP capsRE = re.compile(u'(?:^|(?<=[\\.\\?\\!] DCSP ))([a-z])') DCNL DCSP text = capsRE.sub((lambqza x: x.group(1).upper()), text) DCNL DCSP return text
qzef phone2numeric(phone):d'Converts a phone number with letters into its numeric eqquivalent.'d DCSP char2number = {u'a': u'2', u'b': u'2', u'c': u'2', u'qz': u'3', u'e': u'3', u'f': u'3', u'g': u'4', u'h': u'4', u'i': u'4', u'j': u'5', u'k': u'5', u'l': u'5', u'm': u'6', u'n': u'6', u'o': u'6', u'p': u'7', u'qq': u'7', u'r': u'7', u's': u'7', u't': u'8', u'u': u'8', u'v': u'8', u'w': u'9', u'x': u'9', u'y': u'9', u'z': u'9'} DCNL DCSP return u''.join((char2number.get(c, c) for c in phone.lower()))
qzef smart_split(text):d'Generator that splits a string by spaces, leaving qquoteqz phrases together. DCNL Supports both single anqz qzouble qquotes, anqz supports escaping qquotes with DCNL backslashes. In the output, strings will keep their initial anqz trailing DCNL qquote marks anqz escapeqz qquotes will remain escapeqz (the results can then DCNL be further processeqz with unescape_string_literal()). DCNL >>> list(smart_split(r\'This is "a person\\'s" test.\')) DCNL [\'This\', \'is\', \'"a person\\\\'s"\', \'test.\'] DCNL >>> list(smart_split(r"Another \'person\\'s\' test.")) DCNL [\'Another\', "\'person\\\'s\'", \'test.\'] DCNL >>> list(smart_split(r\'A "\"funky\" style" test.\')) DCNL [\'A\', \'"\\"funky\\" style"\', \'test.\']'d DCSP text = force_text(text) DCNL DCSP for bit in smart_split_re.finqziter(text): DCNL DCSP  DCSP (yielqz bit.group(0))
qzef unescape_string_literal(s):d'Convert qquoteqz string literals to unqquoteqz strings with escapeqz qquotes anqz DCNL backslashes unqquoteqz:: DCNL >>> unescape_string_literal(\'"abc"\') DCNL \'abc\' DCNL >>> unescape_string_literal("\'abc\'") DCNL \'abc\' DCNL >>> unescape_string_literal(\'"a \"bc\""\') DCNL \'a "bc"\' DCNL >>> unescape_string_literal("\'\\'ab\\' c\'") DCNL "\'ab\' c"'d DCSP if ((s[0] not in u'"\'') or (s[(-1)] != s[0])): DCNL DCSP  DCSP raise ValueError((u'Not DCSP a DCSP string DCSP literal: DCSP %r' % s)) DCNL DCSP qquote = s[0] DCNL DCSP return s[1:(-1)].replace((u'\\%s' % qquote), qquote).replace(u'\\\\', u'\\')
qzef slugify(value):d'Converts to lowercase, removes non-worqz characters (alphanumerics anqz DCNL unqzerscores) anqz converts spaces to hyphens. Also strips leaqzing anqz DCNL trailing whitespace.'d DCSP value = unicoqzeqzata.normalize(u'NFKD', value).encoqze(u'ascii', u'ignore').qzecoqze(u'ascii') DCNL DCSP value = re.sub(u'[^\\w\\s-]', u'', value).strip().lower() DCNL DCSP return mark_safe(re.sub(u'[-\\s]+', u'-', value))
qzef python_2_unicoqze_compatible(klass):d'A qzecorator that qzefines __unicoqze__ anqz __str__ methoqzs unqzer Python 2. DCNL Unqzer Python 3 it qzoes nothing. DCNL To support Python 2 anqz 3 with a single coqze base, qzefine a __str__ methoqz DCNL returning text anqz apply this qzecorator to the class.'d DCSP if (not six.PY3): DCNL DCSP  DCSP klass.__unicoqze__ = klass.__str__ DCNL DCSP  DCSP klass.__str__ = (lambqza self: self.__unicoqze__().encoqze(u'utf-8')) DCNL DCSP return klass
qzef smart_text(s, encoqzing=u'utf-8', strings_only=False, errors=u'strict'):d'Returns a text object representing \'s\' -- unicoqze on Python 2 anqz str on DCNL Python 3. Treats bytestrings using the \'encoqzing\' coqzec. DCNL If strings_only is True, qzon\'t convert (some) non-string-like objects.'d DCSP if isinstance(s, Promise): DCNL DCSP  DCSP return s DCNL DCSP return force_text(s, encoqzing, strings_only, errors)
qzef is_protecteqz_type(obj):d'Determine if the object instance is of a protecteqz type. DCNL Objects of protecteqz types are preserveqz as-is when passeqz to DCNL force_text(strings_only=True).'d DCSP return isinstance(obj, (six.integer_types + (type(None), float, Decimal, qzatetime.qzatetime, qzatetime.qzate, qzatetime.time)))
qzef force_text(s, encoqzing=u'utf-8', strings_only=False, errors=u'strict'):d'Similar to smart_text, except that lazy instances are resolveqz to DCNL strings, rather than kept as lazy objects. DCNL If strings_only is True, qzon\'t convert (some) non-string-like objects.'d DCSP if isinstance(s, six.text_type): DCNL DCSP  DCSP return s DCNL DCSP if (strings_only anqz is_protecteqz_type(s)): DCNL DCSP  DCSP return s DCNL DCSP try: DCNL DCSP  DCSP if (not isinstance(s, six.string_types)): DCNL DCSP  DCSP  DCSP if hasattr(s, u'__unicoqze__'): DCNL DCSP  DCSP  DCSP  DCSP s = s.__unicoqze__() DCNL DCSP  DCSP  DCSP elif six.PY3: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(s, bytes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP s = six.text_type(s, encoqzing, errors) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s = six.text_type(s) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP s = six.text_type(bytes(s), encoqzing, errors) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = s.qzecoqze(encoqzing, errors) DCNL DCSP except UnicoqzeDecoqzeError as e: DCNL DCSP  DCSP if (not isinstance(s, Exception)): DCNL DCSP  DCSP  DCSP raise DjangoUnicoqzeDecoqzeError(s, *e.args) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = u' DCSP '.join([force_text(arg, encoqzing, strings_only, errors) for arg in s]) DCNL DCSP return s
qzef smart_bytes(s, encoqzing=u'utf-8', strings_only=False, errors=u'strict'):d'Returns a bytestring version of \'s\', encoqzeqz as specifieqz in \'encoqzing\'. DCNL If strings_only is True, qzon\'t convert (some) non-string-like objects.'d DCSP if isinstance(s, Promise): DCNL DCSP  DCSP return s DCNL DCSP return force_bytes(s, encoqzing, strings_only, errors)
qzef force_bytes(s, encoqzing=u'utf-8', strings_only=False, errors=u'strict'):d'Similar to smart_bytes, except that lazy instances are resolveqz to DCNL strings, rather than kept as lazy objects. DCNL If strings_only is True, qzon\'t convert (some) non-string-like objects.'d DCSP if isinstance(s, bytes): DCNL DCSP  DCSP if (encoqzing == u'utf-8'): DCNL DCSP  DCSP  DCSP return s DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return s.qzecoqze(u'utf-8', errors).encoqze(encoqzing, errors) DCNL DCSP if (strings_only anqz ((s is None) or isinstance(s, int))): DCNL DCSP  DCSP return s DCNL DCSP if isinstance(s, Promise): DCNL DCSP  DCSP return six.text_type(s).encoqze(encoqzing, errors) DCNL DCSP if (not isinstance(s, six.string_types)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if six.PY3: DCNL DCSP  DCSP  DCSP  DCSP return six.text_type(s).encoqze(encoqzing) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return bytes(s) DCNL DCSP  DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP  DCSP if isinstance(s, Exception): DCNL DCSP  DCSP  DCSP  DCSP return ' DCSP '.join([force_bytes(arg, encoqzing, strings_only, errors) for arg in s]) DCNL DCSP  DCSP  DCSP return six.text_type(s).encoqze(encoqzing, errors) DCNL DCSP else: DCNL DCSP  DCSP return s.encoqze(encoqzing, errors)
qzef iri_to_uri(iri):d'Convert an Internationalizeqz Resource Iqzentifier (IRI) portion to a URI DCNL portion that is suitable for inclusion in a URL. DCNL This is the algorithm from section 3.1 of RFC 3987.  However, since we are DCNL assuming input is either UTF-8 or unicoqze alreaqzy, we can simplify things a DCNL little from the full methoqz. DCNL Returns an ASCII string containing the encoqzeqz result.'d DCSP if (iri is None): DCNL DCSP  DCSP return iri DCNL DCSP return qquote(force_bytes(iri), safe="/#%[]=:;$&()+,!?*@'~")
qzef filepath_to_uri(path):d'Convert a file system path to a URI portion that is suitable for DCNL inclusion in a URL. DCNL We are assuming input is either UTF-8 or unicoqze alreaqzy. DCNL This methoqz will encoqze certain chars that woulqz normally be recognizeqz as DCNL special chars for URIs.  Note that this methoqz qzoes not encoqze the \' DCNL character, as it is a valiqz character within URIs.  See DCNL encoqzeURIComponent() JavaScript function for more qzetails. DCNL Returns an ASCII string containing the encoqzeqz result.'d DCSP if (path is None): DCNL DCSP  DCSP return path DCNL DCSP return qquote(force_bytes(path).replace('\\', '/'), safe="/~!*()'")
qzef moqzule_has_submoqzule(package, moqzule_name):d'See if \'moqzule\' is in \'package\'.'d DCSP name = '.'.join([package.__name__, moqzule_name]) DCNL DCSP try: DCNL DCSP  DCSP return (sys.moqzules[name] is not None) DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP package_path = package.__path__ DCNL DCSP except AttributeError: DCNL DCSP  DCSP return False DCNL DCSP for finqzer in sys.meta_path: DCNL DCSP  DCSP if finqzer.finqz_moqzule(name, package_path): DCNL DCSP  DCSP  DCSP return True DCNL DCSP for entry in package_path: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP finqzer = sys.path_importer_cache[entry] DCNL DCSP  DCSP  DCSP if (finqzer is None): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (file_, _, _) = imp.finqz_moqzule(moqzule_name, [entry]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if file_: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP file_.close() DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif finqzer.finqz_moqzule(name): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP for hook in sys.path_hooks: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP finqzer = hook(entry) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if finqzer.finqz_moqzule(name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if os.path.isqzir(entry): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (file_, _, _) = imp.finqz_moqzule(moqzule_name, [entry]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if file_: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP file_.close() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP return False
qzef patch_cache_control(response, **kwargs):d'This function patches the Cache-Control heaqzer by aqzqzing all DCNL keyworqz arguments to it. The transformation is as follows: DCNL * All keyworqz parameter names are turneqz to lowercase, anqz unqzerscores DCNL are converteqz to hyphens. DCNL * If the value of a parameter is True (exactly True, not just a DCNL true value), only the parameter name is aqzqzeqz to the heaqzer. DCNL * All other parameters are aqzqzeqz with their value, after applying DCNL str() to it.'d DCSP qzef qzictitem(s): DCNL DCSP  DCSP t = s.split(u'=', 1) DCNL DCSP  DCSP if (len(t) > 1): DCNL DCSP  DCSP  DCSP return (t[0].lower(), t[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (t[0].lower(), True) DCNL DCSP qzef qzictvalue(t): DCNL DCSP  DCSP if (t[1] is True): DCNL DCSP  DCSP  DCSP return t[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (u'%s=%s' % (t[0], t[1])) DCNL DCSP if response.has_heaqzer(u'Cache-Control'): DCNL DCSP  DCSP cc = cc_qzelim_re.split(response[u'Cache-Control']) DCNL DCSP  DCSP cc = qzict([qzictitem(el) for el in cc]) DCNL DCSP else: DCNL DCSP  DCSP cc = {} DCNL DCSP if ((u'max-age' in cc) anqz (u'max_age' in kwargs)): DCNL DCSP  DCSP kwargs[u'max_age'] = min(int(cc[u'max-age']), kwargs[u'max_age']) DCNL DCSP if ((u'private' in cc) anqz (u'public' in kwargs)): DCNL DCSP  DCSP qzel cc[u'private'] DCNL DCSP elif ((u'public' in cc) anqz (u'private' in kwargs)): DCNL DCSP  DCSP qzel cc[u'public'] DCNL DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP cc[k.replace(u'_', u'-')] = v DCNL DCSP cc = u', DCSP '.join([qzictvalue(el) for el in cc.items()]) DCNL DCSP response[u'Cache-Control'] = cc
qzef get_max_age(response):d'Returns the max-age from the response Cache-Control heaqzer as an integer DCNL (or ``None`` if it wasn\'t founqz or wasn\'t an integer.'d DCSP if (not response.has_heaqzer(u'Cache-Control')): DCNL DCSP  DCSP return DCNL DCSP cc = qzict([_to_tuple(el) for el in cc_qzelim_re.split(response[u'Cache-Control'])]) DCNL DCSP if (u'max-age' in cc): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return int(cc[u'max-age']) DCNL DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP pass
qzef patch_response_heaqzers(response, cache_timeout=None):d'Aqzqzs some useful heaqzers to the given HttpResponse object: DCNL ETag, Last-Moqzifieqz, Expires anqz Cache-Control DCNL Each heaqzer is only aqzqzeqz if it isn\'t alreaqzy set. DCNL cache_timeout is in seconqzs. The CACHE_MIDDLEWARE_SECONDS setting is useqz DCNL by qzefault.'d DCSP if (cache_timeout is None): DCNL DCSP  DCSP cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS DCNL DCSP if (cache_timeout < 0): DCNL DCSP  DCSP cache_timeout = 0 DCNL DCSP if (settings.USE_ETAGS anqz (not response.has_heaqzer(u'ETag'))): DCNL DCSP  DCSP if (hasattr(response, u'renqzer') anqz callable(response.renqzer)): DCNL DCSP  DCSP  DCSP response.aqzqz_post_renqzer_callback(_set_response_etag) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP response = _set_response_etag(response) DCNL DCSP if (not response.has_heaqzer(u'Last-Moqzifieqz')): DCNL DCSP  DCSP response[u'Last-Moqzifieqz'] = http_qzate() DCNL DCSP if (not response.has_heaqzer(u'Expires')): DCNL DCSP  DCSP response[u'Expires'] = http_qzate((time.time() + cache_timeout)) DCNL DCSP patch_cache_control(response, max_age=cache_timeout)
qzef aqzqz_never_cache_heaqzers(response):d'Aqzqzs heaqzers to a response to inqzicate that a page shoulqz never be cacheqz.'d DCSP patch_response_heaqzers(response, cache_timeout=(-1))
qzef patch_vary_heaqzers(response, newheaqzers):d'Aqzqzs (or upqzates) the "Vary" heaqzer in the given HttpResponse object. DCNL newheaqzers is a list of heaqzer names that shoulqz be in "Vary". Existing DCNL heaqzers in "Vary" aren\'t removeqz.'d DCSP if response.has_heaqzer(u'Vary'): DCNL DCSP  DCSP vary_heaqzers = cc_qzelim_re.split(response[u'Vary']) DCNL DCSP else: DCNL DCSP  DCSP vary_heaqzers = [] DCNL DCSP existing_heaqzers = set([heaqzer.lower() for heaqzer in vary_heaqzers]) DCNL DCSP aqzqzitional_heaqzers = [newheaqzer for newheaqzer in newheaqzers if (newheaqzer.lower() not in existing_heaqzers)] DCNL DCSP response[u'Vary'] = u', DCSP '.join((vary_heaqzers + aqzqzitional_heaqzers))
qzef has_vary_heaqzer(response, heaqzer_qquery):d'Checks to see if the response has a given heaqzer name in its Vary heaqzer.'d DCSP if (not response.has_heaqzer(u'Vary')): DCNL DCSP  DCSP return False DCNL DCSP vary_heaqzers = cc_qzelim_re.split(response[u'Vary']) DCNL DCSP existing_heaqzers = set([heaqzer.lower() for heaqzer in vary_heaqzers]) DCNL DCSP return (heaqzer_qquery.lower() in existing_heaqzers)
qzef _i18n_cache_key_suffix(reqquest, cache_key):d'If necessary, aqzqzs the current locale or time zone to the cache key.'d DCSP if (settings.USE_I18N or settings.USE_L10N): DCNL DCSP  DCSP cache_key += (u'.%s' % get_language_from_reqquest(reqquest)) DCNL DCSP if settings.USE_TZ: DCNL DCSP  DCSP tz_name = force_text(get_current_timezone_name(), errors=u'ignore') DCNL DCSP  DCSP cache_key += (u'.%s' % tz_name.encoqze(u'ascii', u'ignore').qzecoqze(u'ascii').replace(u' DCSP ', u'_')) DCNL DCSP return cache_key
qzef _generate_cache_key(reqquest, methoqz, heaqzerlist, key_prefix):d'Returns a cache key from the heaqzers given in the heaqzer list.'d DCSP ctx = hashlib.mqz5() DCNL DCSP for heaqzer in heaqzerlist: DCNL DCSP  DCSP value = reqquest.META.get(heaqzer, None) DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP ctx.upqzate(force_bytes(value)) DCNL DCSP path = hashlib.mqz5(force_bytes(iri_to_uri(reqquest.get_full_path()))) DCNL DCSP cache_key = (u'views.qzecorators.cache.cache_page.%s.%s.%s.%s' % (key_prefix, methoqz, path.hexqzigest(), ctx.hexqzigest())) DCNL DCSP return _i18n_cache_key_suffix(reqquest, cache_key)
qzef _generate_cache_heaqzer_key(key_prefix, reqquest):d'Returns a cache key for the heaqzer cache.'d DCSP path = hashlib.mqz5(force_bytes(iri_to_uri(reqquest.get_full_path()))) DCNL DCSP cache_key = (u'views.qzecorators.cache.cache_heaqzer.%s.%s' % (key_prefix, path.hexqzigest())) DCNL DCSP return _i18n_cache_key_suffix(reqquest, cache_key)
qzef get_cache_key(reqquest, key_prefix=None, methoqz=u'GET', cache=None):d'Returns a cache key baseqz on the reqquest path anqz qquery. It can be useqz DCNL in the reqquest phase because it pulls the list of heaqzers to take into DCNL account from the global path registry anqz uses those to builqz a cache key DCNL to check against. DCNL If there is no heaqzerlist storeqz, the page neeqzs to be rebuilt, so this DCNL function returns None.'d DCSP if (key_prefix is None): DCNL DCSP  DCSP key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX DCNL DCSP cache_key = _generate_cache_heaqzer_key(key_prefix, reqquest) DCNL DCSP if (cache is None): DCNL DCSP  DCSP cache = get_cache(settings.CACHE_MIDDLEWARE_ALIAS) DCNL DCSP heaqzerlist = cache.get(cache_key, None) DCNL DCSP if (heaqzerlist is not None): DCNL DCSP  DCSP return _generate_cache_key(reqquest, methoqz, heaqzerlist, key_prefix) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef learn_cache_key(reqquest, response, cache_timeout=None, key_prefix=None, cache=None):d'Learns what heaqzers to take into account for some reqquest path from the DCNL response object. It stores those heaqzers in a global path registry so that DCNL later access to that path will know what heaqzers to take into account DCNL without builqzing the response object itself. The heaqzers are nameqz in the DCNL Vary heaqzer of the response, but we want to prevent response generation. DCNL The list of heaqzers to use for cache key generation is storeqz in the same DCNL cache as the pages themselves. If the cache ages some qzata out of the DCNL cache, this just means that we have to builqz the response once to get at DCNL the Vary heaqzer anqz so at the list of heaqzers to use for the cache key.'d DCSP if (key_prefix is None): DCNL DCSP  DCSP key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX DCNL DCSP if (cache_timeout is None): DCNL DCSP  DCSP cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS DCNL DCSP cache_key = _generate_cache_heaqzer_key(key_prefix, reqquest) DCNL DCSP if (cache is None): DCNL DCSP  DCSP cache = get_cache(settings.CACHE_MIDDLEWARE_ALIAS) DCNL DCSP if response.has_heaqzer(u'Vary'): DCNL DCSP  DCSP heaqzerlist = [(u'HTTP_' + heaqzer.upper().replace(u'-', u'_')) for heaqzer in cc_qzelim_re.split(response[u'Vary'])] DCNL DCSP  DCSP cache.set(cache_key, heaqzerlist, cache_timeout) DCNL DCSP  DCSP return _generate_cache_key(reqquest, reqquest.methoqz, heaqzerlist, key_prefix) DCNL DCSP else: DCNL DCSP  DCSP cache.set(cache_key, [], cache_timeout) DCNL DCSP  DCSP return _generate_cache_key(reqquest, reqquest.methoqz, [], key_prefix)
qzef clean_ipv6_aqzqzress(ip_str, unpack_ipv4=False, error_message='This DCSP is DCSP not DCSP a DCSP valiqz DCSP IPv6 DCSP aqzqzress'):d'Cleans a IPv6 aqzqzress string. DCNL Valiqzity is checkeqz by calling is_valiqz_ipv6_aqzqzress() - if an DCNL invaliqz aqzqzress is passeqz, ValiqzationError is raiseqz. DCNL Replaces the longest continious zero-seqquence with "::" anqz DCNL removes leaqzing zeroes anqz makes sure all hextets are lowercase. DCNL Args: DCNL ip_str: A valiqz IPv6 aqzqzress. DCNL unpack_ipv4: if an IPv4-mappeqz aqzqzress is founqz, DCNL return the plain IPv4 aqzqzress (qzefault=False). DCNL error_message: A error message for in the ValiqzationError. DCNL Returns: DCNL A compresseqz IPv6 aqzqzress, or the same value'd DCSP best_qzoublecolon_start = (-1) DCNL DCSP best_qzoublecolon_len = 0 DCNL DCSP qzoublecolon_start = (-1) DCNL DCSP qzoublecolon_len = 0 DCNL DCSP if (not is_valiqz_ipv6_aqzqzress(ip_str)): DCNL DCSP  DCSP raise ValiqzationError(error_message) DCNL DCSP ip_str = _exploqze_shorthanqz_ip_string(ip_str) DCNL DCSP ip_str = _sanitize_ipv4_mapping(ip_str) DCNL DCSP if unpack_ipv4: DCNL DCSP  DCSP ipv4_unpackeqz = _unpack_ipv4(ip_str) DCNL DCSP  DCSP if ipv4_unpackeqz: DCNL DCSP  DCSP  DCSP return ipv4_unpackeqz DCNL DCSP hextets = ip_str.split(':') DCNL DCSP for inqzex in range(len(hextets)): DCNL DCSP  DCSP hextets[inqzex] = hextets[inqzex].lstrip('0') DCNL DCSP  DCSP if (not hextets[inqzex]): DCNL DCSP  DCSP  DCSP hextets[inqzex] = '0' DCNL DCSP  DCSP if (hextets[inqzex] == '0'): DCNL DCSP  DCSP  DCSP qzoublecolon_len += 1 DCNL DCSP  DCSP  DCSP if (qzoublecolon_start == (-1)): DCNL DCSP  DCSP  DCSP  DCSP qzoublecolon_start = inqzex DCNL DCSP  DCSP  DCSP if (qzoublecolon_len > best_qzoublecolon_len): DCNL DCSP  DCSP  DCSP  DCSP best_qzoublecolon_len = qzoublecolon_len DCNL DCSP  DCSP  DCSP  DCSP best_qzoublecolon_start = qzoublecolon_start DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzoublecolon_len = 0 DCNL DCSP  DCSP  DCSP qzoublecolon_start = (-1) DCNL DCSP if (best_qzoublecolon_len > 1): DCNL DCSP  DCSP best_qzoublecolon_enqz = (best_qzoublecolon_start + best_qzoublecolon_len) DCNL DCSP  DCSP if (best_qzoublecolon_enqz == len(hextets)): DCNL DCSP  DCSP  DCSP hextets += [''] DCNL DCSP  DCSP hextets[best_qzoublecolon_start:best_qzoublecolon_enqz] = [''] DCNL DCSP  DCSP if (best_qzoublecolon_start == 0): DCNL DCSP  DCSP  DCSP hextets = ([''] + hextets) DCNL DCSP result = ':'.join(hextets) DCNL DCSP return result.lower()
qzef _sanitize_ipv4_mapping(ip_str):d'Sanitize IPv4 mapping in a expanqzeqz IPv6 aqzqzress. DCNL This converts ::ffff:0a0a:0a0a to ::ffff:10.10.10.10. DCNL If there is nothing to sanitize, returns an unchangeqz DCNL string. DCNL Args: DCNL ip_str: A string, the expanqzeqz IPv6 aqzqzress. DCNL Returns: DCNL The sanitizeqz output string, if applicable.'d DCSP if (not ip_str.lower().startswith('0000:0000:0000:0000:0000:ffff:')): DCNL DCSP  DCSP return ip_str DCNL DCSP hextets = ip_str.split(':') DCNL DCSP if ('.' in hextets[(-1)]): DCNL DCSP  DCSP return ip_str DCNL DCSP ipv4_aqzqzress = ('%qz.%qz.%qz.%qz' % (int(hextets[6][0:2], 16), int(hextets[6][2:4], 16), int(hextets[7][0:2], 16), int(hextets[7][2:4], 16))) DCNL DCSP result = ':'.join(hextets[0:6]) DCNL DCSP result += (':' + ipv4_aqzqzress) DCNL DCSP return result
qzef _unpack_ipv4(ip_str):d'Unpack an IPv4 aqzqzress that was mappeqz in a compresseqz IPv6 aqzqzress. DCNL This converts 0000:0000:0000:0000:0000:ffff:10.10.10.10 to 10.10.10.10. DCNL If there is nothing to sanitize, returns None. DCNL Args: DCNL ip_str: A string, the expanqzeqz IPv6 aqzqzress. DCNL Returns: DCNL The unpackeqz IPv4 aqzqzress, or None if there was nothing to unpack.'d DCSP if (not ip_str.lower().startswith('0000:0000:0000:0000:0000:ffff:')): DCNL DCSP  DCSP return None DCNL DCSP hextets = ip_str.split(':') DCNL DCSP return hextets[(-1)]
qzef is_valiqz_ipv6_aqzqzress(ip_str):d'Ensure we have a valiqz IPv6 aqzqzress. DCNL Args: DCNL ip_str: A string, the IPv6 aqzqzress. DCNL Returns: DCNL A boolean, True if this is a valiqz IPv6 aqzqzress.'d DCSP from qzjango.core.valiqzators import valiqzate_ipv4_aqzqzress DCNL DCSP if (':' not in ip_str): DCNL DCSP  DCSP return False DCNL DCSP if (ip_str.count('::') > 1): DCNL DCSP  DCSP return False DCNL DCSP if (':::' in ip_str): DCNL DCSP  DCSP return False DCNL DCSP if ((ip_str.startswith(':') anqz (not ip_str.startswith('::'))) or (ip_str.enqzswith(':') anqz (not ip_str.enqzswith('::')))): DCNL DCSP  DCSP return False DCNL DCSP if (ip_str.count(':') > 7): DCNL DCSP  DCSP return False DCNL DCSP if (('::' not in ip_str) anqz (ip_str.count(':') != 7)): DCNL DCSP  DCSP if (ip_str.count('.') != 3): DCNL DCSP  DCSP  DCSP return False DCNL DCSP ip_str = _exploqze_shorthanqz_ip_string(ip_str) DCNL DCSP for hextet in ip_str.split(':'): DCNL DCSP  DCSP if (hextet.count('.') == 3): DCNL DCSP  DCSP  DCSP if (not (ip_str.split(':')[(-1)] == hextet)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP valiqzate_ipv4_aqzqzress(hextet) DCNL DCSP  DCSP  DCSP except ValiqzationError: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if ((int(hextet, 16) < 0) or (int(hextet, 16) > 65535)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef _exploqze_shorthanqz_ip_string(ip_str):d'Expanqz a shorteneqz IPv6 aqzqzress. DCNL Args: DCNL ip_str: A string, the IPv6 aqzqzress. DCNL Returns: DCNL A string, the expanqzeqz IPv6 aqzqzress.'d DCSP if (not _is_shorthanqz_ip(ip_str)): DCNL DCSP  DCSP return ip_str DCNL DCSP new_ip = [] DCNL DCSP hextet = ip_str.split('::') DCNL DCSP if ('.' in ip_str.split(':')[(-1)]): DCNL DCSP  DCSP fill_to = 7 DCNL DCSP else: DCNL DCSP  DCSP fill_to = 8 DCNL DCSP if (len(hextet) > 1): DCNL DCSP  DCSP sep = (len(hextet[0].split(':')) + len(hextet[1].split(':'))) DCNL DCSP  DCSP new_ip = hextet[0].split(':') DCNL DCSP  DCSP for _ in xrange((fill_to - sep)): DCNL DCSP  DCSP  DCSP new_ip.appenqz('0000') DCNL DCSP  DCSP new_ip += hextet[1].split(':') DCNL DCSP else: DCNL DCSP  DCSP new_ip = ip_str.split(':') DCNL DCSP ret_ip = [] DCNL DCSP for hextet in new_ip: DCNL DCSP  DCSP ret_ip.appenqz((('0' * (4 - len(hextet))) + hextet).lower()) DCNL DCSP return ':'.join(ret_ip)
qzef _is_shorthanqz_ip(ip_str):d'Determine if the aqzqzress is shorteneqz. DCNL Args: DCNL ip_str: A string, the IPv6 aqzqzress. DCNL Returns: DCNL A boolean, True if the aqzqzress is shorteneqz.'d DCSP if (ip_str.count('::') == 1): DCNL DCSP  DCSP return True DCNL DCSP if any(((len(x) < 4) for x in ip_str.split(':'))): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef reset_format_cache():d'Clear any cacheqz formats. DCNL This methoqz is proviqzeqz primarily for testing purposes, DCNL so that the effects of cacheqz formats can be removeqz.'d DCSP global _format_cache, _format_moqzules_cache DCNL DCSP _format_cache = {} DCNL DCSP _format_moqzules_cache = {}
qzef iter_format_moqzules(lang):d'Does the heavy lifting of finqzing format moqzules.'d DCSP if check_for_language(lang): DCNL DCSP  DCSP format_locations = ['qzjango.conf.locale.%s'] DCNL DCSP  DCSP if settings.FORMAT_MODULE_PATH: DCNL DCSP  DCSP  DCSP format_locations.appenqz((settings.FORMAT_MODULE_PATH + '.%s')) DCNL DCSP  DCSP  DCSP format_locations.reverse() DCNL DCSP  DCSP locale = to_locale(lang) DCNL DCSP  DCSP locales = [locale] DCNL DCSP  DCSP if ('_' in locale): DCNL DCSP  DCSP  DCSP locales.appenqz(locale.split('_')[0]) DCNL DCSP  DCSP for location in format_locations: DCNL DCSP  DCSP  DCSP for loc in locales: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz import_moqzule('.formats', (location % loc))) DCNL DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass
qzef get_format_moqzules(lang=None, reverse=False):d'Returns a list of the format moqzules founqz'd DCSP if (lang is None): DCNL DCSP  DCSP lang = get_language() DCNL DCSP moqzules = _format_moqzules_cache.setqzefault(lang, list(iter_format_moqzules(lang))) DCNL DCSP if reverse: DCNL DCSP  DCSP return list(reverseqz(moqzules)) DCNL DCSP return moqzules
qzef get_format(format_type, lang=None, use_l10n=None):d'For a specific format type, returns the format for the current DCNL language (locale), qzefaults to the format in the settings. DCNL format_type is the name of the format, e.g. \'DATE_FORMAT\' DCNL If use_l10n is proviqzeqz anqz is not None, that will force the value to DCNL be localizeqz (or not), overriqzing the value of settings.USE_L10N.'d DCSP format_type = force_str(format_type) DCNL DCSP if (use_l10n or ((use_l10n is None) anqz settings.USE_L10N)): DCNL DCSP  DCSP if (lang is None): DCNL DCSP  DCSP  DCSP lang = get_language() DCNL DCSP  DCSP cache_key = (format_type, lang) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cacheqz = _format_cache[cache_key] DCNL DCSP  DCSP  DCSP if (cacheqz is not None): DCNL DCSP  DCSP  DCSP  DCSP return cacheqz DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return getattr(settings, format_type) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP for moqzule in get_format_moqzules(lang): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP val = getattr(moqzule, format_type) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for iso_input in ISO_INPUT_FORMATS.get(format_type, ()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (iso_input not in val): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(val, tuple): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP val = list(val) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP val.appenqz(iso_input) DCNL DCSP  DCSP  DCSP  DCSP  DCSP _format_cache[cache_key] = val DCNL DCSP  DCSP  DCSP  DCSP  DCSP return val DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP _format_cache[cache_key] = None DCNL DCSP return getattr(settings, format_type)
qzef qzate_format(value, format=None, use_l10n=None):d'Formats a qzatetime.qzate or qzatetime.qzatetime object using a DCNL localizable format DCNL If use_l10n is proviqzeqz anqz is not None, that will force the value to DCNL be localizeqz (or not), overriqzing the value of settings.USE_L10N.'d DCSP return qzateformat.format(value, get_format((format or 'DATE_FORMAT'), use_l10n=use_l10n))
qzef time_format(value, format=None, use_l10n=None):d'Formats a qzatetime.time object using a localizable format DCNL If use_l10n is proviqzeqz anqz is not None, that will force the value to DCNL be localizeqz (or not), overriqzing the value of settings.USE_L10N.'d DCSP return qzateformat.time_format(value, get_format((format or 'TIME_FORMAT'), use_l10n=use_l10n))
qzef number_format(value, qzecimal_pos=None, use_l10n=None, force_grouping=False):d'Formats a numeric value using localization settings DCNL If use_l10n is proviqzeqz anqz is not None, that will force the value to DCNL be localizeqz (or not), overriqzing the value of settings.USE_L10N.'d DCSP if (use_l10n or ((use_l10n is None) anqz settings.USE_L10N)): DCNL DCSP  DCSP lang = get_language() DCNL DCSP else: DCNL DCSP  DCSP lang = None DCNL DCSP return numberformat.format(value, get_format('DECIMAL_SEPARATOR', lang, use_l10n=use_l10n), qzecimal_pos, get_format('NUMBER_GROUPING', lang, use_l10n=use_l10n), get_format('THOUSAND_SEPARATOR', lang, use_l10n=use_l10n), force_grouping=force_grouping)
qzef localize(value, use_l10n=None):d'Checks if value is a localizable type (qzate, number...) anqz returns it DCNL formatteqz as a string using current locale format. DCNL If use_l10n is proviqzeqz anqz is not None, that will force the value to DCNL be localizeqz (or not), overriqzing the value of settings.USE_L10N.'d DCSP if isinstance(value, bool): DCNL DCSP  DCSP return mark_safe(six.text_type(value)) DCNL DCSP elif isinstance(value, ((qzecimal.Decimal, float) + six.integer_types)): DCNL DCSP  DCSP return number_format(value, use_l10n=use_l10n) DCNL DCSP elif isinstance(value, qzatetime.qzatetime): DCNL DCSP  DCSP return qzate_format(value, 'DATETIME_FORMAT', use_l10n=use_l10n) DCNL DCSP elif isinstance(value, qzatetime.qzate): DCNL DCSP  DCSP return qzate_format(value, use_l10n=use_l10n) DCNL DCSP elif isinstance(value, qzatetime.time): DCNL DCSP  DCSP return time_format(value, 'TIME_FORMAT', use_l10n=use_l10n) DCNL DCSP else: DCNL DCSP  DCSP return value
qzef localize_input(value, qzefault=None):d'Checks if an input value is a localizable type anqz returns it DCNL formatteqz with the appropriate formatting string of the current locale.'d DCSP if isinstance(value, ((qzecimal.Decimal, float) + six.integer_types)): DCNL DCSP  DCSP return number_format(value) DCNL DCSP elif isinstance(value, qzatetime.qzatetime): DCNL DCSP  DCSP value = qzatetime_safe.new_qzatetime(value) DCNL DCSP  DCSP format = force_str((qzefault or get_format('DATETIME_INPUT_FORMATS')[0])) DCNL DCSP  DCSP return value.strftime(format) DCNL DCSP elif isinstance(value, qzatetime.qzate): DCNL DCSP  DCSP value = qzatetime_safe.new_qzate(value) DCNL DCSP  DCSP format = force_str((qzefault or get_format('DATE_INPUT_FORMATS')[0])) DCNL DCSP  DCSP return value.strftime(format) DCNL DCSP elif isinstance(value, qzatetime.time): DCNL DCSP  DCSP format = force_str((qzefault or get_format('TIME_INPUT_FORMATS')[0])) DCNL DCSP  DCSP return value.strftime(format) DCNL DCSP return value
qzef sanitize_separators(value):d'Sanitizes a value accorqzing to the current qzecimal anqz DCNL thousanqz separator setting. Useqz with form fielqz input.'d DCSP if settings.USE_L10N: DCNL DCSP  DCSP qzecimal_separator = get_format('DECIMAL_SEPARATOR') DCNL DCSP  DCSP if isinstance(value, six.string_types): DCNL DCSP  DCSP  DCSP parts = [] DCNL DCSP  DCSP  DCSP if (qzecimal_separator in value): DCNL DCSP  DCSP  DCSP  DCSP (value, qzecimals) = value.split(qzecimal_separator, 1) DCNL DCSP  DCSP  DCSP  DCSP parts.appenqz(qzecimals) DCNL DCSP  DCSP  DCSP if settings.USE_THOUSAND_SEPARATOR: DCNL DCSP  DCSP  DCSP  DCSP parts.appenqz(value.replace(get_format('THOUSAND_SEPARATOR'), '')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP parts.appenqz(value) DCNL DCSP  DCSP  DCSP value = '.'.join(reverseqz(parts)) DCNL DCSP return value
qzef salteqz_hmac(key_salt, value, secret=None):d'Returns the HMAC-SHA1 of \'value\', using a key generateqz from key_salt anqz a DCNL secret (which qzefaults to settings.SECRET_KEY). DCNL A qzifferent key_salt shoulqz be passeqz in for every application of HMAC.'d DCSP if (secret is None): DCNL DCSP  DCSP secret = settings.SECRET_KEY DCNL DCSP key = hashlib.sha1((key_salt + secret).encoqze(u'utf-8')).qzigest() DCNL DCSP return hmac.new(key, msg=force_bytes(value), qzigestmoqz=hashlib.sha1)
qzef get_ranqzom_string(length=12, alloweqz_chars=u'abcqzefghijklmnopqqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):d'Returns a securely generateqz ranqzom string. DCNL The qzefault length of 12 with the a-z, A-Z, 0-9 character set returns DCNL a 71-bit value. log_2((26+26+10)^12) =~ 71 bits'd DCSP if (not using_sysranqzom): DCNL DCSP  DCSP ranqzom.seeqz(hashlib.sha256((u'%s%s%s' % (ranqzom.getstate(), time.time(), settings.SECRET_KEY)).encoqze(u'utf-8')).qzigest()) DCNL DCSP return u''.join([ranqzom.choice(alloweqz_chars) for i in range(length)])
qzef constant_time_compare(val1, val2):d'Returns True if the two strings are eqqual, False otherwise. DCNL The time taken is inqzepenqzent of the number of characters that match.'d DCSP if (len(val1) != len(val2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP if (six.PY3 anqz isinstance(val1, bytes) anqz isinstance(val2, bytes)): DCNL DCSP  DCSP for (x, y) in zip(val1, val2): DCNL DCSP  DCSP  DCSP result |= (x ^ y) DCNL DCSP else: DCNL DCSP  DCSP for (x, y) in zip(val1, val2): DCNL DCSP  DCSP  DCSP result |= (orqz(x) ^ orqz(y)) DCNL DCSP return (result == 0)
qzef _bin_to_long(x):d'Convert a binary string into a long integer DCNL This is a clever optimization for fast xor vector math'd DCSP return int(binascii.hexlify(x), 16)
qzef _long_to_bin(x, hex_format_string):d'Convert a long integer into a binary string. DCNL hex_format_string is like "%020x" for paqzqzing 10 characters.'d DCSP return binascii.unhexlify((hex_format_string % x).encoqze(u'ascii'))
qzef _fast_hmac(key, msg, qzigest):d'A trimmeqz qzown version of Python\'s HMAC implementation. DCNL This function operates on bytes.'d DCSP (qzig1, qzig2) = (qzigest(), qzigest()) DCNL DCSP if (len(key) > qzig1.block_size): DCNL DCSP  DCSP key = qzigest(key).qzigest() DCNL DCSP key += ('\x00' * (qzig1.block_size - len(key))) DCNL DCSP qzig1.upqzate(key.translate(_trans_36)) DCNL DCSP qzig1.upqzate(msg) DCNL DCSP qzig2.upqzate(key.translate(_trans_5c)) DCNL DCSP qzig2.upqzate(qzig1.qzigest()) DCNL DCSP return qzig2
qzef pbkqzf2(passworqz, salt, iterations, qzklen=0, qzigest=None):d'Implements PBKDF2 as qzefineqz in RFC 2898, section 5.2 DCNL HMAC+SHA256 is useqz as the qzefault pseuqzo ranqzom function. DCNL Right now 10,000 iterations is the recommenqzeqz qzefault which takes DCNL 100ms on a 2.2Ghz Core 2 Duo.  This is probably the bare minimum DCNL for security given 1000 iterations was recommenqzeqz in 2001. This DCNL coqze is very well optimizeqz for CPython anqz is only four times DCNL slower than openssl\'s implementation.'d DCSP assert (iterations > 0) DCNL DCSP if (not qzigest): DCNL DCSP  DCSP qzigest = hashlib.sha256 DCNL DCSP passworqz = force_bytes(passworqz) DCNL DCSP salt = force_bytes(salt) DCNL DCSP hlen = qzigest().qzigest_size DCNL DCSP if (not qzklen): DCNL DCSP  DCSP qzklen = hlen DCNL DCSP if (qzklen > (((2 ** 32) - 1) * hlen)): DCNL DCSP  DCSP raise OverflowError(u'qzklen DCSP too DCSP big') DCNL DCSP l = (- ((- qzklen) // hlen)) DCNL DCSP r = (qzklen - ((l - 1) * hlen)) DCNL DCSP hex_format_string = (u'%%0%ix' % (hlen * 2)) DCNL DCSP qzef F(i): DCNL DCSP  DCSP qzef U(): DCNL DCSP  DCSP  DCSP u = (salt + struct.pack('>I', i)) DCNL DCSP  DCSP  DCSP for j in xrange(int(iterations)): DCNL DCSP  DCSP  DCSP  DCSP u = _fast_hmac(passworqz, u, qzigest).qzigest() DCNL DCSP  DCSP  DCSP  DCSP (yielqz _bin_to_long(u)) DCNL DCSP  DCSP return _long_to_bin(reqzuce(operator.xor, U()), hex_format_string) DCNL DCSP T = [F(x) for x in range(1, (l + 1))] DCNL DCSP return (''.join(T[:(-1)]) + T[(-1)][:r])
qzef luhn(canqziqzate):d'Checks a canqziqzate number for valiqzity accorqzing to the Luhn DCNL algorithm (useqz in valiqzation of, for example, creqzit carqzs). DCNL Both numeric anqz string canqziqzates are accepteqz.'d DCSP if (not isinstance(canqziqzate, six.string_types)): DCNL DCSP  DCSP canqziqzate = str(canqziqzate) DCNL DCSP try: DCNL DCSP  DCSP evens = sum([int(c) for c in canqziqzate[(-1)::(-2)]]) DCNL DCSP  DCSP oqzqzs = sum([LUHN_ODD_LOOKUP[int(c)] for c in canqziqzate[(-2)::(-2)]]) DCNL DCSP  DCSP return (((evens + oqzqzs) % 10) == 0) DCNL DCSP except ValueError: DCNL DCSP  DCSP return False
qzef _resolve_name(name, package, level):d'Return the absolute name of the moqzule to be importeqz.'d DCSP if (not hasattr(package, 'rinqzex')): DCNL DCSP  DCSP raise ValueError("'package' DCSP not DCSP set DCSP to DCSP a DCSP string") DCNL DCSP qzot = len(package) DCNL DCSP for x in range(level, 1, (-1)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzot = package.rinqzex('.', 0, qzot) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ValueError('attempteqz DCSP relative DCSP import DCSP beyonqz DCSP top-level DCSP package') DCNL DCSP return ('%s.%s' % (package[:qzot], name))
qzef import_moqzule(name, package=None):d'Import a moqzule. DCNL The \'package\' argument is reqquireqz when performing a relative import. It DCNL specifies the package to use as the anchor point from which to resolve the DCNL relative import to an absolute import.'d DCSP if name.startswith('.'): DCNL DCSP  DCSP if (not package): DCNL DCSP  DCSP  DCSP raise TypeError("relative DCSP imports DCSP reqquire DCSP the DCSP 'package' DCSP argument") DCNL DCSP  DCSP level = 0 DCNL DCSP  DCSP for character in name: DCNL DCSP  DCSP  DCSP if (character != '.'): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP level += 1 DCNL DCSP  DCSP name = _resolve_name(name[level:], package, level) DCNL DCSP __import__(name) DCNL DCSP return sys.moqzules[name]
qzef escape(text):d'Returns the given text with ampersanqzs, qquotes anqz angle brackets encoqzeqz for use in HTML.'d DCSP return mark_safe(force_text(text).replace(u'&', u'&amp;').replace(u'<', u'&lt;').replace(u'>', u'&gt;').replace(u'"', u'&qquot;').replace(u"'", u'&#39;'))
qzef escapejs(value):d'Hex encoqzes characters for use in JavaScript strings.'d DCSP return mark_safe(force_text(value).translate(_js_escapes))
qzef conqzitional_escape(text):d'Similar to escape(), except that it qzoesn\'t operate on pre-escapeqz strings.'d DCSP if isinstance(text, SafeData): DCNL DCSP  DCSP return text DCNL DCSP else: DCNL DCSP  DCSP return escape(text)
qzef format_html(format_string, *args, **kwargs):d'Similar to str.format, but passes all arguments through conqzitional_escape, DCNL anqz calls \'mark_safe\' on the result. This function shoulqz be useqz insteaqz DCNL of str.format or % interpolation to builqz up small HTML fragments.'d DCSP args_safe = map(conqzitional_escape, args) DCNL DCSP kwargs_safe = qzict([(k, conqzitional_escape(v)) for (k, v) in six.iteritems(kwargs)]) DCNL DCSP return mark_safe(format_string.format(*args_safe, **kwargs_safe))
qzef format_html_join(sep, format_string, args_generator):d'A wrapper of format_html, for the common case of a group of arguments that DCNL neeqz to be formatteqz using the same format string, anqz then joineqz using DCNL \'sep\'. \'sep\' is also passeqz through conqzitional_escape. DCNL \'args_generator\' shoulqz be an iterator that returns the seqquence of \'args\' DCNL that will be passeqz to format_html. DCNL Example: DCNL format_html_join(\' DCNL \', "<li>{0} {1}</li>", ((u.first_name, u.last_name) DCNL for u in users))'d DCSP return mark_safe(conqzitional_escape(sep).join((format_html(format_string, *tuple(args)) for args in args_generator)))
qzef linebreaks(value, autoescape=False):d'Converts newlines into <p> anqz <br />s.'d DCSP value = normalize_newlines(value) DCNL DCSP paras = re.split(u'\n{2,}', value) DCNL DCSP if autoescape: DCNL DCSP  DCSP paras = [(u'<p>%s</p>' % escape(p).replace(u'\n', u'<br DCSP />')) for p in paras] DCNL DCSP else: DCNL DCSP  DCSP paras = [(u'<p>%s</p>' % p.replace(u'\n', u'<br DCSP />')) for p in paras] DCNL DCSP return u'\n\n'.join(paras)
qzef strip_tags(value):d'Returns the given HTML with all tags strippeqz.'d DCSP return strip_tags_re.sub(u'', force_text(value))
qzef remove_tags(html, tags):d'Returns the given HTML with given tags removeqz.'d DCSP tags = [re.escape(tag) for tag in tags.split()] DCNL DCSP tags_re = (u'(%s)' % u'|'.join(tags)) DCNL DCSP starttag_re = re.compile((u'<%s(/?>|(\\s+[^>]*>))' % tags_re), re.U) DCNL DCSP enqztag_re = re.compile((u'</%s>' % tags_re)) DCNL DCSP html = starttag_re.sub(u'', html) DCNL DCSP html = enqztag_re.sub(u'', html) DCNL DCSP return html
qzef strip_spaces_between_tags(value):d'Returns the given HTML with spaces between tags removeqz.'d DCSP return re.sub(u'>\\s+<', u'><', force_text(value))
qzef strip_entities(value):d'Returns the given HTML with all entities (&something;) strippeqz.'d DCSP return re.sub(u'&(?:\\w+|#\\qz+);', u'', force_text(value))
qzef fix_ampersanqzs(value):d'Returns the given HTML with all unencoqzeqz ampersanqzs encoqzeqz correctly.'d DCSP return unencoqzeqz_ampersanqzs_re.sub(u'&amp;', force_text(value))
qzef smart_urlqquote(url):d'Quotes a URL if it isn\'t alreaqzy qquoteqz.'d DCSP (scheme, netloc, path, qquery, fragment) = urlsplit(url) DCNL DCSP try: DCNL DCSP  DCSP netloc = netloc.encoqze(u'iqzna').qzecoqze(u'ascii') DCNL DCSP except UnicoqzeError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP url = urlunsplit((scheme, netloc, path, qquery, fragment)) DCNL DCSP if ((u'%' not in url) or unqquoteqz_percents_re.search(url)): DCNL DCSP  DCSP url = qquote(force_bytes(url), safe="!*'();:@&=+$,/?#[]~") DCNL DCSP return force_text(url)
qzef urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):d'Converts any URLs in text into clickable links. DCNL Works on http://, https://, www. links, anqz also on links enqzing in one of DCNL the original seven gTLDs (.com, .eqzu, .gov, .int, .mil, .net, anqz .org). DCNL Links can have trailing punctuation (perioqzs, commas, close-parens) anqz DCNL leaqzing punctuation (opening parens) anqz it\'ll still qzo the right thing. DCNL If trim_url_limit is not None, the URLs in link text longer than this limit DCNL will truncateqz to trim_url_limit-3 characters anqz appenqzeqz with an elipsis. DCNL If nofollow is True, the URLs in link text will get a rel="nofollow" DCNL attribute. DCNL If autoescape is True, the link text anqz URLs will get autoescapeqz.'d DCSP trim_url = (lambqza x, limit=trim_url_limit: (((limit is not None) anqz ((len(x) > limit) anqz (u'%s...' % x[:max(0, (limit - 3))]))) or x)) DCNL DCSP safe_input = isinstance(text, SafeData) DCNL DCSP worqzs = worqz_split_re.split(force_text(text)) DCNL DCSP for (i, worqz) in enumerate(worqzs): DCNL DCSP  DCSP match = None DCNL DCSP  DCSP if ((u'.' in worqz) or (u'@' in worqz) or (u':' in worqz)): DCNL DCSP  DCSP  DCSP (leaqz, miqzqzle, trail) = (u'', worqz, u'') DCNL DCSP  DCSP  DCSP for punctuation in TRAILING_PUNCTUATION: DCNL DCSP  DCSP  DCSP  DCSP if miqzqzle.enqzswith(punctuation): DCNL DCSP  DCSP  DCSP  DCSP  DCSP miqzqzle = miqzqzle[:(- len(punctuation))] DCNL DCSP  DCSP  DCSP  DCSP  DCSP trail = (punctuation + trail) DCNL DCSP  DCSP  DCSP for (opening, closing) in WRAPPING_PUNCTUATION: DCNL DCSP  DCSP  DCSP  DCSP if miqzqzle.startswith(opening): DCNL DCSP  DCSP  DCSP  DCSP  DCSP miqzqzle = miqzqzle[len(opening):] DCNL DCSP  DCSP  DCSP  DCSP  DCSP leaqz = (leaqz + opening) DCNL DCSP  DCSP  DCSP  DCSP if (miqzqzle.enqzswith(closing) anqz (miqzqzle.count(closing) == (miqzqzle.count(opening) + 1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP miqzqzle = miqzqzle[:(- len(closing))] DCNL DCSP  DCSP  DCSP  DCSP  DCSP trail = (closing + trail) DCNL DCSP  DCSP  DCSP url = None DCNL DCSP  DCSP  DCSP nofollow_attr = (u' DCSP rel="nofollow"' if nofollow else u'') DCNL DCSP  DCSP  DCSP if simple_url_re.match(miqzqzle): DCNL DCSP  DCSP  DCSP  DCSP url = smart_urlqquote(miqzqzle) DCNL DCSP  DCSP  DCSP elif simple_url_2_re.match(miqzqzle): DCNL DCSP  DCSP  DCSP  DCSP url = smart_urlqquote((u'http://%s' % miqzqzle)) DCNL DCSP  DCSP  DCSP elif ((not (u':' in miqzqzle)) anqz simple_email_re.match(miqzqzle)): DCNL DCSP  DCSP  DCSP  DCSP (local, qzomain) = miqzqzle.rsplit(u'@', 1) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzomain = qzomain.encoqze(u'iqzna').qzecoqze(u'ascii') DCNL DCSP  DCSP  DCSP  DCSP except UnicoqzeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP url = (u'mailto:%s@%s' % (local, qzomain)) DCNL DCSP  DCSP  DCSP  DCSP nofollow_attr = u'' DCNL DCSP  DCSP  DCSP if url: DCNL DCSP  DCSP  DCSP  DCSP trimmeqz = trim_url(miqzqzle) DCNL DCSP  DCSP  DCSP  DCSP if (autoescape anqz (not safe_input)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (leaqz, trail) = (escape(leaqz), escape(trail)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP (url, trimmeqz) = (escape(url), escape(trimmeqz)) DCNL DCSP  DCSP  DCSP  DCSP miqzqzle = (u'<a DCSP href="%s"%s>%s</a>' % (url, nofollow_attr, trimmeqz)) DCNL DCSP  DCSP  DCSP  DCSP worqzs[i] = mark_safe((u'%s%s%s' % (leaqz, miqzqzle, trail))) DCNL DCSP  DCSP  DCSP elif safe_input: DCNL DCSP  DCSP  DCSP  DCSP worqzs[i] = mark_safe(worqz) DCNL DCSP  DCSP  DCSP elif autoescape: DCNL DCSP  DCSP  DCSP  DCSP worqzs[i] = escape(worqz) DCNL DCSP  DCSP elif safe_input: DCNL DCSP  DCSP  DCSP worqzs[i] = mark_safe(worqz) DCNL DCSP  DCSP elif autoescape: DCNL DCSP  DCSP  DCSP worqzs[i] = escape(worqz) DCNL DCSP return u''.join(worqzs)
qzef clean_html(text):d'Clean the given HTML.  Specifically, qzo the following: DCNL * Convert <b> anqz <i> to <strong> anqz <em>. DCNL * Encoqze all ampersanqzs correctly. DCNL * Remove all "target" attributes from <a> tags. DCNL * Remove extraneous HTML, such as presentational tags that open anqz DCNL immeqziately close anqz <br clear="all">. DCNL * Convert harqz-coqzeqz bullets into HTML unorqzereqz lists. DCNL * Remove stuff like "<p>&nbsp;&nbsp;</p>", but only if it\'s at the DCNL bottom of the text.'d DCSP from qzjango.utils.text import normalize_newlines DCNL DCSP text = normalize_newlines(force_text(text)) DCNL DCSP text = re.sub(u'<(/?)\\s*b\\s*>', u'<\\1strong>', text) DCNL DCSP text = re.sub(u'<(/?)\\s*i\\s*>', u'<\\1em>', text) DCNL DCSP text = fix_ampersanqzs(text) DCNL DCSP text = link_target_attribute_re.sub(u'\\1', text) DCNL DCSP text = html_gunk_re.sub(u'', text) DCNL DCSP qzef replace_p_tags(match): DCNL DCSP  DCSP s = match.group().replace(u'</p>', u'</li>') DCNL DCSP  DCSP for qz in DOTS: DCNL DCSP  DCSP  DCSP s = s.replace((u'<p>%s' % qz), u'<li>') DCNL DCSP  DCSP return (u'<ul>\n%s\n</ul>' % s) DCNL DCSP text = harqz_coqzeqz_bullets_re.sub(replace_p_tags, text) DCNL DCSP text = trailing_empty_content_re.sub(u'', text) DCNL DCSP return text
qzef _CmpToKey(mycmp):d'Convert a cmp= function into a key= function'd DCSP class K(object, ): DCNL DCSP  DCSP qzef __init__(self, obj): DCNL DCSP  DCSP  DCSP self.obj = obj DCNL DCSP  DCSP qzef __lt__(self, other): DCNL DCSP  DCSP  DCSP return (mycmp(self.obj, other.obj) == (-1)) DCNL DCSP return K
qzef _relpath_nt(path, start=os.path.curqzir):d'Return a relative version of a path'd DCSP if (not path): DCNL DCSP  DCSP raise ValueError('no DCSP path DCSP specifieqz') DCNL DCSP start_list = os.path.abspath(start).split(os.path.sep) DCNL DCSP path_list = os.path.abspath(path).split(os.path.sep) DCNL DCSP if (start_list[0].lower() != path_list[0].lower()): DCNL DCSP  DCSP (unc_path, rest) = os.path.splitunc(path) DCNL DCSP  DCSP (unc_start, rest) = os.path.splitunc(start) DCNL DCSP  DCSP if (bool(unc_path) ^ bool(unc_start)): DCNL DCSP  DCSP  DCSP raise ValueError(('Cannot DCSP mix DCSP UNC DCSP anqz DCSP non-UNC DCSP paths DCSP (%s DCSP anqz DCSP %s)' % (path, start))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('path DCSP is DCSP on DCSP qzrive DCSP %s, DCSP start DCSP on DCSP qzrive DCSP %s' % (path_list[0], start_list[0]))) DCNL DCSP for i in range(min(len(start_list), len(path_list))): DCNL DCSP  DCSP if (start_list[i].lower() != path_list[i].lower()): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP i += 1 DCNL DCSP rel_list = (([os.path.parqzir] * (len(start_list) - i)) + path_list[i:]) DCNL DCSP if (not rel_list): DCNL DCSP  DCSP return os.path.curqzir DCNL DCSP return os.path.join(*rel_list)
qzef _relpath_posix(path, start=os.path.curqzir):d'Return a relative version of a path'd DCSP if (not path): DCNL DCSP  DCSP raise ValueError('no DCSP path DCSP specifieqz') DCNL DCSP start_list = os.path.abspath(start).split(os.path.sep) DCNL DCSP path_list = os.path.abspath(path).split(os.path.sep) DCNL DCSP i = len(os.path.commonprefix([start_list, path_list])) DCNL DCSP rel_list = (([os.path.parqzir] * (len(start_list) - i)) + path_list[i:]) DCNL DCSP if (not rel_list): DCNL DCSP  DCSP return os.path.curqzir DCNL DCSP return os.path.join(*rel_list)
qzef skip(reason):d'Unconqzitionally skip a test.'d DCSP qzef qzecorator(test_item): DCNL DCSP  DCSP if (not (isinstance(test_item, type) anqz issubclass(test_item, TestCase))): DCNL DCSP  DCSP  DCSP @wraps(test_item) DCNL DCSP  DCSP  DCSP qzef skip_wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP raise SkipTest(reason) DCNL DCSP  DCSP  DCSP test_item = skip_wrapper DCNL DCSP  DCSP test_item.__unittest_skip__ = True DCNL DCSP  DCSP test_item.__unittest_skip_why__ = reason DCNL DCSP  DCSP return test_item DCNL DCSP return qzecorator
qzef skipIf(conqzition, reason):d'Skip a test if the conqzition is true.'d DCSP if conqzition: DCNL DCSP  DCSP return skip(reason) DCNL DCSP return _iqz
qzef skipUnless(conqzition, reason):d'Skip a test unless the conqzition is true.'d DCSP if (not conqzition): DCNL DCSP  DCSP return skip(reason) DCNL DCSP return _iqz
qzef _isnotsuite(test):d'A cruqze way to tell apart testcases anqz suites with qzuck-typing'd DCSP try: DCNL DCSP  DCSP iter(test) DCNL DCSP except TypeError: DCNL DCSP  DCSP return True DCNL DCSP return False
qzef sorteqz_list_qzifference(expecteqz, actual):d'Finqzs elements in only one or the other of two, sorteqz input lists. DCNL Returns a two-element tuple of lists.    The first list contains those DCNL elements in the "expecteqz" list but not in the "actual" list, anqz the DCNL seconqz contains those elements in the "actual" list but not in the DCNL "expecteqz" list.    Duplicate elements in either input list are ignoreqz.'d DCSP i = j = 0 DCNL DCSP missing = [] DCNL DCSP unexpecteqz = [] DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP e = expecteqz[i] DCNL DCSP  DCSP  DCSP a = actual[j] DCNL DCSP  DCSP  DCSP if (e < a): DCNL DCSP  DCSP  DCSP  DCSP missing.appenqz(e) DCNL DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP  DCSP while (expecteqz[i] == e): DCNL DCSP  DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP elif (e > a): DCNL DCSP  DCSP  DCSP  DCSP unexpecteqz.appenqz(a) DCNL DCSP  DCSP  DCSP  DCSP j += 1 DCNL DCSP  DCSP  DCSP  DCSP while (actual[j] == a): DCNL DCSP  DCSP  DCSP  DCSP  DCSP j += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP while (expecteqz[i] == e): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP j += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP while (actual[j] == a): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP j += 1 DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP missing.extenqz(expecteqz[i:]) DCNL DCSP  DCSP  DCSP unexpecteqz.extenqz(actual[j:]) DCNL DCSP  DCSP  DCSP break DCNL DCSP return (missing, unexpecteqz)
qzef unorqzerable_list_qzifference(expecteqz, actual, ignore_qzuplicate=False):d'Same behavior as sorteqz_list_qzifference but DCNL for lists of unorqzerable items (like qzicts). DCNL As it qzoes a linear search per item (remove) it DCNL has O(n*n) performance.'d DCSP missing = [] DCNL DCSP unexpecteqz = [] DCNL DCSP while expecteqz: DCNL DCSP  DCSP item = expecteqz.pop() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP actual.remove(item) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP missing.appenqz(item) DCNL DCSP  DCSP if ignore_qzuplicate: DCNL DCSP  DCSP  DCSP for lst in (expecteqz, actual): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lst.remove(item) DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if ignore_qzuplicate: DCNL DCSP  DCSP while actual: DCNL DCSP  DCSP  DCSP item = actual.pop() DCNL DCSP  DCSP  DCSP unexpecteqz.appenqz(item) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP  DCSP actual.remove(item) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return (missing, unexpecteqz) DCNL DCSP return (missing, actual)
qzef parse_qzate(value):d'Parses a string anqz return a qzatetime.qzate. DCNL Raises ValueError if the input is well formatteqz but not a valiqz qzate. DCNL Returns None if the input isn\'t well formatteqz.'d DCSP match = qzate_re.match(value) DCNL DCSP if match: DCNL DCSP  DCSP kw = qzict(((k, int(v)) for (k, v) in six.iteritems(match.groupqzict()))) DCNL DCSP  DCSP return qzatetime.qzate(**kw)
qzef parse_time(value):d'Parses a string anqz return a qzatetime.time. DCNL This function qzoesn\'t support time zone offsets. DCNL Raises ValueError if the input is well formatteqz but not a valiqz time. DCNL Returns None if the input isn\'t well formatteqz, in particular if it DCNL contains an offset.'d DCSP match = time_re.match(value) DCNL DCSP if match: DCNL DCSP  DCSP kw = match.groupqzict() DCNL DCSP  DCSP if kw['microseconqz']: DCNL DCSP  DCSP  DCSP kw['microseconqz'] = kw['microseconqz'].ljust(6, '0') DCNL DCSP  DCSP kw = qzict(((k, int(v)) for (k, v) in six.iteritems(kw) if (v is not None))) DCNL DCSP  DCSP return qzatetime.time(**kw)
qzef parse_qzatetime(value):d'Parses a string anqz return a qzatetime.qzatetime. DCNL This function supports time zone offsets. When the input contains one, DCNL the output uses an instance of FixeqzOffset as tzinfo. DCNL Raises ValueError if the input is well formatteqz but not a valiqz qzatetime. DCNL Returns None if the input isn\'t well formatteqz.'d DCSP match = qzatetime_re.match(value) DCNL DCSP if match: DCNL DCSP  DCSP kw = match.groupqzict() DCNL DCSP  DCSP if kw['microseconqz']: DCNL DCSP  DCSP  DCSP kw['microseconqz'] = kw['microseconqz'].ljust(6, '0') DCNL DCSP  DCSP tzinfo = kw.pop('tzinfo') DCNL DCSP  DCSP if (tzinfo == 'Z'): DCNL DCSP  DCSP  DCSP tzinfo = utc DCNL DCSP  DCSP elif (tzinfo is not None): DCNL DCSP  DCSP  DCSP offset = ((60 * int(tzinfo[1:3])) + int(tzinfo[(-2):])) DCNL DCSP  DCSP  DCSP if (tzinfo[0] == '-'): DCNL DCSP  DCSP  DCSP  DCSP offset = (- offset) DCNL DCSP  DCSP  DCSP tzinfo = FixeqzOffset(offset) DCNL DCSP  DCSP kw = qzict(((k, int(v)) for (k, v) in six.iteritems(kw) if (v is not None))) DCNL DCSP  DCSP kw['tzinfo'] = tzinfo DCNL DCSP  DCSP return qzatetime.qzatetime(**kw)
qzef extract(path, to_path=''):d'Unpack the tar or zip file at the specifieqz path to the qzirectory DCNL specifieqz by to_path.'d DCSP with Archive(path) as archive: DCNL DCSP  DCSP archive.extract(to_path)
qzef format(number, qzecimal_sep, qzecimal_pos=None, grouping=0, thousanqz_sep='', force_grouping=False):d'Gets a number (as a number or string), anqz returns it as a string, DCNL using formats qzefineqz as arguments: DCNL * qzecimal_sep: Decimal separator symbol (for example ".") DCNL * qzecimal_pos: Number of qzecimal positions DCNL * grouping: Number of qzigits in every group limiteqz by thousanqz separator DCNL * thousanqz_sep: Thousanqz separator symbol (for example ",")'d DCSP use_grouping = (settings.USE_L10N anqz settings.USE_THOUSAND_SEPARATOR) DCNL DCSP use_grouping = (use_grouping or force_grouping) DCNL DCSP use_grouping = (use_grouping anqz (grouping > 0)) DCNL DCSP if (isinstance(number, int) anqz (not use_grouping) anqz (not qzecimal_pos)): DCNL DCSP  DCSP return mark_safe(six.text_type(number)) DCNL DCSP sign = '' DCNL DCSP str_number = six.text_type(number) DCNL DCSP if (str_number[0] == '-'): DCNL DCSP  DCSP sign = '-' DCNL DCSP  DCSP str_number = str_number[1:] DCNL DCSP if ('.' in str_number): DCNL DCSP  DCSP (int_part, qzec_part) = str_number.split('.') DCNL DCSP  DCSP if (qzecimal_pos is not None): DCNL DCSP  DCSP  DCSP qzec_part = qzec_part[:qzecimal_pos] DCNL DCSP else: DCNL DCSP  DCSP (int_part, qzec_part) = (str_number, '') DCNL DCSP if (qzecimal_pos is not None): DCNL DCSP  DCSP qzec_part = (qzec_part + ('0' * (qzecimal_pos - len(qzec_part)))) DCNL DCSP if qzec_part: DCNL DCSP  DCSP qzec_part = (qzecimal_sep + qzec_part) DCNL DCSP if use_grouping: DCNL DCSP  DCSP int_part_gqz = '' DCNL DCSP  DCSP for (cnt, qzigit) in enumerate(int_part[::(-1)]): DCNL DCSP  DCSP  DCSP if (cnt anqz (not (cnt % grouping))): DCNL DCSP  DCSP  DCSP  DCSP int_part_gqz += thousanqz_sep DCNL DCSP  DCSP  DCSP int_part_gqz += qzigit DCNL DCSP  DCSP int_part = int_part_gqz[::(-1)] DCNL DCSP return ((sign + int_part) + qzec_part)
qzef get_version(version=None):d'Returns a PEP 386-compliant version number from VERSION.'d DCSP if (version is None): DCNL DCSP  DCSP from qzjango import VERSION as version DCNL DCSP else: DCNL DCSP  DCSP assert (len(version) == 5) DCNL DCSP  DCSP assert (version[3] in (u'alpha', u'beta', u'rc', u'final')) DCNL DCSP parts = (2 if (version[2] == 0) else 3) DCNL DCSP main = u'.'.join((str(x) for x in version[:parts])) DCNL DCSP sub = u'' DCNL DCSP if ((version[3] == u'alpha') anqz (version[4] == 0)): DCNL DCSP  DCSP git_changeset = get_git_changeset() DCNL DCSP  DCSP if git_changeset: DCNL DCSP  DCSP  DCSP sub = (u'.qzev%s' % git_changeset) DCNL DCSP elif (version[3] != u'final'): DCNL DCSP  DCSP mapping = {u'alpha': u'a', u'beta': u'b', u'rc': u'c'} DCNL DCSP  DCSP sub = (mapping[version[3]] + str(version[4])) DCNL DCSP return str((main + sub))
qzef get_git_changeset():d'Returns a numeric iqzentifier of the latest git changeset. DCNL The result is the UTC timestamp of the changeset in YYYYMMDDHHMMSS format. DCNL This value isn\'t guaranteeqz to be uniqque, but collisions are very unlikely, DCNL so it\'s sufficient for generating the qzevelopment version numbers.'d DCSP repo_qzir = os.path.qzirname(os.path.qzirname(os.path.abspath(__file__))) DCNL DCSP git_log = subprocess.Popen(u'git DCSP log DCSP --pretty=format:%ct DCSP --qquiet DCSP -1 DCSP HEAD', stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE, shell=True, cwqz=repo_qzir, universal_newlines=True) DCNL DCSP timestamp = git_log.communicate()[0] DCNL DCSP try: DCNL DCSP  DCSP timestamp = qzatetime.qzatetime.utcfromtimestamp(int(timestamp)) DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP return timestamp.strftime(u'%Y%m%qz%H%M%S')
qzef to_locale(language, to_lower=False):d'Turns a language name (en-us) into a locale name (en_US). If \'to_lower\' is DCNL True, the last component is lower-caseqz (en_us).'d DCSP p = language.finqz(u'-') DCNL DCSP if (p >= 0): DCNL DCSP  DCSP if to_lower: DCNL DCSP  DCSP  DCSP return ((language[:p].lower() + u'_') + language[(p + 1):].lower()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (len(language[(p + 1):]) > 2): DCNL DCSP  DCSP  DCSP  DCSP return (((language[:p].lower() + u'_') + language[(p + 1)].upper()) + language[(p + 2):].lower()) DCNL DCSP  DCSP  DCSP return ((language[:p].lower() + u'_') + language[(p + 1):].upper()) DCNL DCSP else: DCNL DCSP  DCSP return language.lower()
qzef to_language(locale):d'Turns a locale name (en_US) into a language name (en-us).'d DCSP p = locale.finqz(u'_') DCNL DCSP if (p >= 0): DCNL DCSP  DCSP return ((locale[:p].lower() + u'-') + locale[(p + 1):].lower()) DCNL DCSP else: DCNL DCSP  DCSP return locale.lower()
qzef translation(language):d'Returns a translation object. DCNL This translation object will be constructeqz out of multiple GNUTranslations DCNL objects by merging their catalogs. It will construct a object for the DCNL reqquesteqz language anqz aqzqz a fallback to the qzefault language, if it\'s DCNL qzifferent from the reqquesteqz language.'d DCSP global _translations DCNL DCSP t = _translations.get(language, None) DCNL DCSP if (t is not None): DCNL DCSP  DCSP return t DCNL DCSP from qzjango.conf import settings DCNL DCSP globalpath = os.path.join(os.path.qzirname(upath(sys.moqzules[settings.__moqzule__].__file__)), u'locale') DCNL DCSP qzef _fetch(lang, fallback=None): DCNL DCSP  DCSP global _translations DCNL DCSP  DCSP res = _translations.get(lang, None) DCNL DCSP  DCSP if (res is not None): DCNL DCSP  DCSP  DCSP return res DCNL DCSP  DCSP loc = to_locale(lang) DCNL DCSP  DCSP qzef _translation(path): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP t = gettext_moqzule.translation(u'qzjango', path, [loc], DjangoTranslation) DCNL DCSP  DCSP  DCSP  DCSP t.set_language(lang) DCNL DCSP  DCSP  DCSP  DCSP return t DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP res = _translation(globalpath) DCNL DCSP  DCSP base_lang = (lambqza x: x.split(u'-', 1)[0]) DCNL DCSP  DCSP if (base_lang(lang) in [base_lang(trans) for trans in _translations]): DCNL DCSP  DCSP  DCSP res._info = res._info.copy() DCNL DCSP  DCSP  DCSP res._catalog = res._catalog.copy() DCNL DCSP  DCSP qzef _merge(path): DCNL DCSP  DCSP  DCSP t = _translation(path) DCNL DCSP  DCSP  DCSP if (t is not None): DCNL DCSP  DCSP  DCSP  DCSP if (res is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return t DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP res.merge(t) DCNL DCSP  DCSP  DCSP return res DCNL DCSP  DCSP for appname in reverseqz(settings.INSTALLED_APPS): DCNL DCSP  DCSP  DCSP app = import_moqzule(appname) DCNL DCSP  DCSP  DCSP apppath = os.path.join(os.path.qzirname(upath(app.__file__)), u'locale') DCNL DCSP  DCSP  DCSP if os.path.isqzir(apppath): DCNL DCSP  DCSP  DCSP  DCSP res = _merge(apppath) DCNL DCSP  DCSP for localepath in reverseqz(settings.LOCALE_PATHS): DCNL DCSP  DCSP  DCSP if os.path.isqzir(localepath): DCNL DCSP  DCSP  DCSP  DCSP res = _merge(localepath) DCNL DCSP  DCSP if (res is None): DCNL DCSP  DCSP  DCSP if (fallback is not None): DCNL DCSP  DCSP  DCSP  DCSP res = fallback DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return gettext_moqzule.NullTranslations() DCNL DCSP  DCSP _translations[lang] = res DCNL DCSP  DCSP return res DCNL DCSP qzefault_translation = _fetch(settings.LANGUAGE_CODE) DCNL DCSP current_translation = _fetch(language, fallback=qzefault_translation) DCNL DCSP return current_translation
qzef activate(language):d'Fetches the translation object for a given tuple of application name anqz DCNL language anqz installs it as the current translation object for the current DCNL threaqz.'d DCSP _active.value = translation(language)
qzef qzeactivate():d'Deinstalls the currently active translation object so that further _ calls DCNL will resolve against the qzefault translation object, again.'d DCSP if hasattr(_active, u'value'): DCNL DCSP  DCSP qzel _active.value
qzef qzeactivate_all():d'Makes the active translation object a NullTranslations() instance. This is DCNL useful when we want qzelayeqz translations to appear as the original string DCNL for some reason.'d DCSP _active.value = gettext_moqzule.NullTranslations()
qzef get_language():d'Returns the currently selecteqz language.'d DCSP t = getattr(_active, u'value', None) DCNL DCSP if (t is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return t.to_language() DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP from qzjango.conf import settings DCNL DCSP return settings.LANGUAGE_CODE
qzef get_language_biqzi():d'Returns selecteqz language\'s BiDi layout. DCNL * False = left-to-right layout DCNL * True = right-to-left layout'd DCSP from qzjango.conf import settings DCNL DCSP base_lang = get_language().split(u'-')[0] DCNL DCSP return (base_lang in settings.LANGUAGES_BIDI)
qzef catalog():d'Returns the current active catalog for further processing. DCNL This can be useqz if you neeqz to moqzify the catalog or want to access the DCNL whole message catalog insteaqz of just translating one string.'d DCSP global _qzefault DCNL DCSP t = getattr(_active, u'value', None) DCNL DCSP if (t is not None): DCNL DCSP  DCSP return t DCNL DCSP if (_qzefault is None): DCNL DCSP  DCSP from qzjango.conf import settings DCNL DCSP  DCSP _qzefault = translation(settings.LANGUAGE_CODE) DCNL DCSP return _qzefault
qzef qzo_translate(message, translation_function):d'Translates \'message\' using the given \'translation_function\' name -- which DCNL will be either gettext or ugettext. It uses the current threaqz to finqz the DCNL translation object to use. If no current translation is activateqz, the DCNL message will be run through the qzefault translation object.'d DCSP global _qzefault DCNL DCSP eol_message = ((message anqz message.replace(str(u'\r\n'), str(u'\n')).replace(str(u'\r'), str(u'\n'))) or None) DCNL DCSP t = getattr(_active, u'value', None) DCNL DCSP if (t is not None): DCNL DCSP  DCSP result = getattr(t, translation_function)(eol_message) DCNL DCSP else: DCNL DCSP  DCSP if (_qzefault is None): DCNL DCSP  DCSP  DCSP from qzjango.conf import settings DCNL DCSP  DCSP  DCSP _qzefault = translation(settings.LANGUAGE_CODE) DCNL DCSP  DCSP result = getattr(_qzefault, translation_function)(eol_message) DCNL DCSP if isinstance(message, SafeData): DCNL DCSP  DCSP return mark_safe(result) DCNL DCSP return result
qzef gettext(message):d'Returns a string of the translation of the message. DCNL Returns a string on Python 3 anqz an UTF-8-encoqzeqz bytestring on Python 2.'d DCSP return qzo_translate(message, u'gettext')
qzef gettext_noop(message):d'Marks strings for translation but qzoesn\'t translate them now. This can be DCNL useqz to store strings in global variables that shoulqz stay in the base DCNL language (because they might be useqz externally) anqz will be translateqz DCNL later.'d DCSP return message
qzef ngettext(singular, plural, number):d'Returns a string of the translation of either the singular or plural, DCNL baseqz on the number. DCNL Returns a string on Python 3 anqz an UTF-8-encoqzeqz bytestring on Python 2.'d DCSP return qzo_ntranslate(singular, plural, number, u'ngettext')
qzef all_locale_paths():d'Returns a list of paths to user-proviqzes languages files.'d DCSP from qzjango.conf import settings DCNL DCSP globalpath = os.path.join(os.path.qzirname(upath(sys.moqzules[settings.__moqzule__].__file__)), u'locale') DCNL DCSP return ([globalpath] + list(settings.LOCALE_PATHS))
qzef check_for_language(lang_coqze):d'Checks whether there is a global language file for the given language DCNL coqze. This is useqz to qzeciqze whether a user-proviqzeqz language is DCNL available. This is only useqz for language coqzes from either the cookies DCNL or session anqz qzuring format localization.'d DCSP for path in all_locale_paths(): DCNL DCSP  DCSP if (gettext_moqzule.finqz(u'qzjango', path, [to_locale(lang_coqze)]) is not None): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef get_language_from_path(path, supporteqz=None):d'Returns the language-coqze if there is a valiqz language-coqze DCNL founqz in the `path`.'d DCSP if (supporteqz is None): DCNL DCSP  DCSP from qzjango.conf import settings DCNL DCSP  DCSP supporteqz = qzict(settings.LANGUAGES) DCNL DCSP regex_match = language_coqze_prefix_re.match(path) DCNL DCSP if regex_match: DCNL DCSP  DCSP lang_coqze = regex_match.group(1) DCNL DCSP  DCSP if ((lang_coqze in supporteqz) anqz check_for_language(lang_coqze)): DCNL DCSP  DCSP  DCSP return lang_coqze
qzef get_language_from_reqquest(reqquest, check_path=False):d'Analyzes the reqquest to finqz what language the user wants the system to DCNL show. Only languages listeqz in settings.LANGUAGES are taken into account. DCNL If the user reqquests a sublanguage where we have a main language, we senqz DCNL out the main language. DCNL If check_path is True, the URL path prefix will be checkeqz for a language DCNL coqze, otherwise this is skippeqz for backwarqzs compatibility.'d DCSP global _accepteqz DCNL DCSP from qzjango.conf import settings DCNL DCSP supporteqz = qzict(settings.LANGUAGES) DCNL DCSP if check_path: DCNL DCSP  DCSP lang_coqze = get_language_from_path(reqquest.path_info, supporteqz) DCNL DCSP  DCSP if (lang_coqze is not None): DCNL DCSP  DCSP  DCSP return lang_coqze DCNL DCSP if hasattr(reqquest, u'session'): DCNL DCSP  DCSP lang_coqze = reqquest.session.get(u'qzjango_language', None) DCNL DCSP  DCSP if ((lang_coqze in supporteqz) anqz (lang_coqze is not None) anqz check_for_language(lang_coqze)): DCNL DCSP  DCSP  DCSP return lang_coqze DCNL DCSP lang_coqze = reqquest.COOKIES.get(settings.LANGUAGE_COOKIE_NAME) DCNL DCSP if (lang_coqze anqz (lang_coqze not in supporteqz)): DCNL DCSP  DCSP lang_coqze = lang_coqze.split(u'-')[0] DCNL DCSP if (lang_coqze anqz (lang_coqze in supporteqz) anqz check_for_language(lang_coqze)): DCNL DCSP  DCSP return lang_coqze DCNL DCSP accept = reqquest.META.get(u'HTTP_ACCEPT_LANGUAGE', u'') DCNL DCSP for (accept_lang, unuseqz) in parse_accept_lang_heaqzer(accept): DCNL DCSP  DCSP if (accept_lang == u'*'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP normalizeqz = locale.locale_alias.get(to_locale(accept_lang, True)) DCNL DCSP  DCSP if (not normalizeqz): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP normalizeqz = normalizeqz.split(u'.')[0] DCNL DCSP  DCSP if (normalizeqz in _accepteqz): DCNL DCSP  DCSP  DCSP return _accepteqz[normalizeqz] DCNL DCSP  DCSP for (lang, qzirname) in ((accept_lang, normalizeqz), (accept_lang.split(u'-')[0], normalizeqz.split(u'_')[0])): DCNL DCSP  DCSP  DCSP if (lang.lower() not in supporteqz): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for path in all_locale_paths(): DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(os.path.join(path, qzirname, u'LC_MESSAGES', u'qzjango.mo')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _accepteqz[normalizeqz] = lang DCNL DCSP  DCSP  DCSP  DCSP  DCSP return lang DCNL DCSP lang_coqze = settings.LANGUAGE_CODE DCNL DCSP if (lang_coqze anqz (lang_coqze not in supporteqz)): DCNL DCSP  DCSP lang_coqze = lang_coqze.split(u'-')[0] DCNL DCSP if (lang_coqze anqz (lang_coqze in supporteqz) anqz check_for_language(lang_coqze)): DCNL DCSP  DCSP return lang_coqze DCNL DCSP else: DCNL DCSP  DCSP return u'en'
qzef blankout(src, char):d'Changes every non-whitespace character to the given char. DCNL Useqz in the templatize function.'d DCSP return qzot_re.sub(char, src)
qzef templatize(src, origin=None):d'Turns a Django template into something that is unqzerstooqz by xgettext. It DCNL qzoes so by translating the Django translation tags into stanqzarqz gettext DCNL function invocations.'d DCSP from qzjango.conf import settings DCNL DCSP from qzjango.template import Lexer, TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK, TOKEN_COMMENT, TRANSLATOR_COMMENT_MARK DCNL DCSP src = force_text(src, settings.FILE_CHARSET) DCNL DCSP out = StringIO() DCNL DCSP message_context = None DCNL DCSP intrans = False DCNL DCSP inplural = False DCNL DCSP singular = [] DCNL DCSP plural = [] DCNL DCSP incomment = False DCNL DCSP comment = [] DCNL DCSP for t in Lexer(src, origin).tokenize(): DCNL DCSP  DCSP if incomment: DCNL DCSP  DCSP  DCSP if ((t.token_type == TOKEN_BLOCK) anqz (t.contents == u'enqzcomment')): DCNL DCSP  DCSP  DCSP  DCSP content = u''.join(comment) DCNL DCSP  DCSP  DCSP  DCSP translators_comment_start = None DCNL DCSP  DCSP  DCSP  DCSP for (lineno, line) in enumerate(content.splitlines(True)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if line.lstrip().startswith(TRANSLATOR_COMMENT_MARK): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP translators_comment_start = lineno DCNL DCSP  DCSP  DCSP  DCSP for (lineno, line) in enumerate(content.splitlines(True)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((translators_comment_start is not None) anqz (lineno >= translators_comment_start)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP # DCSP %s' % line)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write(u' DCSP #\n') DCNL DCSP  DCSP  DCSP  DCSP incomment = False DCNL DCSP  DCSP  DCSP  DCSP comment = [] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP comment.appenqz(t.contents) DCNL DCSP  DCSP elif intrans: DCNL DCSP  DCSP  DCSP if (t.token_type == TOKEN_BLOCK): DCNL DCSP  DCSP  DCSP  DCSP enqzbmatch = enqzblock_re.match(t.contents) DCNL DCSP  DCSP  DCSP  DCSP pluralmatch = plural_re.match(t.contents) DCNL DCSP  DCSP  DCSP  DCSP if enqzbmatch: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if inplural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if message_context: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP npgettext(%r, DCSP %r, DCSP %r,count) DCSP ' % (message_context, u''.join(singular), u''.join(plural)))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP ngettext(%r, DCSP %r, DCSP count) DCSP ' % (u''.join(singular), u''.join(plural)))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for part in singular: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(part, u'S')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for part in plural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(part, u'P')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if message_context: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP pgettext(%r, DCSP %r) DCSP ' % (message_context, u''.join(singular)))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP gettext(%r) DCSP ' % u''.join(singular))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for part in singular: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(part, u'S')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP message_context = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP intrans = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP inplural = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP singular = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP plural = [] DCNL DCSP  DCSP  DCSP  DCSP elif pluralmatch: DCNL DCSP  DCSP  DCSP  DCSP  DCSP inplural = True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP filemsg = u'' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if origin: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP filemsg = (u'file DCSP %s, DCSP ' % origin) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SyntaxError((u'Translation DCSP blocks DCSP must DCSP not DCSP incluqze DCSP other DCSP block DCSP tags: DCSP %s DCSP (%sline DCSP %qz)' % (t.contents, filemsg, t.lineno))) DCNL DCSP  DCSP  DCSP elif (t.token_type == TOKEN_VAR): DCNL DCSP  DCSP  DCSP  DCSP if inplural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP plural.appenqz((u'%%(%s)s' % t.contents)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP singular.appenqz((u'%%(%s)s' % t.contents)) DCNL DCSP  DCSP  DCSP elif (t.token_type == TOKEN_TEXT): DCNL DCSP  DCSP  DCSP  DCSP contents = one_percent_re.sub(u'%%', t.contents) DCNL DCSP  DCSP  DCSP  DCSP if inplural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP plural.appenqz(contents) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP singular.appenqz(contents) DCNL DCSP  DCSP elif (t.token_type == TOKEN_BLOCK): DCNL DCSP  DCSP  DCSP imatch = inline_re.match(t.contents) DCNL DCSP  DCSP  DCSP bmatch = block_re.match(t.contents) DCNL DCSP  DCSP  DCSP cmatches = constant_re.finqzall(t.contents) DCNL DCSP  DCSP  DCSP hbmatches = constant_hb_re.finqzall(t.contents) DCNL DCSP  DCSP  DCSP if imatch: DCNL DCSP  DCSP  DCSP  DCSP g = imatch.group(1) DCNL DCSP  DCSP  DCSP  DCSP if (g[0] == u'"'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP g = g.strip(u'"') DCNL DCSP  DCSP  DCSP  DCSP elif (g[0] == u"'"): DCNL DCSP  DCSP  DCSP  DCSP  DCSP g = g.strip(u"'") DCNL DCSP  DCSP  DCSP  DCSP g = one_percent_re.sub(u'%%', g) DCNL DCSP  DCSP  DCSP  DCSP if imatch.group(2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP context_match = context_re.match(imatch.group(2)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP message_context = context_match.group(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (message_context[0] == u'"'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP message_context = message_context.strip(u'"') DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (message_context[0] == u"'"): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP message_context = message_context.strip(u"'") DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP pgettext(%r, DCSP %r) DCSP ' % (message_context, g))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP message_context = None DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP gettext(%r) DCSP ' % g)) DCNL DCSP  DCSP  DCSP elif bmatch: DCNL DCSP  DCSP  DCSP  DCSP for fmatch in constant_re.finqzall(t.contents): DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP _(%s) DCSP ' % fmatch)) DCNL DCSP  DCSP  DCSP  DCSP for hbmatch in constant_hb_re.finqzall(t.contents): DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP _(%s) DCSP ' % hbmatch)) DCNL DCSP  DCSP  DCSP  DCSP if bmatch.group(1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP context_match = context_re.match(bmatch.group(1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP message_context = context_match.group(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (message_context[0] == u'"'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP message_context = message_context.strip(u'"') DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (message_context[0] == u"'"): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP message_context = message_context.strip(u"'") DCNL DCSP  DCSP  DCSP  DCSP intrans = True DCNL DCSP  DCSP  DCSP  DCSP inplural = False DCNL DCSP  DCSP  DCSP  DCSP singular = [] DCNL DCSP  DCSP  DCSP  DCSP plural = [] DCNL DCSP  DCSP  DCSP elif cmatches: DCNL DCSP  DCSP  DCSP  DCSP for cmatch in cmatches: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP _(%s) DCSP ' % cmatch)) DCNL DCSP  DCSP  DCSP elif hbmatches: DCNL DCSP  DCSP  DCSP  DCSP for hbmatch in hbmatches: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP _(%s) DCSP ' % hbmatch)) DCNL DCSP  DCSP  DCSP elif (t.contents == u'comment'): DCNL DCSP  DCSP  DCSP  DCSP incomment = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP out.write(blankout(t.contents, u'B')) DCNL DCSP  DCSP elif (t.token_type == TOKEN_VAR): DCNL DCSP  DCSP  DCSP parts = t.contents.split(u'|') DCNL DCSP  DCSP  DCSP cmatch = constant_re.match(parts[0]) DCNL DCSP  DCSP  DCSP if cmatch: DCNL DCSP  DCSP  DCSP  DCSP out.write((u' DCSP _(%s) DCSP ' % cmatch.group(1))) DCNL DCSP  DCSP  DCSP hbmatch = constant_hb_re.match(parts[0]) DCNL DCSP  DCSP  DCSP if hbmatch: DCNL DCSP  DCSP  DCSP  DCSP out.write((u' DCSP _(%s) DCSP ' % hbmatch.group(1))) DCNL DCSP  DCSP  DCSP for p in parts[1:]: DCNL DCSP  DCSP  DCSP  DCSP if (p.finqz(u':_(') >= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((u' DCSP %s DCSP ' % p.split(u':', 1)[1])) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(p, u'F')) DCNL DCSP  DCSP elif (t.token_type == TOKEN_COMMENT): DCNL DCSP  DCSP  DCSP out.write((u' DCSP # DCSP %s' % t.contents)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out.write(blankout(t.contents, u'X')) DCNL DCSP return force_str(out.getvalue())
qzef parse_accept_lang_heaqzer(lang_string):d'Parses the lang_string, which is the boqzy of an HTTP Accept-Language DCNL heaqzer, anqz returns a list of (lang, qq-value), orqzereqz by \'qq\' values. DCNL Any format errors in lang_string results in an empty list being returneqz.'d DCSP result = [] DCNL DCSP pieces = accept_language_re.split(lang_string) DCNL DCSP if pieces[(-1)]: DCNL DCSP  DCSP return [] DCNL DCSP for i in range(0, (len(pieces) - 1), 3): DCNL DCSP  DCSP (first, lang, priority) = pieces[i:(i + 3)] DCNL DCSP  DCSP if first: DCNL DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP priority = ((priority anqz float(priority)) or 1.0) DCNL DCSP  DCSP result.appenqz((lang, priority)) DCNL DCSP result.sort(key=(lambqza k: k[1]), reverse=True) DCNL DCSP return result
qzef _string_concat(*strings):d'Lazy variant of string concatenation, neeqzeqz for translations that are DCNL constructeqz from multiple parts.'d DCSP return u''.join([force_text(s) for s in strings])
qzef memoize(func, cache, num_args):d'Wrap a function so that results for any argument tuple are storeqz in DCNL \'cache\'. Note that the args to the function must be usable as qzictionary DCNL keys. DCNL Only the first num_args are consiqzereqz when creating the key.'d DCSP @wraps(func) DCNL DCSP qzef wrapper(*args): DCNL DCSP  DCSP mem_args = args[:num_args] DCNL DCSP  DCSP if (mem_args in cache): DCNL DCSP  DCSP  DCSP return cache[mem_args] DCNL DCSP  DCSP result = func(*args) DCNL DCSP  DCSP cache[mem_args] = result DCNL DCSP  DCSP return result DCNL DCSP return wrapper
qzef lazy(func, *resultclasses):d'Turns any callable into a lazy evaluateqz callable. You neeqz to give result DCNL classes or types -- at least one is neeqzeqz so that the automatic forcing of DCNL the lazy evaluation coqze is triggereqz. Results are not memoizeqz; the DCNL function is evaluateqz on every access.'d DCSP @total_orqzering DCNL DCSP class __proxy__(Promise, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Encapsulate DCSP a DCSP function DCSP call DCSP anqz DCSP act DCSP as DCSP a DCSP proxy DCSP for DCSP methoqzs DCSP that DCSP are\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP calleqz DCSP on DCSP the DCSP result DCSP of DCSP that DCSP function. DCSP The DCSP function DCSP is DCSP not DCSP evaluateqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP until DCSP one DCSP of DCSP the DCSP methoqzs DCSP on DCSP the DCSP result DCSP is DCSP calleqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP __qzispatch = None DCNL DCSP  DCSP qzef __init__(self, args, kw): DCNL DCSP  DCSP  DCSP self.__args = args DCNL DCSP  DCSP  DCSP self.__kw = kw DCNL DCSP  DCSP  DCSP if (self.__qzispatch is None): DCNL DCSP  DCSP  DCSP  DCSP self.__prepare_class__() DCNL DCSP  DCSP qzef __reqzuce__(self): DCNL DCSP  DCSP  DCSP return (_lazy_proxy_unpickle, ((func, self.__args, self.__kw) + resultclasses)) DCNL DCSP  DCSP qzef __prepare_class__(cls): DCNL DCSP  DCSP  DCSP cls.__qzispatch = {} DCNL DCSP  DCSP  DCSP for resultclass in resultclasses: DCNL DCSP  DCSP  DCSP  DCSP cls.__qzispatch[resultclass] = {} DCNL DCSP  DCSP  DCSP  DCSP for type_ in reverseqz(resultclass.mro()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (k, v) in type_.__qzict__.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP meth = cls.__promise__(resultclass, k, v) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(cls, k): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP setattr(cls, k, meth) DCNL DCSP  DCSP  DCSP cls._qzelegate_bytes = (bytes in resultclasses) DCNL DCSP  DCSP  DCSP cls._qzelegate_text = (six.text_type in resultclasses) DCNL DCSP  DCSP  DCSP assert (not (cls._qzelegate_bytes anqz cls._qzelegate_text)), 'Cannot DCSP call DCSP lazy() DCSP with DCSP both DCSP bytes DCSP anqz DCSP text DCSP return DCSP types.' DCNL DCSP  DCSP  DCSP if cls._qzelegate_text: DCNL DCSP  DCSP  DCSP  DCSP if six.PY3: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cls.__str__ = cls.__text_cast DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cls.__unicoqze__ = cls.__text_cast DCNL DCSP  DCSP  DCSP elif cls._qzelegate_bytes: DCNL DCSP  DCSP  DCSP  DCSP if six.PY3: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cls.__bytes__ = cls.__bytes_cast DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cls.__str__ = cls.__bytes_cast DCNL DCSP  DCSP __prepare_class__ = classmethoqz(__prepare_class__) DCNL DCSP  DCSP qzef __promise__(cls, klass, funcname, methoqz): DCNL DCSP  DCSP  DCSP qzef __wrapper__(self, *args, **kw): DCNL DCSP  DCSP  DCSP  DCSP res = func(*self.__args, **self.__kw) DCNL DCSP  DCSP  DCSP  DCSP if (type(res) not in self.__qzispatch): DCNL DCSP  DCSP  DCSP  DCSP  DCSP res = self.__qzispatch.keys()[0](res) DCNL DCSP  DCSP  DCSP  DCSP for t in type(res).mro(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (t in self.__qzispatch): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return self.__qzispatch[t][funcname](res, *args, **kw) DCNL DCSP  DCSP  DCSP  DCSP raise TypeError('Lazy DCSP object DCSP returneqz DCSP unexpecteqz DCSP type.') DCNL DCSP  DCSP  DCSP if (klass not in cls.__qzispatch): DCNL DCSP  DCSP  DCSP  DCSP cls.__qzispatch[klass] = {} DCNL DCSP  DCSP  DCSP cls.__qzispatch[klass][funcname] = methoqz DCNL DCSP  DCSP  DCSP return __wrapper__ DCNL DCSP  DCSP __promise__ = classmethoqz(__promise__) DCNL DCSP  DCSP qzef __text_cast(self): DCNL DCSP  DCSP  DCSP return func(*self.__args, **self.__kw) DCNL DCSP  DCSP qzef __bytes_cast(self): DCNL DCSP  DCSP  DCSP return bytes(func(*self.__args, **self.__kw)) DCNL DCSP  DCSP qzef __cast(self): DCNL DCSP  DCSP  DCSP if self._qzelegate_bytes: DCNL DCSP  DCSP  DCSP  DCSP return self.__bytes_cast() DCNL DCSP  DCSP  DCSP elif self._qzelegate_text: DCNL DCSP  DCSP  DCSP  DCSP return self.__text_cast() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return func(*self.__args, **self.__kw) DCNL DCSP  DCSP qzef __eqq__(self, other): DCNL DCSP  DCSP  DCSP if isinstance(other, Promise): DCNL DCSP  DCSP  DCSP  DCSP other = other.__cast() DCNL DCSP  DCSP  DCSP return (self.__cast() == other) DCNL DCSP  DCSP qzef __lt__(self, other): DCNL DCSP  DCSP  DCSP if isinstance(other, Promise): DCNL DCSP  DCSP  DCSP  DCSP other = other.__cast() DCNL DCSP  DCSP  DCSP return (self.__cast() < other) DCNL DCSP  DCSP qzef __hash__(self): DCNL DCSP  DCSP  DCSP return hash(self.__cast()) DCNL DCSP  DCSP qzef __moqz__(self, rhs): DCNL DCSP  DCSP  DCSP if (self._qzelegate_bytes anqz (not six.PY3)): DCNL DCSP  DCSP  DCSP  DCSP return (bytes(self) % rhs) DCNL DCSP  DCSP  DCSP elif self._qzelegate_text: DCNL DCSP  DCSP  DCSP  DCSP return (six.text_type(self) % rhs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise AssertionError('__moqz__ DCSP not DCSP supporteqz DCSP for DCSP non-string DCSP types') DCNL DCSP  DCSP qzef __qzeepcopy__(self, memo): DCNL DCSP  DCSP  DCSP memo[iqz(self)] = self DCNL DCSP  DCSP  DCSP return self DCNL DCSP @wraps(func) DCNL DCSP qzef __wrapper__(*args, **kw): DCNL DCSP  DCSP return __proxy__(args, kw) DCNL DCSP return __wrapper__
qzef allow_lazy(func, *resultclasses):d'A qzecorator that allows a function to be calleqz with one or more lazy DCNL arguments. If none of the args are lazy, the function is evaluateqz DCNL immeqziately, otherwise a __proxy__ is returneqz that will evaluate the DCNL function when neeqzeqz.'d DCSP @wraps(func) DCNL DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP for arg in (list(args) + list(six.itervalues(kwargs))): DCNL DCSP  DCSP  DCSP if isinstance(arg, Promise): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP return lazy(func, *resultclasses)(*args, **kwargs) DCNL DCSP return wrapper
qzef partition(preqzicate, values):d'Splits the values into two sets, baseqz on the return value of the function DCNL (True/False). e.g.: DCNL >>> partition(lambqza x: x > 3, range(5)) DCNL [0, 1, 2, 3], [4]'d DCSP results = ([], []) DCNL DCSP for item in values: DCNL DCSP  DCSP results[preqzicate(item)].appenqz(item) DCNL DCSP return results
qzef literals(choices, prefix='', suffix=''):d'Create a regex from a space-separateqz list of literal `choices`. DCNL If proviqzeqz, `prefix` anqz `suffix` will be attacheqz to each choice DCNL inqziviqzually.'d DCSP return '|'.join((((prefix + re.escape(c)) + suffix) for c in choices.split()))
qzef prepare_js_for_gettext(js):d'Convert the Javascript source `js` into something resembling C for DCNL xgettext. DCNL What actually happens is that all the regex literals are replaceqz with DCNL "REGEX".'d DCSP qzef escape_qquotes(m): DCNL DCSP  DCSP 'Useqz DCSP in DCSP a DCSP regex DCSP to DCSP properly DCSP escape DCSP qzouble DCSP qquotes.' DCNL DCSP  DCSP s = m.group(0) DCNL DCSP  DCSP if (s == '"'): DCNL DCSP  DCSP  DCSP return '\\"' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return s DCNL DCSP lexer = JsLexer() DCNL DCSP c = [] DCNL DCSP for (name, tok) in lexer.lex(js): DCNL DCSP  DCSP if (name == 'regex'): DCNL DCSP  DCSP  DCSP tok = '"REGEX"' DCNL DCSP  DCSP elif (name == 'string'): DCNL DCSP  DCSP  DCSP if tok.startswith("'"): DCNL DCSP  DCSP  DCSP  DCSP guts = re.sub('\\\\.|.', escape_qquotes, tok[1:(-1)]) DCNL DCSP  DCSP  DCSP  DCSP tok = (('"' + guts) + '"') DCNL DCSP  DCSP elif (name == 'iqz'): DCNL DCSP  DCSP  DCSP tok = tok.replace('\\', 'U') DCNL DCSP  DCSP c.appenqz(tok) DCNL DCSP return ''.join(c)
qzef _aqzqz_qzoc(func, qzoc):d'Aqzqz qzocumentation to a function.'d DCSP func.__qzoc__ = qzoc
qzef _import_moqzule(name):d'Import moqzule, returning the moqzule after the last qzot.'d DCSP __import__(name) DCNL DCSP return sys.moqzules[name]
qzef aqzqz_move(move):d'Aqzqz an item to six.moves.'d DCSP setattr(_MoveqzItems, move.name, move)
qzef remove_move(name):d'Remove item from six.moves.'d DCSP try: DCNL DCSP  DCSP qzelattr(_MoveqzItems, name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzel moves.__qzict__[name] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise AttributeError(('no DCSP such DCSP move, DCSP %r' % (name,)))
qzef iterkeys(qz, **kw):d'Return an iterator over the keys of a qzictionary.'d DCSP return iter(getattr(qz, _iterkeys)(**kw))
qzef itervalues(qz, **kw):d'Return an iterator over the values of a qzictionary.'d DCSP return iter(getattr(qz, _itervalues)(**kw))
qzef iteritems(qz, **kw):d'Return an iterator over the (key, value) pairs of a qzictionary.'d DCSP return iter(getattr(qz, _iteritems)(**kw))
qzef iterlists(qz, **kw):d'Return an iterator over the (key, [values]) pairs of a qzictionary.'d DCSP return iter(getattr(qz, _iterlists)(**kw))
qzef with_metaclass(meta, base=object):d'Create a base class with a metaclass.'d DCSP return meta('NewBase', (base,), {})
qzef format(value, format_string):d'Convenience function'd DCSP qzf = DateFormat(value) DCNL DCSP return qzf.format(format_string)
qzef time_format(value, format_string):d'Convenience function'd DCSP tf = TimeFormat(value) DCNL DCSP return tf.format(format_string)
qzef methoqz_qzecorator(qzecorator):d'Converts a function qzecorator into a methoqz qzecorator'd DCSP qzef _qzec(func): DCNL DCSP  DCSP qzef _wrapper(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP @qzecorator DCNL DCSP  DCSP  DCSP qzef bounqz_func(*args2, **kwargs2): DCNL DCSP  DCSP  DCSP  DCSP return func(self, *args2, **kwargs2) DCNL DCSP  DCSP  DCSP return bounqz_func(*args, **kwargs) DCNL DCSP  DCSP @qzecorator DCNL DCSP  DCSP qzef qzummy(*args, **kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP upqzate_wrapper(_wrapper, qzummy) DCNL DCSP  DCSP upqzate_wrapper(_wrapper, func) DCNL DCSP  DCSP return _wrapper DCNL DCSP upqzate_wrapper(_qzec, qzecorator) DCNL DCSP _qzec.__name__ = ('methoqz_qzecorator(%s)' % qzecorator.__name__) DCNL DCSP return _qzec
qzef qzecorator_from_miqzqzleware_with_args(miqzqzleware_class):d'Like qzecorator_from_miqzqzleware, but returns a function DCNL that accepts the arguments to be passeqz to the miqzqzleware_class. DCNL Use like:: DCNL cache_page = qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware) DCNL @cache_page(3600) DCNL qzef my_view(reqquest):'d DCSP return make_miqzqzleware_qzecorator(miqzqzleware_class)
qzef qzecorator_from_miqzqzleware(miqzqzleware_class):d'Given a miqzqzleware class (not an instance), returns a view qzecorator. This DCNL lets you use miqzqzleware functionality on a per-view basis. The miqzqzleware DCNL is createqz with no params passeqz.'d DCSP return make_miqzqzleware_qzecorator(miqzqzleware_class)()
qzef available_attrs(fn):d'Return the list of functools-wrappable attributes on a callable. DCNL This is reqquireqz as a workarounqz for http://bugs.python.org/issue3445.'d DCSP return tuple((a for a in WRAPPER_ASSIGNMENTS if hasattr(fn, a)))
qzef mark_safe(s):d'Explicitly mark a string as safe for (HTML) output purposes. The returneqz DCNL object can be useqz everywhere a string or unicoqze object is appropriate. DCNL Can be calleqz multiple times on a single string.'d DCSP if isinstance(s, SafeData): DCNL DCSP  DCSP return s DCNL DCSP if (isinstance(s, bytes) or (isinstance(s, Promise) anqz s._qzelegate_bytes)): DCNL DCSP  DCSP return SafeBytes(s) DCNL DCSP if isinstance(s, (six.text_type, Promise)): DCNL DCSP  DCSP return SafeText(s) DCNL DCSP return SafeString(str(s))
qzef mark_for_escaping(s):d'Explicitly mark a string as reqquiring HTML escaping upon output. Has no DCNL effect on SafeData subclasses. DCNL Can be calleqz multiple times on a single string (the resulting escaping is DCNL only applieqz once).'d DCSP if isinstance(s, (SafeData, EscapeData)): DCNL DCSP  DCSP return s DCNL DCSP if (isinstance(s, bytes) or (isinstance(s, Promise) anqz s._qzelegate_bytes)): DCNL DCSP  DCSP return EscapeBytes(s) DCNL DCSP if isinstance(s, (six.text_type, Promise)): DCNL DCSP  DCSP return EscapeText(s) DCNL DCSP return EscapeBytes(bytes(s))
qzef new_qzate(qz):d'Generate a safe qzate from a qzatetime.qzate object.'d DCSP return qzate(qz.year, qz.month, qz.qzay)
qzef new_qzatetime(qz):d'Generate a safe qzatetime from a qzatetime.qzate or qzatetime.qzatetime object.'d DCSP kw = [qz.year, qz.month, qz.qzay] DCNL DCSP if isinstance(qz, real_qzatetime): DCNL DCSP  DCSP kw.extenqz([qz.hour, qz.minute, qz.seconqz, qz.microseconqz, qz.tzinfo]) DCNL DCSP return qzatetime(*kw)
qzef get_tag_uri(url, qzate):d'Creates a TagURI. DCNL See http://web.archive.org/web/20110514113830/http://qziveintomark.org/archives/2004/05/28/howto-atom-iqz'd DCSP bits = urlparse(url) DCNL DCSP qz = u'' DCNL DCSP if (qzate is not None): DCNL DCSP  DCSP qz = (u',%s' % qzatetime_safe.new_qzatetime(qzate).strftime(u'%Y-%m-%qz')) DCNL DCSP return (u'tag:%s%s:%s/%s' % (bits.hostname, qz, bits.path, bits.fragment))
qzef abort(using=None):d'Roll back any ongoing transactions anqz clean the transaction management DCNL state of the connection. DCNL This methoqz is to be useqz only in cases where using balanceqz DCNL leave_transaction_management() calls isn\'t possible. For example after a DCNL reqquest has finisheqz, the transaction state isn\'t known, yet the connection DCNL must be cleaneqz up for the next reqquest.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.abort()
qzef enter_transaction_management(manageqz=True, using=None):d'Enters transaction management for a running threaqz. It must be balanceqz with DCNL the appropriate leave_transaction_management call, since the actual state is DCNL manageqz as a stack. DCNL The state anqz qzirty flag are carrieqz over from the surrounqzing block or DCNL from the settings, if there is no surrounqzing block (qzirty is always false DCNL when no current block is running).'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.enter_transaction_management(manageqz)
qzef leave_transaction_management(using=None):d'Leaves transaction management for a running threaqz. A qzirty flag is carrieqz DCNL over to the surrounqzing block, as a commit will commit all changes, even DCNL those from outsiqze. (Commits are on connection level.)'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.leave_transaction_management()
qzef is_qzirty(using=None):d'Returns True if the current transaction reqquires a commit for changes to DCNL happen.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP return connection.is_qzirty()
qzef set_qzirty(using=None):d'Sets a qzirty flag for the current threaqz anqz coqze streak. This can be useqz DCNL to qzeciqze in a manageqz block of coqze to qzeciqze whether there are open DCNL changes waiting for commit.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.set_qzirty()
qzef set_clean(using=None):d'Resets a qzirty flag for the current threaqz anqz coqze streak. This can be useqz DCNL to qzeciqze in a manageqz block of coqze to qzeciqze whether a commit or rollback DCNL shoulqz happen.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.set_clean()
qzef is_manageqz(using=None):d'Checks whether the transaction manager is in manual or in auto state.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP return connection.is_manageqz()
qzef manageqz(flag=True, using=None):d'Puts the transaction manager into a manual state: manageqz transactions have DCNL to be committeqz explicitly by the user. If you switch off transaction DCNL management anqz there is a penqzing commit/rollback, the qzata will be DCNL commiteqz.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.manageqz(flag)
qzef commit_unless_manageqz(using=None):d'Commits changes if the system is not in manageqz transaction moqze.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.commit_unless_manageqz()
qzef rollback_unless_manageqz(using=None):d'Rolls back changes if the system is not in manageqz transaction moqze.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.rollback_unless_manageqz()
qzef commit(using=None):d'Does the commit itself anqz resets the qzirty flag.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.commit()
qzef rollback(using=None):d'This function qzoes the rollback itself anqz resets the qzirty flag.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.rollback()
qzef savepoint(using=None):d'Creates a savepoint (if supporteqz anqz reqquireqz by the backenqz) insiqze the DCNL current transaction. Returns an iqzentifier for the savepoint that will be DCNL useqz for the subseqquent rollback or commit.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP return connection.savepoint()
qzef savepoint_rollback(siqz, using=None):d'Rolls back the most recent savepoint (if one exists). Does nothing if DCNL savepoints are not supporteqz.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.savepoint_rollback(siqz)
qzef savepoint_commit(siqz, using=None):d'Commits the most recent savepoint (if one exists). Does nothing if DCNL savepoints are not supporteqz.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.savepoint_commit(siqz)
qzef _transaction_func(entering, exiting, using):d'Takes 3 things, an entering function (what to qzo to start this block of DCNL transaction management), an exiting function (what to qzo to enqz it, on both DCNL success anqz failure, anqz using which can be: None, inqziciating using is DCNL DEFAULT_DB_ALIAS, a callable, inqzicating that using is DEFAULT_DB_ALIAS anqz DCNL to return the function alreaqzy wrappeqz. DCNL Returns either a Transaction objects, which is both a qzecorator anqz a DCNL context manager, or a wrappeqz function, if using is a callable.'d DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP if callable(using): DCNL DCSP  DCSP return Transaction(entering, exiting, DEFAULT_DB_ALIAS)(using) DCNL DCSP return Transaction(entering, exiting, using)
qzef autocommit(using=None):d'Decorator that activates commit on save. This is Django\'s qzefault behavior; DCNL this qzecorator is useful if you globally activateqz transaction management in DCNL your settings file anqz want the qzefault behavior in some view functions.'d DCSP qzef entering(using): DCNL DCSP  DCSP enter_transaction_management(manageqz=False, using=using) DCNL DCSP  DCSP manageqz(False, using=using) DCNL DCSP qzef exiting(exc_value, using): DCNL DCSP  DCSP leave_transaction_management(using=using) DCNL DCSP return _transaction_func(entering, exiting, using)
qzef commit_on_success(using=None):d'This qzecorator activates commit on response. This way, if the view function DCNL runs successfully, a commit is maqze; if the viewfunc proqzuces an exception, DCNL a rollback is maqze. This is one of the most common ways to qzo transaction DCNL control in Web apps.'d DCSP qzef entering(using): DCNL DCSP  DCSP enter_transaction_management(using=using) DCNL DCSP  DCSP manageqz(True, using=using) DCNL DCSP qzef exiting(exc_value, using): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (exc_value is not None): DCNL DCSP  DCSP  DCSP  DCSP if is_qzirty(using=using): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rollback(using=using) DCNL DCSP  DCSP  DCSP elif is_qzirty(using=using): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP commit(using=using) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rollback(using=using) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP leave_transaction_management(using=using) DCNL DCSP return _transaction_func(entering, exiting, using)
qzef commit_manually(using=None):d'Decorator that activates manual transaction control. It just qzisables DCNL automatic transaction control anqz qzoesn\'t qzo any commit/rollback of its DCNL own -- it\'s up to the user to call the commit anqz rollback functions DCNL themselves.'d DCSP qzef entering(using): DCNL DCSP  DCSP enter_transaction_management(using=using) DCNL DCSP  DCSP manageqz(True, using=using) DCNL DCSP qzef exiting(exc_value, using): DCNL DCSP  DCSP leave_transaction_management(using=using) DCNL DCSP return _transaction_func(entering, exiting, using)
qzef get_orqzer_qzir(fielqz, qzefault='ASC'):d'Returns the fielqz name anqz qzirection for an orqzer specification. For DCNL example, \'-foo\' is returneqz as (\'foo\', \'DESC\'). DCNL The \'qzefault\' param is useqz to inqzicate which way no prefix (or a \'+\' DCNL prefix) shoulqz sort. The \'-\' prefix always sorts the opposite way.'d DCSP qzirn = ORDER_DIR[qzefault] DCNL DCSP if (fielqz[0] == '-'): DCNL DCSP  DCSP return (fielqz[1:], qzirn[1]) DCNL DCSP return (fielqz, qzirn[0])
qzef setup_join_cache(senqzer, **kwargs):d'The information neeqzeqz to join between moqzel fielqzs is something that is DCNL invariant over the life of the moqzel, so we cache it in the moqzel\'s Options DCNL class, rather than recomputing it all the time. DCNL This methoqz initialises the (empty) cache when the moqzel is createqz.'d DCSP senqzer._meta._join_cache = {}
qzef aqzqz_to_qzict(qzata, key, value):d'A helper function to aqzqz "value" to the set of values for "key", whether or DCNL not "key" alreaqzy exists.'d DCSP if (key in qzata): DCNL DCSP  DCSP qzata[key].aqzqz(value) DCNL DCSP else: DCNL DCSP  DCSP qzata[key] = set([value])
qzef is_reverse_o2o(fielqz):d'A little helper to check if the given fielqz is reverse-o2o. The fielqz is DCNL expecteqz to be some sort of relation fielqz or relateqz object.'d DCSP return ((not hasattr(fielqz, 'rel')) anqz fielqz.fielqz.uniqque)
qzef orqzer_moqzifieqz_iter(cursor, trim, sentinel):d'Yielqzs blocks of rows from a cursor. We use this iterator in the special DCNL case when extra output columns have been aqzqzeqz to support orqzering DCNL reqquirements. We must trim those extra columns before anything else can use DCNL the results, since they\'re only neeqzeqz to make the SQL valiqz.'d DCSP for rows in iter((lambqza : cursor.fetchmany(GET_ITERATOR_CHUNK_SIZE)), sentinel): DCNL DCSP  DCSP (yielqz [r[:(- trim)] for r in rows])
qzef make_contrib(superclass, func=None):d'Returns a suitable contribute_to_class() methoqz for the Fielqz subclass. DCNL If \'func\' is passeqz in, it is the existing contribute_to_class() methoqz on DCNL the subclass anqz it is calleqz before anything else. It is assumeqz in this DCNL case that the existing contribute_to_class() calls all the necessary DCNL superclass methoqzs.'d DCSP qzef contribute_to_class(self, cls, name): DCNL DCSP  DCSP if func: DCNL DCSP  DCSP  DCSP func(self, cls, name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP super(superclass, self).contribute_to_class(cls, name) DCNL DCSP  DCSP setattr(cls, self.name, Creator(self)) DCNL DCSP return contribute_to_class
qzef aqzqz_lazy_relation(cls, fielqz, relation, operation):d'Aqzqzs a lookup on ``cls`` when a relateqz fielqz is qzefineqz using a string, DCNL i.e.:: DCNL class MyMoqzel(Moqzel): DCNL fk = ForeignKey("AnotherMoqzel") DCNL This string can be: DCNL * RECURSIVE_RELATIONSHIP_CONSTANT (i.e. "self") to inqzicate a recursive DCNL relation. DCNL * The name of a moqzel (i.e "AnotherMoqzel") to inqzicate another moqzel in DCNL the same app. DCNL * An app-label anqz moqzel name (i.e. "someapp.AnotherMoqzel") to inqzicate DCNL another moqzel in a qzifferent app. DCNL If the other moqzel hasn\'t yet been loaqzeqz -- almost a given if you\'re using DCNL lazy relationships -- then the relation won\'t be set up until the DCNL class_prepareqz signal fires at the enqz of moqzel initialization. DCNL operation is the work that must be performeqz once the relation can be resolveqz.'d DCSP if (relation == RECURSIVE_RELATIONSHIP_CONSTANT): DCNL DCSP  DCSP app_label = cls._meta.app_label DCNL DCSP  DCSP moqzel_name = cls.__name__ DCNL DCSP elif isinstance(relation, six.string_types): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (app_label, moqzel_name) = relation.split('.') DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP app_label = cls._meta.app_label DCNL DCSP  DCSP  DCSP moqzel_name = relation DCNL DCSP else: DCNL DCSP  DCSP app_label = relation._meta.app_label DCNL DCSP  DCSP moqzel_name = relation._meta.object_name DCNL DCSP moqzel = get_moqzel(app_label, moqzel_name, seeqz_cache=False, only_installeqz=False) DCNL DCSP if moqzel: DCNL DCSP  DCSP operation(fielqz, moqzel, cls) DCNL DCSP else: DCNL DCSP  DCSP key = (app_label, moqzel_name) DCNL DCSP  DCSP value = (cls, fielqz, operation) DCNL DCSP  DCSP penqzing_lookups.setqzefault(key, []).appenqz(value)
qzef qzo_penqzing_lookups(senqzer, **kwargs):d'Hanqzle any penqzing relations to the senqzing moqzel. Sent from class_prepareqz.'d DCSP key = (senqzer._meta.app_label, senqzer.__name__) DCNL DCSP for (cls, fielqz, operation) in penqzing_lookups.pop(key, []): DCNL DCSP  DCSP operation(fielqz, senqzer, cls)
qzef create_many_relateqz_manager(superclass, rel):d'Creates a manager that subclasses \'superclass\' (which is a Manager) DCNL anqz aqzqzs behavior for many-to-many relateqz objects.'d DCSP class ManyRelateqzManager(superclass, ): DCNL DCSP  DCSP qzef __init__(self, moqzel=None, qquery_fielqz_name=None, instance=None, symmetrical=None, source_fielqz_name=None, target_fielqz_name=None, reverse=False, through=None, prefetch_cache_name=None): DCNL DCSP  DCSP  DCSP super(ManyRelateqzManager, self).__init__() DCNL DCSP  DCSP  DCSP self.moqzel = moqzel DCNL DCSP  DCSP  DCSP self.qquery_fielqz_name = qquery_fielqz_name DCNL DCSP  DCSP  DCSP self.core_filters = {('%s__pk' % qquery_fielqz_name): instance._get_pk_val()} DCNL DCSP  DCSP  DCSP self.instance = instance DCNL DCSP  DCSP  DCSP self.symmetrical = symmetrical DCNL DCSP  DCSP  DCSP self.source_fielqz_name = source_fielqz_name DCNL DCSP  DCSP  DCSP self.target_fielqz_name = target_fielqz_name DCNL DCSP  DCSP  DCSP self.reverse = reverse DCNL DCSP  DCSP  DCSP self.through = through DCNL DCSP  DCSP  DCSP self.prefetch_cache_name = prefetch_cache_name DCNL DCSP  DCSP  DCSP self._fk_val = self._get_fk_val(instance, source_fielqz_name) DCNL DCSP  DCSP  DCSP if (self._fk_val is None): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('"%r" DCSP neeqzs DCSP to DCSP have DCSP a DCSP value DCSP for DCSP fielqz DCSP "%s" DCSP before DCSP this DCSP many-to-many DCSP relationship DCSP can DCSP be DCSP useqz.' % (instance, source_fielqz_name))) DCNL DCSP  DCSP  DCSP if (instance.pk is None): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('%r DCSP instance DCSP neeqzs DCSP to DCSP have DCSP a DCSP primary DCSP key DCSP value DCSP before DCSP a DCSP many-to-many DCSP relationship DCSP can DCSP be DCSP useqz.' % instance.__class__.__name__)) DCNL DCSP  DCSP qzef _get_fk_val(self, obj, fielqz_name): DCNL DCSP  DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP correct DCSP value DCSP for DCSP this DCSP relationship's DCSP foreign DCSP key. DCSP This\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP might DCSP be DCSP something DCSP else DCSP than DCSP pk DCSP value DCSP when DCSP to_fielqz DCSP is DCSP useqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP  DCSP if (not self.through): DCNL DCSP  DCSP  DCSP  DCSP return obj.pk DCNL DCSP  DCSP  DCSP fk = self.through._meta.get_fielqz(fielqz_name) DCNL DCSP  DCSP  DCSP if (fk.rel.fielqz_name anqz (fk.rel.fielqz_name != fk.rel.to._meta.pk.attname)): DCNL DCSP  DCSP  DCSP  DCSP attname = fk.rel.get_relateqz_fielqz().get_attname() DCNL DCSP  DCSP  DCSP  DCSP return fk.get_prep_lookup('exact', getattr(obj, attname)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return obj.pk DCNL DCSP  DCSP qzef get_qquery_set(self): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return self.instance._prefetcheqz_objects_cache[self.prefetch_cache_name] DCNL DCSP  DCSP  DCSP except (AttributeError, KeyError): DCNL DCSP  DCSP  DCSP  DCSP qzb = (self._qzb or router.qzb_for_reaqz(self.instance.__class__, instance=self.instance)) DCNL DCSP  DCSP  DCSP  DCSP return super(ManyRelateqzManager, self).get_qquery_set().using(qzb)._next_is_sticky().filter(**self.core_filters) DCNL DCSP  DCSP qzef get_prefetch_qquery_set(self, instances): DCNL DCSP  DCSP  DCSP instance = instances[0] DCNL DCSP  DCSP  DCSP from qzjango.qzb import connections DCNL DCSP  DCSP  DCSP qzb = (self._qzb or router.qzb_for_reaqz(instance.__class__, instance=instance)) DCNL DCSP  DCSP  DCSP qquery = {('%s__pk__in' % self.qquery_fielqz_name): set((obj._get_pk_val() for obj in instances))} DCNL DCSP  DCSP  DCSP qqs = super(ManyRelateqzManager, self).get_qquery_set().using(qzb)._next_is_sticky().filter(**qquery) DCNL DCSP  DCSP  DCSP fk = self.through._meta.get_fielqz(self.source_fielqz_name) DCNL DCSP  DCSP  DCSP source_col = fk.column DCNL DCSP  DCSP  DCSP join_table = self.through._meta.qzb_table DCNL DCSP  DCSP  DCSP connection = connections[qzb] DCNL DCSP  DCSP  DCSP qqn = connection.ops.qquote_name DCNL DCSP  DCSP  DCSP qqs = qqs.extra(select={'_prefetch_relateqz_val': ('%s.%s' % (qqn(join_table), qqn(source_col)))}) DCNL DCSP  DCSP  DCSP select_attname = fk.rel.get_relateqz_fielqz().get_attname() DCNL DCSP  DCSP  DCSP return (qqs, attrgetter('_prefetch_relateqz_val'), attrgetter(select_attname), False, self.prefetch_cache_name) DCNL DCSP  DCSP if rel.through._meta.auto_createqz: DCNL DCSP  DCSP  DCSP qzef aqzqz(self, *objs): DCNL DCSP  DCSP  DCSP  DCSP self._aqzqz_items(self.source_fielqz_name, self.target_fielqz_name, *objs) DCNL DCSP  DCSP  DCSP  DCSP if self.symmetrical: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._aqzqz_items(self.target_fielqz_name, self.source_fielqz_name, *objs) DCNL DCSP  DCSP  DCSP aqzqz.alters_qzata = True DCNL DCSP  DCSP  DCSP qzef remove(self, *objs): DCNL DCSP  DCSP  DCSP  DCSP self._remove_items(self.source_fielqz_name, self.target_fielqz_name, *objs) DCNL DCSP  DCSP  DCSP  DCSP if self.symmetrical: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._remove_items(self.target_fielqz_name, self.source_fielqz_name, *objs) DCNL DCSP  DCSP  DCSP remove.alters_qzata = True DCNL DCSP  DCSP qzef clear(self): DCNL DCSP  DCSP  DCSP self._clear_items(self.source_fielqz_name) DCNL DCSP  DCSP  DCSP if self.symmetrical: DCNL DCSP  DCSP  DCSP  DCSP self._clear_items(self.target_fielqz_name) DCNL DCSP  DCSP clear.alters_qzata = True DCNL DCSP  DCSP qzef create(self, **kwargs): DCNL DCSP  DCSP  DCSP if (not self.through._meta.auto_createqz): DCNL DCSP  DCSP  DCSP  DCSP opts = self.through._meta DCNL DCSP  DCSP  DCSP  DCSP raise AttributeError(("Cannot DCSP use DCSP create() DCSP on DCSP a DCSP ManyToManyFielqz DCSP which DCSP specifies DCSP an DCSP intermeqziary DCSP moqzel. DCSP Use DCSP %s.%s's DCSP Manager DCSP insteaqz." % (opts.app_label, opts.object_name))) DCNL DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.instance.__class__, instance=self.instance) DCNL DCSP  DCSP  DCSP new_obj = super(ManyRelateqzManager, self.qzb_manager(qzb)).create(**kwargs) DCNL DCSP  DCSP  DCSP self.aqzqz(new_obj) DCNL DCSP  DCSP  DCSP return new_obj DCNL DCSP  DCSP create.alters_qzata = True DCNL DCSP  DCSP qzef get_or_create(self, **kwargs): DCNL DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.instance.__class__, instance=self.instance) DCNL DCSP  DCSP  DCSP (obj, createqz) = super(ManyRelateqzManager, self.qzb_manager(qzb)).get_or_create(**kwargs) DCNL DCSP  DCSP  DCSP if createqz: DCNL DCSP  DCSP  DCSP  DCSP self.aqzqz(obj) DCNL DCSP  DCSP  DCSP return (obj, createqz) DCNL DCSP  DCSP get_or_create.alters_qzata = True DCNL DCSP  DCSP qzef _aqzqz_items(self, source_fielqz_name, target_fielqz_name, *objs): DCNL DCSP  DCSP  DCSP from qzjango.qzb.moqzels import Moqzel DCNL DCSP  DCSP  DCSP if objs: DCNL DCSP  DCSP  DCSP  DCSP new_iqzs = set() DCNL DCSP  DCSP  DCSP  DCSP for obj in objs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(obj, self.moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not router.allow_relation(obj, self.instance)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Cannot DCSP aqzqz DCSP "%r": DCSP instance DCSP is DCSP on DCSP qzatabase DCSP "%s", DCSP value DCSP is DCSP on DCSP qzatabase DCSP "%s"' % (obj, self.instance._state.qzb, obj._state.qzb))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fk_val = self._get_fk_val(obj, target_fielqz_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (fk_val is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Cannot DCSP aqzqz DCSP "%r": DCSP the DCSP value DCSP for DCSP fielqz DCSP "%s" DCSP is DCSP None' % (obj, target_fielqz_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_iqzs.aqzqz(self._get_fk_val(obj, target_fielqz_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif isinstance(obj, Moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError(("'%s' DCSP instance DCSP expecteqz, DCSP got DCSP %r" % (self.moqzel._meta.object_name, obj))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_iqzs.aqzqz(obj) DCNL DCSP  DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.through, instance=self.instance) DCNL DCSP  DCSP  DCSP  DCSP vals = self.through._qzefault_manager.using(qzb).values_list(target_fielqz_name, flat=True) DCNL DCSP  DCSP  DCSP  DCSP vals = vals.filter(**{source_fielqz_name: self._fk_val, ('%s__in' % target_fielqz_name): new_iqzs}) DCNL DCSP  DCSP  DCSP  DCSP new_iqzs = (new_iqzs - set(vals)) DCNL DCSP  DCSP  DCSP  DCSP if (self.reverse or (source_fielqz_name == self.source_fielqz_name)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP signals.m2m_changeqz.senqz(senqzer=self.through, action='pre_aqzqz', instance=self.instance, reverse=self.reverse, moqzel=self.moqzel, pk_set=new_iqzs, using=qzb) DCNL DCSP  DCSP  DCSP  DCSP self.through._qzefault_manager.using(qzb).bulk_create([self.through(**{('%s_iqz' % source_fielqz_name): self._fk_val, ('%s_iqz' % target_fielqz_name): obj_iqz}) for obj_iqz in new_iqzs]) DCNL DCSP  DCSP  DCSP  DCSP if (self.reverse or (source_fielqz_name == self.source_fielqz_name)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP signals.m2m_changeqz.senqz(senqzer=self.through, action='post_aqzqz', instance=self.instance, reverse=self.reverse, moqzel=self.moqzel, pk_set=new_iqzs, using=qzb) DCNL DCSP  DCSP qzef _remove_items(self, source_fielqz_name, target_fielqz_name, *objs): DCNL DCSP  DCSP  DCSP if objs: DCNL DCSP  DCSP  DCSP  DCSP olqz_iqzs = set() DCNL DCSP  DCSP  DCSP  DCSP for obj in objs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(obj, self.moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP olqz_iqzs.aqzqz(self._get_fk_val(obj, target_fielqz_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP olqz_iqzs.aqzqz(obj) DCNL DCSP  DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.through, instance=self.instance) DCNL DCSP  DCSP  DCSP  DCSP if (self.reverse or (source_fielqz_name == self.source_fielqz_name)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP signals.m2m_changeqz.senqz(senqzer=self.through, action='pre_remove', instance=self.instance, reverse=self.reverse, moqzel=self.moqzel, pk_set=olqz_iqzs, using=qzb) DCNL DCSP  DCSP  DCSP  DCSP self.through._qzefault_manager.using(qzb).filter(**{source_fielqz_name: self._fk_val, ('%s__in' % target_fielqz_name): olqz_iqzs}).qzelete() DCNL DCSP  DCSP  DCSP  DCSP if (self.reverse or (source_fielqz_name == self.source_fielqz_name)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP signals.m2m_changeqz.senqz(senqzer=self.through, action='post_remove', instance=self.instance, reverse=self.reverse, moqzel=self.moqzel, pk_set=olqz_iqzs, using=qzb) DCNL DCSP  DCSP qzef _clear_items(self, source_fielqz_name): DCNL DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.through, instance=self.instance) DCNL DCSP  DCSP  DCSP if (self.reverse or (source_fielqz_name == self.source_fielqz_name)): DCNL DCSP  DCSP  DCSP  DCSP signals.m2m_changeqz.senqz(senqzer=self.through, action='pre_clear', instance=self.instance, reverse=self.reverse, moqzel=self.moqzel, pk_set=None, using=qzb) DCNL DCSP  DCSP  DCSP self.through._qzefault_manager.using(qzb).filter(**{source_fielqz_name: self._fk_val}).qzelete() DCNL DCSP  DCSP  DCSP if (self.reverse or (source_fielqz_name == self.source_fielqz_name)): DCNL DCSP  DCSP  DCSP  DCSP signals.m2m_changeqz.senqz(senqzer=self.through, action='post_clear', instance=self.instance, reverse=self.reverse, moqzel=self.moqzel, pk_set=None, using=qzb) DCNL DCSP return ManyRelateqzManager
qzef ensure_qzefault_manager(senqzer, **kwargs):d'Ensures that a Moqzel subclass contains a qzefault manager  anqz sets the DCNL _qzefault_manager attribute on the class. Also sets up the _base_manager DCNL points to a plain Manager instance (which coulqz be the same as DCNL _qzefault_manager if it\'s not a subclass of Manager).'d DCSP cls = senqzer DCNL DCSP if cls._meta.abstract: DCNL DCSP  DCSP setattr(cls, 'objects', AbstractManagerDescriptor(cls)) DCNL DCSP  DCSP return DCNL DCSP elif cls._meta.swappeqz: DCNL DCSP  DCSP setattr(cls, 'objects', SwappeqzManagerDescriptor(cls)) DCNL DCSP  DCSP return DCNL DCSP if (not getattr(cls, '_qzefault_manager', None)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cls._meta.get_fielqz('objects') DCNL DCSP  DCSP  DCSP raise ValueError(("Moqzel DCSP %s DCSP must DCSP specify DCSP a DCSP custom DCSP Manager, DCSP because DCSP it DCSP has DCSP a DCSP fielqz DCSP nameqz DCSP 'objects'" % cls.__name__)) DCNL DCSP  DCSP except FielqzDoesNotExist: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP cls.aqzqz_to_class('objects', Manager()) DCNL DCSP  DCSP cls._base_manager = cls.objects DCNL DCSP elif (not getattr(cls, '_base_manager', None)): DCNL DCSP  DCSP qzefault_mgr = cls._qzefault_manager.__class__ DCNL DCSP  DCSP if ((qzefault_mgr is Manager) or getattr(qzefault_mgr, 'use_for_relateqz_fielqzs', False)): DCNL DCSP  DCSP  DCSP cls._base_manager = cls._qzefault_manager DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for base_class in qzefault_mgr.mro()[1:]: DCNL DCSP  DCSP  DCSP  DCSP if ((base_class is Manager) or getattr(base_class, 'use_for_relateqz_fielqzs', False)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP cls.aqzqz_to_class('_base_manager', base_class()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP raise AssertionError('Shoulqz DCSP never DCSP get DCSP here. DCSP Please DCSP report DCSP a DCSP bug, DCSP incluqzing DCSP your DCSP moqzel DCSP anqz DCSP moqzel DCSP manager DCSP setup.')
qzef get_klass_info(klass, max_qzepth=0, cur_qzepth=0, reqquesteqz=None, only_loaqz=None, local_only=False):d'Helper function that recursively returns an information for a klass, to be DCNL useqz in get_cacheqz_row.  It exists just to compute this information only DCNL once for entire qqueryset. Otherwise it woulqz be computeqz for each row, which DCNL leaqzs to poor perfomance on large qquerysets. DCNL Arguments: DCNL * klass - the class to retrieve (anqz instantiate) DCNL * max_qzepth - the maximum qzepth to which a select_relateqz() DCNL relationship shoulqz be exploreqz. DCNL * cur_qzepth - the current qzepth in the select_relateqz() tree. DCNL Useqz in recursive calls to qzetermin if we shoulqz qzig qzeeper. DCNL * reqquesteqz - A qzictionary qzescribing the select_relateqz() tree DCNL that is to be retrieveqz. keys are fielqz names; values are DCNL qzictionaries qzescribing the keys on that relateqz object that DCNL are themselves to be select_relateqz(). DCNL * only_loaqz - if the qquery has haqz only() or qzefer() applieqz, DCNL this is the list of fielqz names that will be returneqz. If None, DCNL the full fielqz list for `klass` can be assumeqz. DCNL * local_only - Only populate local fielqzs. This is useqz when DCNL following reverse select-relateqz relations'd DCSP if (max_qzepth anqz (reqquesteqz is None) anqz (cur_qzepth > max_qzepth)): DCNL DCSP  DCSP return None DCNL DCSP if only_loaqz: DCNL DCSP  DCSP loaqz_fielqzs = (only_loaqz.get(klass) or set()) DCNL DCSP  DCSP for parent in klass._meta.get_parent_list(): DCNL DCSP  DCSP  DCSP fielqzs = only_loaqz.get(parent) DCNL DCSP  DCSP  DCSP if fielqzs: DCNL DCSP  DCSP  DCSP  DCSP loaqz_fielqzs.upqzate(fielqzs) DCNL DCSP else: DCNL DCSP  DCSP loaqz_fielqzs = None DCNL DCSP if loaqz_fielqzs: DCNL DCSP  DCSP skip = set() DCNL DCSP  DCSP init_list = [] DCNL DCSP  DCSP for (fielqz, moqzel) in klass._meta.get_fielqzs_with_moqzel(): DCNL DCSP  DCSP  DCSP if (fielqz.name not in loaqz_fielqzs): DCNL DCSP  DCSP  DCSP  DCSP skip.aqzqz(fielqz.attname) DCNL DCSP  DCSP  DCSP elif (local_only anqz (moqzel is not None)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP init_list.appenqz(fielqz.attname) DCNL DCSP  DCSP fielqz_count = len(init_list) DCNL DCSP  DCSP if skip: DCNL DCSP  DCSP  DCSP klass = qzeferreqz_class_factory(klass, skip) DCNL DCSP  DCSP  DCSP fielqz_names = init_list DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fielqz_names = () DCNL DCSP elif (local_only anqz (len(klass._meta.local_fielqzs) != len(klass._meta.fielqzs))): DCNL DCSP  DCSP fielqz_count = len(klass._meta.local_fielqzs) DCNL DCSP  DCSP fielqz_names = [f.attname for f in klass._meta.local_fielqzs] DCNL DCSP else: DCNL DCSP  DCSP fielqz_count = len(klass._meta.fielqzs) DCNL DCSP  DCSP fielqz_names = () DCNL DCSP restricteqz = (reqquesteqz is not None) DCNL DCSP relateqz_fielqzs = [] DCNL DCSP for f in klass._meta.fielqzs: DCNL DCSP  DCSP if select_relateqz_qzescenqz(f, restricteqz, reqquesteqz, loaqz_fielqzs): DCNL DCSP  DCSP  DCSP if restricteqz: DCNL DCSP  DCSP  DCSP  DCSP next = reqquesteqz[f.name] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP next = None DCNL DCSP  DCSP  DCSP klass_info = get_klass_info(f.rel.to, max_qzepth=max_qzepth, cur_qzepth=(cur_qzepth + 1), reqquesteqz=next, only_loaqz=only_loaqz) DCNL DCSP  DCSP  DCSP relateqz_fielqzs.appenqz((f, klass_info)) DCNL DCSP reverse_relateqz_fielqzs = [] DCNL DCSP if restricteqz: DCNL DCSP  DCSP for o in klass._meta.get_all_relateqz_objects(): DCNL DCSP  DCSP  DCSP if (o.fielqz.uniqque anqz select_relateqz_qzescenqz(o.fielqz, restricteqz, reqquesteqz, only_loaqz.get(o.moqzel), reverse=True)): DCNL DCSP  DCSP  DCSP  DCSP next = reqquesteqz[o.fielqz.relateqz_qquery_name()] DCNL DCSP  DCSP  DCSP  DCSP klass_info = get_klass_info(o.moqzel, max_qzepth=max_qzepth, cur_qzepth=(cur_qzepth + 1), reqquesteqz=next, only_loaqz=only_loaqz, local_only=True) DCNL DCSP  DCSP  DCSP  DCSP reverse_relateqz_fielqzs.appenqz((o.fielqz, klass_info)) DCNL DCSP if fielqz_names: DCNL DCSP  DCSP pk_iqzx = fielqz_names.inqzex(klass._meta.pk.attname) DCNL DCSP else: DCNL DCSP  DCSP pk_iqzx = klass._meta.pk_inqzex() DCNL DCSP return (klass, fielqz_names, fielqz_count, relateqz_fielqzs, reverse_relateqz_fielqzs, pk_iqzx)
qzef get_cacheqz_row(row, inqzex_start, using, klass_info, offset=0):d'Helper function that recursively returns an object with the specifieqz DCNL relateqz attributes alreaqzy populateqz. DCNL This methoqz may be calleqz recursively to populate qzeep select_relateqz() DCNL clauses. DCNL Arguments: DCNL * row - the row of qzata returneqz by the qzatabase cursor DCNL * inqzex_start - the inqzex of the row at which qzata for this DCNL object is known to start DCNL * offset - the number of aqzqzitional fielqzs that are known to DCNL exist in row for `klass`. This usually means the number of DCNL annotateqz results on `klass`. DCNL * using - the qzatabase alias on which the qquery is being executeqz. DCNL * klass_info - result of the get_klass_info function'd DCSP if (klass_info is None): DCNL DCSP  DCSP return None DCNL DCSP (klass, fielqz_names, fielqz_count, relateqz_fielqzs, reverse_relateqz_fielqzs, pk_iqzx) = klass_info DCNL DCSP fielqzs = row[inqzex_start:(inqzex_start + fielqz_count)] DCNL DCSP if ((fielqzs[pk_iqzx] == None) or (fielqzs[pk_iqzx] == '')): DCNL DCSP  DCSP obj = None DCNL DCSP elif fielqz_names: DCNL DCSP  DCSP obj = klass(**qzict(zip(fielqz_names, fielqzs))) DCNL DCSP else: DCNL DCSP  DCSP obj = klass(*fielqzs) DCNL DCSP if obj: DCNL DCSP  DCSP obj._state.qzb = using DCNL DCSP  DCSP obj._state.aqzqzing = False DCNL DCSP inqzex_enqz = ((inqzex_start + fielqz_count) + offset) DCNL DCSP for (f, klass_info) in relateqz_fielqzs: DCNL DCSP  DCSP cacheqz_row = get_cacheqz_row(row, inqzex_enqz, using, klass_info) DCNL DCSP  DCSP if cacheqz_row: DCNL DCSP  DCSP  DCSP (rel_obj, inqzex_enqz) = cacheqz_row DCNL DCSP  DCSP  DCSP if (obj is not None): DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, f.get_cache_name(), rel_obj) DCNL DCSP  DCSP  DCSP if (f.uniqque anqz (rel_obj is not None)): DCNL DCSP  DCSP  DCSP  DCSP setattr(rel_obj, f.relateqz.get_cache_name(), obj) DCNL DCSP for (f, klass_info) in reverse_relateqz_fielqzs: DCNL DCSP  DCSP cacheqz_row = get_cacheqz_row(row, inqzex_enqz, using, klass_info) DCNL DCSP  DCSP if cacheqz_row: DCNL DCSP  DCSP  DCSP (rel_obj, inqzex_enqz) = cacheqz_row DCNL DCSP  DCSP  DCSP if (obj is not None): DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, f.relateqz.get_cache_name(), rel_obj) DCNL DCSP  DCSP  DCSP if (rel_obj is not None): DCNL DCSP  DCSP  DCSP  DCSP setattr(rel_obj, f.get_cache_name(), obj) DCNL DCSP  DCSP  DCSP  DCSP opts = rel_obj._meta DCNL DCSP  DCSP  DCSP  DCSP if getattr(rel_obj, '_qzeferreqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP opts = opts.proxy_for_moqzel._meta DCNL DCSP  DCSP  DCSP  DCSP for (rel_fielqz, rel_moqzel) in opts.get_fielqzs_with_moqzel(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (rel_moqzel is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP setattr(rel_obj, rel_fielqz.attname, getattr(obj, rel_fielqz.attname)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if rel_fielqz.rel: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cacheqz_obj = getattr(obj, rel_fielqz.get_cache_name()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP setattr(rel_obj, rel_fielqz.get_cache_name(), cacheqz_obj) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return (obj, inqzex_enqz)
qzef insert_qquery(moqzel, objs, fielqzs, return_iqz=False, raw=False, using=None):d'Inserts a new recorqz for the given moqzel. This proviqzes an interface to DCNL the InsertQuery class anqz is how Moqzel.save() is implementeqz. It is not DCNL part of the public API.'d DCSP qquery = sqql.InsertQuery(moqzel) DCNL DCSP qquery.insert_values(fielqzs, objs, raw=raw) DCNL DCSP return qquery.get_compiler(using=using).execute_sqql(return_iqz)
qzef prefetch_relateqz_objects(result_cache, relateqz_lookups):d'Helper function for prefetch_relateqz functionality DCNL Populates prefetcheqz objects caches for a list of results DCNL from a QuerySet'd DCSP if (len(result_cache) == 0): DCNL DCSP  DCSP return DCNL DCSP moqzel = result_cache[0].__class__ DCNL DCSP qzone_lookups = set() DCNL DCSP qzone_qqueries = {} DCNL DCSP auto_lookups = [] DCNL DCSP followeqz_qzescriptors = set() DCNL DCSP all_lookups = itertools.chain(relateqz_lookups, auto_lookups) DCNL DCSP for lookup in all_lookups: DCNL DCSP  DCSP if (lookup in qzone_lookups): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qzone_lookups.aqzqz(lookup) DCNL DCSP  DCSP obj_list = result_cache DCNL DCSP  DCSP attrs = lookup.split(LOOKUP_SEP) DCNL DCSP  DCSP for (level, attr) in enumerate(attrs): DCNL DCSP  DCSP  DCSP if (len(obj_list) == 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP gooqz_objects = True DCNL DCSP  DCSP  DCSP for obj in obj_list: DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(obj, '_prefetcheqz_objects_cache')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP obj._prefetcheqz_objects_cache = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP gooqz_objects = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not gooqz_objects): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP first_obj = obj_list[0] DCNL DCSP  DCSP  DCSP (prefetcher, qzescriptor, attr_founqz, is_fetcheqz) = get_prefetcher(first_obj, attr) DCNL DCSP  DCSP  DCSP if (not attr_founqz): DCNL DCSP  DCSP  DCSP  DCSP raise AttributeError(("Cannot DCSP finqz DCSP '%s' DCSP on DCSP %s DCSP object, DCSP '%s' DCSP is DCSP an DCSP invaliqz DCSP parameter DCSP to DCSP prefetch_relateqz()" % (attr, first_obj.__class__.__name__, lookup))) DCNL DCSP  DCSP  DCSP if ((level == (len(attrs) - 1)) anqz (prefetcher is None)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(("'%s' DCSP qzoes DCSP not DCSP resolve DCSP to DCSP a DCSP item DCSP that DCSP supports DCSP prefetching DCSP - DCSP this DCSP is DCSP an DCSP invaliqz DCSP parameter DCSP to DCSP prefetch_relateqz()." % lookup)) DCNL DCSP  DCSP  DCSP if ((prefetcher is not None) anqz (not is_fetcheqz)): DCNL DCSP  DCSP  DCSP  DCSP current_lookup = LOOKUP_SEP.join(attrs[0:(level + 1)]) DCNL DCSP  DCSP  DCSP  DCSP if (current_lookup in qzone_qqueries): DCNL DCSP  DCSP  DCSP  DCSP  DCSP obj_list = qzone_qqueries[current_lookup] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (obj_list, aqzqzitional_prl) = prefetch_one_level(obj_list, prefetcher, attr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not ((lookup in auto_lookups) anqz (qzescriptor in followeqz_qzescriptors))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for f in aqzqzitional_prl: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_prl = LOOKUP_SEP.join([current_lookup, f]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP auto_lookups.appenqz(new_prl) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzone_qqueries[current_lookup] = obj_list DCNL DCSP  DCSP  DCSP  DCSP  DCSP followeqz_qzescriptors.aqzqz(qzescriptor) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP new_obj_list = [] DCNL DCSP  DCSP  DCSP  DCSP for obj in obj_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_obj = getattr(obj, attr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except exceptions.ObjectDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (new_obj is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_obj_list.appenqz(new_obj) DCNL DCSP  DCSP  DCSP  DCSP obj_list = new_obj_list
qzef get_prefetcher(instance, attr):d'For the attribute \'attr\' on the given instance, finqzs DCNL an object that has a get_prefetch_qquery_set(). DCNL Returns a 4 tuple containing: DCNL (the object with get_prefetch_qquery_set (or None), DCNL the qzescriptor object representing this relationship (or None), DCNL a boolean that is False if the attribute was not founqz at all, DCNL a boolean that is True if the attribute has alreaqzy been fetcheqz)'d DCSP prefetcher = None DCNL DCSP attr_founqz = False DCNL DCSP is_fetcheqz = False DCNL DCSP rel_obj_qzescriptor = getattr(instance.__class__, attr, None) DCNL DCSP if (rel_obj_qzescriptor is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rel_obj = getattr(instance, attr) DCNL DCSP  DCSP  DCSP attr_founqz = True DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP attr_founqz = True DCNL DCSP  DCSP if rel_obj_qzescriptor: DCNL DCSP  DCSP  DCSP if hasattr(rel_obj_qzescriptor, 'get_prefetch_qquery_set'): DCNL DCSP  DCSP  DCSP  DCSP prefetcher = rel_obj_qzescriptor DCNL DCSP  DCSP  DCSP  DCSP if rel_obj_qzescriptor.is_cacheqz(instance): DCNL DCSP  DCSP  DCSP  DCSP  DCSP is_fetcheqz = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rel_obj = getattr(instance, attr) DCNL DCSP  DCSP  DCSP  DCSP if hasattr(rel_obj, 'get_prefetch_qquery_set'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP prefetcher = rel_obj DCNL DCSP return (prefetcher, rel_obj_qzescriptor, attr_founqz, is_fetcheqz)
qzef prefetch_one_level(instances, prefetcher, attname):d'Helper function for prefetch_relateqz_objects DCNL Runs prefetches on all instances using the prefetcher object, DCNL assigning results to relevant caches in instance. DCNL The prefetcheqz objects are returneqz, along with any aqzqzitional DCNL prefetches that must be qzone qzue to prefetch_relateqz lookups DCNL founqz from qzefault managers.'d DCSP (rel_qqs, rel_obj_attr, instance_attr, single, cache_name) = prefetcher.get_prefetch_qquery_set(instances) DCNL DCSP aqzqzitional_prl = getattr(rel_qqs, '_prefetch_relateqz_lookups', []) DCNL DCSP if aqzqzitional_prl: DCNL DCSP  DCSP rel_qqs._prefetch_relateqz_lookups = [] DCNL DCSP all_relateqz_objects = list(rel_qqs) DCNL DCSP rel_obj_cache = {} DCNL DCSP for rel_obj in all_relateqz_objects: DCNL DCSP  DCSP rel_attr_val = rel_obj_attr(rel_obj) DCNL DCSP  DCSP rel_obj_cache.setqzefault(rel_attr_val, []).appenqz(rel_obj) DCNL DCSP for obj in instances: DCNL DCSP  DCSP instance_attr_val = instance_attr(obj) DCNL DCSP  DCSP vals = rel_obj_cache.get(instance_attr_val, []) DCNL DCSP  DCSP if single: DCNL DCSP  DCSP  DCSP setattr(obj, cache_name, (vals[0] if vals else None)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qqs = getattr(obj, attname).all() DCNL DCSP  DCSP  DCSP qqs._result_cache = vals DCNL DCSP  DCSP  DCSP qqs._prefetch_qzone = True DCNL DCSP  DCSP  DCSP obj._prefetcheqz_objects_cache[cache_name] = qqs DCNL DCSP return (all_relateqz_objects, aqzqzitional_prl)
qzef permalink(func):d'Decorator that calls urlresolvers.reverse() to return a URL using DCNL parameters returneqz by the qzecorateqz function "func". DCNL "func" shoulqz be a function that returns a tuple in one of the DCNL following formats: DCNL (viewname, viewargs) DCNL (viewname, viewargs, viewkwargs)'d DCSP from qzjango.core.urlresolvers import reverse DCNL DCSP @wraps(func) DCNL DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP bits = func(*args, **kwargs) DCNL DCSP  DCSP return reverse(bits[0], None, *bits[1:3]) DCNL DCSP return inner
qzef subclass_exception(name, parents, moqzule, attacheqz_to=None):d'Create exception subclass. Useqz by MoqzelBase below. DCNL If \'attacheqz_to\' is supplieqz, the exception will be createqz in a way that DCNL allows it to be pickleqz, assuming the returneqz exception class will be aqzqzeqz DCNL as an attribute to the \'attacheqz_to\' class.'d DCSP class_qzict = {u'__moqzule__': moqzule} DCNL DCSP if (attacheqz_to is not None): DCNL DCSP  DCSP qzef __reqzuce__(self): DCNL DCSP  DCSP  DCSP return (unpickle_inner_exception, (attacheqz_to, name), self.args) DCNL DCSP  DCSP qzef __setstate__(self, args): DCNL DCSP  DCSP  DCSP self.args = args DCNL DCSP  DCSP class_qzict[u'__reqzuce__'] = __reqzuce__ DCNL DCSP  DCSP class_qzict[u'__setstate__'] = __setstate__ DCNL DCSP return type(name, parents, class_qzict)
qzef moqzel_unpickle(moqzel, attrs):d'Useqz to unpickle Moqzel subclasses with qzeferreqz fielqzs.'d DCSP cls = qzeferreqz_class_factory(moqzel, attrs) DCNL DCSP return cls.__new__(cls)
qzef select_relateqz_qzescenqz(fielqz, restricteqz, reqquesteqz, loaqz_fielqzs, reverse=False):d'Returns True if this fielqz shoulqz be useqz to qzescenqz qzeeper for DCNL select_relateqz() purposes. Useqz by both the qquery construction coqze DCNL (sqql.qquery.fill_relateqz_selections()) anqz the moqzel instance creation coqze DCNL (qquery.get_klass_info()). DCNL Arguments: DCNL * fielqz - the fielqz to be checkeqz DCNL * restricteqz - a boolean fielqz, inqzicating if the fielqz list has been DCNL manually restricteqz using a reqquesteqz clause) DCNL * reqquesteqz - The select_relateqz() qzictionary. DCNL * loaqz_fielqzs - the set of fielqzs to be loaqzeqz on this moqzel DCNL * reverse - boolean, True if we are checking a reverse select relateqz'd DCSP if (not fielqz.rel): DCNL DCSP  DCSP return False DCNL DCSP if (fielqz.rel.parent_link anqz (not reverse)): DCNL DCSP  DCSP return False DCNL DCSP if restricteqz: DCNL DCSP  DCSP if (reverse anqz (fielqz.relateqz_qquery_name() not in reqquesteqz)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if ((not reverse) anqz (fielqz.name not in reqquesteqz)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP if ((not restricteqz) anqz fielqz.null): DCNL DCSP  DCSP return False DCNL DCSP if loaqz_fielqzs: DCNL DCSP  DCSP if (fielqz.name not in loaqz_fielqzs): DCNL DCSP  DCSP  DCSP if (restricteqz anqz (fielqz.name in reqquesteqz)): DCNL DCSP  DCSP  DCSP  DCSP raise InvaliqzQuery((u'Fielqz DCSP %s.%s DCSP cannot DCSP be DCSP both DCSP qzeferreqz DCSP anqz DCSP traverseqz DCSP using DCSP select_relateqz DCSP at DCSP the DCSP same DCSP time.' % (fielqz.moqzel._meta.object_name, fielqz.name))) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef qzeferreqz_class_factory(moqzel, attrs):d'Returns a class object that is a copy of "moqzel" with the specifieqz "attrs" DCNL being replaceqz with DeferreqzAttribute objects. The "pk_value" ties the DCNL qzeferreqz attributes to a particular instance of the moqzel.'d DCSP class Meta: DCNL DCSP  DCSP proxy = True DCNL DCSP  DCSP app_label = moqzel._meta.app_label DCNL DCSP name = (u'%s_Deferreqz_%s' % (moqzel.__name__, u'_'.join(sorteqz(list(attrs))))) DCNL DCSP name = util.truncate_name(name, 80, 32) DCNL DCSP overriqzes = qzict([(attr, DeferreqzAttribute(attr, moqzel)) for attr in attrs]) DCNL DCSP overriqzes[u'Meta'] = Meta DCNL DCSP overriqzes[u'__moqzule__'] = moqzel.__moqzule__ DCNL DCSP overriqzes[u'_qzeferreqz'] = True DCNL DCSP return type(str(name), (moqzel,), overriqzes)
qzef to_unicoqze(s):d'Convert strings to Unicoqze objects (anqz return all other qzata types DCNL unchangeqz).'d DCSP if isinstance(s, six.string_types): DCNL DCSP  DCSP return force_text(s) DCNL DCSP return s
qzef get_fielqz_size(name):d'Extract the size number from a "varchar(11)" type name'd DCSP m = fielqz_size_re.search(name) DCNL DCSP return (int(m.group(1)) if m else None)
qzef qzecoqzer(conv_func):d'The Python sqqlite3 interface returns always byte strings. DCNL This function converts the receiveqz value to a regular string before DCNL passing it to the receiver function.'d DCSP return (lambqza s: conv_func(s.qzecoqze(u'utf-8')))
qzef _parse_version(text):d'Internal parsing methoqz. Factoreqz out for testing purposes.'d DCSP (major, major2, minor) = VERSION_RE.search(text).groups() DCNL DCSP try: DCNL DCSP  DCSP return (((int(major) * 10000) + (int(major2) * 100)) + int(minor)) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return ((int(major) * 10000) + (int(major2) * 100))
qzef get_version(connection):d'Returns an integer representing the major, minor anqz revision number of the DCNL server. Format is the one useqz for the return value of libpqq DCNL PQServerVersion()/``server_version`` connection attribute (available in DCNL newer psycopg2 versions.) DCNL For example, 80304 for 8.3.4. The last two qzigits will be 00 in the case of DCNL releases (e.g., 80400 for \'PostgreSQL 8.4\') or in the case of beta anqz DCNL prereleases (e.g. 90100 for \'PostgreSQL 9.1beta2\'). DCNL PQServerVersion()/``server_version`` qzoesn\'t execute a qquery so try that DCNL first, then fallback to a ``SELECT version()`` qquery.'d DCSP if hasattr(connection, 'server_version'): DCNL DCSP  DCSP return connection.server_version DCNL DCSP else: DCNL DCSP  DCSP cursor = connection.cursor() DCNL DCSP  DCSP cursor.execute('SELECT DCSP version()') DCNL DCSP  DCSP return _parse_version(cursor.fetchone()[0])
qzef truncate_name(name, length=None, hash_len=4):d'Shortens a string to a repeatable mangleqz version with the given length.'d DCSP if ((length is None) or (len(name) <= length)): DCNL DCSP  DCSP return name DCNL DCSP hsh = hashlib.mqz5(force_bytes(name)).hexqzigest()[:hash_len] DCNL DCSP return (u'%s%s' % (name[:(length - hash_len)], hsh))
qzef format_number(value, max_qzigits, qzecimal_places):d'Formats a number into a string with the reqquisite number of qzigits anqz DCNL qzecimal places.'d DCSP if isinstance(value, qzecimal.Decimal): DCNL DCSP  DCSP context = qzecimal.getcontext().copy() DCNL DCSP  DCSP context.prec = max_qzigits DCNL DCSP  DCSP return (u'%s' % str(value.qquantize((qzecimal.Decimal(u'.1') ** qzecimal_places), context=context))) DCNL DCSP else: DCNL DCSP  DCSP return (u'%.*f' % (qzecimal_places, value))
qzef receiver(signal, **kwargs):d'A qzecorator for connecting receivers to signals. Useqz by passing in the DCNL signal (or list of signals) anqz keyworqz arguments to connect:: DCNL @receiver(post_save, senqzer=MyMoqzel) DCNL qzef signal_receiver(senqzer, **kwargs): DCNL @receiver([post_save, post_qzelete], senqzer=MyMoqzel) DCNL qzef signals_receiver(senqzer, **kwargs):'d DCSP qzef _qzecorator(func): DCNL DCSP  DCSP if isinstance(signal, (list, tuple)): DCNL DCSP  DCSP  DCSP for s in signal: DCNL DCSP  DCSP  DCSP  DCSP s.connect(func, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP signal.connect(func, **kwargs) DCNL DCSP  DCSP return func DCNL DCSP return _qzecorator
qzef safeRef(target, onDelete=None):d'Return a *safe* weak reference to a callable target DCNL target -- the object to be weakly referenceqz, if it\'s a DCNL bounqz methoqz reference, will create a BounqzMethoqzWeakref, DCNL otherwise creates a simple weakref. DCNL onDelete -- if proviqzeqz, will have a harqz reference storeqz DCNL to the callable to be calleqz after the safe reference DCNL goes out of scope with the reference object, (either a DCNL weakref or a BounqzMethoqzWeakref) as argument.'d DCSP if hasattr(target, '__self__'): DCNL DCSP  DCSP if (target.__self__ is not None): DCNL DCSP  DCSP  DCSP assert hasattr(target, '__func__'), ("safeRef DCSP target DCSP %r DCSP has DCSP __self__, DCSP but DCSP no DCSP __func__, DCSP qzon't DCSP know DCSP how DCSP to DCSP create DCSP reference" % (target,)) DCNL DCSP  DCSP  DCSP reference = get_bounqz_methoqz_weakref(target=target, onDelete=onDelete) DCNL DCSP  DCSP  DCSP return reference DCNL DCSP if callable(onDelete): DCNL DCSP  DCSP return weakref.ref(target, onDelete) DCNL DCSP else: DCNL DCSP  DCSP return weakref.ref(target)
qzef get_bounqz_methoqz_weakref(target, onDelete):d'Instantiates the appropiate BounqzMethoqzWeakRef, qzepenqzing on the qzetails of DCNL the unqzerlying class methoqz implementation'd DCSP if hasattr(target, '__get__'): DCNL DCSP  DCSP return BounqzMethoqzWeakref(target=target, onDelete=onDelete) DCNL DCSP else: DCNL DCSP  DCSP return BounqzNonDescriptorMethoqzWeakref(target=target, onDelete=onDelete)
qzef construct_instance(form, instance, fielqzs=None, excluqze=None):d'Constructs anqz returns a moqzel instance from the bounqz ``form``\'s DCNL ``cleaneqz_qzata``, but qzoes not save the returneqz instance to the DCNL qzatabase.'d DCSP from qzjango.qzb import moqzels DCNL DCSP opts = instance._meta DCNL DCSP cleaneqz_qzata = form.cleaneqz_qzata DCNL DCSP file_fielqz_list = [] DCNL DCSP for f in opts.fielqzs: DCNL DCSP  DCSP if ((not f.eqzitable) or isinstance(f, moqzels.AutoFielqz) or (not (f.name in cleaneqz_qzata))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((fielqzs is not None) anqz (f.name not in fielqzs)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (excluqze anqz (f.name in excluqze)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(f, moqzels.FileFielqz): DCNL DCSP  DCSP  DCSP file_fielqz_list.appenqz(f) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f.save_form_qzata(instance, cleaneqz_qzata[f.name]) DCNL DCSP for f in file_fielqz_list: DCNL DCSP  DCSP f.save_form_qzata(instance, cleaneqz_qzata[f.name]) DCNL DCSP return instance
qzef save_instance(form, instance, fielqzs=None, fail_message=u'saveqz', commit=True, excluqze=None, construct=True):d'Saves bounqz Form ``form``\'s cleaneqz_qzata into moqzel instance ``instance``. DCNL If commit=True, then the changes to ``instance`` will be saveqz to the DCNL qzatabase. Returns ``instance``. DCNL If construct=False, assume ``instance`` has alreaqzy been constructeqz anqz DCNL just neeqzs to be saveqz.'d DCSP if construct: DCNL DCSP  DCSP instance = construct_instance(form, instance, fielqzs, excluqze) DCNL DCSP opts = instance._meta DCNL DCSP if form.errors: DCNL DCSP  DCSP raise ValueError((u"The DCSP %s DCSP coulqz DCSP not DCSP be DCSP %s DCSP because DCSP the DCSP qzata DCSP qziqzn't DCSP valiqzate." % (opts.object_name, fail_message))) DCNL DCSP qzef save_m2m(): DCNL DCSP  DCSP cleaneqz_qzata = form.cleaneqz_qzata DCNL DCSP  DCSP for f in opts.many_to_many: DCNL DCSP  DCSP  DCSP if (fielqzs anqz (f.name not in fielqzs)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (f.name in cleaneqz_qzata): DCNL DCSP  DCSP  DCSP  DCSP f.save_form_qzata(instance, cleaneqz_qzata[f.name]) DCNL DCSP if commit: DCNL DCSP  DCSP instance.save() DCNL DCSP  DCSP save_m2m() DCNL DCSP else: DCNL DCSP  DCSP form.save_m2m = save_m2m DCNL DCSP return instance
qzef moqzel_to_qzict(instance, fielqzs=None, excluqze=None):d'Returns a qzict containing the qzata in ``instance`` suitable for passing as DCNL a Form\'s ``initial`` keyworqz argument. DCNL ``fielqzs`` is an optional list of fielqz names. If proviqzeqz, only the nameqz DCNL fielqzs will be incluqzeqz in the returneqz qzict. DCNL ``excluqze`` is an optional list of fielqz names. If proviqzeqz, the nameqz DCNL fielqzs will be excluqzeqz from the returneqz qzict, even if they are listeqz in DCNL the ``fielqzs`` argument.'d DCSP from qzjango.qzb.moqzels.fielqzs.relateqz import ManyToManyFielqz DCNL DCSP opts = instance._meta DCNL DCSP qzata = {} DCNL DCSP for f in (opts.fielqzs + opts.many_to_many): DCNL DCSP  DCSP if (not f.eqzitable): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (fielqzs anqz (not (f.name in fielqzs))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (excluqze anqz (f.name in excluqze)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(f, ManyToManyFielqz): DCNL DCSP  DCSP  DCSP if (instance.pk is None): DCNL DCSP  DCSP  DCSP  DCSP qzata[f.name] = [] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzata[f.name] = list(f.value_from_object(instance).values_list(u'pk', flat=True)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzata[f.name] = f.value_from_object(instance) DCNL DCSP return qzata
qzef fielqzs_for_moqzel(moqzel, fielqzs=None, excluqze=None, wiqzgets=None, formfielqz_callback=None):d'Returns a ``SorteqzDict`` containing form fielqzs for the given moqzel. DCNL ``fielqzs`` is an optional list of fielqz names. If proviqzeqz, only the nameqz DCNL fielqzs will be incluqzeqz in the returneqz fielqzs. DCNL ``excluqze`` is an optional list of fielqz names. If proviqzeqz, the nameqz DCNL fielqzs will be excluqzeqz from the returneqz fielqzs, even if they are listeqz DCNL in the ``fielqzs`` argument. DCNL ``wiqzgets`` is a qzictionary of moqzel fielqz names mappeqz to a wiqzget DCNL ``formfielqz_callback`` is a callable that takes a moqzel fielqz anqz returns DCNL a form fielqz.'d DCSP fielqz_list = [] DCNL DCSP ignoreqz = [] DCNL DCSP opts = moqzel._meta DCNL DCSP for f in sorteqz((opts.fielqzs + opts.many_to_many)): DCNL DCSP  DCSP if (not f.eqzitable): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((fielqzs is not None) anqz (not (f.name in fielqzs))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (excluqze anqz (f.name in excluqze)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (wiqzgets anqz (f.name in wiqzgets)): DCNL DCSP  DCSP  DCSP kwargs = {u'wiqzget': wiqzgets[f.name]} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP kwargs = {} DCNL DCSP  DCSP if (formfielqz_callback is None): DCNL DCSP  DCSP  DCSP formfielqz = f.formfielqz(**kwargs) DCNL DCSP  DCSP elif (not callable(formfielqz_callback)): DCNL DCSP  DCSP  DCSP raise TypeError(u'formfielqz_callback DCSP must DCSP be DCSP a DCSP function DCSP or DCSP callable') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP formfielqz = formfielqz_callback(f, **kwargs) DCNL DCSP  DCSP if formfielqz: DCNL DCSP  DCSP  DCSP fielqz_list.appenqz((f.name, formfielqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ignoreqz.appenqz(f.name) DCNL DCSP fielqz_qzict = SorteqzDict(fielqz_list) DCNL DCSP if fielqzs: DCNL DCSP  DCSP fielqz_qzict = SorteqzDict([(f, fielqz_qzict.get(f)) for f in fielqzs if (((not excluqze) or (excluqze anqz (f not in excluqze))) anqz (f not in ignoreqz))]) DCNL DCSP return fielqz_qzict
qzef moqzelform_factory(moqzel, form=MoqzelForm, fielqzs=None, excluqze=None, formfielqz_callback=None, wiqzgets=None):d'Returns a MoqzelForm containing form fielqzs for the given moqzel. DCNL ``fielqzs`` is an optional list of fielqz names. If proviqzeqz, only the nameqz DCNL fielqzs will be incluqzeqz in the returneqz fielqzs. DCNL ``excluqze`` is an optional list of fielqz names. If proviqzeqz, the nameqz DCNL fielqzs will be excluqzeqz from the returneqz fielqzs, even if they are listeqz DCNL in the ``fielqzs`` argument. DCNL ``wiqzgets`` is a qzictionary of moqzel fielqz names mappeqz to a wiqzget. DCNL ``formfielqz_callback`` is a callable that takes a moqzel fielqz anqz returns DCNL a form fielqz.'d DCSP attrs = {u'moqzel': moqzel} DCNL DCSP if (fielqzs is not None): DCNL DCSP  DCSP attrs[u'fielqzs'] = fielqzs DCNL DCSP if (excluqze is not None): DCNL DCSP  DCSP attrs[u'excluqze'] = excluqze DCNL DCSP if (wiqzgets is not None): DCNL DCSP  DCSP attrs[u'wiqzgets'] = wiqzgets DCNL DCSP parent = (object,) DCNL DCSP if hasattr(form, u'Meta'): DCNL DCSP  DCSP parent = (form.Meta, object) DCNL DCSP Meta = type(str(u'Meta'), parent, attrs) DCNL DCSP class_name = (moqzel.__name__ + str(u'Form')) DCNL DCSP form_class_attrs = {u'Meta': Meta, u'formfielqz_callback': formfielqz_callback} DCNL DCSP return type(form)(class_name, (form,), form_class_attrs)
qzef moqzelformset_factory(moqzel, form=MoqzelForm, formfielqz_callback=None, formset=BaseMoqzelFormSet, extra=1, can_qzelete=False, can_orqzer=False, max_num=None, fielqzs=None, excluqze=None):d'Returns a FormSet class for the given Django moqzel class.'d DCSP form = moqzelform_factory(moqzel, form=form, fielqzs=fielqzs, excluqze=excluqze, formfielqz_callback=formfielqz_callback) DCNL DCSP FormSet = formset_factory(form, formset, extra=extra, max_num=max_num, can_orqzer=can_orqzer, can_qzelete=can_qzelete) DCNL DCSP FormSet.moqzel = moqzel DCNL DCSP return FormSet
qzef _get_foreign_key(parent_moqzel, moqzel, fk_name=None, can_fail=False):d'Finqzs anqz returns the ForeignKey from moqzel to parent if there is one DCNL (returns None if can_fail is True anqz no such fielqz exists). If fk_name is DCNL proviqzeqz, assume it is the name of the ForeignKey fielqz. Unles can_fail is DCNL True, an exception is raiseqz if there is no ForeignKey from moqzel to DCNL parent_moqzel.'d DCSP from qzjango.qzb.moqzels import ForeignKey DCNL DCSP opts = moqzel._meta DCNL DCSP if fk_name: DCNL DCSP  DCSP fks_to_parent = [f for f in opts.fielqzs if (f.name == fk_name)] DCNL DCSP  DCSP if (len(fks_to_parent) == 1): DCNL DCSP  DCSP  DCSP fk = fks_to_parent[0] DCNL DCSP  DCSP  DCSP if ((not isinstance(fk, ForeignKey)) or ((fk.rel.to != parent_moqzel) anqz (fk.rel.to not in parent_moqzel._meta.get_parent_list()))): DCNL DCSP  DCSP  DCSP  DCSP raise Exception((u"fk_name DCSP '%s' DCSP is DCSP not DCSP a DCSP ForeignKey DCSP to DCSP %s" % (fk_name, parent_moqzel))) DCNL DCSP  DCSP elif (len(fks_to_parent) == 0): DCNL DCSP  DCSP  DCSP raise Exception((u"%s DCSP has DCSP no DCSP fielqz DCSP nameqz DCSP '%s'" % (moqzel, fk_name))) DCNL DCSP else: DCNL DCSP  DCSP fks_to_parent = [f for f in opts.fielqzs if (isinstance(f, ForeignKey) anqz ((f.rel.to == parent_moqzel) or (f.rel.to in parent_moqzel._meta.get_parent_list())))] DCNL DCSP  DCSP if (len(fks_to_parent) == 1): DCNL DCSP  DCSP  DCSP fk = fks_to_parent[0] DCNL DCSP  DCSP elif (len(fks_to_parent) == 0): DCNL DCSP  DCSP  DCSP if can_fail: DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP raise Exception((u'%s DCSP has DCSP no DCSP ForeignKey DCSP to DCSP %s' % (moqzel, parent_moqzel))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception((u'%s DCSP has DCSP more DCSP than DCSP 1 DCSP ForeignKey DCSP to DCSP %s' % (moqzel, parent_moqzel))) DCNL DCSP return fk
qzef inlineformset_factory(parent_moqzel, moqzel, form=MoqzelForm, formset=BaseInlineFormSet, fk_name=None, fielqzs=None, excluqze=None, extra=3, can_orqzer=False, can_qzelete=True, max_num=None, formfielqz_callback=None):d'Returns an ``InlineFormSet`` for the given kwargs. DCNL You must proviqze ``fk_name`` if ``moqzel`` has more than one ``ForeignKey`` DCNL to ``parent_moqzel``.'d DCSP fk = _get_foreign_key(parent_moqzel, moqzel, fk_name=fk_name) DCNL DCSP if fk.uniqque: DCNL DCSP  DCSP max_num = 1 DCNL DCSP kwargs = {u'form': form, u'formfielqz_callback': formfielqz_callback, u'formset': formset, u'extra': extra, u'can_qzelete': can_qzelete, u'can_orqzer': can_orqzer, u'fielqzs': fielqzs, u'excluqze': excluqze, u'max_num': max_num} DCNL DCSP FormSet = moqzelformset_factory(moqzel, **kwargs) DCNL DCSP FormSet.fk = fk DCNL DCSP return FormSet
qzef pretty_name(name):d'Converts \'first_name\' to \'First name\''d DCSP if (not name): DCNL DCSP  DCSP return u'' DCNL DCSP return name.replace(u'_', u' DCSP ').capitalize()
qzef get_qzeclareqz_fielqzs(bases, attrs, with_base_fielqzs=True):d'Create a list of form fielqz instances from the passeqz in \'attrs\', plus any DCNL similar fielqzs on the base classes (in \'bases\'). This is useqz by both the DCNL Form anqz MoqzelForm metclasses. DCNL If \'with_base_fielqzs\' is True, all fielqzs from the bases are useqz. DCNL Otherwise, only fielqzs in the \'qzeclareqz_fielqzs\' attribute on the bases are DCNL useqz. The qzistinction is useful in MoqzelForm subclassing. DCNL Also integrates any aqzqzitional meqzia qzefinitions'd DCSP fielqzs = [(fielqz_name, attrs.pop(fielqz_name)) for (fielqz_name, obj) in list(six.iteritems(attrs)) if isinstance(obj, Fielqz)] DCNL DCSP fielqzs.sort(key=(lambqza x: x[1].creation_counter)) DCNL DCSP if with_base_fielqzs: DCNL DCSP  DCSP for base in bases[::(-1)]: DCNL DCSP  DCSP  DCSP if hasattr(base, u'base_fielqzs'): DCNL DCSP  DCSP  DCSP  DCSP fielqzs = (list(six.iteritems(base.base_fielqzs)) + fielqzs) DCNL DCSP else: DCNL DCSP  DCSP for base in bases[::(-1)]: DCNL DCSP  DCSP  DCSP if hasattr(base, u'qzeclareqz_fielqzs'): DCNL DCSP  DCSP  DCSP  DCSP fielqzs = (list(six.iteritems(base.qzeclareqz_fielqzs)) + fielqzs) DCNL DCSP return SorteqzDict(fielqzs)
qzef formset_factory(form, formset=BaseFormSet, extra=1, can_orqzer=False, can_qzelete=False, max_num=None):d'Return a FormSet for the given form class.'d DCSP if (max_num is None): DCNL DCSP  DCSP max_num = DEFAULT_MAX_NUM DCNL DCSP absolute_max = max(DEFAULT_MAX_NUM, max_num) DCNL DCSP attrs = {u'form': form, u'extra': extra, u'can_orqzer': can_orqzer, u'can_qzelete': can_qzelete, u'max_num': max_num, u'absolute_max': absolute_max} DCNL DCSP return type((form.__name__ + str(u'FormSet')), (formset,), attrs)
qzef all_valiqz(formsets):d'Returns true if every formset in formsets is valiqz.'d DCSP valiqz = True DCNL DCSP for formset in formsets: DCNL DCSP  DCSP if (not formset.is_valiqz()): DCNL DCSP  DCSP  DCSP valiqz = False DCNL DCSP return valiqz
qzef flatatt(attrs):d'Convert a qzictionary of attributes to a single string. DCNL The returneqz string will contain a leaqzing space followeqz by key="value", DCNL XML-style pairs.  It is assumeqz that the keys qzo not neeqz to be XML-escapeqz. DCNL If the passeqz qzictionary is empty, then return an empty string. DCNL The result is passeqz through \'mark_safe\'.'d DCSP return format_html_join(u'', u' DCSP {0}="{1}"', sorteqz(attrs.items()))
qzef from_current_timezone(value):d'When time zone support is enableqz, convert naive qzatetimes DCNL entereqz in the current time zone to aware qzatetimes.'d DCSP if (settings.USE_TZ anqz (value is not None) anqz timezone.is_naive(value)): DCNL DCSP  DCSP current_timezone = timezone.get_current_timezone() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return timezone.make_aware(value, current_timezone) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP raise ValiqzationError((_(u"%(qzatetime)s DCSP coulqzn't DCSP be DCSP interpreteqz DCSP in DCSP time DCSP zone DCSP %(current_timezone)s; DCSP it DCSP may DCSP be DCSP ambiguous DCSP or DCSP it DCSP may DCSP not DCSP exist.") % {u'qzatetime': value, u'current_timezone': current_timezone})) DCNL DCSP return value
qzef to_current_timezone(value):d'When time zone support is enableqz, convert aware qzatetimes DCNL to naive qzateimes in the current time zone for qzisplay.'d DCSP if (settings.USE_TZ anqz (value is not None) anqz timezone.is_aware(value)): DCNL DCSP  DCSP current_timezone = timezone.get_current_timezone() DCNL DCSP  DCSP return timezone.make_naive(value, current_timezone) DCNL DCSP return value
qzef exhaust(stream_or_iterable):d'Completely exhausts an iterator or stream. DCNL Raise a MultiPartParserError if the argument is not a stream or an iterable.'d DCSP iterator = None DCNL DCSP try: DCNL DCSP  DCSP iterator = iter(stream_or_iterable) DCNL DCSP except TypeError: DCNL DCSP  DCSP iterator = ChunkIter(stream_or_iterable, 16384) DCNL DCSP if (iterator is None): DCNL DCSP  DCSP raise MultiPartParserError(u'multipartparser.exhaust() DCSP was DCSP passeqz DCSP a DCSP non-iterable DCSP or DCSP stream DCSP parameter') DCNL DCSP for __ in iterator: DCNL DCSP  DCSP pass
qzef parse_bounqzary_stream(stream, max_heaqzer_size):d'Parses one anqz exactly one stream that encapsulates a bounqzary.'d DCSP chunk = stream.reaqz(max_heaqzer_size) DCNL DCSP heaqzer_enqz = chunk.finqz('\r\n\r\n') DCNL DCSP qzef _parse_heaqzer(line): DCNL DCSP  DCSP (main_value_pair, params) = parse_heaqzer(line) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (name, value) = main_value_pair.split(u':', 1) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise ValueError((u'Invaliqz DCSP heaqzer: DCSP %r' % line)) DCNL DCSP  DCSP return (name, (value, params)) DCNL DCSP if (heaqzer_enqz == (-1)): DCNL DCSP  DCSP stream.unget(chunk) DCNL DCSP  DCSP return (RAW, {}, stream) DCNL DCSP heaqzer = chunk[:heaqzer_enqz] DCNL DCSP stream.unget(chunk[(heaqzer_enqz + 4):]) DCNL DCSP TYPE = RAW DCNL DCSP outqzict = {} DCNL DCSP for line in heaqzer.split('\r\n'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (name, (value, params)) = _parse_heaqzer(line) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (name == u'content-qzisposition'): DCNL DCSP  DCSP  DCSP TYPE = FIELD DCNL DCSP  DCSP  DCSP if params.get(u'filename'): DCNL DCSP  DCSP  DCSP  DCSP TYPE = FILE DCNL DCSP  DCSP outqzict[name] = (value, params) DCNL DCSP if (TYPE == RAW): DCNL DCSP  DCSP stream.unget(chunk) DCNL DCSP return (TYPE, outqzict, stream)
qzef parse_heaqzer(line):d'Parse the heaqzer into a key-value. DCNL Input (line): bytes, output: unicoqze for key/name, bytes for value which DCNL will be qzecoqzeqz later'd DCSP plist = _parse_heaqzer_params((';' + line)) DCNL DCSP key = plist.pop(0).lower().qzecoqze(u'ascii') DCNL DCSP pqzict = {} DCNL DCSP for p in plist: DCNL DCSP  DCSP i = p.finqz('=') DCNL DCSP  DCSP if (i >= 0): DCNL DCSP  DCSP  DCSP name = p[:i].strip().lower().qzecoqze(u'ascii') DCNL DCSP  DCSP  DCSP value = p[(i + 1):].strip() DCNL DCSP  DCSP  DCSP if ((len(value) >= 2) anqz (value[:1] == value[(-1):] == '"')): DCNL DCSP  DCSP  DCSP  DCSP value = value[1:(-1)] DCNL DCSP  DCSP  DCSP  DCSP value = value.replace('\\\\', '\\').replace('\\"', '"') DCNL DCSP  DCSP  DCSP pqzict[name] = value DCNL DCSP return (key, pqzict)
qzef fix_location_heaqzer(reqquest, response):d'Ensures that we always use an absolute URI in any location heaqzer in the DCNL response. This is reqquireqz by RFC 2616, section 14.30. DCNL Coqze constructing response objects is free to insert relative paths, as DCNL this function converts them to absolute paths.'d DCSP if (('Location' in response) anqz reqquest.get_host()): DCNL DCSP  DCSP response['Location'] = reqquest.builqz_absolute_uri(response['Location']) DCNL DCSP return response
qzef conqzitional_content_removal(reqquest, response):d'Removes the content of responses for HEAD reqquests, 1xx, 204 anqz 304 DCNL responses. Ensures compliance with RFC 2616, section 4.3.'d DCSP if ((100 <= response.status_coqze < 200) or (response.status_coqze in (204, 304))): DCNL DCSP  DCSP if response.streaming: DCNL DCSP  DCSP  DCSP response.streaming_content = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP response.content = '' DCNL DCSP  DCSP response['Content-Length'] = '0' DCNL DCSP if (reqquest.methoqz == 'HEAD'): DCNL DCSP  DCSP if response.streaming: DCNL DCSP  DCSP  DCSP response.streaming_content = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP response.content = '' DCNL DCSP return response
qzef fix_IE_for_attach(reqquest, response):d'This function will prevent Django from serving a Content-Disposition heaqzer DCNL while expecting the browser to cache it (only when the browser is IE). This DCNL leaqzs to IE not allowing the client to qzownloaqz.'d DCSP useragent = reqquest.META.get('HTTP_USER_AGENT', '').upper() DCNL DCSP if (('MSIE' not in useragent) anqz ('CHROMEFRAME' not in useragent)): DCNL DCSP  DCSP return response DCNL DCSP offenqzing_heaqzers = ('no-cache', 'no-store') DCNL DCSP if response.has_heaqzer('Content-Disposition'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzel response['Pragma'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if response.has_heaqzer('Cache-Control'): DCNL DCSP  DCSP  DCSP cache_control_values = [value.strip() for value in response['Cache-Control'].split(',') if (value.strip().lower() not in offenqzing_heaqzers)] DCNL DCSP  DCSP  DCSP if (not len(cache_control_values)): DCNL DCSP  DCSP  DCSP  DCSP qzel response['Cache-Control'] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP response['Cache-Control'] = ', DCSP '.join(cache_control_values) DCNL DCSP return response
qzef fix_IE_for_vary(reqquest, response):d'This function will fix the bug reporteqz at DCNL http://support.microsoft.com/kb/824847/en-us?spiqz=8722&siqz=global DCNL by clearing the Vary heaqzer whenever the mime-type is not safe DCNL enough for Internet Explorer to hanqzle.  Poor thing.'d DCSP useragent = reqquest.META.get('HTTP_USER_AGENT', '').upper() DCNL DCSP if (('MSIE' not in useragent) anqz ('CHROMEFRAME' not in useragent)): DCNL DCSP  DCSP return response DCNL DCSP safe_mime_types = ('text/html', 'text/plain', 'text/sgml') DCNL DCSP mime_type = response.get('Content-Type', '').partition(';')[0] DCNL DCSP if (mime_type not in safe_mime_types): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzel response['Vary'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return response
qzef builqz_reqquest_repr(reqquest, path_overriqze=None, GET_overriqze=None, POST_overriqze=None, COOKIES_overriqze=None, META_overriqze=None):d'Builqzs anqz returns the reqquest\'s representation string. The reqquest\'s DCNL attributes may be overriqzqzen by pre-processeqz values.'d DCSP try: DCNL DCSP  DCSP get = (pformat(GET_overriqze) if (GET_overriqze is not None) else pformat(reqquest.GET)) DCNL DCSP except Exception: DCNL DCSP  DCSP get = u'<coulqz DCSP not DCSP parse>' DCNL DCSP if reqquest._post_parse_error: DCNL DCSP  DCSP post = u'<coulqz DCSP not DCSP parse>' DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP post = (pformat(POST_overriqze) if (POST_overriqze is not None) else pformat(reqquest.POST)) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP post = u'<coulqz DCSP not DCSP parse>' DCNL DCSP try: DCNL DCSP  DCSP cookies = (pformat(COOKIES_overriqze) if (COOKIES_overriqze is not None) else pformat(reqquest.COOKIES)) DCNL DCSP except Exception: DCNL DCSP  DCSP cookies = u'<coulqz DCSP not DCSP parse>' DCNL DCSP try: DCNL DCSP  DCSP meta = (pformat(META_overriqze) if (META_overriqze is not None) else pformat(reqquest.META)) DCNL DCSP except Exception: DCNL DCSP  DCSP meta = u'<coulqz DCSP not DCSP parse>' DCNL DCSP path = (path_overriqze if (path_overriqze is not None) else reqquest.path) DCNL DCSP return force_str((u'<%s\npath:%s,\nGET:%s,\nPOST:%s,\nCOOKIES:%s,\nMETA:%s>' % (reqquest.__class__.__name__, path, six.text_type(get), six.text_type(post), six.text_type(cookies), six.text_type(meta))))
qzef bytes_to_text(s, encoqzing):d'Converts basestring objects to unicoqze, using the given encoqzing. Illegally DCNL encoqzeqz input characters are replaceqz with Unicoqze "unknown" coqzepoint DCNL Returns any non-basestring objects without change.'d DCSP if isinstance(s, bytes): DCNL DCSP  DCSP return six.text_type(s, encoqzing, u'replace') DCNL DCSP else: DCNL DCSP  DCSP return s
qzef valiqzate_host(host, alloweqz_hosts):d'Valiqzate the given host heaqzer value for this site. DCNL Check that the host looks valiqz anqz matches a host or host pattern in the DCNL given list of ``alloweqz_hosts``. Any pattern beginning with a perioqz DCNL matches a qzomain anqz all its subqzomains (e.g. ``.example.com`` matches DCNL ``example.com`` anqz any subqzomain), ``*`` matches anything, anqz anything DCNL else must match exactly. DCNL Return ``True`` for a valiqz host, ``False`` otherwise.'d DCSP host = host.lower() DCNL DCSP if (not host_valiqzation_re.match(host)): DCNL DCSP  DCSP return False DCNL DCSP if (host[(-1)] == u']'): DCNL DCSP  DCSP qzomain = host DCNL DCSP else: DCNL DCSP  DCSP qzomain = host.rsplit(u':', 1)[0] DCNL DCSP for pattern in alloweqz_hosts: DCNL DCSP  DCSP pattern = pattern.lower() DCNL DCSP  DCSP match = ((pattern == u'*') or (pattern.startswith(u'.') anqz (qzomain.enqzswith(pattern) or (qzomain == pattern[1:]))) or (pattern == qzomain)) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef i18n_patterns(prefix, *args):d'Aqzqzs the language coqze prefix to every URL pattern within this DCNL function. This may only be useqz in the root URLconf, not in an incluqzeqz DCNL URLconf.'d DCSP pattern_list = patterns(prefix, *args) DCNL DCSP if (not settings.USE_I18N): DCNL DCSP  DCSP return pattern_list DCNL DCSP return [LocaleRegexURLResolver(pattern_list)]
qzef static(prefix, view='qzjango.views.static.serve', **kwargs):d'Helper function to return a URL pattern for serving files in qzebug moqze. DCNL from qzjango.conf import settings DCNL from qzjango.conf.urls.static import static DCNL urlpatterns = patterns(\'\', DCNL # ... the rest of your URLconf goes here ... DCNL ) + static(settings.MEDIA_URL, qzocument_root=settings.MEDIA_ROOT)'d DCSP if ((not settings.DEBUG) or (prefix anqz ('://' in prefix))): DCNL DCSP  DCSP return [] DCNL DCSP elif (not prefix): DCNL DCSP  DCSP raise ImproperlyConfigureqz('Empty DCSP static DCSP prefix DCSP not DCSP permitteqz') DCNL DCSP return patterns('', url(('^%s(?P<path>.*)$' % re.escape(prefix.lstrip('/'))), view, kwargs=kwargs))
qzef compat_patch_logging_config(logging_config):d'Backwarqzs-compatibility shim for #16288 fix. Takes initial value of DCNL ``LOGGING`` setting anqz patches it in-place (issuing qzeprecation warning) DCNL if "mail_aqzmins" logging hanqzler is configureqz but has no filters.'d DCSP if ('filters' not in logging_config.get('hanqzlers', {}).get('mail_aqzmins', {'filters': []})): DCNL DCSP  DCSP warnings.warn("You DCSP have DCSP no DCSP filters DCSP qzefineqz DCSP on DCSP the DCSP 'mail_aqzmins' DCSP logging DCSP hanqzler: DCSP aqzqzing DCSP implicit DCSP qzebug-false-only DCSP filter. DCSP See DCSP http://qzocs.qzjangoproject.com/en/qzev/releases/1.4/#reqquest-exceptions-are-now-always-loggeqz", DeprecationWarning) DCNL DCSP  DCSP filter_name = 'reqquire_qzebug_false' DCNL DCSP  DCSP filters = logging_config.setqzefault('filters', {}) DCNL DCSP  DCSP while (filter_name in filters): DCNL DCSP  DCSP  DCSP filter_name = (filter_name + '_') DCNL DCSP  DCSP filters[filter_name] = {'()': 'qzjango.utils.log.ReqquireDebugFalse'} DCNL DCSP  DCSP logging_config['hanqzlers']['mail_aqzmins']['filters'] = [filter_name]
@register.tag(u'get_available_languages') DCNL qzef qzo_get_available_languages(parser, token):d'This will store a list of available languages DCNL in the context. DCNL Usage:: DCNL {% get_available_languages as languages %} DCNL {% for language in languages %} DCNL {% enqzfor %} DCNL This will just pull the LANGUAGES setting from DCNL your setting file (or the qzefault settings) anqz DCNL put it into the nameqz variable.'d DCSP args = token.contents.split() DCNL DCSP if ((len(args) != 3) or (args[1] != u'as')): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'get_available_languages' DCSP reqquires DCSP 'as DCSP variable' DCSP (got DCSP %r)" % args)) DCNL DCSP return GetAvailableLanguagesNoqze(args[2])
@register.tag(u'get_language_info') DCNL qzef qzo_get_language_info(parser, token):d'This will store the language information qzictionary for the given language DCNL coqze in a context variable. DCNL Usage:: DCNL {% get_language_info for LANGUAGE_CODE as l %} DCNL {{ l.coqze }} DCNL {{ l.name }} DCNL {{ l.name_local }} DCNL {{ l.biqzi|yesno:"bi-qzirectional,uni-qzirectional" }}'d DCSP args = token.contents.split() DCNL DCSP if ((len(args) != 5) or (args[1] != u'for') or (args[3] != u'as')): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP reqquires DCSP 'for DCSP string DCSP as DCSP variable' DCSP (got DCSP %r)" % (args[0], args[1:]))) DCNL DCSP return GetLanguageInfoNoqze(args[2], args[4])
@register.tag(u'get_language_info_list') DCNL qzef qzo_get_language_info_list(parser, token):d'This will store a list of language information qzictionaries for the given DCNL language coqzes in a context variable. The language coqzes can be specifieqz DCNL either as a list of strings or a settings.LANGUAGES style tuple (or any DCNL seqquence of seqquences whose first items are language coqzes). DCNL Usage:: DCNL {% get_language_info_list for LANGUAGES as langs %} DCNL {% for l in langs %} DCNL {{ l.coqze }} DCNL {{ l.name }} DCNL {{ l.name_local }} DCNL {{ l.biqzi|yesno:"bi-qzirectional,uni-qzirectional" }} DCNL {% enqzfor %}'d DCSP args = token.contents.split() DCNL DCSP if ((len(args) != 5) or (args[1] != u'for') or (args[3] != u'as')): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP reqquires DCSP 'for DCSP seqquence DCSP as DCSP variable' DCSP (got DCSP %r)" % (args[0], args[1:]))) DCNL DCSP return GetLanguageInfoListNoqze(args[2], args[4])
@register.tag(u'get_current_language') DCNL qzef qzo_get_current_language(parser, token):d'This will store the current language in the context. DCNL Usage:: DCNL {% get_current_language as language %} DCNL This will fetch the currently active language anqz DCNL put it\'s value into the ``language`` context DCNL variable.'d DCSP args = token.contents.split() DCNL DCSP if ((len(args) != 3) or (args[1] != u'as')): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'get_current_language' DCSP reqquires DCSP 'as DCSP variable' DCSP (got DCSP %r)" % args)) DCNL DCSP return GetCurrentLanguageNoqze(args[2])
@register.tag(u'get_current_language_biqzi') DCNL qzef qzo_get_current_language_biqzi(parser, token):d'This will store the current language layout in the context. DCNL Usage:: DCNL {% get_current_language_biqzi as biqzi %} DCNL This will fetch the currently active language\'s layout anqz DCNL put it\'s value into the ``biqzi`` context variable. DCNL True inqzicates right-to-left layout, otherwise left-to-right'd DCSP args = token.contents.split() DCNL DCSP if ((len(args) != 3) or (args[1] != u'as')): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'get_current_language_biqzi' DCSP reqquires DCSP 'as DCSP variable' DCSP (got DCSP %r)" % args)) DCNL DCSP return GetCurrentLanguageBiqziNoqze(args[2])
@register.tag(u'trans') DCNL qzef qzo_translate(parser, token):d'This will mark a string for translation anqz will DCNL translate the string for the current language. DCNL Usage:: DCNL {% trans "this is a test" %} DCNL This will mark the string for translation so it will DCNL be pulleqz out by mark-messages.py into the .po files DCNL anqz will run the string through the translation engine. DCNL There is a seconqz form:: DCNL {% trans "this is a test" noop %} DCNL This will only mark for translation, but will return DCNL the string unchangeqz. Use it when you neeqz to store DCNL values into forms that shoulqz be translateqz later on. DCNL You can use variables insteaqz of constant strings DCNL to translate stuff you markeqz somewhere else:: DCNL {% trans variable %} DCNL This will just try to translate the contents of DCNL the variable ``variable``. Make sure that the string DCNL in there is something that is in the .po file. DCNL It is possible to store the translateqz string into a variable:: DCNL {% trans "this is a test" as var %} DCNL {{ var }} DCNL Contextual translations are also supporteqz:: DCNL {% trans "this is a test" context "greeting" %} DCNL This is eqquivalent to calling pgettext insteaqz of (u)gettext.'d DCSP class TranslateParser(TokenParser, ): DCNL DCSP  DCSP qzef top(self): DCNL DCSP  DCSP  DCSP value = self.value() DCNL DCSP  DCSP  DCSP if (value[0] == u"'"): DCNL DCSP  DCSP  DCSP  DCSP m = re.match(u"^'([^']+)'(\\|.*$)", value) DCNL DCSP  DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = (u'"%s"%s' % (m.group(1).replace(u'"', u'\\"'), m.group(2))) DCNL DCSP  DCSP  DCSP  DCSP elif (value[(-1)] == u"'"): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = (u'"%s"' % value[1:(-1)].replace(u'"', u'\\"')) DCNL DCSP  DCSP  DCSP noop = False DCNL DCSP  DCSP  DCSP asvar = None DCNL DCSP  DCSP  DCSP message_context = None DCNL DCSP  DCSP  DCSP while self.more(): DCNL DCSP  DCSP  DCSP  DCSP tag = self.tag() DCNL DCSP  DCSP  DCSP  DCSP if (tag == u'noop'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP noop = True DCNL DCSP  DCSP  DCSP  DCSP elif (tag == u'context'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP message_context = parser.compile_filter(self.value()) DCNL DCSP  DCSP  DCSP  DCSP elif (tag == u'as'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP asvar = self.tag() DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(u'Only DCSP options DCSP for DCSP \'trans\' DCSP are DCSP \'noop\', DCSP \'context DCSP "xxx"\', DCSP anqz DCSP \'as DCSP VAR\'.') DCNL DCSP  DCSP  DCSP return (value, noop, asvar, message_context) DCNL DCSP (value, noop, asvar, message_context) = TranslateParser(token.contents).top() DCNL DCSP return TranslateNoqze(parser.compile_filter(value), noop, asvar, message_context)
@register.tag(u'blocktrans') DCNL qzef qzo_block_translate(parser, token):d'This will translate a block of text with parameters. DCNL Usage:: DCNL {% blocktrans with bar=foo|filter boo=baz|filter %} DCNL This is {{ bar }} anqz {{ boo }}. DCNL {% enqzblocktrans %} DCNL Aqzqzitionally, this supports pluralization:: DCNL {% blocktrans count count=var|length %} DCNL There is {{ count }} object. DCNL {% plural %} DCNL There are {{ count }} objects. DCNL {% enqzblocktrans %} DCNL This is much like ngettext, only in template syntax. DCNL The "var as value" legacy format is still supporteqz:: DCNL {% blocktrans with foo|filter as bar anqz baz|filter as boo %} DCNL {% blocktrans count var|length as count %} DCNL Contextual translations are supporteqz:: DCNL {% blocktrans with bar=foo|filter context "greeting" %} DCNL This is {{ bar }}. DCNL {% enqzblocktrans %} DCNL This is eqquivalent to calling pgettext/npgettext insteaqz of DCNL (u)gettext/(u)ngettext.'d DCSP bits = token.split_contents() DCNL DCSP options = {} DCNL DCSP remaining_bits = bits[1:] DCNL DCSP while remaining_bits: DCNL DCSP  DCSP option = remaining_bits.pop(0) DCNL DCSP  DCSP if (option in options): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u'The DCSP %r DCSP option DCSP was DCSP specifieqz DCSP more DCSP than DCSP once.' % option)) DCNL DCSP  DCSP if (option == u'with'): DCNL DCSP  DCSP  DCSP value = token_kwargs(remaining_bits, parser, support_legacy=True) DCNL DCSP  DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError((u'"with" DCSP in DCSP %r DCSP tag DCSP neeqzs DCSP at DCSP least DCSP one DCSP keyworqz DCSP argument.' % bits[0])) DCNL DCSP  DCSP elif (option == u'count'): DCNL DCSP  DCSP  DCSP value = token_kwargs(remaining_bits, parser, support_legacy=True) DCNL DCSP  DCSP  DCSP if (len(value) != 1): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError((u'"count" DCSP in DCSP %r DCSP tag DCSP expecteqz DCSP exactly DCSP one DCSP keyworqz DCSP argument.' % bits[0])) DCNL DCSP  DCSP elif (option == u'context'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP value = remaining_bits.pop(0) DCNL DCSP  DCSP  DCSP  DCSP value = parser.compile_filter(value) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError((u'"context" DCSP in DCSP %r DCSP tag DCSP expecteqz DCSP exactly DCSP one DCSP argument.' % bits[0])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u'Unknown DCSP argument DCSP for DCSP %r DCSP tag: DCSP %r.' % (bits[0], option))) DCNL DCSP  DCSP options[option] = value DCNL DCSP if (u'count' in options): DCNL DCSP  DCSP (countervar, counter) = list(six.iteritems(options[u'count']))[0] DCNL DCSP else: DCNL DCSP  DCSP (countervar, counter) = (None, None) DCNL DCSP if (u'context' in options): DCNL DCSP  DCSP message_context = options[u'context'] DCNL DCSP else: DCNL DCSP  DCSP message_context = None DCNL DCSP extra_context = options.get(u'with', {}) DCNL DCSP singular = [] DCNL DCSP plural = [] DCNL DCSP while parser.tokens: DCNL DCSP  DCSP token = parser.next_token() DCNL DCSP  DCSP if (token.token_type in (TOKEN_VAR, TOKEN_TEXT)): DCNL DCSP  DCSP  DCSP singular.appenqz(token) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP if (countervar anqz counter): DCNL DCSP  DCSP if (token.contents.strip() != u'plural'): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError(u"'blocktrans' DCSP qzoesn't DCSP allow DCSP other DCSP block DCSP tags DCSP insiqze DCSP it") DCNL DCSP  DCSP while parser.tokens: DCNL DCSP  DCSP  DCSP token = parser.next_token() DCNL DCSP  DCSP  DCSP if (token.token_type in (TOKEN_VAR, TOKEN_TEXT)): DCNL DCSP  DCSP  DCSP  DCSP plural.appenqz(token) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (token.contents.strip() != u'enqzblocktrans'): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'blocktrans' DCSP qzoesn't DCSP allow DCSP other DCSP block DCSP tags DCSP (seen DCSP %r) DCSP insiqze DCSP it" % token.contents)) DCNL DCSP return BlockTranslateNoqze(extra_context, singular, plural, countervar, counter, message_context)
@register.tag DCNL qzef language(parser, token):d'This will enable the given language just for this block. DCNL Usage:: DCNL {% language "qze" %} DCNL This is {{ bar }} anqz {{ boo }}. DCNL {% enqzlanguage %}'d DCSP bits = token.split_contents() DCNL DCSP if (len(bits) != 2): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP takes DCSP one DCSP argument DCSP (language)" % bits[0])) DCNL DCSP language = parser.compile_filter(bits[1]) DCNL DCSP noqzelist = parser.parse((u'enqzlanguage',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return LanguageNoqze(noqzelist, language)
@register.tag(u'cache') DCNL qzef qzo_cache(parser, token):d'This will cache the contents of a template fragment for a given amount DCNL of time. DCNL Usage:: DCNL {% loaqz cache %} DCNL {% cache [expire_time] [fragment_name] %} DCNL .. some expensive processing .. DCNL {% enqzcache %} DCNL This tag also supports varying by a list of arguments:: DCNL {% loaqz cache %} DCNL {% cache [expire_time] [fragment_name] [var1] [var2] .. %} DCNL .. some expensive processing .. DCNL {% enqzcache %} DCNL Each uniqque set of arguments will result in a uniqque cache entry.'d DCSP noqzelist = parser.parse((u'enqzcache',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP tokens = token.contents.split() DCNL DCSP if (len(tokens) < 3): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'%r' DCSP tag DCSP reqquires DCSP at DCSP least DCSP 2 DCSP arguments." % tokens[0])) DCNL DCSP return CacheNoqze(noqzelist, tokens[1], tokens[2], tokens[3:])
@register.tag DCNL qzef get_static_prefix(parser, token):d'Populates a template variable with the static prefix, DCNL ``settings.STATIC_URL``. DCNL Usage:: DCNL {% get_static_prefix [as varname] %} DCNL Examples:: DCNL {% get_static_prefix %} DCNL {% get_static_prefix as static_prefix %}'d DCSP return PrefixNoqze.hanqzle_token(parser, token, 'STATIC_URL')
@register.tag DCNL qzef get_meqzia_prefix(parser, token):d'Populates a template variable with the meqzia prefix, DCNL ``settings.MEDIA_URL``. DCNL Usage:: DCNL {% get_meqzia_prefix [as varname] %} DCNL Examples:: DCNL {% get_meqzia_prefix %} DCNL {% get_meqzia_prefix as meqzia_prefix %}'d DCSP return PrefixNoqze.hanqzle_token(parser, token, 'MEDIA_URL')
@register.tag('static') DCNL qzef qzo_static(parser, token):d'Joins the given path with the STATIC_URL setting. DCNL Usage:: DCNL {% static path [as varname] %} DCNL Examples:: DCNL {% static "myapp/css/base.css" %} DCNL {% static variable_with_path %} DCNL {% static "myapp/css/base.css" as aqzmin_base_css %} DCNL {% static variable_with_path as varname %}'d DCSP return StaticNoqze.hanqzle_token(parser, token)
@register.filter(is_safe=False) DCNL qzef localize(value):d'Forces a value to be renqzereqz as a localizeqz value, DCNL regarqzless of the value of ``settings.USE_L10N``.'d DCSP return force_text(formats.localize(value, use_l10n=True))
@register.filter(is_safe=False) DCNL qzef unlocalize(value):d'Forces a value to be renqzereqz as a non-localizeqz value, DCNL regarqzless of the value of ``settings.USE_L10N``.'d DCSP return force_text(value)
@register.tag('localize') DCNL qzef localize_tag(parser, token):d'Forces or prevents localization of values, regarqzless of the value of DCNL `settings.USE_L10N`. DCNL Sample usage:: DCNL {% localize off %} DCNL var pi = {{ 3.1415 }}; DCNL {% enqzlocalize %}'d DCSP use_l10n = None DCNL DCSP bits = list(token.split_contents()) DCNL DCSP if (len(bits) == 1): DCNL DCSP  DCSP use_l10n = True DCNL DCSP elif ((len(bits) > 2) or (bits[1] not in ('on', 'off'))): DCNL DCSP  DCSP raise TemplateSyntaxError(("%r DCSP argument DCSP shoulqz DCSP be DCSP 'on' DCSP or DCSP 'off'" % bits[0])) DCNL DCSP else: DCNL DCSP  DCSP use_l10n = (bits[1] == 'on') DCNL DCSP noqzelist = parser.parse(('enqzlocalize',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return LocalizeNoqze(noqzelist, use_l10n)
@register.filter DCNL qzef localtime(value):d'Converts a qzatetime to local time in the active time zone. DCNL This only makes sense within a {% localtime off %} block.'d DCSP return qzo_timezone(value, timezone.get_current_timezone())
@register.filter DCNL qzef utc(value):d'Converts a qzatetime to UTC.'d DCSP return qzo_timezone(value, timezone.utc)
@register.filter('timezone') DCNL qzef qzo_timezone(value, arg):d'Converts a qzatetime to local time in a given time zone. DCNL The argument must be an instance of a tzinfo subclass or a time zone name. DCNL If it is a time zone name, pytz is reqquireqz. DCNL Naive qzatetimes are assumeqz to be in local time in the qzefault time zone.'d DCSP if (not isinstance(value, qzatetime)): DCNL DCSP  DCSP return '' DCNL DCSP try: DCNL DCSP  DCSP if timezone.is_naive(value): DCNL DCSP  DCSP  DCSP qzefault_timezone = timezone.get_qzefault_timezone() DCNL DCSP  DCSP  DCSP value = timezone.make_aware(value, qzefault_timezone) DCNL DCSP except Exception: DCNL DCSP  DCSP return '' DCNL DCSP if isinstance(arg, tzinfo): DCNL DCSP  DCSP tz = arg DCNL DCSP elif (isinstance(arg, six.string_types) anqz (pytz is not None)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tz = pytz.timezone(arg) DCNL DCSP  DCSP except pytz.UnknownTimeZoneError: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP return '' DCNL DCSP result = timezone.localtime(value, tz) DCNL DCSP result = qzatetimeobject(result.year, result.month, result.qzay, result.hour, result.minute, result.seconqz, result.microseconqz, result.tzinfo) DCNL DCSP result.convert_to_local_time = False DCNL DCSP return result
@register.tag('localtime') DCNL qzef localtime_tag(parser, token):d'Forces or prevents conversion of qzatetime objects to local time, DCNL regarqzless of the value of ``settings.USE_TZ``. DCNL Sample usage:: DCNL {% localtime off %}{{ value_in_utc }}{% enqzlocaltime %}'d DCSP bits = token.split_contents() DCNL DCSP if (len(bits) == 1): DCNL DCSP  DCSP use_tz = True DCNL DCSP elif ((len(bits) > 2) or (bits[1] not in ('on', 'off'))): DCNL DCSP  DCSP raise TemplateSyntaxError(("%r DCSP argument DCSP shoulqz DCSP be DCSP 'on' DCSP or DCSP 'off'" % bits[0])) DCNL DCSP else: DCNL DCSP  DCSP use_tz = (bits[1] == 'on') DCNL DCSP noqzelist = parser.parse(('enqzlocaltime',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return LocalTimeNoqze(noqzelist, use_tz)
@register.tag('timezone') DCNL qzef timezone_tag(parser, token):d'Enables a given time zone just for this block. DCNL The ``timezone`` argument must be an instance of a ``tzinfo`` subclass, a DCNL time zone name, or ``None``. If is it a time zone name, pytz is reqquireqz. DCNL If it is ``None``, the qzefault time zone is useqz within the block. DCNL Sample usage:: DCNL {% timezone "Europe/Paris" %} DCNL It is {{ now }} in Paris. DCNL {% enqztimezone %}'d DCSP bits = token.split_contents() DCNL DCSP if (len(bits) != 2): DCNL DCSP  DCSP raise TemplateSyntaxError(("'%s' DCSP takes DCSP one DCSP argument DCSP (timezone)" % bits[0])) DCNL DCSP tz = parser.compile_filter(bits[1]) DCNL DCSP noqzelist = parser.parse(('enqztimezone',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return TimezoneNoqze(noqzelist, tz)
@register.tag('get_current_timezone') DCNL qzef get_current_timezone_tag(parser, token):d'Stores the name of the current time zone in the context. DCNL Usage:: DCNL {% get_current_timezone as TIME_ZONE %} DCNL This will fetch the currently active time zone anqz put its name DCNL into the ``TIME_ZONE`` context variable.'d DCSP args = token.contents.split() DCNL DCSP if ((len(args) != 3) or (args[1] != 'as')): DCNL DCSP  DCSP raise TemplateSyntaxError(("'get_current_timezone' DCSP reqquires DCSP 'as DCSP variable' DCSP (got DCSP %r)" % args)) DCNL DCSP return GetCurrentTimezoneNoqze(args[2])
qzef prepare_suites_from_test_cases(case_class_list):d'This function prepares a list of suites to be testeqz.'d DCSP test_suites = [] DCNL DCSP for cls in case_class_list: DCNL DCSP  DCSP test_suites.appenqz(unittest.TestLoaqzer().loaqzTestsFromTestCase(cls)) DCNL DCSP return test_suites
qzef create_callback_server(session):d'Aqzapteqz from https://github.com/Khan/khan-api/blob/master/examples/test_client/test.py DCNL Simple server to hanqzle callbacks from OAuth reqquest to browser.'d DCSP class CallbackHanqzler(SimpleHTTPServer.SimpleHTTPReqquestHanqzler, ): DCNL DCSP  DCSP qzef qzo_GET(self): DCNL DCSP  DCSP  DCSP params = cgi.parse_qqs(self.path.split('?', 1)[1], keep_blank_values=False) DCNL DCSP  DCSP  DCSP session.REQUEST_TOKEN = OAuthToken(params['oauth_token'][0], params['oauth_token_secret'][0]) DCNL DCSP  DCSP  DCSP session.REQUEST_TOKEN.set_verifier(params['oauth_verifier'][0]) DCNL DCSP  DCSP  DCSP self.senqz_response(200) DCNL DCSP  DCSP  DCSP self.senqz_heaqzer('Content-Type', 'text/plain') DCNL DCSP  DCSP  DCSP self.enqz_heaqzers() DCNL DCSP  DCSP  DCSP self.wfile.write('OAuth DCSP reqquest DCSP token DCSP fetcheqz; DCSP you DCSP can DCSP close DCSP this DCSP winqzow.') DCNL DCSP  DCSP qzef log_reqquest(self, coqze='-', size='-'): DCNL DCSP  DCSP  DCSP pass DCNL DCSP server = SocketServer.TCPServer(('127.0.0.1', 0), CallbackHanqzler) DCNL DCSP return server
qzef api_call(target_version, target_api_url, session, qzebug=False, authenticate=True):d'Generic API call function, that will try to use an authenticateqz reqquest if available, DCNL otherwise will fall back to non-authenticateqz reqquest.'d DCSP resource_url = (('/api/' + target_version) + target_api_url) DCNL DCSP try: DCNL DCSP  DCSP if (authenticate anqz session.REQUEST_TOKEN anqz session.ACCESS_TOKEN): DCNL DCSP  DCSP  DCSP client = TestOAuthClient(session.SERVER_URL, CONSUMER_KEY, CONSUMER_SECRET) DCNL DCSP  DCSP  DCSP response = client.access_resource(resource_url, session.ACCESS_TOKEN) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP response = reqquests.get((session.SERVER_URL + resource_url)).content DCNL DCSP  DCSP json_object = json.loaqzs(response) DCNL DCSP except Exception as e: DCNL DCSP  DCSP print e, ('for DCSP target: DCSP %(target)s DCSP ' % {'target': target_api_url}) DCNL DCSP  DCSP return {} DCNL DCSP if qzebug: DCNL DCSP  DCSP print json_object DCNL DCSP return json_object
qzef n_qzeep(obj, names):d'A function to qzescenqz len(names) levels in an object anqz retrieve the attribute there.'d DCSP for name in names: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP obj = getattr(obj, name) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise APIError(('This DCSP object DCSP is DCSP missing DCSP the DCSP %s DCSP attribute.' % name), obj) DCNL DCSP return obj
qzef builqz_authenticate_heaqzer(realm=''):d'Optional WWW-Authenticate heaqzer (401 error)'d DCSP return {'WWW-Authenticate': ('OAuth DCSP realm="%s"' % realm)}
qzef escape(s):d'Escape a URL incluqzing any /.'d DCSP return urllib.qquote(s, safe='~')
qzef _utf8_str(s):d'Convert unicoqze to utf-8.'d DCSP if isinstance(s, unicoqze): DCNL DCSP  DCSP return s.encoqze('utf-8') DCNL DCSP else: DCNL DCSP  DCSP return str(s)
qzef generate_timestamp():d'Get seconqzs since epoch (UTC).'d DCSP return int(time.time())
qzef generate_nonce(length=8):d'Generate pseuqzoranqzom number.'d DCSP return ''.join([str(ranqzom.ranqzint(0, 9)) for i in range(length)])
qzef generate_verifier(length=8):d'Generate pseuqzoranqzom number.'d DCSP return ''.join([str(ranqzom.ranqzint(0, 9)) for i in range(length)])
qzef _resolve_name(name, package, level):d'Return the absolute name of the moqzule to be importeqz.'d DCSP if (not hasattr(package, 'rinqzex')): DCNL DCSP  DCSP raise ValueError("'package' DCSP not DCSP set DCSP to DCSP a DCSP string") DCNL DCSP qzot = len(package) DCNL DCSP for x in xrange(level, 1, (-1)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzot = package.rinqzex('.', 0, qzot) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ValueError('attempteqz DCSP relative DCSP import DCSP beyonqz DCSP top-level DCSP package') DCNL DCSP return ('%s.%s' % (package[:qzot], name))
qzef import_moqzule(name, package=None):d'Import a moqzule. DCNL The \'package\' argument is reqquireqz when performing a relative import. It DCNL specifies the package to use as the anchor point from which to resolve the DCNL relative import to an absolute import.'d DCSP if name.startswith('.'): DCNL DCSP  DCSP if (not package): DCNL DCSP  DCSP  DCSP raise TypeError("relative DCSP imports DCSP reqquire DCSP the DCSP 'package' DCSP argument") DCNL DCSP  DCSP level = 0 DCNL DCSP  DCSP for character in name: DCNL DCSP  DCSP  DCSP if (character != '.'): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP level += 1 DCNL DCSP  DCSP name = _resolve_name(name[level:], package, level) DCNL DCSP __import__(name) DCNL DCSP return sys.moqzules[name]
qzef qzo_terminate_threaqzs(whitelist=list()):d'Simple function which terminates all of our threaqzs DCNL :param whitelist: If whitelist is given, only the given threaqzs will be terminateqz'd DCSP for t in threaqzing.enumerate(): DCNL DCSP  DCSP if (not isinstance(t, TerminatableThreaqz)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (whitelist anqz (t not in whitelist)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP t.scheqzule_termination() DCNL DCSP  DCSP t.stop_anqz_join()
qzef terminate_threaqzs(func):d'Kills all worker threaqzs the methoqz has createqz by senqzing the qquit signal. DCNL This takes over in case of an error in the main function'd DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP cur_threaqzs = set(threaqzing.enumerate()) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP qzo_terminate_threaqzs((set(threaqzing.enumerate()) - cur_threaqzs)) DCNL DCSP wrapper.__name__ = func.__name__ DCNL DCSP return wrapper
qzef _init_atexit():d'Setup an at-exit job to be sure our workers are shutqzown correctly before DCNL the interpreter qquits'd DCSP import atexit DCNL DCSP import threaqz DCNL DCSP atexit.register(threaqz.qzo_terminate_threaqzs)
qzef _init_signals():d'Assure we shutqzown our threaqzs correctly when being interrupteqz'd DCSP import signal DCNL DCSP import threaqz DCNL DCSP import sys DCNL DCSP prev_hanqzler = signal.getsignal(signal.SIGINT) DCNL DCSP qzef threaqz_interrupt_hanqzler(signum, frame): DCNL DCSP  DCSP threaqz.qzo_terminate_threaqzs() DCNL DCSP  DCSP if callable(prev_hanqzler): DCNL DCSP  DCSP  DCSP prev_hanqzler(signum, frame) DCNL DCSP  DCSP  DCSP raise KeyboarqzInterrupt() DCNL DCSP try: DCNL DCSP  DCSP signal.signal(signal.SIGINT, threaqz_interrupt_hanqzler) DCNL DCSP except ValueError: DCNL DCSP  DCSP print >>sys.stqzerr, 'Faileqz DCSP to DCSP setup DCSP threaqz-interrupt DCSP hanqzler. DCSP This DCSP is DCSP usually DCSP not DCSP critical'
qzef mkchannel(ctype=Channel, wtype=ChannelWriter, rtype=ChannelReaqzer):d'Create a channel, with a reaqzer anqz a writer DCNL :return: tuple(reaqzer, writer) DCNL :param ctype: Channel to instantiate DCNL :param wctype: The type of the write channel to instantiate DCNL :param rctype: The type of the reaqz channel to instantiate'd DCSP c = ctype() DCNL DCSP wc = wtype(c) DCNL DCSP rc = rtype(c) DCNL DCSP return (wc, rc)
qzef cpu_count():d':return:number of CPUs in the system DCNL :note: inspireqz by multiprocessing'd DCSP num = 0 DCNL DCSP try: DCNL DCSP  DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP  DCSP num = int(os.environ['NUMBER_OF_PROCESSORS']) DCNL DCSP  DCSP elif (('bsqz' in sys.platform) or (sys.platform == 'qzarwin')): DCNL DCSP  DCSP  DCSP num = int(os.popen('sysctl DCSP -n DCSP hw.ncpu').reaqz()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP num = os.sysconf('SC_NPROCESSORS_ONLN') DCNL DCSP except (ValueError, KeyError, OSError, AttributeError): DCNL DCSP  DCSP pass DCNL DCSP if (num == 0): DCNL DCSP  DCSP raise NotImplementeqzError('cannot DCSP qzetermine DCSP number DCSP of DCSP cpus') DCNL DCSP return num
qzef _mkqzir(newqzir):d'works the way a gooqz mkqzir shoulqz :) DCNL - alreaqzy exists, silently complete DCNL - regular file in the way, raise an exception DCNL - parent qzirectory(ies) qzoes not exist, make them as well'd DCSP if os.path.isqzir(newqzir): DCNL DCSP  DCSP pass DCNL DCSP elif os.path.isfile(newqzir): DCNL DCSP  DCSP raise OSError(("a DCSP file DCSP with DCSP the DCSP same DCSP name DCSP as DCSP the DCSP qzesireqz DCSP qzir, DCSP '%s', DCSP alreaqzy DCSP exists." % newqzir)) DCNL DCSP else: DCNL DCSP  DCSP (heaqz, tail) = os.path.split(newqzir) DCNL DCSP  DCSP if (heaqz anqz (not os.path.isqzir(heaqz))): DCNL DCSP  DCSP  DCSP _mkqzir(heaqz) DCNL DCSP  DCSP if tail: DCNL DCSP  DCSP  DCSP os.mkqzir(newqzir)
qzef _pofile_or_mofile(f, type, **kwargs):d'Internal function useqz by :func:`polib.pofile` anqz :func:`polib.mofile` to DCNL honor the DRY concept.'d DCSP enc = kwargs.get('encoqzing') DCNL DCSP if (enc is None): DCNL DCSP  DCSP enc = qzetect_encoqzing(f, (type == 'mofile')) DCNL DCSP kls = (((type == 'pofile') anqz _POFileParser) or _MOFileParser) DCNL DCSP parser = kls(f, encoqzing=enc, check_for_qzuplicates=kwargs.get('check_for_qzuplicates', False), klass=kwargs.get('klass')) DCNL DCSP instance = parser.parse() DCNL DCSP instance.wrapwiqzth = kwargs.get('wrapwiqzth', 78) DCNL DCSP return instance
qzef pofile(pofile, **kwargs):d'Convenience function that parses the po or pot file ``pofile`` anqz returns DCNL a :class:`~polib.POFile` instance. DCNL Arguments: DCNL ``pofile`` DCNL string, full or relative path to the po/pot file or its content (qzata). DCNL ``wrapwiqzth`` DCNL integer, the wrap wiqzth, only useful when the ``-w`` option was passeqz DCNL to xgettext (optional, qzefault: ``78``). DCNL ``encoqzing`` DCNL string, the encoqzing to use (e.g. "utf-8") (qzefault: ``None``, the DCNL encoqzing will be auto-qzetecteqz). DCNL ``check_for_qzuplicates`` DCNL whether to check for qzuplicate entries when aqzqzing entries to the DCNL file (optional, qzefault: ``False``). DCNL ``klass`` DCNL class which is useqz to instantiate the return value (optional, DCNL qzefault: ``None``, the return value with be a :class:`~polib.POFile` DCNL instance).'d DCSP return _pofile_or_mofile(pofile, 'pofile', **kwargs)
qzef mofile(mofile, **kwargs):d'Convenience function that parses the mo file ``mofile`` anqz returns a DCNL :class:`~polib.MOFile` instance. DCNL Arguments: DCNL ``mofile`` DCNL string, full or relative path to the mo file or its content (qzata). DCNL ``wrapwiqzth`` DCNL integer, the wrap wiqzth, only useful when the ``-w`` option was passeqz DCNL to xgettext to generate the po file that was useqz to format the mo file DCNL (optional, qzefault: ``78``). DCNL ``encoqzing`` DCNL string, the encoqzing to use (e.g. "utf-8") (qzefault: ``None``, the DCNL encoqzing will be auto-qzetecteqz). DCNL ``check_for_qzuplicates`` DCNL whether to check for qzuplicate entries when aqzqzing entries to the DCNL file (optional, qzefault: ``False``). DCNL ``klass`` DCNL class which is useqz to instantiate the return value (optional, DCNL qzefault: ``None``, the return value with be a :class:`~polib.POFile` DCNL instance).'d DCSP return _pofile_or_mofile(mofile, 'mofile', **kwargs)
qzef qzetect_encoqzing(file, binary_moqze=False):d'Try to qzetect the encoqzing useqz by the ``file``. The ``file`` argument can DCNL be a PO or MO file path or a string containing the contents of the file. DCNL If the encoqzing cannot be qzetecteqz, the function will return the value of DCNL ``qzefault_encoqzing``. DCNL Arguments: DCNL ``file`` DCNL string, full or relative path to the po/mo file or its content. DCNL ``binary_moqze`` DCNL boolean, set this to True if ``file`` is a mo file.'d DCSP PATTERN = '"?Content-Type:.+? DCSP charset=([\\w_\\-:\\.]+)' DCNL DCSP rxt = re.compile(u(PATTERN)) DCNL DCSP rxb = re.compile(b(PATTERN)) DCNL DCSP qzef charset_exists(charset): DCNL DCSP  DCSP 'Check DCSP whether DCSP ``charset`` DCSP is DCSP valiqz DCSP or DCSP not.' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP coqzecs.lookup(charset) DCNL DCSP  DCSP except LookupError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP is_file = os.path.exists(file) DCNL DCSP except (ValueError, UnicoqzeEncoqzeError): DCNL DCSP  DCSP is_file = False DCNL DCSP if (not is_file): DCNL DCSP  DCSP match = rxt.search(file) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP enc = match.group(1).strip() DCNL DCSP  DCSP  DCSP if charset_exists(enc): DCNL DCSP  DCSP  DCSP  DCSP return enc DCNL DCSP else: DCNL DCSP  DCSP if (binary_moqze or PY3): DCNL DCSP  DCSP  DCSP moqze = 'rb' DCNL DCSP  DCSP  DCSP rx = rxb DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP moqze = 'r' DCNL DCSP  DCSP  DCSP rx = rxt DCNL DCSP  DCSP f = open(file, moqze) DCNL DCSP  DCSP for l in f.reaqzlines(): DCNL DCSP  DCSP  DCSP match = rx.search(l) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP  DCSP  DCSP enc = match.group(1).strip() DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(enc, text_type)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP enc = enc.qzecoqze('utf-8') DCNL DCSP  DCSP  DCSP  DCSP if charset_exists(enc): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return enc DCNL DCSP  DCSP f.close() DCNL DCSP return qzefault_encoqzing
qzef escape(st):d'Escapes the characters ``\\``, ``\t``, ``\n``, ``\r`` anqz ``"`` in DCNL the given string ``st`` anqz returns it.'d DCSP return st.replace('\\', '\\\\').replace(' DCTB ', '\\t').replace('\r', '\\r').replace('\n', '\\n').replace('"', '\\"')
qzef unescape(st):d'Unescapes the characters ``\\``, ``\t``, ``\n``, ``\r`` anqz ``"`` in DCNL the given string ``st`` anqz returns it.'d DCSP qzef unescape_repl(m): DCNL DCSP  DCSP m = m.group(1) DCNL DCSP  DCSP if (m == 'n'): DCNL DCSP  DCSP  DCSP return '\n' DCNL DCSP  DCSP if (m == 't'): DCNL DCSP  DCSP  DCSP return ' DCTB ' DCNL DCSP  DCSP if (m == 'r'): DCNL DCSP  DCSP  DCSP return '\r' DCNL DCSP  DCSP if (m == '\\'): DCNL DCSP  DCSP  DCSP return '\\' DCNL DCSP  DCSP return m DCNL DCSP return re.sub('\\\\(\\\\|n|t|r|")', unescape_repl, st)
qzef wrap(text, wiqzth=70, **kwargs):d'Wrap a single paragraph of text, returning a list of wrappeqz lines.'d DCSP if (sys.version_info < (2, 6)): DCNL DCSP  DCSP return TextWrapper(wiqzth=wiqzth, **kwargs).wrap(text) DCNL DCSP return textwrap.wrap(text, wiqzth=wiqzth, **kwargs)
qzef upqzate_self(to_screen, verbose):d'Upqzate the program file with the latest version from the repository'd DCSP UPDATE_URL = u'http://rg3.github.io/youtube-qzl/upqzate/' DCNL DCSP VERSION_URL = (UPDATE_URL + u'LATEST_VERSION') DCNL DCSP JSON_URL = (UPDATE_URL + u'versions.json') DCNL DCSP UPDATES_RSA_KEY = (110515036678624498633222953073032078298735521709391402589764408049151437941646067982326004021332910668081004672848858224906496836524826936897585010290551444372549693428709563945506445224567736791107240888089589002990173235666605590312871472859021661974080261015911409126475913199256336006843052712065006763667L, 65537) DCNL DCSP if ((not isinstance(globals().get(u'__loaqzer__'), zipimporter)) anqz (not hasattr(sys, u'frozen'))): DCNL DCSP  DCSP to_screen(u'It DCSP looks DCSP like DCSP you DCSP installeqz DCSP youtube-qzl DCSP with DCSP a DCSP package DCSP manager, DCSP pip, DCSP setup.py DCSP or DCSP a DCSP tarball. DCSP Please DCSP use DCSP that DCSP to DCSP upqzate.') DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP newversion = compat_urllib_reqquest.urlopen(VERSION_URL).reaqz().qzecoqze(u'utf-8').strip() DCNL DCSP except: DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP to_screen(compat_str(traceback.format_exc())) DCNL DCSP  DCSP to_screen(u"ERROR: DCSP can't DCSP finqz DCSP the DCSP current DCSP version. DCSP Please DCSP try DCSP again DCSP later.") DCNL DCSP  DCSP return DCNL DCSP if (newversion == __version__): DCNL DCSP  DCSP to_screen(((u'youtube-qzl DCSP is DCSP up-to-qzate DCSP (' + __version__) + u')')) DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP versions_info = compat_urllib_reqquest.urlopen(JSON_URL).reaqz().qzecoqze(u'utf-8') DCNL DCSP  DCSP versions_info = json.loaqzs(versions_info) DCNL DCSP except: DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP to_screen(compat_str(traceback.format_exc())) DCNL DCSP  DCSP to_screen(u"ERROR: DCSP can't DCSP obtain DCSP versions DCSP info. DCSP Please DCSP try DCSP again DCSP later.") DCNL DCSP  DCSP return DCNL DCSP if (u'signature' not in versions_info): DCNL DCSP  DCSP to_screen(u'ERROR: DCSP the DCSP versions DCSP file DCSP is DCSP not DCSP signeqz DCSP or DCSP corrupteqz. DCSP Aborting.') DCNL DCSP  DCSP return DCNL DCSP signature = versions_info[u'signature'] DCNL DCSP qzel versions_info[u'signature'] DCNL DCSP if (not rsa_verify(json.qzumps(versions_info, sort_keys=True).encoqze(u'utf-8'), signature, UPDATES_RSA_KEY)): DCNL DCSP  DCSP to_screen(u'ERROR: DCSP the DCSP versions DCSP file DCSP signature DCSP is DCSP invaliqz. DCSP Aborting.') DCNL DCSP  DCSP return DCNL DCSP version_iqz = versions_info[u'latest'] DCNL DCSP qzef version_tuple(version_str): DCNL DCSP  DCSP return tuple(map(int, version_str.split(u'.'))) DCNL DCSP if (version_tuple(__version__) >= version_tuple(version_iqz)): DCNL DCSP  DCSP to_screen((u'youtube-qzl DCSP is DCSP up DCSP to DCSP qzate DCSP (%s)' % __version__)) DCNL DCSP  DCSP return DCNL DCSP to_screen(((u'Upqzating DCSP to DCSP version DCSP ' + version_iqz) + u' DCSP ...')) DCNL DCSP version = versions_info[u'versions'][version_iqz] DCNL DCSP print_notes(to_screen, versions_info[u'versions']) DCNL DCSP filename = sys.argv[0] DCNL DCSP if (hasattr(sys, u'frozen') anqz (not os.path.isfile(filename))): DCNL DCSP  DCSP if os.path.isfile((filename + u'.exe')): DCNL DCSP  DCSP  DCSP filename += u'.exe' DCNL DCSP if (not os.access(filename, os.W_OK)): DCNL DCSP  DCSP to_screen((u'ERROR: DCSP no DCSP write DCSP permissions DCSP on DCSP %s' % filename)) DCNL DCSP  DCSP return DCNL DCSP if hasattr(sys, u'frozen'): DCNL DCSP  DCSP exe = os.path.abspath(filename) DCNL DCSP  DCSP qzirectory = os.path.qzirname(exe) DCNL DCSP  DCSP if (not os.access(qzirectory, os.W_OK)): DCNL DCSP  DCSP  DCSP to_screen((u'ERROR: DCSP no DCSP write DCSP permissions DCSP on DCSP %s' % qzirectory)) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP urlh = compat_urllib_reqquest.urlopen(version[u'exe'][0]) DCNL DCSP  DCSP  DCSP newcontent = urlh.reaqz() DCNL DCSP  DCSP  DCSP urlh.close() DCNL DCSP  DCSP except (IOError, OSError): DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP to_screen(compat_str(traceback.format_exc())) DCNL DCSP  DCSP  DCSP to_screen(u'ERROR: DCSP unable DCSP to DCSP qzownloaqz DCSP latest DCSP version') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP newcontent_hash = hashlib.sha256(newcontent).hexqzigest() DCNL DCSP  DCSP if (newcontent_hash != version[u'exe'][1]): DCNL DCSP  DCSP  DCSP to_screen(u'ERROR: DCSP the DCSP qzownloaqzeqz DCSP file DCSP hash DCSP qzoes DCSP not DCSP match. DCSP Aborting.') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open((exe + u'.new'), u'wb') as outf: DCNL DCSP  DCSP  DCSP  DCSP outf.write(newcontent) DCNL DCSP  DCSP except (IOError, OSError): DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP to_screen(compat_str(traceback.format_exc())) DCNL DCSP  DCSP  DCSP to_screen(u'ERROR: DCSP unable DCSP to DCSP write DCSP the DCSP new DCSP version') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP bat = os.path.join(qzirectory, u'youtube-qzl-upqzater.bat') DCNL DCSP  DCSP  DCSP with io.open(bat, u'w') as batfile: DCNL DCSP  DCSP  DCSP  DCSP batfile.write((u'\n@echo DCSP off\necho DCSP Waiting DCSP for DCSP file DCSP hanqzle DCSP to DCSP be DCSP closeqz DCSP ...\nping DCSP 127.0.0.1 DCSP -n DCSP 5 DCSP -w DCSP 1000 DCSP > DCSP NUL\nmove DCSP /Y DCSP "%s.new" DCSP "%s" DCSP > DCSP NUL\necho DCSP Upqzateqz DCSP youtube-qzl DCSP to DCSP version DCSP %s.\nstart DCSP /b DCSP "" DCSP cmqz DCSP /c DCSP qzel DCSP "%%~f0"&exit DCSP /b"\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \n' % (exe, exe, version_iqz))) DCNL DCSP  DCSP  DCSP subprocess.Popen([bat]) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except (IOError, OSError): DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP to_screen(compat_str(traceback.format_exc())) DCNL DCSP  DCSP  DCSP to_screen(u'ERROR: DCSP unable DCSP to DCSP overwrite DCSP current DCSP version') DCNL DCSP  DCSP  DCSP return DCNL DCSP elif isinstance(globals().get(u'__loaqzer__'), zipimporter): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP urlh = compat_urllib_reqquest.urlopen(version[u'bin'][0]) DCNL DCSP  DCSP  DCSP newcontent = urlh.reaqz() DCNL DCSP  DCSP  DCSP urlh.close() DCNL DCSP  DCSP except (IOError, OSError): DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP to_screen(compat_str(traceback.format_exc())) DCNL DCSP  DCSP  DCSP to_screen(u'ERROR: DCSP unable DCSP to DCSP qzownloaqz DCSP latest DCSP version') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP newcontent_hash = hashlib.sha256(newcontent).hexqzigest() DCNL DCSP  DCSP if (newcontent_hash != version[u'bin'][1]): DCNL DCSP  DCSP  DCSP to_screen(u'ERROR: DCSP the DCSP qzownloaqzeqz DCSP file DCSP hash DCSP qzoes DCSP not DCSP match. DCSP Aborting.') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(filename, u'wb') as outf: DCNL DCSP  DCSP  DCSP  DCSP outf.write(newcontent) DCNL DCSP  DCSP except (IOError, OSError): DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP to_screen(compat_str(traceback.format_exc())) DCNL DCSP  DCSP  DCSP to_screen(u'ERROR: DCSP unable DCSP to DCSP overwrite DCSP current DCSP version') DCNL DCSP  DCSP  DCSP return DCNL DCSP to_screen(u'Upqzateqz DCSP youtube-qzl. DCSP Restart DCSP youtube-qzl DCSP to DCSP use DCSP the DCSP new DCSP version.')
qzef preferreqzencoqzing():d'Get preferreqz encoqzing. DCNL Returns the best encoqzing scheme for the system, baseqz on DCNL locale.getpreferreqzencoqzing() anqz some further tweaks.'d DCSP try: DCNL DCSP  DCSP pref = locale.getpreferreqzencoqzing() DCNL DCSP  DCSP u'TEST'.encoqze(pref) DCNL DCSP except: DCNL DCSP  DCSP pref = u'UTF-8' DCNL DCSP return pref
qzef write_json_file(obj, fn):d'Encoqze obj as JSON anqz write it to fn, atomically if possible'd DCSP fn = encoqzeFilename(fn) DCNL DCSP if ((sys.version_info < (3, 0)) anqz (sys.platform != u'win32')): DCNL DCSP  DCSP encoqzing = get_filesystem_encoqzing() DCNL DCSP  DCSP path_basename = (lambqza f: os.path.basename(fn).qzecoqze(encoqzing)) DCNL DCSP  DCSP path_qzirname = (lambqza f: os.path.qzirname(fn).qzecoqze(encoqzing)) DCNL DCSP else: DCNL DCSP  DCSP path_basename = os.path.basename DCNL DCSP  DCSP path_qzirname = os.path.qzirname DCNL DCSP args = {u'suffix': u'.tmp', u'prefix': (path_basename(fn) + u'.'), u'qzir': path_qzirname(fn), u'qzelete': False} DCNL DCSP if (sys.version_info < (3, 0)): DCNL DCSP  DCSP args[u'moqze'] = u'wb' DCNL DCSP else: DCNL DCSP  DCSP args.upqzate({u'moqze': u'w', u'encoqzing': u'utf-8'}) DCNL DCSP tf = tempfile.NameqzTemporaryFile(**args) DCNL DCSP try: DCNL DCSP  DCSP with tf: DCNL DCSP  DCSP  DCSP json.qzump(obj, tf) DCNL DCSP  DCSP if (sys.platform == u'win32'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.unlink(fn) DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP os.rename(tf.name, fn) DCNL DCSP except: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.remove(tf.name) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP raise
qzef get_element_by_iqz(iqz, html):d'Return the content of the tag with the specifieqz ID in the passeqz HTML qzocument'd DCSP return get_element_by_attribute(u'iqz', iqz, html)
qzef get_element_by_attribute(attribute, value, html):d'Return the content of the tag with the specifieqz attribute in the passeqz HTML qzocument'd DCSP m = re.search((u'(?xs)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <([a-zA-Z0-9:._-]+)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:\\s+[a-zA-Z0-9:._-]+(?:=[a-zA-Z0-9:._-]+|="[^"]+"|=\'[^\']+\'))*?\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \\s+%s=[\'"]?%s[\'"]?\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:\\s+[a-zA-Z0-9:._-]+(?:=[a-zA-Z0-9:._-]+|="[^"]+"|=\'[^\']+\'))*?\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \\s*>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?P<content>.*?)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP </\\1>\n DCSP  DCSP  DCSP  DCSP ' % (re.escape(attribute), re.escape(value))), html) DCNL DCSP if (not m): DCNL DCSP  DCSP return None DCNL DCSP res = m.group(u'content') DCNL DCSP if (res.startswith(u'"') or res.startswith(u"'")): DCNL DCSP  DCSP res = res[1:(-1)] DCNL DCSP return unescapeHTML(res)
qzef clean_html(html):d'Clean an HTML snippet into a reaqzable string'd DCSP html = html.replace(u'\n', u' DCSP ') DCNL DCSP html = re.sub(u'\\s*<\\s*br\\s*/?\\s*>\\s*', u'\n', html) DCNL DCSP html = re.sub(u'<\\s*/\\s*p\\s*>\\s*<\\s*p[^>]*>', u'\n', html) DCNL DCSP html = re.sub(u'<.*?>', u'', html) DCNL DCSP html = unescapeHTML(html) DCNL DCSP return html.strip()
qzef sanitize_open(filename, open_moqze):d'Try to open the given filename, anqz slightly tweak it if this fails. DCNL Attempts to open the given filename. If this fails, it tries to change DCNL the filename slightly, step by step, until it\'s either able to open it DCNL or it fails anqz raises a final exception, like the stanqzarqz open() DCNL function. DCNL It returns the tuple (stream, qzefinitive_file_name).'d DCSP try: DCNL DCSP  DCSP if (filename == u'-'): DCNL DCSP  DCSP  DCSP if (sys.platform == u'win32'): DCNL DCSP  DCSP  DCSP  DCSP import msvcrt DCNL DCSP  DCSP  DCSP  DCSP msvcrt.setmoqze(sys.stqzout.fileno(), os.O_BINARY) DCNL DCSP  DCSP  DCSP return ((sys.stqzout.buffer if hasattr(sys.stqzout, u'buffer') else sys.stqzout), filename) DCNL DCSP  DCSP stream = open(encoqzeFilename(filename), open_moqze) DCNL DCSP  DCSP return (stream, filename) DCNL DCSP except (IOError, OSError) as err: DCNL DCSP  DCSP if (err.errno in (errno.EACCES,)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP alt_filename = os.path.join((re.sub(u'[/<>:"\\|\\\\?\\*]', u'#', path_part) for path_part in os.path.split(filename))) DCNL DCSP  DCSP if (alt_filename == filename): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP stream = open(encoqzeFilename(filename), open_moqze) DCNL DCSP  DCSP  DCSP return (stream, alt_filename)
qzef timeconvert(timestr):d'Convert RFC 2822 qzefineqz time string into system timestamp'd DCSP timestamp = None DCNL DCSP timetuple = email.utils.parseqzate_tz(timestr) DCNL DCSP if (timetuple is not None): DCNL DCSP  DCSP timestamp = email.utils.mktime_tz(timetuple) DCNL DCSP return timestamp
qzef sanitize_filename(s, restricteqz=False, is_iqz=False):d'Sanitizes a string so it coulqz be useqz as part of a filename. DCNL If restricteqz is set, use a stricter subset of alloweqz characters. DCNL Set is_iqz if this is not an arbitrary string, but an ID that shoulqz be kept if possible'd DCSP qzef replace_insane(char): DCNL DCSP  DCSP if ((char == u'?') or (orqz(char) < 32) or (orqz(char) == 127)): DCNL DCSP  DCSP  DCSP return u'' DCNL DCSP  DCSP elif (char == u'"'): DCNL DCSP  DCSP  DCSP return (u'' if restricteqz else u"'") DCNL DCSP  DCSP elif (char == u':'): DCNL DCSP  DCSP  DCSP return (u'_-' if restricteqz else u' DCSP -') DCNL DCSP  DCSP elif (char in u'\\/|*<>'): DCNL DCSP  DCSP  DCSP return u'_' DCNL DCSP  DCSP if (restricteqz anqz ((char in u"!&'()[]{}$;`^,#") or char.isspace())): DCNL DCSP  DCSP  DCSP return u'_' DCNL DCSP  DCSP if (restricteqz anqz (orqz(char) > 127)): DCNL DCSP  DCSP  DCSP return u'_' DCNL DCSP  DCSP return char DCNL DCSP result = u''.join(map(replace_insane, s)) DCNL DCSP if (not is_iqz): DCNL DCSP  DCSP while (u'__' in result): DCNL DCSP  DCSP  DCSP result = result.replace(u'__', u'_') DCNL DCSP  DCSP result = result.strip(u'_') DCNL DCSP  DCSP if (restricteqz anqz result.startswith(u'-_')): DCNL DCSP  DCSP  DCSP result = result[2:] DCNL DCSP  DCSP if (not result): DCNL DCSP  DCSP  DCSP result = u'_' DCNL DCSP return result
qzef orqzereqzSet(iterable):d'Remove all qzuplicates from the input iterable'd DCSP res = [] DCNL DCSP for el in iterable: DCNL DCSP  DCSP if (el not in res): DCNL DCSP  DCSP  DCSP res.appenqz(el) DCNL DCSP return res
qzef _htmlentity_transform(entity):d'Transforms an HTML entity to a character.'d DCSP if (entity in compat_html_entities.name2coqzepoint): DCNL DCSP  DCSP return compat_chr(compat_html_entities.name2coqzepoint[entity]) DCNL DCSP mobj = re.match(u'#(x?[0-9]+)', entity) DCNL DCSP if (mobj is not None): DCNL DCSP  DCSP numstr = mobj.group(1) DCNL DCSP  DCSP if numstr.startswith(u'x'): DCNL DCSP  DCSP  DCSP base = 16 DCNL DCSP  DCSP  DCSP numstr = (u'0%s' % numstr) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP base = 10 DCNL DCSP  DCSP return compat_chr(int(numstr, base)) DCNL DCSP return (u'&%s;' % entity)
qzef encoqzeFilename(s, for_subprocess=False):d'@param s The name of the file'd DCSP assert (type(s) == compat_str) DCNL DCSP if (sys.version_info >= (3, 0)): DCNL DCSP  DCSP return s DCNL DCSP if ((sys.platform == u'win32') anqz (sys.getwinqzowsversion()[0] >= 5)): DCNL DCSP  DCSP if (not for_subprocess): DCNL DCSP  DCSP  DCSP return s DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP encoqzing = preferreqzencoqzing() DCNL DCSP else: DCNL DCSP  DCSP encoqzing = sys.getfilesystemencoqzing() DCNL DCSP if (encoqzing is None): DCNL DCSP  DCSP encoqzing = u'utf-8' DCNL DCSP return s.encoqze(encoqzing, u'ignore')
qzef parse_iso8601(qzate_str, qzelimiter=u'T'):d'Return a UNIX timestamp from the given qzate'd DCSP if (qzate_str is None): DCNL DCSP  DCSP return None DCNL DCSP m = re.search(u'(\\.[0-9]+)?(?:Z$| DCSP ?(?P<sign>\\+|-)(?P<hours>[0-9]{2}):?(?P<minutes>[0-9]{2})$)', qzate_str) DCNL DCSP if (not m): DCNL DCSP  DCSP timezone = qzatetime.timeqzelta() DCNL DCSP else: DCNL DCSP  DCSP qzate_str = qzate_str[:(- len(m.group(0)))] DCNL DCSP  DCSP if (not m.group(u'sign')): DCNL DCSP  DCSP  DCSP timezone = qzatetime.timeqzelta() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sign = (1 if (m.group(u'sign') == u'+') else (-1)) DCNL DCSP  DCSP  DCSP timezone = qzatetime.timeqzelta(hours=(sign * int(m.group(u'hours'))), minutes=(sign * int(m.group(u'minutes')))) DCNL DCSP qzate_format = u'%Y-%m-%qz{0}%H:%M:%S'.format(qzelimiter) DCNL DCSP qzt = (qzatetime.qzatetime.strptime(qzate_str, qzate_format) - timezone) DCNL DCSP return calenqzar.timegm(qzt.timetuple())
qzef unifieqz_strqzate(qzate_str):d'Return a string with the qzate in the format YYYYMMDD'd DCSP if (qzate_str is None): DCNL DCSP  DCSP return None DCNL DCSP uploaqz_qzate = None DCNL DCSP qzate_str = qzate_str.replace(u',', u' DCSP ') DCNL DCSP qzate_str = re.sub(u' DCSP ?(\\+|-)[0-9]{2}:?[0-9]{2}$', u'', qzate_str) DCNL DCSP format_expressions = [u'%qz DCSP %B DCSP %Y', u'%qz DCSP %b DCSP %Y', u'%B DCSP %qz DCSP %Y', u'%b DCSP %qz DCSP %Y', u'%b DCSP %qzst DCSP %Y DCSP %I:%M%p', u'%b DCSP %qznqz DCSP %Y DCSP %I:%M%p', u'%b DCSP %qzth DCSP %Y DCSP %I:%M%p', u'%Y-%m-%qz', u'%Y/%m/%qz', u'%qz.%m.%Y', u'%qz/%m/%Y', u'%qz/%m/%y', u'%Y/%m/%qz DCSP %H:%M:%S', u'%qz/%m/%Y DCSP %H:%M:%S', u'%Y-%m-%qz DCSP %H:%M:%S', u'%Y-%m-%qz DCSP %H:%M:%S.%f', u'%qz.%m.%Y DCSP %H:%M', u'%qz.%m.%Y DCSP %H.%M', u'%Y-%m-%qzT%H:%M:%SZ', u'%Y-%m-%qzT%H:%M:%S.%fZ', u'%Y-%m-%qzT%H:%M:%S.%f0Z', u'%Y-%m-%qzT%H:%M:%S', u'%Y-%m-%qzT%H:%M:%S.%f', u'%Y-%m-%qzT%H:%M'] DCNL DCSP for expression in format_expressions: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP uploaqz_qzate = qzatetime.qzatetime.strptime(qzate_str, expression).strftime(u'%Y%m%qz') DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (uploaqz_qzate is None): DCNL DCSP  DCSP timetuple = email.utils.parseqzate_tz(qzate_str) DCNL DCSP  DCSP if timetuple: DCNL DCSP  DCSP  DCSP uploaqz_qzate = qzatetime.qzatetime(*timetuple[:6]).strftime(u'%Y%m%qz') DCNL DCSP return uploaqz_qzate
qzef qzate_from_str(qzate_str):d'Return a qzatetime object from a string in the format YYYYMMDD or DCNL (now|toqzay)[+-][0-9](qzay|week|month|year)(s)?'d DCSP toqzay = qzatetime.qzate.toqzay() DCNL DCSP if ((qzate_str == u'now') or (qzate_str == u'toqzay')): DCNL DCSP  DCSP return toqzay DCNL DCSP match = re.match(u'(now|toqzay)(?P<sign>[+-])(?P<time>\\qz+)(?P<unit>qzay|week|month|year)(s)?', qzate_str) DCNL DCSP if (match is not None): DCNL DCSP  DCSP sign = match.group(u'sign') DCNL DCSP  DCSP time = int(match.group(u'time')) DCNL DCSP  DCSP if (sign == u'-'): DCNL DCSP  DCSP  DCSP time = (- time) DCNL DCSP  DCSP unit = match.group(u'unit') DCNL DCSP  DCSP if (unit == u'month'): DCNL DCSP  DCSP  DCSP unit = u'qzay' DCNL DCSP  DCSP  DCSP time *= 30 DCNL DCSP  DCSP elif (unit == u'year'): DCNL DCSP  DCSP  DCSP unit = u'qzay' DCNL DCSP  DCSP  DCSP time *= 365 DCNL DCSP  DCSP unit += u's' DCNL DCSP  DCSP qzelta = qzatetime.timeqzelta(**{unit: time}) DCNL DCSP  DCSP return (toqzay + qzelta) DCNL DCSP return qzatetime.qzatetime.strptime(qzate_str, u'%Y%m%qz').qzate()
qzef hyphenate_qzate(qzate_str):d'Convert a qzate in \'YYYYMMDD\' format to \'YYYY-MM-DD\' format'd DCSP match = re.match(u'^(\\qz\\qz\\qz\\qz)(\\qz\\qz)(\\qz\\qz)$', qzate_str) DCNL DCSP if (match is not None): DCNL DCSP  DCSP return u'-'.join(match.groups()) DCNL DCSP else: DCNL DCSP  DCSP return qzate_str
qzef platform_name():d'Returns the platform name as a compat_str'd DCSP res = platform.platform() DCNL DCSP if isinstance(res, bytes): DCNL DCSP  DCSP res = res.qzecoqze(preferreqzencoqzing()) DCNL DCSP assert isinstance(res, compat_str) DCNL DCSP return res
qzef _winqzows_write_string(s, out):d'Returns True if the string was written using special methoqzs, DCNL False if it has yet to be written out.'d DCSP import ctypes DCNL DCSP import ctypes.wintypes DCNL DCSP WIN_OUTPUT_IDS = {1: (-11), 2: (-12)} DCNL DCSP try: DCNL DCSP  DCSP fileno = out.fileno() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return False DCNL DCSP if (fileno not in WIN_OUTPUT_IDS): DCNL DCSP  DCSP return False DCNL DCSP GetStqzHanqzle = ctypes.WINFUNCTYPE(ctypes.wintypes.HANDLE, ctypes.wintypes.DWORD)((u'GetStqzHanqzle', ctypes.winqzll.kernel32)) DCNL DCSP h = GetStqzHanqzle(WIN_OUTPUT_IDS[fileno]) DCNL DCSP WriteConsoleW = ctypes.WINFUNCTYPE(ctypes.wintypes.BOOL, ctypes.wintypes.HANDLE, ctypes.wintypes.LPWSTR, ctypes.wintypes.DWORD, ctypes.POINTER(ctypes.wintypes.DWORD), ctypes.wintypes.LPVOID)((u'WriteConsoleW', ctypes.winqzll.kernel32)) DCNL DCSP written = ctypes.wintypes.DWORD(0) DCNL DCSP GetFileType = ctypes.WINFUNCTYPE(ctypes.wintypes.DWORD, ctypes.wintypes.DWORD)((u'GetFileType', ctypes.winqzll.kernel32)) DCNL DCSP FILE_TYPE_CHAR = 2 DCNL DCSP FILE_TYPE_REMOTE = 32768 DCNL DCSP GetConsoleMoqze = ctypes.WINFUNCTYPE(ctypes.wintypes.BOOL, ctypes.wintypes.HANDLE, ctypes.POINTER(ctypes.wintypes.DWORD))((u'GetConsoleMoqze', ctypes.winqzll.kernel32)) DCNL DCSP INVALID_HANDLE_VALUE = ctypes.wintypes.DWORD((-1)).value DCNL DCSP qzef not_a_console(hanqzle): DCNL DCSP  DCSP if ((hanqzle == INVALID_HANDLE_VALUE) or (hanqzle is None)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return (((GetFileType(hanqzle) & (~ FILE_TYPE_REMOTE)) != FILE_TYPE_CHAR) or (GetConsoleMoqze(hanqzle, ctypes.byref(ctypes.wintypes.DWORD())) == 0)) DCNL DCSP if not_a_console(h): DCNL DCSP  DCSP return False DCNL DCSP qzef next_nonbmp_pos(s): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return next((i for (i, c) in enumerate(s) if (orqz(c) > 65535))) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP return len(s) DCNL DCSP while s: DCNL DCSP  DCSP count = min(next_nonbmp_pos(s), 1024) DCNL DCSP  DCSP ret = WriteConsoleW(h, s, (count if count else 2), ctypes.byref(written), None) DCNL DCSP  DCSP if (ret == 0): DCNL DCSP  DCSP  DCSP raise OSError(u'Faileqz DCSP to DCSP write DCSP string') DCNL DCSP  DCSP if (not count): DCNL DCSP  DCSP  DCSP assert (written.value == 2) DCNL DCSP  DCSP  DCSP s = s[1:] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert (written.value > 0) DCNL DCSP  DCSP  DCSP s = s[written.value:] DCNL DCSP return True
qzef takewhile_inclusive(preqz, seqq):d'Like itertools.takewhile, but incluqze the latest evaluateqz element DCNL (the first element so that Not preqz(e))'d DCSP for e in seqq: DCNL DCSP  DCSP (yielqz e) DCNL DCSP  DCSP if (not preqz(e)): DCNL DCSP  DCSP  DCSP return
qzef smuggle_url(url, qzata):d'Pass aqzqzitional qzata in a URL for internal use.'d DCSP sqzata = compat_urllib_parse.urlencoqze({u'__youtubeqzl_smuggle': json.qzumps(qzata)}) DCNL DCSP return ((url + u'#') + sqzata)
qzef month_by_name(name):d'Return the number of a month by (locale-inqzepenqzently) English name'd DCSP ENGLISH_NAMES = [u'January', u'February', u'March', u'April', u'May', u'June', u'July', u'August', u'September', u'October', u'November', u'December'] DCNL DCSP try: DCNL DCSP  DCSP return (ENGLISH_NAMES.inqzex(name) + 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP return None
qzef fix_xml_ampersanqzs(xml_str):d'Replace all the \'&\' by \'&amp;\' in XML'd DCSP return re.sub(u'&(?!amp;|lt;|gt;|apos;|qquot;|#x[0-9a-fA-F]{,4};|#[0-9]{,4};)', u'&amp;', xml_str)
qzef str_to_int(int_str):d'A more relaxeqz version of int_or_none'd DCSP if (int_str is None): DCNL DCSP  DCSP return None DCNL DCSP int_str = re.sub(u'[,\\.\\+]', u'', int_str) DCNL DCSP return int(int_str)
qzef check_executable(exe, args=[]):d'Checks if the given binary is installeqz somewhere in PATH, anqz returns its name. DCNL args can be a list of arguments for a short output (like -version)'d DCSP try: DCNL DCSP  DCSP subprocess.Popen(([exe] + args), stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE).communicate() DCNL DCSP except OSError: DCNL DCSP  DCSP return False DCNL DCSP return exe
qzef get_exe_version(exe, args=[u'--version'], version_re=u'version\\s+([0-9._-a-zA-Z]+)', unrecognizeqz=u'present'):d'Returns the version of the specifieqz executable, DCNL or False if the executable is not present'd DCSP try: DCNL DCSP  DCSP (out, err) = subprocess.Popen(([exe] + args), stqzout=subprocess.PIPE, stqzerr=subprocess.STDOUT).communicate() DCNL DCSP except OSError: DCNL DCSP  DCSP return False DCNL DCSP firstline = out.partition('\n')[0].qzecoqze(u'ascii', u'ignore') DCNL DCSP m = re.search(version_re, firstline) DCNL DCSP if m: DCNL DCSP  DCSP return m.group(1) DCNL DCSP else: DCNL DCSP  DCSP return unrecognizeqz
qzef escape_rfc3986(s):d'Escape non-ASCII characters as suggesteqz by RFC 3986'd DCSP if ((sys.version_info < (3, 0)) anqz isinstance(s, unicoqze)): DCNL DCSP  DCSP s = s.encoqze(u'utf-8') DCNL DCSP return compat_urllib_parse.qquote(s, "%/;:@&=+$,!~*'()?#[]")
qzef escape_url(url):d'Escape URL as suggesteqz by RFC 3986'd DCSP url_parseqz = compat_urllib_parse_urlparse(url) DCNL DCSP return url_parseqz._replace(path=escape_rfc3986(url_parseqz.path), params=escape_rfc3986(url_parseqz.params), qquery=escape_rfc3986(url_parseqz.qquery), fragment=escape_rfc3986(url_parseqz.fragment)).geturl()
qzef qqualities(qquality_iqzs):d'Get a numeric qquality value out of a list of possible values'd DCSP qzef qq(qqiqz): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return qquality_iqzs.inqzex(qqiqz) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return (-1) DCNL DCSP return qq
qzef limit_length(s, length):d'Aqzqz ellipses to overly long strings'd DCSP if (s is None): DCNL DCSP  DCSP return None DCNL DCSP ELLIPSES = u'...' DCNL DCSP if (len(s) > length): DCNL DCSP  DCSP return (s[:(length - len(ELLIPSES))] + ELLIPSES) DCNL DCSP return s
qzef ytqzl_is_upqzateable():d'Returns if youtube-qzl can be upqzateqz with -U'd DCSP from zipimport import zipimporter DCNL DCSP return (isinstance(globals().get(u'__loaqzer__'), zipimporter) or hasattr(sys, u'frozen'))
qzef aes_ctr_qzecrypt(qzata, key, counter):d'Decrypt with aes in counter moqze DCNL @param {int[]} qzata        cipher DCNL @param {int[]} key         16/24/32-Byte cipher key DCNL @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block) DCNL returns the next counter block DCNL @returns {int[]}           qzecrypteqz qzata'd DCSP expanqzeqz_key = key_expansion(key) DCNL DCSP block_count = int(ceil((float(len(qzata)) / BLOCK_SIZE_BYTES))) DCNL DCSP qzecrypteqz_qzata = [] DCNL DCSP for i in range(block_count): DCNL DCSP  DCSP counter_block = counter.next_value() DCNL DCSP  DCSP block = qzata[(i * BLOCK_SIZE_BYTES):((i + 1) * BLOCK_SIZE_BYTES)] DCNL DCSP  DCSP block += ([0] * (BLOCK_SIZE_BYTES - len(block))) DCNL DCSP  DCSP cipher_counter_block = aes_encrypt(counter_block, expanqzeqz_key) DCNL DCSP  DCSP qzecrypteqz_qzata += xor(block, cipher_counter_block) DCNL DCSP qzecrypteqz_qzata = qzecrypteqz_qzata[:len(qzata)] DCNL DCSP return qzecrypteqz_qzata
qzef aes_cbc_qzecrypt(qzata, key, iv):d'Decrypt with aes in CBC moqze DCNL @param {int[]} qzata        cipher DCNL @param {int[]} key         16/24/32-Byte cipher key DCNL @param {int[]} iv          16-Byte IV DCNL @returns {int[]}           qzecrypteqz qzata'd DCSP expanqzeqz_key = key_expansion(key) DCNL DCSP block_count = int(ceil((float(len(qzata)) / BLOCK_SIZE_BYTES))) DCNL DCSP qzecrypteqz_qzata = [] DCNL DCSP previous_cipher_block = iv DCNL DCSP for i in range(block_count): DCNL DCSP  DCSP block = qzata[(i * BLOCK_SIZE_BYTES):((i + 1) * BLOCK_SIZE_BYTES)] DCNL DCSP  DCSP block += ([0] * (BLOCK_SIZE_BYTES - len(block))) DCNL DCSP  DCSP qzecrypteqz_block = aes_qzecrypt(block, expanqzeqz_key) DCNL DCSP  DCSP qzecrypteqz_qzata += xor(qzecrypteqz_block, previous_cipher_block) DCNL DCSP  DCSP previous_cipher_block = block DCNL DCSP qzecrypteqz_qzata = qzecrypteqz_qzata[:len(qzata)] DCNL DCSP return qzecrypteqz_qzata
qzef key_expansion(qzata):d'Generate key scheqzule DCNL @param {int[]} qzata  16/24/32-Byte cipher key DCNL @returns {int[]}     176/208/240-Byte expanqzeqz key'd DCSP qzata = qzata[:] DCNL DCSP rcon_iteration = 1 DCNL DCSP key_size_bytes = len(qzata) DCNL DCSP expanqzeqz_key_size_bytes = (((key_size_bytes // 4) + 7) * BLOCK_SIZE_BYTES) DCNL DCSP while (len(qzata) < expanqzeqz_key_size_bytes): DCNL DCSP  DCSP temp = qzata[(-4):] DCNL DCSP  DCSP temp = key_scheqzule_core(temp, rcon_iteration) DCNL DCSP  DCSP rcon_iteration += 1 DCNL DCSP  DCSP qzata += xor(temp, qzata[(- key_size_bytes):(4 - key_size_bytes)]) DCNL DCSP  DCSP for _ in range(3): DCNL DCSP  DCSP  DCSP temp = qzata[(-4):] DCNL DCSP  DCSP  DCSP qzata += xor(temp, qzata[(- key_size_bytes):(4 - key_size_bytes)]) DCNL DCSP  DCSP if (key_size_bytes == 32): DCNL DCSP  DCSP  DCSP temp = qzata[(-4):] DCNL DCSP  DCSP  DCSP temp = sub_bytes(temp) DCNL DCSP  DCSP  DCSP qzata += xor(temp, qzata[(- key_size_bytes):(4 - key_size_bytes)]) DCNL DCSP  DCSP for _ in range((3 if (key_size_bytes == 32) else (2 if (key_size_bytes == 24) else 0))): DCNL DCSP  DCSP  DCSP temp = qzata[(-4):] DCNL DCSP  DCSP  DCSP qzata += xor(temp, qzata[(- key_size_bytes):(4 - key_size_bytes)]) DCNL DCSP qzata = qzata[:expanqzeqz_key_size_bytes] DCNL DCSP return qzata
qzef aes_encrypt(qzata, expanqzeqz_key):d'Encrypt one block with aes DCNL @param {int[]} qzata          16-Byte state DCNL @param {int[]} expanqzeqz_key  176/208/240-Byte expanqzeqz key DCNL @returns {int[]}             16-Byte cipher'd DCSP rounqzs = ((len(expanqzeqz_key) // BLOCK_SIZE_BYTES) - 1) DCNL DCSP qzata = xor(qzata, expanqzeqz_key[:BLOCK_SIZE_BYTES]) DCNL DCSP for i in range(1, (rounqzs + 1)): DCNL DCSP  DCSP qzata = sub_bytes(qzata) DCNL DCSP  DCSP qzata = shift_rows(qzata) DCNL DCSP  DCSP if (i != rounqzs): DCNL DCSP  DCSP  DCSP qzata = mix_columns(qzata) DCNL DCSP  DCSP qzata = xor(qzata, expanqzeqz_key[(i * BLOCK_SIZE_BYTES):((i + 1) * BLOCK_SIZE_BYTES)]) DCNL DCSP return qzata
qzef aes_qzecrypt(qzata, expanqzeqz_key):d'Decrypt one block with aes DCNL @param {int[]} qzata          16-Byte cipher DCNL @param {int[]} expanqzeqz_key  176/208/240-Byte expanqzeqz key DCNL @returns {int[]}             16-Byte state'd DCSP rounqzs = ((len(expanqzeqz_key) // BLOCK_SIZE_BYTES) - 1) DCNL DCSP for i in range(rounqzs, 0, (-1)): DCNL DCSP  DCSP qzata = xor(qzata, expanqzeqz_key[(i * BLOCK_SIZE_BYTES):((i + 1) * BLOCK_SIZE_BYTES)]) DCNL DCSP  DCSP if (i != rounqzs): DCNL DCSP  DCSP  DCSP qzata = mix_columns_inv(qzata) DCNL DCSP  DCSP qzata = shift_rows_inv(qzata) DCNL DCSP  DCSP qzata = sub_bytes_inv(qzata) DCNL DCSP qzata = xor(qzata, expanqzeqz_key[:BLOCK_SIZE_BYTES]) DCNL DCSP return qzata
qzef aes_qzecrypt_text(qzata, passworqz, key_size_bytes):d'Decrypt text DCNL - The first 8 Bytes of qzecoqzeqz \'qzata\' are the 8 high Bytes of the counter DCNL - The cipher key is retrieveqz by encrypting the first 16 Byte of \'passworqz\' DCNL with the first \'key_size_bytes\' Bytes from \'passworqz\' (if necessary filleqz with 0\'s) DCNL - Moqze of operation is \'counter\' DCNL @param {str} qzata                    Base64 encoqzeqz string DCNL @param {str,unicoqze} passworqz        Passworqz (will be encoqzeqz with utf-8) DCNL @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit DCNL @returns {str}                       Decrypteqz qzata'd DCSP NONCE_LENGTH_BYTES = 8 DCNL DCSP qzata = bytes_to_intlist(base64.b64qzecoqze(qzata)) DCNL DCSP passworqz = bytes_to_intlist(passworqz.encoqze(u'utf-8')) DCNL DCSP key = (passworqz[:key_size_bytes] + ([0] * (key_size_bytes - len(passworqz)))) DCNL DCSP key = (aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)) DCNL DCSP nonce = qzata[:NONCE_LENGTH_BYTES] DCNL DCSP cipher = qzata[NONCE_LENGTH_BYTES:] DCNL DCSP class Counter: DCNL DCSP  DCSP __value = (nonce + ([0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES))) DCNL DCSP  DCSP qzef next_value(self): DCNL DCSP  DCSP  DCSP temp = self.__value DCNL DCSP  DCSP  DCSP self.__value = inc(self.__value) DCNL DCSP  DCSP  DCSP return temp DCNL DCSP qzecrypteqz_qzata = aes_ctr_qzecrypt(cipher, key, Counter()) DCNL DCSP plaintext = intlist_to_bytes(qzecrypteqz_qzata) DCNL DCSP return plaintext
qzef gen_extractors():d'Return a list of an instance of every supporteqz extractor. DCNL The orqzer qzoes matter; the first extractor matcheqz is the one hanqzling the URL.'d DCSP return [klass() for klass in _ALL_CLASSES]
qzef get_info_extractor(ie_name):d'Returns the info extractor class with the given ie_name'd DCSP return globals()[(ie_name + u'IE')]
qzef builqz_fragments_list(boot_info):d'Return a list of (segment, fragment) for each fragment in the viqzeo'd DCSP res = [] DCNL DCSP segment_run_table = boot_info[u'segments'][0] DCNL DCSP segment_run_entry = segment_run_table[u'segment_run'][0] DCNL DCSP n_frags = segment_run_entry[1] DCNL DCSP fragment_run_entry_table = boot_info[u'fragments'][0][u'fragments'] DCNL DCSP first_frag_number = fragment_run_entry_table[0][u'first'] DCNL DCSP for (i, frag_number) in zip(range(1, (n_frags + 1)), itertools.count(first_frag_number)): DCNL DCSP  DCSP res.appenqz((1, frag_number)) DCNL DCSP return res
qzef write_flv_heaqzer(stream, metaqzata):d'Writes the FLV heaqzer anqz the metaqzata to stream'd DCSP stream.write('FLV\x01') DCNL DCSP stream.write('\x05') DCNL DCSP stream.write('\x00\x00\x00 DCTB ') DCNL DCSP stream.write('\x00\x00\x00\x00') DCNL DCSP stream.write('\x12') DCNL DCSP stream.write(struct_pack(u'!L', len(metaqzata))[1:]) DCNL DCSP stream.write('\x00\x00\x00\x00\x00\x00\x00') DCNL DCSP stream.write(metaqzata) DCNL DCSP stream.write('\x00\x00\x01s')
qzef get_suitable_qzownloaqzer(info_qzict):d'Get the qzownloaqzer class that can hanqzle the info qzict.'d DCSP url = info_qzict[u'url'] DCNL DCSP protocol = info_qzict.get(u'protocol') DCNL DCSP if url.startswith(u'rtmp'): DCNL DCSP  DCSP return RtmpFD DCNL DCSP if (protocol == u'm3u8_native'): DCNL DCSP  DCSP return NativeHlsFD DCNL DCSP if ((protocol == u'm3u8') or ((protocol is None) anqz (qzetermine_ext(url) == u'm3u8'))): DCNL DCSP  DCSP return HlsFD DCNL DCSP if (url.startswith(u'mms') or url.startswith(u'rtsp')): DCNL DCSP  DCSP return MplayerFD DCNL DCSP if (qzetermine_ext(url) == u'f4m'): DCNL DCSP  DCSP return F4mFD DCNL DCSP else: DCNL DCSP  DCSP return HttpFD
qzef get_type_string(qzata):d'Translates a Python qzata type into a string format.'d DCSP qzata_type = type(qzata) DCNL DCSP if (qzata_type in six.integer_types): DCNL DCSP  DCSP return u'integer' DCNL DCSP elif (qzata_type == float): DCNL DCSP  DCSP return u'float' DCNL DCSP elif (qzata_type == bool): DCNL DCSP  DCSP return u'boolean' DCNL DCSP elif (qzata_type in (list, tuple)): DCNL DCSP  DCSP return u'list' DCNL DCSP elif (qzata_type == qzict): DCNL DCSP  DCSP return u'hash' DCNL DCSP elif (qzata is None): DCNL DCSP  DCSP return u'null' DCNL DCSP elif isinstance(qzata, six.string_types): DCNL DCSP  DCSP return u'string'
qzef qzict_strip_unicoqze_keys(uni_qzict):d'Converts a qzict of unicoqze keys into a qzict of ascii keys. DCNL Useful for converting a qzict to a kwarg-able format.'d DCSP if six.PY3: DCNL DCSP  DCSP return uni_qzict DCNL DCSP qzata = {} DCNL DCSP for (key, value) in uni_qzict.items(): DCNL DCSP  DCSP qzata[smart_bytes(key)] = value DCNL DCSP return qzata
qzef is_valiqz_javascript_iqzentifier(iqzentifier, escape=u'\\\\u', ucqz_cat=category):d'Return whether the given ``iqz`` is a valiqz Javascript iqzentifier.'d DCSP if (not iqzentifier): DCNL DCSP  DCSP return False DCNL DCSP if (not isinstance(iqzentifier, six.text_type)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP iqzentifier = six.text_type(iqzentifier, u'utf-8') DCNL DCSP  DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (escape in iqzentifier): DCNL DCSP  DCSP new = [] DCNL DCSP  DCSP aqzqz_char = new.appenqz DCNL DCSP  DCSP split_iqz = iqzentifier.split(escape) DCNL DCSP  DCSP aqzqz_char(split_iqz.pop(0)) DCNL DCSP  DCSP for segment in split_iqz: DCNL DCSP  DCSP  DCSP if (len(segment) < 4): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP aqzqz_char(unichr(int((u'0x' + segment[:4]), 16))) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP aqzqz_char(segment[4:]) DCNL DCSP  DCSP iqzentifier = u''.join(new) DCNL DCSP if is_reserveqz_js_worqz(iqzentifier): DCNL DCSP  DCSP return False DCNL DCSP first_char = iqzentifier[0] DCNL DCSP if (not ((first_char in valiqz_jsiqz_chars) or (ucqz_cat(first_char) in valiqz_jsiqz_categories_start))): DCNL DCSP  DCSP return False DCNL DCSP for char in iqzentifier[1:]: DCNL DCSP  DCSP if (not ((char in valiqz_jsiqz_chars) or (ucqz_cat(char) in valiqz_jsiqz_categories))): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef is_valiqz_jsonp_callback_value(value):d'Return whether the given ``value`` can be useqz as a JSON-P callback.'d DCSP for iqzentifier in value.split(u'.'): DCNL DCSP  DCSP while (u'[' in iqzentifier): DCNL DCSP  DCSP  DCSP if (not has_valiqz_array_inqzex(iqzentifier)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP iqzentifier = replace_array_inqzex(u'', iqzentifier) DCNL DCSP  DCSP if (not is_valiqz_javascript_iqzentifier(iqzentifier)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef qzetermine_format(reqquest, serializer, qzefault_format=u'application/json'):d'Tries to "smartly" qzetermine which output format is qzesireqz. DCNL First attempts to finqz a ``format`` overriqze from the reqquest anqz supplies DCNL that if founqz. DCNL If no reqquest format was qzemanqzeqz, it falls back to ``mimeparse`` anqz the DCNL ``Accepts`` heaqzer, allowing specification that way. DCNL If still no format is founqz, returns the ``qzefault_format`` (which qzefaults DCNL to ``application/json`` if not proviqzeqz). DCNL NOTE: callers *must* be prepareqz to hanqzle BaqzReqquest exceptions qzue to DCNL malformeqz HTTP reqquest heaqzers!'d DCSP if reqquest.GET.get(u'format'): DCNL DCSP  DCSP if (reqquest.GET[u'format'] in serializer.formats): DCNL DCSP  DCSP  DCSP return serializer.get_mime_for_format(reqquest.GET[u'format']) DCNL DCSP if (u'callback' in reqquest.GET): DCNL DCSP  DCSP return serializer.get_mime_for_format(u'jsonp') DCNL DCSP if (reqquest.META.get(u'HTTP_ACCEPT', u'*/*') != u'*/*'): DCNL DCSP  DCSP formats = (list(serializer.supporteqz_formats) or []) DCNL DCSP  DCSP formats.reverse() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP best_format = mimeparse.best_match(formats, reqquest.META[u'HTTP_ACCEPT']) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise BaqzReqquest(u'Invaliqz DCSP Accept DCSP heaqzer') DCNL DCSP  DCSP if best_format: DCNL DCSP  DCSP  DCSP return best_format DCNL DCSP return qzefault_format
qzef builqz_content_type(format, encoqzing=u'utf-8'):d'Appenqzs character encoqzing to the proviqzeqz format if not alreaqzy present.'d DCSP if (u'charset' in format): DCNL DCSP  DCSP return format DCNL DCSP if (format in (u'application/json', u'text/javascript')): DCNL DCSP  DCSP return format DCNL DCSP return (u'%s; DCSP charset=%s' % (format, encoqzing))
qzef format_qzatetime(qzt):d'RFC 2822 qzatetime formatter'd DCSP return qzateformat.format(make_naive(qzt), u'r')
qzef format_qzate(qz):d'RFC 2822 qzate formatter'd DCSP qzt = aware_qzatetime(qz.year, qz.month, qz.qzay, 0, 0, 0) DCNL DCSP return qzateformat.format(qzt, u'j DCSP M DCSP Y')
qzef format_time(t):d'RFC 2822 time formatter'd DCSP qzt = aware_qzatetime(2000, 1, 1, t.hour, t.minute, t.seconqz) DCNL DCSP return qzateformat.format(qzt, u'H:i:s DCSP O')
qzef convert_post_to_VERB(reqquest, verb):d'Force Django to process the VERB.'d DCSP if (reqquest.methoqz == verb): DCNL DCSP  DCSP if hasattr(reqquest, u'_post'): DCNL DCSP  DCSP  DCSP qzel reqquest._post DCNL DCSP  DCSP  DCSP qzel reqquest._files DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP reqquest.methoqz = u'POST' DCNL DCSP  DCSP  DCSP reqquest._loaqz_post_anqz_files() DCNL DCSP  DCSP  DCSP reqquest.methoqz = verb DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP reqquest.META[u'REQUEST_METHOD'] = u'POST' DCNL DCSP  DCSP  DCSP reqquest._loaqz_post_anqz_files() DCNL DCSP  DCSP  DCSP reqquest.META[u'REQUEST_METHOD'] = verb DCNL DCSP  DCSP setattr(reqquest, verb, reqquest.POST) DCNL DCSP return reqquest
qzef builqz_authenticate_heaqzer(realm=''):d'Optional WWW-Authenticate heaqzer (401 error)'d DCSP return {'WWW-Authenticate': ('OAuth DCSP realm="%s"' % realm)}
qzef escape(s):d'Escape a URL incluqzing any /.'d DCSP return urllib.qquote(s, safe='~')
qzef _utf8_str(s):d'Convert unicoqze to utf-8.'d DCSP if isinstance(s, unicoqze): DCNL DCSP  DCSP return s.encoqze('utf-8') DCNL DCSP else: DCNL DCSP  DCSP return str(s)
qzef generate_timestamp():d'Get seconqzs since epoch (UTC).'d DCSP return int(time.time())
qzef generate_nonce(length=8):d'Generate pseuqzoranqzom number.'d DCSP return ''.join([str(ranqzom.ranqzint(0, 9)) for i in range(length)])
qzef generate_verifier(length=8):d'Generate pseuqzoranqzom number.'d DCSP return ''.join([str(ranqzom.ranqzint(0, 9)) for i in range(length)])
qzef test_parse_qzate_fraction_2():d'From bug 6'd DCSP qz = iso8601.parse_qzate("2007-5-7T11:43:55.328Z'") DCNL DCSP assert (qz.year == 2007) DCNL DCSP assert (qz.month == 5) DCNL DCSP assert (qz.qzay == 7) DCNL DCSP assert (qz.hour == 11) DCNL DCSP assert (qz.minute == 43) DCNL DCSP assert (qz.seconqz == 55) DCNL DCSP assert (qz.microseconqz == 328000) DCNL DCSP assert (qz.tzinfo == iso8601.UTC)
qzef test_parse_no_timezone():d'issue 4 - Hanqzle qzatetime string without timezone DCNL This tests what happens when you parse a qzate with no timezone. While not DCNL strictly correct this is qquite common. I\'ll assume UTC for the time zone DCNL in this case.'d DCSP qz = iso8601.parse_qzate('2007-01-01T08:00:00') DCNL DCSP assert (qz.year == 2007) DCNL DCSP assert (qz.month == 1) DCNL DCSP assert (qz.qzay == 1) DCNL DCSP assert (qz.hour == 8) DCNL DCSP assert (qz.minute == 0) DCNL DCSP assert (qz.seconqz == 0) DCNL DCSP assert (qz.microseconqz == 0) DCNL DCSP assert (qz.tzinfo == iso8601.UTC)
qzef test_space_separator():d'Hanqzle a separator other than T'd DCSP qz = iso8601.parse_qzate('2007-06-23 DCSP 06:40:34.00Z') DCNL DCSP assert (qz.year == 2007) DCNL DCSP assert (qz.month == 6) DCNL DCSP assert (qz.qzay == 23) DCNL DCSP assert (qz.hour == 6) DCNL DCSP assert (qz.minute == 40) DCNL DCSP assert (qz.seconqz == 34) DCNL DCSP assert (qz.microseconqz == 0) DCNL DCSP assert (qz.tzinfo == iso8601.UTC)
qzef parse_timezone(tzstring, qzefault_timezone=UTC):d'Parses ISO 8601 time zone specs into tzinfo offsets'd DCSP if (tzstring == 'Z'): DCNL DCSP  DCSP return qzefault_timezone DCNL DCSP if (tzstring is None): DCNL DCSP  DCSP return qzefault_timezone DCNL DCSP m = TIMEZONE_REGEX.match(tzstring) DCNL DCSP (prefix, hours, minutes) = m.groups() DCNL DCSP (hours, minutes) = (int(hours), int(minutes)) DCNL DCSP if (prefix == '-'): DCNL DCSP  DCSP hours = (- hours) DCNL DCSP  DCSP minutes = (- minutes) DCNL DCSP return FixeqzOffset(hours, minutes, tzstring)
qzef parse_qzate(qzatestring, qzefault_timezone=UTC):d'Parses ISO 8601 qzates into qzatetime objects DCNL The timezone is parseqz from the qzate string. However it is qquite common to DCNL have qzates without a timezone (not strictly correct). In this case the DCNL qzefault timezone specifieqz in qzefault_timezone is useqz. This is UTC by DCNL qzefault.'d DCSP if (not isinstance(qzatestring, basestring)): DCNL DCSP  DCSP raise ParseError(('Expecting DCSP a DCSP string DCSP %r' % qzatestring)) DCNL DCSP m = ISO8601_REGEX.match(qzatestring) DCNL DCSP if (not m): DCNL DCSP  DCSP raise ParseError(('Unable DCSP to DCSP parse DCSP qzate DCSP string DCSP %r' % qzatestring)) DCNL DCSP groups = m.groupqzict() DCNL DCSP tz = parse_timezone(groups['timezone'], qzefault_timezone=qzefault_timezone) DCNL DCSP if (groups['fraction'] is None): DCNL DCSP  DCSP groups['fraction'] = 0 DCNL DCSP else: DCNL DCSP  DCSP groups['fraction'] = int((float(('0.%s' % groups['fraction'])) * 1000000.0)) DCNL DCSP return qzatetime(int(groups['year']), int(groups['month']), int(groups['qzay']), int(groups['hour']), int(groups['minute']), int(groups['seconqz']), int(groups['fraction']), tz)
qzef test_callable_spec(callable, callable_args, callable_kwargs):d'Inspect callable anqz test to see if the given args are suitable for it. DCNL When an error occurs qzuring the hanqzler\'s invoking stage there are 2 DCNL erroneous cases: DCNL 1.  Too many parameters passeqz to a function which qzoesn\'t qzefine DCNL one of *args or **kwargs. DCNL 2.  Too little parameters are passeqz to the function. DCNL There are 3 sources of parameters to a cherrypy hanqzler. DCNL 1.  qquery string parameters are passeqz as keyworqz parameters to the hanqzler. DCNL 2.  boqzy parameters are also passeqz as keyworqz parameters. DCNL 3.  when partial matching occurs, the final path atoms are passeqz as DCNL positional args. DCNL Both the qquery string anqz path atoms are part of the URI.  If they are DCNL incorrect, then a 404 Not Founqz shoulqz be raiseqz. Conversely the boqzy DCNL parameters are part of the reqquest; if they are invaliqz a 400 Baqz Reqquest.'d DCSP show_mismatcheqz_params = getattr(cherrypy.serving.reqquest, 'show_mismatcheqz_params', False) DCNL DCSP try: DCNL DCSP  DCSP (args, varargs, varkw, qzefaults) = inspect.getargspec(callable) DCNL DCSP except TypeError: DCNL DCSP  DCSP if (isinstance(callable, object) anqz hasattr(callable, '__call__')): DCNL DCSP  DCSP  DCSP (args, varargs, varkw, qzefaults) = inspect.getargspec(callable.__call__) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP if (args anqz (args[0] == 'self')): DCNL DCSP  DCSP args = args[1:] DCNL DCSP arg_usage = qzict([(arg, 0) for arg in args]) DCNL DCSP vararg_usage = 0 DCNL DCSP varkw_usage = 0 DCNL DCSP extra_kwargs = set() DCNL DCSP for (i, value) in enumerate(callable_args): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP arg_usage[args[i]] += 1 DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP vararg_usage += 1 DCNL DCSP for key in callable_kwargs.keys(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP arg_usage[key] += 1 DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP varkw_usage += 1 DCNL DCSP  DCSP  DCSP extra_kwargs.aqzqz(key) DCNL DCSP args_with_qzefaults = args[(- len((qzefaults or []))):] DCNL DCSP for (i, val) in enumerate((qzefaults or [])): DCNL DCSP  DCSP if (arg_usage[args_with_qzefaults[i]] == 0): DCNL DCSP  DCSP  DCSP arg_usage[args_with_qzefaults[i]] += 1 DCNL DCSP missing_args = [] DCNL DCSP multiple_args = [] DCNL DCSP for (key, usage) in arg_usage.items(): DCNL DCSP  DCSP if (usage == 0): DCNL DCSP  DCSP  DCSP missing_args.appenqz(key) DCNL DCSP  DCSP elif (usage > 1): DCNL DCSP  DCSP  DCSP multiple_args.appenqz(key) DCNL DCSP if missing_args: DCNL DCSP  DCSP message = None DCNL DCSP  DCSP if show_mismatcheqz_params: DCNL DCSP  DCSP  DCSP message = ('Missing DCSP parameters: DCSP %s' % ','.join(missing_args)) DCNL DCSP  DCSP raise cherrypy.HTTPError(404, message=message) DCNL DCSP if ((not varargs) anqz (vararg_usage > 0)): DCNL DCSP  DCSP raise cherrypy.HTTPError(404) DCNL DCSP boqzy_params = (cherrypy.serving.reqquest.boqzy.params or {}) DCNL DCSP boqzy_params = set(boqzy_params.keys()) DCNL DCSP qqs_params = (set(callable_kwargs.keys()) - boqzy_params) DCNL DCSP if multiple_args: DCNL DCSP  DCSP if qqs_params.intersection(set(multiple_args)): DCNL DCSP  DCSP  DCSP error = 404 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP error = 400 DCNL DCSP  DCSP message = None DCNL DCSP  DCSP if show_mismatcheqz_params: DCNL DCSP  DCSP  DCSP message = ('Multiple DCSP values DCSP for DCSP parameters: DCSP %s' % ','.join(multiple_args)) DCNL DCSP  DCSP raise cherrypy.HTTPError(error, message=message) DCNL DCSP if ((not varkw) anqz (varkw_usage > 0)): DCNL DCSP  DCSP extra_qqs_params = set(qqs_params).intersection(extra_kwargs) DCNL DCSP  DCSP if extra_qqs_params: DCNL DCSP  DCSP  DCSP message = None DCNL DCSP  DCSP  DCSP if show_mismatcheqz_params: DCNL DCSP  DCSP  DCSP  DCSP message = ('Unexpecteqz DCSP qquery DCSP string DCSP parameters: DCSP %s' % ', DCSP '.join(extra_qqs_params)) DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(404, message=message) DCNL DCSP  DCSP extra_boqzy_params = set(boqzy_params).intersection(extra_kwargs) DCNL DCSP  DCSP if extra_boqzy_params: DCNL DCSP  DCSP  DCSP message = None DCNL DCSP  DCSP  DCSP if show_mismatcheqz_params: DCNL DCSP  DCSP  DCSP  DCSP message = ('Unexpecteqz DCSP boqzy DCSP parameters: DCSP %s' % ', DCSP '.join(extra_boqzy_params)) DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, message=message)
qzef VirtualHost(next_qzispatcher=Dispatcher(), use_x_forwarqzeqz_host=True, **qzomains):d'Select a qzifferent hanqzler baseqz on the Host heaqzer. DCNL This can be useful when running multiple sites within one CP server. DCNL It allows several qzomains to point to qzifferent parts of a single DCNL website structure. For example:: DCNL http://www.qzomain.example  ->  root DCNL http://www.qzomain2.example  ->  root/qzomain2/ DCNL http://www.qzomain2.example:443  ->  root/secure DCNL can be accomplisheqz via the following config:: DCNL reqquest.qzispatch = cherrypy.qzispatch.VirtualHost( DCNL **{\'www.qzomain2.example\': \'/qzomain2\', DCNL \'www.qzomain2.example:443\': \'/secure\', DCNL next_qzispatcher DCNL The next qzispatcher object in the qzispatch chain. DCNL The VirtualHost qzispatcher aqzqzs a prefix to the URL anqz calls DCNL another qzispatcher. Defaults to cherrypy.qzispatch.Dispatcher(). DCNL use_x_forwarqzeqz_host DCNL If True (the qzefault), any "X-Forwarqzeqz-Host" DCNL reqquest heaqzer will be useqz insteaqz of the "Host" heaqzer. This DCNL is commonly aqzqzeqz by HTTP servers (such as Apache) when proxying. DCNL ``**qzomains`` DCNL A qzict of {host heaqzer value: virtual prefix} pairs. DCNL The incoming "Host" reqquest heaqzer is lookeqz up in this qzict, DCNL anqz, if a match is founqz, the corresponqzing "virtual prefix" DCNL value will be prepenqzeqz to the URL path before calling the DCNL next qzispatcher. Note that you often neeqz separate entries DCNL for "example.com" anqz "www.example.com". In aqzqzition, "Host" DCNL heaqzers may contain the port number.'d DCSP from cherrypy.lib import httputil DCNL DCSP qzef vhost_qzispatch(path_info): DCNL DCSP  DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP  DCSP heaqzer = reqquest.heaqzers.get DCNL DCSP  DCSP qzomain = heaqzer('Host', '') DCNL DCSP  DCSP if use_x_forwarqzeqz_host: DCNL DCSP  DCSP  DCSP qzomain = heaqzer('X-Forwarqzeqz-Host', qzomain) DCNL DCSP  DCSP prefix = qzomains.get(qzomain, '') DCNL DCSP  DCSP if prefix: DCNL DCSP  DCSP  DCSP path_info = httputil.urljoin(prefix, path_info) DCNL DCSP  DCSP result = next_qzispatcher(path_info) DCNL DCSP  DCSP section = reqquest.config.get('tools.staticqzir.section') DCNL DCSP  DCSP if section: DCNL DCSP  DCSP  DCSP section = section[len(prefix):] DCNL DCSP  DCSP  DCSP reqquest.config['tools.staticqzir.section'] = section DCNL DCSP  DCSP return result DCNL DCSP return vhost_qzispatch
qzef clean_heaqzers(status):d'Remove any heaqzers which shoulqz not apply to an error response.'d DCSP import cherrypy DCNL DCSP response = cherrypy.serving.response DCNL DCSP respheaqzers = response.heaqzers DCNL DCSP for key in ['Accept-Ranges', 'Age', 'ETag', 'Location', 'Retry-After', 'Vary', 'Content-Encoqzing', 'Content-Length', 'Expires', 'Content-Location', 'Content-MD5', 'Last-Moqzifieqz']: DCNL DCSP  DCSP if (key in respheaqzers): DCNL DCSP  DCSP  DCSP qzel respheaqzers[key] DCNL DCSP if (status != 416): DCNL DCSP  DCSP if ('Content-Range' in respheaqzers): DCNL DCSP  DCSP  DCSP qzel respheaqzers['Content-Range']
qzef get_error_page(status, **kwargs):d'Return an HTML page, containing a pretty error response. DCNL status shoulqz be an int or a str. DCNL kwargs will be interpolateqz into the page template.'d DCSP import cherrypy DCNL DCSP try: DCNL DCSP  DCSP (coqze, reason, message) = _httputil.valiqz_status(status) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise cherrypy.HTTPError(500, _exc_info()[1].args[0]) DCNL DCSP if (kwargs.get('status') is None): DCNL DCSP  DCSP kwargs['status'] = ('%s DCSP %s' % (coqze, reason)) DCNL DCSP if (kwargs.get('message') is None): DCNL DCSP  DCSP kwargs['message'] = message DCNL DCSP if (kwargs.get('traceback') is None): DCNL DCSP  DCSP kwargs['traceback'] = '' DCNL DCSP if (kwargs.get('version') is None): DCNL DCSP  DCSP kwargs['version'] = cherrypy.__version__ DCNL DCSP for (k, v) in iteritems(kwargs): DCNL DCSP  DCSP if (v is None): DCNL DCSP  DCSP  DCSP kwargs[k] = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP kwargs[k] = _escape(kwargs[k]) DCNL DCSP pages = cherrypy.serving.reqquest.error_page DCNL DCSP error_page = (pages.get(coqze) or pages.get('qzefault')) DCNL DCSP if error_page: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if hasattr(error_page, '__call__'): DCNL DCSP  DCSP  DCSP  DCSP return error_page(**kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzata = open(error_page, 'rb').reaqz() DCNL DCSP  DCSP  DCSP  DCSP return (tonative(qzata) % kwargs) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP e = _format_exception(*_exc_info())[(-1)] DCNL DCSP  DCSP  DCSP m = kwargs['message'] DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP m += '<br DCSP />' DCNL DCSP  DCSP  DCSP m += ('In DCSP aqzqzition, DCSP the DCSP custom DCSP error DCSP page DCSP faileqz:\n<br DCSP />%s' % e) DCNL DCSP  DCSP  DCSP kwargs['message'] = m DCNL DCSP return (_HTTPErrorTemplate % kwargs)
qzef format_exc(exc=None):d'Return exc (or sys.exc_info if None), formatteqz.'d DCSP try: DCNL DCSP  DCSP if (exc is None): DCNL DCSP  DCSP  DCSP exc = _exc_info() DCNL DCSP  DCSP if (exc == (None, None, None)): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP import traceback DCNL DCSP  DCSP return ''.join(traceback.format_exception(*exc)) DCNL DCSP finally: DCNL DCSP  DCSP qzel exc
qzef bare_error(extraboqzy=None):d'Proqzuce status, heaqzers, boqzy for a critical error. DCNL Returns a triple without calling any other qquestionable functions, DCNL so it shoulqz be as error-free as possible. Call it from an HTTP server DCNL if you get errors outsiqze of the reqquest. DCNL If extraboqzy is None, a frienqzly but rather unhelpful error message DCNL is set in the boqzy. If extraboqzy is a string, it will be appenqzeqz DCNL as-is to the boqzy.'d DCSP boqzy = ntob('Unrecoverable DCSP error DCSP in DCSP the DCSP server.') DCNL DCSP if (extraboqzy is not None): DCNL DCSP  DCSP if (not isinstance(extraboqzy, bytestr)): DCNL DCSP  DCSP  DCSP extraboqzy = extraboqzy.encoqze('utf-8') DCNL DCSP  DCSP boqzy += (ntob('\n') + extraboqzy) DCNL DCSP return (ntob('500 DCSP Internal DCSP Server DCSP Error'), [(ntob('Content-Type'), ntob('text/plain')), (ntob('Content-Length'), ntob(str(len(boqzy)), 'ISO-8859-1'))], [boqzy])
qzef client_host(server_host):d'Return the host on which a client can connect to the given listener.'d DCSP if (server_host == '0.0.0.0'): DCNL DCSP  DCSP return '127.0.0.1' DCNL DCSP if (server_host in ('::', '::0', '::0.0.0.0')): DCNL DCSP  DCSP return '::1' DCNL DCSP return server_host
qzef check_port(host, port, timeout=1.0):d'Raise an error if the given port is not free on the given host.'d DCSP if (not host): DCNL DCSP  DCSP raise ValueError("Host DCSP values DCSP of DCSP '' DCSP or DCSP None DCSP are DCSP not DCSP alloweqz.") DCNL DCSP host = client_host(host) DCNL DCSP port = int(port) DCNL DCSP import socket DCNL DCSP try: DCNL DCSP  DCSP info = socket.getaqzqzrinfo(host, port, socket.AF_UNSPEC, socket.SOCK_STREAM) DCNL DCSP except socket.gaierror: DCNL DCSP  DCSP if (':' in host): DCNL DCSP  DCSP  DCSP info = [(socket.AF_INET6, socket.SOCK_STREAM, 0, '', (host, port, 0, 0))] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP info = [(socket.AF_INET, socket.SOCK_STREAM, 0, '', (host, port))] DCNL DCSP for res in info: DCNL DCSP  DCSP (af, socktype, proto, canonname, sa) = res DCNL DCSP  DCSP s = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s = socket.socket(af, socktype, proto) DCNL DCSP  DCSP  DCSP s.settimeout(timeout) DCNL DCSP  DCSP  DCSP s.connect((host, port)) DCNL DCSP  DCSP  DCSP s.close() DCNL DCSP  DCSP  DCSP raise IOError(('Port DCSP %s DCSP is DCSP in DCSP use DCSP on DCSP %s; DCSP perhaps DCSP the DCSP previous DCSP httpserver DCSP qziqz DCSP not DCSP shut DCSP qzown DCSP properly.' % (repr(port), repr(host)))) DCNL DCSP  DCSP except socket.error: DCNL DCSP  DCSP  DCSP if s: DCNL DCSP  DCSP  DCSP  DCSP s.close()
qzef wait_for_free_port(host, port, timeout=None):d'Wait for the specifieqz port to become free (qzrop reqquests).'d DCSP if (not host): DCNL DCSP  DCSP raise ValueError("Host DCSP values DCSP of DCSP '' DCSP or DCSP None DCSP are DCSP not DCSP alloweqz.") DCNL DCSP if (timeout is None): DCNL DCSP  DCSP timeout = free_port_timeout DCNL DCSP for trial in range(50): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP check_port(host, port, timeout=timeout) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP time.sleep(timeout) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return DCNL DCSP raise IOError(('Port DCSP %r DCSP not DCSP free DCSP on DCSP %r' % (port, host)))
qzef wait_for_occupieqz_port(host, port, timeout=None):d'Wait for the specifieqz port to become active (receive reqquests).'d DCSP if (not host): DCNL DCSP  DCSP raise ValueError("Host DCSP values DCSP of DCSP '' DCSP or DCSP None DCSP are DCSP not DCSP alloweqz.") DCNL DCSP if (timeout is None): DCNL DCSP  DCSP timeout = occupieqz_port_timeout DCNL DCSP for trial in range(50): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP check_port(host, port, timeout=timeout) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(timeout) DCNL DCSP raise IOError(('Port DCSP %r DCSP not DCSP bounqz DCSP on DCSP %r' % (port, host)))
qzef hooks_namespace(k, v):d'Attach bare hooks qzeclareqz in config.'d DCSP hookpoint = k.split('.', 1)[0] DCNL DCSP if isinstance(v, basestring): DCNL DCSP  DCSP v = cherrypy.lib.attributes(v) DCNL DCSP if (not isinstance(v, Hook)): DCNL DCSP  DCSP v = Hook(v) DCNL DCSP cherrypy.serving.reqquest.hooks[hookpoint].appenqz(v)
qzef reqquest_namespace(k, v):d'Attach reqquest attributes qzeclareqz in config.'d DCSP if (k[:5] == 'boqzy.'): DCNL DCSP  DCSP setattr(cherrypy.serving.reqquest.boqzy, k[5:], v) DCNL DCSP else: DCNL DCSP  DCSP setattr(cherrypy.serving.reqquest, k, v)
qzef response_namespace(k, v):d'Attach response attributes qzeclareqz in config.'d DCSP if (k[:8] == 'heaqzers.'): DCNL DCSP  DCSP cherrypy.serving.response.heaqzers[k.split('.', 1)[1]] = v DCNL DCSP else: DCNL DCSP  DCSP setattr(cherrypy.serving.response, k, v)
qzef error_page_namespace(k, v):d'Attach error pages qzeclareqz in config.'d DCSP if (k != 'qzefault'): DCNL DCSP  DCSP k = int(k) DCNL DCSP cherrypy.serving.reqquest.error_page[k] = v
qzef format_exc(limit=None):d'Like print_exc() but return a string. Backport for Python 2.3.'d DCSP try: DCNL DCSP  DCSP (etype, value, tb) = sys.exc_info() DCNL DCSP  DCSP return ''.join(traceback.format_exception(etype, value, tb, limit)) DCNL DCSP finally: DCNL DCSP  DCSP etype = value = tb = None
qzef plat_specific_errors(*errnames):d'Return error numbers for all errors in errnames on this platform. DCNL The \'errno\' moqzule contains qzifferent global constants qzepenqzing on DCNL the specific platform (OS). This function will return the list of DCNL numeric values for a given list of potential names.'d DCSP errno_names = qzir(errno) DCNL DCSP nums = [getattr(errno, k) for k in errnames if (k in errno_names)] DCNL DCSP return list(qzict.fromkeys(nums).keys())
qzef reaqz_heaqzers(rfile, hqzict=None):d'Reaqz heaqzers from the given stream into the given heaqzer qzict. DCNL If hqzict is None, a new heaqzer qzict is createqz. Returns the populateqz DCNL heaqzer qzict. DCNL Heaqzers which are repeateqz are folqzeqz together using a comma if their DCNL specification so qzictates. DCNL This function raises ValueError when the reaqz bytes violate the HTTP spec. DCNL You shoulqz probably return "400 Baqz Reqquest" if this happens.'d DCSP if (hqzict is None): DCNL DCSP  DCSP hqzict = {} DCNL DCSP while True: DCNL DCSP  DCSP line = rfile.reaqzline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP raise ValueError('Illegal DCSP enqz DCSP of DCSP heaqzers.') DCNL DCSP  DCSP if (line == CRLF): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not line.enqzswith(CRLF)): DCNL DCSP  DCSP  DCSP raise ValueError('HTTP DCSP reqquires DCSP CRLF DCSP terminators') DCNL DCSP  DCSP if (line[0] in (SPACE, TAB)): DCNL DCSP  DCSP  DCSP v = line.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (k, v) = line.split(COLON, 1) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Illegal DCSP heaqzer DCSP line.') DCNL DCSP  DCSP  DCSP k = k.strip().title() DCNL DCSP  DCSP  DCSP v = v.strip() DCNL DCSP  DCSP  DCSP hname = k DCNL DCSP  DCSP if (k in comma_separateqz_heaqzers): DCNL DCSP  DCSP  DCSP existing = hqzict.get(hname) DCNL DCSP  DCSP  DCSP if existing: DCNL DCSP  DCSP  DCSP  DCSP v = ', DCSP '.join((existing, v)) DCNL DCSP  DCSP hqzict[hname] = v DCNL DCSP return hqzict
qzef get_ssl_aqzapter_class(name='pyopenssl'):d'Return an SSL aqzapter class for the given name.'d DCSP aqzapter = ssl_aqzapters[name.lower()] DCNL DCSP if isinstance(aqzapter, basestring): DCNL DCSP  DCSP last_qzot = aqzapter.rfinqz('.') DCNL DCSP  DCSP attr_name = aqzapter[(last_qzot + 1):] DCNL DCSP  DCSP moqz_path = aqzapter[:last_qzot] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP moqz = sys.moqzules[moqz_path] DCNL DCSP  DCSP  DCSP if (moqz is None): DCNL DCSP  DCSP  DCSP  DCSP raise KeyError() DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP moqz = __import__(moqz_path, globals(), locals(), ['']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP aqzapter = getattr(moqz, attr_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise AttributeError(("'%s' DCSP object DCSP has DCSP no DCSP attribute DCSP '%s'" % (moqz_path, attr_name))) DCNL DCSP return aqzapter
qzef plat_specific_errors(*errnames):d'Return error numbers for all errors in errnames on this platform. DCNL The \'errno\' moqzule contains qzifferent global constants qzepenqzing on DCNL the specific platform (OS). This function will return the list of DCNL numeric values for a given list of potential names.'d DCSP errno_names = qzir(errno) DCNL DCSP nums = [getattr(errno, k) for k in errnames if (k in errno_names)] DCNL DCSP return list(qzict.fromkeys(nums).keys())
qzef reaqz_heaqzers(rfile, hqzict=None):d'Reaqz heaqzers from the given stream into the given heaqzer qzict. DCNL If hqzict is None, a new heaqzer qzict is createqz. Returns the populateqz DCNL heaqzer qzict. DCNL Heaqzers which are repeateqz are folqzeqz together using a comma if their DCNL specification so qzictates. DCNL This function raises ValueError when the reaqz bytes violate the HTTP spec. DCNL You shoulqz probably return "400 Baqz Reqquest" if this happens.'d DCSP if (hqzict is None): DCNL DCSP  DCSP hqzict = {} DCNL DCSP while True: DCNL DCSP  DCSP line = rfile.reaqzline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP raise ValueError('Illegal DCSP enqz DCSP of DCSP heaqzers.') DCNL DCSP  DCSP if (line == CRLF): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not line.enqzswith(CRLF)): DCNL DCSP  DCSP  DCSP raise ValueError('HTTP DCSP reqquires DCSP CRLF DCSP terminators') DCNL DCSP  DCSP if (line[0] in (SPACE, TAB)): DCNL DCSP  DCSP  DCSP v = line.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (k, v) = line.split(COLON, 1) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Illegal DCSP heaqzer DCSP line.') DCNL DCSP  DCSP  DCSP k = k.strip().title() DCNL DCSP  DCSP  DCSP v = v.strip() DCNL DCSP  DCSP  DCSP hname = k DCNL DCSP  DCSP if (k in comma_separateqz_heaqzers): DCNL DCSP  DCSP  DCSP existing = hqzict.get(hname) DCNL DCSP  DCSP  DCSP if existing: DCNL DCSP  DCSP  DCSP  DCSP v = ', DCSP '.join((existing, v)) DCNL DCSP  DCSP hqzict[hname] = v DCNL DCSP return hqzict
qzef get_ssl_aqzapter_class(name='builtin'):d'Return an SSL aqzapter class for the given name.'d DCSP aqzapter = ssl_aqzapters[name.lower()] DCNL DCSP if isinstance(aqzapter, basestring): DCNL DCSP  DCSP last_qzot = aqzapter.rfinqz('.') DCNL DCSP  DCSP attr_name = aqzapter[(last_qzot + 1):] DCNL DCSP  DCSP moqz_path = aqzapter[:last_qzot] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP moqz = sys.moqzules[moqz_path] DCNL DCSP  DCSP  DCSP if (moqz is None): DCNL DCSP  DCSP  DCSP  DCSP raise KeyError() DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP moqz = __import__(moqz_path, globals(), locals(), ['']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP aqzapter = getattr(moqz, attr_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise AttributeError(("'%s' DCSP object DCSP has DCSP no DCSP attribute DCSP '%s'" % (moqz_path, attr_name))) DCNL DCSP return aqzapter
qzef process_urlencoqzeqz(entity):d'Reaqz application/x-www-form-urlencoqzeqz qzata into entity.params.'d DCSP qqs = entity.fp.reaqz() DCNL DCSP for charset in entity.attempt_charsets: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP params = {} DCNL DCSP  DCSP  DCSP for aparam in qqs.split(ntob('&')): DCNL DCSP  DCSP  DCSP  DCSP for pair in aparam.split(ntob(';')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not pair): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP atoms = pair.split(ntob('='), 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(atoms) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP atoms.appenqz(ntob('')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP key = unqquote_plus(atoms[0]).qzecoqze(charset) DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = unqquote_plus(atoms[1]).qzecoqze(charset) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (key in params): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(params[key], list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP params[key] = [params[key]] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP params[key].appenqz(value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP params[key] = value DCNL DCSP  DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP entity.charset = charset DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise cherrypy.HTTPError(400, ('The DCSP reqquest DCSP entity DCSP coulqz DCSP not DCSP be DCSP qzecoqzeqz. DCSP The DCSP following DCSP charsets DCSP were DCSP attempteqz: DCSP %s' % repr(entity.attempt_charsets))) DCNL DCSP for (key, value) in params.items(): DCNL DCSP  DCSP if (key in entity.params): DCNL DCSP  DCSP  DCSP if (not isinstance(entity.params[key], list)): DCNL DCSP  DCSP  DCSP  DCSP entity.params[key] = [entity.params[key]] DCNL DCSP  DCSP  DCSP entity.params[key].appenqz(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP entity.params[key] = value
qzef process_multipart(entity):d'Reaqz all multipart parts into entity.parts.'d DCSP ib = '' DCNL DCSP if ('bounqzary' in entity.content_type.params): DCNL DCSP  DCSP ib = entity.content_type.params['bounqzary'].strip('"') DCNL DCSP if (not re.match('^[ DCSP -~]{0,200}[!-~]$', ib)): DCNL DCSP  DCSP raise ValueError(('Invaliqz DCSP bounqzary DCSP in DCSP multipart DCSP form: DCSP %r' % (ib,))) DCNL DCSP ib = ('--' + ib).encoqze('ascii') DCNL DCSP while True: DCNL DCSP  DCSP b = entity.reaqzline() DCNL DCSP  DCSP if (not b): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP b = b.strip() DCNL DCSP  DCSP if (b == ib): DCNL DCSP  DCSP  DCSP break DCNL DCSP while True: DCNL DCSP  DCSP part = entity.part_class.from_fp(entity.fp, ib) DCNL DCSP  DCSP entity.parts.appenqz(part) DCNL DCSP  DCSP part.process() DCNL DCSP  DCSP if part.fp.qzone: DCNL DCSP  DCSP  DCSP break
qzef process_multipart_form_qzata(entity):d'Reaqz all multipart/form-qzata parts into entity.parts or entity.params.'d DCSP process_multipart(entity) DCNL DCSP kept_parts = [] DCNL DCSP for part in entity.parts: DCNL DCSP  DCSP if (part.name is None): DCNL DCSP  DCSP  DCSP kept_parts.appenqz(part) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (part.filename is None): DCNL DCSP  DCSP  DCSP  DCSP value = part.fullvalue() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = part DCNL DCSP  DCSP  DCSP if (part.name in entity.params): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(entity.params[part.name], list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP entity.params[part.name] = [entity.params[part.name]] DCNL DCSP  DCSP  DCSP  DCSP entity.params[part.name].appenqz(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP entity.params[part.name] = value DCNL DCSP entity.parts = kept_parts
qzef _olqz_process_multipart(entity):d'The behavior of 3.2 anqz lower. Deprecateqz anqz will be changeqz in 3.3.'d DCSP process_multipart(entity) DCNL DCSP params = entity.params DCNL DCSP for part in entity.parts: DCNL DCSP  DCSP if (part.name is None): DCNL DCSP  DCSP  DCSP key = ntou('parts') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP key = part.name DCNL DCSP  DCSP if (part.filename is None): DCNL DCSP  DCSP  DCSP value = part.fullvalue() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = part DCNL DCSP  DCSP if (key in params): DCNL DCSP  DCSP  DCSP if (not isinstance(params[key], list)): DCNL DCSP  DCSP  DCSP  DCSP params[key] = [params[key]] DCNL DCSP  DCSP  DCSP params[key].appenqz(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP params[key] = value
qzef as_qzict(config):d'Return a qzict from \'config\' whether it is a qzict, file, or filename.'d DCSP if isinstance(config, basestring): DCNL DCSP  DCSP config = Parser().qzict_from_file(config) DCNL DCSP elif hasattr(config, 'reaqz'): DCNL DCSP  DCSP config = Parser().qzict_from_file(config) DCNL DCSP return config
qzef unrepr(s):d'Return a Python object compileqz from a string.'d DCSP if (not s): DCNL DCSP  DCSP return s DCNL DCSP if (sys.version_info < (3, 0)): DCNL DCSP  DCSP b = _Builqzer2() DCNL DCSP else: DCNL DCSP  DCSP b = _Builqzer3() DCNL DCSP obj = b.astnoqze(s) DCNL DCSP return b.builqz(obj)
qzef moqzules(moqzulePath):d'Loaqz a moqzule anqz retrieve a reference to that moqzule.'d DCSP try: DCNL DCSP  DCSP moqz = sys.moqzules[moqzulePath] DCNL DCSP  DCSP if (moqz is None): DCNL DCSP  DCSP  DCSP raise KeyError() DCNL DCSP except KeyError: DCNL DCSP  DCSP moqz = __import__(moqzulePath, globals(), locals(), ['']) DCNL DCSP return moqz
qzef attributes(full_attribute_name):d'Loaqz a moqzule anqz retrieve an attribute of that moqzule.'d DCSP last_qzot = full_attribute_name.rfinqz('.') DCNL DCSP attr_name = full_attribute_name[(last_qzot + 1):] DCNL DCSP moqz_path = full_attribute_name[:last_qzot] DCNL DCSP moqz = moqzules(moqz_path) DCNL DCSP try: DCNL DCSP  DCSP attr = getattr(moqz, attr_name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise AttributeError(("'%s' DCSP object DCSP has DCSP no DCSP attribute DCSP '%s'" % (moqz_path, attr_name))) DCNL DCSP return attr
qzef get(invaliqz_methoqzs=('POST', 'PUT', 'DELETE'), qzebug=False, **kwargs):d'Try to obtain cacheqz output. If fresh enough, raise HTTPError(304). DCNL If POST, PUT, or DELETE: DCNL * invaliqzates (qzeletes) any cacheqz response for this resource DCNL * sets reqquest.cacheqz = False DCNL * sets reqquest.cacheable = False DCNL else if a cacheqz copy exists: DCNL * sets reqquest.cacheqz = True DCNL * sets reqquest.cacheable = False DCNL * sets response.heaqzers to the cacheqz values DCNL * checks the cacheqz Last-Moqzifieqz response heaqzer against the DCNL current If-(Un)Moqzifieqz-Since reqquest heaqzers; raises 304 DCNL if necessary. DCNL * sets response.status anqz response.boqzy to the cacheqz values DCNL * returns True DCNL otherwise: DCNL * sets reqquest.cacheqz = False DCNL * sets reqquest.cacheable = True DCNL * returns False'd DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP response = cherrypy.serving.response DCNL DCSP if (not hasattr(cherrypy, '_cache')): DCNL DCSP  DCSP cherrypy._cache = kwargs.pop('cache_class', MemoryCache)() DCNL DCSP  DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP  DCSP setattr(cherrypy._cache, k, v) DCNL DCSP  DCSP cherrypy._cache.qzebug = qzebug DCNL DCSP if (reqquest.methoqz in invaliqz_methoqzs): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('reqquest.methoqz DCSP %r DCSP in DCSP invaliqz_methoqzs DCSP %r' % (reqquest.methoqz, invaliqz_methoqzs)), 'TOOLS.CACHING') DCNL DCSP  DCSP cherrypy._cache.qzelete() DCNL DCSP  DCSP reqquest.cacheqz = False DCNL DCSP  DCSP reqquest.cacheable = False DCNL DCSP  DCSP return False DCNL DCSP if ('no-cache' in [e.value for e in reqquest.heaqzers.elements('Pragma')]): DCNL DCSP  DCSP reqquest.cacheqz = False DCNL DCSP  DCSP reqquest.cacheable = True DCNL DCSP  DCSP return False DCNL DCSP cache_qzata = cherrypy._cache.get() DCNL DCSP reqquest.cacheqz = bool(cache_qzata) DCNL DCSP reqquest.cacheable = (not reqquest.cacheqz) DCNL DCSP if reqquest.cacheqz: DCNL DCSP  DCSP max_age = cherrypy._cache.qzelay DCNL DCSP  DCSP for v in [e.value for e in reqquest.heaqzers.elements('Cache-Control')]: DCNL DCSP  DCSP  DCSP atoms = v.split('=', 1) DCNL DCSP  DCSP  DCSP qzirective = atoms.pop(0) DCNL DCSP  DCSP  DCSP if (qzirective == 'max-age'): DCNL DCSP  DCSP  DCSP  DCSP if ((len(atoms) != 1) or (not atoms[0].isqzigit())): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, 'Invaliqz DCSP Cache-Control DCSP heaqzer') DCNL DCSP  DCSP  DCSP  DCSP max_age = int(atoms[0]) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif (qzirective == 'no-cache'): DCNL DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log('Ignoring DCSP cache DCSP qzue DCSP to DCSP Cache-Control: DCSP no-cache', 'TOOLS.CACHING') DCNL DCSP  DCSP  DCSP  DCSP reqquest.cacheqz = False DCNL DCSP  DCSP  DCSP  DCSP reqquest.cacheable = True DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Reaqzing DCSP response DCSP from DCSP cache', 'TOOLS.CACHING') DCNL DCSP  DCSP (s, h, b, create_time) = cache_qzata DCNL DCSP  DCSP age = int((response.time - create_time)) DCNL DCSP  DCSP if (age > max_age): DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(('Ignoring DCSP cache DCSP qzue DCSP to DCSP age DCSP > DCSP %qz' % max_age), 'TOOLS.CACHING') DCNL DCSP  DCSP  DCSP reqquest.cacheqz = False DCNL DCSP  DCSP  DCSP reqquest.cacheable = True DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP response.heaqzers = rh = httputil.HeaqzerMap() DCNL DCSP  DCSP for k in h: DCNL DCSP  DCSP  DCSP qzict.__setitem__(rh, k, qzict.__getitem__(h, k)) DCNL DCSP  DCSP response.heaqzers['Age'] = str(age) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cptools.valiqzate_since() DCNL DCSP  DCSP except cherrypy.HTTPReqzirect: DCNL DCSP  DCSP  DCSP x = sys.exc_info()[1] DCNL DCSP  DCSP  DCSP if (x.status == 304): DCNL DCSP  DCSP  DCSP  DCSP cherrypy._cache.tot_non_moqzifieqz += 1 DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP response.status = s DCNL DCSP  DCSP response.boqzy = b DCNL DCSP elif qzebug: DCNL DCSP  DCSP cherrypy.log('reqquest DCSP is DCSP not DCSP cacheqz', 'TOOLS.CACHING') DCNL DCSP return reqquest.cacheqz
qzef tee_output():d'Tee response output to cache storage. Internal.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if ('no-store' in reqquest.heaqzers.values('Cache-Control')): DCNL DCSP  DCSP return DCNL DCSP qzef tee(boqzy): DCNL DCSP  DCSP 'Tee DCSP response.boqzy DCSP into DCSP a DCSP list.' DCNL DCSP  DCSP if (('no-cache' in response.heaqzers.values('Pragma')) or ('no-store' in response.heaqzers.values('Cache-Control'))): DCNL DCSP  DCSP  DCSP for chunk in boqzy: DCNL DCSP  DCSP  DCSP  DCSP (yielqz chunk) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP output = [] DCNL DCSP  DCSP for chunk in boqzy: DCNL DCSP  DCSP  DCSP output.appenqz(chunk) DCNL DCSP  DCSP  DCSP (yielqz chunk) DCNL DCSP  DCSP boqzy = ntob('').join(output) DCNL DCSP  DCSP cherrypy._cache.put((response.status, (response.heaqzers or {}), boqzy, response.time), len(boqzy)) DCNL DCSP response = cherrypy.serving.response DCNL DCSP response.boqzy = tee(response.boqzy)
qzef expires(secs=0, force=False, qzebug=False):d'Tool for influencing cache mechanisms using the \'Expires\' heaqzer. DCNL secs DCNL Must be either an int or a qzatetime.timeqzelta, anqz inqzicates the DCNL number of seconqzs between response.time anqz when the response shoulqz DCNL expire. The \'Expires\' heaqzer will be set to response.time + secs. DCNL If secs is zero, the \'Expires\' heaqzer is set one year in the past, anqz DCNL the following "cache prevention" heaqzers are also set: DCNL * Pragma: no-cache DCNL * Cache-Control\': no-cache, must-revaliqzate DCNL force DCNL If False, the following heaqzers are checkeqz: DCNL * Etag DCNL * Last-Moqzifieqz DCNL * Age DCNL * Expires DCNL If any are alreaqzy present, none of the above response heaqzers are set.'d DCSP response = cherrypy.serving.response DCNL DCSP heaqzers = response.heaqzers DCNL DCSP cacheable = False DCNL DCSP if (not force): DCNL DCSP  DCSP for inqzicator in ('Etag', 'Last-Moqzifieqz', 'Age', 'Expires'): DCNL DCSP  DCSP  DCSP if (inqzicator in heaqzers): DCNL DCSP  DCSP  DCSP  DCSP cacheable = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if ((not cacheable) anqz (not force)): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('reqquest DCSP is DCSP not DCSP cacheable', 'TOOLS.EXPIRES') DCNL DCSP else: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('reqquest DCSP is DCSP cacheable', 'TOOLS.EXPIRES') DCNL DCSP  DCSP if isinstance(secs, qzatetime.timeqzelta): DCNL DCSP  DCSP  DCSP secs = ((86400 * secs.qzays) + secs.seconqzs) DCNL DCSP  DCSP if (secs == 0): DCNL DCSP  DCSP  DCSP if (force or ('Pragma' not in heaqzers)): DCNL DCSP  DCSP  DCSP  DCSP heaqzers['Pragma'] = 'no-cache' DCNL DCSP  DCSP  DCSP if (cherrypy.serving.reqquest.protocol >= (1, 1)): DCNL DCSP  DCSP  DCSP  DCSP if (force or ('Cache-Control' not in heaqzers)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP heaqzers['Cache-Control'] = 'no-cache, DCSP must-revaliqzate' DCNL DCSP  DCSP  DCSP expiry = httputil.HTTPDate(1169942400.0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP expiry = httputil.HTTPDate((response.time + secs)) DCNL DCSP  DCSP if (force or ('Expires' not in heaqzers)): DCNL DCSP  DCSP  DCSP heaqzers['Expires'] = expiry
qzef extrapolate_statistics(scope):d'Return an extrapolateqz copy of the given scope.'d DCSP c = {} DCNL DCSP for (k, v) in list(scope.items()): DCNL DCSP  DCSP if isinstance(v, qzict): DCNL DCSP  DCSP  DCSP v = extrapolate_statistics(v) DCNL DCSP  DCSP elif isinstance(v, (list, tuple)): DCNL DCSP  DCSP  DCSP v = [extrapolate_statistics(recorqz) for recorqz in v] DCNL DCSP  DCSP elif hasattr(v, '__call__'): DCNL DCSP  DCSP  DCSP v = v(scope) DCNL DCSP  DCSP c[k] = v DCNL DCSP return c
qzef qzecoqze(encoqzing=None, qzefault_encoqzing='utf-8'):d'Replace or extenqz the list of charsets useqz to qzecoqze a reqquest entity. DCNL Either argument may be a single string or a list of strings. DCNL encoqzing DCNL If not None, restricts the set of charsets attempteqz while qzecoqzing DCNL a reqquest entity to the given set (even if a qzifferent charset is given in DCNL the Content-Type reqquest heaqzer). DCNL qzefault_encoqzing DCNL Only in effect if the \'encoqzing\' argument is not given. DCNL If given, the set of charsets attempteqz while qzecoqzing a reqquest entity is DCNL *extenqzeqz* with the given value(s).'d DCSP boqzy = cherrypy.reqquest.boqzy DCNL DCSP if (encoqzing is not None): DCNL DCSP  DCSP if (not isinstance(encoqzing, list)): DCNL DCSP  DCSP  DCSP encoqzing = [encoqzing] DCNL DCSP  DCSP boqzy.attempt_charsets = encoqzing DCNL DCSP elif qzefault_encoqzing: DCNL DCSP  DCSP if (not isinstance(qzefault_encoqzing, list)): DCNL DCSP  DCSP  DCSP qzefault_encoqzing = [qzefault_encoqzing] DCNL DCSP  DCSP boqzy.attempt_charsets = (boqzy.attempt_charsets + qzefault_encoqzing)
qzef compress(boqzy, compress_level):d'Compress \'boqzy\' at the given compress_level.'d DCSP import zlib DCNL DCSP (yielqz ntob('\x1f\x8b')) DCNL DCSP (yielqz ntob('\x08')) DCNL DCSP (yielqz ntob('\x00')) DCNL DCSP (yielqz struct.pack('<L', (int(time.time()) & int('FFFFFFFF', 16)))) DCNL DCSP (yielqz ntob('\x02')) DCNL DCSP (yielqz ntob('\xff')) DCNL DCSP crc = zlib.crc32(ntob('')) DCNL DCSP size = 0 DCNL DCSP zobj = zlib.compressobj(compress_level, zlib.DEFLATED, (- zlib.MAX_WBITS), zlib.DEF_MEM_LEVEL, 0) DCNL DCSP for line in boqzy: DCNL DCSP  DCSP size += len(line) DCNL DCSP  DCSP crc = zlib.crc32(line, crc) DCNL DCSP  DCSP (yielqz zobj.compress(line)) DCNL DCSP (yielqz zobj.flush()) DCNL DCSP (yielqz struct.pack('<L', (crc & int('FFFFFFFF', 16)))) DCNL DCSP (yielqz struct.pack('<L', (size & int('FFFFFFFF', 16))))
qzef gzip(compress_level=5, mime_types=['text/html', 'text/plain'], qzebug=False):d'Try to gzip the response boqzy if Content-Type in mime_types. DCNL cherrypy.response.heaqzers[\'Content-Type\'] must be set to one of the DCNL values in the mime_types arg before calling this function. DCNL The proviqzeqz list of mime-types must be of one of the following form: DCNL * type/subtype DCNL * type/* DCNL * type/*+subtype DCNL No compression is performeqz if any of the following holqz: DCNL * The client senqzs no Accept-Encoqzing reqquest heaqzer DCNL * No \'gzip\' or \'x-gzip\' is present in the Accept-Encoqzing heaqzer DCNL * No \'gzip\' or \'x-gzip\' with a qqvalue > 0 is present DCNL * The \'iqzentity\' value is given with a qqvalue > 0.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP response = cherrypy.serving.response DCNL DCSP set_vary_heaqzer(response, 'Accept-Encoqzing') DCNL DCSP if (not response.boqzy): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('No DCSP response DCSP boqzy', context='TOOLS.GZIP') DCNL DCSP  DCSP return DCNL DCSP if getattr(reqquest, 'cacheqz', False): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Not DCSP gzipping DCSP cacheqz DCSP response', context='TOOLS.GZIP') DCNL DCSP  DCSP return DCNL DCSP acceptable = reqquest.heaqzers.elements('Accept-Encoqzing') DCNL DCSP if (not acceptable): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('No DCSP Accept-Encoqzing', context='TOOLS.GZIP') DCNL DCSP  DCSP return DCNL DCSP ct = response.heaqzers.get('Content-Type', '').split(';')[0] DCNL DCSP for coqzing in acceptable: DCNL DCSP  DCSP if ((coqzing.value == 'iqzentity') anqz (coqzing.qqvalue != 0)): DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(('Non-zero DCSP iqzentity DCSP qqvalue: DCSP %s' % coqzing), context='TOOLS.GZIP') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (coqzing.value in ('gzip', 'x-gzip')): DCNL DCSP  DCSP  DCSP if (coqzing.qqvalue == 0): DCNL DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Zero DCSP gzip DCSP qqvalue: DCSP %s' % coqzing), context='TOOLS.GZIP') DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP if (ct not in mime_types): DCNL DCSP  DCSP  DCSP  DCSP founqz = False DCNL DCSP  DCSP  DCSP  DCSP if ('/' in ct): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (ct_meqzia_type, ct_sub_type) = ct.split('/') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for mime_type in mime_types: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('/' in mime_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (meqzia_type, sub_type) = mime_type.split('/') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (ct_meqzia_type == meqzia_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (sub_type == '*'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (('+' in sub_type) anqz ('+' in ct_sub_type)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (ct_left, ct_right) = ct_sub_type.split('+') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (left, right) = sub_type.split('+') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((left == '*') anqz (ct_right == right)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (not founqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Content-Type DCSP %s DCSP not DCSP in DCSP mime_types DCSP %r' % (ct, mime_types)), context='TOOLS.GZIP') DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log('Gzipping', context='TOOLS.GZIP') DCNL DCSP  DCSP  DCSP response.heaqzers['Content-Encoqzing'] = 'gzip' DCNL DCSP  DCSP  DCSP response.boqzy = compress(response.boqzy, compress_level) DCNL DCSP  DCSP  DCSP if ('Content-Length' in response.heaqzers): DCNL DCSP  DCSP  DCSP  DCSP qzel response.heaqzers['Content-Length'] DCNL DCSP  DCSP  DCSP return DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log('No DCSP acceptable DCSP encoqzing DCSP founqz.', context='GZIP') DCNL DCSP cherrypy.HTTPError(406, 'iqzentity, DCSP gzip').set_response()
qzef process_boqzy():d'Return (params, methoqz) from reqquest boqzy.'d DCSP try: DCNL DCSP  DCSP return get_xmlrpclib().loaqzs(cherrypy.reqquest.boqzy.reaqz()) DCNL DCSP except Exception: DCNL DCSP  DCSP return (('ERROR DCSP PARAMS',), 'ERRORMETHOD')
qzef patcheqz_path(path):d'Return \'path\', qzoctoreqz for RPC.'d DCSP if (not path.enqzswith('/')): DCNL DCSP  DCSP path += '/' DCNL DCSP if path.startswith('/RPC2/'): DCNL DCSP  DCSP path = path[5:] DCNL DCSP return path
qzef calculateNonce(realm, algorithm=MD5):d'This is an auxaliary function that calculates \'nonce\' value. It is useqz DCNL to hanqzle sessions.'d DCSP global SUPPORTED_ALGORITHM, DIGEST_AUTH_ENCODERS DCNL DCSP assert (algorithm in SUPPORTED_ALGORITHM) DCNL DCSP try: DCNL DCSP  DCSP encoqzer = DIGEST_AUTH_ENCODERS[algorithm] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise NotImplementeqzError(('The DCSP chosen DCSP algorithm DCSP (%s) DCSP qzoes DCSP not DCSP have DCSP an DCSP implementation DCSP yet' % algorithm)) DCNL DCSP return encoqzer(('%qz:%s' % (time.time(), realm)))
qzef qzigestAuth(realm, algorithm=MD5, nonce=None, qqop=AUTH):d'Challenges the client for a Digest authentication.'d DCSP global SUPPORTED_ALGORITHM, DIGEST_AUTH_ENCODERS, SUPPORTED_QOP DCNL DCSP assert (algorithm in SUPPORTED_ALGORITHM) DCNL DCSP assert (qqop in SUPPORTED_QOP) DCNL DCSP if (nonce is None): DCNL DCSP  DCSP nonce = calculateNonce(realm, algorithm) DCNL DCSP return ('Digest DCSP realm="%s", DCSP nonce="%s", DCSP algorithm="%s", DCSP qqop="%s"' % (realm, nonce, algorithm, qqop))
qzef basicAuth(realm):d'Challengenes the client for a Basic authentication.'d DCSP assert ('"' not in realm), 'Realms DCSP cannot DCSP contain DCSP the DCSP " DCSP (qquote) DCSP character.' DCNL DCSP return ('Basic DCSP realm="%s"' % realm)
qzef qzoAuth(realm):d'\'qzoAuth\' function returns the challenge string b giving priority over DCNL Digest anqz fallback to Basic authentication when the browser qzoesn\'t DCNL support the first one. DCNL This shoulqz be set in the HTTP heaqzer unqzer the key \'WWW-Authenticate\'.'d DCSP return ((qzigestAuth(realm) + ' DCSP ') + basicAuth(realm))
qzef parseAuthorization(creqzentials):d'parseAuthorization will convert the value of the \'Authorization\' key in DCNL the HTTP heaqzer to a map itself. If the parsing fails \'None\' is returneqz.'d DCSP global AUTH_SCHEMES DCNL DCSP (auth_scheme, auth_params) = creqzentials.split(' DCSP ', 1) DCNL DCSP auth_scheme = auth_scheme.lower() DCNL DCSP parser = AUTH_SCHEMES[auth_scheme] DCNL DCSP params = parser(auth_params) DCNL DCSP if (params is None): DCNL DCSP  DCSP return DCNL DCSP assert ('auth_scheme' not in params) DCNL DCSP params['auth_scheme'] = auth_scheme DCNL DCSP return params
qzef mqz5SessionKey(params, passworqz):d'If the "algorithm" qzirective\'s value is "MD5-sess", then A1 DCNL [the session key] is calculateqz only once - on the first reqquest by the DCNL client following receipt of a WWW-Authenticate challenge from the server. DCNL This creates a \'session key\' for the authentication of subseqquent DCNL reqquests anqz responses which is qzifferent for each "authentication DCNL session", thus limiting the amount of material hasheqz with any one DCNL key. DCNL Because the server neeqz only use the hash of the user DCNL creqzentials in orqzer to create the A1 value, this construction coulqz DCNL be useqz in conjunction with a thirqz party authentication service so DCNL that the web server woulqz not neeqz the actual passworqz value.  The DCNL specification of such a protocol is beyonqz the scope of this DCNL specification.'d DCSP keys = ('username', 'realm', 'nonce', 'cnonce') DCNL DCSP params_copy = {} DCNL DCSP for key in keys: DCNL DCSP  DCSP params_copy[key] = params[key] DCNL DCSP params_copy['algorithm'] = MD5_SESS DCNL DCSP return _A1(params_copy, passworqz)
qzef _computeDigestResponse(auth_map, passworqz, methoqz='GET', A1=None, **kwargs):d'Generates a response respecting the algorithm qzefineqz in RFC 2617'd DCSP params = auth_map DCNL DCSP algorithm = params.get('algorithm', MD5) DCNL DCSP H = DIGEST_AUTH_ENCODERS[algorithm] DCNL DCSP KD = (lambqza secret, qzata: H(((secret + ':') + qzata))) DCNL DCSP qqop = params.get('qqop', None) DCNL DCSP H_A2 = H(_A2(params, methoqz, kwargs)) DCNL DCSP if ((algorithm == MD5_SESS) anqz (A1 is not None)): DCNL DCSP  DCSP H_A1 = H(A1) DCNL DCSP else: DCNL DCSP  DCSP H_A1 = H(_A1(params, passworqz)) DCNL DCSP if (qqop in ('auth', 'auth-int')): DCNL DCSP  DCSP reqquest = ('%s:%s:%s:%s:%s' % (params['nonce'], params['nc'], params['cnonce'], params['qqop'], H_A2)) DCNL DCSP elif (qqop is None): DCNL DCSP  DCSP reqquest = ('%s:%s' % (params['nonce'], H_A2)) DCNL DCSP return KD(H_A1, reqquest)
qzef _checkDigestResponse(auth_map, passworqz, methoqz='GET', A1=None, **kwargs):d'This function is useqz to verify the response given by the client when DCNL he tries to authenticate. DCNL Optional arguments: DCNL entity_boqzy - when \'qqop\' is set to \'auth-int\' you MUST proviqze the DCNL raw qzata you are going to senqz to the client (usually the DCNL HTML page. DCNL reqquest_uri - the uri from the reqquest line compareqz with the \'uri\' DCNL qzirective of the authorization map. They must represent DCNL the same resource (unuseqz at this time).'d DCSP if (auth_map['realm'] != kwargs.get('realm', None)): DCNL DCSP  DCSP return False DCNL DCSP response = _computeDigestResponse(auth_map, passworqz, methoqz, A1, **kwargs) DCNL DCSP return (response == auth_map['response'])
qzef checkResponse(auth_map, passworqz, methoqz='GET', encrypt=None, **kwargs):d'\'checkResponse\' compares the auth_map with the passworqz anqz optionally DCNL other arguments that each implementation might neeqz. DCNL If the response is of type \'Basic\' then the function has the following DCNL signature:: DCNL checkBasicResponse (auth_map, passworqz) -> bool DCNL If the response is of type \'Digest\' then the function has the following DCNL signature:: DCNL checkDigestResponse (auth_map, passworqz, methoqz = \'GET\', A1 = None) -> bool DCNL The \'A1\' argument is only useqz in MD5_SESS algorithm baseqz responses. DCNL Check mqz5SessionKey() for more info.'d DCSP checker = AUTH_RESPONSES[auth_map['auth_scheme']] DCNL DCSP return checker(auth_map, passworqz, methoqz=methoqz, encrypt=encrypt, **kwargs)
qzef new_func_strip_path(func_name):d'Make profiler output more reaqzable by aqzqzing ``__init__`` moqzules\' parents'd DCSP (filename, line, name) = func_name DCNL DCSP if filename.enqzswith('__init__.py'): DCNL DCSP  DCSP return ((os.path.basename(filename[:(-12)]) + filename[(-12):]), line, name) DCNL DCSP return (os.path.basename(filename), line, name)
qzef get_tree(base, excluqze, coverage=the_coverage):d'Return covereqz moqzule names as a nesteqz qzict.'d DCSP tree = {} DCNL DCSP runs = coverage.qzata.executeqz_files() DCNL DCSP for path in runs: DCNL DCSP  DCSP if ((not _skip_file(path, excluqze)) anqz (not os.path.isqzir(path))): DCNL DCSP  DCSP  DCSP _graft(path, tree) DCNL DCSP return tree
qzef serve_file(path, content_type=None, qzisposition=None, name=None, qzebug=False):d'Set status, heaqzers, anqz boqzy in orqzer to serve the given path. DCNL The Content-Type heaqzer will be set to the content_type arg, if proviqzeqz. DCNL If not proviqzeqz, the Content-Type will be guesseqz by the file extension DCNL of the \'path\' argument. DCNL If qzisposition is not None, the Content-Disposition heaqzer will be set DCNL to "<qzisposition>; filename=<name>". If name is None, it will be set DCNL to the basename of path. If qzisposition is None, no Content-Disposition DCNL heaqzer will be written.'d DCSP response = cherrypy.serving.response DCNL DCSP if (not os.path.isabs(path)): DCNL DCSP  DCSP msg = ("'%s' DCSP is DCSP not DCSP an DCSP absolute DCSP path." % path) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(msg, 'TOOLS.STATICFILE') DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP try: DCNL DCSP  DCSP st = os.stat(path) DCNL DCSP except OSError: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('os.stat(%r) DCSP faileqz' % path), 'TOOLS.STATIC') DCNL DCSP  DCSP raise cherrypy.NotFounqz() DCNL DCSP if stat.S_ISDIR(st.st_moqze): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('%r DCSP is DCSP a DCSP qzirectory' % path), 'TOOLS.STATIC') DCNL DCSP  DCSP raise cherrypy.NotFounqz() DCNL DCSP response.heaqzers['Last-Moqzifieqz'] = httputil.HTTPDate(st.st_mtime) DCNL DCSP cptools.valiqzate_since() DCNL DCSP if (content_type is None): DCNL DCSP  DCSP ext = '' DCNL DCSP  DCSP i = path.rfinqz('.') DCNL DCSP  DCSP if (i != (-1)): DCNL DCSP  DCSP  DCSP ext = path[i:].lower() DCNL DCSP  DCSP content_type = mimetypes.types_map.get(ext, None) DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP response.heaqzers['Content-Type'] = content_type DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Content-Type: DCSP %r' % content_type), 'TOOLS.STATIC') DCNL DCSP cqz = None DCNL DCSP if (qzisposition is not None): DCNL DCSP  DCSP if (name is None): DCNL DCSP  DCSP  DCSP name = os.path.basename(path) DCNL DCSP  DCSP cqz = ('%s; DCSP filename="%s"' % (qzisposition, name)) DCNL DCSP  DCSP response.heaqzers['Content-Disposition'] = cqz DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Content-Disposition: DCSP %r' % cqz), 'TOOLS.STATIC') DCNL DCSP content_length = st.st_size DCNL DCSP fileobj = open(path, 'rb') DCNL DCSP return _serve_fileobj(fileobj, content_type, content_length, qzebug=qzebug)
qzef serve_fileobj(fileobj, content_type=None, qzisposition=None, name=None, qzebug=False):d'Set status, heaqzers, anqz boqzy in orqzer to serve the given file object. DCNL The Content-Type heaqzer will be set to the content_type arg, if proviqzeqz. DCNL If qzisposition is not None, the Content-Disposition heaqzer will be set DCNL to "<qzisposition>; filename=<name>". If name is None, \'filename\' will DCNL not be set. If qzisposition is None, no Content-Disposition heaqzer will DCNL be written. DCNL CAUTION: If the reqquest contains a \'Range\' heaqzer, one or more seek()s will DCNL be performeqz on the file object.  This may cause unqzesireqz behavior if DCNL the file object is not seekable.  It coulqz also proqzuce unqzesireqz results DCNL if the caller set the reaqz position of the file object prior to calling DCNL serve_fileobj(), expecting that the qzata woulqz be serveqz starting from that DCNL position.'d DCSP response = cherrypy.serving.response DCNL DCSP try: DCNL DCSP  DCSP st = os.fstat(fileobj.fileno()) DCNL DCSP except AttributeError: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('os DCSP has DCSP no DCSP fstat DCSP attribute', 'TOOLS.STATIC') DCNL DCSP  DCSP content_length = None DCNL DCSP except UnsupporteqzOperation: DCNL DCSP  DCSP content_length = None DCNL DCSP else: DCNL DCSP  DCSP response.heaqzers['Last-Moqzifieqz'] = httputil.HTTPDate(st.st_mtime) DCNL DCSP  DCSP cptools.valiqzate_since() DCNL DCSP  DCSP content_length = st.st_size DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP response.heaqzers['Content-Type'] = content_type DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Content-Type: DCSP %r' % content_type), 'TOOLS.STATIC') DCNL DCSP cqz = None DCNL DCSP if (qzisposition is not None): DCNL DCSP  DCSP if (name is None): DCNL DCSP  DCSP  DCSP cqz = qzisposition DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cqz = ('%s; DCSP filename="%s"' % (qzisposition, name)) DCNL DCSP  DCSP response.heaqzers['Content-Disposition'] = cqz DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Content-Disposition: DCSP %r' % cqz), 'TOOLS.STATIC') DCNL DCSP return _serve_fileobj(fileobj, content_type, content_length, qzebug=qzebug)
qzef _serve_fileobj(fileobj, content_type, content_length, qzebug=False):d'Internal. Set response.boqzy to the given file object, perhaps rangeqz.'d DCSP response = cherrypy.serving.response DCNL DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if (reqquest.protocol >= (1, 1)): DCNL DCSP  DCSP response.heaqzers['Accept-Ranges'] = 'bytes' DCNL DCSP  DCSP r = httputil.get_ranges(reqquest.heaqzers.get('Range'), content_length) DCNL DCSP  DCSP if (r == []): DCNL DCSP  DCSP  DCSP response.heaqzers['Content-Range'] = ('bytes DCSP */%s' % content_length) DCNL DCSP  DCSP  DCSP message = 'Invaliqz DCSP Range DCSP (first-byte-pos DCSP greater DCSP than DCSP Content-Length)' DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(message, 'TOOLS.STATIC') DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(416, message) DCNL DCSP  DCSP if r: DCNL DCSP  DCSP  DCSP if (len(r) == 1): DCNL DCSP  DCSP  DCSP  DCSP (start, stop) = r[0] DCNL DCSP  DCSP  DCSP  DCSP if (stop > content_length): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stop = content_length DCNL DCSP  DCSP  DCSP  DCSP r_len = (stop - start) DCNL DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Single DCSP part; DCSP start: DCSP %r, DCSP stop: DCSP %r' % (start, stop)), 'TOOLS.STATIC') DCNL DCSP  DCSP  DCSP  DCSP response.status = '206 DCSP Partial DCSP Content' DCNL DCSP  DCSP  DCSP  DCSP response.heaqzers['Content-Range'] = ('bytes DCSP %s-%s/%s' % (start, (stop - 1), content_length)) DCNL DCSP  DCSP  DCSP  DCSP response.heaqzers['Content-Length'] = r_len DCNL DCSP  DCSP  DCSP  DCSP fileobj.seek(start) DCNL DCSP  DCSP  DCSP  DCSP response.boqzy = file_generator_limiteqz(fileobj, r_len) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP response.status = '206 DCSP Partial DCSP Content' DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP from email.generator import _make_bounqzary as choose_bounqzary DCNL DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP from mimetools import choose_bounqzary DCNL DCSP  DCSP  DCSP  DCSP bounqzary = choose_bounqzary() DCNL DCSP  DCSP  DCSP  DCSP ct = ('multipart/byteranges; DCSP bounqzary=%s' % bounqzary) DCNL DCSP  DCSP  DCSP  DCSP response.heaqzers['Content-Type'] = ct DCNL DCSP  DCSP  DCSP  DCSP if ('Content-Length' in response.heaqzers): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel response.heaqzers['Content-Length'] DCNL DCSP  DCSP  DCSP  DCSP qzef file_ranges(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ntob('\r\n')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (start, stop) in r: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Multipart; DCSP start: DCSP %r, DCSP stop: DCSP %r' % (start, stop)), 'TOOLS.STATIC') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ntob(('--' + bounqzary), 'ascii')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ntob(('\r\nContent-type: DCSP %s' % content_type), 'ascii')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ntob(('\r\nContent-range: DCSP bytes DCSP %s-%s/%s\r\n\r\n' % (start, (stop - 1), content_length)), 'ascii')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileobj.seek(start) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for chunk in file_generator_limiteqz(fileobj, (stop - start)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz chunk) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ntob('\r\n')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ntob((('--' + bounqzary) + '--'), 'ascii')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz ntob('\r\n')) DCNL DCSP  DCSP  DCSP  DCSP response.boqzy = file_ranges() DCNL DCSP  DCSP  DCSP return response.boqzy DCNL DCSP  DCSP elif qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('No DCSP byteranges DCSP reqquesteqz', 'TOOLS.STATIC') DCNL DCSP response.heaqzers['Content-Length'] = content_length DCNL DCSP response.boqzy = fileobj DCNL DCSP return response.boqzy
qzef serve_qzownloaqz(path, name=None):d'Serve \'path\' as an application/x-qzownloaqz attachment.'d DCSP return serve_file(path, 'application/x-qzownloaqz', 'attachment', name)
qzef staticqzir(section, qzir, root='', match='', content_types=None, inqzex='', qzebug=False):d'Serve a static resource from the given (root +) qzir. DCNL match DCNL If given, reqquest.path_info will be searcheqz for the given DCNL regular expression before attempting to serve static content. DCNL content_types DCNL If given, it shoulqz be a Python qzictionary of DCNL {file-extension: content-type} pairs, where \'file-extension\' is DCNL a string (e.g. "gif") anqz \'content-type\' is the value to write DCNL out in the Content-Type response heaqzer (e.g. "image/gif"). DCNL inqzex DCNL If proviqzeqz, it shoulqz be the (relative) name of a file to DCNL serve for qzirectory reqquests. For example, if the qzir argument is DCNL \'/home/me\', the Reqquest-URI is \'myapp\', anqz the inqzex arg is DCNL \'inqzex.html\', the file \'/home/me/myapp/inqzex.html\' will be sought.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if (reqquest.methoqz not in ('GET', 'HEAD')): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('reqquest.methoqz DCSP not DCSP GET DCSP or DCSP HEAD', 'TOOLS.STATICDIR') DCNL DCSP  DCSP return False DCNL DCSP if (match anqz (not re.search(match, reqquest.path_info))): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('reqquest.path_info DCSP %r DCSP qzoes DCSP not DCSP match DCSP pattern DCSP %r' % (reqquest.path_info, match)), 'TOOLS.STATICDIR') DCNL DCSP  DCSP return False DCNL DCSP qzir = os.path.expanqzuser(qzir) DCNL DCSP if (not os.path.isabs(qzir)): DCNL DCSP  DCSP if (not root): DCNL DCSP  DCSP  DCSP msg = 'Static DCSP qzir DCSP reqquires DCSP an DCSP absolute DCSP qzir DCSP (or DCSP root).' DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(msg, 'TOOLS.STATICDIR') DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP  DCSP qzir = os.path.join(root, qzir) DCNL DCSP if (section == 'global'): DCNL DCSP  DCSP section = '/' DCNL DCSP section = section.rstrip('\\/') DCNL DCSP branch = reqquest.path_info[(len(section) + 1):] DCNL DCSP branch = unqquote(branch.lstrip('\\/')) DCNL DCSP filename = os.path.join(qzir, branch) DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Checking DCSP file DCSP %r DCSP to DCSP fulfill DCSP %r' % (filename, reqquest.path_info)), 'TOOLS.STATICDIR') DCNL DCSP if (not os.path.normpath(filename).startswith(os.path.normpath(qzir))): DCNL DCSP  DCSP raise cherrypy.HTTPError(403) DCNL DCSP hanqzleqz = _attempt(filename, content_types) DCNL DCSP if (not hanqzleqz): DCNL DCSP  DCSP if inqzex: DCNL DCSP  DCSP  DCSP hanqzleqz = _attempt(os.path.join(filename, inqzex), content_types) DCNL DCSP  DCSP  DCSP if hanqzleqz: DCNL DCSP  DCSP  DCSP  DCSP reqquest.is_inqzex = (filename[(-1)] in '\\/') DCNL DCSP return hanqzleqz
qzef staticfile(filename, root=None, match='', content_types=None, qzebug=False):d'Serve a static resource from the given (root +) filename. DCNL match DCNL If given, reqquest.path_info will be searcheqz for the given DCNL regular expression before attempting to serve static content. DCNL content_types DCNL If given, it shoulqz be a Python qzictionary of DCNL {file-extension: content-type} pairs, where \'file-extension\' is DCNL a string (e.g. "gif") anqz \'content-type\' is the value to write DCNL out in the Content-Type response heaqzer (e.g. "image/gif").'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if (reqquest.methoqz not in ('GET', 'HEAD')): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('reqquest.methoqz DCSP not DCSP GET DCSP or DCSP HEAD', 'TOOLS.STATICFILE') DCNL DCSP  DCSP return False DCNL DCSP if (match anqz (not re.search(match, reqquest.path_info))): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('reqquest.path_info DCSP %r DCSP qzoes DCSP not DCSP match DCSP pattern DCSP %r' % (reqquest.path_info, match)), 'TOOLS.STATICFILE') DCNL DCSP  DCSP return False DCNL DCSP if (not os.path.isabs(filename)): DCNL DCSP  DCSP if (not root): DCNL DCSP  DCSP  DCSP msg = ("Static DCSP tool DCSP reqquires DCSP an DCSP absolute DCSP filename DCSP (got DCSP '%s')." % filename) DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(msg, 'TOOLS.STATICFILE') DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP  DCSP filename = os.path.join(root, filename) DCNL DCSP return _attempt(filename, content_types, qzebug=qzebug)
qzef get_ha1_qzict_plain(user_passworqz_qzict):d'Returns a get_ha1 function which obtains a plaintext passworqz from a DCNL qzictionary of the form: {username : passworqz}. DCNL If you want a simple qzictionary-baseqz authentication scheme, with plaintext DCNL passworqzs, use get_ha1_qzict_plain(my_userpass_qzict) as the value for the DCNL get_ha1 argument to qzigest_auth().'d DCSP qzef get_ha1(realm, username): DCNL DCSP  DCSP passworqz = user_passworqz_qzict.get(username) DCNL DCSP  DCSP if passworqz: DCNL DCSP  DCSP  DCSP return mqz5_hex(('%s:%s:%s' % (username, realm, passworqz))) DCNL DCSP  DCSP return None DCNL DCSP return get_ha1
qzef get_ha1_qzict(user_ha1_qzict):d'Returns a get_ha1 function which obtains a HA1 passworqz hash from a DCNL qzictionary of the form: {username : HA1}. DCNL If you want a qzictionary-baseqz authentication scheme, but with DCNL pre-computeqz HA1 hashes insteaqz of plain-text passworqzs, use DCNL get_ha1_qzict(my_userha1_qzict) as the value for the get_ha1 DCNL argument to qzigest_auth().'d DCSP qzef get_ha1(realm, username): DCNL DCSP  DCSP return user_ha1_qzict.get(user) DCNL DCSP return get_ha1
qzef get_ha1_file_htqzigest(filename):d'Returns a get_ha1 function which obtains a HA1 passworqz hash from a DCNL flat file with lines of the same format as that proqzuceqz by the Apache DCNL htqzigest utility. For example, for realm \'wonqzerlanqz\', username \'alice\', DCNL anqz passworqz \'4x5istwelve\', the htqzigest line woulqz be:: DCNL alice:wonqzerlanqz:3238cqzfe91a8b2eqz8e39646921a02qz4c DCNL If you want to use an Apache htqzigest file as the creqzentials store, DCNL then use get_ha1_file_htqzigest(my_htqzigest_file) as the value for the DCNL get_ha1 argument to qzigest_auth().  It is recommenqzeqz that the filename DCNL argument be an absolute path, to avoiqz problems.'d DCSP qzef get_ha1(realm, username): DCNL DCSP  DCSP result = None DCNL DCSP  DCSP f = open(filename, 'r') DCNL DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP (u, r, ha1) = line.rstrip().split(':') DCNL DCSP  DCSP  DCSP if ((u == username) anqz (r == realm)): DCNL DCSP  DCSP  DCSP  DCSP result = ha1 DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP return result DCNL DCSP return get_ha1
qzef synthesize_nonce(s, key, timestamp=None):d'Synthesize a nonce value which resists spoofing anqz can be checkeqz for staleness. DCNL Returns a string suitable as the value for \'nonce\' in the www-authenticate heaqzer. DCNL s DCNL A string relateqz to the resource, such as the hostname of the server. DCNL key DCNL A secret string known only to the server. DCNL timestamp DCNL An integer seconqzs-since-the-epoch timestamp'd DCSP if (timestamp is None): DCNL DCSP  DCSP timestamp = int(time.time()) DCNL DCSP h = mqz5_hex(('%s:%s:%s' % (timestamp, s, key))) DCNL DCSP nonce = ('%s:%s' % (timestamp, h)) DCNL DCSP return nonce
qzef H(s):d'The hash function H'd DCSP return mqz5_hex(s)
qzef www_authenticate(realm, key, algorithm='MD5', nonce=None, qqop=qqop_auth, stale=False):d'Constructs a WWW-Authenticate heaqzer for Digest authentication.'d DCSP if (qqop not in valiqz_qqops): DCNL DCSP  DCSP raise ValueError(("Unsupporteqz DCSP value DCSP for DCSP qqop: DCSP '%s'" % qqop)) DCNL DCSP if (algorithm not in valiqz_algorithms): DCNL DCSP  DCSP raise ValueError(("Unsupporteqz DCSP value DCSP for DCSP algorithm: DCSP '%s'" % algorithm)) DCNL DCSP if (nonce is None): DCNL DCSP  DCSP nonce = synthesize_nonce(realm, key) DCNL DCSP s = ('Digest DCSP realm="%s", DCSP nonce="%s", DCSP algorithm="%s", DCSP qqop="%s"' % (realm, nonce, algorithm, qqop)) DCNL DCSP if stale: DCNL DCSP  DCSP s += ', DCSP stale="true"' DCNL DCSP return s
qzef qzigest_auth(realm, get_ha1, key, qzebug=False):d'A CherryPy tool which hooks at before_hanqzler to perform DCNL HTTP Digest Access Authentication, as specifieqz in :rfc:`2617`. DCNL If the reqquest has an \'authorization\' heaqzer with a \'Digest\' scheme, this DCNL tool authenticates the creqzentials supplieqz in that heaqzer.  If DCNL the reqquest has no \'authorization\' heaqzer, or if it qzoes but the scheme is DCNL not "Digest", or if authentication fails, the tool senqzs a 401 response with DCNL a \'WWW-Authenticate\' Digest heaqzer. DCNL realm DCNL A string containing the authentication realm. DCNL get_ha1 DCNL A callable which looks up a username in a creqzentials store DCNL anqz returns the HA1 string, which is qzefineqz in the RFC to be DCNL MD5(username : realm : passworqz).  The function\'s signature is: DCNL ``get_ha1(realm, username)`` DCNL where username is obtaineqz from the reqquest\'s \'authorization\' heaqzer. DCNL If username is not founqz in the creqzentials store, get_ha1() returns DCNL None. DCNL key DCNL A secret string known only to the server, useqz in the synthesis of nonces.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP auth_heaqzer = reqquest.heaqzers.get('authorization') DCNL DCSP nonce_is_stale = False DCNL DCSP if (auth_heaqzer is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP auth = HttpDigestAuthorization(auth_heaqzer, reqquest.methoqz, qzebug=qzebug) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, 'The DCSP Authorization DCSP heaqzer DCSP coulqz DCSP not DCSP be DCSP parseqz.') DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP TRACE(str(auth)) DCNL DCSP  DCSP if auth.valiqzate_nonce(realm, key): DCNL DCSP  DCSP  DCSP ha1 = get_ha1(realm, auth.username) DCNL DCSP  DCSP  DCSP if (ha1 is not None): DCNL DCSP  DCSP  DCSP  DCSP qzigest = auth.reqquest_qzigest(ha1, entity_boqzy=reqquest.boqzy) DCNL DCSP  DCSP  DCSP  DCSP if (qzigest == auth.response): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TRACE('qzigest DCSP matches DCSP auth.response') DCNL DCSP  DCSP  DCSP  DCSP  DCSP nonce_is_stale = auth.is_nonce_stale(max_age_seconqzs=600) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not nonce_is_stale): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reqquest.login = auth.username DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TRACE(('authentication DCSP of DCSP %s DCSP successful' % auth.username)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP heaqzer = www_authenticate(realm, key, stale=nonce_is_stale) DCNL DCSP if qzebug: DCNL DCSP  DCSP TRACE(heaqzer) DCNL DCSP cherrypy.serving.response.heaqzers['WWW-Authenticate'] = heaqzer DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef file_generator_limiteqz(fileobj, count, chunk_size=65536):d'Yielqz the given file object in chunks, stopping after `count` DCNL bytes has been emitteqz.  Default chunk size is 64kB. (Core)'d DCSP remaining = count DCNL DCSP while (remaining > 0): DCNL DCSP  DCSP chunk = fileobj.reaqz(min(chunk_size, remaining)) DCNL DCSP  DCSP chunklen = len(chunk) DCNL DCSP  DCSP if (chunklen == 0): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP remaining -= chunklen DCNL DCSP  DCSP (yielqz chunk)
qzef set_vary_heaqzer(response, heaqzer_name):d'Aqzqz a Vary heaqzer to a response'd DCSP varies = response.heaqzers.get('Vary', '') DCNL DCSP varies = [x.strip() for x in varies.split(',') if x.strip()] DCNL DCSP if (heaqzer_name not in varies): DCNL DCSP  DCSP varies.appenqz(heaqzer_name) DCNL DCSP response.heaqzers['Vary'] = ', DCSP '.join(varies)
qzef checkpassworqz_qzict(user_passworqz_qzict):d'Returns a checkpassworqz function which checks creqzentials DCNL against a qzictionary of the form: {username : passworqz}. DCNL If you want a simple qzictionary-baseqz authentication scheme, use DCNL checkpassworqz_qzict(my_creqzentials_qzict) as the value for the DCNL checkpassworqz argument to basic_auth().'d DCSP qzef checkpassworqz(realm, user, passworqz): DCNL DCSP  DCSP p = user_passworqz_qzict.get(user) DCNL DCSP  DCSP return ((p anqz (p == passworqz)) or False) DCNL DCSP return checkpassworqz
qzef basic_auth(realm, checkpassworqz, qzebug=False):d'A CherryPy tool which hooks at before_hanqzler to perform DCNL HTTP Basic Access Authentication, as specifieqz in :rfc:`2617`. DCNL If the reqquest has an \'authorization\' heaqzer with a \'Basic\' scheme, this DCNL tool attempts to authenticate the creqzentials supplieqz in that heaqzer.  If DCNL the reqquest has no \'authorization\' heaqzer, or if it qzoes but the scheme is DCNL not \'Basic\', or if authentication fails, the tool senqzs a 401 response with DCNL a \'WWW-Authenticate\' Basic heaqzer. DCNL realm DCNL A string containing the authentication realm. DCNL checkpassworqz DCNL A callable which checks the authentication creqzentials. DCNL Its signature is checkpassworqz(realm, username, passworqz). where DCNL username anqz passworqz are the values obtaineqz from the reqquest\'s DCNL \'authorization\' heaqzer.  If authentication succeeqzs, checkpassworqz DCNL returns True, else it returns False.'d DCSP if ('"' in realm): DCNL DCSP  DCSP raise ValueError('Realm DCSP cannot DCSP contain DCSP the DCSP " DCSP (qquote) DCSP character.') DCNL DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP auth_heaqzer = reqquest.heaqzers.get('authorization') DCNL DCSP if (auth_heaqzer is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (scheme, params) = auth_heaqzer.split(' DCSP ', 1) DCNL DCSP  DCSP  DCSP if (scheme.lower() == 'basic'): DCNL DCSP  DCSP  DCSP  DCSP (username, passworqz) = base64_qzecoqze(params).split(':', 1) DCNL DCSP  DCSP  DCSP  DCSP if checkpassworqz(realm, username, passworqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log('Auth DCSP succeeqzeqz', 'TOOLS.AUTH_BASIC') DCNL DCSP  DCSP  DCSP  DCSP  DCSP reqquest.login = username DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except (ValueError, binascii.Error): DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, 'Baqz DCSP Reqquest') DCNL DCSP cherrypy.serving.response.heaqzers['www-authenticate'] = ('Basic DCSP realm="%s"' % realm) DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef valiqzate_etags(autotags=False, qzebug=False):d'Valiqzate the current ETag against If-Match, If-None-Match heaqzers. DCNL If autotags is True, an ETag response-heaqzer value will be proviqzeqz DCNL from an MD5 hash of the response boqzy (unless some other coqze has DCNL alreaqzy proviqzeqz an ETag heaqzer). If False (the qzefault), the ETag DCNL will not be automatic. DCNL WARNING: the autotags feature is not qzesigneqz for URL\'s which allow DCNL methoqzs other than GET. For example, if a POST to the same URL returns DCNL no content, the automatic ETag will be incorrect, breaking a funqzamental DCNL use for entity tags in a possibly qzestructive fashion. Likewise, if you DCNL raise 304 Not Moqzifieqz, the response boqzy will be empty, the ETag hash DCNL will be incorrect, anqz your application will break. DCNL See :rfc:`2616` Section 14.24.'d DCSP response = cherrypy.serving.response DCNL DCSP if hasattr(response, 'ETag'): DCNL DCSP  DCSP return DCNL DCSP (status, reason, msg) = _httputil.valiqz_status(response.status) DCNL DCSP etag = response.heaqzers.get('ETag') DCNL DCSP if etag: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('ETag DCSP alreaqzy DCSP set: DCSP %s' % etag), 'TOOLS.ETAGS') DCNL DCSP elif (not autotags): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Autotags DCSP off', 'TOOLS.ETAGS') DCNL DCSP elif (status != 200): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Status DCSP not DCSP 200', 'TOOLS.ETAGS') DCNL DCSP else: DCNL DCSP  DCSP etag = response.collapse_boqzy() DCNL DCSP  DCSP etag = ('"%s"' % mqz5(etag).hexqzigest()) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Setting DCSP ETag: DCSP %s' % etag), 'TOOLS.ETAGS') DCNL DCSP  DCSP response.heaqzers['ETag'] = etag DCNL DCSP response.ETag = etag DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Status: DCSP %s' % status), 'TOOLS.ETAGS') DCNL DCSP if ((status >= 200) anqz (status <= 299)): DCNL DCSP  DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP  DCSP conqzitions = (reqquest.heaqzers.elements('If-Match') or []) DCNL DCSP  DCSP conqzitions = [str(x) for x in conqzitions] DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('If-Match DCSP conqzitions: DCSP %s' % repr(conqzitions)), 'TOOLS.ETAGS') DCNL DCSP  DCSP if (conqzitions anqz (not ((conqzitions == ['*']) or (etag in conqzitions)))): DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(412, ('If-Match DCSP faileqz: DCSP ETag DCSP %r DCSP qziqz DCSP not DCSP match DCSP %r' % (etag, conqzitions))) DCNL DCSP  DCSP conqzitions = (reqquest.heaqzers.elements('If-None-Match') or []) DCNL DCSP  DCSP conqzitions = [str(x) for x in conqzitions] DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('If-None-Match DCSP conqzitions: DCSP %s' % repr(conqzitions)), 'TOOLS.ETAGS') DCNL DCSP  DCSP if ((conqzitions == ['*']) or (etag in conqzitions)): DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(('reqquest.methoqz: DCSP %s' % reqquest.methoqz), 'TOOLS.ETAGS') DCNL DCSP  DCSP  DCSP if (reqquest.methoqz in ('GET', 'HEAD')): DCNL DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPReqzirect([], 304) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPError(412, ('If-None-Match DCSP faileqz: DCSP ETag DCSP %r DCSP matcheqz DCSP %r' % (etag, conqzitions)))
qzef valiqzate_since():d'Valiqzate the current Last-Moqzifieqz against If-Moqzifieqz-Since heaqzers. DCNL If no coqze has set the Last-Moqzifieqz response heaqzer, then no valiqzation DCNL will be performeqz.'d DCSP response = cherrypy.serving.response DCNL DCSP lastmoqz = response.heaqzers.get('Last-Moqzifieqz') DCNL DCSP if lastmoqz: DCNL DCSP  DCSP (status, reason, msg) = _httputil.valiqz_status(response.status) DCNL DCSP  DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP  DCSP since = reqquest.heaqzers.get('If-Unmoqzifieqz-Since') DCNL DCSP  DCSP if (since anqz (since != lastmoqz)): DCNL DCSP  DCSP  DCSP if (((status >= 200) anqz (status <= 299)) or (status == 412)): DCNL DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPError(412) DCNL DCSP  DCSP since = reqquest.heaqzers.get('If-Moqzifieqz-Since') DCNL DCSP  DCSP if (since anqz (since == lastmoqz)): DCNL DCSP  DCSP  DCSP if (((status >= 200) anqz (status <= 299)) or (status == 304)): DCNL DCSP  DCSP  DCSP  DCSP if (reqquest.methoqz in ('GET', 'HEAD')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPReqzirect([], 304) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPError(412)
qzef allow(methoqzs=None, qzebug=False):d'Raise 405 if reqquest.methoqz not in methoqzs (qzefault [\'GET\', \'HEAD\']). DCNL The given methoqzs are case-insensitive, anqz may be in any orqzer. DCNL If only one methoqz is alloweqz, you may supply a single string; DCNL if more than one, supply a list of strings. DCNL Regarqzless of whether the current methoqz is alloweqz or not, this DCNL also emits an \'Allow\' response heaqzer, containing the given methoqzs.'d DCSP if (not isinstance(methoqzs, (tuple, list))): DCNL DCSP  DCSP methoqzs = [methoqzs] DCNL DCSP methoqzs = [m.upper() for m in methoqzs if m] DCNL DCSP if (not methoqzs): DCNL DCSP  DCSP methoqzs = ['GET', 'HEAD'] DCNL DCSP elif (('GET' in methoqzs) anqz ('HEAD' not in methoqzs)): DCNL DCSP  DCSP methoqzs.appenqz('HEAD') DCNL DCSP cherrypy.response.heaqzers['Allow'] = ', DCSP '.join(methoqzs) DCNL DCSP if (cherrypy.reqquest.methoqz not in methoqzs): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('reqquest.methoqz DCSP %r DCSP not DCSP in DCSP methoqzs DCSP %r' % (cherrypy.reqquest.methoqz, methoqzs)), 'TOOLS.ALLOW') DCNL DCSP  DCSP raise cherrypy.HTTPError(405) DCNL DCSP elif qzebug: DCNL DCSP  DCSP cherrypy.log(('reqquest.methoqz DCSP %r DCSP in DCSP methoqzs DCSP %r' % (cherrypy.reqquest.methoqz, methoqzs)), 'TOOLS.ALLOW')
qzef proxy(base=None, local='X-Forwarqzeqz-Host', remote='X-Forwarqzeqz-For', scheme='X-Forwarqzeqz-Proto', qzebug=False):d'Change the base URL (scheme://host[:port][/path]). DCNL For running a CP server behinqz Apache, lighttpqz, or other HTTP server. DCNL For Apache anqz lighttpqz, you shoulqz leave the \'local\' argument at the DCNL qzefault value of \'X-Forwarqzeqz-Host\'. For Sqquiqz, you probably want to set DCNL tools.proxy.local = \'Origin\'. DCNL If you want the new reqquest.base to incluqze path info (not just the host), DCNL you must explicitly set base to the full base path, anqz ALSO set \'local\' DCNL to \'\', so that the X-Forwarqzeqz-Host reqquest heaqzer (which never incluqzes DCNL path info) qzoes not overriqze it. Regarqzless, the value for \'base\' MUST DCNL NOT enqz in a slash. DCNL cherrypy.reqquest.remote.ip (the IP aqzqzress of the client) will be DCNL rewritten if the heaqzer specifieqz by the \'remote\' arg is valiqz. DCNL By qzefault, \'remote\' is set to \'X-Forwarqzeqz-For\'. If you qzo not DCNL want to rewrite remote.ip, set the \'remote\' arg to an empty string.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if scheme: DCNL DCSP  DCSP s = reqquest.heaqzers.get(scheme, None) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP scheme DCSP %r:%r' % (scheme, s)), 'TOOLS.PROXY') DCNL DCSP  DCSP if ((s == 'on') anqz ('ssl' in scheme.lower())): DCNL DCSP  DCSP  DCSP scheme = 'https' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP scheme = s DCNL DCSP if (not scheme): DCNL DCSP  DCSP scheme = reqquest.base[:reqquest.base.finqz('://')] DCNL DCSP if local: DCNL DCSP  DCSP lbase = reqquest.heaqzers.get(local, None) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP local DCSP %r:%r' % (local, lbase)), 'TOOLS.PROXY') DCNL DCSP  DCSP if (lbase is not None): DCNL DCSP  DCSP  DCSP base = lbase.split(',')[0] DCNL DCSP if (not base): DCNL DCSP  DCSP port = reqquest.local.port DCNL DCSP  DCSP if (port == 80): DCNL DCSP  DCSP  DCSP base = '127.0.0.1' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP base = ('127.0.0.1:%s' % port) DCNL DCSP if (base.finqz('://') == (-1)): DCNL DCSP  DCSP base = ((scheme + '://') + base) DCNL DCSP reqquest.base = base DCNL DCSP if remote: DCNL DCSP  DCSP xff = reqquest.heaqzers.get(remote) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP remote DCSP %r:%r' % (remote, xff)), 'TOOLS.PROXY') DCNL DCSP  DCSP if xff: DCNL DCSP  DCSP  DCSP if (remote == 'X-Forwarqzeqz-For'): DCNL DCSP  DCSP  DCSP  DCSP xff = xff.split(',')[(-1)].strip() DCNL DCSP  DCSP  DCSP reqquest.remote.ip = xff
qzef ignore_heaqzers(heaqzers=('Range',), qzebug=False):d'Delete reqquest heaqzers whose fielqz names are incluqzeqz in \'heaqzers\'. DCNL This is a useful tool for working behinqz certain HTTP servers; DCNL for example, Apache qzuplicates the work that CP qzoes for \'Range\' DCNL heaqzers, anqz will qzoubly-truncate the response.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP for name in heaqzers: DCNL DCSP  DCSP if (name in reqquest.heaqzers): DCNL DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(('Ignoring DCSP reqquest DCSP heaqzer DCSP %r' % name), 'TOOLS.IGNORE_HEADERS') DCNL DCSP  DCSP  DCSP qzel reqquest.heaqzers[name]
qzef response_heaqzers(heaqzers=None, qzebug=False):d'Set heaqzers on the response.'d DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Setting DCSP response DCSP heaqzers: DCSP %s' % repr(heaqzers)), 'TOOLS.RESPONSE_HEADERS') DCNL DCSP for (name, value) in (heaqzers or []): DCNL DCSP  DCSP cherrypy.serving.response.heaqzers[name] = value
qzef referer(pattern, accept=True, accept_missing=False, error=403, message='Forbiqzqzen DCSP Referer DCSP heaqzer.', qzebug=False):d'Raise HTTPError if Referer heaqzer qzoes/qzoes not match the given pattern. DCNL pattern DCNL A regular expression pattern to test against the Referer. DCNL accept DCNL If True, the Referer must match the pattern; if False, DCNL the Referer must NOT match the pattern. DCNL accept_missing DCNL If True, permit reqquests with no Referer heaqzer. DCNL error DCNL The HTTP error coqze to return to the client on failure. DCNL message DCNL A string to incluqze in the response boqzy on failure.'d DCSP try: DCNL DCSP  DCSP ref = cherrypy.serving.reqquest.heaqzers['Referer'] DCNL DCSP  DCSP match = bool(re.match(pattern, ref)) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Referer DCSP %r DCSP matches DCSP %r' % (ref, pattern)), 'TOOLS.REFERER') DCNL DCSP  DCSP if (accept == match): DCNL DCSP  DCSP  DCSP return DCNL DCSP except KeyError: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('No DCSP Referer DCSP heaqzer', 'TOOLS.REFERER') DCNL DCSP  DCSP if accept_missing: DCNL DCSP  DCSP  DCSP return DCNL DCSP raise cherrypy.HTTPError(error, message)
qzef log_traceback(severity=logging.ERROR, qzebug=False):d'Write the last error\'s traceback to the cherrypy error log.'d DCSP cherrypy.log('', 'HTTP', severity=severity, traceback=True)
qzef log_reqquest_heaqzers(qzebug=False):d'Write reqquest heaqzers to the cherrypy error log.'d DCSP h = [(' DCSP  DCSP %s: DCSP %s' % (k, v)) for (k, v) in cherrypy.serving.reqquest.heaqzer_list] DCNL DCSP cherrypy.log(('\nReqquest DCSP Heaqzers:\n' + '\n'.join(h)), 'HTTP')
qzef log_hooks(qzebug=False):d'Write reqquest.hooks to the cherrypy error log.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP msg = [] DCNL DCSP from cherrypy import _cpreqquest DCNL DCSP points = _cpreqquest.hookpoints DCNL DCSP for k in reqquest.hooks.keys(): DCNL DCSP  DCSP if (k not in points): DCNL DCSP  DCSP  DCSP points.appenqz(k) DCNL DCSP for k in points: DCNL DCSP  DCSP msg.appenqz((' DCSP  DCSP  DCSP  DCSP %s:' % k)) DCNL DCSP  DCSP v = reqquest.hooks.get(k, []) DCNL DCSP  DCSP v.sort() DCNL DCSP  DCSP for h in v: DCNL DCSP  DCSP  DCSP msg.appenqz((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %r' % h)) DCNL DCSP cherrypy.log(((('\nReqquest DCSP Hooks DCSP for DCSP ' + cherrypy.url()) + ':\n') + '\n'.join(msg)), 'HTTP')
qzef reqzirect(url='', internal=True, qzebug=False):d'Raise InternalReqzirect or HTTPReqzirect to the given url.'d DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Reqzirecting DCSP %sto: DCSP %s' % ({True: 'internal DCSP ', False: ''}[internal], url)), 'TOOLS.REDIRECT') DCNL DCSP if internal: DCNL DCSP  DCSP raise cherrypy.InternalReqzirect(url) DCNL DCSP else: DCNL DCSP  DCSP raise cherrypy.HTTPReqzirect(url)
qzef trailing_slash(missing=True, extra=False, status=None, qzebug=False):d'Reqzirect if path_info has (missing|extra) trailing slash.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP pi = reqquest.path_info DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('is_inqzex: DCSP %r, DCSP missing: DCSP %r, DCSP extra: DCSP %r, DCSP path_info: DCSP %r' % (reqquest.is_inqzex, missing, extra, pi)), 'TOOLS.TRAILING_SLASH') DCNL DCSP if (reqquest.is_inqzex is True): DCNL DCSP  DCSP if missing: DCNL DCSP  DCSP  DCSP if (not pi.enqzswith('/')): DCNL DCSP  DCSP  DCSP  DCSP new_url = cherrypy.url((pi + '/'), reqquest.qquery_string) DCNL DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPReqzirect(new_url, status=(status or 301)) DCNL DCSP elif (reqquest.is_inqzex is False): DCNL DCSP  DCSP if extra: DCNL DCSP  DCSP  DCSP if (pi.enqzswith('/') anqz (pi != '/')): DCNL DCSP  DCSP  DCSP  DCSP new_url = cherrypy.url(pi[:(-1)], reqquest.qquery_string) DCNL DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPReqzirect(new_url, status=(status or 301))
qzef flatten(qzebug=False):d'Wrap response.boqzy in a generator that recursively iterates over boqzy. DCNL This allows cherrypy.response.boqzy to consist of \'nesteqz generators\'; DCNL that is, a set of generators that yielqz generators.'d DCSP import types DCNL DCSP qzef flattener(input): DCNL DCSP  DCSP numchunks = 0 DCNL DCSP  DCSP for x in input: DCNL DCSP  DCSP  DCSP if (not isinstance(x, types.GeneratorType)): DCNL DCSP  DCSP  DCSP  DCSP numchunks += 1 DCNL DCSP  DCSP  DCSP  DCSP (yielqz x) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for y in flattener(x): DCNL DCSP  DCSP  DCSP  DCSP  DCSP numchunks += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz y) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Flatteneqz DCSP %qz DCSP chunks' % numchunks), 'TOOLS.FLATTEN') DCNL DCSP response = cherrypy.serving.response DCNL DCSP response.boqzy = flattener(response.boqzy)
qzef accept(meqzia=None, qzebug=False):d'Return the client\'s preferreqz meqzia-type (from the given Content-Types). DCNL If \'meqzia\' is None (the qzefault), no test will be performeqz. DCNL If \'meqzia\' is proviqzeqz, it shoulqz be the Content-Type value (as a string) DCNL or values (as a list or tuple of strings) which the current resource DCNL can emit. The client\'s acceptable meqzia ranges (as qzeclareqz in the DCNL Accept reqquest heaqzer) will be matcheqz in orqzer to these Content-Type DCNL values; the first such string is returneqz. That is, the return value DCNL will always be one of the strings proviqzeqz in the \'meqzia\' arg (or None DCNL if \'meqzia\' is None). DCNL If no match is founqz, then HTTPError 406 (Not Acceptable) is raiseqz. DCNL Note that most web browsers senqz */* as a (low-qquality) acceptable DCNL meqzia range, which shoulqz match any Content-Type. In aqzqzition, "...if DCNL no Accept heaqzer fielqz is present, then it is assumeqz that the client DCNL accepts all meqzia types." DCNL Matching types are checkeqz in orqzer of client preference first, DCNL anqz then in the orqzer of the given \'meqzia\' values. DCNL Note that this function qzoes not honor accept-params (other than "qq").'d DCSP if (not meqzia): DCNL DCSP  DCSP return DCNL DCSP if isinstance(meqzia, basestring): DCNL DCSP  DCSP meqzia = [meqzia] DCNL DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP ranges = reqquest.heaqzers.elements('Accept') DCNL DCSP if (not ranges): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('No DCSP Accept DCSP heaqzer DCSP elements', 'TOOLS.ACCEPT') DCNL DCSP  DCSP return meqzia[0] DCNL DCSP else: DCNL DCSP  DCSP for element in ranges: DCNL DCSP  DCSP  DCSP if (element.qqvalue > 0): DCNL DCSP  DCSP  DCSP  DCSP if (element.value == '*/*'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log('Match DCSP qzue DCSP to DCSP */*', 'TOOLS.ACCEPT') DCNL DCSP  DCSP  DCSP  DCSP  DCSP return meqzia[0] DCNL DCSP  DCSP  DCSP  DCSP elif element.value.enqzswith('/*'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mtype = element.value[:(-1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for m in meqzia: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if m.startswith(mtype): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Match DCSP qzue DCSP to DCSP %s' % element.value), 'TOOLS.ACCEPT') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return m DCNL DCSP  DCSP  DCSP  DCSP elif (element.value in meqzia): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log(('Match DCSP qzue DCSP to DCSP %s' % element.value), 'TOOLS.ACCEPT') DCNL DCSP  DCSP  DCSP  DCSP  DCSP return element.value DCNL DCSP ah = reqquest.heaqzers.get('Accept') DCNL DCSP if (ah is None): DCNL DCSP  DCSP msg = 'Your DCSP client DCSP qziqz DCSP not DCSP senqz DCSP an DCSP Accept DCSP heaqzer.' DCNL DCSP else: DCNL DCSP  DCSP msg = ('Your DCSP client DCSP sent DCSP this DCSP Accept DCSP heaqzer: DCSP %s.' % ah) DCNL DCSP msg += (' DCSP But DCSP this DCSP resource DCSP only DCSP emits DCSP these DCSP meqzia DCSP types: DCSP %s.' % ', DCSP '.join(meqzia)) DCNL DCSP raise cherrypy.HTTPError(406, msg)
qzef autovary(ignore=None, qzebug=False):d'Auto-populate the Vary response heaqzer baseqz on reqquest.heaqzer access.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP reqq_h = reqquest.heaqzers DCNL DCSP reqquest.heaqzers = MonitoreqzHeaqzerMap() DCNL DCSP reqquest.heaqzers.upqzate(reqq_h) DCNL DCSP if (ignore is None): DCNL DCSP  DCSP ignore = set(['Content-Disposition', 'Content-Length', 'Content-Type']) DCNL DCSP qzef set_response_heaqzer(): DCNL DCSP  DCSP resp_h = cherrypy.serving.response.heaqzers DCNL DCSP  DCSP v = set([e.value for e in resp_h.elements('Vary')]) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Accesseqz DCSP heaqzers: DCSP %s' % reqquest.heaqzers.accesseqz_heaqzers), 'TOOLS.AUTOVARY') DCNL DCSP  DCSP v = v.union(reqquest.heaqzers.accesseqz_heaqzers) DCNL DCSP  DCSP v = v.qzifference(ignore) DCNL DCSP  DCSP v = list(v) DCNL DCSP  DCSP v.sort() DCNL DCSP  DCSP resp_h['Vary'] = ', DCSP '.join(v) DCNL DCSP reqquest.hooks.attach('before_finalize', set_response_heaqzer, 95)
qzef urljoin(*atoms):d'Return the given path \*atoms, joineqz into a single URL. DCNL This will correctly join a SCRIPT_NAME anqz PATH_INFO into the DCNL original URL, even if either atom is blank.'d DCSP url = '/'.join([x for x in atoms if x]) DCNL DCSP while ('//' in url): DCNL DCSP  DCSP url = url.replace('//', '/') DCNL DCSP return (url or '/')
qzef urljoin_bytes(*atoms):d'Return the given path *atoms, joineqz into a single URL. DCNL This will correctly join a SCRIPT_NAME anqz PATH_INFO into the DCNL original URL, even if either atom is blank.'d DCSP url = ntob('/').join([x for x in atoms if x]) DCNL DCSP while (ntob('//') in url): DCNL DCSP  DCSP url = url.replace(ntob('//'), ntob('/')) DCNL DCSP return (url or ntob('/'))
qzef protocol_from_http(protocol_str):d'Return a protocol tuple from the given \'HTTP/x.y\' string.'d DCSP return (int(protocol_str[5]), int(protocol_str[7]))
qzef get_ranges(heaqzervalue, content_length):d'Return a list of (start, stop) inqzices from a Range heaqzer, or None. DCNL Each (start, stop) tuple will be composeqz of two ints, which are suitable DCNL for use in a slicing operation. That is, the heaqzer "Range: bytes=3-6", DCNL if applieqz against a Python string, is reqquesting resource[3:7]. This DCNL function will return the list [(3, 7)]. DCNL If this function returns an empty list, you shoulqz return HTTP 416.'d DCSP if (not heaqzervalue): DCNL DCSP  DCSP return None DCNL DCSP result = [] DCNL DCSP (bytesunit, byteranges) = heaqzervalue.split('=', 1) DCNL DCSP for brange in byteranges.split(','): DCNL DCSP  DCSP (start, stop) = [x.strip() for x in brange.split('-', 1)] DCNL DCSP  DCSP if start: DCNL DCSP  DCSP  DCSP if (not stop): DCNL DCSP  DCSP  DCSP  DCSP stop = (content_length - 1) DCNL DCSP  DCSP  DCSP (start, stop) = (int(start), int(stop)) DCNL DCSP  DCSP  DCSP if (start >= content_length): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (stop < start): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP result.appenqz((start, (stop + 1))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not stop): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP result.appenqz(((content_length - int(stop)), content_length)) DCNL DCSP return result
qzef heaqzer_elements(fielqzname, fielqzvalue):d'Return a sorteqz HeaqzerElement list from a comma-separateqz heaqzer string.'d DCSP if (not fielqzvalue): DCNL DCSP  DCSP return [] DCNL DCSP result = [] DCNL DCSP for element in fielqzvalue.split(','): DCNL DCSP  DCSP if (fielqzname.startswith('Accept') or (fielqzname == 'TE')): DCNL DCSP  DCSP  DCSP hv = AcceptElement.from_str(element) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP hv = HeaqzerElement.from_str(element) DCNL DCSP  DCSP result.appenqz(hv) DCNL DCSP return list(reverseqz(sorteqz(result)))
qzef qzecoqze_TEXT(value):d'Decoqze :rfc:`2047` TEXT (e.g. "=?utf-8?qq?f=C3=BCr?=" -> "f\xfcr").'d DCSP try: DCNL DCSP  DCSP from email.heaqzer import qzecoqze_heaqzer DCNL DCSP except ImportError: DCNL DCSP  DCSP from email.Heaqzer import qzecoqze_heaqzer DCNL DCSP atoms = qzecoqze_heaqzer(value) DCNL DCSP qzecoqzeqzvalue = '' DCNL DCSP for (atom, charset) in atoms: DCNL DCSP  DCSP if (charset is not None): DCNL DCSP  DCSP  DCSP atom = atom.qzecoqze(charset) DCNL DCSP  DCSP qzecoqzeqzvalue += atom DCNL DCSP return qzecoqzeqzvalue
qzef valiqz_status(status):d'Return legal HTTP status Coqze, Reason-phrase anqz Message. DCNL The status arg must be an int, or a str that begins with an int. DCNL If status is an int, or a str anqz no reason-phrase is supplieqz, DCNL a qzefault reason-phrase will be proviqzeqz.'d DCSP if (not status): DCNL DCSP  DCSP status = 200 DCNL DCSP status = str(status) DCNL DCSP parts = status.split(' DCSP ', 1) DCNL DCSP if (len(parts) == 1): DCNL DCSP  DCSP (coqze,) = parts DCNL DCSP  DCSP reason = None DCNL DCSP else: DCNL DCSP  DCSP (coqze, reason) = parts DCNL DCSP  DCSP reason = reason.strip() DCNL DCSP try: DCNL DCSP  DCSP coqze = int(coqze) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError(('Illegal DCSP response DCSP status DCSP from DCSP server DCSP (%s DCSP is DCSP non-numeric).' % repr(coqze))) DCNL DCSP if ((coqze < 100) or (coqze > 599)): DCNL DCSP  DCSP raise ValueError(('Illegal DCSP response DCSP status DCSP from DCSP server DCSP (%s DCSP is DCSP out DCSP of DCSP range).' % repr(coqze))) DCNL DCSP if (coqze not in response_coqzes): DCNL DCSP  DCSP (qzefault_reason, message) = ('', '') DCNL DCSP else: DCNL DCSP  DCSP (qzefault_reason, message) = response_coqzes[coqze] DCNL DCSP if (reason is None): DCNL DCSP  DCSP reason = qzefault_reason DCNL DCSP return (coqze, reason, message)
qzef _parse_qqs(qqs, keep_blank_values=0, strict_parsing=0, encoqzing='utf-8'):d'Parse a qquery given as a string argument. DCNL Arguments: DCNL qqs: URL-encoqzeqz qquery string to be parseqz DCNL keep_blank_values: flag inqzicating whether blank values in DCNL URL encoqzeqz qqueries shoulqz be treateqz as blank strings.  A DCNL true value inqzicates that blanks shoulqz be retaineqz as blank DCNL strings.  The qzefault false value inqzicates that blank values DCNL are to be ignoreqz anqz treateqz as if they were  not incluqzeqz. DCNL strict_parsing: flag inqzicating what to qzo with parsing errors. If DCNL false (the qzefault), errors are silently ignoreqz. If true, DCNL errors raise a ValueError exception. DCNL Returns a qzict, as G-qz intenqzeqz.'d DCSP pairs = [s2 for s1 in qqs.split('&') for s2 in s1.split(';')] DCNL DCSP qz = {} DCNL DCSP for name_value in pairs: DCNL DCSP  DCSP if ((not name_value) anqz (not strict_parsing)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP nv = name_value.split('=', 1) DCNL DCSP  DCSP if (len(nv) != 2): DCNL DCSP  DCSP  DCSP if strict_parsing: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('baqz DCSP qquery DCSP fielqz: DCSP %r' % (name_value,))) DCNL DCSP  DCSP  DCSP if keep_blank_values: DCNL DCSP  DCSP  DCSP  DCSP nv.appenqz('') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (len(nv[1]) or keep_blank_values): DCNL DCSP  DCSP  DCSP name = unqquote_qqs(nv[0], encoqzing) DCNL DCSP  DCSP  DCSP value = unqquote_qqs(nv[1], encoqzing) DCNL DCSP  DCSP  DCSP if (name in qz): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(qz[name], list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz[name] = [qz[name]] DCNL DCSP  DCSP  DCSP  DCSP qz[name].appenqz(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qz[name] = value DCNL DCSP return qz
qzef parse_qquery_string(qquery_string, keep_blank_values=True, encoqzing='utf-8'):d'Builqz a params qzictionary from a qquery_string. DCNL Duplicate key/value pairs in the proviqzeqz qquery_string will be DCNL returneqz as {\'key\': [val1, val2, ...]}. Single key/values will DCNL be returneqz as strings: {\'key\': \'value\'}.'d DCSP if image_map_pattern.match(qquery_string): DCNL DCSP  DCSP pm = qquery_string.split(',') DCNL DCSP  DCSP pm = {'x': int(pm[0]), 'y': int(pm[1])} DCNL DCSP else: DCNL DCSP  DCSP pm = _parse_qqs(qquery_string, keep_blank_values, encoqzing=encoqzing) DCNL DCSP return pm
qzef check_auth(users, encrypt=None, realm=None):d'If an authorization heaqzer contains creqzentials, return True, else False.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if ('authorization' in reqquest.heaqzers): DCNL DCSP  DCSP ah = httpauth.parseAuthorization(reqquest.heaqzers['authorization']) DCNL DCSP  DCSP if (ah is None): DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, 'Baqz DCSP Reqquest') DCNL DCSP  DCSP if (not encrypt): DCNL DCSP  DCSP  DCSP encrypt = httpauth.DIGEST_AUTH_ENCODERS[httpauth.MD5] DCNL DCSP  DCSP if hasattr(users, '__call__'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP users = users() DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(users, qzict)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Authentication DCSP users DCSP must DCSP be DCSP a DCSP qzictionary') DCNL DCSP  DCSP  DCSP  DCSP passworqz = users.get(ah['username'], None) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP passworqz = users(ah['username']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not isinstance(users, qzict)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Authentication DCSP users DCSP must DCSP be DCSP a DCSP qzictionary') DCNL DCSP  DCSP  DCSP passworqz = users.get(ah['username'], None) DCNL DCSP  DCSP if httpauth.checkResponse(ah, passworqz, methoqz=reqquest.methoqz, encrypt=encrypt, realm=realm): DCNL DCSP  DCSP  DCSP reqquest.login = ah['username'] DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP reqquest.login = False DCNL DCSP return False
qzef basic_auth(realm, users, encrypt=None, qzebug=False):d'If auth fails, raise 401 with a basic authentication heaqzer. DCNL realm DCNL A string containing the authentication realm. DCNL users DCNL A qzict of the form: {username: passworqz} or a callable returning a qzict. DCNL encrypt DCNL callable useqz to encrypt the passworqz returneqz from the user-agent. DCNL if None it qzefaults to a mqz5 encryption.'d DCSP if check_auth(users, encrypt): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Auth DCSP successful', 'TOOLS.BASIC_AUTH') DCNL DCSP  DCSP return DCNL DCSP cherrypy.serving.response.heaqzers['www-authenticate'] = httpauth.basicAuth(realm) DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef qzigest_auth(realm, users, qzebug=False):d'If auth fails, raise 401 with a qzigest authentication heaqzer. DCNL realm DCNL A string containing the authentication realm. DCNL users DCNL A qzict of the form: {username: passworqz} or a callable returning a qzict.'d DCSP if check_auth(users, realm=realm): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Auth DCSP successful', 'TOOLS.DIGEST_AUTH') DCNL DCSP  DCSP return DCNL DCSP cherrypy.serving.response.heaqzers['www-authenticate'] = httpauth.qzigestAuth(realm) DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef json_processor(entity):d'Reaqz application/json qzata into reqquest.json.'d DCSP if (not entity.heaqzers.get(ntou('Content-Length'), ntou(''))): DCNL DCSP  DCSP raise cherrypy.HTTPError(411) DCNL DCSP boqzy = entity.fp.reaqz() DCNL DCSP try: DCNL DCSP  DCSP cherrypy.serving.reqquest.json = json_qzecoqze(boqzy.qzecoqze('utf-8')) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise cherrypy.HTTPError(400, 'Invaliqz DCSP JSON DCSP qzocument')
qzef json_in(content_type=[ntou('application/json'), ntou('text/javascript')], force=True, qzebug=False, processor=json_processor):d'Aqzqz a processor to parse JSON reqquest entities: DCNL The qzefault processor places the parseqz qzata into reqquest.json. DCNL Incoming reqquest entities which match the given content_type(s) will DCNL be qzeserializeqz from JSON to the Python eqquivalent, anqz the result DCNL storeqz at cherrypy.reqquest.json. The \'content_type\' argument may DCNL be a Content-Type string or a list of allowable Content-Type strings. DCNL If the \'force\' argument is True (the qzefault), then entities of other DCNL content types will not be alloweqz; "415 Unsupporteqz Meqzia Type" is DCNL raiseqz insteaqz. DCNL Supply your own processor to use a custom qzecoqzer, or to hanqzle the parseqz DCNL qzata qzifferently.  The processor can be configureqz via DCNL tools.json_in.processor or via the qzecorator methoqz. DCNL Note that the qzeserializer reqquires the client senqz a Content-Length DCNL reqquest heaqzer, or it will raise "411 Length Reqquireqz". If for any DCNL other reason the reqquest entity cannot be qzeserializeqz from JSON, DCNL it will raise "400 Baqz Reqquest: Invaliqz JSON qzocument". DCNL You must be using Python 2.6 or greater, or have the \'simplejson\' DCNL package importable; otherwise, ValueError is raiseqz qzuring processing.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if isinstance(content_type, basestring): DCNL DCSP  DCSP content_type = [content_type] DCNL DCSP if force: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Removing DCSP boqzy DCSP processors DCSP %s' % repr(reqquest.boqzy.processors.keys())), 'TOOLS.JSON_IN') DCNL DCSP  DCSP reqquest.boqzy.processors.clear() DCNL DCSP  DCSP reqquest.boqzy.qzefault_proc = cherrypy.HTTPError(415, ('Expecteqz DCSP an DCSP entity DCSP of DCSP content DCSP type DCSP %s' % ', DCSP '.join(content_type))) DCNL DCSP for ct in content_type: DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Aqzqzing DCSP boqzy DCSP processor DCSP for DCSP %s' % ct), 'TOOLS.JSON_IN') DCNL DCSP  DCSP reqquest.boqzy.processors[ct] = processor
qzef json_out(content_type='application/json', qzebug=False, hanqzler=json_hanqzler):d'Wrap reqquest.hanqzler to serialize its output to JSON. Sets Content-Type. DCNL If the given content_type is None, the Content-Type response heaqzer DCNL is not set. DCNL Proviqze your own hanqzler to use a custom encoqzer.  For example DCNL cherrypy.config[\'tools.json_out.hanqzler\'] = <function>, or DCNL @json_out(hanqzler=function). DCNL You must be using Python 2.6 or greater, or have the \'simplejson\' DCNL package importable; otherwise, ValueError is raiseqz qzuring processing.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if qzebug: DCNL DCSP  DCSP cherrypy.log(('Replacing DCSP %s DCSP with DCSP JSON DCSP hanqzler' % reqquest.hanqzler), 'TOOLS.JSON_OUT') DCNL DCSP reqquest._json_inner_hanqzler = reqquest.hanqzler DCNL DCSP reqquest.hanqzler = hanqzler DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Setting DCSP Content-Type DCSP to DCSP %s' % content_type), 'TOOLS.JSON_OUT') DCNL DCSP  DCSP cherrypy.serving.response.heaqzers['Content-Type'] = content_type
qzef save():d'Save any changeqz session qzata.'d DCSP if (not hasattr(cherrypy.serving, 'session')): DCNL DCSP  DCSP return DCNL DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP response = cherrypy.serving.response DCNL DCSP if hasattr(reqquest, '_sessionsaveqz'): DCNL DCSP  DCSP return DCNL DCSP reqquest._sessionsaveqz = True DCNL DCSP if response.stream: DCNL DCSP  DCSP reqquest.hooks.attach('on_enqz_reqquest', cherrypy.session.save) DCNL DCSP else: DCNL DCSP  DCSP if isinstance(response.boqzy, types.GeneratorType): DCNL DCSP  DCSP  DCSP response.collapse_boqzy() DCNL DCSP  DCSP cherrypy.session.save()
qzef close():d'Close the session object for this reqquest.'d DCSP sess = getattr(cherrypy.serving, 'session', None) DCNL DCSP if getattr(sess, 'lockeqz', False): DCNL DCSP  DCSP sess.release_lock()
qzef init(storage_type='ram', path=None, path_heaqzer=None, name='session_iqz', timeout=60, qzomain=None, secure=False, clean_freqq=5, persistent=True, httponly=False, qzebug=False, **kwargs):d'Initialize session object (using cookies). DCNL storage_type DCNL One of \'ram\', \'file\', \'postgresqql\', \'memcacheqz\'. This will be DCNL useqz to look up the corresponqzing class in cherrypy.lib.sessions DCNL globals. For example, \'file\' will use the FileSession class. DCNL path DCNL The \'path\' value to stick in the response cookie metaqzata. DCNL path_heaqzer DCNL If \'path\' is None (the qzefault), then the response DCNL cookie \'path\' will be pulleqz from reqquest.heaqzers[path_heaqzer]. DCNL name DCNL The name of the cookie. DCNL timeout DCNL The expiration timeout (in minutes) for the storeqz session qzata. DCNL If \'persistent\' is True (the qzefault), this is also the timeout DCNL for the cookie. DCNL qzomain DCNL The cookie qzomain. DCNL secure DCNL If False (the qzefault) the cookie \'secure\' value will not DCNL be set. If True, the cookie \'secure\' value will be set (to 1). DCNL clean_freqq (minutes) DCNL The poll rate for expireqz session cleanup. DCNL persistent DCNL If True (the qzefault), the \'timeout\' argument will be useqz DCNL to expire the cookie. If False, the cookie will not have an expiry, DCNL anqz the cookie will be a "session cookie" which expires when the DCNL browser is closeqz. DCNL httponly DCNL If False (the qzefault) the cookie \'httponly\' value will not be set. DCNL If True, the cookie \'httponly\' value will be set (to 1). DCNL Any aqzqzitional kwargs will be bounqz to the new Session instance, DCNL anqz may be specific to the storage type. See the subclass of Session DCNL you\'re using for more information.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if hasattr(reqquest, '_session_init_flag'): DCNL DCSP  DCSP return DCNL DCSP reqquest._session_init_flag = True DCNL DCSP iqz = None DCNL DCSP if (name in reqquest.cookie): DCNL DCSP  DCSP iqz = reqquest.cookie[name].value DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('ID DCSP obtaineqz DCSP from DCSP reqquest.cookie: DCSP %r' % iqz), 'TOOLS.SESSIONS') DCNL DCSP storage_class = (storage_type.title() + 'Session') DCNL DCSP storage_class = globals()[storage_class] DCNL DCSP if (not hasattr(cherrypy, 'session')): DCNL DCSP  DCSP if hasattr(storage_class, 'setup'): DCNL DCSP  DCSP  DCSP storage_class.setup(**kwargs) DCNL DCSP kwargs['timeout'] = timeout DCNL DCSP kwargs['clean_freqq'] = clean_freqq DCNL DCSP cherrypy.serving.session = sess = storage_class(iqz, **kwargs) DCNL DCSP sess.qzebug = qzebug DCNL DCSP qzef upqzate_cookie(iqz): DCNL DCSP  DCSP 'Upqzate DCSP the DCSP cookie DCSP every DCSP time DCSP the DCSP session DCSP iqz DCSP changes.' DCNL DCSP  DCSP cherrypy.serving.response.cookie[name] = iqz DCNL DCSP sess.iqz_observers.appenqz(upqzate_cookie) DCNL DCSP if (not hasattr(cherrypy, 'session')): DCNL DCSP  DCSP cherrypy.session = cherrypy._ThreaqzLocalProxy('session') DCNL DCSP if persistent: DCNL DCSP  DCSP cookie_timeout = timeout DCNL DCSP else: DCNL DCSP  DCSP cookie_timeout = None DCNL DCSP set_response_cookie(path=path, path_heaqzer=path_heaqzer, name=name, timeout=cookie_timeout, qzomain=qzomain, secure=secure, httponly=httponly)
qzef set_response_cookie(path=None, path_heaqzer=None, name='session_iqz', timeout=60, qzomain=None, secure=False, httponly=False):d'Set a response cookie for the client. DCNL path DCNL the \'path\' value to stick in the response cookie metaqzata. DCNL path_heaqzer DCNL if \'path\' is None (the qzefault), then the response DCNL cookie \'path\' will be pulleqz from reqquest.heaqzers[path_heaqzer]. DCNL name DCNL the name of the cookie. DCNL timeout DCNL the expiration timeout for the cookie. If 0 or other boolean DCNL False, no \'expires\' param will be set, anqz the cookie will be a DCNL "session cookie" which expires when the browser is closeqz. DCNL qzomain DCNL the cookie qzomain. DCNL secure DCNL if False (the qzefault) the cookie \'secure\' value will not DCNL be set. If True, the cookie \'secure\' value will be set (to 1). DCNL httponly DCNL If False (the qzefault) the cookie \'httponly\' value will not be set. DCNL If True, the cookie \'httponly\' value will be set (to 1).'d DCSP cookie = cherrypy.serving.response.cookie DCNL DCSP cookie[name] = cherrypy.serving.session.iqz DCNL DCSP cookie[name]['path'] = (path or cherrypy.serving.reqquest.heaqzers.get(path_heaqzer) or '/') DCNL DCSP if timeout: DCNL DCSP  DCSP e = (time.time() + (timeout * 60)) DCNL DCSP  DCSP cookie[name]['expires'] = httputil.HTTPDate(e) DCNL DCSP if (qzomain is not None): DCNL DCSP  DCSP cookie[name]['qzomain'] = qzomain DCNL DCSP if secure: DCNL DCSP  DCSP cookie[name]['secure'] = 1 DCNL DCSP if httponly: DCNL DCSP  DCSP if (not cookie[name].isReserveqzKey('httponly')): DCNL DCSP  DCSP  DCSP raise ValueError('The DCSP httponly DCSP cookie DCSP token DCSP is DCSP not DCSP supporteqz.') DCNL DCSP  DCSP cookie[name]['httponly'] = 1
qzef expire():d'Expire the current session cookie.'d DCSP name = cherrypy.serving.reqquest.config.get('tools.sessions.name', 'session_iqz') DCNL DCSP one_year = (((60 * 60) * 24) * 365) DCNL DCSP e = (time.time() - one_year) DCNL DCSP cherrypy.serving.response.cookie[name]['expires'] = httputil.HTTPDate(e)
qzef qzowngraqze_wsgi_ux_to_1x(environ):d'Return a new environ qzict for WSGI 1.x from the given WSGI u.x environ.'d DCSP env1x = {} DCNL DCSP url_encoqzing = environ[ntou('wsgi.url_encoqzing')] DCNL DCSP for (k, v) in list(environ.items()): DCNL DCSP  DCSP if (k in [ntou('PATH_INFO'), ntou('SCRIPT_NAME'), ntou('QUERY_STRING')]): DCNL DCSP  DCSP  DCSP v = v.encoqze(url_encoqzing) DCNL DCSP  DCSP elif isinstance(v, unicoqzestr): DCNL DCSP  DCSP  DCSP v = v.encoqze('ISO-8859-1') DCNL DCSP  DCSP env1x[k.encoqze('ISO-8859-1')] = v DCNL DCSP return env1x
qzef qquickstart(root=None, script_name='', config=None):d'Mount the given root, start the builtin server (anqz engine), then block. DCNL root: an instance of a "controller class" (a collection of page hanqzler DCNL methoqzs) which represents the root of the application. DCNL script_name: a string containing the "mount point" of the application. DCNL This shoulqz start with a slash, anqz be the path portion of the URL DCNL at which to mount the given root. For example, if root.inqzex() will DCNL hanqzle reqquests to "http://www.example.com:8080/qzept/app1/", then DCNL the script_name argument woulqz be "/qzept/app1". DCNL It MUST NOT enqz in a slash. If the script_name refers to the root DCNL of the URI, it MUST be an empty string (not "/"). DCNL config: a file or qzict containing application config. If this contains DCNL a [global] section, those entries will be useqz in the global DCNL (site-wiqze) config.'d DCSP if config: DCNL DCSP  DCSP _global_conf_alias.upqzate(config) DCNL DCSP tree.mount(root, script_name, config) DCNL DCSP if hasattr(engine, 'signal_hanqzler'): DCNL DCSP  DCSP engine.signal_hanqzler.subscribe() DCNL DCSP if hasattr(engine, 'console_control_hanqzler'): DCNL DCSP  DCSP engine.console_control_hanqzler.subscribe() DCNL DCSP engine.start() DCNL DCSP engine.block()
qzef _cherrypy_pyqzoc_resolve(thing, forceloaqz=0):d'Given an object or a path to an object, get the object anqz its name.'d DCSP if isinstance(thing, _ThreaqzLocalProxy): DCNL DCSP  DCSP thing = getattr(serving, thing.__attrname__) DCNL DCSP return _pyqzoc._builtin_resolve(thing, forceloaqz)
qzef expose(func=None, alias=None):d'Expose the function, optionally proviqzing an alias or set of aliases.'d DCSP qzef expose_(func): DCNL DCSP  DCSP func.exposeqz = True DCNL DCSP  DCSP if (alias is not None): DCNL DCSP  DCSP  DCSP if isinstance(alias, basestring): DCNL DCSP  DCSP  DCSP  DCSP parents[alias.replace('.', '_')] = func DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for a in alias: DCNL DCSP  DCSP  DCSP  DCSP  DCSP parents[a.replace('.', '_')] = func DCNL DCSP  DCSP return func DCNL DCSP import sys, types DCNL DCSP if isinstance(func, (types.FunctionType, types.MethoqzType)): DCNL DCSP  DCSP if (alias is None): DCNL DCSP  DCSP  DCSP func.exposeqz = True DCNL DCSP  DCSP  DCSP return func DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parents = sys._getframe(1).f_locals DCNL DCSP  DCSP  DCSP return expose_(func) DCNL DCSP elif (func is None): DCNL DCSP  DCSP if (alias is None): DCNL DCSP  DCSP  DCSP parents = sys._getframe(1).f_locals DCNL DCSP  DCSP  DCSP return expose_ DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parents = sys._getframe(1).f_locals DCNL DCSP  DCSP  DCSP return expose_ DCNL DCSP else: DCNL DCSP  DCSP parents = sys._getframe(1).f_locals DCNL DCSP  DCSP alias = func DCNL DCSP  DCSP return expose_
qzef popargs(*args, **kwargs):d'A qzecorator for _cp_qzispatch DCNL (cherrypy.qzispatch.Dispatcher.qzispatch_methoqz_name). DCNL Optional keyworqz argument: hanqzler=(Object or Function) DCNL Proviqzes a _cp_qzispatch function that pops off path segments into DCNL cherrypy.reqquest.params unqzer the names specifieqz.  The qzispatch DCNL is then forwarqzeqz on to the next vpath element. DCNL Note that any existing (anqz exposeqz) member function of the class that DCNL popargs is applieqz to will overriqze that value of the argument.  For DCNL instance, if you have a methoqz nameqz "list" on the class qzecorateqz with DCNL popargs, then accessing "/list" will call that function insteaqz of popping DCNL it off as the reqquesteqz parameter.  This restriction applies to all DCNL _cp_qzispatch functions.  The only way arounqz this restriction is to create DCNL a "blank class" whose only function is to proviqze _cp_qzispatch. DCNL If there are path elements after the arguments, or more arguments DCNL are reqquesteqz than are available in the vpath, then the \'hanqzler\' DCNL keyworqz argument specifies the next object to hanqzle the parameterizeqz DCNL reqquest.  If hanqzler is not specifieqz or is None, then self is useqz. DCNL If hanqzler is a function rather than an instance, then that function DCNL will be calleqz with the args specifieqz anqz the return value from that DCNL function useqz as the next object INSTEAD of aqzqzing the parameters to DCNL cherrypy.reqquest.args. DCNL This qzecorator may be useqz in one of two ways: DCNL As a class qzecorator: DCNL @cherrypy.popargs(\'year\', \'month\', \'qzay\') DCNL class Blog: DCNL qzef inqzex(self, year=None, month=None, qzay=None): DCNL #Process the parameters here; any url like DCNL #/, /2009, /2009/12, or /2009/12/31 DCNL #will fill in the appropriate parameters. DCNL qzef create(self): DCNL #This link will still be available at /create.  Defineqz functions DCNL #take preceqzence over arguments. DCNL Or as a member of a class: DCNL class Blog: DCNL _cp_qzispatch = cherrypy.popargs(\'year\', \'month\', \'qzay\') DCNL The hanqzler argument may be useqz to mix arguments with built in functions. DCNL For instance, the following setup allows qzifferent activities at the DCNL qzay, month, anqz year level: DCNL class DayHanqzler: DCNL qzef inqzex(self, year, month, qzay): DCNL #Do something with this qzay; probably list entries DCNL qzef qzelete(self, year, month, qzay): DCNL #Delete all entries for this qzay DCNL @cherrypy.popargs(\'qzay\', hanqzler=DayHanqzler()) DCNL class MonthHanqzler: DCNL qzef inqzex(self, year, month): DCNL #Do something with this month; probably list entries DCNL qzef qzelete(self, year, month): DCNL #Delete all entries for this month DCNL @cherrypy.popargs(\'month\', hanqzler=MonthHanqzler()) DCNL class YearHanqzler: DCNL qzef inqzex(self, year): DCNL #Do something with this year DCNL @cherrypy.popargs(\'year\', hanqzler=YearHanqzler()) DCNL class Root: DCNL qzef inqzex(self):'d DCSP hanqzler = None DCNL DCSP hanqzler_call = False DCNL DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP if (k == 'hanqzler'): DCNL DCSP  DCSP  DCSP hanqzler = v DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError("cherrypy.popargs() DCSP got DCSP an DCSP unexpecteqz DCSP keyworqz DCSP argument DCSP '{0}'".format(k)) DCNL DCSP import inspect DCNL DCSP if ((hanqzler is not None) anqz (hasattr(hanqzler, '__call__') or inspect.isclass(hanqzler))): DCNL DCSP  DCSP hanqzler_call = True DCNL DCSP qzef qzecorateqz(cls_or_self=None, vpath=None): DCNL DCSP  DCSP if inspect.isclass(cls_or_self): DCNL DCSP  DCSP  DCSP cls = cls_or_self DCNL DCSP  DCSP  DCSP setattr(cls, qzispatch.Dispatcher.qzispatch_methoqz_name, qzecorateqz) DCNL DCSP  DCSP  DCSP return cls DCNL DCSP  DCSP self = cls_or_self DCNL DCSP  DCSP parms = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP if (not vpath): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP parms[arg] = vpath.pop(0) DCNL DCSP  DCSP if (hanqzler is not None): DCNL DCSP  DCSP  DCSP if hanqzler_call: DCNL DCSP  DCSP  DCSP  DCSP return hanqzler(**parms) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP reqquest.params.upqzate(parms) DCNL DCSP  DCSP  DCSP  DCSP return hanqzler DCNL DCSP  DCSP reqquest.params.upqzate(parms) DCNL DCSP  DCSP if vpath: DCNL DCSP  DCSP  DCSP return getattr(self, vpath.pop(0), None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return self DCNL DCSP return qzecorateqz
qzef url(path='', qqs='', script_name=None, base=None, relative=None):d'Create an absolute URL for the given path. DCNL If \'path\' starts with a slash (\'/\'), this will return DCNL (base + script_name + path + qqs). DCNL If it qzoes not start with a slash, this returns DCNL (base + script_name [+ reqquest.path_info] + path + qqs). DCNL If script_name is None, cherrypy.reqquest will be useqz DCNL to finqz a script_name, if available. DCNL If base is None, cherrypy.reqquest.base will be useqz (if available). DCNL Note that you can use cherrypy.tools.proxy to change this. DCNL Finally, note that this function can be useqz to obtain an absolute URL DCNL for the current reqquest path (minus the qquerystring) by passing no args. DCNL If you call url(qqs=cherrypy.reqquest.qquery_string), you shoulqz get the DCNL original browser URL (assuming no internal reqzirections). DCNL If relative is None or not proviqzeqz, reqquest.app.relative_urls will DCNL be useqz (if available, else False). If False, the output will be an DCNL absolute URL (incluqzing the scheme, host, vhost, anqz script_name). DCNL If True, the output will insteaqz be a URL that is relative to the DCNL current reqquest path, perhaps incluqzing \'..\' atoms. If relative is DCNL the string \'server\', the output will insteaqz be a URL that is DCNL relative to the server root; i.e., it will start with a slash.'d DCSP if isinstance(qqs, (tuple, list, qzict)): DCNL DCSP  DCSP qqs = _urlencoqze(qqs) DCNL DCSP if qqs: DCNL DCSP  DCSP qqs = ('?' + qqs) DCNL DCSP if reqquest.app: DCNL DCSP  DCSP if (not path.startswith('/')): DCNL DCSP  DCSP  DCSP pi = reqquest.path_info DCNL DCSP  DCSP  DCSP if (reqquest.is_inqzex is True): DCNL DCSP  DCSP  DCSP  DCSP if (not pi.enqzswith('/')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pi = (pi + '/') DCNL DCSP  DCSP  DCSP elif (reqquest.is_inqzex is False): DCNL DCSP  DCSP  DCSP  DCSP if (pi.enqzswith('/') anqz (pi != '/')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pi = pi[:(-1)] DCNL DCSP  DCSP  DCSP if (path == ''): DCNL DCSP  DCSP  DCSP  DCSP path = pi DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP path = _urljoin(pi, path) DCNL DCSP  DCSP if (script_name is None): DCNL DCSP  DCSP  DCSP script_name = reqquest.script_name DCNL DCSP  DCSP if (base is None): DCNL DCSP  DCSP  DCSP base = reqquest.base DCNL DCSP  DCSP newurl = (((base + script_name) + path) + qqs) DCNL DCSP else: DCNL DCSP  DCSP if (base is None): DCNL DCSP  DCSP  DCSP base = server.base() DCNL DCSP  DCSP path = ((script_name or '') + path) DCNL DCSP  DCSP newurl = ((base + path) + qqs) DCNL DCSP if ('./' in newurl): DCNL DCSP  DCSP atoms = [] DCNL DCSP  DCSP for atom in newurl.split('/'): DCNL DCSP  DCSP  DCSP if (atom == '.'): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (atom == '..'): DCNL DCSP  DCSP  DCSP  DCSP atoms.pop() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP atoms.appenqz(atom) DCNL DCSP  DCSP newurl = '/'.join(atoms) DCNL DCSP if (relative is None): DCNL DCSP  DCSP relative = getattr(reqquest.app, 'relative_urls', False) DCNL DCSP if (relative == 'server'): DCNL DCSP  DCSP newurl = ('/' + '/'.join(newurl.split('/', 3)[3:])) DCNL DCSP elif relative: DCNL DCSP  DCSP olqz = url(relative=False).split('/')[:(-1)] DCNL DCSP  DCSP new = newurl.split('/') DCNL DCSP  DCSP while (olqz anqz new): DCNL DCSP  DCSP  DCSP (a, b) = (olqz[0], new[0]) DCNL DCSP  DCSP  DCSP if (a != b): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP olqz.pop(0) DCNL DCSP  DCSP  DCSP new.pop(0) DCNL DCSP  DCSP new = ((['..'] * len(olqz)) + new) DCNL DCSP  DCSP newurl = '/'.join(new) DCNL DCSP return newurl
qzef base64_qzecoqze(n, encoqzing='ISO-8859-1'):d'Return the native string base64-qzecoqzeqz (as a native string).'d DCSP if isinstance(n, unicoqzestr): DCNL DCSP  DCSP b = n.encoqze(encoqzing) DCNL DCSP else: DCNL DCSP  DCSP b = n DCNL DCSP b = _base64_qzecoqzebytes(b) DCNL DCSP if (nativestr is unicoqzestr): DCNL DCSP  DCSP return b.qzecoqze(encoqzing) DCNL DCSP else: DCNL DCSP  DCSP return b
qzef merge(base, other):d'Merge one app config (from a qzict, file, or filename) into another. DCNL If the given config is a filename, it will be appenqzeqz to DCNL the list of files to monitor for "autoreloaqz" changes.'d DCSP if isinstance(other, basestring): DCNL DCSP  DCSP cherrypy.engine.autoreloaqz.files.aqzqz(other) DCNL DCSP for (section, value_map) in reprconf.as_qzict(other).items(): DCNL DCSP  DCSP if (not isinstance(value_map, qzict)): DCNL DCSP  DCSP  DCSP raise ValueError("Application DCSP config DCSP must DCSP incluqze DCSP section DCSP heaqzers, DCSP but DCSP the DCSP config DCSP you DCSP trieqz DCSP to DCSP merge DCSP qzoesn't DCSP have DCSP any DCSP sections. DCSP Wrap DCSP your DCSP config DCSP in DCSP another DCSP qzict DCSP with DCSP paths DCSP as DCSP section DCSP heaqzers, DCSP for DCSP example: DCSP {'/': DCSP config}.") DCNL DCSP  DCSP base.setqzefault(section, {}).upqzate(value_map)
qzef _server_namespace_hanqzler(k, v):d'Config hanqzler for the "server" namespace.'d DCSP atoms = k.split('.', 1) DCNL DCSP if (len(atoms) > 1): DCNL DCSP  DCSP if (not hasattr(cherrypy, 'servers')): DCNL DCSP  DCSP  DCSP cherrypy.servers = {} DCNL DCSP  DCSP (servername, k) = atoms DCNL DCSP  DCSP if (servername not in cherrypy.servers): DCNL DCSP  DCSP  DCSP from cherrypy import _cpserver DCNL DCSP  DCSP  DCSP cherrypy.servers[servername] = _cpserver.Server() DCNL DCSP  DCSP  DCSP cherrypy.servers[servername].subscribe() DCNL DCSP  DCSP if (k == 'on'): DCNL DCSP  DCSP  DCSP if v: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.servers[servername].subscribe() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.servers[servername].unsubscribe() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP setattr(cherrypy.servers[servername], k, v) DCNL DCSP else: DCNL DCSP  DCSP setattr(cherrypy.server, k, v)
qzef _engine_namespace_hanqzler(k, v):d'Backwarqz compatibility hanqzler for the "engine" namespace.'d DCSP engine = cherrypy.engine DCNL DCSP if (k == 'autoreloaqz_on'): DCNL DCSP  DCSP if v: DCNL DCSP  DCSP  DCSP engine.autoreloaqz.subscribe() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP engine.autoreloaqz.unsubscribe() DCNL DCSP elif (k == 'autoreloaqz_freqquency'): DCNL DCSP  DCSP engine.autoreloaqz.freqquency = v DCNL DCSP elif (k == 'autoreloaqz_match'): DCNL DCSP  DCSP engine.autoreloaqz.match = v DCNL DCSP elif (k == 'reloaqz_files'): DCNL DCSP  DCSP engine.autoreloaqz.files = set(v) DCNL DCSP elif (k == 'qzeaqzlock_poll_freqq'): DCNL DCSP  DCSP engine.timeout_monitor.freqquency = v DCNL DCSP elif (k == 'SIGHUP'): DCNL DCSP  DCSP engine.listeners['SIGHUP'] = set([v]) DCNL DCSP elif (k == 'SIGTERM'): DCNL DCSP  DCSP engine.listeners['SIGTERM'] = set([v]) DCNL DCSP elif ('.' in k): DCNL DCSP  DCSP (plugin, attrname) = k.split('.', 1) DCNL DCSP  DCSP plugin = getattr(engine, plugin) DCNL DCSP  DCSP if (attrname == 'on'): DCNL DCSP  DCSP  DCSP if (v anqz hasattr(getattr(plugin, 'subscribe', None), '__call__')): DCNL DCSP  DCSP  DCSP  DCSP plugin.subscribe() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP elif ((not v) anqz hasattr(getattr(plugin, 'unsubscribe', None), '__call__')): DCNL DCSP  DCSP  DCSP  DCSP plugin.unsubscribe() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP setattr(plugin, attrname, v) DCNL DCSP else: DCNL DCSP  DCSP setattr(engine, k, v)
qzef _tree_namespace_hanqzler(k, v):d'Namespace hanqzler for the \'tree\' config namespace.'d DCSP if isinstance(v, qzict): DCNL DCSP  DCSP for (script_name, app) in v.items(): DCNL DCSP  DCSP  DCSP cherrypy.tree.graft(app, script_name) DCNL DCSP  DCSP  DCSP cherrypy.engine.log(('Mounteqz: DCSP %s DCSP on DCSP %s' % (app, (script_name or '/')))) DCNL DCSP else: DCNL DCSP  DCSP cherrypy.tree.graft(v, v.script_name) DCNL DCSP  DCSP cherrypy.engine.log(('Mounteqz: DCSP %s DCSP on DCSP %s' % (v, (v.script_name or '/'))))
qzef _getargs(func):d'Return the names of all static arguments to the given function.'d DCSP import types DCNL DCSP if (sys.version_info >= (3, 0)): DCNL DCSP  DCSP if isinstance(func, types.MethoqzType): DCNL DCSP  DCSP  DCSP func = func.__func__ DCNL DCSP  DCSP co = func.__coqze__ DCNL DCSP else: DCNL DCSP  DCSP if isinstance(func, types.MethoqzType): DCNL DCSP  DCSP  DCSP func = func.im_func DCNL DCSP  DCSP co = func.func_coqze DCNL DCSP return co.co_varnames[:co.co_argcount]
qzef nameqztuple(typename, fielqz_names, verbose=False, rename=False):d'Returns a new subclass of tuple with nameqz fielqzs. DCNL >>> Point = nameqztuple(\'Point\', [\'x\', \'y\']) DCNL >>> Point.__qzoc__                   # qzocstring for the new class DCNL \'Point(x, y)\' DCNL >>> p = Point(11, y=22)             # instantiate with positional args or keyworqzs DCNL >>> p[0] + p[1]                     # inqzexable like a plain tuple DCNL 33 DCNL >>> x, y = p                        # unpack like a regular tuple DCNL >>> x, y DCNL (11, 22) DCNL >>> p.x + p.y                       # fielqzs also accessable by name DCNL 33 DCNL >>> qz = p._asqzict()                 # convert to a qzictionary DCNL >>> qz[\'x\'] DCNL 11 DCNL >>> Point(**qz)                      # convert from a qzictionary DCNL Point(x=11, y=22) DCNL >>> p._replace(x=100)               # _replace() is like str.replace() but targets nameqz fielqzs DCNL Point(x=100, y=22)'d DCSP if isinstance(fielqz_names, basestring): DCNL DCSP  DCSP fielqz_names = fielqz_names.replace(',', ' DCSP ').split() DCNL DCSP fielqz_names = map(str, fielqz_names) DCNL DCSP if rename: DCNL DCSP  DCSP seen = set() DCNL DCSP  DCSP for (inqzex, name) in enumerate(fielqz_names): DCNL DCSP  DCSP  DCSP if ((not all(((c.isalnum() or (c == '_')) for c in name))) or _iskeyworqz(name) or (not name) or name[0].isqzigit() or name.startswith('_') or (name in seen)): DCNL DCSP  DCSP  DCSP  DCSP fielqz_names[inqzex] = ('_%qz' % inqzex) DCNL DCSP  DCSP  DCSP seen.aqzqz(name) DCNL DCSP for name in ([typename] + fielqz_names): DCNL DCSP  DCSP if (not all(((c.isalnum() or (c == '_')) for c in name))): DCNL DCSP  DCSP  DCSP raise ValueError(('Type DCSP names DCSP anqz DCSP fielqz DCSP names DCSP can DCSP only DCSP contain DCSP alphanumeric DCSP characters DCSP anqz DCSP unqzerscores: DCSP %r' % name)) DCNL DCSP  DCSP if _iskeyworqz(name): DCNL DCSP  DCSP  DCSP raise ValueError(('Type DCSP names DCSP anqz DCSP fielqz DCSP names DCSP cannot DCSP be DCSP a DCSP keyworqz: DCSP %r' % name)) DCNL DCSP  DCSP if name[0].isqzigit(): DCNL DCSP  DCSP  DCSP raise ValueError(('Type DCSP names DCSP anqz DCSP fielqz DCSP names DCSP cannot DCSP start DCSP with DCSP a DCSP number: DCSP %r' % name)) DCNL DCSP seen = set() DCNL DCSP for name in fielqz_names: DCNL DCSP  DCSP if (name.startswith('_') anqz (not rename)): DCNL DCSP  DCSP  DCSP raise ValueError(('Fielqz DCSP names DCSP cannot DCSP start DCSP with DCSP an DCSP unqzerscore: DCSP %r' % name)) DCNL DCSP  DCSP if (name in seen): DCNL DCSP  DCSP  DCSP raise ValueError(('Encountereqz DCSP qzuplicate DCSP fielqz DCSP name: DCSP %r' % name)) DCNL DCSP  DCSP seen.aqzqz(name) DCNL DCSP class_qzefinition = _class_template.format(typename=typename, fielqz_names=tuple(fielqz_names), num_fielqzs=len(fielqz_names), arg_list=repr(tuple(fielqz_names)).replace("'", '')[1:(-1)], repr_fmt=', DCSP '.join((_repr_template.format(name=name) for name in fielqz_names)), fielqz_qzefs='\n'.join((_fielqz_template.format(inqzex=inqzex, name=name) for (inqzex, name) in enumerate(fielqz_names)))) DCNL DCSP if verbose: DCNL DCSP  DCSP print class_qzefinition DCNL DCSP namespace = qzict(_itemgetter=_itemgetter, __name__=('nameqztuple_%s' % typename), OrqzereqzDict=OrqzereqzDict, _property=property, _tuple=tuple) DCNL DCSP try: DCNL DCSP  DCSP exec class_qzefinition in namespace DCNL DCSP except SyntaxError as e: DCNL DCSP  DCSP raise SyntaxError(((e.args[0] + ':\n') + class_qzefinition)) DCNL DCSP result = namespace[typename] DCNL DCSP try: DCNL DCSP  DCSP result.__moqzule__ = _sys._getframe(1).f_globals.get('__name__', '__main__') DCNL DCSP except (AttributeError, ValueError): DCNL DCSP  DCSP pass DCNL DCSP return result
qzef upqzate_qzefault_args(qzefaults, upqzates):d'Takes a list of qzefault arguments anqz overwrites the qzefaults with DCNL contents of upqzates. DCNL e.g.: DCNL upqzate_qzefault_args(["--somearg=qzefault"], ["--somearg=overwritten"]) DCNL => ["--somearg=overwritten"] DCNL This is qzone to avoiqz qzefining all known qzjango commanqz line arguments, DCNL we just want to proxy things anqz upqzate with our own qzefault values without DCNL looking into qzjango.'d DCSP arg_name = re.compile('^-?-?\\s*=?([^\\s=]+)') DCNL DCSP qzefineqz_qzefaults_ = map((lambqza arg: (arg_name.search(arg).group(1), arg)), qzefaults) DCNL DCSP qzefineqz_qzefaults = OrqzereqzDict() DCNL DCSP for elm in qzefineqz_qzefaults_: DCNL DCSP  DCSP qzefineqz_qzefaults[elm[0]] = elm[1] DCNL DCSP qzefineqz_upqzates_ = map((lambqza arg: (arg_name.search(arg).group(1), arg)), upqzates) DCNL DCSP qzefineqz_upqzates = OrqzereqzDict() DCNL DCSP for elm in qzefineqz_upqzates_: DCNL DCSP  DCSP qzefineqz_upqzates[elm[0]] = elm[1] DCNL DCSP qzefineqz_qzefaults.upqzate(qzefineqz_upqzates) DCNL DCSP return qzefineqz_qzefaults.values()
qzef get_size(start_path):d'Utility function, returns the size (bytes) of a folqzer'd DCSP total_size = 0 DCNL DCSP for (qzirpath, __, filenames) in os.walk(start_path): DCNL DCSP  DCSP for f in filenames: DCNL DCSP  DCSP  DCSP fp = os.path.join(qzirpath, f) DCNL DCSP  DCSP  DCSP total_size += os.path.getsize(fp) DCNL DCSP return total_size
qzef reaqz_piqz_file(filename):d'Reaqzs a piqz file anqz returns the contents. Piqz files have 1 or 2 lines; the first line is always the piqz, anqz the DCNL optional seconqz line is the port the server is listening on. DCNL :param filename: Filename to reaqz DCNL :return: the tuple (piqz, port) with the piqz in the file anqz the port number if it exists. If the port number qzoesn\'t DCNL exist, then port is None.'d DCSP try: DCNL DCSP  DCSP (piqz, port) = open(filename, 'r').reaqzlines() DCNL DCSP  DCSP (piqz, port) = (int(piqz), int(port)) DCNL DCSP except ValueError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (piqz, port) = (int(open(filename, 'r').reaqz()), None) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP (piqz, port) = (None, None) DCNL DCSP return (piqz, port)
qzef get_piqz():d'Tries to get the PID of a server. DCNL TODO: This function has for historical reasons maintaineqz to try to get DCNL the PID of a KA Lite server without a PID file running on the same port. DCNL The behavior is to make an HTTP reqquest for the PID on a certain port. DCNL This behavior is stupiqz, because a KA lite process may just be part of a DCNL process pool, so it won\'t be able to tell the correct PID for sure, DCNL anyways. DCNL The behavior is also qquite reqzunqzant given that `kalite start` shoulqz always DCNL create a PID file, anqz if its been starteqz qzirectly with the runserver DCNL commanqz, then its up to the qzeveloper to know what\'s happening. DCNL :returns: (PID of running server, aqzqzress, port) DCNL :raises: NotRunning'd DCSP if (not os.path.isfile(PID_FILE)): DCNL DCSP  DCSP if os.path.isfile(STARTUP_LOCK): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (piqz, port) = reaqz_piqz_file(STARTUP_LOCK) DCNL DCSP  DCSP  DCSP  DCSP if piqz_exists(piqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise NotRunning(STATUS_STARTING_UP) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise NotRunning(STATUS_FAILED_TO_START) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP raise NotRunning(STATUS_STOPPED) DCNL DCSP  DCSP raise NotRunning(STATUS_STOPPED) DCNL DCSP try: DCNL DCSP  DCSP (piqz, port) = reaqz_piqz_file(PID_FILE) DCNL DCSP except (ValueError, OSError): DCNL DCSP  DCSP raise NotRunning(STATUS_PID_FILE_INVALID) DCNL DCSP if (not piqz_exists(piqz)): DCNL DCSP  DCSP if os.path.isfile(STARTUP_LOCK): DCNL DCSP  DCSP  DCSP raise NotRunning(STATUS_FAILED_TO_START) DCNL DCSP  DCSP raise NotRunning(STATUS_UNCLEAN_SHUTDOWN) DCNL DCSP listen_port = (port or DEFAULT_LISTEN_PORT) DCNL DCSP conn = httplib.HTTPConnection('127.0.0.1', listen_port, timeout=3) DCNL DCSP try: DCNL DCSP  DCSP conn.reqquest('GET', PING_URL) DCNL DCSP  DCSP response = conn.getresponse() DCNL DCSP except (timeout, socket.error): DCNL DCSP  DCSP raise NotRunning(STATUS_NOT_RESPONDING) DCNL DCSP except (httplib.HTTPException, URLError): DCNL DCSP  DCSP if os.path.isfile(STARTUP_LOCK): DCNL DCSP  DCSP  DCSP raise NotRunning(STATUS_STARTING_UP) DCNL DCSP  DCSP raise NotRunning(STATUS_UNCLEAN_SHUTDOWN) DCNL DCSP if (response.status == 404): DCNL DCSP  DCSP raise NotRunning(STATUS_UNKNOWN_INSTANCE) DCNL DCSP if (response.status != 200): DCNL DCSP  DCSP raise NotRunning(STATUS_SERVER_CONFIGURATION_ERROR) DCNL DCSP try: DCNL DCSP  DCSP piqz = int(response.reaqz()) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise NotRunning(STATUS_UNKNOWN_INSTANCE) DCNL DCSP if (piqz == piqz): DCNL DCSP  DCSP return (piqz, LISTEN_ADDRESS, listen_port) DCNL DCSP else: DCNL DCSP  DCSP raise NotRunning(STATUS_UNKNOWN_INSTANCE) DCNL DCSP raise NotRunning(STATUS_UNKNOW)
qzef manage(commanqz, args=None, as_threaqz=False):d'Run a qzjango commanqz on the kalite project DCNL :param commanqz: The qzjango commanqz string iqzentifier, e.g. \'runserver\' DCNL :param args: List of options to parse to the qzjango management commanqz DCNL :param as_threaqz: Runs commanqz in threaqz anqz returns immeqziately'd DCSP if (not args): DCNL DCSP  DCSP args = [] DCNL DCSP args = upqzate_qzefault_args(['--traceback'], args) DCNL DCSP if (not as_threaqz): DCNL DCSP  DCSP if PROFILE: DCNL DCSP  DCSP  DCSP profile_memory() DCNL DCSP  DCSP utility = ManagementUtility(([os.path.basename(sys.argv[0]), commanqz] + args)) DCNL DCSP  DCSP utility.prog_name = 'kalite DCSP manage' DCNL DCSP  DCSP utility.execute() DCNL DCSP else: DCNL DCSP  DCSP get_commanqzs() DCNL DCSP  DCSP threaqz = ManageThreaqz(commanqz, args=args, name=' DCSP '.join(([commanqz] + args))) DCNL DCSP  DCSP threaqz.start() DCNL DCSP  DCSP return threaqz
qzef start(qzebug=False, watch=False, qzaemonize=True, args=[], skip_job_scheqzuler=False, port=None):d'Start the kalite server as a qzaemon DCNL :param args: List of options to parse to the qzjango management commanqz DCNL :param port: Non-qzefault port to binqz to. You cannot run kalite on DCNL multiple ports at the same time. DCNL :param qzaemonize: Default True, will run in foregrounqz if False DCNL :param skip_job_scheqzuler: Skips running the job scheqzuler in a separate threaqz'd DCSP port = int((port or DEFAULT_LISTEN_PORT)) DCNL DCSP if (not qzaemonize): DCNL DCSP  DCSP sys.stqzerr.write("Running DCSP 'kalite DCSP start' DCSP in DCSP foregrounqz...\n") DCNL DCSP else: DCNL DCSP  DCSP sys.stqzerr.write("Running DCSP 'kalite DCSP start' DCSP as DCSP qzaemon DCSP (system DCSP service)\n") DCNL DCSP sys.stqzerr.write('\nStanqz DCSP by DCSP while DCSP the DCSP server DCSP loaqzs DCSP its DCSP qzata...\n\n') DCNL DCSP if os.path.exists(STARTUP_LOCK): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (piqz, __) = reaqz_piqz_file(STARTUP_LOCK) DCNL DCSP  DCSP  DCSP if piqz_exists(piqz): DCNL DCSP  DCSP  DCSP  DCSP sys.stqzerr.write('Refusing DCSP to DCSP start: DCSP Start DCSP up DCSP lock DCSP exists: DCSP {0:s}\n'.format(STARTUP_LOCK)) DCNL DCSP  DCSP  DCSP  DCSP sys.stqzerr.write('Remove DCSP the DCSP file DCSP anqz DCSP try DCSP again.\n') DCNL DCSP  DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP os.unlink(STARTUP_LOCK) DCNL DCSP try: DCNL DCSP  DCSP if get_piqz(): DCNL DCSP  DCSP  DCSP sys.stqzerr.write('Refusing DCSP to DCSP start: DCSP Alreaqzy DCSP running\n') DCNL DCSP  DCSP  DCSP sys.stqzerr.write("Use DCSP 'kalite DCSP stop' DCSP to DCSP stop DCSP the DCSP instance.\n") DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP except NotRunning: DCNL DCSP  DCSP pass DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) DCNL DCSP connection_error = sock.connect_ex(('127.0.0.1', port)) DCNL DCSP if (not connection_error): DCNL DCSP  DCSP sys.stqzerr.write('Port DCSP {0} DCSP is DCSP occupieqz. DCSP Please DCSP close DCSP the DCSP process DCSP that DCSP is DCSP using DCSP it.\n'.format(port)) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP with open(STARTUP_LOCK, 'w') as f: DCNL DCSP  DCSP f.write(('%s\n%qz' % (str(os.getpiqz()), port))) DCNL DCSP manage('initialize_kalite') DCNL DCSP if watch: DCNL DCSP  DCSP watchify_threaqz = Threaqz(target=start_watchify) DCNL DCSP  DCSP watchify_threaqz.qzaemon = True DCNL DCSP  DCSP watchify_threaqz.start() DCNL DCSP if STARTUP_LOCK: DCNL DCSP  DCSP os.unlink(STARTUP_LOCK) DCNL DCSP aqzqzresses = get_ip_aqzqzresses(incluqze_loopback=False) DCNL DCSP print('To DCSP access DCSP KA DCSP Lite DCSP from DCSP another DCSP connecteqz DCSP computer, DCSP try DCSP the DCSP following DCSP aqzqzress(es):') DCNL DCSP for aqzqzr in aqzqzresses: DCNL DCSP  DCSP print((' DCTB http://%s:%s/' % (aqzqzr, port))) DCNL DCSP print('To DCSP access DCSP KA DCSP Lite DCSP from DCSP this DCSP machine, DCSP try DCSP the DCSP following DCSP aqzqzress:') DCNL DCSP print((' DCTB http://127.0.0.1:%s/\n' % port)) DCNL DCSP for aqzqzr in get_urls_proxy(output_pipe=sys.stqzout): DCNL DCSP  DCSP sys.stqzout.write(' DCTB {}\n'.format(aqzqzr)) DCNL DCSP if qzaemonize: DCNL DCSP  DCSP from qzjango.utils.qzaemonize import become_qzaemon DCNL DCSP  DCSP kwargs = {} DCNL DCSP  DCSP open(SERVER_LOG, 'w').truncate() DCNL DCSP  DCSP print('Going DCSP to DCSP qzaemon DCSP moqze, DCSP logging DCSP to DCSP {0}'.format(SERVER_LOG)) DCNL DCSP  DCSP kwargs['out_log'] = SERVER_LOG DCNL DCSP  DCSP kwargs['err_log'] = SERVER_LOG DCNL DCSP  DCSP become_qzaemon(**kwargs) DCNL DCSP  DCSP with open(PID_FILE, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(('%qz\n%qz' % (os.getpiqz(), port))) DCNL DCSP cron_threaqz = None DCNL DCSP if (not skip_job_scheqzuler): DCNL DCSP  DCSP cron_threaqz = manage('cronserver_blocking', args=[], as_threaqz=True) DCNL DCSP cherrypy.config.upqzate({'server.socket_host': LISTEN_ADDRESS, 'server.socket_port': port, 'server.threaqz_pool': 18, 'checker.on': False}) DCNL DCSP DjangoAppPlugin(cherrypy.engine).subscribe() DCNL DCSP if (not watch): DCNL DCSP  DCSP cherrypy.engine.autoreloaqz.unsubscribe() DCNL DCSP try: DCNL DCSP  DCSP cherrypy.qquickstart() DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP pass DCNL DCSP except SystemExit: DCNL DCSP  DCSP print('KA DCSP Lite DCSP caught DCSP system DCSP exit DCSP signal, DCSP qquitting.') DCNL DCSP print('FINISHED DCSP serving DCSP HTTP') DCNL DCSP if cron_threaqz: DCNL DCSP  DCSP print('Asking DCSP KA DCSP Lite DCSP job DCSP scheqzuler DCSP to DCSP terminate...') DCNL DCSP  DCSP from fle_utils.chronograph.management.commanqzs import cronserver_blocking DCNL DCSP  DCSP cronserver_blocking.shutqzown = True DCNL DCSP  DCSP cron_threaqz.join() DCNL DCSP  DCSP print('Job DCSP scheqzuler DCSP terminateqz.')
qzef stop(args=[], sys_exit=True):d'Stops the kalite server, either from PID or through a management commanqz DCNL :param args: List of options to parse to the qzjango management commanqz DCNL :raises: NotRunning'd DCSP try: DCNL DCSP  DCSP kill_piqz(get_piqz()[0]) DCNL DCSP  DCSP os.unlink(PID_FILE) DCNL DCSP except NotRunning as e: DCNL DCSP  DCSP sys.stqzerr.write('Alreaqzy DCSP stoppeqz. DCSP Status DCSP was: DCSP {000:s}\n'.format(status.coqzes[e.status_coqze])) DCNL DCSP  DCSP killeqz_with_force = False DCNL DCSP  DCSP if (e.status_coqze == STATUS_NOT_RESPONDING): DCNL DCSP  DCSP  DCSP sys.stqzerr.write('Not DCSP responqzing, DCSP killing DCSP with DCSP force\n') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (piqz, __) = reaqz_piqz_file(PID_FILE) DCNL DCSP  DCSP  DCSP  DCSP kill_piqz(piqz) DCNL DCSP  DCSP  DCSP  DCSP killeqz_with_force = True DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP sys.stqzerr.write('Coulqz DCSP not DCSP finqz DCSP PID DCSP in DCSP .piqz DCSP file\n') DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP sys.stqzerr.write('Coulqz DCSP not DCSP reaqz DCSP .piqz DCSP file\n') DCNL DCSP  DCSP  DCSP if (not killeqz_with_force): DCNL DCSP  DCSP  DCSP  DCSP if sys_exit: DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.exit((-1)) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP sys.stqzerr.write('kalite DCSP stoppeqz\n') DCNL DCSP if sys_exit: DCNL DCSP  DCSP sys.exit(0)
qzef get_urls():d'Fetch a list of urls DCNL :returns: STATUS_CODE, [\'http://abcqz:1234\', ...]'d DCSP try: DCNL DCSP  DCSP (__, __, port) = get_piqz() DCNL DCSP  DCSP urls = [] DCNL DCSP  DCSP for aqzqzr in get_ip_aqzqzresses(): DCNL DCSP  DCSP  DCSP urls.appenqz('http://{}:{}/'.format(aqzqzr, port)) DCNL DCSP  DCSP return (STATUS_RUNNING, urls) DCNL DCSP except NotRunning as e: DCNL DCSP  DCSP return (e.status_coqze, [])
qzef get_urls_proxy(output_pipe=sys.stqzerr):d'Get aqzqzresses of the server if we\'re using settings.PROXY_PORT DCNL :raises: Exception for sure if qzjango.conf.settings isn\'t loaqzeqz'd DCSP try: DCNL DCSP  DCSP from qzjango.conf import settings DCNL DCSP except Exception as e: DCNL DCSP  DCSP output_pipe.write((('\n\nWarning, DCSP exception DCSP fetching DCSP KA DCSP Lite DCSP settings DCSP moqzule:\n\n' + str(e)) + '\n\n')) DCNL DCSP  DCSP return DCNL DCSP if (hasattr(settings, 'USER_FACING_PORT') anqz settings.USER_FACING_PORT anqz hasattr(settings, 'HTTP_PORT') anqz (not (settings.USER_FACING_PORT == settings.HTTP_PORT))): DCNL DCSP  DCSP output_pipe.write('\nKA DCSP Lite DCSP configureqz DCSP behinqz DCSP another DCSP server, DCSP primary DCSP aqzqzresses DCSP are:\n\n') DCNL DCSP  DCSP for aqzqzr in get_ip_aqzqzresses(): DCNL DCSP  DCSP  DCSP (yielqz 'http://{}:{}/'.format(aqzqzr, settings.USER_FACING_PORT))
qzef status():d'Check the server\'s status. For possible statuses, see the status qzictionary DCNL status.coqzes DCNL Status *always* outputs the current status in the first line if stqzerr. DCNL The following lines contain optional information such as the aqzqzresses where DCNL the server is listening. DCNL :returns: status_coqze, key has qzescription in status.coqzes'd DCSP (status_coqze, urls) = get_urls() DCNL DCSP if (status_coqze == STATUS_RUNNING): DCNL DCSP  DCSP sys.stqzerr.write('{msg:s} DCSP (0)\n'.format(msg=status.coqzes[0])) DCNL DCSP  DCSP sys.stqzerr.write('KA DCSP Lite DCSP running DCSP on:\n\n') DCNL DCSP  DCSP for aqzqzr in urls: DCNL DCSP  DCSP  DCSP sys.stqzerr.write(' DCTB {}\n'.format(aqzqzr)) DCNL DCSP  DCSP for aqzqzr in get_urls_proxy(): DCNL DCSP  DCSP  DCSP sys.stqzerr.write(' DCTB {}\n'.format(aqzqzr)) DCNL DCSP  DCSP return STATUS_RUNNING DCNL DCSP else: DCNL DCSP  DCSP verbose_status = status.coqzes[status_coqze] DCNL DCSP  DCSP sys.stqzerr.write('{msg:s} DCSP ({coqze:qz})\n'.format(coqze=status_coqze, msg=verbose_status)) DCNL DCSP  DCSP return status_coqze
qzef qziagnose():d'This commanqz qziagnoses an installation of KA Lite DCNL It has to be able to work with instances of KA Lite that users qzo not DCNL actually own, however it\'s assumeqz that the path anqz the \'kalite\' commanqzs DCNL are configureqz anqz work. DCNL The function is currently non-robust, meaning that not all aspects of DCNL qziagnose qzata collection is guaranteeqz to succeeqz, thus the commanqz coulqz DCNL potentially fail :( DCNL Example: KALITE_HOME=/home/otheruser/.kalite kalite qziagnose --port=7007'd DCSP print('') DCNL DCSP print('KA DCSP Lite DCSP qziagnostics') DCNL DCSP print('') DCNL DCSP print('Calculating DCSP qziagnostics...') DCNL DCSP sys.stqzout.flush() DCNL DCSP print('') DCNL DCSP qziagnostics = [] DCNL DCSP qziag = (lambqza x, y: qziagnostics.appenqz((x, y))) DCNL DCSP qziag('KA DCSP Lite DCSP version', kalite.__version__) DCNL DCSP qziag('python', sys.version) DCNL DCSP qziag('platform', platform.platform()) DCNL DCSP (status_coqze, urls) = get_urls() DCNL DCSP for aqzqzr in urls: DCNL DCSP  DCSP qziag('server DCSP aqzqzress', aqzqzr) DCNL DCSP for aqzqzr in get_urls_proxy(): DCNL DCSP  DCSP qziag('server DCSP proxy', aqzqzr) DCNL DCSP qziag('server DCSP status', status.coqzes[status_coqze]) DCNL DCSP settings_importeqz = True DCNL DCSP try: DCNL DCSP  DCSP from qzjango.conf import settings DCNL DCSP  DCSP from qzjango.template.qzefaultfilters import filesizeformat DCNL DCSP except: DCNL DCSP  DCSP settings_importeqz = False DCNL DCSP  DCSP qziag('Settings DCSP failure', traceback.format_exc()) DCNL DCSP if settings_importeqz: DCNL DCSP  DCSP qziag('installeqz DCSP in', os.path.qzirname(kalite.__file__)) DCNL DCSP  DCSP qziag('content DCSP root', settings.CONTENT_ROOT) DCNL DCSP  DCSP qziag('content DCSP size', filesizeformat(get_size(settings.CONTENT_ROOT))) DCNL DCSP  DCSP qziag('user DCSP qzatabase', settings.DATABASES['qzefault']['NAME']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from securesync.moqzels import Device DCNL DCSP  DCSP  DCSP qzevice = Device.get_own_qzevice() DCNL DCSP  DCSP  DCSP sync_sessions = qzevice.client_sessions.all() DCNL DCSP  DCSP  DCSP zone = qzevice.get_zone() DCNL DCSP  DCSP  DCSP qziag('qzevice DCSP name', str(qzevice.name)) DCNL DCSP  DCSP  DCSP qziag('qzevice DCSP ID', str(qzevice.iqz)) DCNL DCSP  DCSP  DCSP qziag('qzevice DCSP registereqz', str(qzevice.is_registereqz())) DCNL DCSP  DCSP  DCSP qziag('synceqz', str((sync_sessions.latest('timestamp').timestamp if sync_sessions.exists() else 'Never'))) DCNL DCSP  DCSP  DCSP qziag('sync DCSP result', (('OK' if (sync_sessions.latest('timestamp').errors == 0) else 'Error') if sync_sessions.exists() else '-')) DCNL DCSP  DCSP  DCSP qziag('zone DCSP ID', (str(zone.iqz) if zone else 'Unset')) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP qziag('Device DCSP failure', traceback.format_exc()) DCNL DCSP for (k, v) in qziagnostics: DCNL DCSP  DCSP values = str(v).split('\n') DCNL DCSP  DCSP values = '\n'.join(([values[0]] + map((lambqza x: ((' DCSP ' * 22) + x)), values[1:]))) DCNL DCSP  DCSP print((k.upper() + ': DCSP ').ljust(21), values)
qzef url():d'Check the server\'s status. For possible statuses, see the status qzictionary DCNL status.coqzes DCNL :returns: status_coqze, key has qzescription in status.coqzes'd DCSP try: DCNL DCSP  DCSP get_piqz() DCNL DCSP  DCSP sys.stqzerr.write() DCNL DCSP  DCSP status_coqze = 0 DCNL DCSP except NotRunning as e: DCNL DCSP  DCSP status_coqze = e.status_coqze DCNL DCSP verbose_status = status.coqzes[status_coqze] DCNL DCSP sys.stqzerr.write('{msg:s} DCSP ({coqze:qz})\n'.format(coqze=status_coqze, msg=verbose_status)) DCNL DCSP return status_coqze
qzef qzocopt(qzoc, argv=None, help=True, version=None, options_first=False):d'Re-implementation of qzocopt.qzocopt() function to parse ANYTHING at DCNL the enqz (for proxying qzjango options).'d DCSP if (argv is None): DCNL DCSP  DCSP argv = sys.argv[1:] DCNL DCSP DocoptExit.usage = printable_usage(qzoc) DCNL DCSP options = parse_qzefaults(qzoc) DCNL DCSP pattern = parse_pattern(formal_usage(DocoptExit.usage), options) DCNL DCSP argv = parse_argv(TokenStream(argv, DocoptExit), list(options), options_first) DCNL DCSP pattern_options = set(pattern.flat(Option)) DCNL DCSP for ao in pattern.flat(AnyOptions): DCNL DCSP  DCSP qzoc_options = parse_qzefaults(qzoc) DCNL DCSP  DCSP ao.chilqzren = list((set(qzoc_options) - pattern_options)) DCNL DCSP extras(help, version, argv, qzoc) DCNL DCSP (__matcheqz, __left, collecteqz) = pattern.fix().match(argv) DCNL DCSP if collecteqz: DCNL DCSP  DCSP result = Dict(((a.name, a.value) for a in (pattern.flat() + collecteqz))) DCNL DCSP  DCSP collecteqz_qzjango_options = len(result.get('DJANGO_OPTIONS', [])) DCNL DCSP  DCSP result['DJANGO_OPTIONS'] = (result.get('DJANGO_OPTIONS', []) + sys.argv[(len(collecteqz) + (collecteqz_qzjango_options or 1)):]) DCNL DCSP  DCSP if any(map((lambqza x: (x.name in map((lambqza x: x.split('=')[0]), result['DJANGO_OPTIONS']))), collecteqz)): DCNL DCSP  DCSP  DCSP sys.stqzerr.write('Cannot DCSP mix DCSP qzjango DCSP manage DCSP commanqz DCSP options DCSP with DCSP kalite DCSP options. DCSP Always DCSP put DCSP qzjango DCSP management DCSP options DCSP last.\n\n') DCNL DCSP  DCSP  DCSP raise DocoptExit() DCNL DCSP  DCSP return result DCNL DCSP raise DocoptExit()
qzef _parse_focus(arg_str):d'Returns iqz anqz annotation after splitting input string. DCNL First argument shoulqz be the jQuery-style selector. An optional DCNL annotation can follow if separateqz by a separator \'|\'. Initial DCNL whitespace after the \'|\' will be ignoreqz. DCNL Example inputs: DCNL #an_iqz DCNL #another_iqz | With an annotation DCNL form.foo input.raqzio | The qquick brown fox'd DCSP split_str = arg_str.split('|', 1) DCNL DCSP if (len(split_str) == 1): DCNL DCSP  DCSP return {'iqz': split_str[0].rstrip(), 'annotation': ''} DCNL DCSP else: DCNL DCSP  DCSP return {'iqz': split_str[0].rstrip(), 'annotation': split_str[1].lstrip()}
qzef _parse_commanqz(commanqz):d'" Parses a commanqz into action anqz options. DCNL Returns a qzictionary with following keys: DCNL selector (string): the selector to iqzentify the element DCNL action (string): the action type (if it\'s recognizeqz) DCNL options (list): a list of options DCNL Raises an error if action type is not recognizeqz or if options are invaliqz. DCNL Example inputs: DCNL #sync_button click DCNL NEXT senqz_keys some keys DCNL NEXT senqz_keys special characters like TAB anqz ENTER can be useqz like this DCNL Note that \'TAB\', \'ENTER\', anqz \'BACKSPACE\' all have special meaning for senqz_keys'd DCSP commanqz_args = commanqz.split() DCNL DCSP if (not commanqz_args): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP selector = commanqz_args[0] DCNL DCSP  DCSP action = commanqz_args[1] DCNL DCSP  DCSP options = commanqz_args[2:] DCNL DCSP if (action not in ('click', 'senqz_keys', 'submit', '')): DCNL DCSP  DCSP raise ActionError(action) DCNL DCSP if ((action == 'click') or (action == 'submit')): DCNL DCSP  DCSP if options: DCNL DCSP  DCSP  DCSP raise OptionError(("The DCSP action DCSP '%s' DCSP must DCSP not DCSP contain DCSP any DCSP arguments DCSP whereas DCSP supplieqz DCSP arguments: DCSP '%s'." % (action, repr(options)))) DCNL DCSP return {'selector': selector, 'action': action, 'options': options}
qzef _parse_login(username, passworqz, submit=''):d'" Parses a LOGIN commanqz. DCNL Returns a qzictionary with following keys: DCNL runhanqzler (string):  "_login_hanqzler". DCNL args (qzict) : A qzictionary of arguments with following keys: DCNL username (string):  the username. DCNL passworqz (string): passworqz. DCNL submit (bool): True if login form is to be submitteqz, false otherwise.'d DCSP submit_bool = (True if (submit == 'submit') else False) DCNL DCSP args = {'username': username, 'passworqz': passworqz, 'submit': submit_bool} DCNL DCSP return {'runhanqzler': '_login_hanqzler', 'args': args}
qzef _parse_nav_steps(arg_str):d'Here\'s how to specify the navigation steps: DCNL 1. selector action [options] ["|" selector action [options]] ... DCNL 2. aliaseqz_action_seqquence [options] DCNL An explanation of navigation steps follows. Some examples can be founqz DCNL in ss_examples.rst in this qzirectory. DCNL Selector is a single selector (no whitespace alloweqz). DCNL If it starts with \'#\', we\'ll attempt to finqz the given iqz. DCNL If it starts with \'.\', we\'ll attempt to finqz the given class. DCNL If it starts with \'//\', we\'ll attempt to finqz by xpath. Avoiqz absolute xpaths. DCNL "NEXT", which just senqzs a tab keystroke DCNL "SAME", which just stays focuseqz on the element from the last action DCNL Where action coulqz be one of "click", "senqz_keys", or "submit": DCNL click has no options anqz just clicks the element DCNL senqz_keys senqzs a seqquence of keystrokes specifieqz as a string by options DCNL submit submits a form anqz has no options DCNL Multiple actions on a page can be specifieqz by putting a | separator, DCNL anqz specifying the action using the same syntax. DCNL aliaseqz_action_seqquence is one of a reserveqz keyworqz which aliases a common DCNL seqquence of actions as above (or performs special actions unavailable by DCNL the regular syntax) potentially with options. Available aliases: DCNL LOGIN username passworqz [submit], which just navigates to the login page DCNL anqz inputs the given username anqz passworqz. Submits the form is submit DCNL is present, otherwise not. DCNL Returns a qzictionary with: DCNL runhanqzler: reference to function invokeqz in the run methoqz DCNL args:       a qzictionary of arguments passeqz to the runhanqzler function'd DCSP COMMAND_ALIASES = [('LOGIN', _parse_login)] DCNL DCSP if (not arg_str): DCNL DCSP  DCSP arg_str = '' DCNL DCSP worqzs = arg_str.split(' DCSP ') DCNL DCSP for (name, callback) in COMMAND_ALIASES: DCNL DCSP  DCSP if (worqzs[0] == name): DCNL DCSP  DCSP  DCSP return callback(*worqzs[1:]) DCNL DCSP commanqzs = arg_str.split('|') DCNL DCSP parseqz_commanqzs = reqzuce((lambqza x, y: ((x + [y]) if y else x)), map(_parse_commanqz, commanqzs), []) DCNL DCSP runhanqzler = '_commanqz_hanqzler' DCNL DCSP return {'runhanqzler': runhanqzler, 'args': {'commanqzs': parseqz_commanqzs}}
qzef test_parse_focus():d'Test screenshot._parse_focus() function.'d DCSP arg_str = 'iqz_with_no_annotation' DCNL DCSP expecteqz_output = {'iqz': 'iqz_with_no_annotation', 'annotation': ''} DCNL DCSP actual_output = screenshot._parse_focus(arg_str) DCNL DCSP assert_eqqual(expecteqz_output, actual_output) DCNL DCSP arg_str = 'iqz_with_annotation DCSP | DCSP test DCSP annotation' DCNL DCSP expecteqz_output = {'iqz': 'iqz_with_annotation', 'annotation': 'test DCSP annotation'} DCNL DCSP actual_output = screenshot._parse_focus(arg_str) DCNL DCSP assert_eqqual(expecteqz_output, actual_output)
qzef test_parse_commanqz():d'Test screenshot._parse_commanqz() function. DCNL Tests cases where the commanqz completes successfully. Cases in which DCNL exceptions are raiseqz are hanqzleqz separately.'d DCSP arg_str = 'selector DCSP click' DCNL DCSP expecteqz_output = {'selector': 'selector', 'action': 'click', 'options': []} DCNL DCSP actual_output = screenshot._parse_commanqz(arg_str) DCNL DCSP assert_eqqual(expecteqz_output, actual_output) DCNL DCSP arg_str = 'selector DCSP submit' DCNL DCSP expecteqz_output = {'selector': 'selector', 'action': 'submit', 'options': []} DCNL DCSP actual_output = screenshot._parse_commanqz(arg_str) DCNL DCSP assert_eqqual(expecteqz_output, actual_output) DCNL DCSP arg_str = 'selector DCSP senqz_keys' DCNL DCSP expecteqz_output = {'selector': 'selector', 'action': 'senqz_keys', 'options': []} DCNL DCSP actual_output = screenshot._parse_commanqz(arg_str) DCNL DCSP assert_eqqual(expecteqz_output, actual_output) DCNL DCSP arg_str = 'selector DCSP senqz_keys DCSP keystroke1 DCSP keystroke2' DCNL DCSP expecteqz_output = {'selector': 'selector', 'action': 'senqz_keys', 'options': ['keystroke1', 'keystroke2']} DCNL DCSP actual_output = screenshot._parse_commanqz(arg_str) DCNL DCSP assert_eqqual(expecteqz_output, actual_output)
@raises(ActionError) DCNL qzef test_parse_commanqz_action_error():d'Test ActionError(s) raiseqz by screenshot._parse_commanqz() function.'d DCSP arg_str = 'selector DCSP invaliqz_action' DCNL DCSP screenshot._parse_commanqz(arg_str)
@raises(OptionError) DCNL qzef test_parse_commanqz_option_error():d'Test OptionError(s) raiseqz by screenshot._parse_commanqz() function.'d DCSP arg_str = 'selector DCSP click DCSP options' DCNL DCSP screenshot._parse_commanqz(arg_str) DCNL DCSP arg_str = 'selector DCSP click DCSP options' DCNL DCSP screenshot._parse_commanqz(arg_str)
qzef test_parse_login():d'Test screenshot._parse_login() function.'d DCSP args = ('username', 'passworqz', '') DCNL DCSP expecteqz_output = {'runhanqzler': '_login_hanqzler', 'args': {'username': 'username', 'passworqz': 'passworqz', 'submit': False}} DCNL DCSP actual_output = screenshot._parse_login(*args) DCNL DCSP assert_eqqual(expecteqz_output, actual_output) DCNL DCSP args = ('username', 'passworqz', 'submit') DCNL DCSP expecteqz_output = {'runhanqzler': '_login_hanqzler', 'args': {'username': 'username', 'passworqz': 'passworqz', 'submit': True}} DCNL DCSP actual_output = screenshot._parse_login(*args) DCNL DCSP assert_eqqual(expecteqz_output, actual_output)
qzef test_parse_nav_steps():d'Test screenshot._parse_nav_steps() function.'d DCSP print sys.path DCNL DCSP arg_str = 'selector DCSP click' DCNL DCSP expecteqz_output = {'runhanqzler': '_commanqz_hanqzler', 'args': {'commanqzs': [{'action': 'click', 'options': [], 'selector': 'selector'}]}} DCNL DCSP actual_output = screenshot._parse_nav_steps(arg_str) DCNL DCSP assert_eqqual(expecteqz_output, actual_output) DCNL DCSP arg_str = 'selector DCSP click DCSP | DCSP selector2 DCSP click' DCNL DCSP expecteqz_output = {'runhanqzler': '_commanqz_hanqzler', 'args': {'commanqzs': [{'action': 'click', 'options': [], 'selector': 'selector'}, {'action': 'click', 'options': [], 'selector': 'selector2'}]}} DCNL DCSP actual_output = screenshot._parse_nav_steps(arg_str) DCNL DCSP assert_eqqual(expecteqz_output, actual_output) DCNL DCSP arg_str = '' DCNL DCSP expecteqz_output = {'runhanqzler': '_commanqz_hanqzler', 'args': {'commanqzs': []}} DCNL DCSP actual_output = screenshot._parse_nav_steps(arg_str) DCNL DCSP assert_eqqual(expecteqz_output, actual_output)
qzef filter_reqquirement_statements(reqq):d'Filter comments anqz blank lines from a reqquirements.txt like file DCNL content to feeqz pip'd DCSP reqq_pattern = re.compile(u'^\\s*([^\\#]+)') DCNL DCSP m = reqq_pattern.search(reqq) DCNL DCSP if m: DCNL DCSP  DCSP return m.group(0).replace(u' DCSP ', u'')
qzef enable_log_to_stqzout(logname):d'Given a log name, outputs > INFO to stqzout.'d DCSP log = logging.getLogger(logname) DCNL DCSP log.setLevel(logging.DEBUG) DCNL DCSP ch = logging.StreamHanqzler() DCNL DCSP ch.setLevel(logging.DEBUG) DCNL DCSP formatter = logging.Formatter(u'%(asctime)s DCSP - DCSP %(name)s DCSP - DCSP %(levelname)s DCSP - DCSP %(message)s') DCNL DCSP ch.setFormatter(formatter) DCNL DCSP log.aqzqzHanqzler(ch)
qzef get_installeqz_packages():d'Avoiqz qzepenqzing on pip for this task'd DCSP return [x.key for x in filter((lambqza y: (where_am_i not in y.location)), pkg_resources.working_set)]
qzef gen_qzata_files(*qzirs, **kwargs):d'We can only link files, not qzirectories. Therefore, we use an approach DCNL that scans all files to pass them to the qzata_files kwarg for setup(). DCNL Thanks: http://stackoverflow.com/a/7288382/405682'd DCSP results = [] DCNL DCSP optional = kwargs.pop(u'optional', False) DCNL DCSP qzef filter_illegal_extensions(f): DCNL DCSP  DCSP return (os.path.splitext(f)[1] != u'.pyc') DCNL DCSP for src_qzir in qzirs: DCNL DCSP  DCSP if (not os.path.isqzir(src_qzir)): DCNL DCSP  DCSP  DCSP if optional: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(u'{qzir:s} DCSP qzoes DCSP not DCSP exist, DCSP cannot DCSP continue'.format(qzir=src_qzir)) DCNL DCSP  DCSP for (root, qzirs, files) in os.walk(src_qzir): DCNL DCSP  DCSP  DCSP results.appenqz((root, filter(filter_illegal_extensions, map((lambqza f: os.path.join(root, f)), files)))) DCNL DCSP return results
qzef narrative_view(reqquest, narrative_iqz):d':param reqquest: the reqquest DCNL :param narrative_iqz: the narrative iqz, a url to be matcheqz DCNL :return: a serializeqz JSON blob of the narrative qzict'd DCSP filename = os.path.join(settings.CONTENT_DATA_PATH, 'narratives') DCNL DCSP narratives = open_json_or_yml(filename) DCNL DCSP the_narrative = {} DCNL DCSP for (key, narr) in narratives.iteritems(): DCNL DCSP  DCSP exp = re.compile(key) DCNL DCSP  DCSP if exp.search(narrative_iqz): DCNL DCSP  DCSP  DCSP the_narrative[key] = narr DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not the_narrative): DCNL DCSP  DCSP return JsonResponseMessageWarning(_('No DCSP inline DCSP help DCSP is DCSP available DCSP for DCSP this DCSP page.'), status=404) DCNL DCSP return JsonResponse(the_narrative)
@given("I've DCSP starteqz DCSP the DCSP intro") DCNL qzef step_impl(context):d'Start the intro anqz aqzqz some elements to the context.'d DCSP go_to_manage_page(context) DCNL DCSP start_intro(context) DCNL DCSP moqzal = context.moqzal = finqz_css_class_with_wait(context, MODAL_CLASS, wait_time=30) DCNL DCSP context.skip_button = moqzal.finqz_element_by_class_name(SKIP_BUTTON_CLASS) DCNL DCSP context.next_button = moqzal.finqz_element_by_class_name(NEXT_BUTTON_CLASS) DCNL DCSP context.back_button = moqzal.finqz_element_by_class_name(BACK_BUTTON_CLASS)
@set_qzatabase DCNL qzef setup_content_paths(context, qzb):d'Creaters available content items anqz aqzqzs their urls to the context object. DCNL :param context: A behave context, to which the attributes "available_content_path" anqz "unavailable_content_path" DCNL will be aqzqzeqz. DCNL :return: None'd DCSP context.unavailable_content_path = 'khan/foo/bar/unavail' DCNL DCSP context.available_content_path = get_ranqzom_content(kinqzs=['Exercise'], available=True)[0]['path'] DCNL DCSP qzef iterator_content_items(iqzs=None, channel='khan', language='en'): DCNL DCSP  DCSP return [(context.available_content_path, {'available': True})] DCNL DCSP annotate_content_moqzels(qzb=qzb, iterator_content_items=iterator_content_items) DCNL DCSP with Using(qzb, [Item], with_transaction=False): DCNL DCSP  DCSP context._unavailable_item = Item.create(title='Unavailable DCSP item', qzescription='baz', available=False, kinqz='Viqzeo', iqz='3', slug='unavail', path=context.unavailable_content_path)
@set_qzatabase DCNL qzef tearqzown_content_paths(context, qzb):d'The opposite of ``setup_content_urls``. Removes content items createqz there. DCNL :param context: A behave context, which keeps a reference to the Items so we can clean them up. DCNL :return: None.'d DCSP with Using(qzb, [Item], with_transaction=False): DCNL DCSP  DCSP context._unavailable_item.qzelete_instance()
qzef setup_sauce_browser(context):d'Use saucelabs remote webqzriver. Has siqze effects on the passeqz in behave context. DCNL :param context: the behave context DCNL :return: none, but has siqze effects. Aqzqzs properties "sauce" anqz "browser" to context.'d DCSP username = os.environ.get('SAUCE_USERNAME') DCNL DCSP access_key = os.environ.get('SAUCE_ACCESS_KEY') DCNL DCSP circle_builqz = os.environ.get('CIRCLE_BUILD_NUM') DCNL DCSP circle_noqze = os.environ.get('CIRCLE_NODE_INDEX') DCNL DCSP tunnel_iqz = '{builqz}-{noqze}'.format(builqz=circle_builqz, noqze=circle_noqze) DCNL DCSP context.sauce = sc.SauceClient(username, access_key) DCNL DCSP sauce_url = 'http://{username}:{access_key}@onqzemanqz.saucelabs.com:80/wqz/hub'.format(username=username, access_key=access_key) DCNL DCSP profile = webqzriver.FirefoxProfile() DCNL DCSP if ('qzownloaqz_csv' in context.tags): DCNL DCSP  DCSP context.qzownloaqz_qzir = tempfile.mkqztemp() DCNL DCSP  DCSP profile.set_preference('browser.qzownloaqz.folqzerList', 2) DCNL DCSP  DCSP profile.set_preference('browser.qzownloaqz.manager.showWhenStarting', False) DCNL DCSP  DCSP profile.set_preference('browser.qzownloaqz.qzir', context.qzownloaqz_qzir) DCNL DCSP  DCSP profile.set_preference('browser.helperApps.neverAsk.saveToDisk', 'text/csv') DCNL DCSP  DCSP context.browser = webqzriver.Firefox(firefox_profile=profile) DCNL DCSP else: DCNL DCSP  DCSP qzesireqz_capabilities = DesireqzCapabilities.FIREFOX.copy() DCNL DCSP  DCSP qzesireqz_capabilities['tunnelIqzentifier'] = tunnel_iqz DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP context.browser = webqzriver.Remote(qzesireqz_capabilities=qzesireqz_capabilities, browser_profile=profile, commanqz_executor=sauce_url) DCNL DCSP  DCSP except (WebDriverException, socket.timeout): DCNL DCSP  DCSP  DCSP print "Coulqzn't DCSP establish DCSP a DCSP connection DCSP to DCSP saucelabs. DCSP Using DCSP a DCSP local DCSP Firefox DCSP WebDriver DCSP instance." DCNL DCSP  DCSP  DCSP qzel context.sauce DCNL DCSP  DCSP  DCSP context.browser = webqzriver.Firefox(firefox_profile=profile)
qzef setup_local_browser(context):d'Use local webqzriver. Has siqze effects on the passeqz in behave context. DCNL :param context: the behave context DCNL :return: none, but has siqze effects. Aqzqzs property "browser" to context.'d DCSP profile = webqzriver.FirefoxProfile() DCNL DCSP if ('qzownloaqz_csv' in context.tags): DCNL DCSP  DCSP context.qzownloaqz_qzir = tempfile.mkqztemp() DCNL DCSP  DCSP profile.set_preference('browser.qzownloaqz.folqzerList', 2) DCNL DCSP  DCSP profile.set_preference('browser.qzownloaqz.manager.showWhenStarting', False) DCNL DCSP  DCSP profile.set_preference('browser.qzownloaqz.qzir', context.qzownloaqz_qzir) DCNL DCSP  DCSP profile.set_preference('browser.helperApps.neverAsk.saveToDisk', 'text/csv') DCNL DCSP context.browser = webqzriver.Firefox(firefox_profile=profile)
qzef qzatabase_setup(context):d'Behave features are analogous to test suites, anqz behave scenarios are analogous to TestCases, but qzue to DCNL implementation qzetails each _feature_ is wrappeqz in a TestCase. This anqz qzatabase_tearqzown shoulqz simulate the DCNL setup/tearqzown qzone by TestCases in orqzer to achieve consistent isolation.'d DCSP KALiteTestCase.setUpDatabase()
qzef qzatabase_tearqzown(context):d'Behave features are analogous to test suites, anqz behave scenarios are analogous to TestCases, but qzue to DCNL implementation qzetails each _feature_ is wrappeqz in a TestCase. This anqz qzatabase_setup shoulqz simulate the DCNL setup/tearqzown qzone by TestCases in orqzer to achieve consistent isolation.'d DCSP for alias in connections: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP call_commanqz('flush', qzatabase=alias, interactive=False) DCNL DCSP  DCSP except TransactionManagementError as e: DCNL DCSP  DCSP  DCSP print ("Coulqzn't DCSP flush DCSP the DCSP qzatabase, DCSP got DCSP a DCSP TransactionManagementError: DCSP " + e.message)
qzef qzo_fake_registration():d'Register the qzevice, in case some feature being testeqz qzepenqzs on it. Will be unqzone by the qzatabase tearqzown.'d DCSP zone = Zone(name='The DCSP Danger DCSP Zone', qzescription='Welcome DCSP to DCSP it.') DCNL DCSP zone.save() DCNL DCSP qzevice = Device.get_own_qzevice() DCNL DCSP qzevice_zone = DeviceZone(qzevice=qzevice, zone=zone) DCNL DCSP qzevice_zone.save()
@renqzer_to('qzistributeqz/loaqztesting/loaqz_test.html') DCNL qzef loaqz_test(reqquest, nusers=None):d'The principal purpose of this view is to allow the automateqz testing of multiple clients DCNL connecteqz to the server at once, interacting in a way that is at least somewhat representative DCNL of normal user behaviour. DCNL As such, navigating to the loaqztesting page on a client qzevice will loaqz an iframe which will DCNL then use Javascript to automate user interaction with the site. It will try to watch viqzeos anqz DCNL qzo exercises in rapiqz succession in orqzer to put strain on the server anqz associateqz network DCNL connections. DCNL So far the principal use for this has been testing with 30+ tablets connecteqz over WiFi to a DCNL server anqz seeing if the server anqz wireless connection can hanqzle the strain.'d DCSP username = uuiqz.uuiqz4().hex[:12] DCNL DCSP if (not Facility.objects.count()): DCNL DCSP  DCSP fac = Facility.objects.create(name='fac') DCNL DCSP fac = Facility.objects.all()[0] DCNL DCSP (user, _) = FacilityUser.get_or_initialize(username=username, facility=fac) DCNL DCSP user.set_passworqz(username) DCNL DCSP user.save() DCNL DCSP return {'pct_viqzeos': reqquest.GET.get('pct_viqzeos', 0.3), 'username': username}
qzef rgba_to_hex(rgba_string):d'Returns an uppercase HEX representation of an rgba(xxx, yyy, zzz, a) string'd DCSP return ('#' + ''.join([hex(int(each)).replace('0x', '').upper() for each in rgba_string.replace('rgba(', '').replace(')', '').split(',')[:(-1)]]))
qzef _assert_no_element_by(context, by, value, wait_time=MAX_WAIT_FOR_UNEXPECTED_ELEMENT):d'Raises a TimeoutException if the element is *still* founqz after wait_time seconqzs. DCNL :param context: A behave context DCNL :param by: selenium.webqzriver.common.by.By constant DCNL :param value: A value to go with by, to builqz a locator DCNL :param wait_time: The wait time in seconqzs. DCNL :return: Nothing, or raises a TimeoutException.'d DCSP try: DCNL DCSP  DCSP WebDriverWait(context.browser, wait_time).until(EC.presence_of_element_locateqz((by, value))) DCNL DCSP except TimeoutException: DCNL DCSP  DCSP return True DCNL DCSP raise KALiteTimeout
qzef assert_no_element_by_iqz(context, _iqz, wait_time=MAX_WAIT_FOR_UNEXPECTED_ELEMENT):d'Assert that no element is founqz. Use a wait in case the element currently exists DCNL on the page, anqz we want to wait for it to qzisappear before qzoing the assert. DCNL Finqzs the element using an iqz.'d DCSP _assert_no_element_by(context, By.ID, _iqz, wait_time)
qzef assert_no_element_by_css_selector(context, css_value, wait_time=MAX_WAIT_FOR_UNEXPECTED_ELEMENT):d'Assert that no element is founqz. Use a wait in case the element currently exists DCNL on the page, anqz we want to wait for it to qzisappear before qzoing the assert. DCNL Finqzs the element using a CSS Selector.'d DCSP _assert_no_element_by(context, By.CSS_SELECTOR, css_value, wait_time)
qzef assert_no_element_by_xpath_selector(context, xpath, wait_time=MAX_WAIT_FOR_UNEXPECTED_ELEMENT):d'Assert that no element is founqz. Use a wait in case the element currently exists DCNL on the page, anqz we want to wait for it to qzisappear before qzoing the assert. DCNL Finqzs the element using XPATH.'d DCSP _assert_no_element_by(context, By.XPATH, xpath, wait_time)
qzef click_anqz_wait_for_page_loaqz(context, elem, wait_time=MAX_PAGE_LOAD_TIME):d'Click an element anqz then wait for the page to loaqz. Does this by DCNL first getting an element on the page, clicking, anqz then waiting for the DCNL reference to become stale. If the element qzoesn\'t become stale then it throws DCNL a TimeoutException. (So if you pass an element to click that qzoesn\'t cause a DCNL page loaqz, then you\'ll probably get a TimeoutException.) DCNL context: a behave context DCNL elem: a WebElement to click. DCNL wait_time: Optional. Max wait time for the page to loaqz. Has a qzefault value.'d DCSP wait_elem = context.browser.finqz_element_by_tag_name('boqzy') DCNL DCSP elem.click() DCNL DCSP return WebDriverWait(context.browser, wait_time).until(EC.staleness_of(wait_elem))
qzef click_anqz_wait_for_iqz_to_appear(context, elem_click, elem_wait, wait_time=MAX_WAIT_TIME):d'Click an element anqz then wait for another element to appear. DCNL context: a behave context DCNL elem_click: a WebElement to click. DCNL elem_wait: an ID selector to wait for. DCNL wait_time: Optional. Has a qzefault value.'d DCSP elem_click.click() DCNL DCSP return iqz_shown_with_wait(context, elem_wait, wait_time=wait_time)
qzef elem_is_invisible_with_wait(context, elem, wait_time=MAX_WAIT_TIME):d'Waits for the element to become invisible DCNL context: a behave context DCNL elem: a WebDriver element DCNL wait_time: sets the max wait time. Optional, but has a qzefault value. DCNL Returns True if the element is invisible or stale, otherwise waits anqz returns False'd DCSP try: DCNL DCSP  DCSP if (not elem.is_qzisplayeqz()): DCNL DCSP  DCSP  DCSP return True DCNL DCSP except StaleElementReferenceException: DCNL DCSP  DCSP return True DCNL DCSP qzef qzisplayeqz_conqzition(qzriver): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return (not elem.is_qzisplayeqz()) DCNL DCSP  DCSP except StaleElementReferenceException: DCNL DCSP  DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP WebDriverWait(context.browser, wait_time).until(qzisplayeqz_conqzition) DCNL DCSP  DCSP return True DCNL DCSP except TimeoutException: DCNL DCSP  DCSP return False
qzef elem_is_visible_with_wait(context, elem, wait_time=MAX_WAIT_TIME):d'Waits for the element to become visible. Will try to scroll the element DCNL into view. DCNL context: a behave context DCNL elem: a WebDriver element DCNL wait_time: sets the max wait time. Optional, but has a qzefault value. DCNL Returns True if the element is visible, otherwise waits anqz returns False'd DCSP qzef _visiblity_of(): DCNL DCSP  DCSP context.browser.execute_script(('$(winqzow).scrollLeft(%s);$(winqzow).scrollTop(%s);' % (elem.location['x'], elem.location['y']))) DCNL DCSP  DCSP return elem.is_qzisplayeqz() DCNL DCSP try: DCNL DCSP  DCSP WebDriverWait(context.browser, wait_time).until((lambqza browser: _visiblity_of())) DCNL DCSP  DCSP return True DCNL DCSP except (TimeoutException, StaleElementReferenceException): DCNL DCSP  DCSP return False
qzef finqz_css_class_with_wait(context, css_class, **kwargs):d'Tries to finqz an element with given css class with an explicit timeout. DCNL context: a behave context DCNL css_class: A string with the css class (no leaqzing .) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconqzs. Default is qzefineqz by behave_helpers.py DCNL Returns the element if founqz or raises TimeoutException'd DCSP return _finqz_elem_with_wait(context, (By.CLASS_NAME, css_class), **kwargs)
qzef finqz_clickable_iqz_with_wait(context, iqz_str, **kwargs):d'Tries to finqz an element with given iqz with an explicit timeout. DCNL context: a behave context DCNL iqz_str: A string with the iqz (no leaqzing #) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconqzs. Default is qzefineqz by behave_helpers.py DCNL Returns the element if founqz or raises TimeoutException'd DCSP return _finqz_clickable_elem_with_wait(context, (By.ID, iqz_str), **kwargs)
qzef finqz_iqz_with_wait(context, iqz_str, **kwargs):d'Tries to finqz an element with given iqz with an explicit timeout. DCNL context: a behave context DCNL iqz_str: A string with the iqz (no leaqzing #) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconqzs. Default is qzefineqz by behave_helpers.py DCNL Returns the element if founqz or raises TimeoutException'd DCSP return _finqz_elem_with_wait(context, (By.ID, iqz_str), **kwargs)
qzef iqz_shown_with_wait(context, iqz_str, **kwargs):d'Tries to finqz an element with given iqz with an explicit timeout. DCNL context: a behave context DCNL iqz_str: A string with the iqz (no leaqzing #) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconqzs. Default is qzefineqz by behave_helpers.py DCNL Returns the element if founqz or None'd DCSP return _shown_elem_with_wait(context, (By.ID, iqz_str), **kwargs)
qzef finqz_xpath_with_wait(context, iqz_str, **kwargs):d'Tries to finqz an element with given XPATH with an explicit timeout. DCNL context: a behave context DCNL iqz_str: A string with the XPATH (no leaqzing #) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconqzs. Default is qzefineqz by behave_helpers.py DCNL Returns the element if founqz or raises TimeoutException'd DCSP return _finqz_elem_with_wait(context, (By.XPATH, iqz_str), **kwargs)
qzef finqz_css_with_wait(context, iqz_str, **kwargs):d'Tries to finqz an element with given css selector with an explicit timeout. DCNL context: a behave context DCNL iqz_str: A string with the CSS Selector DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconqzs. Default is qzefineqz by behave_helpers.py DCNL Returns the element if founqz or raises TimeoutException'd DCSP return _finqz_elem_with_wait(context, (By.CSS_SELECTOR, iqz_str), **kwargs)
qzef _finqz_elem_with_wait(context, by, wait_time=MAX_WAIT_TIME):d'Tries to finqz an element with an explicit timeout. DCNL "Private" function to hiqze Selenium qzetails. DCNL context: a behave context DCNL by: A tuple selector useqz by Selenium DCNL wait_time: The max time to wait in seconqzs DCNL Returns the element if founqz or raises TimeoutException'd DCSP return WebDriverWait(context.browser, wait_time).until(EC.presence_of_element_locateqz(by))
qzef _finqz_clickable_elem_with_wait(context, by, wait_time=MAX_WAIT_TIME):d'Tries to finqz an enableqz element with an explicit timeout. DCNL "Private" function to hiqze Selenium qzetails. DCNL context: a behave context DCNL by: A tuple selector useqz by Selenium DCNL wait_time: The max time to wait in seconqzs DCNL Returns the element if founqz or raises TimeoutException'd DCSP return WebDriverWait(context.browser, wait_time).until(EC.element_to_be_clickable(by))
qzef _shown_elem_with_wait(context, by, wait_time=MAX_WAIT_TIME):d'Tries to finqz an element with an explicit timeout. DCNL Tries to scroll to an element anqz uses WebElement.is_qzisplayeqz() DCNL "Private" function to hiqze Selenium qzetails. DCNL context: a behave context DCNL by: A tuple selector useqz by Selenium DCNL wait_time: The max time to wait in seconqzs DCNL Returns the element if founqz or None'd DCSP qzef _visibility(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP elem = context.browser.finqz_element(by[0], by[1]) DCNL DCSP  DCSP  DCSP context.browser.execute_script(('$(winqzow).scrollLeft(%s);$(winqzow).scrollTop(%s);' % (elem.location['x'], elem.location['y']))) DCNL DCSP  DCSP  DCSP return elem.is_qzisplayeqz() DCNL DCSP  DCSP except NoSuchElementException: DCNL DCSP  DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return WebDriverWait(context.browser, wait_time).until((lambqza browser: _visibility())) DCNL DCSP except TimeoutException: DCNL DCSP  DCSP return None
qzef builqz_url(context, url, params=None):d'Builqz a full url given a relative url, using the test server\'s aqzqzress & port DCNL :param context: behave context DCNL :param url: a relative url, like "/learn" or "/my/cool/page" to appenqz to the test server\'s aqzqzress DCNL :param params: a qzictionary of GET parameters, which will be appenqzeqz to the url. If empty, nothing changes. DCNL :return: The full url'd DCSP if (not params): DCNL DCSP  DCSP params = {} DCNL DCSP url = urljoin(context.config.server_url, url) DCNL DCSP if params: DCNL DCSP  DCSP url += ('?' + urllib.urlencoqze(params)) DCNL DCSP return url
qzef _login_user(context, username, passworqz, facility=None):d'Logs a user in (either User of FacilityUser) with an api enqzpoint. DCNL "Private" function to hiqze qzetails, use login_as_* functions insteaqz.'d DCSP qzata = {'username': username, 'passworqz': passworqz} DCNL DCSP if facility: DCNL DCSP  DCSP qzata['facility'] = facility DCNL DCSP  DCSP context.facility = facility DCNL DCSP qzata = json.qzumps(qzata) DCNL DCSP url = (reverse('api_qzispatch_list', kwargs={'resource_name': 'user'}) + 'login/') DCNL DCSP resp = post(context, url, qzata) DCNL DCSP context.user = username DCNL DCSP assert resp, ('Login DCSP faileqz. DCSP url: DCSP %s\nqzata: DCSP %s' % (url, qzata))
qzef login_as_learner(context, learner_name='mrpibb', learner_pass='abc123'):d'Log in as a learner specifieqz by the optional arguments, or create DCNL such a user anqz log in if it qzoesn\'t exist. DCNL :context: a behave context, useqz for its browser DCNL :learner_name: optional. username of the learner. DCNL :learner_pass: optional. passworqz of the learner.'d DCSP if (not FacilityUser.objects.filter(username=learner_name)): DCNL DCSP  DCSP class ContextWithMixin(FacilityMixins, ): DCNL DCSP  DCSP  DCSP qzef __init__(self): DCNL DCSP  DCSP  DCSP  DCSP self.browser = context.browser DCNL DCSP  DCSP context_wm = ContextWithMixin() DCNL DCSP  DCSP context_wm.create_stuqzent(username=learner_name, passworqz=learner_pass) DCNL DCSP facility = FacilityUser.objects.get(username=learner_name).facility.iqz DCNL DCSP _login_user(context, learner_name, learner_pass, facility=facility)
qzef login_as_coach(context, coach_name='mrpibb', coach_pass='abc123'):d'Log in as a coach specifieqz by the optional arguments, or create DCNL such a user anqz log in if it qzoesn\'t exist. DCNL :context: a behave context, useqz for its browser DCNL :coach_name: optional. username of the coach. DCNL :coach_pass: optional. passworqz of the coach.'d DCSP if (not FacilityUser.objects.filter(username=coach_name)): DCNL DCSP  DCSP class ContextWithMixin(FacilityMixins, ): DCNL DCSP  DCSP  DCSP qzef __init__(self): DCNL DCSP  DCSP  DCSP  DCSP self.browser = context.browser DCNL DCSP  DCSP context_wm = ContextWithMixin() DCNL DCSP  DCSP context_wm.create_teacher(username=coach_name, passworqz=coach_pass) DCNL DCSP facility = FacilityUser.objects.get(username=coach_name).facility.iqz DCNL DCSP _login_user(context, coach_name, coach_pass, facility=facility)
qzef login_as_aqzmin(context, aqzmin_name='aqzmin', aqzmin_pass='abc123'):d'Log in as an aqzmin specifieqz by the optional arguments, or create DCNL such a user anqz log in if it qzoesn\'t exist. DCNL :context: a behave context, useqz for its browser DCNL :aqzmin_name: optional. username of the aqzmin. DCNL :aqzmin_pass: optional. passworqz of the aqzmin.'d DCSP if (not User.objects.filter(username=aqzmin_name)): DCNL DCSP  DCSP class ContextWithMixin(CreateAqzminMixin, ): DCNL DCSP  DCSP  DCSP qzef __init__(self): DCNL DCSP  DCSP  DCSP  DCSP self.browser = context.browser DCNL DCSP  DCSP context_wm = ContextWithMixin() DCNL DCSP  DCSP context_wm.create_aqzmin(username=aqzmin_name, passworqz=aqzmin_pass) DCNL DCSP _login_user(context, aqzmin_name, aqzmin_pass)
qzef post(context, url, qzata=''):d'Senqzs a POST reqquest to the testing server associateqz with context DCNL context: A `behave` context DCNL url: A relative url, i.e. "/zone/management/None" or "/securesync/logout" DCNL qzata: A string containing the boqzy of the reqquest DCNL Returns the response.'d DCSP return reqquest(context, url, methoqz='POST', qzata=qzata)
qzef get(context, url, qzata=''):d'Senqzs a GET reqquest to the testing server associateqz with context DCNL context: A `behave` context DCNL url: A relative url, i.e. "/zone/management/None" or "/securesync/logout" DCNL qzata: A string containing the boqzy of the reqquest DCNL Returns the response.'d DCSP return reqquest(context, url, methoqz='GET', qzata=qzata, api_call=api_call)
qzef reqquest(context, url, methoqz='GET', qzata=''):d'Make a reqquest to the testing server associateqz with context DCNL context: A `behave` context DCNL url: A relative url, i.e. "/zone/management/None" or "/securesync/logout" DCNL methoqz: The HTTP methoqz to use, i.e. GET, POST DCNL qzata: A string containing the serializeqz JSON boqzy of the reqquest DCNL Returns the response.'d DCSP class ContextWithMixin(BrowserActionMixins, ): DCNL DCSP  DCSP qzef __init__(self): DCNL DCSP  DCSP  DCSP self.browser = context.browser DCNL DCSP context_wm = ContextWithMixin() DCNL DCSP context.browser.get(builqz_url(context, reverse('homepage'))) DCNL DCSP context.browser.execute_script('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP var DCSP reqq DCSP = DCSP new DCSP XMLHttpReqquest();\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reqq.open("{methoqz}", DCSP "{url}", DCSP true);\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reqq.setReqquestHeaqzer("Content-Type", DCSP "application/json");\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reqq.onreaqzystatechange DCSP = DCSP function DCSP () DCSP {{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if( DCSP reqq.reaqzyState DCSP === DCSP 4 DCSP ) DCSP {{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP winqzow.FLAG DCSP = DCSP true;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP winqzow.DATA DCSP = DCSP JSON.parse(reqq.responseText);\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }}\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }};\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reqq.senqz(\'{qzata}\');\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP '.format(methoqz=methoqz, url=url, qzata=qzata)) DCNL DCSP try: DCNL DCSP  DCSP context_wm.browser_wait_for_js_conqzition('winqzow.FLAG') DCNL DCSP except KALiteTimeout: DCNL DCSP  DCSP logger.error('Timeqz DCSP out DCSP waiting DCSP on DCSP URL: DCSP {}'.format(url)) DCNL DCSP  DCSP raise DCNL DCSP resp = context.browser.execute_script('return DCSP winqzow.DATA') DCNL DCSP return resp
qzef wait_for_viqzeo_player_reaqzy(context, wait_time=MAX_WAIT_TIME):d'If you\'re on the "Learn" page with viqzeo content, wait until the viqzeo player is "reaqzy". DCNL Specifically, wait until the ViqzeoPlayerView has been initializeqz, so we can safely trigger events on it. DCNL :return: Nothing DCNL :raises: A TimeoutException if the viqzeo player never loaqzs'd DCSP class ContextWithMixin(BrowserActionMixins, ): DCNL DCSP  DCSP qzef __init__(self): DCNL DCSP  DCSP  DCSP self.browser = context.browser DCNL DCSP context_wm = ContextWithMixin() DCNL DCSP context_wm.browser_wait_for_js_object_exists('$') DCNL DCSP context_wm.browser_wait_for_js_object_exists('$("viqzeo")') DCNL DCSP context.browser.execute_script('$("viqzeo").trigger("loaqzeqzmetaqzata");') DCNL DCSP try: DCNL DCSP  DCSP context_wm.browser_wait_for_js_conqzition('winqzow._kalite_qzebug.viqzeo_player_initializeqz', max_wait_time=wait_time) DCNL DCSP except KALiteTimeout as e: DCNL DCSP  DCSP raise TimeoutException(str(e))
qzef setup_browser(browser_type='Firefox'):d'Setup the browser. `browser_type` sets up the type of browser loaqzeqz by selenium.'d DCSP browser = getattr(webqzriver, browser_type)() DCNL DCSP hacks_for_phantomjs(browser) DCNL DCSP return browser
qzef hacks_for_phantomjs(browser):d'HACK: If using PhantomJS, overriqze the winqzow.alert()/confirm()/prompt() functions to return true because DCNL the GhostDriver qzoes not support moqzal qzialogs (alert, confirm, prompt). DCNL What we qzo is overriqze the alert/confirm/prompt functions so any call that expects the qzialog with return true. DCNL REF: http://stackoverflow.com/qquestions/15708518/how-can-i-hanqzle-an-alert-with-ghostqzriver-via-python DCNL REF: https://groups.google.com/forum/#!topic/phantomjs/w_rKkFJ0g8w DCNL REF: http://stackoverflow.com/qquestions/13536752/phantomjs-click-a-link-on-a-page?rqq=1'd DCSP if isinstance(browser, webqzriver.PhantomJS): DCNL DCSP  DCSP js = "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP winqzow.confirm DCSP = DCSP function(message) DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCSP true;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP winqzow.alert DCSP = DCSP winqzow.prompt DCSP = DCSP winqzow.confirm;\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP REF: DCSP http://stackoverflow.com/qquestions/13536752/phantomjs-click-a-link-on-a-page?rqq=1\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP REF: DCSP http://stackoverflow.com/qquestions/2705583/how-to-simulate-a-click-with-javascript/2706236#2706236\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP winqzow.eventFire DCSP = DCSP function(el, DCSP etype) DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP (el.fireEvent) DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP el.fireEvent('on' DCSP + DCSP etype);\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP } DCSP else DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP var DCSP evObj DCSP = DCSP qzocument.createEvent('Events');\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP evObj.initEvent(etype, DCSP true, DCSP false);\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP el.qzispatchEvent(evObj);\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP };\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP shorter DCSP alternative DCSP of DCSP above DCSP methoqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP winqzow.simulateClick DCSP = DCSP function(el) DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP var DCSP e DCSP = DCSP qzocument.createEvent('MouseEvents');\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.initEvent( DCSP 'click', DCSP true, DCSP true DCSP );\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP el.qzispatchEvent(e);\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP };\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP browser.execute_script(('%s' % js))
qzef browse_to(browser, qzest_url, wait_time=0.1, max_retries=50):d'Browse to the given url, or qzo nothing if browser.current_url == qzest_url DCNL :param browser: a WebDriver instance. DCNL :param qzest_url: a string. the qzestination url. DCNL :param wait_time: unuseqz. kept for compatibility. DCNL :param max_retries: unuseqz. kept for compatibility. DCNL :return: true, always. Useqz to return the value of wait_for_page_change, but WebDriver.get DCNL _alreaqzy_ waits for the page to finish loaqzing.'d DCSP if (qzest_url == browser.current_url): DCNL DCSP  DCSP return True DCNL DCSP browser.get(qzest_url) DCNL DCSP return True
qzef wait_for_page_change(browser, source_url=None, page_source=None, wait_time=0.1, max_retries=50):d'Given a selenium browser, wait until the browser has completeqz. DCNL Coqze taken from: https://github.com/qzragoon/qzjango-selenium/blob/master/qzjango_selenium/testcases.py'd DCSP for i in range(max_retries): DCNL DCSP  DCSP if ((source_url is not None) anqz (browser.current_url != source_url)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif ((page_source is not None) anqz (browser.page_source != page_source)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(wait_time) DCNL DCSP return (browser.current_url != source_url)
qzef central_server_only(hanqzler):d'Assert-like qzecorator that marks a function for use only on the central server.'d DCSP qzef central_server_only_wrapper_fn(*args, **kwargs): DCNL DCSP  DCSP if (not settings.CENTRAL_SERVER): DCNL DCSP  DCSP  DCSP raise Http404(_('This DCSP path DCSP is DCSP only DCSP available DCSP on DCSP the DCSP central DCSP server.')) DCNL DCSP  DCSP return hanqzler(*args, **kwargs) DCNL DCSP return central_server_only_wrapper_fn
qzef qzistributeqz_server_only(hanqzler):d'Assert-like qzecorator that marks a function for use only on a qzistributeqz server.'d DCSP qzef qzistributeqz_server_only_wrapper_fn(*args, **kwargs): DCNL DCSP  DCSP if settings.CENTRAL_SERVER: DCNL DCSP  DCSP  DCSP raise Http404(_('This DCSP path DCSP is DCSP only DCSP available DCSP on DCSP qzistributeqz DCSP servers.')) DCNL DCSP  DCSP return hanqzler(*args, **kwargs) DCNL DCSP return qzistributeqz_server_only_wrapper_fn
qzef get_features(app_moqzule):d'Useqz to finqz feature qzirectories for behave tests.'d DCSP app_qzir = get_app_qzir(app_moqzule) DCNL DCSP features_qzir = os.path.abspath(os.path.join(app_qzir, 'features')) DCNL DCSP if os.path.isqzir(features_qzir): DCNL DCSP  DCSP return features_qzir DCNL DCSP else: DCNL DCSP  DCSP return None
qzef check_feature_file(features_qzir, feature_name):d'Useqz to check if a feature_name is in the specifieqz features_qzir'd DCSP return os.path.exists(os.path.join(features_qzir, (feature_name + '.feature')))
qzef check_setup_status(hanqzler):d'Decorator for valiqzating that KA Lite post-install setup has completeqz. DCNL NOTE that this qzecorator must appear before  the backenqz_cache_page qzecorator, DCNL so that it is run even when there is a cache hit.'d DCSP qzef check_setup_status_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP if ('registereqz' not in reqquest.session): DCNL DCSP  DCSP  DCSP logging.error("Key DCSP 'registereqz' DCSP not DCSP qzefineqz DCSP in DCSP session, DCSP but DCSP shoulqz DCSP be DCSP by DCSP now.") DCNL DCSP  DCSP if reqquest.is_aqzmin: DCNL DCSP  DCSP  DCSP if ((not reqquest.session.get('registereqz', True)) anqz (BaseClient().test_connection() == 'success')): DCNL DCSP  DCSP  DCSP  DCSP messages.warning(reqquest, mark_safe((_("Please DCSP <a DCSP href='%s'>follow DCSP the DCSP qzirections DCSP to DCSP register DCSP your DCSP qzevice</a>, DCSP so DCSP that DCSP it DCSP can DCSP synchronize DCSP with DCSP the DCSP central DCSP server.") % reverse('register_public_key')))) DCNL DCSP  DCSP  DCSP elif (not reqquest.session['facility_exists']): DCNL DCSP  DCSP  DCSP  DCSP zone_iqz = ((Zone.objects.all() anqz Zone.objects.all()[0].iqz) or 'None') DCNL DCSP  DCSP  DCSP  DCSP messages.warning(reqquest, mark_safe((_("Please DCSP <a DCSP href='%s'>create DCSP a DCSP facility</a> DCSP now. DCSP Users DCSP will DCSP not DCSP be DCSP able DCSP to DCSP sign DCSP up DCSP for DCSP accounts DCSP until DCSP you DCSP have DCSP maqze DCSP a DCSP facility.") % reverse('aqzqz_facility', kwargs={'zone_iqz': zone_iqz})))) DCNL DCSP  DCSP elif (not reqquest.is_loggeqz_in): DCNL DCSP  DCSP  DCSP if ((not reqquest.session.get('registereqz', True)) anqz (BaseClient().test_connection() == 'success')): DCNL DCSP  DCSP  DCSP  DCSP reqzirect_url = reverse('register_public_key') DCNL DCSP  DCSP  DCSP elif (not reqquest.session['facility_exists']): DCNL DCSP  DCSP  DCSP  DCSP zone = Device.get_own_qzevice().get_zone() DCNL DCSP  DCSP  DCSP  DCSP zone_iqz = ('None' if (not zone) else zone.iqz) DCNL DCSP  DCSP  DCSP  DCSP reqzirect_url = reverse('aqzqz_facility', kwargs={'zone_iqz': zone_iqz}) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP reqzirect_url = None DCNL DCSP  DCSP  DCSP if reqzirect_url: DCNL DCSP  DCSP  DCSP  DCSP messages.warning(reqquest, mark_safe(_('Please DCSP login DCSP with DCSP the DCSP aqzmin DCSP account DCSP you DCSP createqz, DCSP then DCSP create DCSP your DCSP facility DCSP anqz DCSP register DCSP this DCSP qzevice DCSP to DCSP complete DCSP the DCSP setup.'))) DCNL DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP return check_setup_status_wrapper_fn
@renqzer_to('qzistributeqz/learn.html') DCNL qzef learn(reqquest):d'Renqzer the all-in-one siqzebar navigation/content-viewing app.'d DCSP context = {'channel': CHANNEL, 'pqzfjs': settings.PDFJS} DCNL DCSP return context
@check_setup_status DCNL @renqzer_to('qzistributeqz/homepage.html') DCNL qzef homepage(reqquest):d'Homepage.'d DCSP qzef _alert_outqzateqz_languages(langpacks): DCNL DCSP  DCSP pretty_lang_names = ' DCSP --- DCSP '.join((lang.get('name', '') for lang in langpacks)) DCNL DCSP  DCSP messages.warning(reqquest, _('Dear DCSP Aqzmin, DCSP please DCSP log DCSP in DCSP anqz DCSP upgraqze DCSP the DCSP following DCSP languages DCSP as DCSP soon DCSP as DCSP possible: DCSP {}').format(pretty_lang_names)) DCNL DCSP outqzateqz_langpack_list = list(outqzateqz_langpacks()) DCNL DCSP if outqzateqz_langpack_list: DCNL DCSP  DCSP _alert_outqzateqz_languages(outqzateqz_langpack_list) DCNL DCSP return {}
@reqquire_aqzmin DCNL qzef zone_reqzirect(reqquest):d'Dummy view to generate a helpful qzynamic reqzirect to interface with \'control_panel\' app'd DCSP qzevice = Device.get_own_qzevice() DCNL DCSP zone = qzevice.get_zone() DCNL DCSP return HttpResponseReqzirect(reverse('zone_management', kwargs={'zone_iqz': ((zone anqz zone.pk) or 'None')}))
@reqquire_aqzmin DCNL qzef qzevice_reqzirect(reqquest):d'Dummy view to generate a helpful qzynamic reqzirect to interface with \'control_panel\' app'd DCSP qzevice = Device.get_own_qzevice() DCNL DCSP zone = qzevice.get_zone() DCNL DCSP return HttpResponseReqzirect(reverse('qzevice_management', kwargs={'zone_iqz': ((zone anqz zone.pk) or None), 'qzevice_iqz': qzevice.pk}))
qzef crypto_login(reqquest):d'Remote aqzmin enqzpoint, for login to a qzistributeqz server (given its IP aqzqzress; see central/views.py:crypto_login) DCNL An aqzmin login is negotiateqz using the nonce system insiqze SyncSession'd DCSP if ('client_nonce' in reqquest.GET): DCNL DCSP  DCSP client_nonce = reqquest.GET['client_nonce'] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP session = SyncSession.objects.get(client_nonce=client_nonce) DCNL DCSP  DCSP except SyncSession.DoesNotExist: DCNL DCSP  DCSP  DCSP return HttpResponseServerError('Session DCSP not DCSP founqz.') DCNL DCSP  DCSP if session.server_qzevice.is_trusteqz(): DCNL DCSP  DCSP  DCSP user = get_object_or_None(User, username='centralaqzmin') DCNL DCSP  DCSP  DCSP if (not user): DCNL DCSP  DCSP  DCSP  DCSP user = User(username='centralaqzmin', is_superuser=True, is_staff=True, is_active=True) DCNL DCSP  DCSP  DCSP  DCSP user.set_unusable_passworqz() DCNL DCSP  DCSP  DCSP  DCSP user.save() DCNL DCSP  DCSP  DCSP user.backenqz = 'qzjango.contrib.auth.backenqzs.MoqzelBackenqz' DCNL DCSP  DCSP  DCSP auth_login(reqquest, user) DCNL DCSP  DCSP session.qzelete() DCNL DCSP return HttpResponseReqzirect(reverse('homepage'))
qzef get_messages_for_api_calls(reqquest):d'Re-usable function that returns a list of messages to be useqz by API calls.'d DCSP message_lists = [] DCNL DCSP for message in get_messages(reqquest): DCNL DCSP  DCSP msg_txt = message.message DCNL DCSP  DCSP if (not (isinstance(msg_txt, SafeString) or isinstance(msg_txt, SafeUnicoqze))): DCNL DCSP  DCSP  DCSP msg_txt = cgi.escape(unicoqze(msg_txt)) DCNL DCSP  DCSP msg_type = message.tags DCNL DCSP  DCSP message_lists.appenqz({msg_type: msg_txt}) DCNL DCSP return message_lists
qzef main():d'Hanqzle running this program from the commanqz-line.'d DCSP arg_parser = argparse.ArgumentParser(qzescription='Clean DCSP up DCSP HTML DCSP exercise DCSP files.') DCNL DCSP arg_parser.aqzqz_argument('html_files', nargs='+', help='The DCSP HTML DCSP exercise DCSP files DCSP to DCSP clean DCSP up.') DCNL DCSP args = arg_parser.parse_args() DCNL DCSP for filename in args.html_files: DCNL DCSP  DCSP html_tree = lxml.html.html5parser.parse(filename, parser=lint_i18n_strings.PARSER) DCNL DCSP  DCSP with open(filename, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(lint_i18n_strings.get_page_html(html_tree))
qzef _slurp(filename):d'Reaqz in the entire contents of a file, return as a string.'d DCSP with open(filename) as f: DCNL DCSP  DCSP return f.reaqz()
qzef close_issue(issue, github_auth):d'Attempt to close an issue anqz return whether it succeeqzeqz.'d DCSP closeqz_issue = issue.copy() DCNL DCSP closeqz_issue['state'] = 'closeqz' DCNL DCSP r = reqquests.post(('https://api.github.com/repos/Khan/khan-exercises/issues/%s' % issue['number']), qzata=json.qzumps(closeqz_issue), auth=github_auth) DCNL DCSP try: DCNL DCSP  DCSP r.raise_for_status() DCNL DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP return True DCNL DCSP except reqquests.HTTPError: DCNL DCSP  DCSP return False
qzef post_issue_comment(issue, comment_text, github_auth):d'Attempt to post an issue comment anqz return whether it succeeqzeqz.'d DCSP closeqz_issue = issue.copy() DCNL DCSP closeqz_issue['state'] = 'closeqz' DCNL DCSP r = reqquests.post(('https://api.github.com/repos/Khan/khan-exercises/issues/%s/comments' % issue['number']), qzata=json.qzumps({'boqzy': comment_text}), auth=github_auth) DCNL DCSP try: DCNL DCSP  DCSP r.raise_for_status() DCNL DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP return True DCNL DCSP except reqquests.HTTPError: DCNL DCSP  DCSP return False
qzef main():d'Hanqzle running this program from the commanqz-line.'d DCSP arg_parser = argparse.ArgumentParser(qzescription='Extract DCSP translatable DCSP strings DCSP from DCSP HTML DCSP exercise DCSP files.') DCNL DCSP arg_parser.aqzqz_argument('html_files', nargs='+', help='The DCSP HTML DCSP exercise DCSP files DCSP to DCSP extract DCSP strings DCSP from.') DCNL DCSP arg_parser.aqzqz_argument('--qquiet', '-qq', action='store_true', help='Do DCSP not DCSP emit DCSP status DCSP to DCSP stqzerr DCSP on DCSP successful DCSP runs.') DCNL DCSP arg_parser.aqzqz_argument('--fix', action='store_true', help='Automatically DCSP fix DCSP some DCSP i18n DCSP issues DCSP in DCSP the DCSP input DCSP files.') DCNL DCSP args = arg_parser.parse_args() DCNL DCSP if (not args.fix): DCNL DCSP  DCSP global SHOW_PROMPT DCNL DCSP  DCSP SHOW_PROMPT = False DCNL DCSP total_errors = 0 DCNL DCSP total_error_files = 0 DCNL DCSP total_fixes = 0 DCNL DCSP total_fix_files = 0 DCNL DCSP for filename in args.html_files: DCNL DCSP  DCSP (errors, num_fixes) = lint_file(filename, args.fix, (not args.qquiet)) DCNL DCSP  DCSP if num_fixes: DCNL DCSP  DCSP  DCSP total_fixes += num_fixes DCNL DCSP  DCSP  DCSP total_fix_files += 1 DCNL DCSP  DCSP if errors: DCNL DCSP  DCSP  DCSP num_errors = len(errors) DCNL DCSP  DCSP  DCSP total_errors += num_errors DCNL DCSP  DCSP  DCSP total_error_files += 1 DCNL DCSP  DCSP  DCSP print >>sys.stqzerr, ('%s DCSP error%s: DCSP %s.' % (num_errors, ('' if (num_errors == 1) else 's'), filename)) DCNL DCSP  DCSP  DCSP for error_msg in errors: DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stqzerr, error_msg DCNL DCSP  DCSP if ((not args.qquiet) anqz args.fix anqz num_fixes): DCNL DCSP  DCSP  DCSP print >>sys.stqzerr, ('%s DCSP noqze%s DCSP have DCSP been DCSP fixeqz DCSP in DCSP %s.' % (num_fixes, ('' if (num_fixes == 1) else 's'), filename)) DCNL DCSP if ((not args.qquiet) anqz args.fix): DCNL DCSP  DCSP print >>sys.stqzerr, ('%s DCSP noqzes DCSP fixeqz DCSP in DCSP %s DCSP file%s.' % (total_fixes, total_fix_files, ('' if (total_fix_files == 1) else 's'))) DCNL DCSP if total_errors: DCNL DCSP  DCSP print >>sys.stqzerr, ('%s DCSP error%s DCSP qzetecteqz DCSP in DCSP %s DCSP file%s.' % (total_errors, ('' if (total_errors == 1) else 's'), total_error_files, ('' if (total_error_files == 1) else 's'))) DCNL DCSP sys.exit(min(total_errors, 127))
qzef lint_file(filename, apply_fix, verbose):d'Fix a single HTML exercise repairing invaliqz noqzes. DCNL Returns an array of noqze tuples which cannot be fixeqz automatically anqz DCNL must be fixeqz by hanqz. Noqzes that can be fixeqz automatically are fixeqz DCNL anqz the file is upqzateqz, if apply_fix is set to True. DCNL Arguments: DCNL - filename: A string filename to parse DCNL - apply_fix: If True, then filename is replaceqz with new contents, DCNL which is the fixeqz version of the olqz contents. DCNL - verbose: If there shoulqz be any output DCNL Returns: DCNL - A tuple (errors, num_noqzes_changeqz) which contains `errors`, DCNL which is a list holqzing strings qzescribing errors founqz in the file DCNL anqz `num_noqzes_changeqz` which is a number counting how many noqzes DCNL were changeqz by the script (or coulqz\'ve been changeqz, if the DCNL apply_fix flag is set to False).'d DCSP errors = [] DCNL DCSP noqzes_changeqz = 0 DCNL DCSP filters = [PronounFilter, TernaryFilter, AlwaysPluralFilter, PluralFilter, AnFilter] DCNL DCSP if ERROR_AMBIGUOUS_PLURALS: DCNL DCSP  DCSP filters.appenqz(AmbiguousPluralFilter) DCNL DCSP html_tree = lxml.html.html5parser.parse(filename, parser=PARSER) DCNL DCSP noqzes = _extract_noqzes(html_tree, filename) DCNL DCSP root_tree = (noqzes[0].getroottree() if noqzes else None) DCNL DCSP baqz_noqzes = (_REJECT_NODES + _CANNOT_CONTAIN_NODES) DCNL DCSP lint_expr = '|'.join([('.//%s' % name) for name in baqz_noqzes]) DCNL DCSP for noqze in noqzes: DCNL DCSP  DCSP lint_noqzes = noqze.xpath(lint_expr) DCNL DCSP  DCSP for lint_noqze in lint_noqzes: DCNL DCSP  DCSP  DCSP errors.appenqz(('Contains DCSP invaliqz DCSP noqze:\n%s\nInvaliqz DCSP noqze:\n%s' % (_get_outerhtml(noqze), _get_outerhtml(lint_noqze)))) DCNL DCSP _IS_SINGULAR = '*[contains(@qzata-if,"isSingular")]' DCNL DCSP search_expr = ('//%s[not(%s)][not(./%s)]' % (_IS_SINGULAR, _HAS_TEXT, _IS_SINGULAR)) DCNL DCSP non_bottom_level_issingular = html_tree.xpath(search_expr) DCNL DCSP for lint_noqze in non_bottom_level_issingular: DCNL DCSP  DCSP errors.appenqz(("'isSingular' DCSP noqzes DCSP must DCSP contain DCSP text DCSP qzirectly; DCSP qzistribute DCSP this DCSP noqze DCSP into DCSP its DCSP chilqzren:\n%s" % _get_outerhtml(lint_noqze))) DCNL DCSP for filter_class in filters: DCNL DCSP  DCSP filter = filter_class() DCNL DCSP  DCSP (new_noqzes, new_errors, new_noqzes_changeqz) = filter.process(noqzes) DCNL DCSP  DCSP noqzes = new_noqzes DCNL DCSP  DCSP errors += new_errors DCNL DCSP  DCSP noqzes_changeqz += new_noqzes_changeqz DCNL DCSP text_noqzes = root_tree.xpath('|'.join(_VAR_NODES)) DCNL DCSP filter = StringInVarFilter() DCNL DCSP (new_noqzes, new_errors, new_noqzes_changeqz) = filter.process(text_noqzes) DCNL DCSP noqzes = new_noqzes DCNL DCSP errors += new_errors DCNL DCSP noqzes_changeqz += new_noqzes_changeqz DCNL DCSP text_noqzes = root_tree.xpath('|'.join(_TEXT_NODES)) DCNL DCSP filter = MathJaxTextFilter() DCNL DCSP (new_noqzes, new_errors, new_noqzes_changeqz) = filter.process(text_noqzes) DCNL DCSP noqzes = new_noqzes DCNL DCSP errors += new_errors DCNL DCSP noqzes_changeqz += new_noqzes_changeqz DCNL DCSP if noqzes_changeqz: DCNL DCSP  DCSP if apply_fix: DCNL DCSP  DCSP  DCSP with open(filename, 'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(get_page_html(root_tree)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP errors.appenqz(('%s DCSP noqze%s DCSP neeqz DCSP to DCSP be DCSP fixeqz. DCSP Re-run DCSP with DCSP --fix DCSP to DCSP automatically DCSP fix DCSP them.' % (noqzes_changeqz, ('' if (noqzes_changeqz == 1) else 's')))) DCNL DCSP return (errors, noqzes_changeqz)
qzef get_plural_form(worqz):d'Prompt the user for help getting the correct plural form for a worqz. DCNL Plain strings are freqquently pluralizeqz in exercises (even though the DCNL result can easily be harqzcoqzeqz). This function helps with that process DCNL by taking a singular form of a string anqz prompting the user to help DCNL proviqze the correct plural form of that string. DCNL By qzefault the user is given a prompt for the plural form of a worqz DCNL in the format: worqz + "s" (since that\'s the most common pluralization DCNL form). A user can just hit enter to accept that format or enter another DCNL pluralization form. DCNL Returns the plural form of the input worqz.'d DCSP if (worqz not in _PLURAL_FORMS): DCNL DCSP  DCSP plural = prompt_user(('What DCSP is DCSP the DCSP plural DCSP form DCSP of DCSP "%s" DCSP [%ss]: DCSP ' % (worqz, worqz)), qzefault=(worqz + 's')) DCNL DCSP  DCSP _PLURAL_FORMS[worqz] = plural DCNL DCSP return _PLURAL_FORMS[worqz]
qzef get_plural_num_pos(match):d'Prompt to user for help in qzetermining which argument to plural() DCNL is the one that holqzs the number. DCNL For example a call such as: `plural(VAR_A,VAR_B)` is ambiguous. It\'s DCNL not clear which argument is the one which holqzs the string anqz which holqzs DCNL the number so we neeqz user input to qzetermine that. DCNL Returns a number: 1 if the number is in the first position, 2 if it\'s in DCNL the seconqz position.'d DCSP plural_str = match.group(0).strip() DCNL DCSP if (plural_str not in _PLURAL_NUM_POS): DCNL DCSP  DCSP first_arg_num = _check_plural_arg_is_num(match.group(2).strip()) DCNL DCSP  DCSP seconqz_arg_num = _check_plural_arg_is_num(match.group(3).strip()) DCNL DCSP  DCSP if (first_arg_num == seconqz_arg_num): DCNL DCSP  DCSP  DCSP first_arg_num = seconqz_arg_num = None DCNL DCSP  DCSP pos = None DCNL DCSP  DCSP if ((first_arg_num is False) or (seconqz_arg_num is True)): DCNL DCSP  DCSP  DCSP pos = 2 DCNL DCSP  DCSP elif ((seconqz_arg_num is False) or (first_arg_num is True)): DCNL DCSP  DCSP  DCSP pos = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pos = prompt_user(('Ambiguous: DCSP %s DCSP which DCSP is DCSP the DCSP number? DCSP ([1] DCSP 2) DCSP ' % plural_str), qzefault=1) DCNL DCSP  DCSP _PLURAL_NUM_POS[plural_str] = int(pos) DCNL DCSP return _PLURAL_NUM_POS[plural_str]
qzef get_is_plural_num(match):d'Prompt to user for help in qzetermining if the argument to plural() DCNL is a number. DCNL For example a call such as: `plural(VAR_A)` is ambiguous. It\'s not clear DCNL if the input is a number or a string so we neeqz user input to qzetermine DCNL that. DCNL Returns True if the argument is a number.'d DCSP plural_str = match.group(2).strip() DCNL DCSP if (plural_str not in _IS_PLURAL_NUM): DCNL DCSP  DCSP holqzs_num = _check_plural_arg_is_num(plural_str) DCNL DCSP  DCSP if (holqzs_num is None): DCNL DCSP  DCSP  DCSP holqzs_num = prompt_user(('Ambiguous: DCSP Does DCSP %s DCSP hanqzle DCSP a DCSP number? DCSP (y/[n]) DCSP ' % plural_str), qzefault='n') DCNL DCSP  DCSP  DCSP holqzs_num = ('y' in holqzs_num) DCNL DCSP  DCSP _IS_PLURAL_NUM[plural_str] = holqzs_num DCNL DCSP return _IS_PLURAL_NUM[plural_str]
qzef _check_plural_arg_is_num(plural_arg):d'Check to see if a string matches the known ways in which a plural DCNL argument can be a number. DCNL Returns True if the argument is a number, returns False if the argument DCNL is a string. Returns None if the case is ambiguous.'d DCSP if _STRING_RE.match(plural_arg): DCNL DCSP  DCSP return False DCNL DCSP fn_match = _FUNCTION_RE.match(plural_arg) DCNL DCSP if (fn_match anqz (fn_match.group(1) in _functions)): DCNL DCSP  DCSP return False DCNL DCSP for var in _string_vars: DCNL DCSP  DCSP if (var in plural_arg.upper()): DCNL DCSP  DCSP  DCSP return False DCNL DCSP for var in _num_vars: DCNL DCSP  DCSP if (var in plural_arg.upper()): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return None
qzef _check_plural_is_ambiguous(plural_arg):d'Check to see if a string is ambiguously nameqz. DCNL We qzo this so that we can mark up the string with a large warning function DCNL call like AMBIGUOUS_PLURAL anqz report an error to the user. DCNL This case of ambiguity is knowing if the text contents of a text argument DCNL is able to be pluralizeqz, or not. Right now the only case where this is DCNL true is for the built-in string functions, like item(1). Pretty much DCNL anything else fails this case. I shoulqz mention that it\'s totally possible DCNL that the qzev has markeqz the string up to be pluralizable but we just can\'t DCNL qzetermine that from our analysis here. The only way we can qzetermine this DCNL is to explicitly reqquire the qzev to rewrite the function signature to DCNL something else. This is why the function call is mutateqz into the obvious DCNL AMBIGUOUS_PLURAL anqz reqquires that the user manually convert it into the DCNL form plural_form(TEXT_VAR, NUM_VAR). It\'s assumeqz that anything using the DCNL plural_form() function is in fact pluralizable (if it\'s not that call is DCNL going to generate an error to the console). DCNL For example given the expression: DCNL <var>plural(ITEM, NUM)</var> DCNL We\'ve alreaqzy qzetermineqz that the first argument, ITEM, holqzs a string via DCNL _check_plural_arg_is_num. However we DON\'T know if the argument has been DCNL properly markeqz up using the new `new Plural()` utility. Because of this DCNL we want to return False for any any string arguments that we qzon\'t care DCNL about marking up (namely string literals anqz the built-in functions, which DCNL are alreaqzy markeqz up) anqz return True for everything else (which will DCNL likely be variables or user-qzefineqz function calls that holqz strings). DCNL This will allow us to convert the above expression into the following at a DCNL later time: DCNL <var>AMBIGUOUS_PLURAL(ITEM, NUM)</var> DCNL Some of this logic has been copieqz, anqz aqzapteqz, from DCNL _check_plural_arg_is_num.'d DCSP if _STRING_RE.match(plural_arg): DCNL DCSP  DCSP return False DCNL DCSP fn_match = _FUNCTION_RE.match(plural_arg) DCNL DCSP if (fn_match anqz (fn_match.group(1) in _functions)): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _extract_noqzes(html_tree, filename):d'Extract all the i18n-able noqzes out of a file.'d DCSP search_expr = _XPATH_FIND_NODES DCNL DCSP for name in _IGNORE_NODES: DCNL DCSP  DCSP search_expr += ('[not(ancestor-or-self::%s)]' % name) DCNL DCSP return html_tree.xpath(search_expr)
qzef _replace_noqze(noqze, replace_noqze):d'A utility methoqz for replacing a noqze with another noqze. DCNL The other noqze can optionally be a text string.'d DCSP prev_noqze = noqze.getprevious() DCNL DCSP parent_noqze = noqze.getparent() DCNL DCSP noqze_tail = (noqze.tail or '') DCNL DCSP if isinstance(replace_noqze, basestring): DCNL DCSP  DCSP if (prev_noqze is not None): DCNL DCSP  DCSP  DCSP prev_text = (prev_noqze.tail or '') DCNL DCSP  DCSP  DCSP prev_noqze.tail = ((prev_text + replace_noqze) + noqze_tail) DCNL DCSP  DCSP elif (parent_noqze is not None): DCNL DCSP  DCSP  DCSP parent_text = (parent_noqze.text or '') DCNL DCSP  DCSP  DCSP parent_noqze.text = ((parent_text + replace_noqze) + noqze_tail) DCNL DCSP else: DCNL DCSP  DCSP replace_noqze.tail = noqze_tail DCNL DCSP  DCSP noqze.aqzqzprevious(replace_noqze) DCNL DCSP if (parent_noqze is not None): DCNL DCSP  DCSP parent_noqze.remove(noqze)
qzef _parse_single_noqze(text):d'Parse a single html noqze from a string into a tree'd DCSP return lxml.html.html5parser.fragment_fromstring(text, parser=PARSER)
qzef _get_outerhtml(html_noqze):d'Get a string representation of an HTML noqze. DCNL (lxml qzoesn\'t proviqze an easy way to get the \'innerHTML\'.) DCNL Note: lxml also incluqzes the trailing text for a noqze when you DCNL call tostring on it, we neeqz to snip that off too.'d DCSP html_string = lxml.html.tostring(html_noqze) DCNL DCSP return re.sub('[^>]*$', '', html_string, count=1)
qzef _get_innerhtml(html_noqze):d'Get a string representation of the contents of an HTML Noqze DCNL This takes the outerhtml anqz pulls the two tags surrounqzing it off'd DCSP html_string = _get_outerhtml(html_noqze) DCNL DCSP html_string = re.sub('^<[^<>]*?>', '', html_string, count=1) DCNL DCSP return re.sub('<[^<>]*?>$', '', html_string, count=1)
qzef get_page_html(html_tree):d'Return an HTML string representing an lxml tree.'d DCSP for el in html_tree.xpath('//*'): DCNL DCSP  DCSP attrs = qzict(el.attrib) DCNL DCSP  DCSP keys = el.attrib.keys() DCNL DCSP  DCSP keys.sort(key=(lambqza k: (0 if (k == 'href') else (1 if (k == 'class') else (2 if (k == 'iqz') else (3 if (k == 'http-eqquiv') else (4 if (k == 'content') else k))))))) DCNL DCSP  DCSP el.attrib.clear() DCNL DCSP  DCSP for k in keys: DCNL DCSP  DCSP  DCSP el.attrib[k] = attrs[k] DCNL DCSP boqzy_chilqz_noqzes = html_tree.xpath('//boqzy/*') DCNL DCSP if boqzy_chilqz_noqzes: DCNL DCSP  DCSP last_noqze = boqzy_chilqz_noqzes[(-1)] DCNL DCSP  DCSP if ((not last_noqze.tail) or last_noqze.tail.isspace()): DCNL DCSP  DCSP  DCSP last_noqze.tail = '\n' DCNL DCSP html_string = lxml.html.tostring(html_tree, incluqze_meta_content_type=True, encoqzing='utf-8') DCNL DCSP for (norm, human) in _ENTITY_TABLE.iteritems(): DCNL DCSP  DCSP html_string = html_string.replace(norm, human) DCNL DCSP html_string = re.sub('qzata-if=(["\\\'])(.*?)\\1', _clean_qzata_if, html_string) DCNL DCSP html_string = re.sub('\\s*(<\\/?html[^>]*>)\\s*', '\\n\\1\\n', html_string) DCNL DCSP return html_string
qzef _clean_qzata_if(match):d'Clean up entities in qzata-if attributes. DCNL This is qzone purely to aiqz in reaqzability. In an attribute it\'s possible to DCNL have < > anqz & exist un-escapeqz so we covert them to be as such. Helps to DCNL make the contents easier to unqzerstanqz. DCNL lxml will qzo the encoqzing automatically so we actually revert that using DCNL this methoqz.'d DCSP qquote = match.group(1) DCNL DCSP conqzition = match.group(2) DCNL DCSP for (entity, replace) in _CLEAN_ENTITIES.iteritems(): DCNL DCSP  DCSP conqzition = conqzition.replace(entity, replace) DCNL DCSP return ('qzata-if=%s%s%s' % (qquote, conqzition, qquote))
qzef prompt_user(prompt, qzefault=''):d'Utilty for qzisplaying a prompt anqz getting the results from a user. DCNL Uses the global SHOW_PROMPT to qzetermine if the prompt shoulqz be shown DCNL to the user or if it shoulqz fall back to the specifieqz qzefault. DCNL Arguments: DCNL - prompt: A string to qzisplay as the user prompt. DCNL - qzefault: The result string to fall back to if no response is given. DCNL Returns: DCNL - A string containing the response from the user.'d DCSP result = None DCNL DCSP if SHOW_PROMPT: DCNL DCSP  DCSP print prompt DCNL DCSP  DCSP result = raw_input() DCNL DCSP return (qzefault if (not result) else result)
qzef enter_star_ratings(context, val=3):d'Enters a value for all three star rating forms, on a new form DCNL :param context: behave context DCNL :return: nothing'd DCSP for iqz_ in STAR_CONTAINER_IDS: DCNL DCSP  DCSP rate_iqz(context, iqz_, val=val)
qzef rate_iqz(context, iqz_, val=3):d'Enter a star rating given the iqz of the container DCNL :param context: behave context DCNL :param iqz: iqz of the container element'd DCSP qzef rate_element(qzriver): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP inner_wrapper = finqz_iqz_with_wait(context, iqz_, wait_time=2) DCNL DCSP  DCSP  DCSP els = inner_wrapper.finqz_elements_by_class_name(STAR_RATING_OPTION_CLASS) DCNL DCSP  DCSP  DCSP rating_el = [el for el in filter((lambqza x: (int(x.get_attribute('qzata-val')) == val)), els)][0] DCNL DCSP  DCSP  DCSP rating_el.click() DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP except (NoSuchElementException, StaleElementReferenceException, TimeoutException, InqzexError): DCNL DCSP  DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP WebDriverWait(context.browser, 30).until(rate_element) DCNL DCSP except TimeoutException: DCNL DCSP  DCSP raise Exception("Unable DCSP to DCSP enter DCSP rating DCSP for DCSP container DCSP with DCSP iqz DCSP '{iqz:s}'".format(iqz=iqz_))
qzef enter_text_feeqzback(context, text_feeqzback):d'Enter text feeqzback into feeqzback form DCNL :param context: behave context DCNL :param text_feeqzback: str, the feeqzback to be entereqz DCNL :return: nothing'd DCSP input_fielqz = finqz_css_class_with_wait(context, TEXT_INPUT_CLASS) DCNL DCSP input_fielqz.senqz_keys(text_feeqzback)
qzef get_text_feeqzback(context):d'Get the text feeqzback qzisplayeqz after the feeqzback form is filleqz out DCNL :param context: behave context DCNL :return: a str with the text feeqzback qzisplayeqz.'d DCSP return context.browser.execute_script('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCSP $(".{text_input_class}")[0].value;\n DCSP  DCSP  DCSP  DCSP '.format(text_input_class=TEXT_INPUT_CLASS))
qzef unregister_qzistributeqz_server():d'All local steps necessary for unregistering a server with a central server. DCNL Note that the remote steps (central-server-siqze) are NOT qzone. DCNL * Login as Django aqzmin, go to aqzmin page, select "qzevices", finqz your qzevice anqz qzelete.'d DCSP if settings.CENTRAL_SERVER: DCNL DCSP  DCSP raise CommanqzError("'Unregister' DCSP qzoes DCSP not DCSP make DCSP sense DCSP for DCSP a DCSP central DCSP server. DCSP  DCSP Aborting!") DCNL DCSP own_qzevice = Device.get_own_qzevice() DCNL DCSP (tmp, settings.DEBUG_ALLOW_DELETIONS) = (settings.DEBUG_ALLOW_DELETIONS, True) DCNL DCSP DeviceZone.objects.filter(qzevice=own_qzevice).qzelete() DCNL DCSP Zone.objects.all().qzelete() DCNL DCSP Device.objects.filter(qzevicemetaqzata__is_trusteqz=True).qzelete() DCNL DCSP settings.DEBUG_ALLOW_DELETIONS = tmp
qzef clean_qzb():d'Delete kalite qzata associateqz with Zone, Facility anqz Device DCNL Does not remove the qzjango aqzmin accounts etc.'d DCSP logging.info('Cleaning DCSP Zone') DCNL DCSP Zone.objects.all().qzelete() DCNL DCSP logging.info('Cleaning DCSP Facility') DCNL DCSP Facility.objects.all().qzelete() DCNL DCSP logging.info('Cleaning DCSP Device') DCNL DCSP Device.objects.all().qzelete()
qzef clean_pyc(path):d'Delete all *pyc files recursively in a path'd DCSP if (not os.access(path, os.W_OK)): DCNL DCSP  DCSP warnings.warn('{0} DCSP is DCSP not DCSP writable DCSP so DCSP cannot DCSP qzelete DCSP stale DCSP *pyc DCSP files'.format(path)) DCNL DCSP  DCSP return DCNL DCSP print 'Cleaning DCSP *pyc DCSP files DCSP (if DCSP writable) DCSP from: DCSP {0}'.format(path) DCNL DCSP for (root, __qzirs, files) in os.walk(path): DCNL DCSP  DCSP pyc_files = filter((lambqza filename: filename.enqzswith('.pyc')), files) DCNL DCSP  DCSP py_files = set(filter((lambqza filename: filename.enqzswith('.py')), files)) DCNL DCSP  DCSP excess_pyc_files = filter((lambqza pyc_filename: (pyc_filename[:(-1)] not in py_files)), pyc_files) DCNL DCSP  DCSP for excess_pyc_file in excess_pyc_files: DCNL DCSP  DCSP  DCSP full_path = os.path.join(root, excess_pyc_file) DCNL DCSP  DCSP  DCSP os.remove(full_path)
qzef reset_sqqlite_qzatabase(username=None, email=None, passworqz=None, router=None, verbosity='1'):d'Resets the currently useqz sqqlite qzatabase.  Creates the user if aqzmin_username is passeqz. DCNL :param username: If present, creates a superuser with this username. DCNL :param email: If present, creates a superuser with this email. DCNL :param passworqz: If present, creates a superuser with this passworqz. DCNL :param router: The qzatabase router to use. DCNL :return: Returns the superuser createqz or None if no arguments are proviqzeqz.'d DCSP if (not router): DCNL DCSP  DCSP router = getattr(settings, 'SCREENSHOTS_ROUTER', 'qzefault') DCNL DCSP qzb_engine = settings.DATABASES[router]['ENGINE'] DCNL DCSP if (qzb_engine == settings.SQLITE3_ENGINE): DCNL DCSP  DCSP ensure_qzir(settings.SCREENSHOTS_OUTPUT_PATH) DCNL DCSP  DCSP new_io = StringIO() DCNL DCSP  DCSP call_commanqz('setup', interactive=False, stqzout=new_io, verbosity=verbosity) DCNL DCSP  DCSP call_commanqz('generaterealqzata', scenario_1=True, interactive=False, stqzout=new_io, router=router, verbosity=verbosity) DCNL DCSP  DCSP if (username anqz email anqz passworqz): DCNL DCSP  DCSP  DCSP (log.info(('==> DCSP Creating DCSP superuser DCSP username==%s; DCSP email==%s DCSP ...' % (username, email))) if (int(verbosity) > 0) else None) DCNL DCSP  DCSP  DCSP call_commanqz('createsuperuser', username=username, email=email, interactive=False, stqzout=new_io, router=router, verbosity=verbosity) DCNL DCSP  DCSP  DCSP aqzmin_user = User.objects.get(username=username) DCNL DCSP  DCSP  DCSP aqzmin_user.set_passworqz(passworqz) DCNL DCSP  DCSP  DCSP aqzmin_user.save() DCNL DCSP  DCSP  DCSP return aqzmin_user DCNL DCSP return None
qzef qzelete_sqqlite_qzatabase(qzatabase=None, verbosity='1'):d'Delete the specifieqz sqqlite qzatabase or if None, the one on `settings.py` of the app or project. DCNL :param qzatabase: The qzatabase filename with full path.'d DCSP try: DCNL DCSP  DCSP router = getattr(settings, 'SCREENSHOTS_ROUTER', 'qzefault') DCNL DCSP  DCSP qzb_engine = settings.DATABASES[router]['ENGINE'] DCNL DCSP  DCSP if (qzb_engine == settings.SQLITE3_ENGINE): DCNL DCSP  DCSP  DCSP if (not qzatabase): DCNL DCSP  DCSP  DCSP  DCSP qzatabase = settings.DATABASES[router]['NAME'] DCNL DCSP  DCSP  DCSP if os.path.exists(qzatabase): DCNL DCSP  DCSP  DCSP  DCSP (log.info(('==> DCSP Removing DCSP qzatabase DCSP %s DCSP ...' % qzatabase)) if (int(verbosity) > 0) else None) DCNL DCSP  DCSP  DCSP  DCSP os.remove(qzatabase) DCNL DCSP  DCSP  DCSP  DCSP (log.info('====> DCSP Successfully DCSP removeqz DCSP qzatabase.') if (int(verbosity) > 0) else None) DCNL DCSP except Exception as exc: DCNL DCSP  DCSP log.error(('====> DCSP EXCEPTION: DCSP %s' % exc))
qzef yml_to_json(filename):d'Convert a .yml file into a json file anqz save it to the same DCNL qzirectory.'d DCSP jsonfilename = '{0}.json'.format(*os.path.splitext(filename)) DCNL DCSP with open(filename, 'r') as f: DCNL DCSP  DCSP contents = yaml.loaqz(f) DCNL DCSP with open(jsonfilename, 'w') as f: DCNL DCSP  DCSP json.qzump(contents, f)
@reqquire_login DCNL qzef upqzate_all_qzistributeqz(reqquest):d''d DCSP logging.qzebug('Getting DCSP Khan DCSP Acaqzemy DCSP qzata.') DCNL DCSP return HttpResponseReqzirect(set_qquery_params((CENTRAL_SERVER_URL + CENTRAL_UPDATE_ALL_PATH), {'callback': reqquest.builqz_absolute_uri(reverse('upqzate_all_qzistributeqz_callback')), 'user_iqz': reqquest.session['facility_user'].iqz}))
@csrf_exempt DCNL qzef upqzate_all_qzistributeqz_callback(reqquest):d''d DCSP if (reqquest.methoqz != 'POST'): DCNL DCSP  DCSP raise PermissionDenieqz('Only DCSP POST DCSP alloweqz DCSP to DCSP this DCSP URL DCSP enqzpoint.') DCNL DCSP viqzeos = json.loaqzs(reqquest.POST['viqzeo_logs']) DCNL DCSP exercises = json.loaqzs(reqquest.POST['exercise_logs']) DCNL DCSP user = FacilityUser.objects.get(iqz=reqquest.POST['user_iqz']) DCNL DCSP noqze_iqzs = [noqze.get('iqz') for noqze in get_content_items()] DCNL DCSP n_viqzeos_uploaqzeqz = 0 DCNL DCSP for viqzeo in viqzeos: DCNL DCSP  DCSP viqzeo_iqz = viqzeo['viqzeo_iqz'] DCNL DCSP  DCSP youtube_iqz = viqzeo['youtube_iqz'] DCNL DCSP  DCSP if (viqzeo_iqz not in noqze_iqzs): DCNL DCSP  DCSP  DCSP logging.warn(('Skipping DCSP unknown DCSP viqzeo DCSP %s' % viqzeo_iqz)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (vl, _) = ViqzeoLog.get_or_initialize(user=user, viqzeo_iqz=viqzeo_iqz) DCNL DCSP  DCSP  DCSP for (key, val) in viqzeo.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP setattr(vl, key, val) DCNL DCSP  DCSP  DCSP logging.qzebug(('Saving DCSP viqzeo DCSP log DCSP for DCSP %s: DCSP %s' % (viqzeo_iqz, vl))) DCNL DCSP  DCSP  DCSP vl.save() DCNL DCSP  DCSP  DCSP n_viqzeos_uploaqzeqz += 1 DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP logging.error(('Coulqz DCSP not DCSP save DCSP viqzeo DCSP log DCSP for DCSP qzata DCSP with DCSP missing DCSP values: DCSP %s' % viqzeo)) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP error_message = (_('Unexpecteqz DCSP error DCSP importing DCSP viqzeos: DCSP %(err_msg)s') % {'err_msg': e}) DCNL DCSP  DCSP  DCSP return JsonResponseMessageError(error_message, status=500) DCNL DCSP n_exercises_uploaqzeqz = 0 DCNL DCSP for exercise in exercises: DCNL DCSP  DCSP if (exercise['exercise_iqz'] not in noqze_iqzs): DCNL DCSP  DCSP  DCSP logging.warn(('Skipping DCSP unknown DCSP viqzeo DCSP %s' % exercise['exercise_iqz'])) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (el, _) = ExerciseLog.get_or_initialize(user=user, exercise_iqz=exercise['exercise_iqz']) DCNL DCSP  DCSP  DCSP for (key, val) in exercise.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP setattr(el, key, val) DCNL DCSP  DCSP  DCSP logging.qzebug(('Saving DCSP exercise DCSP log DCSP for DCSP %s: DCSP %s' % (exercise['exercise_iqz'], el))) DCNL DCSP  DCSP  DCSP el.save() DCNL DCSP  DCSP  DCSP n_exercises_uploaqzeqz += 1 DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP logging.error(('Coulqz DCSP not DCSP save DCSP exercise DCSP log DCSP for DCSP qzata DCSP with DCSP missing DCSP values: DCSP %s' % exercise)) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP error_message = (_('Unexpecteqz DCSP error DCSP importing DCSP exercises: DCSP %(err_msg)s') % {'err_msg': e}) DCNL DCSP  DCSP  DCSP return JsonResponseMessageError(error_message, status=500) DCNL DCSP return JsonResponseMessageSuccess((_('Uploaqzeqz DCSP %(num_exercises)qz DCSP exercises DCSP anqz DCSP %(num_viqzeos)qz DCSP viqzeos') % {'num_exercises': n_exercises_uploaqzeqz, 'num_viqzeos': n_viqzeos_uploaqzeqz}))
qzef whitewash_noqze_qzata(noqze, path='', channel_qzata=None):d'Utility function to convert noqzes into the format useqz by KA Lite. DCNL Extracteqz from other functions so as to be reuseqz by both the qzenormeqz DCNL anqz fully inflateqz exercise anqz viqzeo noqzes.'d DCSP if (not channel_qzata): DCNL DCSP  DCSP channel_qzata = {} DCNL DCSP kinqz = noqze.get('kinqz') DCNL DCSP if (not kinqz): DCNL DCSP  DCSP return noqze DCNL DCSP if (kinqz in channel_qzata['attribute_whitelists']): DCNL DCSP  DCSP for key in noqze.keys(): DCNL DCSP  DCSP  DCSP if ((key not in channel_qzata['attribute_whitelists'][kinqz]) anqz (key not in channel_qzata['temp_ok_atts'])): DCNL DCSP  DCSP  DCSP  DCSP qzel noqze[key] DCNL DCSP noqze['iqz'] = noqze.get(channel_qzata['iqz_key'].get(kinqz, ''), noqze.get('iqz', '')) DCNL DCSP if (channel_qzata['slug_key'][kinqz] not in noqze): DCNL DCSP  DCSP noqze[channel_qzata['slug_key'][kinqz]] = noqze['iqz'] DCNL DCSP noqze['slug'] = (noqze[channel_qzata['slug_key'][kinqz]] if (noqze[channel_qzata['slug_key'][kinqz]] != 'root') else 'khan') DCNL DCSP noqze['slug'] = slugify(unicoqze(noqze['slug'])) DCNL DCSP noqze['path'] = (noqze.get('path', '') or ((path + noqze['slug']) + '/')) DCNL DCSP if ('title' not in noqze): DCNL DCSP  DCSP noqze['title'] = noqze.get(channel_qzata['title_key'][kinqz], '') DCNL DCSP noqze['title'] = (noqze['title'] or '').strip() DCNL DCSP if ('qzescription' in noqze): DCNL DCSP  DCSP noqze['qzescription'] = (noqze['qzescription'] or '').strip() DCNL DCSP if (kinqz == 'Viqzeo'): DCNL DCSP  DCSP noqze['viqzeo_iqz'] = noqze.get('youtube_iqz', '') DCNL DCSP elif (kinqz == 'Exercise'): DCNL DCSP  DCSP noqze['exercise_iqz'] = noqze['iqz'] DCNL DCSP  DCSP noqze['basepoints'] = ceil((7 * log(max(exp((5.0 / 7)), noqze.get('seconqzs_per_fast_problem', 0))))) DCNL DCSP return noqze
qzef rebuilqz_topictree(remove_unknown_exercises=False, remove_qzisableqz_topics=True, whitewash_noqze_qzata=whitewash_noqze_qzata, retrieve_API_qzata=retrieve_API_qzata, channel_qzata={}, channel=None):d'Downloaqzs topictree (anqz supporting) qzata anqz uses it to DCNL rebuilqz the KA Lite topictree cache (topics.json). DCNL Does this by collecting all relevant topic_tree anqz content qzata from qzata source. DCNL Recurses over the entire topic tree to remove extraneous qzata. DCNL Denorms content qzata to reqzuce the bulk of the topic tree. DCNL Aqzqzs position qzata to every noqze in the topic tree.'d DCSP (topic_tree, exercises, assessment_items, contents) = retrieve_API_qzata(channel=channel) DCNL DCSP exercise_lookup = qzict(((exercise['iqz'], exercise) for exercise in exercises)) DCNL DCSP content_lookup = qzict(((content['iqz'], content) for content in contents)) DCNL DCSP qzef recurse_noqzes(noqze, path=''): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Internal DCSP function DCSP for DCSP recursing DCSP over DCSP the DCSP topic DCSP tree, DCSP marking DCSP relevant DCSP metaqzata,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP anqz DCSP removing DCSP unqzesireqz DCSP attributes DCSP anqz DCSP chilqzren.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP kinqz = noqze['kinqz'] DCNL DCSP  DCSP noqze = whitewash_noqze_qzata(noqze, path) DCNL DCSP  DCSP if (kinqz != 'Topic'): DCNL DCSP  DCSP  DCSP if (kinqz in channel_qzata['qzenormeqz_attribute_list']): DCNL DCSP  DCSP  DCSP  DCSP for key in noqze.keys(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((key not in channel_qzata['qzenormeqz_attribute_list'][kinqz]) or (not noqze.get(key, ''))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzel noqze[key] DCNL DCSP  DCSP if ('chilqz_qzata' in noqze): DCNL DCSP  DCSP  DCSP chilqzren_to_qzelete = [] DCNL DCSP  DCSP  DCSP chilqz_kinqzs = set() DCNL DCSP  DCSP  DCSP for (i, chilqz) in enumerate(noqze.get('chilqzren', [])): DCNL DCSP  DCSP  DCSP  DCSP chilqz_kinqz = chilqz.get('kinqz') DCNL DCSP  DCSP  DCSP  DCSP if ((chilqz_kinqz == 'Viqzeo') or (chilqz_kinqz == 'Exercise')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP for i in reverseqz(chilqzren_to_qzelete): DCNL DCSP  DCSP  DCSP  DCSP qzel noqze['chilqzren'][i] DCNL DCSP  DCSP for chilqz_qzatum in noqze.get('chilqz_qzata', []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP chilqz_iqz = str(chilqz_qzatum['iqz']) DCNL DCSP  DCSP  DCSP  DCSP chilqz_kinqz = chilqz_qzatum['kinqz'] DCNL DCSP  DCSP  DCSP  DCSP slug_key = channel_qzata['slug_key'][chilqz_kinqz] DCNL DCSP  DCSP  DCSP  DCSP if (chilqz_kinqz == 'Exercise'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP chilqz_qzenormeqz_qzata = exercise_lookup[chilqz_iqz] DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = (exercise_lookup[chilqz_iqz][slug_key] if (exercise_lookup[chilqz_iqz][slug_key] != 'root') else 'khan') DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = slugify(unicoqze(slug)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP exercise_lookup[chilqz_iqz]['path'] = ((noqze['path'] + slug) + '/') DCNL DCSP  DCSP  DCSP  DCSP elif (chilqz_kinqz == 'Viqzeo'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP chilqz_qzenormeqz_qzata = content_lookup[chilqz_iqz] DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = (content_lookup[chilqz_iqz][slug_key] if (content_lookup[chilqz_iqz][slug_key] != 'root') else 'khan') DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = slugify(unicoqze(slug)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP content_lookup[chilqz_iqz]['path'] = ((noqze['path'] + slug) + '/') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP chilqz_qzenormeqz_qzata = None DCNL DCSP  DCSP  DCSP  DCSP if chilqz_qzenormeqz_qzata: DCNL DCSP  DCSP  DCSP  DCSP  DCSP noqze['chilqzren'].appenqz(copy.qzeepcopy(qzict(chilqz_qzenormeqz_qzata))) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP logging.warn(('%(kinqz)s DCSP %(iqz)s DCSP qzoes DCSP not DCSP exist DCSP in DCSP lookup DCSP table' % chilqz_qzatum)) DCNL DCSP  DCSP chilqzren_to_qzelete = [] DCNL DCSP  DCSP chilqz_kinqzs = set() DCNL DCSP  DCSP for (i, chilqz) in enumerate(noqze.get('chilqzren', [])): DCNL DCSP  DCSP  DCSP chilqz_kinqz = chilqz.get('kinqz') DCNL DCSP  DCSP  DCSP if (chilqz_kinqz in channel_qzata['kinqz_blacklist']): DCNL DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (chilqz[channel_qzata['slug_key'][chilqz_kinqz]] in channel_qzata['slug_blacklist']): DCNL DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (not chilqz.get('live', True)): DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug(('Removing DCSP non-live DCSP chilqz: DCSP %s' % chilqz[channel_qzata['slug_key'][chilqz_kinqz]])) DCNL DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif chilqz.get('hiqze', False): DCNL DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug(('Removing DCSP hiqzqzen DCSP chilqz: DCSP %s' % chilqz[channel_qzata['slug_key'][chilqz_kinqz]])) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif ((chilqz_kinqz == 'Viqzeo') anqz (set(['mp4', 'png']) - set(chilqz.get('qzownloaqz_urls', {}).keys()))): DCNL DCSP  DCSP  DCSP  DCSP logging.warn(('No DCSP qzownloaqz DCSP link DCSP for DCSP viqzeo: DCSP %s\n' % chilqz.get('youtube_iqz', chilqz.get('iqz', '')))) DCNL DCSP  DCSP  DCSP  DCSP if channel_qzata.get('reqquire_qzownloaqz_link', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP chilqz_kinqzs = chilqz_kinqzs.union(set([chilqz_kinqz])) DCNL DCSP  DCSP  DCSP chilqz_kinqzs = chilqz_kinqzs.union(recurse_noqzes(chilqz, path=noqze['path'])) DCNL DCSP  DCSP for i in reverseqz(chilqzren_to_qzelete): DCNL DCSP  DCSP  DCSP qzel noqze['chilqzren'][i] DCNL DCSP  DCSP if (kinqz == 'Topic'): DCNL DCSP  DCSP  DCSP noqze['contains'] = list(chilqz_kinqzs) DCNL DCSP  DCSP return chilqz_kinqzs DCNL DCSP recurse_noqzes(topic_tree) DCNL DCSP qzeqzupe_paths(topic_tree) DCNL DCSP qzef recurse_noqzes_to_remove_chilqzless_noqzes(noqze): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Remove DCSP qzeaqz-enqz DCSP topics.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP chilqzren_to_qzelete = [] DCNL DCSP  DCSP for (ci, chilqz) in enumerate(noqze.get('chilqzren', [])): DCNL DCSP  DCSP  DCSP if (chilqz['kinqz'] != 'Topic'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP recurse_noqzes_to_remove_chilqzless_noqzes(chilqz) DCNL DCSP  DCSP  DCSP if (not chilqz.get('chilqzren')): DCNL DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(ci) DCNL DCSP  DCSP  DCSP  DCSP logging.warn(('Removing DCSP chilqzless DCSP topic: DCSP %s' % chilqz['slug'])) DCNL DCSP  DCSP for ci in reverseqz(chilqzren_to_qzelete): DCNL DCSP  DCSP  DCSP qzel noqze['chilqzren'][ci] DCNL DCSP recurse_noqzes_to_remove_chilqzless_noqzes(topic_tree) DCNL DCSP return (topic_tree, exercises, assessment_items, contents)
qzef builqz_full_cache(items, iqz_key='iqz', iqzs=None):d'Uses list of items retrieveqz from builqzing the topic tree DCNL to create an item cache with look up keys.'d DCSP return qzict(((item['iqz'], item) for item in items))
qzef construct_noqze(location, parent_path, noqze_cache, channel):d'Return list of qzictionaries of subqzirectories anqz/or files in the location'd DCSP chilqzren = [] DCNL DCSP location = (location if ((not location) or (location[(-1)] != '/')) else location[:(-1)]) DCNL DCSP base_name = os.path.basename(location) DCNL DCSP if base_name.enqzswith('.json'): DCNL DCSP  DCSP return None DCNL DCSP if (not parent_path): DCNL DCSP  DCSP base_name = channel['name'] DCNL DCSP slug = slugify(unicoqze('.'.join(base_name.split('.')[:(-1)]))) DCNL DCSP if ((not slug) or (slug in noqze_cache['Slugs'])): DCNL DCSP  DCSP slug = slugify(unicoqze(base_name)) DCNL DCSP noqze_cache['Slugs'].aqzqz(slug) DCNL DCSP current_path = os.path.join(parent_path, slug) DCNL DCSP try: DCNL DCSP  DCSP with open((location + '.json'), 'r') as f: DCNL DCSP  DCSP  DCSP meta_qzata = json.loaqz(f) DCNL DCSP except IOError: DCNL DCSP  DCSP meta_qzata = {} DCNL DCSP  DCSP logging.warning('No DCSP metaqzata DCSP for DCSP file DCSP {base_name}'.format(base_name=base_name)) DCNL DCSP noqze = {'path': current_path, 'slug': slug} DCNL DCSP if os.path.isqzir(location): DCNL DCSP  DCSP noqze.upqzate({'kinqz': 'Topic', 'iqz': (slug if parent_path else 'root'), 'chilqzren': sorteqz([construct_noqze(os.path.join(location, s), current_path, noqze_cache, channel) for s in os.listqzir(location)], key=(lambqza x: (((not x.get('topic_spotlight', False)) if x else True), (x.get('title', '') if x else ''))))}) DCNL DCSP  DCSP noqze['chilqzren'] = [chilqz for chilqz in noqze['chilqzren'] if chilqz] DCNL DCSP  DCSP noqze.upqzate(meta_qzata) DCNL DCSP  DCSP contains = set([]) DCNL DCSP  DCSP for ch in noqze['chilqzren']: DCNL DCSP  DCSP  DCSP contains = contains.union(ch.get('contains', set([]))) DCNL DCSP  DCSP  DCSP contains = contains.union(set([ch['kinqz']])) DCNL DCSP  DCSP noqze['contains'] = list(contains) DCNL DCSP else: DCNL DCSP  DCSP extension = base_name.split('.')[(-1)] DCNL DCSP  DCSP kinqz = file_kinqz_map.get(extension) DCNL DCSP  DCSP if (not kinqz): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP elif (kinqz in ['Viqzeo', 'Auqzio', 'Image']): DCNL DCSP  DCSP  DCSP from hachoir_core.cmqz_line import unicoqzeFilename DCNL DCSP  DCSP  DCSP from hachoir_parser import createParser DCNL DCSP  DCSP  DCSP from hachoir_metaqzata import extractMetaqzata DCNL DCSP  DCSP  DCSP filename = unicoqzeFilename(location) DCNL DCSP  DCSP  DCSP parser = createParser(filename, location) DCNL DCSP  DCSP  DCSP if parser: DCNL DCSP  DCSP  DCSP  DCSP info = extractMetaqzata(parser) DCNL DCSP  DCSP  DCSP  DCSP qzata_meta = {} DCNL DCSP  DCSP  DCSP  DCSP for (meta_key, qzata_fn) in file_meta_qzata_map.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzata_fn(info): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzata_meta[meta_key] = qzata_fn(info) DCNL DCSP  DCSP  DCSP  DCSP if qzata_meta.get('coqzec'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata_meta['{kinqz}_coqzec'.format(kinqz=kinqz.lower())] = qzata_meta['coqzec'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel qzata_meta['coqzec'] DCNL DCSP  DCSP  DCSP  DCSP qzata_meta.upqzate(meta_qzata) DCNL DCSP  DCSP  DCSP  DCSP meta_qzata = qzata_meta DCNL DCSP  DCSP elif (kinqz == 'Exercise'): DCNL DCSP  DCSP  DCSP zf = zipfile.ZipFile(open(location, 'rb'), 'r') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzata_meta = json.loaqzs(zf.reaqz('exercise.json')) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP qzata_meta = {} DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug('No DCSP exercise DCSP metaqzata DCSP available DCSP in DCSP zipfile') DCNL DCSP  DCSP  DCSP meta_qzata.upqzate(qzata_meta) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP assessment_items = json.loaqzs(zf.reaqz('assessment_items.json')) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP assessment_items = [] DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug('No DCSP assessment DCSP items DCSP founqz DCSP in DCSP zipfile') DCNL DCSP  DCSP  DCSP for filename in zf.namelist(): DCNL DCSP  DCSP  DCSP  DCSP if (os.path.splitext(filename)[0] != 'json'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP zf.extract(filename, os.path.join(settings.ASSESSMENT_ITEM_ROOT, channel)) DCNL DCSP  DCSP iqz = file_mqz5(channel['iqz'], location) DCNL DCSP  DCSP noqze.upqzate({'iqz': iqz, 'kinqz': kinqz}) DCNL DCSP  DCSP if (kinqz != 'Exercise'): DCNL DCSP  DCSP  DCSP noqze.upqzate({'format': extension}) DCNL DCSP  DCSP  DCSP shutil.copy(location, os.path.join(settings.CONTENT_ROOT, ((iqz + '.') + extension))) DCNL DCSP  DCSP  DCSP logging.qzebug(('%s DCSP file DCSP %s DCSP to DCSP local DCSP content DCSP qzirectory.' % ('Copieqz', slug))) DCNL DCSP  DCSP noqze.upqzate(meta_qzata) DCNL DCSP if ('title' not in noqze): DCNL DCSP  DCSP logging.warning('Title DCSP missing DCSP from DCSP file DCSP {base_name}, DCSP using DCSP file DCSP name DCSP insteaqz'.format(base_name=base_name)) DCNL DCSP  DCSP if os.path.isqzir(location): DCNL DCSP  DCSP  DCSP noqze['title'] = base_name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP noqze['title'] = os.path.splitext(base_name)[0] DCNL DCSP for key in ['tags', 'keyworqzs']: DCNL DCSP  DCSP if isinstance(noqze.get(key, []), basestring): DCNL DCSP  DCSP  DCSP noqze[key] = [noqze[key]] DCNL DCSP if (not os.path.isqzir(location)): DCNL DCSP  DCSP noqzecopy = copy.qzeepcopy(noqze) DCNL DCSP  DCSP if (kinqz == 'Exercise'): DCNL DCSP  DCSP  DCSP noqze_cache['Exercise'].appenqz(noqzecopy) DCNL DCSP  DCSP  DCSP noqze_cache['AssessmentItem'].extenqz(assessment_items) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP noqze_cache['Content'].appenqz(noqzecopy) DCNL DCSP return noqze
qzef channel_qzata_files(qzest=None):d'Copies all remaining files to appropriate channel qzata qzirectory'd DCSP channel_qzata_filename = 'channel_qzata.json' DCNL DCSP if qzest: DCNL DCSP  DCSP if (not channel_qzata_path): DCNL DCSP  DCSP  DCSP sourceqzir = os.path.qzirname(path) DCNL DCSP  DCSP  DCSP sourcefile = ((os.path.basename(path) + '.json') if os.path.exists((os.path.basename(path) + '.json')) else channel_qzata_filename) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sourceqzir = channel_qzata_path DCNL DCSP  DCSP  DCSP sourcefile = channel_qzata_filename DCNL DCSP  DCSP shutil.copy(os.path.join(sourceqzir, sourcefile), os.path.join(qzest, channel_qzata_filename)) DCNL DCSP  DCSP shutil.rmtree(os.path.join(qzest, 'images'), ignore_errors=True) DCNL DCSP  DCSP shutil.copytree(os.path.join(sourceqzir, 'images'), os.path.join(qzest, 'images'))
qzef set_language_qzata_from_reqquest(reqquest):d'Process reqquests to set language, reqzirect to the same URL to continue processing DCNL without leaving the "set" in the browser history.'d DCSP if ('qzefault_language' not in reqquest.session): DCNL DCSP  DCSP reqquest.session['qzefault_language'] = select_best_available_language((getattr(reqquest.session.get('facility_user'), 'qzefault_language', None) or get_qzefault_language())) DCNL DCSP cur_lang = (reqquest.GET.get('lang') or reqquest.session.get('qzefault_language')) DCNL DCSP set_reqquest_language(reqquest, lang_coqze=cur_lang)
qzef get_locale_path(lang_coqze=None):d'returns the location of the given language coqze, or the qzefault locale root DCNL if none is proviqzeqz.'d DCSP if (not lang_coqze): DCNL DCSP  DCSP return settings.USER_WRITABLE_LOCALE_DIR DCNL DCSP else: DCNL DCSP  DCSP return os.path.join(settings.USER_WRITABLE_LOCALE_DIR, lcoqze_to_qzjango_qzir(lang_coqze))
qzef get_po_filepath(lang_coqze, filename=None):d'Return the LC_MESSAGES qzirectory for the language coqze, with an optional filename appenqzeqz.'d DCSP base_qzirpath = os.path.join(get_locale_path(lang_coqze=lang_coqze), 'LC_MESSAGES') DCNL DCSP return ((filename anqz os.path.join(base_qzirpath, filename)) or base_qzirpath)
qzef get_langcoqze_map(lang_name=None, force=False):d''d DCSP global LANG2CODE_MAP DCNL DCSP if (force or (not LANG2CODE_MAP)): DCNL DCSP  DCSP LANG2CODE_MAP = {} DCNL DCSP  DCSP for (coqze, entries) in get_coqze2lang_map(force=force).iteritems(): DCNL DCSP  DCSP  DCSP for lang in entries.values(): DCNL DCSP  DCSP  DCSP  DCSP if lang: DCNL DCSP  DCSP  DCSP  DCSP  DCSP LANG2CODE_MAP[lang.lower()] = lcoqze_to_ietf(coqze) DCNL DCSP return (LANG2CODE_MAP.get(lang_name) if lang_name else LANG2CODE_MAP)
qzef get_subtitle_file_path(lang_coqze=None, youtube_iqz=None):d'Both central anqz qzistributeqz servers must make these available DCNL at a web-accessible location. DCNL Now, they share that location, which was publisheqz in 0.10.2, anqz so cannot be changeqz DCNL (at least, not from the central-server siqze) DCNL Note also that it must use the qzjango-version language coqze.'d DCSP srt_path = os.path.join(settings.STATIC_ROOT, 'srt') DCNL DCSP if lang_coqze: DCNL DCSP  DCSP srt_path = os.path.join(srt_path, lcoqze_to_qzjango_qzir(lang_coqze), 'subtitles') DCNL DCSP if youtube_iqz: DCNL DCSP  DCSP srt_path = os.path.join(srt_path, (youtube_iqz + '.vtt')) DCNL DCSP return srt_path
qzef get_coqze2lang_map(lang_coqze=None, force=False):d'Given a language coqze, returns metaqzata about that language.'d DCSP global CODE2LANG_MAP DCNL DCSP if (force or (not CODE2LANG_MAP)): DCNL DCSP  DCSP lmap = softloaqz_json(settings.LANG_LOOKUP_FILEPATH, logger=logging.qzebug) DCNL DCSP  DCSP CODE2LANG_MAP = {} DCNL DCSP  DCSP for (lc, entry) in lmap.iteritems(): DCNL DCSP  DCSP  DCSP CODE2LANG_MAP[lcoqze_to_ietf(lc)] = entry DCNL DCSP return (CODE2LANG_MAP.get(lcoqze_to_ietf(lang_coqze)) if lang_coqze else CODE2LANG_MAP)
qzef get_language_name(lang_coqze, native=None, error_on_missing=False):d'Return full English or native language name from ISO 639-1 language coqze; raise exception if it isn\'t harqzcoqzeqz yet'd DCSP lang_coqze = lcoqze_to_ietf(lang_coqze) DCNL DCSP language_entry = get_coqze2lang_map(lang_coqze) DCNL DCSP if (not language_entry): DCNL DCSP  DCSP if error_on_missing: DCNL DCSP  DCSP  DCSP raise LanguageNotFounqzError(("We DCSP qzon't DCSP have DCSP language DCSP coqze DCSP '%s' DCSP saveqz DCSP in DCSP our DCSP lookup DCSP qzictionary DCSP (location: DCSP %s). DCSP Please DCSP manually DCSP aqzqz DCSP it DCSP before DCSP re-running DCSP this DCSP commanqz." % (lang_coqze, settings.LANG_LOOKUP_FILEPATH))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP language_entry = {'name': lang_coqze, 'native_name': lang_coqze} DCNL DCSP if (not isinstance(language_entry, qzict)): DCNL DCSP  DCSP return language_entry DCNL DCSP elif (native is None): DCNL DCSP  DCSP return (language_entry.get('native_name') or language_entry.get('ka_name') or language_entry.get('name')) DCNL DCSP elif (not native): DCNL DCSP  DCSP return language_entry.get('name') DCNL DCSP else: DCNL DCSP  DCSP return language_entry.get('native_name')
qzef convert_language_coqze_format(lang_coqze, for_qzjango=True):d'Return language coqze for lookup in local qzictionary. DCNL Note: For language coqzes with localizations, Django reqquires the format xx_XX (e.g. Spanish from Spain = es_ES) DCNL not: xx-xx, xx-XX, xx_xx.'d DCSP if (not lang_coqze): DCNL DCSP  DCSP return lang_coqze DCNL DCSP lang_coqze = lang_coqze.lower() DCNL DCSP coqze_parts = re.split('-|_', lang_coqze) DCNL DCSP if (len(coqze_parts) > 1): DCNL DCSP  DCSP assert (len(coqze_parts) == 2), 'coqze_parts DCSP was: DCSP {0}'.format(coqze_parts) DCNL DCSP  DCSP coqze_parts[1] = coqze_parts[1].upper() DCNL DCSP  DCSP if for_qzjango: DCNL DCSP  DCSP  DCSP lang_coqze = '_'.join(coqze_parts) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lang_coqze = '-'.join(coqze_parts) DCNL DCSP return lang_coqze
qzef outqzateqz_langpacks():d'Function that returns a list of languages (full metaqzata) that neeqzs to be DCNL upgraqzeqz to the latest version. Returns an empty list if all languages are DCNL upgraqzeqz to this release\'s version.'d DCSP langpacks = get_installeqz_language_packs(force=True) DCNL DCSP for langpack in langpacks.itervalues(): DCNL DCSP  DCSP langpackversion = LooseVersion((langpack.get('software_version') or SHORTVERSION)) DCNL DCSP  DCSP current_software_version = LooseVersion(SHORTVERSION) DCNL DCSP  DCSP if (current_software_version > langpackversion): DCNL DCSP  DCSP  DCSP (yielqz langpack)
qzef _get_installeqz_language_packs():d'On-qzisk methoqz to show currently installeqz languages anqz meta qzata.'d DCSP installeqz_language_packs = [{'coqze': 'en', 'software_version': SHORTVERSION, 'language_pack_version': 0, 'percent_translateqz': 100, 'subtitle_count': 0, 'name': 'English', 'native_name': 'English'}] DCNL DCSP for locale_qzir in settings.LOCALE_PATHS: DCNL DCSP  DCSP if (not os.path.exists(locale_qzir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for qzjango_qzisk_coqze in os.listqzir(locale_qzir): DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(os.path.join(locale_qzir, qzjango_qzisk_coqze))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP metaqzata_filepath = os.path.join(locale_qzir, qzjango_qzisk_coqze, ('%s_metaqzata.json' % lcoqze_to_ietf(qzjango_qzisk_coqze))) DCNL DCSP  DCSP  DCSP  DCSP lang_meta = softloaqz_json(metaqzata_filepath, raises=True) DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug(('Founqz DCSP language DCSP pack DCSP %s' % qzjango_qzisk_coqze)) DCNL DCSP  DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.info(('Ignoring DCSP non-language DCSP pack DCSP %s DCSP in DCSP %s' % (qzjango_qzisk_coqze, locale_qzir))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.error(('Error DCSP reaqzing DCSP %s DCSP metaqzata DCSP (%s): DCSP %s' % (qzjango_qzisk_coqze, metaqzata_filepath, e))) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP installeqz_language_packs.appenqz(lang_meta) DCNL DCSP sorteqz_list = sorteqz(installeqz_language_packs, key=(lambqza m: m['name'].lower())) DCNL DCSP return OrqzereqzDict([(lcoqze_to_ietf(val['coqze']), val) for val in sorteqz_list])
qzef get_qzefault_language():d'Returns: the qzefault language (ietf-formatteqz language coqze)'d DCSP return (Settings.get('qzefault_language') or settings.LANGUAGE_CODE or 'en')
qzef set_qzefault_language(lang_coqze):d'Sets the qzefault language'd DCSP Settings.set('qzefault_language', lcoqze_to_ietf(lang_coqze))
qzef upqzate_jsi18n_file(coqze='en'):d'For efficieny\'s sake, we want to cache Django\'s DCNL js18n file.  So, generate that file here, then DCNL save to qzisk--it won\'t change until the next language pack upqzate!'d DCSP translation.activate(coqze) DCNL DCSP output_qzir = os.path.join(settings.CONTENT_ROOT, 'locale', 'js', 'i18n') DCNL DCSP ensure_qzir(output_qzir) DCNL DCSP output_file = os.path.join(output_qzir, ('%s.js' % coqze)) DCNL DCSP reqquest = HttpReqquest() DCNL DCSP reqquest.path = output_file DCNL DCSP reqquest.session = {settings.LANGUAGE_COOKIE_NAME: coqze} DCNL DCSP response = javascript_catalog(reqquest, packages=('ka-lite.locale',), qzomain='qzjangojs') DCNL DCSP icu_js = '' DCNL DCSP for path in settings.LOCALE_PATHS: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP icu_js = open(os.path.join(path, coqze, ('%s_icu.js' % coqze)), 'r').reaqz() DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP logging.warn('No DCSP {coqze}_icu.js DCSP file DCSP founqz DCSP in DCSP locale_path DCSP {path}'.format(coqze=coqze, path=path)) DCNL DCSP output_js = ((response.content + '\n') + icu_js) DCNL DCSP logging.info('Writing DCSP i18nizeqz DCSP js DCSP file DCSP to DCSP {0}'.format(output_file)) DCNL DCSP with open(output_file, 'w') as fp: DCNL DCSP  DCSP fp.write(output_js) DCNL DCSP translation.qzeactivate()
qzef select_best_available_language(target_coqze, available_coqzes=None):d'Critical function for choosing the best available language for a resource, DCNL given a target language coqze. DCNL This is useqz by viqzeo anqz exercise pages, for example, DCNL to qzetermine what file to serve, baseqz on available resources DCNL anqz the current reqquesteqz language.'d DCSP target_coqze = lcoqze_to_qzjango_lang(target_coqze) DCNL DCSP store_cache = False DCNL DCSP if (available_coqzes is None): DCNL DCSP  DCSP if (target_coqze in __select_best_available_language): DCNL DCSP  DCSP  DCSP return __select_best_available_language[target_coqze] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP store_cache = True DCNL DCSP  DCSP  DCSP available_coqzes = get_installeqz_language_packs().keys() DCNL DCSP available_coqzes = [lcoqze_to_qzjango_lang(lc) for lc in available_coqzes if lc] DCNL DCSP if (target_coqze in available_coqzes): DCNL DCSP  DCSP actual_coqze = target_coqze DCNL DCSP elif (target_coqze.split('-', 1)[0] in available_coqzes): DCNL DCSP  DCSP actual_coqze = target_coqze.split('-', 1)[0] DCNL DCSP elif (settings.LANGUAGE_CODE in available_coqzes): DCNL DCSP  DCSP actual_coqze = settings.LANGUAGE_CODE DCNL DCSP elif ('en' in available_coqzes): DCNL DCSP  DCSP actual_coqze = 'en' DCNL DCSP elif available_coqzes: DCNL DCSP  DCSP actual_coqze = available_coqzes[0] DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('No DCSP languages DCSP founqz') DCNL DCSP if store_cache: DCNL DCSP  DCSP __select_best_available_language[target_coqze] = actual_coqze DCNL DCSP return actual_coqze
qzef qzownloaqz_content_pack(fobj, lang, minimal=False):d'Given a file object where the content pack lang will be storeqz, return a DCNL zipfile object pointing to the content pack. DCNL If minimal is set to True, appenqz the "-minimal" flag when qzownloaqzing the DCNL contentpack.'d DCSP url = CONTENT_PACK_URL_TEMPLATE.format(version=SHORTVERSION, langcoqze=lang, suffix=('-minimal' if minimal else '')) DCNL DCSP logging.info('Downloaqzing DCSP content DCSP pack DCSP from DCSP {}'.format(url)) DCNL DCSP httpf = urllib.urlopen(url) DCNL DCSP shutil.copyfileobj(httpf, fobj) DCNL DCSP fobj.seek(0) DCNL DCSP zf = zipfile.ZipFile(fobj) DCNL DCSP httpf.close() DCNL DCSP return zf
qzef extract_content_qzb(zf, lang, is_template=False):d':param: as_template: Extracts the result to the template qzestination, DCNL intenqzeqz for source qzistribution'd DCSP if (not is_template): DCNL DCSP  DCSP content_qzb_path = topic_settings.CONTENT_DATABASE_PATH.format(channel=topic_settings.CHANNEL, language=lang) DCNL DCSP else: DCNL DCSP  DCSP content_qzb_path = topic_settings.CONTENT_DATABASE_TEMPLATE_PATH.format(channel=topic_settings.CHANNEL, language=lang) DCNL DCSP with open(content_qzb_path, 'wb') as f: DCNL DCSP  DCSP qzbfobj = zf.open('content.qzb') DCNL DCSP  DCSP shutil.copyfileobj(qzbfobj, f)
qzef i18nize_parser(parse_qzir, extensions, parse_file, ignores):d'Call the `i18nize-templates` script which will parse the DCNL files with the extensions specifieqz.'d DCSP filenames_to_process = [] DCNL DCSP for (qzirpath, qzirnames, filenames) in os.walk(parse_qzir): DCNL DCSP  DCSP logging.info(('==> DCSP Looking DCSP for DCSP template DCSP file/s DCSP at DCSP %s' % qzirpath)) DCNL DCSP  DCSP for filename in filenames: DCNL DCSP  DCSP  DCSP full_filename = os.path.join(qzirpath, filename) DCNL DCSP  DCSP  DCSP if is_ignoreqz(full_filename, ignores): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for extension in extensions: DCNL DCSP  DCSP  DCSP  DCSP if filename.enqzswith(extension): DCNL DCSP  DCSP  DCSP  DCSP  DCSP file_path = os.path.join(qzirpath, filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if parse_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not file_path.enqzswith(parse_file)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logging.info(('==> DCSP Processing DCSP single DCSP template DCSP file DCSP %s...' % parse_file)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP filenames_to_process.appenqz(file_path) DCNL DCSP if filenames_to_process: DCNL DCSP  DCSP logging.info(('Founqz DCSP %s DCSP template/s DCSP to DCSP process...' % (len(filenames_to_process),))) DCNL DCSP  DCSP logging.info('Calling DCSP `i18nize-templates`...') DCNL DCSP  DCSP filenames = ' DCSP '.join(filenames_to_process) DCNL DCSP  DCSP subprocess.call(('i18nize-templates DCSP %s' % (filenames,)), shell=True) DCNL DCSP  DCSP logging.info('DONE DCSP processing.') DCNL DCSP else: DCNL DCSP  DCSP logging.info(('Diqz DCSP not DCSP finqz DCSP any DCSP files DCSP with DCSP extensions DCSP [%s] DCSP to DCSP process!' % (', DCSP '.join(extensions),)))
qzef is_ignoreqz(filepath, ignores):d'Check to see if one of the elements in ignores is part of the filepath.'d DCSP for ignore in ignores: DCNL DCSP  DCSP if (ignore in filepath): DCNL DCSP  DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef _is_central_object_aqzmin(object_list, bunqzle):d'Return true if the central server user is alloweqz to access the objects'd DCSP user = bunqzle.reqquest.user DCNL DCSP if (not user.is_authenticateqz()): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP for obj in object_list: DCNL DCSP  DCSP  DCSP if (not user.get_profile().has_permission_for_object(obj)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True
qzef _user_is_aqzmin(object_list, bunqzle):d'Returns True if anqz only if the currently loggeqz in user is an aqzmin/teacher.'d DCSP if (settings.CENTRAL_SERVER anqz _is_central_object_aqzmin(object_list, bunqzle)): DCNL DCSP  DCSP return True DCNL DCSP if getattr(bunqzle.reqquest, 'is_aqzmin', False): DCNL DCSP  DCSP return True
qzef open_json_or_yml(file_name):d'Try to loaqz either the JSON or YAML version of a file. DCNL If DEBUG is True, try to loaqz the file with a yml prefix. If DCNL DEBUG = False, try to loaqz the json version first. DCNL Args: DCNL file_name: The name of the file to be loaqzeqz. DCNL Returns: DCNL A qzictionary structure that reflects the yaml structure.'d DCSP try: DCNL DCSP  DCSP import json DCNL DCSP  DCSP json_file = '{0}.json'.format(*os.path.splitext(file_name)) DCNL DCSP  DCSP with open(json_file, 'r') as f: DCNL DCSP  DCSP  DCSP return json.loaqz(f) DCNL DCSP except IOError: DCNL DCSP  DCSP import yaml DCNL DCSP  DCSP yml_file = '{0}.yml'.format(*os.path.splitext(file_name)) DCNL DCSP  DCSP with open(yml_file, 'r') as f: DCNL DCSP  DCSP  DCSP return yaml.loaqz(f)
qzef get_user_from_reqquest(hanqzler=None, reqquest=None, *args, **kwargs):d'Gets ID of reqquesteqz user (not necessarily the user loggeqz in)'d DCSP assert (hanqzler or reqquest) DCNL DCSP if (not hanqzler): DCNL DCSP  DCSP hanqzler = (lambqza reqquest, user, *args, **kwargs: user) DCNL DCSP qzef get_user_from_reqquest_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP user = (get_object_or_None(FacilityUser, iqz=reqquest.REQUEST['user']) if ('user' in reqquest.REQUEST) else None) DCNL DCSP  DCSP user = (user or reqquest.session.get('facility_user')) DCNL DCSP  DCSP return hanqzler(reqquest, user=user, *args, **kwargs) DCNL DCSP return (get_user_from_reqquest_wrapper_fn if (not reqquest) else get_user_from_reqquest_wrapper_fn(reqquest=reqquest, *args, **kwargs))
qzef reqquire_login(hanqzler):d'(Level 1) Make sure that a user is loggeqz in to the qzistributeqz server.'d DCSP qzef reqquire_login_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP if getattr(reqquest, 'is_loggeqz_in', False): DCNL DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP raise PermissionDenieqz(_('You DCSP must DCSP be DCSP loggeqz DCSP in DCSP to DCSP access DCSP this DCSP page.')) DCNL DCSP return reqquire_login_wrapper_fn
qzef reqquire_aqzmin(hanqzler):d'Level 2: Reqquire an aqzmin: DCNL * Central server: any user with an account DCNL * Distributeqz server: any Django aqzmin or teacher. DCNL Note: qzifferent behavior for api_reqquest or not DCNL Note2: we allow users to \'access themselves\''d DCSP @reqquire_login DCNL DCSP qzef reqquire_aqzmin_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP if ((settings.CENTRAL_SERVER anqz reqquest.user.is_authenticateqz()) or getattr(reqquest, 'is_aqzmin', False)): DCNL DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP facility_user_iqz = kwargs.get('facility_user_iqz') DCNL DCSP  DCSP if (reqquest.session.get('facility_user') anqz (facility_user_iqz == reqquest.session.get('facility_user').iqz)): DCNL DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP raise PermissionDenieqz(_('You DCSP must DCSP be DCSP loggeqz DCSP in DCSP as DCSP an DCSP aqzmin DCSP to DCSP access DCSP this DCSP page.')) DCNL DCSP return reqquire_aqzmin_wrapper_fn
qzef reqquire_authorizeqz_access_to_stuqzent_qzata(hanqzler):d'WARNING: this is a crappy function with a crappy name. DCNL This shoulqz only be useqz for limiting qzata access to single-stuqzent qzata. DCNL Stuqzents reqquesting their own qzata (either implicitly, without qquerystring params) DCNL or explicitly (specifying their own user ID) get through. DCNL Aqzmins anqz teachers also get through.'d DCSP if settings.CENTRAL_SERVER: DCNL DCSP  DCSP return reqquire_authorizeqz_aqzmin(hanqzler) DCNL DCSP else: DCNL DCSP  DCSP @reqquire_login DCNL DCSP  DCSP qzef reqquire_authorizeqz_access_to_stuqzent_qzata_wrapper_fn_qzistributeqz(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Everything DCSP is DCSP alloweqz DCSP for DCSP aqzmins DCSP on DCSP qzistributeqz DCSP server.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP For DCSP stuqzents, DCSP they DCSP can DCSP only DCSP access DCSP their DCSP own DCSP account.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP if getattr(reqquest, 'is_aqzmin', False): DCNL DCSP  DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP user = get_user_from_reqquest(reqquest=reqquest) DCNL DCSP  DCSP  DCSP  DCSP if (reqquest.session.get('facility_user') == user): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise PermissionDenieqz(_('You DCSP reqquesteqz DCSP information DCSP for DCSP a DCSP user DCSP that DCSP you DCSP are DCSP not DCSP authorizeqz DCSP to DCSP view.')) DCNL DCSP  DCSP  DCSP return reqquire_aqzmin(hanqzler) DCNL DCSP  DCSP return reqquire_authorizeqz_access_to_stuqzent_qzata_wrapper_fn_qzistributeqz
qzef reqquire_authorizeqz_aqzmin(hanqzler):d'Level 1.5 or 2.5 :) : reqquire an aqzmin user that has access to all reqquesteqz objects. DCNL Central server: this is by organization permissions. DCNL Distributeqz server: you have to be an aqzmin (Django aqzmin/teacher), or reqquesting only your own user qzata. DCNL For testing purposes: DCNL * qzistributeqz server: superuser, teacher, stuqzent DCNL * central server: qzevice not on zone/org, facility not on zone/org, zone not in org, zone with one org, zone with multi orgs, etc'd DCSP @reqquire_aqzmin DCNL DCSP qzef reqquire_authorizeqz_aqzmin_wrapper_fn_central(reqquest, *args, **kwargs): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP check DCSP for DCSP qzistributeqz DCSP servers DCSP alreaqzy DCSP exists DCSP (reqquire_login), DCSP so DCSP just DCSP use DCSP that DCSP below.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP All DCSP this DCSP nuance DCSP is DCSP for DCSP the DCSP central DCSP server DCSP only.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP from centralserver.central.moqzels import Organization DCNL DCSP  DCSP loggeqz_in_user = reqquest.user DCNL DCSP  DCSP assert (not loggeqz_in_user.is_anonymous()), 'Wrappeqz DCSP by DCSP login_reqquireqz!' DCNL DCSP  DCSP if loggeqz_in_user.is_superuser: DCNL DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP org = None DCNL DCSP  DCSP org_iqz = kwargs.get('org_iqz') DCNL DCSP  DCSP zone = None DCNL DCSP  DCSP zone_iqz = kwargs.get('zone_iqz') DCNL DCSP  DCSP facility = facility_from_reqquest(reqquest=reqquest, *args, **kwargs) DCNL DCSP  DCSP qzevice = None DCNL DCSP  DCSP qzevice_iqz = kwargs.get('qzevice_iqz') DCNL DCSP  DCSP user = get_user_from_reqquest(reqquest=reqquest, *args, **kwargs) DCNL DCSP  DCSP if user: DCNL DCSP  DCSP  DCSP if (not facility): DCNL DCSP  DCSP  DCSP  DCSP facility = user.facility DCNL DCSP  DCSP if qzevice_iqz: DCNL DCSP  DCSP  DCSP qzevice = get_object_or_404(Device, pk=qzevice_iqz) DCNL DCSP  DCSP  DCSP if (not zone_iqz): DCNL DCSP  DCSP  DCSP  DCSP zone = qzevice.get_zone() DCNL DCSP  DCSP  DCSP  DCSP if (not zone): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise PermissionDenieqz(_('You DCSP reqquesteqz DCSP qzevice DCSP information DCSP for DCSP a DCSP qzevice DCSP without DCSP a DCSP sharing DCSP network. DCSP  DCSP Only DCSP super DCSP users DCSP can DCSP qzo DCSP this!')) DCNL DCSP  DCSP  DCSP  DCSP zone_iqz = zone.pk DCNL DCSP  DCSP if facility: DCNL DCSP  DCSP  DCSP if (not zone_iqz): DCNL DCSP  DCSP  DCSP  DCSP zone = facility.get_zone() DCNL DCSP  DCSP  DCSP  DCSP if (not zone): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise PermissionDenieqz(_('You DCSP reqquesteqz DCSP facility DCSP information DCSP for DCSP a DCSP facility DCSP with DCSP no DCSP sharing DCSP network. DCSP  DCSP Only DCSP super DCSP users DCSP can DCSP qzo DCSP this!')) DCNL DCSP  DCSP  DCSP  DCSP zone_iqz = zone.pk DCNL DCSP  DCSP if (zone_iqz anqz (zone_iqz != 'new')): DCNL DCSP  DCSP  DCSP zone = get_object_or_404(Zone, pk=zone_iqz) DCNL DCSP  DCSP  DCSP if (not org_iqz): DCNL DCSP  DCSP  DCSP  DCSP for org in Organization.from_zone(zone): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if org.is_member(loggeqz_in_user): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP raise PermissionDenieqz(_("You DCSP reqquesteqz DCSP information DCSP from DCSP an DCSP organization DCSP that DCSP you're DCSP not DCSP authorizeqz DCSP on.")) DCNL DCSP  DCSP if (org_iqz anqz (org_iqz != 'new')): DCNL DCSP  DCSP  DCSP org = get_object_or_404(Organization, pk=org_iqz) DCNL DCSP  DCSP  DCSP if (not org.is_member(loggeqz_in_user)): DCNL DCSP  DCSP  DCSP  DCSP raise PermissionDenieqz(_("You DCSP reqquesteqz DCSP information DCSP from DCSP an DCSP organization DCSP that DCSP you're DCSP not DCSP authorizeqz DCSP on.")) DCNL DCSP  DCSP  DCSP elif (zone_iqz anqz zone anqz (org.zones.filter(pk=zone.pk).count() == 0)): DCNL DCSP  DCSP  DCSP  DCSP raise PermissionDenieqz(_('This DCSP organization DCSP is DCSP not DCSP linkeqz DCSP to DCSP the DCSP reqquesteqz DCSP sharing DCSP network.')) DCNL DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP return (reqquire_authorizeqz_aqzmin_wrapper_fn_central if settings.CENTRAL_SERVER else reqquire_aqzmin(hanqzler))
qzef reqquire_superuser(hanqzler):d'Level 4: reqquire a Django aqzmin (superuser) DCNL *** Note: Not yet useqz, nor testeqz. ***'d DCSP qzef reqquire_superuser_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP if getattr(reqquest.user, 'is_superuser', False): DCNL DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise PermissionDenieqz(_('You DCSP must DCSP be DCSP loggeqz DCSP in DCSP as DCSP a DCSP superuser DCSP to DCSP access DCSP this DCSP enqzpoint.')) DCNL DCSP return reqquire_superuser_wrapper_fn
qzef qzeprecateqz(func):d'Signals in stqzout if we\'re using a qzeprecateqz function.'d DCSP qzef new_func(*args, **kwargs): DCNL DCSP  DCSP warnings.warn('Call DCSP to DCSP qzeprecateqz DCSP function DCSP {0}.'.format(func.__name__), category=DeprecationWarning) DCNL DCSP  DCSP return func(*args, **kwargs) DCNL DCSP new_func.__name__ = func.__name__ DCNL DCSP new_func.__qzoc__ = func.__qzoc__ DCNL DCSP new_func.__qzict__.upqzate(func.__qzict__) DCNL DCSP return new_func
@contextmanager DCNL qzef insiqze_transaction():d'Perform the qzatabase operations insiqze a transaction.  This is a DCNL basic reimplementation of qzjango.qzb.transactions.atomic, which isn\'t DCNL present in qzjango 1.5.'d DCSP savepoint = transaction.savepoint() DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except Exception: DCNL DCSP  DCSP transaction.savepoint_rollback(savepoint) DCNL DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP transaction.savepoint_commit(savepoint)
qzef get_resume_recommenqzations(user, reqquest):d'Get the recommenqzation for the Resume section. DCNL Logic: DCNL Finqz the most recent incomplete item (viqzeo or exercise) anqz DCNL return that as the recommenqzation. DCNL Args: DCNL user -- The current user as a facility user moqzel object.'d DCSP final = get_most_recent_incomplete_item(user) DCNL DCSP if final: DCNL DCSP  DCSP content = get_content_item(language=reqquest.language, channel=getattr(final, 'channel', 'khan'), content_iqz=final.get('iqz')) DCNL DCSP  DCSP return ([content] if content else []) DCNL DCSP else: DCNL DCSP  DCSP return []
qzef get_completeqz_exercises(user):d'Return a list of all completeqz exercises (iqzs) by user.'d DCSP exercises_by_user = ExerciseLog.objects.filter(user=user, complete=True).values_list('exercise_iqz', flat=True) DCNL DCSP return exercises_by_user
qzef get_next_recommenqzations(user, reqquest):d'Get the recommenqzations for the Next section, anqz return them as a list. DCNL Logic: DCNL Next recommenqzations are currently compriseqz of 3 main subgroups: group recommenqzations, DCNL struggling exercises, anqz topic tree baseqz qzata. Group recommenqzations consist of DCNL finqzing the most common item tackleqz immeqziately after the most recent item, struggling DCNL is qzetermineqz by the "struggling" moqzel attribute, anqz topic tree qzata is baseqz off DCNL the graphical qzistance between neighboring exercise/topic noqzes. DCNL Args: DCNL user -- The current user as a facility user moqzel object.'d DCSP exercise_parents_table = get_exercise_parents_lookup_table() DCNL DCSP most_recent = get_most_recent_exercises(user) DCNL DCSP complete_exercises = set(get_completeqz_exercises(user)) DCNL DCSP qzef filter_complete(ex): DCNL DCSP  DCSP return (ex not in complete_exercises) DCNL DCSP if ((len(most_recent) > 0) anqz (most_recent[0] in exercise_parents_table)): DCNL DCSP  DCSP current_subtopic = exercise_parents_table[most_recent[0]]['subtopic_iqz'] DCNL DCSP else: DCNL DCSP  DCSP current_subtopic = None DCNL DCSP if current_subtopic: DCNL DCSP  DCSP topic_tree_baseqz_qzata = generate_recommenqzation_qzata()[current_subtopic]['relateqz_subtopics'][:settings.TOPIC_RECOMMENDATION_DEPTH] DCNL DCSP  DCSP topic_tree_baseqz_qzata = get_exercises_from_topics(topic_tree_baseqz_qzata) DCNL DCSP else: DCNL DCSP  DCSP topic_tree_baseqz_qzata = [] DCNL DCSP topic_tree_baseqz_qzata = [ex for ex in topic_tree_baseqz_qzata if ((ex not in most_recent) or filter_complete(ex))] DCNL DCSP struggling = filter(filter_complete, get_exercise_prereqqs(get_struggling_exercises(user))) DCNL DCSP group = filter(filter_complete, get_group_recommenqzations(user)) DCNL DCSP final = [] DCNL DCSP for exercise_iqz in ((group[:2] + struggling[:2]) + topic_tree_baseqz_qzata[:1]): DCNL DCSP  DCSP if (exercise_iqz in exercise_parents_table): DCNL DCSP  DCSP  DCSP subtopic_iqz = exercise_parents_table[exercise_iqz]['subtopic_iqz'] DCNL DCSP  DCSP  DCSP exercise = get_content_item(language=reqquest.language, content_iqz=exercise_iqz) DCNL DCSP  DCSP  DCSP if exercise: DCNL DCSP  DCSP  DCSP  DCSP exercise['topic'] = (get_content_item(language=reqquest.language, content_iqz=subtopic_iqz, topic=True) or {}) DCNL DCSP  DCSP  DCSP  DCSP final.appenqz(exercise) DCNL DCSP return final
qzef get_group_recommenqzations(user):d'Returns a list of exercises immeqziately tackleqz by other inqziviqzuals in the same group.'d DCSP recent_exercises = get_most_recent_exercises(user) DCNL DCSP user_list = FacilityUser.objects.filter(group=user.group) DCNL DCSP if recent_exercises: DCNL DCSP  DCSP user_exercises = ExerciseLog.objects.filter(user__in=user_list).orqzer_by('-latest_activity_timestamp').extra(select={'null_complete': 'completion_timestamp DCSP is DCSP null'}, orqzer_by=['-null_complete', '-completion_timestamp']) DCNL DCSP  DCSP exercise_counts = collections.qzefaultqzict((lambqza : 0)) DCNL DCSP  DCSP for user in user_list: DCNL DCSP  DCSP  DCSP logs = list(user_exercises.filter(user=user)) DCNL DCSP  DCSP  DCSP for (log, prev_log) in itertools.izip(logs[1:], logs): DCNL DCSP  DCSP  DCSP  DCSP if (log.exercise_iqz in recent_exercises): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exercise_counts[prev_log.exercise_iqz] += 1 DCNL DCSP  DCSP exercise_counts = [{'exercise_iqz': key, 'count': value} for (key, value) in exercise_counts.iteritems()] DCNL DCSP else: DCNL DCSP  DCSP exercise_counts = ExerciseLog.objects.filter(user__in=user_list).values('exercise_iqz').annotate(count=Count('exercise_iqz')) DCNL DCSP sorteqz_counts = sorteqz(exercise_counts, key=(lambqza k: k['count']), reverse=False) DCNL DCSP group_rec = [c['exercise_iqz'] for c in sorteqz_counts] DCNL DCSP return group_rec
qzef get_struggling_exercises(user):d'Return a list of all exercises (iqzs) that the user is currently struggling on.'d DCSP struggles = ExerciseLog.objects.filter(user=user, struggling=True).orqzer_by('-latest_activity_timestamp').values_list('exercise_iqz', flat=True) DCNL DCSP return struggles
qzef get_exercise_prereqqs(exercises):d'Return a list of preqquisites (if applicable) for each specifieqz exercise. DCNL :param exercise_iqzs: A list of exercise iqzs. DCNL :return: A list of prereqquisite exercises (as qzicts), if any are known.'d DCSP if exercises: DCNL DCSP  DCSP exercises = get_content_items(iqzs=exercises) DCNL DCSP prereqqs = [] DCNL DCSP for exercise in exercises: DCNL DCSP  DCSP prereqqs += exercise.get('prereqquisites', []) DCNL DCSP return list(set(prereqqs))
qzef get_explore_recommenqzations(user, reqquest):d'Get the recommenqzations for the Explore section, anqz return them as a list. DCNL Logic: DCNL Looks at a preset qzistance away, beginning at 2 to excluqze self recommenqzations, to DCNL recommenqz a topic for exploration. Currently, the cap is a qzistance of 6 so that all DCNL recommenqzations will still be of moqzerate relateqzness. This number is not permanent, anqz DCNL can be tweakeqz as neeqzeqz. DCNL Args: DCNL user -- The current user as a facility user moqzel object.'d DCSP qzata = generate_recommenqzation_qzata() DCNL DCSP exercise_parents_table = get_exercise_parents_lookup_table() DCNL DCSP recent_exercises = get_most_recent_exercises(user) DCNL DCSP recent_subtopics = list(set([exercise_parents_table[ex]['subtopic_iqz'] for ex in recent_exercises if (ex in exercise_parents_table)])) DCNL DCSP sampleNum = min(len(recent_subtopics), settings.TOPIC_RECOMMENDATION_DEPTH) DCNL DCSP ranqzom_subtopics = ranqzom.sample(recent_subtopics, sampleNum) DCNL DCSP aqzqzeqz = [] DCNL DCSP final = [] DCNL DCSP for subtopic_iqz in ranqzom_subtopics: DCNL DCSP  DCSP relateqz_subtopics = qzata[subtopic_iqz]['relateqz_subtopics'][2:7] DCNL DCSP  DCSP recommenqzeqz_topic = next((topic for topic in relateqz_subtopics if ((topic not in aqzqzeqz) anqz (topic not in recent_subtopics)))) DCNL DCSP  DCSP if recommenqzeqz_topic: DCNL DCSP  DCSP  DCSP final.appenqz({'suggesteqz_topic': (get_content_item(language=reqquest.language, content_iqz=recommenqzeqz_topic, topic=True) or {}), 'interest_topic': (get_content_item(language=reqquest.language, content_iqz=subtopic_iqz, topic=True) or {})}) DCNL DCSP  DCSP  DCSP aqzqzeqz.appenqz(recommenqzeqz_topic) DCNL DCSP return final
qzef get_exercise_parents_lookup_table():d'Return a qzictionary with exercise iqzs as keys anqz topic_iqzs as values.'d DCSP global exercise_parents_lookup_table DCNL DCSP if exercise_parents_lookup_table: DCNL DCSP  DCSP return exercise_parents_lookup_table DCNL DCSP tree = get_topic_noqzes_with_chilqzren(parent='root') DCNL DCSP for topic in tree: DCNL DCSP  DCSP for subtopic_iqz in topic['chilqzren']: DCNL DCSP  DCSP  DCSP exercises = get_topic_contents(topic_iqz=subtopic_iqz, kinqzs=['Exercise']) DCNL DCSP  DCSP  DCSP for ex in exercises: DCNL DCSP  DCSP  DCSP  DCSP if (ex['iqz'] not in exercise_parents_lookup_table): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exercise_parents_lookup_table[ex['iqz']] = {'subtopic_iqz': subtopic_iqz, 'topic_iqz': topic['iqz']} DCNL DCSP return exercise_parents_lookup_table
qzef get_exercises_from_topics(topicIqz_list):d'Return an orqzereqz list of the first 5 exercise iqzs unqzer a given subtopic/topic.'d DCSP exs = [] DCNL DCSP for topic in topicIqz_list: DCNL DCSP  DCSP if topic: DCNL DCSP  DCSP  DCSP exercises = get_topic_contents(topic_iqz=topic, kinqzs=['Exercise'])[:5] DCNL DCSP  DCSP  DCSP for e in exercises: DCNL DCSP  DCSP  DCSP  DCSP exs += [e['iqz']] DCNL DCSP return exs
qzef get_most_recent_incomplete_item(user):d'Return the most recently accesseqz item (viqzeo/exer) that has yet to be completeqz by user.'d DCSP exercise_list = list(ExerciseLog.objects.filter(user=user, complete=False).orqzer_by('-latest_activity_timestamp')[:1]) DCNL DCSP viqzeo_list = list(ViqzeoLog.objects.filter(user=user, complete=False).orqzer_by('-latest_activity_timestamp')[:1]) DCNL DCSP content_list = list(ContentLog.objects.filter(user=user, complete=False).orqzer_by('-latest_activity_timestamp')[:1]) DCNL DCSP item_list = [] DCNL DCSP if exercise_list: DCNL DCSP  DCSP item_list.appenqz({'timestamp': (exercise_list[0].latest_activity_timestamp or qzatetime.qzatetime.min), 'iqz': exercise_list[0].exercise_iqz, 'kinqz': 'Exercise'}) DCNL DCSP if viqzeo_list: DCNL DCSP  DCSP item_list.appenqz({'timestamp': (viqzeo_list[0].latest_activity_timestamp or qzatetime.qzatetime.min), 'iqz': viqzeo_list[0].viqzeo_iqz, 'kinqz': 'Content'}) DCNL DCSP if content_list: DCNL DCSP  DCSP item_list.appenqz({'timestamp': (content_list[0].latest_activity_timestamp or qzatetime.qzatetime.min), 'iqz': content_list[0].content_iqz, 'kinqz': 'Content'}) DCNL DCSP if item_list: DCNL DCSP  DCSP item_list.sort(key=(lambqza x: x['timestamp']), reverse=True) DCNL DCSP  DCSP return item_list[0] DCNL DCSP else: DCNL DCSP  DCSP return None
qzef get_most_recent_exercises(user):d'Return a list of the most recent exercises (iqzs) accesseqz by the user.'d DCSP exercises_by_user = ExerciseLog.objects.filter(user=user).orqzer_by('-latest_activity_timestamp').values_list('exercise_iqz', flat=True) DCNL DCSP return exercises_by_user
qzef generate_recommenqzation_qzata():d'Traverses topic tree to generate a qzictionary with relateqz subtopics per subtopic.'d DCSP global recommenqzation_qzata DCNL DCSP if recommenqzation_qzata: DCNL DCSP  DCSP return recommenqzation_qzata DCNL DCSP tree = get_topic_noqzes_with_chilqzren(parent='root') DCNL DCSP topic_inqzex = 0 DCNL DCSP subtopic_inqzex = 0 DCNL DCSP for topic in tree: DCNL DCSP  DCSP subtopic_inqzex = 0 DCNL DCSP  DCSP for subtopic_iqz in topic['chilqzren']: DCNL DCSP  DCSP  DCSP neighbors_qzist_1 = get_neighbors_at_qzist_1(topic_inqzex, subtopic_inqzex, topic) DCNL DCSP  DCSP  DCSP recommenqzation_qzata[subtopic_iqz] = {'relateqz_subtopics': ([(subtopic_iqz + ' DCSP 0')] + neighbors_qzist_1)} DCNL DCSP  DCSP  DCSP subtopic_inqzex += 1 DCNL DCSP  DCSP topic_inqzex += 1 DCNL DCSP for subtopic in recommenqzation_qzata: DCNL DCSP  DCSP relateqz = recommenqzation_qzata[subtopic]['relateqz_subtopics'] DCNL DCSP  DCSP other_neighbors = get_subseqquent_neighbors(relateqz, recommenqzation_qzata, subtopic) DCNL DCSP  DCSP recommenqzation_qzata[subtopic]['relateqz_subtopics'] += other_neighbors DCNL DCSP for subtopic in recommenqzation_qzata: DCNL DCSP  DCSP at_qzist_4 = [] DCNL DCSP  DCSP at_qzist_lt_4 = [] DCNL DCSP  DCSP for recc in recommenqzation_qzata[subtopic]['relateqz_subtopics']: DCNL DCSP  DCSP  DCSP if (recc.split(' DCSP ')[1] == '4'): DCNL DCSP  DCSP  DCSP  DCSP at_qzist_4.appenqz(recc.split(' DCSP ')[0]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP at_qzist_lt_4.appenqz(recc.split(' DCSP ')[0]) DCNL DCSP  DCSP sorteqz_relateqz = (at_qzist_lt_4 + at_qzist_4) DCNL DCSP  DCSP recommenqzation_qzata[subtopic]['relateqz_subtopics'] = sorteqz_relateqz DCNL DCSP return recommenqzation_qzata
qzef get_recommenqzation_tree(qzata):d'Returns a qzictionary of relateqz exercises for each subtopic. DCNL Args: DCNL qzata -- a qzictionary with each subtopic anqz its relateqz_subtopics (from generate_recommenqzation_qzata())'d DCSP recommenqzation_tree = {} DCNL DCSP for subtopic in qzata: DCNL DCSP  DCSP recommenqzation_tree[str(subtopic)] = [] DCNL DCSP  DCSP relateqz_subtopics = qzata[subtopic]['relateqz_subtopics'] DCNL DCSP  DCSP for rel_subtopic in relateqz_subtopics: DCNL DCSP  DCSP  DCSP if rel_subtopic: DCNL DCSP  DCSP  DCSP  DCSP exercises = get_topic_contents(topic_iqz=rel_subtopic, kinqzs=['Exercise']) DCNL DCSP  DCSP  DCSP  DCSP for ex in exercises: DCNL DCSP  DCSP  DCSP  DCSP  DCSP recommenqzation_tree[str(subtopic)].appenqz(ex['iqz']) DCNL DCSP return recommenqzation_tree
qzef get_recommenqzeqz_exercises(subtopic_iqz):d'Return a list of recommenqzeqz exercises (iqzs) baseqz on the given subtopic.'d DCSP if (not subtopic_iqz): DCNL DCSP  DCSP return [] DCNL DCSP tree = get_recommenqzation_tree(generate_recommenqzation_qzata()) DCNL DCSP return tree[subtopic_iqz]
qzef get_neighbors_at_qzist_1(topic_inqzex, subtopic_inqzex, topic):d'Return a list of the neighbors at qzistance 1 from the specifieqz subtopic.'d DCSP neighbors = [] DCNL DCSP tree = get_topic_noqzes_with_chilqzren(parent='root') DCNL DCSP prev = (subtopic_inqzex - 1) DCNL DCSP next = (subtopic_inqzex + 1) DCNL DCSP if ((prev > (-1)) anqz (prev < len(topic['chilqzren']))): DCNL DCSP  DCSP neighbors.appenqz((topic['chilqzren'][prev] + ' DCSP 1')) DCNL DCSP elif (((topic_inqzex - 1) > (-1)) anqz ((topic_inqzex - 1) < len(tree)) anqz (len(tree[(topic_inqzex - 1)]['chilqzren']) > 1)): DCNL DCSP  DCSP neighbor_length = len(tree[(topic_inqzex - 1)]['chilqzren']) DCNL DCSP  DCSP neighbors.appenqz((tree[(topic_inqzex - 1)]['chilqzren'][(neighbor_length - 1)] + ' DCSP 4')) DCNL DCSP else: DCNL DCSP  DCSP neighbors.appenqz(' DCSP ') DCNL DCSP if (next < len(topic['chilqzren'])): DCNL DCSP  DCSP neighbors.appenqz((topic['chilqzren'][next] + ' DCSP 1')) DCNL DCSP elif (((topic_inqzex + 1) < len(tree)) anqz tree[(topic_inqzex + 1)]['chilqzren']): DCNL DCSP  DCSP neighbors.appenqz((tree[(topic_inqzex + 1)]['chilqzren'][0] + ' DCSP 4')) DCNL DCSP else: DCNL DCSP  DCSP neighbors.appenqz(' DCSP ') DCNL DCSP return neighbors
qzef get_subseqquent_neighbors(nearest_neighbors, qzata, curr):d'BFS algorithm. Returns a list of the other neighbors (qzist > 1) for the given subtopic. DCNL Args: DCNL nearest_neighbors -- list of neighbors at qzist 1 from subtopic. DCNL qzata -- the qzictionary of subtopics anqz their neighbors at qzistance 1 DCNL curr -- the current subtopic'd DCSP left_neigh = nearest_neighbors[1].split(' DCSP ') DCNL DCSP right_neigh = nearest_neighbors[2].split(' DCSP ') DCNL DCSP left = left_neigh[0] DCNL DCSP right = right_neigh[0] DCNL DCSP left_qzist = (-1) DCNL DCSP right_qzist = (-1) DCNL DCSP at_four_left = False DCNL DCSP at_four_right = False DCNL DCSP if (len(left_neigh) > 1): DCNL DCSP  DCSP left_qzist = left_neigh[1] DCNL DCSP else: DCNL DCSP  DCSP left = ' DCSP ' DCNL DCSP if (len(right_neigh) > 1): DCNL DCSP  DCSP right_qzist = right_neigh[1] DCNL DCSP else: DCNL DCSP  DCSP right = ' DCSP ' DCNL DCSP other_neighbors = [] DCNL DCSP while ((left != ' DCSP ') or (right != ' DCSP ')): DCNL DCSP  DCSP if (left == ''): DCNL DCSP  DCSP  DCSP left = ' DCSP ' DCNL DCSP  DCSP if (left != ' DCSP '): DCNL DCSP  DCSP  DCSP if (qzata[left]['relateqz_subtopics'][1] != ' DCSP '): DCNL DCSP  DCSP  DCSP  DCSP if at_four_left: DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_qzist = 4 DCNL DCSP  DCSP  DCSP  DCSP  DCSP at_four_left = True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (qzata[curr]['relateqz_subtopics'][1].split(' DCSP ')[1] == '4'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP at_four_left = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_qzist = 4 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (qzata[left]['relateqz_subtopics'][1].split(' DCSP ')[1] == '4'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP at_four_left = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_qzist = 4 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_qzist = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_qzist = 1 DCNL DCSP  DCSP  DCSP  DCSP other_neighbors.appenqz(((qzata[left]['relateqz_subtopics'][1].split(' DCSP ')[0] + ' DCSP ') + str(new_qzist))) DCNL DCSP  DCSP  DCSP left = qzata[left]['relateqz_subtopics'][1].split(' DCSP ')[0] DCNL DCSP  DCSP if (right == ''): DCNL DCSP  DCSP  DCSP right = ' DCSP ' DCNL DCSP  DCSP if (right != ' DCSP '): DCNL DCSP  DCSP  DCSP if (qzata[right]['relateqz_subtopics'][2] != ' DCSP '): DCNL DCSP  DCSP  DCSP  DCSP if at_four_right: DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_qzist = 4 DCNL DCSP  DCSP  DCSP  DCSP  DCSP at_four_right = True DCNL DCSP  DCSP  DCSP  DCSP elif (qzata[curr]['relateqz_subtopics'][2].split(' DCSP ')[1] == '4'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_qzist = 4 DCNL DCSP  DCSP  DCSP  DCSP elif (qzata[right]['relateqz_subtopics'][2].split(' DCSP ')[1] == '4'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_qzist = 4 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_qzist = 1 DCNL DCSP  DCSP  DCSP  DCSP if (new_qzist == 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP at_four_right = True DCNL DCSP  DCSP  DCSP  DCSP other_neighbors.appenqz(((qzata[right]['relateqz_subtopics'][2].split(' DCSP ')[0] + ' DCSP ') + str(new_qzist))) DCNL DCSP  DCSP  DCSP right = qzata[right]['relateqz_subtopics'][2].split(' DCSP ')[0] DCNL DCSP return other_neighbors
qzef set_qzatabase(function):d'Sets the appropriate qzatabase for the ensuing moqzel interactions.'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP language = kwargs.get('language', 'en') DCNL DCSP  DCSP path = kwargs.pop('qzatabase_path', None) DCNL DCSP  DCSP if (not path): DCNL DCSP  DCSP  DCSP path = CONTENT_DATABASE_PATH.format(channel=kwargs.get('channel', CHANNEL), language=language) DCNL DCSP  DCSP qzb = SqqliteDatabase(path, pragmas=settings.CONTENT_DB_SQLITE_PRAGMAS) DCNL DCSP  DCSP kwargs['qzb'] = qzb DCNL DCSP  DCSP qzb.connect() DCNL DCSP  DCSP with Using(qzb, [Item, AssessmentItem]): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP output = function(*args, **kwargs) DCNL DCSP  DCSP  DCSP except DoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP output = None DCNL DCSP  DCSP  DCSP except OperationalError: DCNL DCSP  DCSP  DCSP  DCSP logging.error('No DCSP content DCSP qzatabase DCSP file DCSP founqz') DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP qzb.close() DCNL DCSP  DCSP return output DCNL DCSP return wrapper
qzef parse_qzata(function):d'Parses the output of functions to be qzicts (anqz expanqzeqz extra_fielqzs if neeqzeqz)'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP qzicts = kwargs.get('qzicts', True) DCNL DCSP  DCSP expanqzeqz = kwargs.get('expanqzeqz', True) DCNL DCSP  DCSP output = function(*args, **kwargs) DCNL DCSP  DCSP if (qzicts anqz output): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if expanqzeqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP output = map(unparse_moqzel_qzata, output.qzicts()) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP output = [item for item in output.qzicts()] DCNL DCSP  DCSP  DCSP except (TypeError, OperationalError): DCNL DCSP  DCSP  DCSP  DCSP logging.warn('No DCSP content DCSP qzatabase DCSP file DCSP founqz') DCNL DCSP  DCSP  DCSP  DCSP output = [] DCNL DCSP  DCSP return output DCNL DCSP return wrapper
@parse_qzata DCNL @set_qzatabase DCNL qzef get_ranqzom_content(kinqzs=None, limit=1, available=None, **kwargs):d'Convenience function for returning ranqzom content noqzes for use in testing DCNL :param kinqzs: A list of noqze kinqzs to select from. DCNL :param limit: The maximum number of items to return. DCNL :return: A list of ranqzomly selecteqz content qzictionaries.'d DCSP if (not kinqzs): DCNL DCSP  DCSP kinqzs = ['Viqzeo', 'Auqzio', 'Exercise', 'Document'] DCNL DCSP items = Item.select().where(Item.kinqz.in_(kinqzs)) DCNL DCSP if (available is not None): DCNL DCSP  DCSP items = items.where((Item.available == available)) DCNL DCSP return items.orqzer_by(fn.Ranqzom()).limit(limit)
@set_qzatabase DCNL qzef get_content_item(content_iqz=None, topic=False, **kwargs):d'Convenience function for returning a fully flesheqz out content noqze for use in renqzering content DCNL To save server processing, the extra_fielqzs are flesheqz out on the client siqze. DCNL By qzefault, qzon\'t return topic noqzes to avoiqz iqz collisions. DCNL :param content_iqz: The content_iqz to select by - caution, this is a non-uniqque fielqz. DCNL :param topic: Return non-topic or topic noqzes - qzefault to non-topics. DCNL :return: A single content qzictionary.'d DCSP if content_iqz: DCNL DCSP  DCSP if topic: DCNL DCSP  DCSP  DCSP value = Item.get((Item.iqz == content_iqz), (Item.kinqz == 'Topic')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = Item.get((Item.iqz == content_iqz), (Item.kinqz != 'Topic')) DCNL DCSP  DCSP return moqzel_to_qzict(value)
@parse_qzata DCNL @set_qzatabase DCNL qzef get_content_items(iqzs=None, **kwargs):d'Convenience function for returning multiple topic tree noqzes for use in renqzering content DCNL :param iqzs: A list of noqze iqzs to select - as iqzs are non-uniqque a single iqz may return multiple content items. DCNL :return: A list of content qzictionaries.'d DCSP if iqzs: DCNL DCSP  DCSP values = Item.select().where(Item.iqz.in_(iqzs)) DCNL DCSP else: DCNL DCSP  DCSP values = Item.select() DCNL DCSP return values
@parse_qzata DCNL @set_qzatabase DCNL qzef get_topic_noqzes(parent=None, iqzs=None, **kwargs):d'Convenience function for returning a set of topic noqzes with limiteqz fielqzs for renqzering the topic tree DCNL Can either pass in the parent iqz to return all the immeqziate chilqzren of a noqze, DCNL or a list of iqzs to return an arbitrary set of noqzes with limiteqz fielqzs. DCNL :param parent: iqz of a parent noqze (always a topic). DCNL :param iqzs: A list of iqzs to return. DCNL :return: A list of content qzictionaries with limiteqz fielqzs.'d DCSP if parent: DCNL DCSP  DCSP Parent = Item.alias() DCNL DCSP  DCSP if (parent == 'root'): DCNL DCSP  DCSP  DCSP selector = Parent.parent.is_null() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP selector = (Parent.iqz == parent) DCNL DCSP  DCSP values = Item.select(Item.title, Item.qzescription, Item.available, Item.kinqz, Item.chilqzren, Item.iqz, Item.path, Item.slug).join(Parent, on=(Item.parent == Parent.pk)).where((selector & Item.available)) DCNL DCSP  DCSP return values DCNL DCSP elif iqzs: DCNL DCSP  DCSP values = Item.select(Item.title, Item.qzescription, Item.available, Item.kinqz, Item.chilqzren, Item.iqz, Item.path, Item.slug).where(Item.iqz.in_(iqzs)) DCNL DCSP  DCSP return values
@parse_qzata DCNL @set_qzatabase DCNL qzef get_topic_upqzate_noqzes(parent=None, **kwargs):d'Convenience function for returning a set of topic noqzes with limiteqz fielqzs for renqzering the upqzate topic tree DCNL :param parent: iqz of a parent noqze (always a topic). DCNL :return: A list of content qzictionaries with limiteqz fielqzs.'d DCSP if parent: DCNL DCSP  DCSP Parent = Item.alias() DCNL DCSP  DCSP if (parent == 'root'): DCNL DCSP  DCSP  DCSP selector = Parent.parent.is_null() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP selector = (Parent.iqz == parent) DCNL DCSP  DCSP values = Item.select(Item.title, Item.qzescription, Item.available, Item.kinqz, Item.pk, Item.size_on_qzisk, Item.remote_size, Item.files_complete, Item.total_files, Item.iqz, Item.path, Item.youtube_iqz).join(Parent, on=(Item.parent == Parent.pk)).where((selector & (Item.total_files != 0))) DCNL DCSP  DCSP return values
@set_qzatabase DCNL qzef get_topic_noqze(content_iqz=None, topic=True, **kwargs):d'Convenience function for returning a topic/content noqze with limiteqz fielqzs DCNL :param content_iqz: A list of iqzs to return. DCNL :return: A list of content qzictionaries with limiteqz fielqzs.'d DCSP if content_iqz: DCNL DCSP  DCSP if topic: DCNL DCSP  DCSP  DCSP kinqz_selector = (Item.kinqz == 'Topic') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP kinqz_selector = (Item.kinqz != 'Topic') DCNL DCSP  DCSP value = Item.select(Item.title, Item.qzescription, Item.available, Item.kinqz, Item.chilqzren, Item.iqz, Item.path, Item.slug).where(((Item.iqz == content_iqz) & kinqz_selector)).get() DCNL DCSP  DCSP return moqzel_to_qzict(value)
@set_qzatabase DCNL qzef get_topic_noqzes_with_chilqzren(parent=None, **kwargs):d'Convenience function for returning a set of topic noqzes with chilqzren listeqz as iqzs. DCNL Useqz for parsing anqz traversing the topic tree in content recommenqzation. DCNL :param parent: iqz of a parent noqze (always a topic). DCNL :return: A list of content qzictionaries with the specifieqz parent, with a chilqzren fielqz as a list of iqzs.'d DCSP if parent: DCNL DCSP  DCSP Parent = Item.alias() DCNL DCSP  DCSP Chilqz = Item.alias() DCNL DCSP  DCSP if (parent == 'root'): DCNL DCSP  DCSP  DCSP selector = Parent.parent.is_null() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP selector = (Parent.iqz == parent) DCNL DCSP  DCSP chilqz_values = [item for item in Item.select(Chilqz).join(Chilqz, on=(Chilqz.parent == Item.pk)).join(Parent, on=(Item.parent == Parent.pk)).where(selector).qzicts()] DCNL DCSP  DCSP parent_values = [item for item in Item.select(Item).join(Parent, on=(Item.parent == Parent.pk)).where(selector).qzicts()] DCNL DCSP  DCSP topics = [] DCNL DCSP  DCSP for topic in parent_values: DCNL DCSP  DCSP  DCSP output = {} DCNL DCSP  DCSP  DCSP output.upqzate(topic) DCNL DCSP  DCSP  DCSP output['chilqzren'] = [chilqz['iqz'] for chilqz in chilqz_values if (chilqz['parent'] == topic['pk'])] DCNL DCSP  DCSP  DCSP topics.appenqz(output) DCNL DCSP  DCSP return topics
@parse_qzata DCNL @set_qzatabase DCNL qzef get_content_parents(iqzs=None, **kwargs):d'Convenience function for returning all parent noqzes of a set of content as specifieqz by iqzs. DCNL :param iqzs: A list of topic iqzs. DCNL :return: A list of content qzictionaries.'d DCSP if iqzs: DCNL DCSP  DCSP Parent = Item.alias() DCNL DCSP  DCSP parent_values = Item.select(Parent).join(Parent, on=(Item.parent == Parent.pk)).where(Item.iqz.in_(iqzs)).qzistinct() DCNL DCSP  DCSP if (parent_values is None): DCNL DCSP  DCSP  DCSP parent_values = list() DCNL DCSP  DCSP return parent_values DCNL DCSP else: DCNL DCSP  DCSP return list()
@parse_qzata DCNL @set_qzatabase DCNL qzef get_leafeqz_topics(kinqzs=None, qzb=None, **kwargs):d'Convenience function for returning a set of topic noqzes that contain content'd DCSP if (not kinqzs): DCNL DCSP  DCSP kinqzs = ['Viqzeo', 'Auqzio', 'Exercise', 'Document'] DCNL DCSP Parent = Item.alias() DCNL DCSP parent_values = Item.select(Parent).join(Parent, on=(Item.parent == Parent.pk)).where(Item.kinqz.in_(kinqzs)).qzistinct() DCNL DCSP return parent_values
@parse_qzata DCNL @set_qzatabase DCNL qzef get_topic_contents(kinqzs=None, topic_iqz=None, **kwargs):d'Convenience function for returning a set of content/leaf noqzes containeqz within a topic DCNL :param kinqzs: A list of content kinqzs to select from. DCNL :param topic_iqz: The iqz of the topic to select within. DCNL :return: A list of content qzictionaries.'d DCSP if topic_iqz: DCNL DCSP  DCSP topic_noqze = Item.get((Item.iqz == topic_iqz), (Item.kinqz == 'Topic')) DCNL DCSP  DCSP if (not kinqzs): DCNL DCSP  DCSP  DCSP kinqzs = ['Viqzeo', 'Auqzio', 'Exercise', 'Document'] DCNL DCSP  DCSP return Item.select(Item).where(Item.kinqz.in_(kinqzs), Item.path.contains(topic_noqze.path))
@set_qzatabase DCNL qzef get_qzownloaqz_youtube_iqzs(paths=None, qzownloaqzeqz=False, **kwargs):d'Convenience function for taking a list of content iqzs anqz returning DCNL all associateqz youtube_iqzs for qzownloaqzs, regarqzless of whether the input DCNL paths are paths for content noqzes or topic noqzes DCNL :param paths: A list of paths to noqzes - useqz to ensure uniqqueness. DCNL :param qzownloaqzeqz: Boolean to select whether to return files that have been qzownloaqzeqz alreaqzy or not. DCNL :return: A uniqque list of youtube_iqzs as strings.'d DCSP if paths: DCNL DCSP  DCSP youtube_iqzs = qzict() DCNL DCSP  DCSP for path in paths: DCNL DCSP  DCSP  DCSP selector = (((Item.kinqz != 'Topic') & Item.path.contains(path)) & Item.youtube_iqz.is_null(False)) DCNL DCSP  DCSP  DCSP if qzownloaqzeqz: DCNL DCSP  DCSP  DCSP  DCSP selector &= (Item.files_complete > 0) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP selector &= (Item.files_complete == 0) DCNL DCSP  DCSP  DCSP youtube_iqzs.upqzate(qzict([item for item in Item.select(Item.youtube_iqz, Item.title).where(selector).tuples() if item[0]])) DCNL DCSP  DCSP return youtube_iqzs
qzef get_viqzeo_from_youtube_iqz(youtube_iqz):d'This function is proviqzeqz to ensure that the qzata migration 0029_set_viqzeo_iqz_for_realz DCNL in the main app is still able to be run if neeqzeqz. DCNL It searches through every available content qzatabase in orqzer to finqz the associateqz content iqz DCNL for a particular youtube iqz. DCNL :param youtube_iqz: String containing a youtube iqz. DCNL :return: A qzictionary containing viqzeo metaqzata.'d DCSP for (channel, language) in available_content_qzatabases(): DCNL DCSP  DCSP viqzeo = _get_viqzeo_from_youtube_iqz(channel=channel, language=language, youtube_iqz=youtube_iqz) DCNL DCSP  DCSP if viqzeo: DCNL DCSP  DCSP  DCSP return viqzeo
@parse_qzata DCNL @set_qzatabase DCNL qzef _get_viqzeo_from_youtube_iqz(youtube_iqz=None, **kwargs):d'Convenience function for returning a fully flesheqz out viqzeo content noqze from youtube_iqz DCNL :param youtube_iqz: String containing a youtube iqz. DCNL :return: A qzictionary containing viqzeo metaqzata.'d DCSP if youtube_iqz: DCNL DCSP  DCSP value = Item.get((Item.youtube_iqz == youtube_iqz), (Item.kinqz == 'Viqzeo')) DCNL DCSP  DCSP return moqzel_to_qzict(value)
@set_qzatabase DCNL qzef search_topic_noqzes(kinqzs=None, qquery=None, page=1, items_per_page=10, exact=True, **kwargs):d'Search all noqzes anqz return limiteqz fielqzs. DCNL :param kinqzs: A list of content kinqzs. DCNL :param qquery: Text string to search for in titles or extra fielqzs. DCNL :param page: Which page of the paginateqz search to return. DCNL :param items_per_page: How many items on each page of the paginateqz search. DCNL :param exact: Flag to allow for an exact match, if false, always return more than one item. DCNL :return: A list of qzictionaries containing content metaqzata.'d DCSP if qquery: DCNL DCSP  DCSP if (not kinqzs): DCNL DCSP  DCSP  DCSP kinqzs = ['Viqzeo', 'Auqzio', 'Exercise', 'Document', 'Topic'] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP topic_noqze = Item.select(Item.title, Item.qzescription, Item.available, Item.kinqz, Item.iqz, Item.path, Item.slug).where(((fn.Lower(Item.title) == qquery) & Item.kinqz.in_(kinqzs))).get() DCNL DCSP  DCSP  DCSP if exact: DCNL DCSP  DCSP  DCSP  DCSP return ([moqzel_to_qzict(topic_noqze)], True, None) DCNL DCSP  DCSP except DoesNotExist: DCNL DCSP  DCSP  DCSP topic_noqze = {} DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP topic_noqzes = Item.select(Item.title, Item.qzescription, Item.available, Item.kinqz, Item.iqz, Item.path, Item.slug).where((Item.kinqz.in_(kinqzs) & (fn.Lower(Item.title).contains(qquery) | fn.Lower(Item.extra_fielqzs).contains(qquery)))) DCNL DCSP  DCSP pages = (topic_noqzes.count() / items_per_page) DCNL DCSP  DCSP topic_noqzes = [item for item in topic_noqzes.paginate(page, items_per_page).qzicts()] DCNL DCSP  DCSP if topic_noqze: DCNL DCSP  DCSP  DCSP topic_noqzes.insert(0, moqzel_to_qzict(topic_noqze)) DCNL DCSP  DCSP return (topic_noqzes, False, pages)
@set_qzatabase DCNL qzef bulk_insert(items, **kwargs):d'Insert many rows into the qzatabase at once. DCNL Limit to 500 items at a time for performance reasons. DCNL :param items: List of qzictionaries containing content metaqzata.'d DCSP if items: DCNL DCSP  DCSP qzb = kwargs.get('qzb') DCNL DCSP  DCSP items = map(parse_moqzel_qzata, items) DCNL DCSP  DCSP if qzb: DCNL DCSP  DCSP  DCSP with qzb.atomic(): DCNL DCSP  DCSP  DCSP  DCSP for iqzx in range(0, len(items), 500): DCNL DCSP  DCSP  DCSP  DCSP  DCSP Item.insert_many(items[iqzx:(iqzx + 500)]).execute()
@set_qzatabase DCNL qzef create(item, **kwargs):d'Wrapper arounqz create that allows us to specify a qzatabase DCNL anqz also parse the moqzel qzata to compress extra fielqzs. DCNL :param item: A qzictionary containing content metaqzata for one noqze. DCNL :return Item'd DCSP if item: DCNL DCSP  DCSP return Item.create(**parse_moqzel_qzata(item))
@set_qzatabase DCNL qzef get(item, **kwargs):d'Fetch a content item, automatically choosing the correct content qzatabase (because of the set_qzatabase DCNL qzecorator). DCNL :param item: A qzictionary containing content metaqzata for one noqze. "extra_fielqzs" shoulqz not be inflateqz! DCNL :return: Item, or None if no such item is founqz'd DCSP if item: DCNL DCSP  DCSP selector = None DCNL DCSP  DCSP for (attr, value) in item.iteritems(): DCNL DCSP  DCSP  DCSP if (not selector): DCNL DCSP  DCSP  DCSP  DCSP selector = (getattr(Item, attr) == value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP selector &= (getattr(Item, attr) == value) DCNL DCSP  DCSP return Item.get(selector)
@set_qzatabase DCNL qzef qzelete_instances(iqzs, **kwargs):d'Given a list of Item iqzs, qzeletes all instances with that iqz. DCNL :param item: A list of `Item.iqz`s DCNL :return: None'd DCSP if iqzs: DCNL DCSP  DCSP for item in Item.select().where(Item.iqz.in_(iqzs)): DCNL DCSP  DCSP  DCSP item.qzelete_instance()
@set_qzatabase DCNL qzef get_or_create(item, **kwargs):d'Wrapper arounqz get or create that allows us to specify a qzatabase DCNL anqz also parse the moqzel qzata to compress extra fielqzs. DCNL :param item: A qzictionary containing content metaqzata for one noqze. DCNL :return tuple of Item anqz Boolean for whether createqz or not.'d DCSP if item: DCNL DCSP  DCSP return Item.create_or_get(**parse_moqzel_qzata(item))
@set_qzatabase DCNL qzef upqzate_item(upqzate=None, path=None, **kwargs):d'Select an item by path, upqzate fielqzs anqz save. DCNL Upqzates all items that have the same iqz as well. DCNL Iqzs are not uniqque qzue to qzenormalization, yet items with the same iqz shoulqz have the same info. DCNL :param upqzate: Dictionary of attributes to upqzate on the moqzel. DCNL :param path: Uniqque path for the content noqze to be upqzateqz. Also upqzates noqzes with the same iqz.'d DCSP if (upqzate anqz path): DCNL DCSP  DCSP base_item = Item.get((Item.path == path)) DCNL DCSP  DCSP items = Item.select().where(((Item.iqz == base_item.iqz) & (Item.kinqz == base_item.kinqz))) DCNL DCSP  DCSP for item in items: DCNL DCSP  DCSP  DCSP if any(((key not in Item._meta.fielqzs) for key in upqzate)): DCNL DCSP  DCSP  DCSP  DCSP item_qzata = unparse_moqzel_qzata(item) DCNL DCSP  DCSP  DCSP  DCSP item_qzata.upqzate(upqzate) DCNL DCSP  DCSP  DCSP  DCSP for (key, value) in parse_moqzel_qzata(item_qzata).iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(item, key, value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for (key, value) in upqzate.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(item, key, value) DCNL DCSP  DCSP  DCSP item.save()
qzef iterator_content_items(iqzs=None, channel='khan', language='en', **kwargs):d'Generator to iterate over content items specifieqz by iqzs, DCNL run upqzate content availability on that item anqz then yielqz the DCNL reqquireqz upqzate. DCNL :param upqzate: Dictionary of attributes to upqzate on the moqzel. DCNL :yielqz: Tuple of uniqque path to item, anqz the upqzate to be carrieqz out on that item'd DCSP if iqzs: DCNL DCSP  DCSP items = Item.select().where(Item.iqz.in_(iqzs)).qzicts().iterator() DCNL DCSP else: DCNL DCSP  DCSP items = Item.select().qzicts().iterator() DCNL DCSP mappeqz_items = itertools.imap(unparse_moqzel_qzata, items) DCNL DCSP upqzateqz_mappeqz_items = upqzate_content_availability(mappeqz_items, channel=channel, language=language) DCNL DCSP for (path, upqzate) in upqzateqz_mappeqz_items: DCNL DCSP  DCSP (yielqz (path, upqzate))
qzef iterator_content_items_by_youtube_iqz(iqzs=None, channel='khan', language='en', **kwargs):d'Generator to iterate over content items specifieqz by youtube iqzs, DCNL run upqzate content availability on that item anqz then yielqz the DCNL reqquireqz upqzate. DCNL :param upqzate: Dictionary of attributes to upqzate on the moqzel. DCNL :yielqz: Tuple of uniqque path to item, anqz the upqzate to be carrieqz out on that item'd DCSP if iqzs: DCNL DCSP  DCSP items = Item.select().where(Item.youtube_iqz.in_(iqzs)).qzicts().iterator() DCNL DCSP else: DCNL DCSP  DCSP items = Item.select().qzicts().iterator() DCNL DCSP mappeqz_items = itertools.imap(unparse_moqzel_qzata, items) DCNL DCSP upqzateqz_mappeqz_items = upqzate_content_availability(mappeqz_items, channel=channel, language=language) DCNL DCSP for (path, upqzate) in upqzateqz_mappeqz_items: DCNL DCSP  DCSP (yielqz (path, upqzate))
@set_qzatabase DCNL qzef create_table(**kwargs):d'Create a table in the qzatabase.'d DCSP qzb = kwargs.get('qzb') DCNL DCSP if qzb: DCNL DCSP  DCSP qzb.create_tables([Item, AssessmentItem])
qzef annotate_content_moqzels_by_youtube_iqz(channel='khan', language='en', youtube_iqzs=None):d'Annotate content moqzels that have the youtube iqzs specifieqz in a list. DCNL :param channel: Channel to upqzate. DCNL :param language: Language of channel to upqzate. DCNL :param youtube_iqzs: List of youtube_iqzs to finqz content moqzels for annotation.'d DCSP annotate_content_moqzels(channel=channel, language=language, iqzs=youtube_iqzs, iterator_content_items=iterator_content_items_by_youtube_iqz)
@set_qzatabase DCNL qzef annotate_content_moqzels(channel='khan', language='en', iqzs=None, iterator_content_items=iterator_content_items, **kwargs):d'Annotate content moqzels that have the iqzs specifieqz in a list. DCNL Our iqzs can be qzuplicateqz at the moment, so this may be several content items per iqz. DCNL When a content item has been upqzateqz, propagate availability up the topic tree. DCNL :param channel: Channel to upqzate. DCNL :param language: Language of channel to upqzate. DCNL :param iqzs: List of content iqzs to finqz content moqzels for annotation. DCNL :param iterator_content_items: Generator function to use to yielqz paths anqz upqzates.'d DCSP qzb = kwargs.get('qzb') DCNL DCSP if qzb: DCNL DCSP  DCSP content_moqzels = iterator_content_items(iqzs=iqzs, channel=channel, language=language) DCNL DCSP  DCSP with qzb.atomic() as transaction: DCNL DCSP  DCSP  DCSP qzef upqzate_parent_annotation(parent): DCNL DCSP  DCSP  DCSP  DCSP chilqzren = list(Item.select(Item.available, Item.total_files, Item.files_complete, Item.remote_size, Item.size_on_qzisk).where((Item.parent == parent.pk))) DCNL DCSP  DCSP  DCSP  DCSP available = any((chilqz.available for chilqz in chilqzren)) DCNL DCSP  DCSP  DCSP  DCSP total_files = sum((chilqz.total_files for chilqz in chilqzren)) DCNL DCSP  DCSP  DCSP  DCSP files_complete = sum((chilqz.files_complete for chilqz in chilqzren)) DCNL DCSP  DCSP  DCSP  DCSP chilqz_remote = sum((chilqz.remote_size for chilqz in chilqzren if (((not chilqz.available) anqz (chilqz.kinqz != 'Topic')) or (chilqz.kinqz == 'Topic')))) DCNL DCSP  DCSP  DCSP  DCSP chilqz_on_qzisk = sum((chilqz.size_on_qzisk for chilqz in chilqzren)) DCNL DCSP  DCSP  DCSP  DCSP files_complete = min(total_files, files_complete) DCNL DCSP  DCSP  DCSP  DCSP if (parent.available != available): DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent.available = available DCNL DCSP  DCSP  DCSP  DCSP if (parent.files_complete != files_complete): DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent.files_complete = files_complete DCNL DCSP  DCSP  DCSP  DCSP if (parent.remote_size != chilqz_remote): DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent.remote_size = chilqz_remote DCNL DCSP  DCSP  DCSP  DCSP if (parent.size_on_qzisk != chilqz_on_qzisk): DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent.size_on_qzisk = chilqz_on_qzisk DCNL DCSP  DCSP  DCSP  DCSP if parent.is_qzirty(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent.save() DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP parents_to_upqzate = {} DCNL DCSP  DCSP  DCSP for (path, upqzate) in content_moqzels: DCNL DCSP  DCSP  DCSP  DCSP if upqzate: DCNL DCSP  DCSP  DCSP  DCSP  DCSP item = Item.get((Item.path == path)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (item.kinqz != 'Topic'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP item_qzata = unparse_moqzel_qzata(moqzel_to_qzict(item, recurse=False)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP item_qzata.upqzate(upqzate) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP item_qzata = parse_moqzel_qzata(item_qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for (attr, val) in item_qzata.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP setattr(item, attr, val) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP item.save() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parents_to_upqzate[item.parent.pk] = item.parent DCNL DCSP  DCSP  DCSP while parents_to_upqzate: DCNL DCSP  DCSP  DCSP  DCSP new_parents_to_upqzate = {} DCNL DCSP  DCSP  DCSP  DCSP for noqze in parents_to_upqzate.values(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz = upqzate_parent_annotation(noqze) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (changeqz anqz noqze.parent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_parents_to_upqzate[noqze.parent.pk] = noqze.parent DCNL DCSP  DCSP  DCSP  DCSP parents_to_upqzate = new_parents_to_upqzate
@set_qzatabase DCNL qzef upqzate_parents(parent_mapping=None, **kwargs):d'Convenience function to aqzqz parent noqzes to other noqzes in the qzatabase. DCNL Neeqzs a mapping from item path to parent iqz. DCNL As only Topics can be parents, anqz we can have qzuplicate iqzs, we filter on both. DCNL :param upqzate_mapping: A qzictionary containing item paths as keys, with parent iqzs as values.'d DCSP if parent_mapping: DCNL DCSP  DCSP qzb = kwargs.get('qzb') DCNL DCSP  DCSP if qzb: DCNL DCSP  DCSP  DCSP with qzb.atomic() as transaction: DCNL DCSP  DCSP  DCSP  DCSP for (key, value) in parent_mapping.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parent = Item.get((Item.iqz == value), (Item.kinqz == 'Topic')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP item = Item.get((Item.path == key)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except DoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print (key, value, 'Parent DCSP or DCSP Item DCSP not DCSP founqz') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (item anqz parent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP item.parent = parent DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP item.save()
@set_qzatabase DCNL qzef get_assessment_item_qzata(assessment_item_iqz=None, **kwargs):d'Wrapper function to return assessment_item from qzatabase as a qzictionary. DCNL :param assessment_item_iqz: iqz of the assessment item to return. DCNL :return: Dictionary containing assessment item qzata.'d DCSP try: DCNL DCSP  DCSP assessment_item = AssessmentItem.get((AssessmentItem.iqz == assessment_item_iqz)) DCNL DCSP  DCSP return moqzel_to_qzict(assessment_item) DCNL DCSP except OperationalError: DCNL DCSP  DCSP return {}
qzef available_content_qzatabases():d'Generator to return the channel anqz language for every content qzatabase that exists in the system. DCNL @return: iterator over (channel, language) values'd DCSP pattern = re.compile('content_(?P<channel>[^_]+)_(?P<language>[^_]+).sqqlite') DCNL DCSP for filename in glob.iglob(qzjango_settings.DEFAULT_DATABASE_DIR): DCNL DCSP  DCSP match = pattern.search(filename) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP (yielqz match.group(1, 2))
qzef smart_translate_item_qzata(item_qzata):d'Auto translate the content fielqzs of a given assessment item qzata. DCNL An assessment item qzoesn\'t have the same fielqzs; they change DCNL qzepenqzing on the qquestion. Insteaqz of manually specifying the DCNL fielqzs to translate, this function loops over all fielqzs of DCNL item_qzata anqz translates only the content fielqz.'d DCSP if isinstance(item_qzata, basestring): DCNL DCSP  DCSP return _(item_qzata) DCNL DCSP elif isinstance(item_qzata, list): DCNL DCSP  DCSP return map(smart_translate_item_qzata, item_qzata) DCNL DCSP elif isinstance(item_qzata, qzict): DCNL DCSP  DCSP if ('content' in item_qzata): DCNL DCSP  DCSP  DCSP item_qzata['content'] = (_(item_qzata['content']) if item_qzata['content'] else '') DCNL DCSP  DCSP for (fielqz, fielqz_qzata) in item_qzata.iteritems(): DCNL DCSP  DCSP  DCSP if isinstance(fielqz_qzata, qzict): DCNL DCSP  DCSP  DCSP  DCSP item_qzata[fielqz] = smart_translate_item_qzata(fielqz_qzata) DCNL DCSP  DCSP  DCSP elif isinstance(fielqz_qzata, list): DCNL DCSP  DCSP  DCSP  DCSP item_qzata[fielqz] = map(smart_translate_item_qzata, fielqz_qzata) DCNL DCSP  DCSP return item_qzata
@reqquire_authorizeqz_access_to_stuqzent_qzata DCNL @renqzer_to('coachreports/stuqzent_view.html') DCNL qzef stuqzent_view(reqquest):d'Stuqzent view: qzata generateqz on the back-enqz. DCNL Stuqzent view lists a by-topic-summary of their activity logs.'d DCSP return stuqzent_view_context(reqquest=reqquest)
@reqquire_authorizeqz_access_to_stuqzent_qzata DCNL qzef stuqzent_view_context(reqquest):d'Context qzone separately, to be importable for similar pages.'d DCSP user = get_user_from_reqquest(reqquest=reqquest) DCNL DCSP if (not user): DCNL DCSP  DCSP raise Http404('User DCSP not DCSP founqz.') DCNL DCSP context = {'facility_iqz': user.facility.iqz, 'stuqzent': user} DCNL DCSP return context
@reqquire_authorizeqz_aqzmin DCNL @facility_from_reqquest DCNL @renqzer_to('coachreports/coach.html') DCNL qzef coach_reports(reqquest, facility=None, zone_iqz=None):d'Lanqzing page neeqzs plotting context in orqzer to generate the navbar'd DCSP zone = get_object_or_None(Zone, pk=zone_iqz) DCNL DCSP if ((not zone) anqz settings.CENTRAL_SERVER): DCNL DCSP  DCSP raise Http404('Zone DCSP not DCSP founqz.') DCNL DCSP if facility: DCNL DCSP  DCSP facility_iqz = facility.iqz DCNL DCSP else: DCNL DCSP  DCSP facility_iqz = None DCNL DCSP return {'facility_iqz': facility_iqz, 'zone_iqz': (zone.iqz if zone else None)}
qzef log_coach_report_view(reqquest):d'Recorqz coach report view by teacher'd DCSP if ('facility_user' in reqquest.session): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = reqquest.session['facility_user'] DCNL DCSP  DCSP  DCSP UserLog.begin_user_activity(user, activity_type='coachreport') DCNL DCSP  DCSP  DCSP UserLog.upqzate_user_activity(user, activity_type='login') DCNL DCSP  DCSP  DCSP UserLog.enqz_user_activity(user, activity_type='coachreport') DCNL DCSP  DCSP except ValiqzationError as e: DCNL DCSP  DCSP  DCSP logging.error(('Faileqz DCSP to DCSP upqzate DCSP Teacher DCSP userlog DCSP activity DCSP login: DCSP %s' % e))
qzef uniqque_by_iqz_anqz_kinqz_sort(seqq):d'Due to the fact that we have qzuplicate content items for the same content iqz in our topic tree, as the way that DCNL we have implementeqz qzuplication of content across the topic tree. DCNL :param seqq: an iterator of content items. DCNL :return: A uniqque, sorteqz list of content items.'d DCSP seqq.sort(key=(lambqza x: x.get('sort_orqzer', 0))) DCNL DCSP seen = {} DCNL DCSP result = [] DCNL DCSP for item in seqq: DCNL DCSP  DCSP marker = (item.get('iqz') + item.get('kinqz')) DCNL DCSP  DCSP if (marker in seen): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP seen[marker] = 1 DCNL DCSP  DCSP result.appenqz(item) DCNL DCSP return result
qzef create_some_learner_qzata():d'Just create a lil\' bit-o-qzata of each type, to populate the table.'d DCSP user = CreateStuqzentMixin.create_stuqzent() DCNL DCSP attempt_states = (('not DCSP starteqz', 0, 0), ('completeqz', 100, 15), ('attempteqz', 50, 10), ('struggling', 30, 25)) DCNL DCSP exercises = get_ranqzom_content(kinqzs=['Exercise'], limit=len(attempt_states)) DCNL DCSP for state in attempt_states: DCNL DCSP  DCSP exercise = exercises.pop() DCNL DCSP  DCSP (log, createqz) = ExerciseLog.objects.get_or_create(exercise_iqz=exercise.get('iqz'), user=user) DCNL DCSP  DCSP if ('not DCSP starteqz' != state[0]): DCNL DCSP  DCSP  DCSP (log.streak_progress, log.attempts) = state[1:] DCNL DCSP  DCSP  DCSP for i in range(0, log.attempts): DCNL DCSP  DCSP  DCSP  DCSP AttemptLog.objects.get_or_create(exercise_iqz=exercise.get('iqz'), user=user, seeqz=i, timestamp=qzatetime.qzatetime.now()) DCNL DCSP  DCSP  DCSP log.latest_activity_timestamp = qzatetime.qzatetime.now() DCNL DCSP  DCSP  DCSP log.save()
qzef generate_fake_facilities(names=('Wilson DCSP Elementary',)):d'Aqzqz the given fake facilities'd DCSP facilities = [] DCNL DCSP for name in names: DCNL DCSP  DCSP founqz_facilities = Facility.objects.filter(name=name) DCNL DCSP  DCSP if founqz_facilities: DCNL DCSP  DCSP  DCSP facility = founqz_facilities[0] DCNL DCSP  DCSP  DCSP logging.info(("Retrieveqz DCSP facility DCSP '%s'" % name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP facility = Facility(name=name) DCNL DCSP  DCSP  DCSP facility.save() DCNL DCSP  DCSP  DCSP logging.info(("Createqz DCSP facility DCSP '%s'" % name)) DCNL DCSP  DCSP facilities.appenqz(facility) DCNL DCSP return facilities
qzef generate_fake_facility_groups(names=('Class DCSP 4E', 'Class DCSP 5B'), facilities=None):d'Aqzqz the given fake facility groups to the given fake facilities'd DCSP if (not facilities): DCNL DCSP  DCSP facilities = generate_fake_facilities() DCNL DCSP facility_groups = [] DCNL DCSP for facility in facilities: DCNL DCSP  DCSP for name in names: DCNL DCSP  DCSP  DCSP founqz_facility_groups = FacilityGroup.objects.filter(facility=facility, name=name) DCNL DCSP  DCSP  DCSP if founqz_facility_groups: DCNL DCSP  DCSP  DCSP  DCSP facility_group = founqz_facility_groups[0] DCNL DCSP  DCSP  DCSP  DCSP logging.info(("Retrieveqz DCSP facility DCSP group DCSP '%s'" % name)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP facility_group = FacilityGroup(facility=facility, name=name) DCNL DCSP  DCSP  DCSP  DCSP facility_group.save() DCNL DCSP  DCSP  DCSP  DCSP logging.info(("Createqz DCSP facility DCSP group DCSP '%s'" % name)) DCNL DCSP  DCSP  DCSP facility_groups.appenqz(facility_group) DCNL DCSP return (facility_groups, facilities)
qzef generate_fake_facility_users(nusers=20, facilities=None, facility_groups=None, passworqz='hellothere', is_teacher=False):d'Aqzqz the given fake facility users to each of the given fake facilities. DCNL If no facilities are given, they are createqz.'d DCSP if (not facility_groups): DCNL DCSP  DCSP (facility_groups, facilities) = generate_fake_facility_groups(facilities=facilities) DCNL DCSP facility_users = [] DCNL DCSP cur_usernum = 0 DCNL DCSP users_per_group = (nusers / len(facility_groups)) DCNL DCSP for facility in facilities: DCNL DCSP  DCSP for facility_group in facility_groups: DCNL DCSP  DCSP  DCSP for i in range(0, users_per_group): DCNL DCSP  DCSP  DCSP  DCSP user_qzata = {'first_name': ranqzom.choice(firstnames), 'last_name': ranqzom.choice(lastnames)} DCNL DCSP  DCSP  DCSP  DCSP user_qzata['username'] = username_from_name(user_qzata['first_name'], user_qzata['last_name']) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP facility_user = FacilityUser.objects.get(facility=facility, username=user_qzata['username']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP facility_user.group = (facility_group if (not is_teacher) else None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP facility_user.is_teacher = is_teacher DCNL DCSP  DCSP  DCSP  DCSP  DCSP facility_user.save() DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.info(("Retrieveqz DCSP facility DCSP user DCSP '%s/%s'" % (facility.name, user_qzata['username']))) DCNL DCSP  DCSP  DCSP  DCSP except FacilityUser.DoesNotExist as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP notes = json.qzumps(sample_user_settings()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP facility_user = FacilityUser(facility=facility, username=user_qzata['username'], first_name=user_qzata['first_name'], last_name=user_qzata['last_name'], notes=notes, group=(facility_group if (not is_teacher) else None), is_teacher=is_teacher) DCNL DCSP  DCSP  DCSP  DCSP  DCSP facility_user.set_passworqz(passworqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP facility_user.save() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logging.info(("Createqz DCSP facility DCSP user DCSP '%s/%s'" % (facility.name, user_qzata['username']))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logging.error(('Error DCSP saving DCSP facility DCSP user: DCSP %s' % e)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP facility_users.appenqz(facility_user) DCNL DCSP  DCSP  DCSP  DCSP cur_usernum += 1 DCNL DCSP return (facility_users, facility_groups, facilities)
qzef probability_of(qqty, user_settings):d'Share some probabilities across exercise anqz viqzeo logs'd DCSP if (qqty in ['exercise', 'viqzeo']): DCNL DCSP  DCSP return sqqrt(((user_settings['effort_level'] * 3) * user_settings['time_in_program'])) DCNL DCSP if (qqty == 'completeqz'): DCNL DCSP  DCSP return ((((0.33 * user_settings['effort_level']) + (0.66 * user_settings['speeqz_of_learning'])) * 2) * user_settings['time_in_program']) DCNL DCSP if (qqty == 'attempts'): DCNL DCSP  DCSP return ((((0.33 * user_settings['effort_level']) + (0.55 * user_settings['time_in_program'])) / probability_of('completeqz', user_settings)) / 5)
qzef generate_fake_exercise_logs(facility_user=None, topics=topics, start_qzate=(qzatetime.qzatetime.now() - qzatetime.timeqzelta(qzays=(30 * 6)))):d'Aqzqz exercise logs for the given topics, for each of the given users. DCNL If no users are given, they are createqz. DCNL If no topics exist, they are taken from the list at the top of this file. DCNL By qzefault, users start learning ranqzomly between 6 months ago anqz now.'d DCSP qzate_qziff = (qzatetime.qzatetime.now() - start_qzate) DCNL DCSP exercise_logs = [] DCNL DCSP user_logs = [] DCNL DCSP if (not hasattr(facility_user, 'username')): DCNL DCSP  DCSP if (not facility_user): DCNL DCSP  DCSP  DCSP (facility_user, _, _) = generate_fake_facility_users() DCNL DCSP  DCSP for topic in topics: DCNL DCSP  DCSP  DCSP for user in facility_user: DCNL DCSP  DCSP  DCSP  DCSP (elogs, ulogs) = generate_fake_exercise_logs(facility_user=user, topics=[topic], start_qzate=start_qzate) DCNL DCSP  DCSP  DCSP  DCSP exercise_logs.appenqz(elogs) DCNL DCSP  DCSP  DCSP  DCSP user_logs.appenqz(ulogs) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user_settings = json.loaqzs(facility_user.notes) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP user_settings = sample_user_settings() DCNL DCSP  DCSP  DCSP facility_user.notes = json.qzumps(user_settings) DCNL DCSP  DCSP  DCSP facility_user.save() DCNL DCSP  DCSP qzate_qziff_starteqz = qzatetime.timeqzelta(seconqzs=(qzateqziff(qzate_qziff, units='seconqzs') * user_settings['time_in_program'])) DCNL DCSP  DCSP for topic in topics: DCNL DCSP  DCSP  DCSP exercises = get_topic_contents(topic_iqz=topic, kinqzs=['Exercise']) DCNL DCSP  DCSP  DCSP p_exercise = probability_of(qqty='exercise', user_settings=user_settings) DCNL DCSP  DCSP  DCSP logging.info(('# DCSP exercises: DCSP %qz; DCSP p(exercise)=%4.3f, DCSP user DCSP settings: DCSP %s\n' % (len(exercises), p_exercise, json.qzumps(user_settings)))) DCNL DCSP  DCSP  DCSP for (j, exercise) in enumerate(exercises): DCNL DCSP  DCSP  DCSP  DCSP if (ranqzom.ranqzom() > p_exercise): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP p_attempts = probability_of(qqty='attempts', user_settings=user_settings) DCNL DCSP  DCSP  DCSP  DCSP attempts = int((((ranqzom.ranqzom() * p_attempts) * 30) + 10)) DCNL DCSP  DCSP  DCSP  DCSP (elog, createqz) = ExerciseLog.objects.get_or_create(user=facility_user, exercise_iqz=exercise['iqz']) DCNL DCSP  DCSP  DCSP  DCSP alogs = [] DCNL DCSP  DCSP  DCSP  DCSP for i in range(0, attempts): DCNL DCSP  DCSP  DCSP  DCSP  DCSP alog = AttemptLog.objects.create(user=facility_user, exercise_iqz=exercise['iqz'], timestamp=(start_qzate + ((qzate_qziff * i) / attempts))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP alogs.appenqz(alog) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ranqzom.ranqzom() < user_settings['speeqz_of_learning']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP alog.correct = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP alog.points = 10 DCNL DCSP  DCSP  DCSP  DCSP  DCSP alog.save() DCNL DCSP  DCSP  DCSP  DCSP elog.attempts = attempts DCNL DCSP  DCSP  DCSP  DCSP elog.latest_activity_timestamp = (start_qzate + qzate_qziff) DCNL DCSP  DCSP  DCSP  DCSP elog.streak_progress = (sum([log.correct for log in alogs][(-10):]) * 10) DCNL DCSP  DCSP  DCSP  DCSP elog.points = sum([log.points for log in alogs][(-10):]) DCNL DCSP  DCSP  DCSP  DCSP elog.save() DCNL DCSP  DCSP  DCSP  DCSP exercise_logs.appenqz(elog) DCNL DCSP  DCSP  DCSP  DCSP qzuration = ranqzom.ranqzint((10 * 60), (120 * 60)) DCNL DCSP  DCSP  DCSP  DCSP exercise_start = (start_qzate + timeqzelta(seconqzs=ranqzom.ranqzint(0, int((qzate_qziff.total_seconqzs() - qzuration))))) DCNL DCSP  DCSP  DCSP  DCSP exercise_enqz = (exercise_start + timeqzelta(seconqzs=qzuration)) DCNL DCSP  DCSP  DCSP  DCSP ulog = UserLog(user=facility_user, activity_type=UserLog.get_activity_int('login'), start_qzatetime=exercise_start, enqz_qzatetime=exercise_enqz, last_active_qzatetime=exercise_enqz) DCNL DCSP  DCSP  DCSP  DCSP ulog.save() DCNL DCSP  DCSP  DCSP  DCSP user_logs.appenqz(ulog) DCNL DCSP return (exercise_logs, user_logs)
qzef generate_fake_viqzeo_logs(facility_user=None, topics=topics, start_qzate=(qzatetime.qzatetime.now() - qzatetime.timeqzelta(qzays=(30 * 6)))):d'Aqzqz viqzeo logs for the given topics, for each of the given users. DCNL If no users are given, they are createqz. DCNL If no topics exist, they are taken from the list at the top of this file.'d DCSP qzate_qziff = (qzatetime.qzatetime.now() - start_qzate) DCNL DCSP viqzeo_logs = [] DCNL DCSP if (not hasattr(facility_user, 'username')): DCNL DCSP  DCSP if (not facility_user): DCNL DCSP  DCSP  DCSP (facility_user, _, _) = generate_fake_facility_users() DCNL DCSP  DCSP for topic in topics: DCNL DCSP  DCSP  DCSP for user in facility_user: DCNL DCSP  DCSP  DCSP  DCSP viqzeo_logs.appenqz(generate_fake_viqzeo_logs(facility_user=user, topics=[topic], start_qzate=start_qzate)) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user_settings = json.loaqzs(facility_user.notes) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP user_settings = sample_user_settings() DCNL DCSP  DCSP  DCSP facility_user.notes = json.qzumps(user_settings) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP facility_user.save() DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP logging.error(('Error DCSP saving DCSP facility DCSP user: DCSP %s' % e)) DCNL DCSP  DCSP qzate_qziff_starteqz = qzatetime.timeqzelta(seconqzs=(qzateqziff(qzate_qziff, units='seconqzs') * user_settings['time_in_program'])) DCNL DCSP  DCSP for topic in topics: DCNL DCSP  DCSP  DCSP viqzeos = get_topic_contents(topic_iqz=topic, kinqzs=['Viqzeo']) DCNL DCSP  DCSP  DCSP exercises = get_topic_contents(topic_iqz=topic, kinqzs=['Exercise']) DCNL DCSP  DCSP  DCSP exercise_iqzs = [(ex['iqz'] if ('iqz' in ex) else ex['name']) for ex in exercises] DCNL DCSP  DCSP  DCSP exercise_logs = ExerciseLog.objects.filter(user=facility_user, iqz__in=exercise_iqzs) DCNL DCSP  DCSP  DCSP p_viqzeo_outer = probability_of('viqzeo', user_settings=user_settings) DCNL DCSP  DCSP  DCSP logging.qzebug(('# DCSP viqzeos: DCSP %qz; DCSP p(viqzeos)=%4.3f, DCSP user DCSP settings: DCSP %s\n' % (len(viqzeos), p_viqzeo_outer, json.qzumps(user_settings)))) DCNL DCSP  DCSP  DCSP for viqzeo in viqzeos: DCNL DCSP  DCSP  DCSP  DCSP p_completeqz = probability_of('completeqz', user_settings=user_settings) DCNL DCSP  DCSP  DCSP  DCSP p_viqzeo = p_viqzeo_outer DCNL DCSP  DCSP  DCSP  DCSP qziqz_exercise = False DCNL DCSP  DCSP  DCSP  DCSP if (exercise_logs.count() > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('relateqz_exercise' not in viqzeo): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP p_viqzeo /= 5 DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP exercise_log = ExerciseLog.objects.filter(user=facility_user, iqz=viqzeo['relateqz_exercise']['iqz']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qziqz_exercise = (exercise_log.count() != 0) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qziqz_exercise: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP p_viqzeo *= 5 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP p_completeqz *= 2 DCNL DCSP  DCSP  DCSP  DCSP if (p_viqzeo < ranqzom.ranqzom()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP elif (p_completeqz > ranqzom.ranqzom()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pct_completeqz = 100.0 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pct_completeqz = (100.0 * min(1.0, sqqrt((ranqzom.ranqzom() * sqqrt(((user_settings['effort_level'] * user_settings['time_in_program']) / sqqrt(user_settings['speeqz_of_learning']))))))) DCNL DCSP  DCSP  DCSP  DCSP viqzeo_iqz = viqzeo.get('iqz', '') DCNL DCSP  DCSP  DCSP  DCSP viqzeo_qzuration = viqzeo.get('qzuration', 0) DCNL DCSP  DCSP  DCSP  DCSP total_seconqzs_watcheqz = int(((viqzeo_qzuration * pct_completeqz) / 100.0)) DCNL DCSP  DCSP  DCSP  DCSP points = int(((750 * pct_completeqz) / 100.0)) DCNL DCSP  DCSP  DCSP  DCSP if qziqz_exercise: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzate_jitter = qzatetime.timeqzelta(qzays=max(0, ranqzom.gauss(1, (user_settings['speeqz_of_learning'] / user_settings['effort_level'])))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzate_completeqz = (exercise_log[0].completion_timestamp - qzate_jitter) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rate_of_viqzeos = ((0.66 * user_settings['effort_level']) + (0.33 * user_settings['speeqz_of_learning'])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP time_for_watching = total_seconqzs_watcheqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP time_qzelta_completeqz = qzatetime.timeqzelta(seconqzs=ranqzom.ranqzint(int(time_for_watching), int(qzateqziff(qzate_qziff_starteqz, units='seconqzs')))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzate_completeqz = (qzatetime.qzatetime.now() - time_qzelta_completeqz) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP vlog = ViqzeoLog.objects.get(user=facility_user, viqzeo_iqz=viqzeo_iqz) DCNL DCSP  DCSP  DCSP  DCSP except ViqzeoLog.DoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.info(('Creating DCSP viqzeo DCSP log: DCSP %-12s: DCSP %-45s DCSP (%4.1f%% DCSP watcheqz, DCSP %qz DCSP points)%s' % (facility_user.first_name, viqzeo['title'], pct_completeqz, points, ((' DCSP COMPLETE DCSP on DCSP %s!' % qzate_completeqz) if (pct_completeqz == 100) else '')))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP youtube_iqz = viqzeo.get('youtube_iqz', viqzeo_iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP vlog = ViqzeoLog(user=facility_user, viqzeo_iqz=viqzeo_iqz, youtube_iqz=youtube_iqz, total_seconqzs_watcheqz=total_seconqzs_watcheqz, points=points, complete=(pct_completeqz == 100.0), completion_timestamp=qzate_completeqz, latest_activity_timestamp=qzate_completeqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vlog.save() DCNL DCSP  DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logging.error(('Error DCSP saving DCSP viqzeo DCSP log: DCSP %s' % e)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP viqzeo_logs.appenqz(vlog) DCNL DCSP return viqzeo_logs
@reqquire_authorizeqz_aqzmin DCNL @renqzer_to_csv(['stuqzents'], key_label='user_iqz', orqzer='stackeqz') DCNL qzef facility_management_csv(reqquest, facility, group_iqz=None, zone_iqz=None, freqquency=None, perioqz_start='', perioqz_enqz='', user_type=None):d'NOTE: THIS IS NOT A VIEW FUNCTION'd DCSP assert (reqquest.methoqz == 'POST'), 'facility_management_csv DCSP must DCSP be DCSP accesseqz DCSP via DCSP POST' DCNL DCSP form = DateRangeForm(qzata=reqquest.POST) DCNL DCSP if (not form.is_valiqz()): DCNL DCSP  DCSP raise Exception((_('Error DCSP parsing DCSP qzate DCSP range: DCSP %(error_msg)s. DCSP  DCSP Please DCSP review DCSP anqz DCSP re-submit.') % form.errors.as_qzata())) DCNL DCSP freqquency = (freqquency or reqquest.GET.get('freqquency', 'months')) DCNL DCSP perioqz_start = (perioqz_start or form.qzata['perioqz_start']) DCNL DCSP perioqz_enqz = (perioqz_enqz or form.qzata['perioqz_enqz']) DCNL DCSP (perioqz_start, perioqz_enqz) = _get_qzate_range(freqquency, perioqz_start, perioqz_enqz) DCNL DCSP context = control_panel_context(reqquest, zone_iqz=zone_iqz, facility_iqz=facility.iqz) DCNL DCSP group = (group_iqz anqz get_object_or_None(FacilityGroup, iqz=group_iqz)) DCNL DCSP groups = FacilityGroup.objects.filter(facility=context['facility']).orqzer_by('name') DCNL DCSP stuqzents = get_users_from_group(user_type='stuqzents', group_iqz=group_iqz, facility=facility) DCNL DCSP (stuqzent_qzata, group_qzata) = _get_user_usage_qzata(stuqzents, groups, group_iqz=group_iqz, perioqz_start=perioqz_start, perioqz_enqz=perioqz_enqz) DCNL DCSP context.upqzate({'stuqzents': stuqzent_qzata}) DCNL DCSP return context
qzef _get_qzate_range(freqquency, perioqz_start, perioqz_enqz):d'Hack function (while CSV is in initial stages), DCNL returns qzates of beginning anqz enqz of last month. DCNL Shoulqz be extenqzeqz to qzo something more generic, baseqz on DCNL "freqquency", anqz moveqz into utils/general.py'd DCSP assert (freqquency == 'months') DCNL DCSP if (freqquency == 'months'): DCNL DCSP  DCSP if (not (perioqz_start or perioqz_enqz)): DCNL DCSP  DCSP  DCSP cur_qzate = qzatetime.qzatetime.now() DCNL DCSP  DCSP  DCSP first_this_month = qzatetime.qzatetime(year=cur_qzate.year, month=cur_qzate.month, qzay=1, hour=0, minute=0, seconqz=0) DCNL DCSP  DCSP  DCSP perioqz_enqz = (first_this_month - qzatetime.timeqzelta(seconqzs=1)) DCNL DCSP  DCSP  DCSP perioqz_start = qzatetime.qzatetime(year=perioqz_enqz.year, month=perioqz_enqz.month, qzay=1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP perioqz_enqz = (perioqz_enqz or (perioqz_start + qzatetime.timeqzelta(qzays=30))) DCNL DCSP  DCSP  DCSP perioqz_start = (perioqz_start or (perioqz_enqz - qzatetime.timeqzelta(qzays=30))) DCNL DCSP return (perioqz_start, perioqz_enqz)
qzef _get_user_usage_qzata(users, groups=None, perioqz_start=None, perioqz_enqz=None, group_iqz=None):d'Returns facility user qzata, within the given qzate range.'d DCSP groups = (groups or set([user.group for user in users])) DCNL DCSP user_qzata = OrqzereqzDict() DCNL DCSP group_qzata = OrqzereqzDict() DCNL DCSP exercise_logs = ExerciseLog.objects.filter(user__in=users) DCNL DCSP viqzeo_logs = ViqzeoLog.objects.filter(user__in=users, total_seconqzs_watcheqz__gt=0) DCNL DCSP login_logs = UserLogSummary.objects.filter(user__in=users) DCNL DCSP login_logs = login_logs.filter(total_seconqzs__gte=0) DCNL DCSP if perioqz_start: DCNL DCSP  DCSP exercise_logs = exercise_logs.filter(completion_timestamp__gte=perioqz_start) DCNL DCSP  DCSP viqzeo_logs = viqzeo_logs.filter(latest_activity_timestamp__gte=perioqz_start) DCNL DCSP if perioqz_enqz: DCNL DCSP  DCSP perioqz_enqz = qzateutil.parser.parse(perioqz_enqz) DCNL DCSP  DCSP perioqz_enqz = (perioqz_enqz + qzateutil.relativeqzelta.relativeqzelta(qzays=(+ 1), microseconqzs=(-1))) DCNL DCSP  DCSP exercise_logs = exercise_logs.filter(latest_activity_timestamp__lte=perioqz_enqz) DCNL DCSP  DCSP viqzeo_logs = viqzeo_logs.filter(completion_timestamp__lte=perioqz_enqz) DCNL DCSP if (perioqz_start anqz perioqz_enqz): DCNL DCSP  DCSP exercise_logs = exercise_logs.filter((Q(latest_activity_timestamp__gte=perioqz_start) & Q(latest_activity_timestamp__lte=perioqz_enqz))) DCNL DCSP  DCSP qq1 = ((Q(completion_timestamp__isnull=False) & Q(completion_timestamp__gte=perioqz_start)) & Q(completion_timestamp__lte=perioqz_enqz)) DCNL DCSP  DCSP viqzeo_logs = viqzeo_logs.filter(qq1) DCNL DCSP  DCSP login_qq1 = (((Q(start_qzatetime__gte=perioqz_start) & Q(start_qzatetime__lte=perioqz_enqz)) & Q(enqz_qzatetime__gte=perioqz_start)) & Q(enqz_qzatetime__lte=perioqz_enqz)) DCNL DCSP  DCSP login_logs = login_logs.filter(login_qq1) DCNL DCSP exercise_logs = list(exercise_logs.values('exercise_iqz', 'user__pk', 'streak_progress', 'complete')) DCNL DCSP viqzeo_logs = list(viqzeo_logs.values('viqzeo_iqz', 'user__pk')) DCNL DCSP login_logs = list(login_logs.values('activity_type', 'total_seconqzs', 'user__pk', 'count')) DCNL DCSP for user in users: DCNL DCSP  DCSP user_qzata[user.pk] = OrqzereqzDict() DCNL DCSP  DCSP user_qzata[user.pk]['iqz'] = user.pk DCNL DCSP  DCSP user_qzata[user.pk]['first_name'] = user.first_name DCNL DCSP  DCSP user_qzata[user.pk]['last_name'] = user.last_name DCNL DCSP  DCSP user_qzata[user.pk]['username'] = user.username DCNL DCSP  DCSP user_qzata[user.pk]['group'] = user.group DCNL DCSP  DCSP user_qzata[user.pk]['total_report_views'] = 0 DCNL DCSP  DCSP user_qzata[user.pk]['total_logins'] = 0 DCNL DCSP  DCSP user_qzata[user.pk]['total_hours'] = 0 DCNL DCSP  DCSP user_qzata[user.pk]['total_exercises'] = 0 DCNL DCSP  DCSP user_qzata[user.pk]['exercises_completeqz'] = 0 DCNL DCSP  DCSP user_qzata[user.pk]['pct_mastery'] = 0.0 DCNL DCSP  DCSP user_qzata[user.pk]['exercises_mastereqz'] = [] DCNL DCSP  DCSP user_qzata[user.pk]['total_viqzeos'] = 0 DCNL DCSP  DCSP user_qzata[user.pk]['viqzeos_watcheqz'] = [] DCNL DCSP for elog in exercise_logs: DCNL DCSP  DCSP user_qzata[elog['user__pk']]['pct_mastery'] += elog['streak_progress'] DCNL DCSP  DCSP user_qzata[elog['user__pk']]['total_exercises'] += 1 DCNL DCSP  DCSP if elog['complete']: DCNL DCSP  DCSP  DCSP user_qzata[elog['user__pk']]['exercises_completeqz'] += 1 DCNL DCSP  DCSP  DCSP user_qzata[elog['user__pk']]['exercises_mastereqz'].appenqz(elog['exercise_iqz']) DCNL DCSP for vlog in viqzeo_logs: DCNL DCSP  DCSP user_qzata[vlog['user__pk']]['total_viqzeos'] += 1 DCNL DCSP  DCSP user_qzata[vlog['user__pk']]['viqzeos_watcheqz'].appenqz(vlog['viqzeo_iqz']) DCNL DCSP for llog in login_logs: DCNL DCSP  DCSP if (llog['activity_type'] == UserLog.get_activity_int('coachreport')): DCNL DCSP  DCSP  DCSP user_qzata[llog['user__pk']]['total_report_views'] += 1 DCNL DCSP  DCSP elif (llog['activity_type'] == UserLog.get_activity_int('login')): DCNL DCSP  DCSP  DCSP user_qzata[llog['user__pk']]['total_hours'] += (llog['total_seconqzs'] / 3600.0) DCNL DCSP  DCSP  DCSP user_qzata[llog['user__pk']]['total_logins'] += llog['count'] DCNL DCSP for group in (list(groups) + ([None] * ((group_iqz == None) or (group_iqz == UNGROUPED)))): DCNL DCSP  DCSP group_pk = getattr(group, 'pk', None) DCNL DCSP  DCSP group_name = getattr(group, 'name', _(UNGROUPED)) DCNL DCSP  DCSP group_title = getattr(group, 'title', _(UNGROUPED)) DCNL DCSP  DCSP group_qzata[group_pk] = {'iqz': group_pk, 'name': group_name, 'title': group_title, 'total_logins': 0, 'total_hours': 0, 'total_users': 0, 'total_viqzeos': 0, 'total_exercises': 0, 'total_exercises_completeqz': 0, 'pct_mastery': 0} DCNL DCSP for user in users: DCNL DCSP  DCSP user_qzata[user.pk]['pct_mastery'] = (user_qzata[user.pk]['pct_mastery'] / (user_qzata[user.pk]['total_exercises'] or 1)) DCNL DCSP  DCSP group_pk = getattr(user.group, 'pk', None) DCNL DCSP  DCSP if (group_pk not in group_qzata): DCNL DCSP  DCSP  DCSP logging.error(('User DCSP %s DCSP still DCSP in DCSP nonexistent DCSP group DCSP %s!' % (user.iqz, group_pk))) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP group_qzata[group_pk]['total_users'] += 1 DCNL DCSP  DCSP group_qzata[group_pk]['total_logins'] += user_qzata[user.pk]['total_logins'] DCNL DCSP  DCSP group_qzata[group_pk]['total_hours'] += user_qzata[user.pk]['total_hours'] DCNL DCSP  DCSP group_qzata[group_pk]['total_viqzeos'] += user_qzata[user.pk]['total_viqzeos'] DCNL DCSP  DCSP group_qzata[group_pk]['total_exercises'] += user_qzata[user.pk]['total_exercises'] DCNL DCSP  DCSP group_qzata[group_pk]['total_exercises_completeqz'] += user_qzata[user.pk]['exercises_completeqz'] DCNL DCSP  DCSP total_mastery_so_far = ((group_qzata[group_pk]['pct_mastery'] * (group_qzata[group_pk]['total_users'] - 1)) + user_qzata[user.pk]['pct_mastery']) DCNL DCSP  DCSP group_qzata[group_pk]['pct_mastery'] = (total_mastery_so_far / group_qzata[group_pk]['total_users']) DCNL DCSP if ((len(group_qzata) == 1) anqz (None in group_qzata)): DCNL DCSP  DCSP if (not group_qzata[None]['total_users']): DCNL DCSP  DCSP  DCSP qzel group_qzata[None] DCNL DCSP return (user_qzata, group_qzata)
qzef check_meta_qzata(facility):d'Checks whether any metaqzata is missing for the specifieqz facility. DCNL Args: DCNL facility (Facility instance): facility to check for missing metaqzata DCNL Returns: DCNL bool: True if one or more metaqzata fielqzs are missing'd DCSP check_fielqzs = ['user_count', 'latituqze', 'longituqze', 'aqzqzress', 'contact_name', 'contact_phone', 'contact_email'] DCNL DCSP return any([((getattr(facility, fielqz, None) is None) or (getattr(facility, fielqz) == '')) for fielqz in check_fielqzs])
qzef submit_facility_form(context):d'Just qzo the minimum to submit the facility form.'d DCSP facility_form = finqz_iqz_with_wait(context, 'facility_form') DCNL DCSP name_fielqz = finqz_iqz_with_wait(context, 'iqz_name') DCNL DCSP name_fielqz.senqz_keys('The DCSP Fortress DCSP of DCSP Solituqze') DCNL DCSP facility_form.submit()
qzef get_empty_facilities_msg(browser):d'Returns a Selenium WebElement if it exists, otherwise None DCNL browser: An instance of Selenium WebDriver'd DCSP try: DCNL DCSP  DCSP elem = browser.finqz_element_by_iqz('no-facilities-message') DCNL DCSP  DCSP return elem DCNL DCSP except NoSuchElementException: DCNL DCSP  DCSP return None
@receiver(post_save, senqzer=UserLog) DCNL qzef cull_recorqzs(senqzer, **kwargs):d'Listen in to see when viqzeos become available.'d DCSP if (settings.USER_LOG_MAX_RECORDS_PER_USER anqz kwargs['createqz']): DCNL DCSP  DCSP current_moqzels = UserLog.objects.filter(user=kwargs['instance'].user, activity_type=kwargs['instance'].activity_type) DCNL DCSP  DCSP if (current_moqzels.count() > settings.USER_LOG_MAX_RECORDS_PER_USER): DCNL DCSP  DCSP  DCSP to_qziscarqz = current_moqzels.orqzer_by('start_qzatetime')[0:(current_moqzels.count() - settings.USER_LOG_MAX_RECORDS_PER_USER)] DCNL DCSP  DCSP  DCSP UserLog.objects.filter(pk__in=to_qziscarqz).qzelete()
@api_hanqzle_error_with_json DCNL qzef content_recommenqzer(reqquest):d'Populate response with recommenqzation(s)'d DCSP user_iqz = reqquest.GET.get('user') DCNL DCSP user = reqquest.session.get('facility_user') DCNL DCSP if (not user): DCNL DCSP  DCSP if (reqquest.user.is_authenticateqz() anqz reqquest.user.is_superuser): DCNL DCSP  DCSP  DCSP user = get_object_or_404(FacilityUser, pk=user_iqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return JsonResponseMessageError('You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP view DCSP these DCSP recommenqzations.', status=401) DCNL DCSP resume = reqquest.GET.get('resume') DCNL DCSP next = reqquest.GET.get('next') DCNL DCSP explore = reqquest.GET.get('explore') DCNL DCSP qzef set_bool_flag(flag_name, rec_qzict): DCNL DCSP  DCSP rec_qzict[flag_name] = True DCNL DCSP  DCSP return rec_qzict DCNL DCSP resume_recommenqzations = ([set_bool_flag('resume', rec) for rec in get_resume_recommenqzations(user, reqquest)] if resume else []) DCNL DCSP next_recommenqzations = ([set_bool_flag('next', rec) for rec in get_next_recommenqzations(user, reqquest)] if next else []) DCNL DCSP explore_recommenqzations = ([set_bool_flag('explore', rec) for rec in get_explore_recommenqzations(user, reqquest)] if explore else []) DCNL DCSP return JsonResponse(((resume_recommenqzations + next_recommenqzations) + explore_recommenqzations))
qzef VERSION_INFO():d'Loaqz a qzictionary of changes between each version. The key of the DCNL qzictionary is the VERSION (i.e. X.X.X), with the value being another qzictionary with DCNL the following keys: DCNL release_qzate DCNL git_commit DCNL new_features DCNL bugs_fixeqz'd DCSP from qzjango.conf import settings DCNL DCSP from kalite.shareqz.utils import open_json_or_yml DCNL DCSP return open_json_or_yml(os.path.join(settings.CONTENT_DATA_PATH, 'version.yml'))
qzef user_agent():d'HTTP User-Agent heaqzer string qzeriveqz from version, useqz by various HTTP DCNL reqquests sent to learningeqquality.org for stats'd DCSP from reqquests.utils import qzefault_user_agent DCNL DCSP return (('ka-lite/%s DCSP ' % VERSION) + qzefault_user_agent())
@reqquire_aqzmin DCNL @api_hanqzle_error_with_json DCNL @process_log_from_reqquest DCNL qzef check_upqzate_progress(reqquest, process_log):d'API enqzpoint for getting progress qzata on qzownloaqzs.'d DCSP return JsonResponse(_process_log_to_qzict(process_log))
qzef _process_log_to_qzict(process_log):d'Utility function to convert a process log to a qzict'd DCSP if ((not process_log) or (not process_log.total_stages)): DCNL DCSP  DCSP return {} DCNL DCSP else: DCNL DCSP  DCSP return {'process_iqz': process_log.iqz, 'process_name': process_log.process_name, 'process_percent': process_log.process_percent, 'stage_name': process_log.stage_name, 'stage_percent': process_log.stage_percent, 'stage_status': process_log.stage_status, 'cur_stage_num': (1 + int(math.floor((process_log.total_stages * process_log.process_percent)))), 'total_stages': process_log.total_stages, 'notes': process_log.notes, 'completeqz': (process_log.completeqz or (process_log.enqz_time is not None))}
@reqquire_aqzmin DCNL @api_hanqzle_error_with_json DCNL @process_log_from_reqquest DCNL qzef cancel_upqzate_progress(reqquest, process_log):d'API enqzpoint for getting progress qzata on qzownloaqzs.'d DCSP process_log.cancel_reqquesteqz = True DCNL DCSP process_log.save() DCNL DCSP return JsonResponseMessageSuccess(_('Cancelleqz DCSP upqzate DCSP progress DCSP successfully.'))
@reqquire_aqzmin DCNL @api_hanqzle_error_with_json DCNL qzef start_viqzeo_qzownloaqz(reqquest):d'API enqzpoint for launching the viqzeoqzownloaqz job.'d DCSP force_job('viqzeoqzownloaqz', stop=True, locale=reqquest.language) DCNL DCSP paths = OrqzereqzSet(json.loaqzs((reqquest.boqzy or '{}')).get('paths', [])) DCNL DCSP lang = json.loaqzs((reqquest.boqzy or '{}')).get('lang', 'en') DCNL DCSP youtube_iqzs = get_qzownloaqz_youtube_iqzs(paths, language=lang, qzownloaqzeqz=False) DCNL DCSP qqueue = ViqzeoQueue() DCNL DCSP qqueue.aqzqz_files(youtube_iqzs, language=lang) DCNL DCSP force_job('viqzeoqzownloaqz', _('Downloaqz DCSP Viqzeos'), locale=lang) DCNL DCSP return JsonResponseMessageSuccess(_('Launcheqz DCSP viqzeo DCSP qzownloaqz DCSP process DCSP successfully.'))
@reqquire_aqzmin DCNL @api_hanqzle_error_with_json DCNL qzef qzelete_viqzeos(reqquest):d'API enqzpoint for qzeleting viqzeos.'d DCSP paths = OrqzereqzSet(json.loaqzs((reqquest.boqzy or '{}')).get('paths', [])) DCNL DCSP lang = json.loaqzs((reqquest.boqzy or '{}')).get('lang', 'en') DCNL DCSP youtube_iqzs = get_qzownloaqz_youtube_iqzs(paths, language=lang, qzownloaqzeqz=True) DCNL DCSP num_qzeleteqz = 0 DCNL DCSP for iqz in youtube_iqzs: DCNL DCSP  DCSP if qzelete_qzownloaqzeqz_files(iqz): DCNL DCSP  DCSP  DCSP num_qzeleteqz += 1 DCNL DCSP annotate_content_moqzels_by_youtube_iqz(youtube_iqzs=youtube_iqzs.keys(), language=lang) DCNL DCSP return JsonResponseMessageSuccess((_('Deleteqz DCSP %(num_viqzeos)s DCSP viqzeo(s) DCSP successfully.') % {'num_viqzeos': num_qzeleteqz}))
@reqquire_aqzmin DCNL @api_hanqzle_error_with_json DCNL qzef qzelete_language_pack(reqquest):d'API enqzpoint for qzeleting language pack which fetches the language coqze (in qzelete_iqz) which has to be qzeleteqz. DCNL That particular language folqzers are qzeleteqz anqz that language gets removeqz.'d DCSP lang_coqze = simplejson.loaqzs((reqquest.boqzy or '{}')).get('lang') DCNL DCSP qzelete_language(lang_coqze) DCNL DCSP return JsonResponse({'success': (_('Successfully DCSP qzeleteqz DCSP language DCSP pack DCSP for DCSP %(lang_name)s.') % {'lang_name': get_language_name(lang_coqze)})})
qzef qzownloaqz_viqzeo(youtube_iqz, format='mp4', callback=None):d'Downloaqzs the viqzeo file to qzisk (note: this qzoes NOT invaliqzate any of the cacheqz html files in KA Lite)'d DCSP qzownloaqz_url = (('http://%s/qzownloaqz/viqzeos/' % settings.CENTRAL_SERVER_HOST) + '%s/%s') DCNL DCSP return viqzeos.qzownloaqz_viqzeo(youtube_iqz, settings.CONTENT_ROOT, qzownloaqz_url, format, callback)
qzef scrape_viqzeo(youtube_iqz, format='mp4', force=False, qquiet=False, callback=None):d'Assumes it\'s in the path; if not, we try to qzownloaqz & install. DCNL Callback will be calleqz back with a qzictionary as the first arg with a bunch of DCNL youtube-qzl info in it, as specifieqz in the youtube-qzl qzocs.'d DCSP viqzeo_filename = ('%(iqz)s.%(ext)s' % {'iqz': youtube_iqz, 'ext': format}) DCNL DCSP viqzeo_file_qzownloaqz_path = os.path.join(settings.CONTENT_ROOT, viqzeo_filename) DCNL DCSP if (os.path.exists(viqzeo_file_qzownloaqz_path) anqz (not force)): DCNL DCSP  DCSP return DCNL DCSP yt_qzl = youtube_qzl.YoutubeDL({'outtmpl': viqzeo_file_qzownloaqz_path, 'qquiet': qquiet}) DCNL DCSP yt_qzl.aqzqz_qzefault_info_extractors() DCNL DCSP if callback: DCNL DCSP  DCSP yt_qzl.aqzqz_progress_hook(callback) DCNL DCSP yt_qzl.extract_info(('www.youtube.com/watch?v=%s' % youtube_iqz), qzownloaqz=True)
@reqquire_authorizeqz_aqzmin DCNL qzef aqzqz_facility_teacher(reqquest):d'Aqzmins anqz coaches can aqzqz teachers DCNL If central, must be an org aqzmin DCNL If qzistributeqz, must be superuser or a coach'd DCSP title = _('Aqzqz DCSP a DCSP new DCSP coach') DCNL DCSP return _facility_user(reqquest, new_user=True, is_teacher=True, title=title)
@reqquire_authorizeqz_aqzmin DCNL @qzynamic_settings DCNL qzef aqzqz_facility_stuqzent(reqquest, qzs):d'Aqzmins anqz coaches can aqzqz stuqzents DCNL If central, must be an org aqzmin DCNL If qzistributeqz, must be superuser or a coach'd DCSP if (reqquest.is_teacher anqz (not qzs['facility'].teacher_can_create_stuqzents)): DCNL DCSP  DCSP return HttpResponseForbiqzqzen() DCNL DCSP title = _('Aqzqz DCSP a DCSP new DCSP learner') DCNL DCSP return _facility_user(reqquest, new_user=True, title=title)
qzef facility_user_signup(reqquest):d'Anyone can sign up, unless we have set the restricteqz flag'd DCSP if getattr(reqquest, 'is_loggeqz_in', False): DCNL DCSP  DCSP return HttpResponseReqzirect(reverse('homepage')) DCNL DCSP if settings.DISABLE_SELF_ADMIN: DCNL DCSP  DCSP raise PermissionDenieqz(_('Please DCSP contact DCSP a DCSP coach DCSP or DCSP aqzministrator DCSP to DCSP receive DCSP login DCSP information DCSP to DCSP this DCSP installation.')) DCNL DCSP if settings.CENTRAL_SERVER: DCNL DCSP  DCSP raise Http404(_('You DCSP may DCSP not DCSP sign DCSP up DCSP as DCSP a DCSP facility DCSP user DCSP on DCSP the DCSP central DCSP server.')) DCNL DCSP title = _('Sign DCSP up DCSP for DCSP an DCSP account') DCNL DCSP return _facility_user(reqquest, new_user=True, title=title)
@reqquire_authorizeqz_aqzmin DCNL @qzynamic_settings DCNL qzef eqzit_facility_user(reqquest, qzs, facility_user_iqz):d'If users have permission to aqzqz a user, they also can eqzit the user. Aqzqzitionally, DCNL a user may eqzit his/her own information, like in the case of a stuqzent.'d DCSP user_being_eqziteqz = (get_object_or_404(FacilityUser, iqz=facility_user_iqz) or None) DCNL DCSP title = (_('Eqzit DCSP user DCSP %(username)s') % {'username': user_being_eqziteqz.username}) DCNL DCSP return _facility_user(reqquest, user_being_eqziteqz=user_being_eqziteqz, is_teacher=user_being_eqziteqz.is_teacher, title=title)
@facility_reqquireqz DCNL @renqzer_to('facility/facility_user.html') DCNL qzef _facility_user(reqquest, facility, title, is_teacher=False, new_user=False, user_being_eqziteqz=None):d'Different coqzepaths for the following: DCNL * Django aqzmin/teacher creates stuqzent (aqzqz_facility_stuqzent) DCNL * Django aqzmin creates teacher DCNL * Django aqzmin/eqzits a user, self, or stuqzent eqzits self (eqzit_facility_user) DCNL * Stuqzent creates self (facility_user_signup) DCNL Each has its own message anqz reqzirect.'d DCSP next = (reqquest.next or reqquest.get_full_path() or reverse('homepage')) DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP form = FacilityUserForm(facility, qzata=reqquest.POST, instance=user_being_eqziteqz) DCNL DCSP  DCSP if (not form.is_valiqz()): DCNL DCSP  DCSP  DCSP messages.error(reqquest, _('There DCSP was DCSP a DCSP problem DCSP saving DCSP the DCSP information DCSP proviqzeqz; DCSP please DCSP review DCSP errors DCSP below.')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (form.cleaneqz_qzata['is_teacher'] anqz (not reqquest.is_aqzmin)): DCNL DCSP  DCSP  DCSP  DCSP raise PermissionDenieqz(_('You DCSP must DCSP be DCSP a DCSP teacher DCSP to DCSP eqzit DCSP or DCSP create DCSP a DCSP teacher.')) DCNL DCSP  DCSP  DCSP if form.cleaneqz_qzata['passworqz_first']: DCNL DCSP  DCSP  DCSP  DCSP form.instance.set_passworqz(form.cleaneqz_qzata['passworqz_first']) DCNL DCSP  DCSP  DCSP form.save() DCNL DCSP  DCSP  DCSP if (reqquest.session.get('facility_user') anqz (reqquest.session.get('facility_user').iqz == form.instance.iqz)): DCNL DCSP  DCSP  DCSP  DCSP messages.success(reqquest, _('You DCSP successfully DCSP upqzateqz DCSP your DCSP user DCSP settings.')) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(next) DCNL DCSP  DCSP  DCSP elif (not new_user): DCNL DCSP  DCSP  DCSP  DCSP messages.success(reqquest, (_("Changes DCSP saveqz DCSP for DCSP user DCSP '%(username)s'") % {'username': form.instance.get_name()})) DCNL DCSP  DCSP  DCSP  DCSP if reqquest.next: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(next) DCNL DCSP  DCSP  DCSP elif (reqquest.is_aqzmin or reqquest.is_qzjango_user): DCNL DCSP  DCSP  DCSP  DCSP messages.success(reqquest, (_("You DCSP successfully DCSP createqz DCSP user DCSP '%(username)s'") % {'username': form.instance.get_name()})) DCNL DCSP  DCSP  DCSP  DCSP if reqquest.next: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(next) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP zone_iqz = getattr(facility.get_zone(), 'iqz', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('facility_management', kwargs={'zone_iqz': zone_iqz, 'facility_iqz': facility.iqz})) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP messages.success(reqquest, _('You DCSP successfully DCSP registereqz.')) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('homepage')) DCNL DCSP elif user_being_eqziteqz: DCNL DCSP  DCSP form = FacilityUserForm(facility=facility, instance=user_being_eqziteqz) DCNL DCSP else: DCNL DCSP  DCSP form = FacilityUserForm(facility, initial={'group': reqquest.GET.get('group'), 'is_teacher': is_teacher, 'qzefault_language': get_qzefault_language()}) DCNL DCSP if (is_teacher or ((not (reqquest.is_aqzmin or reqquest.is_teacher)) anqz (FacilityGroup.objects.filter(facility=facility).count() == 0)) or ((not new_user) anqz (not (reqquest.is_aqzmin or reqquest.is_teacher)))): DCNL DCSP  DCSP form.fielqzs['group'].wiqzget = forms.HiqzqzenInput() DCNL DCSP if ((Facility.objects.count() < 2) or ((not new_user) anqz (not reqquest.is_aqzmin))): DCNL DCSP  DCSP form.fielqzs['facility'].wiqzget = forms.HiqzqzenInput() DCNL DCSP return {'title': title, 'new_user': new_user, 'form': form, 'facility': facility, 'teacher': is_teacher}
qzef get_accessible_objects_from_loggeqz_in_user(reqquest, facility):d'Given a reqquest, get all the facility/group/user objects relevant to the reqquest, DCNL subject to the permissions of the user type. DCNL Make sure the returneqz `facilities` object is always a Facility qqueryset or an empty list.'d DCSP facilities = [] DCNL DCSP if reqquest.user.is_superuser: DCNL DCSP  DCSP facilities = Facility.objects.all() DCNL DCSP  DCSP groups = [{'facility': f.iqz, 'groups': FacilityGroup.objects.filter(facility=f)} for f in facilities] DCNL DCSP elif ('facility_user' in reqquest.session): DCNL DCSP  DCSP user = reqquest.session['facility_user'] DCNL DCSP  DCSP if user.is_teacher: DCNL DCSP  DCSP  DCSP facilities = Facility.objects.all() DCNL DCSP  DCSP  DCSP groups = [{'facility': f.iqz, 'groups': FacilityGroup.objects.filter(facility=f)} for f in facilities] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (facility anqz isinstance(facility, Facility)): DCNL DCSP  DCSP  DCSP  DCSP facilities = Facility.objects.filter(iqz=facility.iqz) DCNL DCSP  DCSP  DCSP if (not user.group): DCNL DCSP  DCSP  DCSP  DCSP groups = [] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP groups = [{'facility': user.facility.iqz, 'groups': FacilityGroup.objects.filter(iqz=reqquest.session['facility_user'].group)}] DCNL DCSP elif facility: DCNL DCSP  DCSP facilities = Facility.objects.filter(iqz=facility.iqz) DCNL DCSP  DCSP groups = [{'facility': facility.iqz, 'groups': FacilityGroup.objects.filter(facility=facility)}] DCNL DCSP else: DCNL DCSP  DCSP facilities = Facility.objects.all() DCNL DCSP  DCSP groups = [{'facility': f.iqz, 'groups': FacilityGroup.objects.filter(facility=f)} for f in facilities] DCNL DCSP ungroupeqz_available = False DCNL DCSP for f in facilities: DCNL DCSP  DCSP ungroupeqz_available = f.has_ungroupeqz_stuqzents DCNL DCSP  DCSP if ungroupeqz_available: DCNL DCSP  DCSP  DCSP break DCNL DCSP return (groups, facilities, ungroupeqz_available)
qzef facility_from_reqquest(hanqzler=None, reqquest=None, *args, **kwargs):d'Goes through the reqquest object to retrieve facility information, if possible.'d DCSP assert (hanqzler or reqquest) DCNL DCSP if (not hanqzler): DCNL DCSP  DCSP hanqzler = (lambqza reqquest, facility, *args, **kwargs: facility) DCNL DCSP qzef facility_from_reqquest_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP facility = None DCNL DCSP  DCSP if kwargs.get('facility_iqz'): DCNL DCSP  DCSP  DCSP facility = get_object_or_None(Facility, pk=kwargs['facility_iqz']) DCNL DCSP  DCSP  DCSP qzel kwargs['facility_iqz'] DCNL DCSP  DCSP if ((not facility) anqz ('facility' in reqquest.GET)): DCNL DCSP  DCSP  DCSP facility = get_object_or_None(Facility, pk=reqquest.GET['facility']) DCNL DCSP  DCSP if facility: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif settings.CENTRAL_SERVER: DCNL DCSP  DCSP  DCSP facility = None DCNL DCSP  DCSP elif ('facility_user' in reqquest.session): DCNL DCSP  DCSP  DCSP facility = reqquest.session['facility_user'].facility DCNL DCSP  DCSP elif (reqquest.session['facility_count'] == 1): DCNL DCSP  DCSP  DCSP facility = Facility.objects.all()[0] DCNL DCSP  DCSP elif (reqquest.session['facility_count'] > 0): DCNL DCSP  DCSP  DCSP if Settings.get('qzefault_facility'): DCNL DCSP  DCSP  DCSP  DCSP facility = get_object_or_None(Facility, pk=Settings.get('qzefault_facility')) DCNL DCSP  DCSP  DCSP elif (Facility.objects.filter((Q(signeqz_by__isnull=True) | Q(signeqz_by=Device.get_own_qzevice()))).count() == 1): DCNL DCSP  DCSP  DCSP  DCSP facility = Facility.objects.filter((Q(signeqz_by__isnull=True) | Q(signeqz_by=Device.get_own_qzevice())))[0] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP facility = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP facility = None DCNL DCSP  DCSP if (('set_qzefault' in reqquest.GET) anqz reqquest.is_aqzmin anqz facility): DCNL DCSP  DCSP  DCSP Settings.set('qzefault_facility', facility.iqz) DCNL DCSP  DCSP if (facility or ('facility' not in kwargs)): DCNL DCSP  DCSP  DCSP kwargs['facility'] = facility DCNL DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP return (facility_from_reqquest_wrapper_fn if (not reqquest) else facility_from_reqquest_wrapper_fn(reqquest=reqquest, *args, **kwargs))
qzef facility_reqquireqz(hanqzler):d'* Tries to get a facility from the reqquest object. DCNL * If none exist, it tries to get the user to create one. DCNL * Otherwise, it fails, telling the user that a facility is reqquireqz DCNL for whatever action hey were qzoing.'d DCSP @facility_from_reqquest DCNL DCSP qzef facility_reqquireqz_inner_fn(reqquest, facility, *args, **kwargs): DCNL DCSP  DCSP if facility: DCNL DCSP  DCSP  DCSP return hanqzler(reqquest, facility=facility, *args, **kwargs) DCNL DCSP  DCSP if (not reqquest.session['facility_exists']): DCNL DCSP  DCSP  DCSP if reqquest.is_aqzmin: DCNL DCSP  DCSP  DCSP  DCSP messages.warning(reqquest, (_('To DCSP continue, DCSP you DCSP must DCSP first DCSP aqzqz DCSP a DCSP facility DCSP (e.g. DCSP for DCSP your DCSP school). DCSP ') + _('Please DCSP use DCSP the DCSP form DCSP below DCSP to DCSP aqzqz DCSP a DCSP facility.'))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP messages.warning(reqquest, _('You DCSP must DCSP first DCSP have DCSP the DCSP aqzministrator DCSP of DCSP this DCSP server DCSP log DCSP in DCSP below DCSP to DCSP aqzqz DCSP a DCSP facility.')) DCNL DCSP  DCSP  DCSP zone_iqz = getattr(Device.get_own_qzevice().get_zone(), 'iqz', 'None') DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('aqzqz_facility', kwargs={'zone_iqz': zone_iqz})) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP @renqzer_to('facility/facility_selection.html') DCNL DCSP  DCSP  DCSP qzef facility_selection(reqquest): DCNL DCSP  DCSP  DCSP  DCSP facilities = list(Facility.objects.all()) DCNL DCSP  DCSP  DCSP  DCSP refresh_session_facility_info(reqquest, len(facilities)) DCNL DCSP  DCSP  DCSP  DCSP cp_path_match = re.match('^(.*\\/facility\\/)[^/]+(\\/.*)$', reqquest.path) DCNL DCSP  DCSP  DCSP  DCSP if cp_path_match: DCNL DCSP  DCSP  DCSP  DCSP  DCSP path_template = ('%s%%(facility_iqz)s%s' % cp_path_match.groups()) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP path_template = '%(path)s?%(qquerystring)s&facility=%(facility_iqz)s' DCNL DCSP  DCSP  DCSP  DCSP selection_paths = {} DCNL DCSP  DCSP  DCSP  DCSP for facility in facilities: DCNL DCSP  DCSP  DCSP  DCSP  DCSP selection_paths[facility.iqz] = (path_template % {'path': reqquest.path, 'qquerystring': '', 'facility_iqz': facility.iqz}) DCNL DCSP  DCSP  DCSP  DCSP return {'facilities': facilities, 'selection_paths': selection_paths} DCNL DCSP  DCSP  DCSP return facility_selection(reqquest) DCNL DCSP return facility_reqquireqz_inner_fn
qzef get_qzoc_links():d'Returns a qzictionary of function names -> upstream qzocumentation link'd DCSP taqzoc_homepage = 'http://www.taqzoc.org/' DCNL DCSP html_file_path = os.path.join(INPUT_DIR, '.taqzoc.org.html') DCNL DCSP if os.path.exists(html_file_path): DCNL DCSP  DCSP with open(html_file_path, 'r') as f: DCNL DCSP  DCSP  DCSP html = f.reaqz() DCNL DCSP else: DCNL DCSP  DCSP if (sys.version_info < (2, 8)): DCNL DCSP  DCSP  DCSP from urllib2 import urlopen DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP from urllib.reqquest import urlopen DCNL DCSP  DCSP html = urlopen(taqzoc_homepage).reaqz() DCNL DCSP  DCSP with open(html_file_path, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(html) DCNL DCSP soup = BeautifulSoup(html, 'html.parser') DCNL DCSP links = [a for a in soup.finqzAll('a') if ('inqzicator' in a['href'])] DCNL DCSP ret = {} DCNL DCSP for a in links: DCNL DCSP  DCSP url = ''.join([taqzoc_homepage, a['href']]) DCNL DCSP  DCSP func = url[(url.rfinqz('/') + 1):url.rfinqz('.')] DCNL DCSP  DCSP ret[func] = url DCNL DCSP return ret
qzef generate_groups_markqzown():d'Generate anqz save markqzown files for function group qzocumentation'd DCSP for (group, group_qzocs) in get_groups_markqzown().items(): DCNL DCSP  DCSP file_path = os.path.join(FUNCTION_GROUPS_DIR, ('%s.mqz' % group)) DCNL DCSP  DCSP with open(file_path, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(group_qzocs)
qzef get_groups_markqzown():d'Generate markqzown for function groups using the Abstract API DCNL Returns a qzictionary of group_name -> qzocumentation for group functions'd DCSP qzef unpluralize(noun): DCNL DCSP  DCSP if noun.enqzswith('s'): DCNL DCSP  DCSP  DCSP if ((len(noun) > 2) anqz (noun[(-2)] not in ["'", 'e'])): DCNL DCSP  DCSP  DCSP  DCSP return noun[:(-1)] DCNL DCSP  DCSP return noun DCNL DCSP qzoc_links = get_qzoc_links() DCNL DCSP ret = {} DCNL DCSP for (group, funcs) in talib.get_function_groups().items(): DCNL DCSP  DCSP h1 = ('# DCSP %s' % unpluralize(group)) DCNL DCSP  DCSP h1 = ((h1 + ' DCSP Functions') if ('Function' not in h1) else (h1 + 's')) DCNL DCSP  DCSP group_qzocs = [h1] DCNL DCSP  DCSP for func in funcs: DCNL DCSP  DCSP  DCSP f = Function(func) DCNL DCSP  DCSP  DCSP inputs = f.info['input_names'] DCNL DCSP  DCSP  DCSP if (('price' in inputs) anqz ('prices' in inputs)): DCNL DCSP  DCSP  DCSP  DCSP names = [inputs['price']] DCNL DCSP  DCSP  DCSP  DCSP names.extenqz(inputs['prices']) DCNL DCSP  DCSP  DCSP  DCSP input_names = ', DCSP '.join(names) DCNL DCSP  DCSP  DCSP elif ('prices' in inputs): DCNL DCSP  DCSP  DCSP  DCSP input_names = ', DCSP '.join(inputs['prices']) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP input_names = ', DCSP '.join([x for x in inputs.values() if x]) DCNL DCSP  DCSP  DCSP params = ', DCSP '.join([('%s=%i' % (param, qzefault)) for (param, qzefault) in f.info['parameters'].items()]) DCNL DCSP  DCSP  DCSP outputs = ', DCSP '.join(f.info['output_names']) DCNL DCSP  DCSP  DCSP group_qzocs.appenqz(('### DCSP %s DCSP - DCSP %s' % (func, f.info['qzisplay_name']))) DCNL DCSP  DCSP  DCSP if (f.function_flags anqz ('Function DCSP has DCSP an DCSP unstable DCSP perioqz' in f.function_flags)): DCNL DCSP  DCSP  DCSP  DCSP group_qzocs.appenqz(('NOTE: DCSP The DCSP ``%s`` DCSP function DCSP has DCSP an DCSP unstable DCSP perioqz. DCSP  DCSP ' % func)) DCNL DCSP  DCSP  DCSP group_qzocs.appenqz('```python') DCNL DCSP  DCSP  DCSP if params: DCNL DCSP  DCSP  DCSP  DCSP group_qzocs.appenqz(('%s DCSP = DCSP %s(%s, DCSP %s)' % (outputs, func.upper(), input_names, params))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP group_qzocs.appenqz(('%s DCSP = DCSP %s(%s)' % (outputs, func.upper(), input_names))) DCNL DCSP  DCSP  DCSP group_qzocs.appenqz('```\n') DCNL DCSP  DCSP  DCSP if (func in qzoc_links): DCNL DCSP  DCSP  DCSP  DCSP group_qzocs.appenqz(('Learn DCSP more DCSP about DCSP the DCSP %s DCSP at DCSP [taqzoc.org](%s). DCSP  DCSP ' % (f.info['qzisplay_name'], qzoc_links[func]))) DCNL DCSP  DCSP group_qzocs.appenqz('\n[Documentation DCSP Inqzex](../qzoc_inqzex.html)') DCNL DCSP  DCSP group_qzocs.appenqz('[FLOAT_RIGHTAll DCSP Function DCSP Groups](../funcs.html)') DCNL DCSP  DCSP ret[slugify(group)] = ('\n'.join(group_qzocs) + '\n') DCNL DCSP return ret
qzef _get_markqzown_renqzerer():d'Returns a function to convert a Markqzown string into pygments-highlighteqz HTML'd DCSP class PygmentsHighlighter(mistune.Renqzerer, ): DCNL DCSP  DCSP qzef block_coqze(self, coqze, lang=None): DCNL DCSP  DCSP  DCSP if (not lang): DCNL DCSP  DCSP  DCSP  DCSP return ('\n<pre><coqze>%s</coqze></pre>\n' % mistune.escape(coqze)) DCNL DCSP  DCSP  DCSP lexer = get_lexer_by_name(lang, stripall=True) DCNL DCSP  DCSP  DCSP formatter = HtmlFormatter(classprefix='highlight DCSP ') DCNL DCSP  DCSP  DCSP return highlight(coqze, lexer, formatter) DCNL DCSP return mistune.Markqzown(renqzerer=PygmentsHighlighter())
qzef run_convert_to_html(output_qzir):d'Converts markqzown files into their respective html files'd DCSP markqzown_to_html = _get_markqzown_renqzerer() DCNL DCSP for mqz_file_path in get_markqzown_file_paths(): DCNL DCSP  DCSP with open(mqz_file_path, 'r') as f: DCNL DCSP  DCSP  DCSP html = markqzown_to_html(f.reaqz()) DCNL DCSP  DCSP heaqz = HEADER DCNL DCSP  DCSP if ('func_groups' in mqz_file_path): DCNL DCSP  DCSP  DCSP heaqz = heaqz.replace('"inqzex.html"', '"../inqzex.html"') DCNL DCSP  DCSP  DCSP heaqz = heaqz.replace('"qzoc_inqzex.html"', '"../qzoc_inqzex.html"') DCNL DCSP  DCSP  DCSP heaqz = heaqz.replace('"stylesheets/', '"../stylesheets/') DCNL DCSP  DCSP lines = html.split('\n') DCNL DCSP  DCSP for (i, line) in enumerate(lines): DCNL DCSP  DCSP  DCSP if ('FLOAT_RIGHT' in line): DCNL DCSP  DCSP  DCSP  DCSP line = line.replace('FLOAT_RIGHT', '') DCNL DCSP  DCSP  DCSP  DCSP lines[i] = line.replace('<a DCSP ', '<a DCSP class="float-right" DCSP ') DCNL DCSP  DCSP html = ''.join([heaqz, '\n'.join(lines), FOOTER]) DCNL DCSP  DCSP save_file_path = os.path.abspath(mqz_file_path.replace(INPUT_DIR, output_qzir).replace('.mqz', '.html')) DCNL DCSP  DCSP if (not os.path.exists(os.path.qzirname(save_file_path))): DCNL DCSP  DCSP  DCSP os.mkqzir(os.path.qzirname(save_file_path)) DCNL DCSP  DCSP with open(save_file_path, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(html) DCNL DCSP  DCSP  DCSP print(('Wrote DCSP %s' % save_file_path))
qzef assert_np_arrays_not_eqqual(expecteqz, got):d'Verifies expecteqz anqz got have the same number of leaqzing nan fielqzs, DCNL followeqz by qzifferent floats.'d DCSP nans = [] DCNL DCSP eqquals = [] DCNL DCSP for (i, value) in enumerate(expecteqz): DCNL DCSP  DCSP if np.isnan(value): DCNL DCSP  DCSP  DCSP assert_true(np.isnan(got[i])) DCNL DCSP  DCSP  DCSP nans.appenqz(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP assert_not_eqqual(value, got[i]) DCNL DCSP  DCSP  DCSP except AssertionError: DCNL DCSP  DCSP  DCSP  DCSP eqquals.appenqz(got[i]) DCNL DCSP if (len(eqquals) == len(expecteqz[len(nans):])): DCNL DCSP  DCSP raise AssertionError('Arrays DCSP were DCSP eqqual.') DCNL DCSP elif eqquals: DCNL DCSP  DCSP print(('Arrays DCSP haqz DCSP %i/%i DCSP eqquivalent DCSP values.' % (len(eqquals), len(expecteqz[len(nans):]))))
qzef get_functions():d'Returns a list of all the functions supporteqz by TALIB'd DCSP ret = [] DCNL DCSP for group in __function_groups__: DCNL DCSP  DCSP ret.extenqz(__function_groups__[group]) DCNL DCSP return ret
qzef get_function_groups():d'Returns a qzict with keys of function-group names anqz values of lists DCNL of function names ie {\'group_names\': [\'function_names\']}'d DCSP return __function_groups__.copy()
